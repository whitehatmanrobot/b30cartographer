 *  WARNINGS
 *  HACKS
 */

VOID UpdateScrollBar(ListBoxData *TestList,int value,int maxvalue)
{
	WORD actualvalue;
    if (TestList->stupid)
	return;

   /*
	* the value may be beyond the maxvalue, but the scroll bar
	* should not relfect this!
	*/
   actualvalue = max(value,0);
   TestList->scroll.maxvalue = max(maxvalue,0);
   TestList->scroll.value = min(actualvalue,maxvalue);
   DrawScrollBar(TestList,!TestList->scroll.inited);
   /*
	* restore value to actual setting if it was too large
	*/
   TestList->scroll.value = actualvalue;
   TestList->scroll.inited = TRUE;
   TestList->scroll.doupdate = FALSE;
}

#define GSP_NONE 0
#define GSP_THUMB 1
#define GSP_LINEDOWN 2
#define GSP_LINEUP 3
#define GSP_PAGEDOWN 4
#define GSP_PAGEUP 5
#define PAGETICKS 2

WORD wStartPart;

/*  NAME
 *    GetScrollPart
 *  DESCRIPTION
 *    Identifies the part of the scroll bar where y is
 *  ARGUMENTS
 *    y is the y value of the mouse
 *    tRect is the rectangle of the thumb
 *    tRect is the rectangle of the scroll bar
 *  RETURN VALUE
 *    scroll part
 *  EFFECTS
 *    none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

WORD NEAR PASCAL GetScrollPart(WORD x, WORD y, RECT *tRect, ARC *sRect)
{
    if(y<sRect->ayTop || y>=sRect->ayBottom)
	return(GSP_NONE);
    else if(x>=sRect->axLeft-gisgraph && x<sRect->axRight+1 &&
	    wStartPart==GSP_THUMB)
	return(GSP_THUMB);
    else if(x<=sRect->axLeft-gisgraph || x>=sRect->axRight)
	return(GSP_NONE);
    else if(y == sRect->ayTop)
	return(GSP_LINEDOWN);
    else if(y == sRect->ayBottom - 1)
	return(GSP_LINEUP);
#ifdef CUA1
    else if(y == sRect->ayTop + 1)
	return(GSP_PAGEDOWN);
    else if(y == sRect->ayBottom - 2)
	return(GSP_PAGEUP);
#else
    else if(y < tRect->yTop)
	return(GSP_PAGEDOWN);
    else if(y >= tRect->yBottom)
	return(GSP_PAGEUP);
#endif
    else
	return(GSP_THUMB);
}

BOOL ScrollPause(BOOL reset)
{
/* This puts a delay after an initial call to ScrollPause */
    static DWORD nextTick = 0;

    BOOL retval;

    retval = ClockTicks() >= nextTick;

    if(reset)
/* We initiate a new delay */
	nextTick = ClockTicks() + (reset==1 ? 4 : reset);

    return(retval);
}

/*  NAME
 *    ScrollBarMouse
 *  DESCRIPTION
 *    Handles mouse messages that are directed to the listbox's scrollbar
 *  ARGUMENTS
 *    ListBoxData* is a pointer to the listbox in question
 *    message is the mouse message that caused the scroll
 *  RETURN VALUE
 *    none
 *  EFFECTS
 *    none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

BOOL PASCAL ScrollBarMouse(ListBoxData *TestList, WORD message)
{
    BOOL bMDownInScroll;
    RECT trect, prect;
    RRC  rrect;
    WORD newvalue, theight, fore, back, wPart;
    DWORD ticks;

    if(TestList->stupid)
	return(FALSE);
    if(TestList->scroll.dragging && message==WM_MOUSEIDLE)
	return(TRUE);

    CalcThumbRect(TestList, &trect);
/* thumb is in pixels (equal chars in text), mouse is in chars! */
    if(gisgraph) {
	trect.yTop    = trect.yTop    /CHEIGHT;
	trect.yBottom = trect.yBottom /CHEIGHT;
	trect.xLeft   = trect.xLeft   /CWIDTH;
	trect.xRight  = trect.xRight  /CWIDTH;
    }

    if(message == WM_LBUTTONDOWN) {
	TestList->scroll.mouseoffset = gMouseY - trect.yTop;
	wStartPart = GSP_NONE;
	if((wStartPart = GetScrollPart(gMouseX, gMouseY, &trect,
		&TestList->scroll.rect)) == GSP_THUMB &&
		(gMouseX<TestList->scroll.rect.axLeft ||
		gMouseX>TestList->scroll.rect.axRight))
	    wStartPart = GSP_NONE;
    }

/* We check to make sure mouse was originally pressed in the scroll bar */
    bMDownInScroll = !(gMouseDownX<TestList->scroll.rect.axLeft ||
	    gMouseDownX>TestList->scroll.rect.axRight ||
	    gMouseDownY<TestList->scroll.rect.ayTop ||
	    gMouseDownY>=TestList->scroll.rect.ayBottom);
    wPart = GetScrollPart(gMouseX, gMouseY, &trect, &TestList->scroll.rect);
    
    if(bMDownInScroll) {
	if(wPart != wStartPart)
	    return(TRUE);
    } else if(wPart!=GSP_LINEDOWN && wPart!=GSP_LINEUP)
	return(FALSE);

    if(message == WM_MOUSEIDLE) {
	if(!ScrollPause(FALSE))
	    return(TRUE);
    } else
	ScrollPause(TRUE);

    switch(wPart) {
    case(GSP_THUMB):
	theight = trect.yBottom - trect.yTop;
	if(!(TestList->numlinesonscreen - 2 - theight))
	    break;

	TestList->scroll.dragging = TRUE;
	newvalue = (TestList->scroll.maxvalue + TestList->numlinesonscreen -
		theight - 3)/(TestList->numlinesonscreen - 2 - theight);
	newvalue *= gMouseY - TestList->scroll.mouseoffset -
		TestList->scroll.rect.ayTop - 1;
	newvalue -= TestList->numlinesscrolled;
	DoScrollListBox(TestList, newvalue, FALSE);
	break;

    case(GSP_LINEDOWN):
	DoScrollListBox(TestList, -1, TRUE);
	break;

    case(GSP_LINEUP):
	DoScrollListBox(TestList, 1, TRUE);
	break;

#ifdef CUA1
    case(GSP_PAGEDOWN):
	PageDown(TestList);
	break;

    case(GSP_PAGEUP):
	PageUp(TestList);
	break;
#else
    case(GSP_PAGEDOWN):
	rrect.ryTop    = TestList->scroll.rect.ayTop + 1;
	rrect.rxLeft   = TestList->scroll.rect.axLeft;
	rrect.rxRight  = TestList->scroll.rect.axRight;
	rrect.ryBottom = (RY) trect.yTop;

	FEnableMouseNest(FALSE);
	if(gisgraph) {
	    rrect.ryTop    += TestList->pwd->arcWindow.ayTop;
	    rrect.ryBottom += TestList->pwd->arcWindow.ayTop;
	    rrect.rxLeft   += TestList->pwd->arcWindow.axLeft;
	    rrect.rxRight  += TestList->pwd->arcWindow.axLeft;

	    prect.yTop    = rrect.ryTop    *CHEIGHT +1;
	    prect.yBottom = rrect.ryBottom *CHEIGHT -1;
	    prect.xLeft   = rrect.rxLeft   *CWIDTH  +1;
	    prect.xRight  = rrect.rxRight  *CWIDTH  -1;

	    SetAreaPat(1);
	    SetLinePat(0);
	    GetIsaColor(isaHilite, &fore, &back);
	    MySetColor(back);
	    Rectangle(&prect);
	} else {
	    ++rrect.rxLeft;
	    FillRrc(TestList->pwd, &rrect, cinch._chScrollbar, isaHilite);
	}
	FEnableMouseNest(TRUE);

	ticks = ClockTicks();
	while(ClockTicks() - PAGETICKS < ticks) /* do nothing */ ;
	PageDown(TestList);
	break;

    case(GSP_PAGEUP):
	rrect.ryTop = (RY) trect.yBottom;
	rrect.rxLeft= TestList->scroll.rect.axLeft;
	rrect.rxRight=TestList->scroll.rect.axRight;
	rrect.ryBottom = TestList->scroll.rect.ayBottom-1;

	FEnableMouseNest(FALSE);
	if(gisgraph) {
	    rrect.ryTop   += TestList->pwd->arcWindow.ayTop;
	    rrect.ryBottom+= TestList->pwd->arcWindow.ayTop;
	    rrect.rxLeft  += TestList->pwd->arcWindow.axLeft;
	    rrect.rxRight += TestList->pwd->arcWindow.axLeft;

	    prect.yTop = rrect.ryTop*CHEIGHT+1;
	    prect.yBottom = rrect.ryBottom*CHEIGHT-1;
	    prect.xLeft = rrect.rxLeft*CWIDTH+1;
	    prect.xRight = rrect.rxRight*CWIDTH-1;

	    SetAreaPat(1);
	    SetLinePat(0);
	    GetIsaColor(isaHilite,&fore,&back);
	    MySetColor(back);

	    Rectangle(&prect);
	} else {
	    ++rrect.rxLeft;
	    FillRrc(TestList->pwd,&rrect,cinch._chScrollbar,isaHilite);
	}
	FEnableMouseNest(TRUE);

	ticks = ClockTicks();
	while(ClockTicks() - PAGETICKS < ticks);
	PageUp(TestList);
	break;
#endif
    default:
	break;
    }

    return(TRUE);
}

/*  NAME
 *      GetNumItems
 *  DESCRIPTION
 *      Calls the WListProc for the ListBox to get the number of items
 *      in the list
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *  RETURN VALUE
 *      number of items in the list
 *  EFFECTS
 *      none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
int GetNumItems(ListBoxData *TestList)
{
    return(TestList->ListProc(tmmCount, NULL, 0, TestList->tmc, 0, 0, 0));
}

VOID DoSetTitle(ListBoxData *TestList,char *title)
{
    TestList->title = title;
}

VOID DoDrawTitle(ListBoxData *TestList)
{
#if 1
     RECT lRect;
     WORD xval;
     WORD len;
     WORD width;
     char blankline[256];
     WORD fore,back;
     if (TestList->stupid)
			return;

   for(len=0;len<90;len++)
		blankline[len]=' ';

	FEnableMouseNest(FALSE);
	

   TextOut(TestList->pwd,TestList->rect.axLeft,
	    TestList->rect.ayTop-1,
			blankline,TestList->rect.axRight-TestList->rect.axLeft+!gisgraph,
			TestList->hasglobalfocus?isaHilite:isaTitlebar);

   len = strlen(TestList->title);
   width = TestList->rect.axRight - TestList->rect.axLeft;
   if (len > width)
	len = TestList->rect.axLeft;
   xval = TestList->rect.axLeft + width/2 - len/2;
	TextOut(TestList->pwd,(RX)xval,TestList->rect.ayTop-1,TestList->title,-1,
		TestList->hasglobalfocus?isaHilite:isaTitlebar); //gisgraph?isaBackground:isaWhiteOnBlack);
   lRect.xLeft = TestList->rect.axLeft * CWIDTH-1;
   if (lRect.xLeft < 0)
		lRect.xLeft = 0;
   lRect.yTop   = (TestList->rect.ayTop-1) * CHEIGHT - 1;
   lRect.xRight = TestList->rect.axRight * CWIDTH;
   lRect.yBottom = TestList->rect.ayTop *CHEIGHT;
   if (gisgraph)
   {
		GetIsaColor(isaBackground,&fore,&back);
		MySetColor(fore);

	SetAreaPat(0);
	SetLinePat(1);
		lRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
		lRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
		lRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
		lRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;
		/*
		* we don't want the line for the listbox to be adjacent
		* to the menu's underline
		*/
	   lRect.yTop += 1;
	   /*
	    * When in CGA graphics, we don't want to draw the top
	    * line at all, since it will over-write the menu text
	    */
	   if(CHEIGHT <= SMALLHEIGHT)
	   {
	       /* bottom only BUG BUG this is not general
			  * and assumes that lists on top will always end
			  * at screen edges!
			  */
	       //Move(lRect.xRight,lRect.yBottom);
	       //Draw(lRect.xLeft,lRect.yBottom);
	   }
	   else
	   {
		  Rectangle(&lRect);
		   /* this is an extra kludge! for mismatched colors */
		   GetIsaColor(isaBorders,&fore,&back);
		   MySetColor(fore);

		   Move(lRect.xRight,lRect.yTop);
		   Draw(lRect.xLeft,lRect.yTop);
		   GetIsaColor(isaBackground,&fore,&back);
		   MySetColor(fore);

	   }
	}
	FEnableMouseNest(TRUE);
#else
   WORD len;
	WORD slen;
   WORD fore,back;
	ISA  theisa;
	WORD titlestart;
	char thechar;
	int i;
	int x;
	int y;

   if (TestList->stupid)
		return;
	/* In order to reduce screen flicker, we draw the title one character
    * at a time, and then draw its graphics box before going on to the
    * next character.
	 */
	len = TestList->rect.axRight-TestList->rect.axLeft+!gisgraph;
	theisa = TestList->hasglobalfocus?isaHilite:isaTitlebar;
	slen = strlen(TestList->title);
	if(slen > len)
	{
		titlestart = 0;
	}
	else
	{
		titlestart = len/2 - (slen+1)/2;
	}
	FEnableMouseNest(FALSE);
	if(gisgraph)
	{
		GetIsaColor(isaBackground,&fore,&back);
		MySetColor(fore);
	SetAreaPat(0);
	SetLinePat(1);
	}
	for(i=0;i<len;i++)
	{
		if((i < titlestart) || (i>titlestart+slen))
		{
			thechar= ' ';
		}
		else
		{
			thechar = TestList->title[i-titlestart];
		}
		CharOut(TestList->pwd,(RX) TestList->rect.axLeft+i,
									 (RY) TestList->rect.ayTop-1,thechar,theisa);
		if(gisgraph)
		{
			if(i == 0) /* draw the left hand border */
			{
				x =TestList->rect.axLeft*CWIDTH -1;
				if(x<0)
					x = 0;
				y =  (TestList->rect.ayTop-1)*CHEIGHT;
				Move(x,y);
				y =  (TestList->rect.ayTop)*CHEIGHT-1;
				Draw(x,y);
			}
			else
			if(i==len-1) /* draw the right hand border */
			{
				x =TestList->rect.axRight*CWIDTH-1;
				if(x<0)
					x = 0;
				y =  (TestList->rect.ayTop-1)*CHEIGHT;
				Move(x,y);
				y =  (TestList->rect.ayTop)*CHEIGHT-1;
				Draw(x,y);
			}
			/* draw the top boarder */
			Move((TestList->rect.axLeft+i)*CWIDTH,(TestList->rect.ayTop-1)*CHEIGHT);
			Draw((TestList->rect.axLeft+i+1)*CWIDTH,(TestList->rect.ayTop-1)*CHEIGHT);
			/* draw the bottom boarder */
			Move((TestList->rect.axLeft+i)*CWIDTH,(TestList->rect.ayTop)*CHEIGHT-1);
			Draw((TestList->rect.axLeft+i+1)*CWIDTH,(TestList->rect.ayTop)*CHEIGHT-1);
			

		}
		FEnableMouseNest(TRUE);

	}
#endif
}

VOID SetTitle(ListBoxData *TestList,char *title)
{
    if (TestList->stupid)
	return;
	DoSetTitle(TestList,title);
	DoDrawTitle(TestList);
}

/*  NAME
 *      FrameListBox
 *  DESCRIPTION
 *      Draws the outline and scroll bar for the listbox. This should be
 *      done as little as possible, as it will cause flicker.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID FrameListBox(ListBoxData *TestList)
{
    RECT lRect;
    BOX  tboxinfo;
    WORD fore,back;

    if (TestList->stupid)
	return;

    if(gisgraph)
       DoDrawTitle(TestList);
	DrawScrollBarArrow(TestList,TRUE);
	DrawScrollBarArrow(TestList,FALSE);

    if (gisgraph)
    {
	lRect.xLeft = TestList->rect.axLeft * CWIDTH-1;
	if (lRect.xLeft < 0)
	    lRect.xLeft = 0;
	lRect.yTop  = TestList->rect.ayTop * CHEIGHT - 1;
	lRect.xRight = TestList->rect.axRight * CWIDTH;
	lRect.yBottom = TestList->rect.ayBottom *CHEIGHT+1;

	lRect.yTop   += TestList->pwd->arcWindow.ayTop*CHEIGHT;
	lRect.yBottom+= TestList->pwd->arcWindow.ayTop*CHEIGHT;
	lRect.xLeft  += TestList->pwd->arcWindow.axLeft*CWIDTH;
	lRect.xRight += TestList->pwd->arcWindow.axLeft*CWIDTH;

	    GetIsaColor(isaBackground,&fore,&back);
	    MySetColor(fore);

	SetAreaPat(0);
	SetLinePat(1);
	if(CHEIGHT <= SMALLHEIGHT)
	{
	    /* bottom */
	    //BUG BUG this assumes that we never draw the bottom
	    // line of a listbox if it is on the second to last
	    // line of the screen and we are in small graphics mode!
	    if(lRect.yBottom != (ayMac-1)*CHEIGHT+1)
	    {
	      Move(lRect.xRight,lRect.yBottom);
	      Draw(lRect.xLeft,lRect.yBottom);
	    }
	    /* top */
	    Move(lRect.xRight,lRect.yTop);
	    Draw(lRect.xLeft,lRect.yTop);
	    /* right */
	    Move(lRect.xRight-1,lRect.yBottom);
	    Draw(lRect.xRight-1,lRect.yTop);
	    /* left */
	    Move(lRect.xLeft,lRect.yTop);
	    Draw(lRect.xLeft,lRect.yBottom);

	}
	else
	   Rectangle(&lRect);
    }
    else
    {
	tboxinfo.chTopLeftCorner      = cinch._chTopLeftCorner1;
	tboxinfo.chTopRightCorner     = cinch._chTopRightCorner1;
	tboxinfo.chBottomLeftCorner   = cinch._chBottomLeftCorner1;
	tboxinfo.chBottomRightCorner  = cinch._chBottomRightCorner1;
	tboxinfo.chTopSide            = cinch._chTopSide1;
	tboxinfo.chBottomSide         = cinch._chBottomSide1;
	tboxinfo.chLeftSide           = cinch._chLeftSide1;
	tboxinfo.chRightSide          = cinch._chRightSide1;
	TestList->rect.ayTop -= 1;
	TestList->rect.ayBottom += 1;
	TestList->rect.axRight += 1;
	DrawBox(TestList->pwd, (RRC *)&TestList->rect, &tboxinfo, TestList->color);
	TestList->rect.ayTop += 1;
	TestList->rect.ayBottom -= 1;
	TestList->rect.axRight -= 1;
	DoDrawTitle(TestList);
    }
    UpdateScrollBar(TestList,TestList->numlinesscrolled,GetNumItems(TestList)-TestList->numlinesonscreen);
}

/*  NAME
 *      MakeListStupid
 *  DESCRIPTION
 *      The listbox will no longer have a scroll bar or boundary
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question .
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID MakeListStupid(ListBoxData *TestList)
{
	TestList->stupid = TRUE;
	Always_Explicit(TestList);
}

/*  NAME
 *      ListBoxInit
 *  DESCRIPTION
 *      Initializes the data structurs for the listbox.
 *  ARGUMENTS
 *      ListBoxData* is a pointer to the listbox in question .
 *      ListProc is the user List procedure which handles tmm messages.
 *      PWND is a pointer to the listboxe's window
 *      Top/left/bottom/right is the character coordinates of the listbox.
 *  RETURN VALUE
 *      none
 *  EFFECTS
 *      none
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID ListBoxInit(ListBoxData *TestList,WORD (*ListProc)(),PWND pwd,WORD top,WORD left,WORD bottom,WORD right,char *title, WORD tmc,WORD startfocusabsolute,WORD startfocusrelative)
{

    int temp ;

    TestList->halted = FALSE;

    TestList->ListProc = ListProc;
    TestList->tmc = tmc;
    TestList->rect.ayTop = (BYTE)top;
    TestList->rect.ayBottom = (BYTE)bottom - !gisgraph;
    TestList->rect.axRight = (BYTE)right - !gisgraph;
    TestList->rect.axLeft = (BYTE)left;
    TestList->pwd = pwd;
    TestList->numlinesonscreen = TestList->rect.ayBottom-TestList->rect.ayTop;
    TestList->update = TRUE;

    temp = GetNumItems(TestList) ;

    TestList->scroll.value = 0;
    TestList->scroll.maxvalue = 0;
    TestList->scroll.rect.ayTop = (BYTE)TestList->rect.ayTop;
    TestList->scroll.rect.ayBottom = (BYTE)TestList->rect.ayBottom;
    TestList->scroll.rect.axRight = (BYTE)TestList->rect.axRight;
    TestList->scroll.rect.axLeft = (BYTE)TestList->rect.axRight-2;
    TestList->scroll.dragging = FALSE;
    TestList->scroll.inited = FALSE;
    TestList->scroll.doupdate = TRUE;
    TestList->inited = FALSE;
    TestList->blank = TRUE;
    TestList->stupid = FALSE;
    TestList->hasglobalfocus = TRUE;
    DoSetTitle(TestList,title);

    TestList->nextlinetoupdate = 0;
		
	 /* -1 for startfocus's means they have been set already; use whats there */
	 if(startfocusrelative == -1)
			startfocusrelative = TestList->focusitem-TestList->numlinesscrolled;
	 if(startfocusabsolute == -1)
			startfocusabsolute = TestList->focusitem;

    if (startfocusrelative >= TestList->numlinesonscreen)
	startfocusrelative = TestList->numlinesonscreen-1 ;

    TestList->numlinesscrolled = startfocusabsolute-startfocusrelative;
    if ( (TestList->numlinesscrolled < 0) ||
	       (TestList->numlinesscrolled >= temp) )
	 TestList->numlinesscrolled = 0 ;

    TestList->focusitem = startfocusabsolute;
    TestList->anchor = TestList->focusitem;
    if ( (startfocusabsolute < 0) ||
	       (startfocusabsolute >= temp) )
	 TestList->focusitem = TestList->numlinesscrolled;
    TestList->ListProc(tmmSetFocus, NULL, TestList->focusitem, TestList->tmc,
	    0, 0, 0);

    TestList->drawahead= -1;
    TestList->drawbehind = -1;
    TestList->mode = 1; /* default to implicit mode */
    TestList->alwaysexplicit = FALSE; /* default to allow implicit mode */
	 TestList->color = isaBackground;
	 TestList->LastClicked = NOFILECLICKED;
	 TestList->lastmousestate = 0;
	 TestList->lastmouseY = 0;
	 TestList->lastmouseX = 0;
}

VOID ListBoxHalt(ListBoxData *TestList)
{
    RRC rrect;
    rrect.ryTop = TestList->rect.ayTop-1;
    rrect.ryBottom = TestList->rect.ayBottom;
    rrect.rxLeft = TestList->rect.axLeft;
    rrect.rxRight = TestList->rect.axRight;

    FEnableMouseNest(FALSE);
    FillRrc(TestList->pwd, &rrect, ' ', TestList->color);
    FEnableMouseNest(TRUE);
    TestList->halted = TRUE;
}


/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

BOOL DrawListItem(ListBoxData *TestList,WORD isz,BOOL isfocus)
{
    WORD redrawline;
    TestList->blank = FALSE;

    if (TestList->drawbehind == -1)
    {
       redrawline = TestList->numlinesscrolled;
    }
    else
    {
	redrawline = TestList->drawbehind;
    }
    redrawline += isz;
    if(redrawline>=TestList->numlinesscrolled &&
	    redrawline<TestList->numlinesscrolled+TestList->numlinesonscreen)
	TestList->ListProc(tmmDrawItem, NULL, redrawline,
		       TestList->tmc, TestList->rect.axLeft+1,
		       TestList->rect.ayTop+isz, isfocus & TestList->hasglobalfocus);
    return(TRUE);
}

VOID GlobalFocusBox(ListBoxData *TestList,BOOL yesorno)
{
   if(yesorno)
	gCurrentTMC = TestList->tmc;

	if (TestList->halted)
		return;

   TestList->hasglobalfocus = yesorno;
   DoDrawTitle(TestList);

/* Following #ifdefed out code was introduced as a hack to make the item
 * with focus to be selected when one moves the focus to the file listbox
 * when one is not in add mode.
 */
#if 0
	if((yesorno) && (TestList->mode) &&
				 (!TestList->alwaysexplicit) && (!(TestList->lastmousestate&MK_LBUTTON)))
	{
	  TestList->ListProc(tmmSelect, NULL,
			     TestList->focusitem,
				   TestList->tmc,0,TestList->rect.ayTop+TestList->focusitem-TestList->numlinesscrolled,0);      
	}
#endif

   InsertListItem(TestList,TestList->focusitem);
}


/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

VOID DoUpdateListBox(ListBoxData *TestList,WORD nlines)
{
      int i;

      if (TestList->halted)
	return;
      if (TestList->update)
      {
	if(TestList->numlinesscrolled &&
		TestList->numlinesscrolled+TestList->numlinesonscreen
		> GetNumItems(TestList))
	    DoScrollListBox(TestList, 0, FALSE);
	 FEnableMouseNest(FALSE);
	 for(i=0;i<nlines;i++)
	 {
	     if (TestList->nextlinetoupdate < TestList->numlinesonscreen)
	     {
		  DrawListItem(TestList,TestList->nextlinetoupdate,
		      TestList->focusitem == TestList->numlinesscrolled
		  +TestList->nextlinetoupdate);
		  ++TestList->nextlinetoupdate;
	     }
	     else
	     {
		    TestList->update = FALSE;
		    break;
	     }
	 }
	 FEnableMouseNest(TRUE);
      }
      if(TestList->scroll.doupdate)
      {
	UpdateScrollBar(TestList,TestList->numlinesscrolled,
	   GetNumItems(TestList)-TestList->numlinesonscreen);
      }
}
/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

#if 0
VOID QuickRedisplayList(ListBoxData *TestList)
{
      if (TestList->halted)
	return;
    TestList->numlinesscrolled = 0;
    TestList->focusitem = 0;
    InsertListItem(TestList,0);
}
#endif

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

VOID DoRedisplayList(ListBoxData *TestList)
{
    RRC rrect;
      if (TestList->halted)
	return;
    rrect.ryTop = TestList->rect.ayTop;
    rrect.ryBottom = TestList->rect.ayBottom;
    rrect.rxLeft = TestList->rect.axLeft+!gisgraph;
    rrect.rxRight = TestList->rect.axRight - 2;

    if (!TestList->blank)
    {
      FEnableMouseNest(FALSE);
      FillRrc(TestList->pwd, &rrect, ' ', TestList->color);
      FEnableMouseNest(TRUE);
      TestList->blank = TRUE;
    }
    TestList->numlinesscrolled = 0;
    TestList->focusitem = 0;
    TestList->ListProc(tmmSetFocus, NULL, TestList->focusitem, TestList->tmc,
	    0, 0, 0);
    InsertListItem(TestList,0);
}
/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

VOID DoScrollListBox(ListBoxData *TestList, int amt, BOOL updatenow)
{
    int amount, scrolllinesleft;
    WORD numitems;

    numitems = GetNumItems(TestList);
    scrolllinesleft = numitems - TestList->numlinesonscreen -
	    TestList->numlinesscrolled;

    if(amt > 0)
	amount = min(amt, scrolllinesleft);
    else
	amount = max(amt, -TestList->numlinesscrolled);

    if(numitems <= TestList->numlinesonscreen)
	amount = -TestList->numlinesscrolled;
    else if(scrolllinesleft < 0)
	amount = min(amount, scrolllinesleft);

    if(!amount)
	return;
#if 0 /* I don't see how you can pass this test (assuming numlinesscrolled>0) */
    if(amount>0 && numitems<TestList->numlinesscrolled +
	    TestList->numlinesonscreen))
	amount = 0;
#endif

    TestList->numlinesscrolled += amount;
    FEnableMouseNest(FALSE);
    UpdateScrollBar(TestList, TestList->numlinesscrolled,
	    numitems-TestList->numlinesonscreen);
    FEnableMouseNest(TRUE);
// #define FOCUSVISIBLE
#ifdef FOCUSVISIBLE
    if(TestList->focusitem < TestList->numlinesscrolled) {
	TestList->focusitem = TestList->numlinesscrolled;
    } else if(TestList->focusitem >=
	    TestList->numlinesscrolled+TestList->numlinesonscreen) {
	TestList->focusitem =
		TestList->numlinesscrolled+TestList->numlinesonscreen-1;
    }
    TestList->ListProc(tmmSetFocus, NULL, TestList->focusitem, TestList->tmc,
	    0, 0, 0);
#endif
    TestList->update = TRUE;
    TestList->nextlinetoupdate = 0;
    if(updatenow)
	DoUpdateListBox(TestList, TestList->numlinesonscreen);
}

/*      NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
int NextFocusLineChange(ListBoxData *TestList, int amt)
{
    int nextfocus, numitems;

    numitems = GetNumItems(TestList);
    nextfocus = TestList->focusitem;
    if(amt > 0)
	nextfocus += min(amt, numitems - 1 - nextfocus);
    else
	nextfocus += max(amt, -nextfocus);

    if(nextfocus < 0)
	return(0);
    if(nextfocus >= numitems)
	return(numitems - 1);
    return(nextfocus);
}

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

VOID FocusLineChange(ListBoxData *TestList, int amt)
{
    int numitems, nextfocusitem, saveFocus;

    if(!amt || !(numitems=GetNumItems(TestList)))
	return;
    nextfocusitem = NextFocusLineChange(TestList, amt);

    saveFocus = TestList->focusitem;
    TestList->focusitem = nextfocusitem;
    TestList->ListProc(tmmSetFocus, NULL, TestList->focusitem,
	    TestList->tmc, 0, 0, 0);

    if(nextfocusitem>=TestList->numlinesscrolled+TestList->numlinesonscreen ||
	    nextfocusitem<TestList->numlinesscrolled) {
	nextfocusitem -= TestList->numlinesscrolled;
	if(nextfocusitem > 0)
	    nextfocusitem -= TestList->numlinesonscreen - 1;
	DoScrollListBox(TestList, nextfocusitem, !TestList->halted);
    } else if(!TestList->halted) {
	DrawListItem(TestList, saveFocus-TestList->numlinesscrolled,
		FALSE);
	DrawListItem(TestList, TestList->focusitem-TestList->numlinesscrolled,
		TRUE);
    }
}

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

VOID PageDown(ListBoxData *TestList)
{
   if (GetNumItems(TestList) != 0)
		DoScrollListBox(TestList,-TestList->numlinesonscreen,TRUE);
}
/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID PageUp(ListBoxData *TestList)
{
   if (GetNumItems(TestList) != 0)
		DoScrollListBox(TestList,TestList->numlinesonscreen,TRUE);
}

/*  NAME
 *      Get_Focus_Line
 *  DESCRIPTION
 *      Return the line number of the line that is the "focus" in the
 *  listbox.  This will return the *last* item that had the focus in the
 *  case that the listbox itself does not have the focus.
 *  ARGUMENTS
 *      Pointer to the list box
 *  RETURN VALUE
 *      line number of focus item
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
WORD Get_Focus_Line(ListBoxData *TestList)
{
   return(TestList->focusitem);
}

/*
 *Select range from anchor to toitem
 */
VOID SelectRange(ListBoxData *TestList,WORD toitem)
{
    WORD startrange;
    WORD endrange;

	 /* for stupid list boxes, we don't do range selects! */
	 if (TestList->stupid)
		return ;

    startrange = min(TestList->anchor,toitem);
    endrange = max(TestList->anchor,toitem);
    InsertListItem(TestList,startrange);
    do
    {
	   TestList->ListProc(tmmSelect, (char *) ISRANGESELECT,
	   startrange,
	   TestList->tmc,-1,-1,0);
	   ++startrange;

    }while(startrange <= endrange);
}

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
BOOL ListMouse(ListBoxData *TestList,WORD x,WORD y,WORD message,BOOL state)
{
    int thisclick;

    if(TestList->halted)
	return(FALSE);

    switch(message) {
    case WM_LBUTTONUP:
	TestList->lastmousestate = (BYTE)state;
	break;

    case WM_MOUSEIDLE:
	break;

    case WM_LBUTTONDOWN:
	gMouseDownX = (BYTE)x;
	gMouseDownY = (BYTE)y;
    case WM_MOUSEMOVE:
	gMouseX = (BYTE)x;
	gMouseY = (BYTE)y;
    default:
	TestList->lastmouseX = (BYTE)x;
	TestList->lastmouseY = (BYTE)y;
	TestList->lastmousestate = (BYTE)state;
	break;
    }

/* Set thisclick to the index of the item that was last clicked */
    thisclick = TestList->numlinesscrolled + gMouseDownY - TestList->rect.ayTop;

    if(!(state&MK_LBUTTON)) /* mouse is not down */ {
	switch(TestList->LastClicked) {
	case DESELFILEONMOUSEUP:
	    TestList->ListProc(tmmDeSelect, NULL, thisclick,
		    TestList->tmc, 0, 0, 0);
	    InsertListItem(TestList, thisclick);
	    break;

	case DESELALLONMOUSEUP:
	    TestList->ListProc(tmmDeselectAll, NULL, 0, TestList->tmc, 0, 0, 0);
	    if(!TestList->ListProc(tmmQuerySelect, NULL, thisclick,
		    TestList->tmc, 0, 0, 0))
		TestList->ListProc(tmmSelect, NULL, thisclick, TestList->tmc,
			TestList->lastmouseX, TestList->lastmouseY, 0);
	    InsertListItem(TestList, thisclick);
	    break;
	}
	TestList->LastClicked = NOFILECLICKED;

	if(TestList->scroll.dragging) {
	    TestList->scroll.dragging = FALSE;
	    DrawScrollBar(TestList, FALSE);
	    return(TRUE);
	} else {
#ifndef NODIRECT
	    TestList->ListProc(tmmDrop, NULL, 0, TestList->tmc, x, y,0);
#endif
	    return(FALSE);
	}
    }

/* Mouse is down */
/* Return TRUE if the scroll bar handles the message */
    if(ScrollBarMouse(TestList, message)) {
	return(TRUE);
    }

#ifndef NODIRECT
/* Send the PickUp message if we have one pending and this is a MOUSEMOVE */
    if(TestList->LastClicked!=NOFILECLICKED && message==WM_MOUSEMOVE) {
	TestList->ListProc(tmmPickUp, NULL, thisclick,
		TestList->tmc, x, y, 0);
/* We only want to send one tmmPickUp message */
	TestList->LastClicked = NOFILECLICKED;
    }
#endif

/* Return FALSE if mouse is not in the listbox */
    if(x<TestList->rect.axLeft || x>TestList->rect.axRight ||
	    y<TestList->rect.ayTop-1 || y>=TestList->rect.ayBottom+!gisgraph) {
	return(FALSE);
    }

/* Return TRUE if mouse is in the title bar or the bottom border */
    if(y<TestList->rect.ayTop ||
	    y>=TestList->rect.ayBottom) {
	return(TRUE);
    }

    switch(message) {
    case WM_MOUSEMOVE:
#ifndef NODIRECT
/* Set thisclick to the index of the item under the cursor */
	thisclick = TestList->numlinesscrolled + y - TestList->rect.ayTop;

		  /* If the mouse moved within the range of the contents of the
			* listbox, change focus, else just ignore it. This test is used
			* to take care of the problem when the user clicks at the empty
			* region of a partially filled listbox and mouse the mouse to
			* another blank spot in it. Previously, the focus used to move
			* to the last item and IBM complained about it. This could slow
			* down stuff on mouse moves!
			*/
	if(thisclick < GetNumItems(TestList))
			FocusLineChange(TestList, thisclick-TestList->focusitem);
#endif
	break;

    case WM_LBUTTONDBLCLK:
	if(thisclick >= GetNumItems(TestList))
	    break;

/* Select only the double clicked item, and then activate it */
	TestList->ListProc(tmmDeselectAll, NULL, 0, TestList->tmc, 0, 0, 0);
	TestList->ListProc(tmmSelect, NULL, thisclick, TestList->tmc, x, y, 0);
	FocusLineChange(TestList, thisclick-TestList->focusitem);
	DoUpdateListBox(TestList, TestList->numlinesonscreen);
	TestList->ListProc(tmmActivate, NULL, thisclick, TestList->tmc, x, y,0);

/* You can't drag after double-clicking */
	TestList->LastClicked = NOFILECLICKED;
	break;

    case WM_LBUTTONDOWN:
	if(thisclick >= GetNumItems(TestList))
	    break;

/* default is to do nothing on the corresponding mouse up */
	TestList->LastClicked = NOACTIONONMOUSEUP;

	if(state&MK_SHIFT) {
/* shift selects a contiguous range of items */
	    if(!(state&MK_CONTROL))
		TestList->ListProc(tmmDeselectAll, NULL, 0,
			TestList->tmc, 0, 0, 0);

/* select from the "anchor point" to here */
	    SelectRange(TestList, thisclick);
	} else {
	    if(state&MK_CONTROL) {
		if(TestList->ListProc(tmmQuerySelect, NULL, thisclick,
			TestList->tmc, 0, 0, 0))
		    TestList->LastClicked = DESELFILEONMOUSEUP;
	    } else {
		if(TestList->ListProc(tmmQuerySelect, NULL, thisclick,
			TestList->tmc, 0, 0, 0))
		    TestList->LastClicked = DESELALLONMOUSEUP;
		else
		    TestList->ListProc(tmmDeselectAll, NULL, 0,
			    TestList->tmc, 0, 0, 0);
	    }

/* clicked line always gets selected; if control was down and it was
 * previously selected, it will get deselected when the mouse comes up.
 */
	    FocusLineChange(TestList, thisclick-TestList->focusitem);
	    TestList->ListProc(tmmSelect, NULL, thisclick,
		    TestList->tmc, x, y, 0);

	    Set_Anchor(TestList, thisclick);
	    InsertListItem(TestList, thisclick);
	}
	break;

    // case WM_MOUSEIDLE:
    default:
	break;
    }

    return(TRUE);
}


/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID InsertListItem(ListBoxData *TestList,WORD isz)
{
	 int numitems;

    if (TestList->halted)
	 return;
    if (isz < TestList->numlinesscrolled)
    {
		TestList->nextlinetoupdate = 0;
    }
    else
       TestList->nextlinetoupdate = min(TestList->nextlinetoupdate,isz-TestList->numlinesscrolled);

	 if (TestList->focusitem >= (numitems=GetNumItems(TestList)))
		TestList->focusitem = max(0,numitems-1);
    TestList->scroll.doupdate = TRUE;
    TestList->update = TRUE;

}

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
VOID ListKey(ListBoxData *TestList, WORD key, WORD state)
{
	static char typed[20];

	TMM tmmselectmode;
	int nextfocus;
	char itemstring[256], upperKey;
	int i, j, lastitem, enditem;

	if(TestList->halted)
		return;

	switch((key)) {
	case VK_UP:
		nextfocus = NextFocusLineChange(TestList, -1);
		goto SingleLineChange;

	case VK_DOWN:
		nextfocus = NextFocusLineChange(TestList, 1);
		goto SingleLineChange;

	case VK_PRIOR:
		nextfocus = NextFocusLineChange(TestList, -TestList->numlinesonscreen);
		goto SingleLineChange;

	case VK_NEXT:
		nextfocus = NextFocusLineChange(TestList, TestList->numlinesonscreen);
		goto SingleLineChange;

	case VK_HOME:
		nextfocus = NextFocusLineChange(TestList, -TestList->focusitem);
		goto SingleLineChange;

	case VK_END:
		nextfocus = NextFocusLineChange(TestList,
				GetNumItems(TestList)-TestList->focusitem);

SingleLineChange:
		if(TestList->mode)  /*implicit */
			TestList->ListProc(tmmDeselectAll, NULL, 0,
					TestList->tmc, 0, 0, 0);

		if(state&KK_SHIFT) {
/* select from the "anchor point" to here */
			SelectRange(TestList, nextfocus);
		} else if(TestList->mode) {
/* selected line now has "selected" emphasis too */
			TestList->ListProc(tmmSelect, NULL, nextfocus,
					TestList->tmc, 0, TestList->rect.ayTop+nextfocus
					-TestList->numlinesscrolled, 0);
			Set_Anchor(TestList, nextfocus);
		}
		FocusLineChange(TestList, nextfocus-TestList->focusitem);
		break;

	case ' ':
		if(!(state&KK_CONTROL) && (TestList->mode)) {
			tmmselectmode = tmmSelect;
			TestList->ListProc(tmmDeselectAll, NULL, 0,
					TestList->tmc, 0, 0, 0);
		} else {
			tmmselectmode = tmmToggleSelect;
			InsertListItem(TestList, 0);
		}

		if(state&KK_SHIFT) {
			SelectRange(TestList, TestList->focusitem);
		} else {
			TestList->ListProc(tmmselectmode, NULL, TestList->focusitem,
					TestList->tmc, 0, TestList->rect.ayTop+TestList->focusitem
					-TestList->numlinesscrolled, 0);
			Set_Anchor(TestList,TestList->focusitem);
		}
		break;

	case 13:
		TestList->ListProc(tmmActivate, NULL, TestList->focusitem,
				TestList->tmc, 0, TestList->rect.ayTop+TestList->focusitem
				-TestList->numlinesscrolled, 0);
		break;

	case VK_F8:
		if(state&KK_SHIFT && !TestList->alwaysexplicit) {
			TestList->mode = !TestList->mode;
			TestList->ListProc(TestList->mode ? tmmImplicit : tmmExplicit,
					NULL, 0, TestList->tmc, 0, 0, 0);
		}
		break;

	default:
		if(key>' ' && key<256) {
			if((lastitem = GetNumItems(TestList) - 1) < 0)
				break;

			if(!gListKeyDelay || ScrollPause(gListKeyDelay))
				i = 0;
			else if((i=strlen(typed)) >= sizeof(typed)-1)
				break;
			typed[i  ] = upperKey = (BYTE)toupper(key);
			typed[i+1] = '\0';

			nextfocus = -1;
			enditem = TestList->focusitem;

			if(i) {
				i = enditem;
				TestList->ListProc(tmmGetItemString, itemstring, i,
						TestList->tmc, 0, 0, 0);
				goto SkipFirstTest;
			} else {
				i = enditem>=lastitem ? 0 : enditem+1;
			}

			for( ; i!=enditem; (i>=lastitem ? i=0 : ++i)) {
				itemstring[0]=0;
				TestList->ListProc(tmmGetItemString, itemstring, i,
						TestList->tmc, 0, 0, 0);
				if(itemstring[0] == 0)
					break;
				if(toupper(itemstring[0])==upperKey && nextfocus<0)
					nextfocus = i;
SkipFirstTest:
				for(j=0; typed[j]; ++j)
					if(toupper(itemstring[j])!=typed[j])
						break;
				if(!typed[j]) {
					nextfocus = i;
					goto SingleLineChange;
				}
			}

			if(nextfocus >= 0) {
				typed[0] = upperKey;
				typed[1] = '\0';
				goto SingleLineChange;
			} else
				typed[0] = '\0';
		}
	}
}

extern BOOL IsMenuDown(void);

VOID UpdateListBox(ListBoxData *TestList)
{
    if (TestList->halted)
		return;
	 if(IsMenuDown())
		return; // do nothing now; since .inited is not set, will happen later

      FEnableMouseNest(FALSE);
      TestList->scroll.inited = FALSE;
      FrameListBox(TestList);
      FEnableMouseNest(TRUE);
      InsertListItem(TestList,0);
}



/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *      TRUE if really idle, FALSE otherwise
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
    MSG     pmsg;
BOOL ListBoxIdle(ListBoxData *TestList)
{
    int     i;
    int     numlinestodraw;
    int     message;
    BOOL    amidle=TRUE;

	 /* if a menu is down, we don't do stuff. This is because
     * graphics cannot clip to the menu, so graphics users will
     * trompt on the menu
     */
    if ((TestList->halted) || (IsMenuDown()))
		return(amidle);/* idle */

    if (!TestList->inited)
    {
      UpdateListBox(TestList);
      TestList->inited = TRUE;
      TestList->drawahead= -1;
      TestList->drawbehind = -1;
      amidle = FALSE;
    }

    if(TestList->lastmousestate&MK_LBUTTON) /* mouse is down */
			ListMouse(TestList,TestList->lastmouseX,TestList->lastmouseY,
				WM_MOUSEIDLE, TestList->lastmousestate);
    //DoUpdateListBox(TestList,TestList->numlinesonscreen);
    if(TestList->drawahead != -1)
    {
		TestList->drawbehind = TestList->numlinesscrolled;
		TestList->nextlinetoupdate = TestList->drawahead;
		amidle = FALSE;
    }
    else
    {
		if(TestList->drawbehind!=-1)
		{
		InsertListItem(TestList,0);
		amidle = FALSE;
		}
		TestList->drawbehind = -1;
    }
    i = TestList->numlinesonscreen;
		numlinestodraw = i/4;

	/* ZZZZZZZZ Scott, make sure that I need to put in following check!! */
	/* Actually value shouldn't be < 0, but the following <= check is safe! */
	if (numlinestodraw <= 0)
		numlinestodraw = 1 ; /* Will guarantee termination of foll. loop! */
    /*
     * if they aren't dragging, just update the who thing, otherwise
     * do it in bits, so we break out for a scroll
     */
    if (!TestList->scroll.dragging)
    {
		DoUpdateListBox(TestList,i);
		i=0;
    }
    else
    while(i > 0)
    {
		DoUpdateListBox(TestList,numlinestodraw);
		i-=numlinestodraw;
		if( /* (TestList->scroll.dragging) && */ PeekMessage(&pmsg))
		{
		message = pmsg.message;
		UngetMessage(&pmsg);
		if((message == WM_MOUSEMOVE) || (message == WM_CHAR))
		{
		  break;
		}
		amidle = FALSE;
		}
    }
    if(i>0)
    {
       TestList->drawahead = TestList->nextlinetoupdate;
    }
    else
       TestList->drawahead = -1;
    return(amidle);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\locate.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>
#include <locate.hs>
#include <locate.sdm>

extern VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen) ;

/* Storage to save the glob.MatchPat, before going into Search Mode. */
char gSavedMatchPat[NAMELEN+EXTLEN+1+1] ;

/* Storage to save glob.TreeMode, glob.SortKey before going into search mode */
int gSavedTreeMode ;
int gSavedSortOrder ;
WORD gSavedGlobalFocus ;

BOOL gfSearchDisk ; /* Whether to serch entire disk or not */

BOOL FAR PASCAL FDlglocate(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	char fullparentpath[MAX_PATH+1] ;
	char parentname[60] ;
	PWND lwind ;
	int  itemwidth ;
	int dummylen ;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	if (dlm == dlmInit)
	{
		/* default is always to search entire disk! */
		SetTmcVal(tmcsearchfulldisk, TRUE);

		SetUpDialog(tmcOK,szLocateCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmclocatehelp);
		SetUpEditBox(tmclocatestring, TRUE,NAMELEN+EXTLEN+1, TRUE);
		SetUpCheckBox(tmcsearchfulldisk) ;

		// FormPseudoPathName(parentname, listinfo[0].files, listinfo[0].tree) ;
		Tree2Path(listinfo[0].tree, listinfo[0].files, fullparentpath, &dummylen) ;
		
		lwind = PwndOfTmc(tmclocatedir);
		itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;
		MakeDirNameFit(fullparentpath, NULL, parentname, itemwidth) ; 
		Shell_SetTmcText(tmclocatedir, parentname) ;
	} else if (dlm == dlmSetFocus)
	{
	    gCurrentTMC = tmc;
	} else if (dlm== dlmClick)
	{
		 if(tmc == tmclocatehelp)
			Help(hemDialog, hidLOCATE,NULL,0);

		 SetFocusTmc(gCurrentTMC) ;
	} else if ( (tmc == tmcOK) && (dlm == dlmTerm) )
	    gfSearchDisk = GetTmcVal(tmcsearchfulldisk) ;

	return(TRUE);
}

VOID FAR FileLocateBox()
{
	HCABlocate        h;
	char tstr[MAX_PATH+1];

	h = HcabAlloc(cabiCABlocate);
	if (!h)
	{
	    OutOfMemory() ;
	    return ;
	}
	InitCab(h, cabiCABlocate) ;

	/* The Search Pattern -- We initialize it with the current glob.MatchPat. */
	/* ZZZ should this be a NULL string? */
	SzToCab(h, glob.MatchPat, Iag(CABlocate, pszlocatestring));

	SzToCab(h, szEnterButton, Iag(CABlocate, pszlocateEB));
	SzToCab(h, szCancelButton, Iag(CABlocate, pszlocateCB));
	SzToCab(h, szHelpButton, Iag(CABlocate, pszlocateHB));

	if (MyTmcDoDlg(&dlglocate,h) == tmcOK)
	{
		/* We can't search tree if it is in compact mode */
		if (gfSearchDisk && (listinfo[0].tree->Compacted) )
		{
			OutOfMemory() ;
		}
		else
		{
			/* If we are not invoking Search from within Search save the original
			 * MatchPattern so that we can restore the FM state -- TR_SINGLE,
			 * TR_DOUBLE, TR_SYSTEM.
			 */
			if (glob.TreeMode != TR_SEARCH)
			strcpy(gSavedMatchPat, glob.MatchPat) ;

		SzFromCab(h, tstr, MAX_PATH, Iag(CABlocate, pszlocatestring));
		ScrunchFileName(glob.MatchPat, tstr, TRUE) ;

		/* ZZZZ Probably not needed if dialog box takes care of it! */
#ifdef DBCS
		DBCSstrupr(glob.MatchPat) ;
#else
		strupr(glob.MatchPat) ;
#endif

		strcpy(glob.MatchPat, MakePatWellFormed(glob.MatchPat)) ;
		MarkAllTreeMatches(listinfo[0].tree, FALSE) ;

			/* We do incremental sorting so it is safer to sort whole tree
			 * correctly now.
			 */
			SetUpTreeForSort(listinfo[0].tree) ;

		DoSearchDisplay(TRUE);
		}
	}

	FreeCab(h);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\main.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <prot.h>
#include <time.h>
#include <direct.h>

extern GlobalIdle(void);
extern TOKEN Get_Identifier_Token(char far *identifier);
extern void Shell_TTY_Out(char *str);
extern void Get_CWD(char *);

extern BOOL AddTask(char far *programname, char far *parameters,char far *defaulttitle,TOKEN properties);

struct CountryBuffer {
    int Date_Format;
    char Currency_Symbol[5];
    char Thousands_Sep[2];
    char Decimal_Sep[2];
    char Date_Sep[2];
    char Time_Sep[2];
    char Currency_Pos;
    char Num_Decimals;
    char Time_Format;
    long Case_Mapping;
    char Data_Sep[2];
    char Reserved[10];
} ;
struct CountryBuffer NationData;

MSG     msg;
INST    ginst;
INGD    gingd;
INDV    gindv;
BOOL    gisgraph = FALSE ;
INCH    cinch;

BOOL gfStillInitializing; /* used in allocs to bail if we're gonna toast */
BOOL gfScreenModeChanged; /* used to restore screen in case we bail out early */
BOOL gfSwapHandlerInstalled;

char gStartUpDir[1+MAX_PATH];
char gStartInDir[1+MAX_PATH];
int gStartUpDirEnd; /* location where the NULL goes in the above name */

BOOL gBeeps_On; /* Whether to have Beeps turned on or not on error */

gBeeps_On = TRUE ;

extern MENUINFO MainMenuBar;
extern MENUINFO FileMgrMenuBar;
extern BYTE ErrorCrit;

extern VOID setmenubar(MENUINFO *amenu,PWND towind);
extern BOOL GetInternationalData(void);
extern void InstallSwapHandler(void) ;
extern void     PrintHelpText(void);
extern VOID SetUpExitToDos(void); /* see init.c */
extern BOOL AsynchUpdateTreeList(void);

VOID DeleteBatchFile(void);

extern WND ViewWind;
extern BOOL gMouseDown;
extern BYTE gMouseX;    /* X value of last mouse-down */
extern BYTE gMouseY;    /* Y value of last mouse-down */

/* INTERNATIONALIZE HERE!
 * We still don't have international am/pm symbols
*/
/*
 * sets up datestr to be in format ' 00-00-00 '
 * sets up timestr to be in format ' 12:20 am '
 *
 * if force is not set, and time (minutes) has not changed, returns
 * false and does not format strings.
 * if force is set, formats strings and returns true
 * if force is not set, and time has changed, formats strings and returns true
 */

#define NumToAsc(num,str) (temp=(num)/10, *(str++)=(char)((temp%10)+'0'), *(str++)=(char)((num)-temp*10+'0'))

BOOL FAR Get_Date_and_Time_Strings(unsigned int theDate, unsigned int theTime,
      char *datestr, char *timestr, BOOL force)
{
    static struct tm lasttime;
    struct tm temptime, *newtime;
    time_t long_time;
    register int temp;
    int date1, date2, date3;  /* for international date order */

    if(!theDate && !theTime) {
	time(&long_time);
	newtime = localtime(&long_time);
    } else {
	temptime.tm_year = 80 + (theDate>>0x09);
	temptime.tm_mon  = ((theDate>>0x05)&0x0f) - 1;
	temptime.tm_mday = theDate&0x1f;
	temptime.tm_hour = theTime>>0x0b;
	temptime.tm_min  = (theTime>>0x05)&0x3f;
#if 0 /* We don't use the seconds */
	temptime.tm_sec  = 2*(theTime&0x1f);
#endif

	newtime = &temptime;
	goto FormatDateAndTime;
    }

    if (force || (newtime->tm_min != lasttime.tm_min))
    {
	lasttime = *newtime;
FormatDateAndTime:
	if(datestr) {
	    if(NationData.Date_Format == 1) {
		date1 = newtime->tm_mday;
		date2 = newtime->tm_mon + 1;
		date3 = newtime->tm_year;
	    } else if(NationData.Date_Format == 2) {
		date1 = newtime->tm_year;
		date2 = newtime->tm_mon + 1;
		date3 = newtime->tm_mday;
	    } else {
		date1 = newtime->tm_mon + 1;
		date2 = newtime->tm_mday;
		date3 = newtime->tm_year;
	    }

	    NumToAsc(date1, datestr);
	    *(datestr++) = *NationData.Date_Sep;
	    NumToAsc(date2, datestr);
	    *(datestr++) = *NationData.Date_Sep;
	    NumToAsc(date3, datestr);
	}

	if(timestr) {
	    if(NationData.Time_Format&0x01) { /* A 24-hour clock */
		timestr[5] = ' ';
		NumToAsc(newtime->tm_hour, timestr);
	    } else { /* A 12-hour clock */
		temp = newtime->tm_hour;
		if(temp < 12) {
		    if(temp == 0)
			temp = 12;
		    timestr[5] = 'a';
		} else {
		    if(temp != 12)
			temp = temp - 12;
		    timestr[5] = 'p';
		}
		if((temp/10)>0)
		    *(timestr++) = (char) ((temp/10) + '0');
		else
		    *(timestr++) = (char) ' ';
		*(timestr++) = (char) ((temp%10) + '0');
	    }
	    *(timestr++) = *NationData.Time_Sep;
	    NumToAsc(newtime->tm_min, timestr);
	}

	return(TRUE);
    } else {
       return(FALSE);
    }
}

/*
 * draw the top title bar--
 */
VOID FAR UpdateMainTitleBar(char *szTitle)
{
    char *titlestring;
    int i;
    WORD len;
    WORD titlestart;
    char padded[100];

	 titlestring = szTitle ;

    len = strlen(titlestring);
    titlestart = axMac/2 - len/2;
    for(i=0;i<axMac;i++)
    {
		padded[i] = ' ';
    }
    FEnableMouseNest(FALSE);

    TextOut(&MainWind,(RX) 0,(RY) 0, padded,titlestart,isaHilite);
	 TextOut(&MainWind,(RX) titlestart,0,titlestring,len,isaHilite);
    TextOut(&MainWind,(RX) titlestart+len,(RY)0, padded,axMac-(titlestart+len),isaHilite);
    if (gisgraph)
    {
	if(CHEIGHT > SMALLHEIGHT)
	{
	     SetAreaPat(0);
	     SetLinePat(1);
	     SetColor(0,0x7FFF);
	     Move(0,CHEIGHT-1);
	     Draw((axMac)*CWIDTH,CHEIGHT-1);
	}
    }
    FEnableMouseNest(TRUE);
}

VOID FAR PauseBeforeScreenErase(VOID)
{
#ifndef NOLOADER
    if(Get_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE) != TK_DISABLED)
    {
	if (GET_WAIT_FLAG())
	{
		 /* clear out keyboard buffer */
		 while(kbhit())
			getch();

		 Shell_TTY_Out(szPressAKey);
		 /* wait for key to be hit */
	    while(!kbhit())
				;
		 /* eat key */
	    getch();
	}
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE,TK_ENABLED);
    }
#endif
}


VOID ParseCommandLine(void)
{
    char far *commandline;
    char lastfound=0;
    char tstr[256], *szWhichRes;
    TOKEN tkRes;

#ifndef NOLOADER
    if(GET_WAIT_FLAG())
	return;

	/*      We use the previous bytes to store pause flag status, a far pointer, etc
	 *      See loader.asm for exact details.
	 */
	commandline = GET_COMMAND_PTR()+9;
#if 0
	printf("%d, ", *(commandline-2)) ;
	printf("%d, ", *(commandline-1)) ;
	printf("%d, ", *commandline) ;
	printf("%d, ", *(commandline+1)) ;
	printf("%d, ", *(commandline+2)) ;
	printf("%d, ", *(commandline+3)) ;
	printf("\n") ;
	getchar() ;
#endif
    for( ; ; ++commandline) {
	switch(*commandline) {
	case('\0'):
	case('\r'):
	    goto AllDone;
	    break;

	case('/'):
	    ++commandline;
	    switch(lastfound=(char)toupper(*commandline)) {
	    case 'T':
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_SCREENMODE, TK_TEXT);
		break;

	    case 'G':
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_SCREENMODE,TK_GRAPHICS);
		break ;

#ifdef ERICLIKESBEEPCONTROL
	    case 'B' : // /BEEP
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_BEEP, TK_ENABLED);
		break ;

	    case 'N' : // /NOBEEP
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_BEEP, TK_DISABLED);
		break ;
#else
	    case 'B' :
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_FORCEMONO, TK_ENABLED);
		break ;
#endif

#ifdef SWAPMOUSESWITCH
	    case 'S' : // /SWAPMOUSE
		Set_KeyWord_Assignment(TK_SAVESTATE, TK_SWAPMOUSE,
			Get_KeyWord_Assignment(TK_SAVESTATE, TK_SWAPMOUSE)
			== TK_DISABLED ? TK_ENABLED : TK_DISABLED);
				break ;
#endif
#if 0
	    case '?' : // /HELP
	    case 'H' :
#endif
	    default  :
		PrintHelpText();
		SetUpExitToDos();
		exit(0);
	    }
	    break;

	case(':'):
	    ++commandline;
	    switch(lastfound) {
	    case 'G':
	    case 'T':
		switch(toupper(*commandline)) {
		case 'L':
		    tkRes = TK_LOWRES;
		    goto MakeKeyword;

		case 'M':
		    tkRes = TK_MEDIUMRES;
		    goto MakeKeyword;

		case 'H':
		    tkRes = TK_HIGHRES;
		    goto MakeKeyword;

MakeKeyword:
		    strfcpy(tstr, Get_Token_Identifier(tkRes));
		    for(szWhichRes=tstr; *szWhichRes; ++szWhichRes)
			/*do nothing */ ;
		    for(++commandline; *commandline>='0' && *commandline<='9';
			    ++commandline)
			*(szWhichRes++) = *commandline;
		    *szWhichRes = '\0';

		    Set_KeyWord_Assignment(TK_SAVESTATE, TK_RESOLUTION,
			    Get_Identifier_Token(tstr));
		    break;

		default:
		    break;
		}
				break;

	    default:
		break;
	    }

		    lastfound = 0;
	    break;

	default:
	    break;
	}
    }
AllDone:
    ;
#endif
}

extern char far * cdecl GET_STARTUP_NAME(VOID);
VOID FAR SetUpStartUpDirectory(VOID)
{
#ifndef NOLOADER
    strfcpy(gStartUpDir,GET_STARTUP_NAME());
    gStartUpDirEnd=FindLastComponent(gStartUpDir);
    gStartUpDir[gStartUpDirEnd]= 0;

#else
    strcpy(gStartUpDir,".\\");
	gStartUpDirEnd=2;
#endif
	Get_CWD(gStartInDir);

}

extern char *gpszNonSwap ;
/*
 * This is where all background tasking is done, so it should
 * be called often.
 */
VOID MainIdle(void)
{
   static  int     arbitrarycounter;

		   /* Add more idle procs here if required.
		   */
#ifdef PROF
		   ClockOn();
#endif
		   /* note we need to call both idles always!
		    * thus, the & must be & and not && so it
		    * won't short circuit!
		    */
    if(gMouseDown && m_fPerformingViewFile()) {
	ViewWindProc(&ViewWind, WM_MOUSEIDLE, 1,
		((DWORD)gMouseY<<24) | ((DWORD)gMouseX<<16));
    }
		   if (FileMgrIdle() & StartProgramsIdle() & AsynchUpdateTreeList())
		   {
		      GlobalIdle(); /* Tell the world we're idle */
		   }
		   /*
		    * We poll the time to see if it changed. But we
		    * don't really need to do it all the time, so
		    * we use "arbitrarycounter" to determine if we should
		    * check to see if we should update it. Assumes we
		    * are idle 64k times a minute
		    */
		   if (arbitrarycounter++ == 0)
			MessageBar(gpszNonSwap, isaMenu,FALSE);
#ifdef PROF
		   ClockOff();
#endif
	fPollKeyboard=TRUE;

}

WORD gCnx = cnxNull;
/*
 * Called by CW during menu and dialog idle time
 */
WORD FARPUBLIC RspAppIdle(WORD cnx,DWORD Lparam)
{
    if(cnx == cnxDialog)
    {
		PDLG    pdlg = (PDLG)LOWORD(Lparam);

		if (pdlg->pfnDlg != NULL)
		{
		     /* send dlmIdle to appropriate dialog proc */
		     (*pdlg->pfnDlg)(dlmIdle, 0, 0, 0, 0);
		}

    }
    gCnx = cnx;
     /*
      * do not idle when in a critcal dialog!
      */
     if( ErrorCrit == 0xFF)
     {
	MainIdle();
     }
     gCnx = cnxNull;
     return(rspContinue);
}

/*
 * we don't use the standard argv handling, so why
 * have it around?
 */
void cdecl _setargv(void)
{
}
#if 0
void cdecl _setenvp(void)
{
	static char * foo;
	foo = environ;
	
	unlink("foo");
}
#endif
/* WARNING
 * this is a replacement for the C call malloc. This SHOULD NEVER BE
 * CALLED IN YOUR CODE! This function is called at startup by
 * C-runtime to setup the environment. Since we don't want to carry
 * around a bunch of code we don't use, we just use our own allocation
 * Note that this memory is never freed! This is very important, since
 * the freework function can tromp
 * The real malloc sucks in about .5k of code
 */
void * cdecl malloc(unsigned int s)
{
	return(PbAllocWork(s));
}


BOOL gfEarlyExit = FALSE ;

extern Dos_Version(void);
void VersionCheck(void) 
{
	/* Perform version check!! We use the new "int 2f" issued by the BIOS
	 * to swap disks on a single floppy system -- "A:", "B:" on 1 physical drive
	 */
	if (Dos_Version() < MIN_MAJOR_VERSION)
	{
		Shell_TTY_Out(szIncorrectDosVersion) ;
		gfEarlyExit = TRUE ;
		DoExit() ;
	}
}

extern WORD GetLastScanCode(void);

/*
 * Looks for '!' signature in the ROM, followed 18 bytes later by 
 * '01' which is the ROM BIOS version number.  
 * Thus, this will only detect Tandy's with version 1.0 ROM.
 */
#define IsTandy1000 ( (*((BYTE FAR *)0xf000c000L) == 0x21) && (*((WORD FAR *)0xf000c012L) == 0x3130))

/*
 * The Tandy 1000 returns some strange keyboard messages, so we have to
 * trap them and change them to the correct messages.  GetLastScanCode
 * helps us determine what the correct message is, but it will return
 * useless values if a modifier key is changed, so we have to store the
 * last useful value in wSaveScanCode.
 */
VOID FAR PASCAL Tandy1000KeyboardHook(WORD message, WORD wParam, DWORD lParam)
{
    static WORD wSaveScanCode = 0;
    WORD wLastScanCode;

#if 0
    char buf[80];

    if(message == WM_CHAR)
	com1("\nWM_CHAR    ");
    else if(message == WM_KEYUP)
	com1("\nWM_KEYUP   ");
    else if(message == WM_KEYDOWN)
	com1("\nWM_KEYDOWN ");
    else {
	sprintf(buf, "\n%-10d ", message);
	com1(buf);
    }
    sprintf(buf, "%04x 0x%04x 0x%04x ", wParam, HIWORD(lParam),
	    GetLastScanCode()&0xff7f);
    com1(buf);
    if(message==WM_CHAR && !(wParam&0xff00)) {
	buf[0] = LOBYTE(wParam);
	buf[1] = '\0';
	com1(buf);
    }
#endif

    if(message == WM_CHAR) {
	switch(wParam) {
	case(VK_HOME):
	    wLastScanCode = GetLastScanCode()&0x7f;
	    if(wLastScanCode == 0x47 || wLastScanCode == 0x58)
		wSaveScanCode = wLastScanCode;
	    if(wSaveScanCode == 0x47)
		wParam = '\\';
	    break;

	case(VK_LEFT):
	    wLastScanCode = GetLastScanCode()&0x7f;
	    if(wLastScanCode == 0x4b || wLastScanCode == 0x2b)
		wSaveScanCode = wLastScanCode;
	    if(wSaveScanCode == 0x4b)
		wParam = '|';
	    break;

	case(VK_UP):
	    wLastScanCode = GetLastScanCode()&0x7f;
	    if(wLastScanCode == 0x48 || wLastScanCode == 0x29)
		wSaveScanCode = wLastScanCode;
	    if(wSaveScanCode == 0x48)
		wParam = '~';
	    break;

	case(VK_DOWN):
	    wLastScanCode = GetLastScanCode()&0x7f;
	    if(wLastScanCode == 0x50 || wLastScanCode == 0x4a)
		wSaveScanCode = wLastScanCode;
	    if(wSaveScanCode == 0x50)
		wParam = '`';
	    break;

	case('-'):
	    wLastScanCode = GetLastScanCode()&0x7f;
	    if(wLastScanCode == 0x58 || wLastScanCode == 0x0c)
		wSaveScanCode = wLastScanCode;
	    if(wSaveScanCode == 0x58)
		wParam = VK_HOME;
	    break;
	}
    }
    InsertKeyboardMessage(message, wParam, lParam);
}


#ifdef HASHHITTEST
char b1[80];
extern int ghashhits;
extern int ghashmisses;
extern int ghashnotpresent;
extern int gnohashnotpresent;
#endif

extern VOID Do_Read_Ini_File(void);

/*
**                              Main program
*/
void cdecl main(int argc, char *argv[])
{
	UnReferenced(argc) ;
	UnReferenced(argv) ;

	/* Get information on the country we're in... */
	GetInternationalData();

	/* In case we bail out because of low memory situations, we want to
	 * restore the screen to appropriate state before quitting in case we
	 * modified the screen mode.
	 */
	gfScreenModeChanged = FALSE;

	/* The following field is used to determine whether to bail out or not in
	 * a low memory situation. If we run out of memory when we are initializing
	 * we will bail out.
	 */
	gfStillInitializing = TRUE;

	/* used to de-install swap handler on exitting the shell */
	gfSwapHandlerInstalled = FALSE ;

	VersionCheck() ;

	SetUpStartUpDirectory();
	/*
	 *  parse the shell.ini file
	 */
	Do_Read_Ini_File();
	/* if we are returning from a program, we must pause before
	 * we initialize the screen so the user can read the output
	 * of the last program
	 */
	PauseBeforeScreenErase();
	if (!InitializeShell())
	    DoExit();

    //if(IsTandy1000) check is disfunctional, so we used an ini switch
	if(Get_KeyWord_Assignment(TK_SAVESTATE,TK_TANDY1000) == TK_ENABLED)
		HookKeyboardMessage(TRUE, Tandy1000KeyboardHook);

   /*  Allocate memory for the OutOfMemory Dialog Box HCAB structure now.
	* When we are actually, out of memory, we may not be able to allocate
	* enuf memory to put up the dialog box. This way, we are guaranteed to
	* atleast be able to say: "Out Of Memory" in a neat dialog box!
	*/
	if (!AllocateHcabForOutOfMem())
		DoExit();

	/* Set up the collating table for sorts to be done later! */
	SetCollatingTable() ;

	/* If we have to use the collating sort, set sort functions to the
	 * collating sorts!
	 */
	if (!FDoQuickCompare())
	{
		SortFnArr[SORT_NAME] = name_cmp ;
		SortFnArr[SORT_EXT]  = ext_cmp ;

		/* This is the variable that is used to call the sort function! Update
		 * it correctly.
		 */
		if (*SortCmp == quick_name_cmp)
		{
			*SortCmp = name_cmp ;
		}
		else if (*SortCmp == quick_ext_cmp)
		{
			*SortCmp = ext_cmp ;
		}
	}

	InstallSwapHandler() ;
	/*
	 * WARNING taskmaninit must happen first!
	 */
	DeleteBatchFile();

	gfSwapHandlerInstalled = TRUE ;
	gfStillInitializing = FALSE;

#ifdef HASHHITTEST
	ErrorCrit = 34; 
	itoa(ghashhits, b1, 10);
	strcat(b1, "\n");
	itoa(ghashmisses, b1+strlen(b1), 10);
	strcat(b1, "\n");
	itoa(gnohashnotpresent, b1+strlen(b1), 10);
	ShellMessageBox("HASH RESULTS", b1);
	ErrorCrit = 0xFF;
#endif  

	/*
	 *      Handle messages (keyboard,mouse)
	 */
	MainIdle();
	while (1)
	{
	     if (PeekMessage(&msg))
	     {
		   DispatchMessage(&msg);
	     }
	     else
	     {
			MainIdle();
	     }
	     fPollKeyboard=TRUE;

	}
 }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\init.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <text.h>
#include <assert.h>
#include <screen.hs>
#include <screen.sdm>

extern void UnHookISR9(void) ;
extern BOOL gfOurISR9Installed ;
extern BOOL ErrorCrit;
#ifdef KANJI

#include <kkcfltr.h>

extern char *gpszNonSwap ;

STATIC LONG     FAR PASCAL KkcStatusWndProc(PWND, WORD, WORD, DWORD);

/* kk converter status window (at bottom of screen) */
WND wndKkcStatus =
    wndGeneric(1, WS_TILED, TRUE, 0, 24, 80, 1,
	KkcStatusWndProc, NULL, NULL, NULL)
    endWndGeneric;
    
#endif

/* The maximum number of screen modes that we will scan for in any display! */
#define MAX_SCREEN_MODES                16

/* This data structure will be filled in at startup and then will be looked
 * up by the Screen Mode changing functions.
 */
struct S_Mode sScreenMode[MAX_SCREEN_MODES] ;

/* This variable specifies if we have set the screen mode atleast once.
 * used to decide whether to free all the memory allocated by CW (using
 * calls to our fn "LpwAllocDriverMem()") that are not needed when we change
 * screen modes.
 */
BOOL gfScreenModeHasBeenSetOnce = FALSE ;
extern void OurHackFreeDriverMem(void) ;

extern void FInitMouseNest(void) ;

#define LOW_RES_NUMLINES        25
#define MED_RES_NUMLINES        35

#define m_fIsLowResMode(numlines) ((numlines) <= LOW_RES_NUMLINES)

#define m_fIsMedResMode(numlines) (!m_fIsLowResMode(numlines) && (numlines)<=MED_RES_NUMLINES)

/* Max length of the strings: "Medium Resolution Graphics", "Low Resolution
 *      Text", etc! These also have (xx lines) appended to them! 
 */
#define MAXSCREENMODETITLE 55

extern DTS_API_Exit(void);

extern VOID FirstInitTaskMan(void);
extern BOOL Buffered_Write_Ini_File(BOOL bFreeFM) ;
extern TOKEN Get_Identifier_Token(char far *identifier);
extern BOOL gfScreenModeChanged;
extern BOOL gfSwapHandlerInstalled;
extern int gReadUpdateFreq ;

extern BOOL gBeeps_On ;
extern BOOL gfFMVisited ;

extern MENUINFO MainMenuBar;
extern MENUINFO FileMgrMenuBar;
extern void RemoveSwapHandler(void) ;
extern void HookISR10(void);
extern void UnHookISR10(void);
extern int GetUserColorSelection(void);
extern VOID FAR ScreenDialog(void) ;
extern void DrawScreen(void) ;

extern int gNthColorGroup;
extern char gStartInDir[];
extern char gStartUpDir[];
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */

extern int gNumColorSchemes ;
extern char gColorBoxTitle[] ;
extern char *gCurrentColorTitle ;

BOOL gfFileMgrStartUp = FALSE ;
WORD fSwapButton;

#define SCREENCANCEL -3
#define SCREENOK -2
#define SCREENPREVIEW -1
BOOL gContinueScreens ; /* Whether to keep putting up the screen manager boxes */
WORD gscreenmode; /* mode the screen is in now */

int gScreenListInd; /* Index in the listbox (0 based) of Screen Mode that
							* we want to switch to.
							*/

char *gpszScreenModeTitle ;

int gNumScreenModes=0 ; /* Total number of screen modes supported by display */

ListBoxData ScreenModeList ;

/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

char far *gMouseStateSave;
BOOL DriverFound = TRUE;
WORD ReturnScreenMode;
BYTE StartupNumLines; // number of screen lines at startup

#define NUMISASUSED 31
COLORTABLEENTRY MonoColorTable[NUMISASUSED] =
{
  //background,foreground
  //remember that background bright is really blink!
  { coWhite,coBlack},//isaBackground
  { coBlack,coWhite},//isaHilite
  { coBlack,coWhite},//isaGreyed
  { coWhite,coBlack},//isaEnabled
  { coWhite,coBlack},//isaDisabled
  { coWhite,coBlack},//isaAlert
  { coWhite,coBlack},//isaDialogBox
  //{ coBlack,coWhite}, //isaPushButton
  { coBlack,coWhite},//isaPushButton
  { coBlack,coWhite},//isaButtonDown
  { 0,0},                               //isaListBox
  { coBlack,coWhite},//isaScrollbar
  { coWhite,coBlack},//isaElevator
  { coWhite,coWhite},//isaMenuBox
  { coWhite,coBlack},//isaMenu
  { coBlack,coWhite},//isaMenuSelected
  { coBlack,coWhite},//isaMenuHilite
  { coWhite,coBlack},//isaMenuHiliteSel
  { coBlack,coWhite},//isaItemHiliteSel
  { coWhite,coBlack},//isaDialogAccel
  { coWhite,coBlack},//isaDialogAccelBor
  { coBlack,coBlack},//isaShadow
  { coBlack,coWhite},//isaWhiteOnBlack
  { coWhite,coBlack},//isaBlackOnWhite
  { coBlack,coWhite},//isaTitlebar
  { coWhite,coBlack},//isaDriveicon
  { coWhite,coBlack},//isaDrivebox
  { coBlack,coWhite},   //isaFocus
  { coBlack,coBlack},   //isaBorders
  { coWhite,coBlack},//isahotlink
  { coWhite,coBlack},//isaShellMouse
  { coBlack,coWhite},//isaMessagebar
};


COLORTABLEENTRY TextColorTable[NUMISASUSED] =
{

  //background,foreground
  { coWhite+isBright,coBlack},                    //isaBackground
  { coBlue,coWhite+isBright},   //isaHilite
  { coBlue+isBright,coBlack+isBright},    //isaGreyed
  { coWhite+isBright,coBlack},                    //isaEnabled
  { coWhite+isBright,coWhite},                    //isaDisabled
  { coWhite+isBright,coRed+isBright},                     //isaAlert
  { coWhite+isBright,coBlack},                    //isaDialogBox
  { coBlue,coWhite+isBright},                     //isaPushButton
  { 0,0},                                 //isaButtonDown
  { 0,0},                                 //isaListBox
  { coBlack,coWhite+isBright},                    //isaScrollbar
  { coWhite,coWhite},   //isaElevator
  { coWhite+isBright,coBlack },                   //isaMenuBox
  { coWhite+isBright,coBlack},                    //isaMenu
  { coBlue,coWhite+isBright},                   //isaMenuSelected
  { coWhite+isBright,coCyan},                       //isaMenuHilite
  { coBlue,coCyan},               //isaMenuHiliteSel
  { coWhite+isBright,coCyan},             //isaItemHiliteSel
  { coBlack+isBright,coBlack},            //isaDialogAccel
  { coBlack+isBright,coBlack},            //isaDialogAccelBor
  { coWhite,coBlack+isBright},            //isaShadow
  { coBlack,coWhite+isBright},            //isaWhiteOnBlack
  { coWhite+isBright,coBlack},            //isaBlackOnWhite
  { coWhite,coBlack},                     //isaTitlebar
  { coWhite+isBright,coBlack},                    //isaDriveicon
  { coWhite+isBright,coBlack},             //isaDrivebox
  { coBlack,coWhite+isBright},             //isaSelect
  { coBlack,coBlack},            //isaBorders
  { coWhite+isBright,coCyan}, //isaHotLink
  { coCyan+isBright,coBlack}, //isaShellMouse
  { coWhite,coBlack},                     //isaMessagebar
};

#if 0
COLORTABLEENTRY GraphicsColorTable[NUMISASUSED] =
{
  //background,foreground
  { coWhite+isBright,coBlack},                    //isaBackground
  { coBlue,coWhite+isBright},   //isaHilite
  { coBlue+isBright,coBlack+isBright},    //isaGreyed
  { coWhite+isBright,coBlack},                    //isaEnabled
  { coWhite+isBright,coWhite},                    //isaDisabled
  { coWhite+isBright,coRed+isBright},                     //isaAlert
  { coWhite+isBright,coBlack},                    //isaDialogBox
  { coWhite+isBright,coBlue},                     //isaPushButton
  { 0,0},                                 //isaButtonDown
  { 0,0},                                 //isaListBox
  { coBlack,coWhite+isBright},                    //isaScrollbar
  { coWhite+isBright,coWhite+isBright},   //isaElevator
  { coWhite+isBright,coWhite+isBright },                          //isaMenuBox
  { coWhite+isBright,coBlack},                    //isaMenu
  { coBlue,coWhite+isBright},   //isaMenuSelected
  { coBlue,coWhite+isBright},                       //isaMenuHilite
  { coBlack+isBright,coBlack},            //isaMenuHiliteSel
  { coBlack+isBright,coBlack},            //isaItemHiliteSel
  { coBlack+isBright,coBlack},            //isaDialogAccel
  { coBlack+isBright,coBlack},            //isaDialogAccelBor
  { coWhite,coBlack+isBright},            //isaShadow
  { coBlack,coWhite+isBright},            //isaWhiteOnBlack
  { coWhite+isBright,coBlack},            //isaBlackOnWhite
  { coBlue,coBlack},                      //isaTitlebar
  { coBlack,coWhite},                     //isaDriveicon
  { coBlack+isBright,coBlack},             //isaDrivebox
  { coBlack,coWhite+isBright},             //isaSelect
  { coBlack,coBlack},            //isaBorders
  { coBlack+isBright,coBlack}, //isaHotLink
};

#endif

#define MAXSCREENMODE 16

WORD LinesToMode(WORD lines)
{
	int i;
	for(i=0; i<gNumScreenModes; ++i)
	if(sScreenMode[i].NumLines == (BYTE) lines)
	{
		return(sScreenMode[i].ModeInd);
	}
	return(ReturnScreenMode); // return known valid if none
}

TOKEN ModeMap(int mode)
{
	char tstr[MAXSCREENMODETITLE], *szWhichRes;
	TOKEN tkRes;
	int i;

	for(i=0; i<gNumScreenModes; ++i)
	if(sScreenMode[i].ModeInd == (BYTE)mode)
		break;

	if(m_fIsLowResMode(sScreenMode[i].NumLines))
	tkRes = TK_LOWRES;
	else if(m_fIsMedResMode(sScreenMode[i].NumLines))
	tkRes = TK_MEDIUMRES;
	else
	tkRes = TK_HIGHRES;

	if(!sScreenMode[i].Res_Ordinal)
	return(tkRes);
	else {
	strfcpy(tstr, Get_Token_Identifier(tkRes));
	for(szWhichRes=tstr; *szWhichRes!='\0'; ++szWhichRes) /* do nothing */ ;
	itoa(sScreenMode[i].Res_Ordinal, szWhichRes, 10);
	return(Get_Identifier_Token(tstr));
	}
}

VOID Set_DefaultColors(void)
{
	ISA i;
	COLORTABLEENTRY *colortable;

	static WORD oldshadow = -1;
	if(oldshadow == -1)
		oldshadow = diShadow;
	if(fMonochrome)
	{
		colortable = MonoColorTable;
	}
	else
	{
//          if(gisgraph)
//              colortable = GraphicsColorTable;
//          else
		   colortable = TextColorTable;
	}
	for(i=0;i<NUMISASUSED;i++)
	{
		SetIsaColor(i,colortable[i].foreground,
			  colortable[i].background);
	}
	if(gisgraph)
	{
		SetIsaColor(isaMenuBox,coWhite+isBright,coWhite+isBright);
	   SetIsaFfont(isaMenuHilite,ffontUnderline);
	   SetIsaFfont(isaMenuHiliteSel,ffontUnderline);
	   SetIsaFfont(isaItemHiliteSel,ffontUnderline);
	   diShadow = 0;    /* no character shadows in graphics mode ! */

	}
	else
	{
	   diShadow = oldshadow;
	}

}


VOID FAR InitCColor()
{
	Set_DefaultColors();
	gNthColorGroup=GetUserColorSelection();
	if(gNthColorGroup)
		SelectColorGroup(gNthColorGroup);

}

#if 0
VOID FAR InitGColor()
{
	int i;
	for(i=0;i<NUMISASUSED;i++)
	{
		SetIsaColor(i,GraphicsColorTable[i].foreground,
			  GraphicsColorTable[i].background);
	}
	SetIsaFfont(isaMenuHilite,ffontUnderline);
	SetIsaFfont(isaMenuHiliteSel,ffontUnderline);
	SetIsaFfont(isaItemHiliteSel,ffontUnderline);
	diShadow = 0;    /* no character shadows in graphics mode ! */

	SelectColorGroup(gNthColorGroup);
}
#endif

/* Returns a BOOL indicating whether the mode specified by "inst" is a mode
 * we want to be able to switch to in the SHELL. Modes with columns less
 * than 60 cols or > 90 columns are not modes we want to switch to.
 */
BOOL FIsModeOk(INST *inst)
{
   return ( (inst->finst & finstAvailable)  &&
				!(inst->finst & finstQuestionable) &&
				!(inst->finst & finstDisableMouse)      &&
				(inst->axMac >= 60) &&
				(inst->axMac <= 90)) ;

} /* FIsModeOk */


/*  NAME
 *  DESCRIPTION
 *  ARGUMENTS
 *  RETURN VALUE
 *  EFFECTS
 *  STATE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

/*  NAME
 *      SetScreenMode
 *  DESCRIPTION
 *      Changes the screen mode
 *  ARGUMENTS
 *      mode is the screen mode to switch to
 *  RETURN VALUE
 *      TRUE if successful
 *      FALSE otherwise
 *  EFFECTS
 *      Changes globals (above). Resets screen state.
 *  STATE
 *      Screen state is changed
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */
BOOL FAR SetScreenMode(WORD mode)
{
	if(mode == imodeUnknown)
		return(FALSE);

	if (gisgraph)
	{
		/* The following call is supposed to cause CW to free its old
		 * screen driver allocations. We shall be allocating new buffers
		 * below.
		 */
		TermGraphics();
	}

#ifdef KANJI
	if (gfScreenModeHasBeenSetOnce)
	{
		FreeInstBuffers(&ginst, FreeDriverMem) ;
	}
	if (!FQueryInst(&ginst, mode))
		return(FALSE);
	FAllocInstBuffers(&ginst, LpwAllocDriverMem, TRUE );
	gfScreenModeHasBeenSetOnce = TRUE ;
	gscreenmode = mode;
#else
	if (FQueryInst(&ginst, mode))
	{
		/* Free any driver memory allocated previously, if there was a previous
		 * case (i.e., this is not the first time we SetScreenMode()!
		 */
		if (gfScreenModeHasBeenSetOnce)
		{
			/* ZZZZZZZ */
			/* Use FreeInstBuffers() call to do this. This call was there
			 * when we were using an early version of CW. scottq had some
			 * warning next to it saying that it did not work properly
			 * and that it needed fixing. I don't want to de-stabilize the
			 * SHELL attempting to use it now. This is a good thing to do
			 * when we go to version 5.1 Note that we have a near memory
			 * allocation stuff in LpwAllocDriverMem and that we cannot
			 * free our near memory because we use it in a stack form!
			 */
			OurHackFreeDriverMem() ;
		}

		FAllocInstBuffers(&ginst, LpwAllocDriverMem, TRUE);
		gfScreenModeHasBeenSetOnce = TRUE ;
		gscreenmode = mode;
	}
	else
		return(FALSE);
#endif

	/* Screen mode is changing so clear the icon caches! */
	InitIconCache() ;

	inch = cinch;
#ifdef OLDCW
	if (!FInitScreen(&ginst))
		 return(FALSE);
#else
	HookISR10();  //called before screen info for slow mouse problem
					  //see asmutils.asm for details!
	if (!FInitScreen(&ginst,0))
	{
		  UnHookISR10();
		 return(FALSE);
	}
	//TURN mouse off during start-up
	//Don't use mouse init yet, since it will turn mouse on!
	FEnableMouse(FALSE);
#endif

	if (DriverFound && (FInitGraphics(&ginst,&gingd)))
	{
		gisgraph = TRUE;
		SetPrinting(FALSE);
	}
	else
	{
		CWIDTH = CHEIGHT = 1 ;
		gisgraph = FALSE;
	}
	UnHookISR10();

	InitCColor();
	if (gisgraph)
	{
		 chRightSide1 = ' ';
		 chRightSide2 = ' ';
		 chTopSide1             = ' ';
		 chBottomSide1          = ' ';
		 chLeftSide1            = ' ';
		 chRightSide1           = ' ';
		 chTopLeftCorner1       = ' ';
		 chTopRightCorner1      = ' ';
		 chBottomLeftCorner1    = ' ';
		 chBottomRightCorner1   = ' ';
		 chMiddleLeft1          = ' ';
		 chMiddleRight1         = ' ';
		 chTopSide2             = ' ';
		 chBottomSide2          = ' ';
		 chLeftSide2            = ' ';
		 chRightSide2           = ' ';
		 chTopLeftCorner2       = ' ';
		 chTopRightCorner2      = ' ';
		 chBottomLeftCorner2    = ' ';
		 chBottomRightCorner2   = ' ';
		 //chBullet             = ' ';
		 chMiddleDot            = ' ';
		 chScrollbar            = ' ';
		 chElevator             = ' ';
		 chShadowInit           = ' ';

	}
	else
	{
		 inch = cinch;
		 chTopSide1             = ' ';
		 chBottomSide1          = ' ';
	}
	if(gisgraph)
	   Set_KeyWord_Assignment(TK_SAVESTATE,TK_SCREENMODE,TK_GRAPHICS);
	else
	   Set_KeyWord_Assignment(TK_SAVESTATE,TK_SCREENMODE,TK_TEXT);
	/* Remember that Mode map is zero based */
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_RESOLUTION,ModeMap(mode));
	return(TRUE);
}


/*  NAME SelectScreenMode
 *  DESCRIPTION
 *      Figures out the appropriate screen mode to switch to on startup
 *      and fills in the INST structure passed to it.
 *  ARGUMENTS
 *      Pointer to an INST structure which holds information about the
 *      selected screen mode's capabilities.
 *  RETURN VALUE
 *      Mode selected to switch to.
 *  EFFECTS
 *      NONE
 *  STATE
 *      NONE
 *  COMMENTS
 *      This code needs a better way of determining which mode to go to
 *      This was changed to check for the number of lines requested directly
 *  WARNINGS
 *      The INST structure is filled in for the mode selected only, so
 *      you cannot just blow off the mode returned if you don't like it.
 *  HACKS
 *      Hard coded mode to switch to
 */

int FAR SelectScreenMode(INST *inst)
{
	int i, nRes, temp;
	char tstr[MAXSCREENMODETITLE], *szWhichRes, far *str;
	BOOL istext, fAnything;
	TOKEN tkRes;

	if(DriverFound) {
	istext = Get_KeyWord_Assignment(TK_SAVESTATE,TK_SCREENMODE)
		!= TK_GRAPHICS;

/* Get the resolution string */
	strfcpy(tstr, Get_Token_Identifier(Get_KeyWord_Assignment(TK_SAVESTATE,
		TK_RESOLUTION)));
/* Skip to the first numeric */
	for(szWhichRes=tstr; *szWhichRes!='\0' && (*szWhichRes<'0'
		|| *szWhichRes>'9'); ++szWhichRes) /* do nothing */ ;
/* Get the Res_Ordinal; 0 -> 1 in case there are many modes of a given res */
	nRes = atoi(szWhichRes);
	if(!nRes)
		nRes = 1;

/* Get the resolution name; default to HIGHRES */
/* This will actually find a match if one of the resolutions is a prefix
   of the requested resolution.  The next line is so that there is no match
   at the end of the requested string */
	*szWhichRes = '0';
	for(str=Get_Token_Identifier(TK_LOWRES), szWhichRes=tstr;
		*str==*szWhichRes; ++str, ++szWhichRes) /* do nothing */ ;
	if(!(*str))
		tkRes = TK_LOWRES;
	else {
		for(str=Get_Token_Identifier(TK_MEDIUMRES), szWhichRes=tstr;
			*str==*szWhichRes; ++str, ++szWhichRes) /* do nothing */ ;
		if(!(*str))
		tkRes = TK_MEDIUMRES;
		else
		tkRes = TK_HIGHRES;
	}

/* Look for the closest mode.  Order of importance is (high to low):
   text/graphics
   resolution name
   resolution number
 */
	do {
		fAnything = FALSE;
		do {
		for(i=gNumScreenModes-1; i>=0; --i) {
			temp = sScreenMode[i].fIsGraphicsMode;
			if((istext && temp) || (!istext && !temp)
				|| sScreenMode[i].Res_Ordinal > (BYTE) nRes)
			continue;
			if(fAnything)
			break;

			if(m_fIsLowResMode(sScreenMode[i].NumLines)) {
			if(tkRes == TK_LOWRES)
				break;
			} else if(m_fIsMedResMode(sScreenMode[i].NumLines)) {
			if(tkRes == TK_MEDIUMRES)
				break;
			} else {
			if(tkRes == TK_HIGHRES)
				break;
			}
		}
		} while(!fAnything && i==-1 && (fAnything=TRUE)) ;
/* fAnything gets set if we can't find any modes with the res name */
	} while(!istext && i==-1 && (istext=TRUE)) ;
/* Yes, I do mean istext=TRUE on the previous line, not == */
/* istext gets set if there are no graphics modes */

	i = (i == -1 ? ReturnScreenMode : sScreenMode[i].ModeInd);
	} else {
	i = ReturnScreenMode;
	}

	FQueryInst(inst, i);
	return(i);
}


/*  NAME GetTheScreenMode
 *  DESCRIPTION
 *      Figures out what screen mode the screen is in; or if the lowest
 *  one supported.
 *  ARGUMENTS
 *  RETURN VALUE
 *      Mode of screen.
 *  EFFECTS
 *      Sets global StartupNumLines to record number of lines to start
 *  Switcher apps in.
 *      NONE
 *  STATE
 *      NONE
 *  COMMENTS
 *  WARNINGS
 *  HACKS
 */

WORD FAR GetTheScreenMode()
{
	WORD themode;
	int i;

	themode = ImodeGuessCurrent();
	if(themode == imodeUnknown)
	{
		for(i=0; i < 16; i++)
		{
		  if ( FQueryInst(&ginst, i) && FIsModeOk(&ginst) )
		  {
			 StartupNumLines = ginst.ayMac;
			 themode = i;
			 break;
		  }
		}
	}
	else
	{
	if (FQueryInst(&ginst, themode))
	{
		  StartupNumLines = ginst.ayMac;
	}
	}
	return(themode);
}


void InitializeScreenManagerGlobals(void);



/*  NAME
 *      InitializeScreen
 *  DESCRIPTION
 *      Initializes the screen and the CW environment
 *      Which in turn sets up global state variables
 *      ...
 *  ARGUMENTS
 *      NONE
 *  RETURN VALUE
 *      TRUE if initialization is successful
 *      FALSE otherwize
 *  EFFECTS
 *      Heavy duty--takes over the screen, mouse, keyboard
 *      Initializes globals (above)
 *  STATE
 *      If return value is TRUE, program in ready to use all CW
 *      and screen operations. No state change if FALSE is returned.
 *  COMMENTS
 *      FInitCow may not be necessary, since it is old CW.
 *      RerrLoadCwDrv loads in the basics of the video driver,
 *      FLoadGsd loads in the graphics functions of the video driver.
 * WARNINGS
 *      NONE
 * HACKS
 *      Currently has hardcoded video driver name, looks only in
 *      current directory!!!
 *      draw a rectangle for no good reason
 */
BOOL FAR InitializeScreen(void)
{
	int ind ;
	char videodriver[MAX_PATH+1];
	TOKEN videodir;

	if (!FInitCow())
	{
		return(FALSE);
	}

	videodir = Get_KeyWord_Assignment(TK_SAVESTATE,TK_VIDEODIR);
	if(videodir < 0)
	{
		strcpy(videodriver,gStartUpDir);
		ind = gStartUpDirEnd ;
	}
	else
	{
		strfcpy(videodriver,Get_Token_Identifier(videodir));
		ind = strlen(videodriver);
	}
	/* be sure the path ends in '\' */
#ifdef DBCS
	if (videodriver[ind-1] != '\\' || CheckDBCSTailByte(videodriver,&videodriver[ind-1]))
#else
	if (videodriver[ind-1] != '\\')
#endif
	{
		videodriver[ind++] = '\\' ;
	}
	strcpy(videodriver+ind,szScreenDrv);


	if (!(RerrLoadCwDrv(videodriver) == 0))
	{
		DriverFound = FALSE;
		/* We use the internal default driver */
	}
	else
	{
		if (!FLoadGsd(videodriver))
		{
			DriverFound = FALSE;
			/* no graphics, aye! */;
		}
	}

	/* This call needs to be made after Initializing the screen -- i.e., 
	 * after loading any available screen driver.
	 */
	InitializeScreenManagerGlobals() ;

	ReturnScreenMode = GetTheScreenMode();

	gStartUpDir[gStartUpDirEnd]=0;
	gscreenmode = SelectScreenMode(&ginst);
	cinch = inch;

	if(gscreenmode!=3 && FQueryInst(&ginst, 3)) {
		HookISR10();  //called before screen info for slow mouse problem
					  //see asmutils.asm for details!
		FInitScreen(&ginst, 0);
		UnHookISR10();
	}
	SetScreenMode(gscreenmode);
	
	gfScreenModeChanged = TRUE ;



	return(TRUE);
}

void OurUnHookISR9(void)
{
	if (gfOurISR9Installed)
	{
		UnHookISR9() ;
		gfOurISR9Installed = FALSE ;
	}

} /* OurUnHookISR9 */
/*
 *      We are really exiting back to the parent command
 */
VOID SetUpExitToDos(void)
{
#ifndef NOLOADER
	realdma_ptr = GET_COMMAND_PTR();
	realdma_ptr[EXITPTROFFSET] = 0xFF;
#endif

}

/* Note that this function can be invoked from the Menu -- "Exit" of
 * Program Manager and all such functions accept no arguments!! Hence
 * we use the global variable gfEarlyExit
 */

extern void StoreFMState(void) ;
extern BOOL gTaskListEnabled;
extern ListBoxData TaskList;

VOID FAR DoExit(void)
{
#if 0
	int ind ;
#endif
	extern BOOL gfEarlyExit ;
	char *pExitDir ;
	char ExitDir[MAX_PATH+1] ;
	int dummylen ;

	/* If it is an early exit, GetNumItems() should not be called as that
	 * function pointer is not yet setup!
	 */
	if ((!gfEarlyExit) && (gTaskListEnabled) && (GetNumItems(&TaskList) > 0))
	{
		/* Tell the user that we can't exit with tasks swapped out */
		ShellMessageBox(szExitErrorTitle, szExitErrorMsg) ;
		return ;
	}

#ifdef KANJI
	TermKkc();
#endif

	SetUpExitToDos();

	if (!gfEarlyExit)
	{
		StoreFMState() ;

		if (gfSwapHandlerInstalled)
			RemoveSwapHandler() ;

		OurUnHookISR9() ;

		Set_KeyWord_Assignment(TK_SAVESTATE, TK_FORCEMONO, TK_UNKNOWN);
		
		pExitDir = gStartInDir ;

		if (gfFMVisited)
		{
			Tree2Path(listinfo[glob.FocusBox].tree,
					   listinfo[glob.FocusBox].files, ExitDir, &dummylen) ;
			pExitDir = ExitDir ;
		}
		/* WARNING Trees are toasted in 
		 * buffered_write_ini_file, don't do tree2path anymore!
		 */
		if(!Buffered_Write_Ini_File(TRUE))
		{
			ErrorCrit = 34; // don't allow idle to process
			ShellMessageBox(szNoIniTitle, szNoIniMsg1);
			ErrorCrit = 0xFF;
		}

		UnixChdir(pExitDir);

		SetScreenMode(ReturnScreenMode);

	EndScreen(TRUE);
	EndCow(TRUE);
	}

#if 0
	Beep() ;
	printf("Num Modes = %d\n", gNumScreenModes) ;
	for(ind = 0 ; ind < gNumScreenModes ; ind++)
	{
		printf("mode=%d, lines=%d, ord=%d, fgraphics=%d\n", 
															sScreenMode[ind].ModeInd,
															sScreenMode[ind].NumLines,
															sScreenMode[ind].Res_Ordinal,
														sScreenMode[ind].fIsGraphicsMode) ;

	}
#endif
	//DisableUMBS();
	 DTS_API_Exit();
	exit(0);
}

/* Initialize the globals that will be used by the Color Manager to change
 * screen colors.
 */
void InitializeColorManagerGlobals(void)
{
	TOKEN tokencolor ;

	/* Calculate and store the total number of available color schemes in
	 * "gNumColorSchemes". This is used by the color manager.
	 */
	tokencolor = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_COLOR);
	
	if(tokencolor < 0)
	{
		/* ZZZZZ This should never happen for good any correct INI file as
		 * we should have at least 1 color scheme! Maybe the default color
		 * scheme that the SHELL uses in cases COLORS is not set will
		 * cause this not to happen!
		 */
		gNumColorSchemes = 0;
	}
	else
		gNumColorSchemes = Get_List_Length(tokencolor);

	/* set the global variable for colorbox title now. It needs to be done
	 * just once for the color manager. So we do it now.
	 */
	strcpy(gColorBoxTitle, szCurrentScheme) ;
	
	/* gCurrentColorTitle is using the latter part of the space allocated
	 * to gColorBoxTitle. This saves the concatenation we need to do to
	 * create the color manager's listbox title, each time the color
	 * scheme changes!
	 */
	gCurrentColorTitle = gColorBoxTitle + strlen(szCurrentScheme) ;

} /* InitializeColorManagerGlobals */

/* For all the acceptable screen modes detected by us and stored in the
 * data structure "sScreenMode", update the "Res_Ordinal" field (this is the
 * resolution's ordinal number). If we have more than 1 screen mode with
 * say medium resolution, the one with lowest mode number gets the ordinal
 * number 1, the next one 2, etc. This will be used by the code that
 * changes screen modes to display strings like:
 * "Medium Resolution Graphics 1", "Medium Resolution Graphics 2", etc.
 */
void SetScreenModeOrdinals(void)
{
	/* The maximum ordinal values seen so far in low res text, med res text,
	 * high res text, low res graphics, med res graphics and high res graphics
	 * the elements with array subscript 0 is for graphics mode and 1 for text!
	 */
	BYTE lr_ord[2], mr_ord[2], hr_ord[2] ;
	int i ;

	/* Fast initialization of the two array elements (BYTE) to 0! */
	*((WORD *) lr_ord) = 0 ;
	*((WORD *) mr_ord) = 0 ;
	*((WORD *) hr_ord) = 0 ;

	/* Perform initial marking */
	for (i = 0 ; i < gNumScreenModes ; i++)
	{
		if (m_fIsLowResMode(sScreenMode[i].NumLines))
		{
			sScreenMode[i].Res_Ordinal= ++(lr_ord[sScreenMode[i].fIsGraphicsMode]);
		}
		else if (m_fIsMedResMode(sScreenMode[i].NumLines))
		{
			sScreenMode[i].Res_Ordinal= ++(mr_ord[sScreenMode[i].fIsGraphicsMode]);
		}
		else
			sScreenMode[i].Res_Ordinal= ++(hr_ord[sScreenMode[i].fIsGraphicsMode]);

	} /* for */

	/* Second pass for marking! In case there is just 1 low resolution mode
	 * say, we want to reset the ordinal value to 0. This is used by the
	 * list box routine in the screen mode changer to avoid displaying
	 * the ordinal value of 1, as there is anyway no 2 in this mode!
	 */
	for (i = 0 ; i < gNumScreenModes ; i++)
	{
		if (m_fIsLowResMode(sScreenMode[i].NumLines))
		{
			if (lr_ord[sScreenMode[i].fIsGraphicsMode] == 1)
				sScreenMode[i].Res_Ordinal = 0 ;
		}
		else if (m_fIsMedResMode(sScreenMode[i].NumLines))
		{
			if (mr_ord[sScreenMode[i].fIsGraphicsMode] == 1)
				sScreenMode[i].Res_Ordinal = 0 ;
		}
		else
		{
			if (hr_ord[sScreenMode[i].fIsGraphicsMode] == 1)
				sScreenMode[i].Res_Ordinal = 0 ;
		}
	} /* for */
} /* SetScreenModeOrdinals */

/* Detect all the acceptable modes supported by the current display and the
 * loaded driver (if any). Store the relevant information in the data
 * structure "sScreenMode".
 */
void InitializeScreenManagerGlobals(void)
{
	int i ;
	INST inst ;

	gNumScreenModes = 0 ;

	for (i = 0 ; i < MAX_SCREEN_MODES ; i++)
	{
		if ( FQueryInst(&inst, i) && FIsModeOk(&inst) )
		{
			/* The screen mode ordinals are set after this loop! */
			sScreenMode[gNumScreenModes].ModeInd = (BYTE) i ;
			sScreenMode[gNumScreenModes].NumLines = inst.ayMac ;
			sScreenMode[gNumScreenModes].fIsGraphicsMode = 
													(MyBOOL) !(inst.finst & finstText) ;
			gNumScreenModes++ ;
		}
	} /* for */
	SetScreenModeOrdinals() ;
} /* InitializeScreenManagerGlobals */


VOID Arrow(void);

extern WORD gListKeyDelay;
extern int FarToNearsz(char *, char far *, int);
extern VOID FirstMouseInit(void);

BOOL FAR InitializeShell(VOID)
{
	TOKEN tkTemp;
	RRC rrcClient ; /* temp */

	/* commandline overrides inifile */
	ParseCommandLine();

	/* The following call needs to be done before InitializeScreen() as that
	 * tries to set the screen color and that function needs the global
	 * "gCurrentTitle" to be set!
	 */
	InitializeColorManagerGlobals() ;

	/*
	 *      Initialize Character Windows environment
	 */
	if (!InitializeScreen())
		return(FALSE);

	Arrow(); /* be sure the mouse is an arrow! */

	/*
	 * CW actually sets up its critical error handler. We replace it now.
	 * Set up our critical error handler... Initially, we were setting our
	 * handler earlier and our handler never got control!
	 */
	SetCriticalsToFail();


	InitWindows(TRUE); /* Yes, we are calling this routine for the first time */

	AddChild(NULL, &MainWind);
	DoInitMenus();
	SetMenuKeys(VK_ALT,VK_F10);
	GetClientRrc(&MainWind,&rrcClient);

	// We need a pointer to an ARC, but RRCs and ARCs are isomorphic in struct!
	// So following cast is OK!
	SetGraphicArc((PARC)&rrcClient, TRUE);


	InitFileMgr();
	FirstInitTaskMan();

	if((tkTemp=Get_KeyWord_Assignment(TK_SAVESTATE, TK_LISTKEYDELAY)) < 0)
		gListKeyDelay = 0;
	else {
		char tstr[10];

		FarToNearsz(tstr, Get_Token_Identifier(tkTemp), sizeof(tstr));
		gListKeyDelay = atoi(tstr);
	}

	if((tkTemp=Get_KeyWord_Assignment(TK_SAVESTATE, TK_READUPDATEFREQ)) < 0)
		gReadUpdateFreq = DEFAULT_READ_UPDATE_FREQ;
	else {
		char tstr[10];

		FarToNearsz(tstr, Get_Token_Identifier(tkTemp), sizeof(tstr));
		gReadUpdateFreq = atoi(tstr);

		/* Do the following sanity check */
		if (gReadUpdateFreq <= 0)
			gReadUpdateFreq = DEFAULT_READ_UPDATE_FREQ ;
	}

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_BEEP) == TK_DISABLED)
		gBeeps_On = FALSE ;

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_SWAPMOUSE) == TK_ENABLED)
	{
		// ZZZZZZZZ The following API does not seem to exist.
		SwapMouseButton(TRUE) ;
	}

#ifdef KANJI
	AddChild(NULL, &wndKkcStatus);
	FInitKkc(&wndKkcStatus);
#endif

	if (Get_KeyWord_Assignment(TK_SAVESTATE,TK_STARTUP) == TK_FILEMGR)
	{
		gfFileMgrStartUp = TRUE ;
		DoFileMgr();
	}
	else
	{
	   InitializeStartPrograms();
	}

	FirstMouseInit();
	FInitMouseNest();
	//EnableUMBS();
	return(TRUE);
}


/* This is the function that gets control when user selects the Change Screen
 * menu item (Options.Display)!
 */
/* ZZZZZ Actually to save some code size, one can share code between the
 * ColorBox() and its subroutines with ScreenBox() and its subs. We can
 * actually use "ColorList" in place of "ScreenModeList" as these two
 * dialogs cannot be active at the same time!
 */
VOID ScreenBox(void)
{
	WORD savedscreenmode ;

	gContinueScreens = SCREENPREVIEW ;
	
	savedscreenmode = gscreenmode ;
	/* Loop until user selects OK or CANCEL button in the color manager dialog.
	 * The fn ColorDialog() modifies the global variable gContinueColors.
	 * OK translates to a value of 0, Cancel to -1 and a selection of the
	 * screen mode using mouse (double-click or keyboard "enter") translates
	 * to +1.
	 */
	while(gContinueScreens >= SCREENPREVIEW)
	{
		/* Put up screen manager dialog and set the global "gContinueScreens".
		 * Also, sets the variable "gScreenListInd" indicating which is the new
		 * mode that the user wants to be put into.
		 */
	   ScreenDialog();

		/* Draw the screen based on the user's chosen screen mode. Do this if
		 * user didn't choose CANCEL.
		 */

		/* If the user chooses a different screenmode and if he didn't choose
		 * CANCEL, redraw the screen based on new mode.
		 */
	   if ( (gContinueScreens >= SCREENOK) && 
					(sScreenMode[gScreenListInd].ModeInd != (BYTE) gscreenmode) )
	   {
			/* ZZZZZZ Is this InitCColor needed? */
			InitCColor() ;

			SetScreenMode(sScreenMode[gScreenListInd].ModeInd) ;
			InitWindows(FALSE);
			DrawScreen() ;
	   }
	}

	/* Did the user select "Cancel" to skip the screen mode change? If so, put
	 * him back in the original screen mode that he started the Change
	 * screens dialog in.
	 */
	if(gContinueScreens == SCREENCANCEL)
	{
		/* if the screen mode has changed, restore the original mode */
		if (savedscreenmode != gscreenmode)
		{
			/* ZZZZZZ Is this InitCColor needed? */
			InitCColor() ;

			SetScreenMode(savedscreenmode) ;
			InitWindows(FALSE);
			DrawScreen() ;
		}
	}

} /* ScreenBox */

/* This function returns the index of the screen mode within our array
 * of screen mode structures. "screenmode" is the screen mode that
 * CW passes to us when we query it about screen modes and it is the
 * same mode that we use to SetScreenModes.
 */
int GetScreenModeIndex(WORD screenmode)
{
	int j ;

	/* Locate the index "j" of the screen mode "screenmode"
	 * The index is the subscript into our array structure.
	 */
	for (j = 0 ; j < gNumScreenModes ; j++)
	{
		if (screenmode == sScreenMode[j].ModeInd)
			break ;
	}

	return j ;

} /* GetScreenModeIndex */


/* This function forms the "title" that will be displayed in the 
 * Screen mode change Listbox (within the dialog box).
 * The current screen mode is "gscreenmode". The string is of the form
 * "Graphics Mode (xx lines)" or "Text Mode (xx lines)".
 */
void FormCurrentScreenModeTitle(char *title)
{
	int i, j ;
	char *pszStr ;

	j = GetScreenModeIndex(gscreenmode) ;

	/* The screenmode must be a mode we have already detected */
	assert (j < gNumScreenModes) ;

	pszStr = (!sScreenMode[j].fIsGraphicsMode) ? szText : szGraphics ;

	strcpy(title, szCurrentMode) ;
	i = strlen(szCurrentMode) ;

	while (*pszStr && *pszStr!=' ')
	{
		title[i++] = *(pszStr++) ;
	}
	
	title[i++] = ' ' ;

	/* append the number of lines info */
	title[i++] = (char) LBRACKET_CHAR ;

	/* WARNING! Assuming that number of lines is always a 2 digit value! */
	title[i++] = (char) ('0' + sScreenMode[j].NumLines/10) ;
	title[i++] = (char) ('0' + sScreenMode[j].NumLines%10) ;
	title[i++] = ' ' ;
	
	pszStr = szLines ;
	while (*pszStr)
		title[i++] = *(pszStr++) ;

	title[i++] = (char) RBRACKET_CHAR ;

	title[i] = '\0' ;
	
} /* FormCurrentScreenModeTitle */


/* This function puts up the screen manager dialog box and depending on the
 * user's response (OK, CANCEL or direct mode selection) sets the global
 * variable "gContinueScreens" that is used by its caller to decide whether
 * to dismiss the screen manager dialogs or perform appropriate actions.
 */
VOID FAR ScreenDialog(void)
{
	TMC tmc;
	HCABscreen h ;
	char ScreenModeTitle[75] ;

	h = HcabAlloc(cabiCABscreen) ;

	if (!h)
	{
		OutOfMemory() ;
		return ;
	}
	InitCab(h,cabiCABscreen);

	FormCurrentScreenModeTitle(ScreenModeTitle) ;

	/* Store the pointer to title in this variable, so that the
	 * dialog procedure can access this.
	 */
	gpszScreenModeTitle = ScreenModeTitle ;

	SzToCab(h, szEnterButton, Iag(CABscreen, pszscreenEB));
	SzToCab(h, szCancelButton, Iag(CABscreen, pszscreenCB));
	SzToCab(h, szPreviewButton, Iag(CABscreen, pszscreenPB));

	tmc= MyTmcDoDlg(&dlgscreen,  h);

	switch (tmc)
	{
		case tmcOK:
			gContinueScreens = SCREENOK ;
			break ;

		case tmcCancel:
			gContinueScreens = SCREENCANCEL ;
			break ;

		// case tmcscreenpreview:
		default:
/* gContinueScreens should already be set to the scroll of the listbox */
			break ;
	} /* switch */

	FreeCab(h);

} /* ScreenDialog */

/* The total number of screen modes supported by the current display */
#define GetNumScreenModes() (gNumScreenModes)

/* The number of screen mode titles that will be visible at any point of
 * time in the screen mode listbox.
 */
#define SCREENMODEWINDOWSIZE 4

/*
 * fill in string "szScreenMode" with the ith screen mode permitted.
 * by the display -- 0 based.
 * A sample string is: "Low Resolution Graphics 1"
 */ 
VOID GetNthScreenModeString(int isz, char *szMode)
{
	char *pszStr ;
	int i ;

	i = 0 ;

	pszStr = (!sScreenMode[isz].fIsGraphicsMode) ? szText : szGraphics ;
	while (*pszStr)
		szMode[i++] = *(pszStr++) ;
	szMode[i++] = ' ' ;
	szMode[i++] = ' ' ;

	/* append the number of lines info */
	/* WARNING! Assuming that number of lines is always a 2 digit value! */
	szMode[i++] = (char) ('0' + sScreenMode[isz].NumLines/10) ;
	szMode[i++] = (char) ('0' + sScreenMode[isz].NumLines%10) ;
	szMode[i++] = ' ' ;

	pszStr = szLines ;
	while (*pszStr)
		szMode[i++] = *(pszStr++) ;
	szMode[i++] = ' ' ;
	szMode[i++] = ' ' ;

	if (m_fIsLowResMode(sScreenMode[isz].NumLines))
		pszStr = szLowResolution ;
	else if (m_fIsMedResMode(sScreenMode[isz].NumLines))
		pszStr = szMedResolution ;
	else
		pszStr = szHighResolution ;
	while(*pszStr)
		szMode[i++] = *(pszStr++) ;

	/* Append the ordinal value to the screen mode name, in case there is
	 * more than 1 mode with this resolution. A value of 0 implies that
	 * it is the lone mode with this resolution (in text/graphics)!
	 */
	if (sScreenMode[isz].Res_Ordinal != 0)
	{
		szMode[i++] = ' ' ;
		szMode[i++] = sScreenMode[isz].Res_Ordinal + (char) '0' ;
	}
	
	szMode[i] = '\0' ;
} /* GetNthScreenModeString */


/* This function draws the Screen Mode title string in the listbox. The
 * 'isz'th string (0 based) is to be drawn at (x, y) with color attribute
 * specified by 'bArg'.
 */
void  MakeScreenModeLine(RX x, RY y, WORD isz, WORD bArg)
{
	int i, len ;
	RX rxGraphics ;
	RY ryGraphics ;
	unsigned char ScreenModeStr[65]; /*65 > max length of any screen mode str*/
	unsigned char szScreenMode[MAXSCREENMODETITLE+1] ;

	GetNthScreenModeString(isz, szScreenMode);

	/* the '-2' handles the scroll bar width */
   len = Get_List_Rect(&ScreenModeList).axRight - 
								Get_List_Rect(&ScreenModeList).axLeft - 1 - gisgraph;


	/* Form the color scheme string "ColorString" padded nicely with blanks */
	 *ScreenModeStr = ' ' ;
	for(i=1; szScreenMode[i-1]; i++)
	{
		ScreenModeStr[i] = szScreenMode[i-1];
	}
	
	/* pad with blanks! */
	for(; i < len-3; i++)
	{
		ScreenModeStr[i] = ' ';
	}

	TextOut(ScreenModeList.pwd, x+2, y, ScreenModeStr, len-3,
				(bArg&TF_ISFOCUS) ? isaHilite : isaDialogBox);

	/* Graphics is done relative to top of screen -- i.e. in absolute
	 * co-ordinates and not wrt to a window!!
	 */
	rxGraphics = ScreenModeList.pwd->arcWindow.axLeft + x + 2 ;
	ryGraphics = ScreenModeList.pwd->arcWindow.ayTop + y    ;

	/* The FALSE in the param list forces fn DrawFocusMarker to always draw
	 * the focus box in graphics mode!!
	 */
	DrawFocusMarker(ScreenModeList.pwd, x+1, y, rxGraphics, ryGraphics,
								len-3, bArg & TF_ISFOCUS, FALSE, isaDialogBox) ;

} /* MakeScreenModeLine */


WORD PASCAL ListProcScreenModeList(WORD tmm, char *sz, WORD isz, TMC tmc, 
																WORD x, WORD y, WORD bArg)
{
	RX xval;

	UnReferenced(tmc) ;
	UnReferenced(x) ;

	xval = Get_List_Rect(&ScreenModeList).axLeft;
	switch (tmm) {
		case tmmCount:
			return GetNumScreenModes() ;

		case tmmGetItemString:
			GetNthScreenModeString(isz, sz);
			break ;

		case tmmDrawItem:
			if (isz < GetNumScreenModes())
			{
				if (bArg & TF_ISFOCUS)
				{
					gScreenListInd = isz ;
				}
				MakeScreenModeLine((RX) xval, (RY) y, isz, bArg) ;
			}
			break;

		case tmmActivate:
			if (isz >= GetNumScreenModes())
				return 0 ; /* garbage value */

			gScreenListInd = isz ;
			EndDlgTmc(tmcOK) ;
			break ;
		case tmmSetFocus:
			// be sure we update the previous line, since we draw the focus
			// ignoring the bArg field
			// start at zero, since mouse clicks can be discontigous!
			InsertListItem(&ScreenModeList,0);
		break;
		case tmmSelect:
		case tmmToggleSelect:
			/* Never draw on a select, only mark selections! */

		case tmmDeselectAll:
		default:
			break;
	}
	return TRUE;
} /* ListProcScreenModeList */


/* The PfnFunction that first sees the characters, etc when focus is on the
 * "picture" item of the dialog box (our listbox)
 */
LONG FAR PASCAL pfnScreenModeList(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	UnReferenced(pwnd) ;

	switch(message)
	{
		case WM_CHAR:
			/* pass on the special characters to CW -- returning FALSE does this*/
			if ( (wParam == '\t') || (wParam == ESCAPE) || (wParam == VK_ESCAPE) )
				return(FALSE);

			ListKey(&ScreenModeList,wParam, HIWORD(LParam));
			break;

	  case WM_KILLFOCUS:
		GlobalFocusBox(&ScreenModeList,FALSE);
			break;
				
		case WM_SETFOCUS:
		GlobalFocusBox(&ScreenModeList,TRUE);
		   break;
						
	case WM_PAINT:
	UpdateListBox(&ScreenModeList);
	break;
	} /* switch */

	return(TRUE);
} /* pfnScreenModeList */
		
		
/* Dialog procedure for the screen mode manager. */
BOOL FAR PASCAL FDlgscreen(WORD dlm, TMC tmc, WORD wNew,
												WORD wOld, WORD wParam)
{
	PWND dwind, lwind ;
	WORD mx, my ;
	static BOOL fListBoxInited ;

	UnReferenced(tmc) ;

	dwind = PwndParent(PwndOfListbox(tmcOK));

	switch (dlm)
	{
		case dlmInit:
			/* Initially focus is on the enter button! */
			gCurrentTMC = tmcOK ;

			fListBoxInited = FALSE ;

			SetUpDialog(tmcOK, szChangeScreenModesCaption);

			SetUpButtonForGraphics(tmcOK);
			SetUpButtonForGraphics(tmcCancel);
			SetUpButtonForGraphics(tmcscreenpreview);

			lwind = PwndOfListbox(tmcscreenlist) ;

		   /* We don't want to draw focus cursor in the attr listbox window */
		   EnableCursor(lwind, FALSE) ;

			/* Initially set the focus to be on the listbox */
			SetFocusTmc(tmcscreenlist) ;

		   SetWindowProc(lwind,pfnScreenModeList);

			gScreenListInd = GetScreenModeIndex(gscreenmode) ;
			/* The screenmode must be a mode we have already detected */
			assert (gScreenListInd < gNumScreenModes) ;

			ListBoxInit(&ScreenModeList,ListProcScreenModeList,dwind,
				lwind->arcWindow.ayTop -dwind->arcWindow.ayTop,
			lwind->arcWindow.axLeft-dwind->arcWindow.axLeft,
				lwind->arcWindow.ayTop-dwind->arcWindow.ayTop+SCREENMODEWINDOWSIZE+1,
			lwind->arcWindow.axRight-dwind->arcWindow.axLeft+1,
			gpszScreenModeTitle, tmcscreenlist, gScreenListInd, gScreenListInd);

			Set_List_Color(&ScreenModeList, isaDialogBox) ;

			/* Prevent drawing of the list box until dialog is put up! */
			Halt_Listbox(&ScreenModeList) ;

		   /* Initially the focus is in the listbox */
		   GlobalFocusBox(&ScreenModeList, TRUE);
			break ;

		case dlmSetFocus:
			gCurrentTMC = tmc;
			break ;

		case dlmIdle:
			if (!fListBoxInited)
			{
				fListBoxInited = TRUE ;
				UnHalt_Listbox(&ScreenModeList) ;
				if(gContinueScreens != SCREENPREVIEW)
					DoScrollListBox(&ScreenModeList,
							gContinueScreens-Get_List_Scrolled(&ScreenModeList),
							FALSE);
				ListBoxIdle(&ScreenModeList) ;
			}
			ListBoxIdle(&ScreenModeList);
		break;

		case dlmClientMouse:
			dwind = PwndParent(PwndOfListbox(tmcOK));
			my = HIBYTE(wParam);
			mx = LOBYTE(wParam);
			if (ListMouse(&ScreenModeList, mx, my, wNew, wOld))
			{
				/* If user clicked on the listbox, make it the focus */
				SetFocusTmc(tmcscreenlist);
			}
			break;

		case dlmTerm:
			gContinueScreens = Get_List_Scrolled(&ScreenModeList);
			break;
	} /* switch */

   return(TRUE);
} /* FDlgscreen */


#ifdef  KANJI
STATIC LONG FAR PASCAL
KkcStatusWndProc(pwnd, message, wParam, lParam)
/*
  -- Wnd proc for KK converter Status window
*/
PWND       pwnd;
WORD       message;
WORD       wParam;
DWORD      lParam;
{
	RRC rrc;

	UnReferenced(wParam);
	UnReferenced(lParam);

	if (message == WM_PAINT)
		{
		GetClientRrc(pwnd, &rrc);
		if (fKkcAvailable && fKkcEnabled)
			{
			TextOutAttrX(pwnd, 0, 0, NULL,
				kkcv.lpchSystem, kkcv.lpattrSystem, kkcv.cchSystem, -1);
			rrc.rxLeft = (RX) kkcv.cchSystem;
			}
		if (fKkcEnabled && FActiveKkc())
			FillRrc(pwnd, &rrc, ' ', isaBackground);
		else if (!fKkcEnabled || !FActiveKkc())
			MessageBar(gpszNonSwap, isaMenu,TRUE);
		}
	return 0L;
}

VOID FARPUBLIC
UpdateShiftKj(kjNew, kjOld)
/*
  -- this routine is called by CW to update shift states
*/
WORD    kjNew, kjOld;
{
#if 0
	WORD    kjDelta = kjNew ^ kjOld;

	if (kjDelta & KJ_KANA)
	{
		fKanaAccel = !fKanaAccel;
		DrawMenuBar();
	}
#endif
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\launch.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <associat.hs>
#include <associat.sdm>
#include <assoc2.hs>
#include <assoc2.sdm>
#include <run.hs>
#include <run.sdm>
#include <text.h>
#include <help.h>
#include <ctype.h>
#include <tasklist.h>

/* The length of the EXT list string when one is typing in a list of
 * associations separated by space(s). We have placed a limit of 20 EXTs
 * per program -- arbitrary limit. 79 = 20*3 + 19. 3 is the MAX size
 * of an extension and 19 is the number of spaces between them.
 */

#define ASSOC_EXT_LEN 79 


extern void OurUnHookISR9(void) ;
extern VOID StoreFMState(void) ;
extern TOKEN Get_Identifier_Token(char far *identifier); 
extern VOID ReInitTaskParams(void);
extern VOID FarToNearsz(char *temp, char far *str, int max);

extern TOKEN gNext_Task_Info;
extern char gNext_Task_Name[MAX_TITLE+2];
extern BOOL gfFMVisited ;
extern BOOL gfOurISR9Installed ;

extern int cdecl chdir (char *path) ;
extern void RemoveSwapHandler(void) ;
extern BOOL Buffered_Write_Ini_File(BOOL bFreeFM) ;
extern BOOL FIsExecutableFile(char far *ext) ;

extern WORD ReturnScreenMode;
extern char gStartUpDir[];
extern char gStartInDir[];
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */

extern char *QStatus ; /* re-use of variable to pass status line */

extern TMC gCurrentTMC;
extern char userPrompt[];
extern BOOL gTaskListEnabled;
extern BOOL gSwitchingEnabled; 
extern BOOL gfSwapHandlerInstalled;


PENTRY GetSelectedNode(PENTRY firstfile)
{
	PENTRY node;
	node = firstfile;

	 while (node != NULL)
	 {
		 if (node->SELECTED)
			 break;
		 node = node->x.f.snext;
	 }
	 return(node);
}

/****   fstrncmp - compares far to far string
**
**      ENTRY
**              nstr - string in far memory
**              fstr  - string in far memory
**              len  - maximum length to check
**      EXIT
**              0 if equal, 1 if not
*/
int fstrncmp(nstr, fstr, len)
const char far *nstr;
const char far *fstr;
int len;

{
	int i;

	for (i=0; i < len && *fstr == *nstr && *nstr; i++, fstr++, nstr++)
		;
	if (i != len && *nstr != *fstr)
		return 1;
	else
		return 0;
}

VOID strfcat(char far *dest,char far *src)
{
	while(*dest)
	dest++;
	strfcpy(dest,src);
}

/* Delete existing associations of 'name' from the association list.    */
/* 'isprog' == TRUE means that name is a program name, else it is an    */
/*      extension name. 'name' is a string without any enclosing quotes!        */
VOID Delete_Associations(char *name, BOOL isprog)
{
	char far *tname;
	int i,j;
	TOKEN tokenassoc;
	TOKEN token_prog_ext;
	TOKEN tokentemp;

	tokenassoc = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS);
	token_prog_ext = TK_UNKNOWN;

	if (!((tokenassoc == TK_UNKNOWN) || (tokenassoc == TK_NOTHING)))
	{
	/* delete any existing associations for this program or extension */
	j = Get_List_Length(tokenassoc);
	for(i=1;i<=j;i++)
	{
	   tokentemp = Get_Symbol_Value(Token_To_Symbol(
		Get_Ith_Element(tokenassoc,i)));
	   token_prog_ext = (isprog) ? 
							Get_KeyWord_Assignment(tokentemp,TK_PROGRAM) :
							Get_KeyWord_Assignment(tokentemp,TK_EXT) ;

	   tname = Get_Token_Identifier(token_prog_ext);
	   /* If program name matches delete the existing association */
	   if (fstrncmp(tname, name, 66) == 0)
	   {
			Delete_Ith_Element(tokenassoc,i);

			/* An extension can be associated with only 1 program -- So if */
			/* we have deleted one entry, then we are done. On the other   */
			/* hand, a program can be associated with more than 1 extension */
			if (!isprog)
				return ;

			--j;
			--i;
	   }
	} /* for */
	} /* if */
} /* Delete_Associations */


/*
 * Returns the program associated with the extension -- in FM Internal format
 */

#define NOEXT_CHAR '.'  // The char denoting file with no extension.

char far *Get_Association(char far *extension)
{
	TOKEN tokenassoc;
	TOKEN tokenext;
	TOKEN tokenprog;
	TOKEN tokentemp;
	int i,j;
	char ext[EXTLEN+1];

	/* If file has an extension, move it into 'ext', else use the string "." */
	if (*extension)
	{
		ext[0] = extension[0];
		ext[1] = extension[1];
		ext[2] = extension[2];
	ext[3] = 0;
	}
	else
	{
		ext[0] = (char) NOEXT_CHAR ;
		ext[1] = '\0' ;
	}

	tokenassoc = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS);
	tokenprog = TK_UNKNOWN;

	if ((tokenassoc == TK_UNKNOWN) || (tokenassoc == TK_NOTHING))
		return(NULL);

	j = Get_List_Length(tokenassoc);
	for(i=1;i<=j;i++)
	{
		tokentemp = Get_Symbol_Value(Token_To_Symbol(
		Get_Ith_Element(tokenassoc,i)));
		tokenext = Get_KeyWord_Assignment(tokentemp,TK_EXT);
		if (fstrncmp(Get_Token_Identifier(tokenext),(char far *) ext,3) == 0)
		{
			tokenprog = Get_KeyWord_Assignment(tokentemp,TK_PROGRAM);
			break;
		}
	}
	if((tokenprog==TK_UNKNOWN) || (tokenprog == TK_NOTHING))
		return(NULL);

	return(Get_Token_Identifier(tokenprog));
}


/* Makes an association between 'program' and 'extension' and adds it to */
/* the association list. It is the caller's responsibility to delete any */
/* pre-existing associations if that is desired.                                                 */
VOID Make_Association(char *program, char *extension)
{
	TOKEN tokenassoc;
	TOKEN tokentemp;
	TOKEN tokennewassoc;
	TOKEN tokennewprogram;
	TOKEN tokennewext;
	TOKEN listtemp;

	tokenassoc = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS);
	if(tokenassoc < 0) // no association section defined yet
	{
		Set_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS,TK_SPECIAL);
		tokenassoc = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS);
	}

	if((tokennewassoc=SubClassSymbol(TK_ASSOCIATION))<=0 ||
		(listtemp=SubClassSymbol(tokennewassoc))<=0 ||
		(tokennewprogram=SubClassSymbol(TK_PROGRAM))<=0 ||
		(tokennewext=SubClassSymbol(TK_EXT))<=0)
		return;

	tokentemp = Get_Identifier_Token(program);
	Set_Symbol_Value(Token_To_Symbol(tokennewprogram),tokentemp);

	tokentemp = Get_Identifier_Token(extension);
	Set_Symbol_Value(Token_To_Symbol(tokennewext),tokentemp);

	Append_Symbol(listtemp,tokennewprogram);
	Append_Symbol(listtemp,tokennewext);
	Set_Symbol_Value(Token_To_Symbol(tokennewassoc),listtemp);

	Append_Symbol(tokenassoc,tokennewassoc);
} /* Make_Association */

/*Makes the association of 'program' with each of the extensions in 'extlist'*/
/* 'program' is the full path name -- example C:\XENIX\BIN\VI.EXE                       */
VOID Make_Association_List(char *program,char *extlist)
{
	char ext[5] ;
	int k ;

	/* Perform the assciation for each extension in the extension list */
	while (TRUE)
	{
		while (isspace(*extlist)) 
			extlist++ ; /* This loop skips all leading white space */

		if (*extlist)
		{
			/*  Use only the first 3 characters -- need to ignore rest! */
			for (k = 0 ; k < 3 ; k++)
			{
				if ( (!isspace(*extlist)) && (*extlist) )
					ext[k] = *extlist++ ;
				else
					break ; /* extension is < 3 characters long! */
			}
			ext[k] = '\0' ;
			/* Delete any prev associations for extension 'ext' */
			Delete_Associations(ext, FALSE) ;

			Make_Association(program, ext) ;

			/* Now look for the white space character terminating this      */
			/* extension -- i.e., ignore extra spurious input chars         */
			while ( (!isspace(*extlist))  && (*extlist) )
				extlist++ ;
		}
		else
			break ; /* All extensions in extension list exhausted */
	} /* while */
} /* Make_Association_List */

/*
 * Returns a list of extensions associated to program name in list
 */
VOID Get_Association_List(char far *name,char far *list)
{
	TOKEN tokenassoc;
	TOKEN tokenext;
	TOKEN tokenprog;
	TOKEN tokentemp;
	int i,j;
	char far *progname ;

	list[0] = 0;
	tokenassoc = Get_KeyWord_Assignment(TK_PROGRAMSTARTER,TK_ASSOCIATIONS);
	tokenprog = TK_UNKNOWN;

	if ((tokenassoc == TK_UNKNOWN) || (tokenassoc == TK_NOTHING))
	return;
	j = Get_List_Length(tokenassoc);
	for(i=1;i<=j;i++)
	{
	   tokentemp = Get_Symbol_Value(Token_To_Symbol(
		Get_Ith_Element(tokenassoc,i)));
	   tokenprog = Get_KeyWord_Assignment(tokentemp,TK_PROGRAM);

	   /* ZZZZ We actually need fstrcmpi. It would be nice to have the
			parser routines to store stuff in its data structs only in
			upper-case! -- Prevents case insensitive compares!! */
	   progname = Get_Token_Identifier(tokenprog) ;

	   /* A large number > path lenth takes care of compare till EOS!! */
	   if(fstrncmp(progname, name, 90) == 0)
	   {
		tokenext = Get_KeyWord_Assignment(tokentemp,TK_EXT);

		strfcat(list,Get_Token_Identifier(tokenext));
		strfcat(list," ");
	   }
	}
}

#ifndef NOLOADER
char far *realdma_ptr;
#endif

/* fstrncpy() -
**
** DESCRIPTION
**      Copies exactly len bytes from far null-terminated source string 
**      to destination string.
*/
void fstrncpy(d, s, len)
unsigned char far *d;
unsigned char far *s;
unsigned int    len;
	{
	while (len--)
		*d++ = *s++;
	}

#ifndef NOSWITCHER
extern WORD gScanInfo;


VOID AdjustTaskTitle(char far *dest,char far * title)
{
	int i,j;
	int len;              
	Switch_Entry far *SE;
	char temp[MAX_TITLE+MAX_NUM_PROGRAMS+16]; 


/* The following makes sure the length is at most MAX_TITLE-1 long */
	FarToNearsz(temp, title, MAX_TITLE);

	len = C_GET_LIST_LENGTH();
	i=0;
	while(i<=len)
	{
		SE = (Switch_Entry far *) C_GET_ITH(i);
		for(j=0;temp[j] && (SE->Program_Title[j] == temp[j]);)
			++j;
		if(temp[j]==SE->Program_Title[j])
		{
			//strings are equal
			if(j >= MAX_TITLE-5) // 5 chars for hot-key
				break; // do not extend past max title
			temp[j] = '.';
			temp[j+1] = 0;

			i=0;
		}
		else
		{
			++i;
		}

	}
	/* be sure the destination is cleared with NULLS so old hotkey
	 * stuff doesn't get included!
	 */
	for(i=0;i<MAX_TITLE;i++)
		dest[i] = 0;
	strfcpy(dest,temp);
   
}

BOOL AddTask(char far *programname, char far *parameters,char far *defaulttitle,TOKEN properties,WORD magiccookie)
{
	char szErrorMessage[150];

	   Switch_Entry far *SE;
		TOKEN token;
		char temp[12];
		char far *title;
		WORD hotkey;
		int len,tlen;

		if((programname && programname[0]) && (C_GET_LIST_LENGTH() >= MAXTASKS))
		{
			/* BUGBUG HID! */
		strcpy(szErrorMessage, szSwitchFailed);
		strcat(szErrorMessage, "\n");
		strcat(szErrorMessage, szTooManyTasks);
			ShellMessageBox(szSwitchErrTitle, szErrorMessage);                      
			return(FALSE);  //did not succeed in adding task
		}
		if((programname) && (programname[0]))
		{
		C_ADD_PROGRAM((char far *) programname);
		C_ADD_PARAMS(parameters,myfstrlen(parameters));

		SE = (Switch_Entry far *) C_GET_ITH(0);
		AdjustTaskTitle(SE->Program_Title,defaulttitle);
		//strfcpy(SE->Program_Title,defaulttitle);

			SE->Shell_Cookie = magiccookie;


			token = Get_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE);
			if(token == TK_DISABLED)
		 SE->Program_Flags |= F_NO_PAUSE;
			else
				 SE->Program_Flags &= ~F_NO_PAUSE;


			/* Here is where we set up the parameters in the 
			 * global data structure for the initial launch of
			 * a program item
			 */
			if(properties > 0)
			{
				token = Get_KeyWord_Assignment(properties,TK_TITLE);
				if(token > 0)
					title = Get_Token_Identifier(token);
				else
					title = NULL;
				if(title && title[0])
				{
					/* We will also add in the hot key sequence if it will fit */
				AdjustTaskTitle(SE->Program_Title,title);
					tlen = myfstrlen(SE->Program_Title);
					token = Get_KeyWord_Assignment(properties,TK_SHORTCUT);
					if(token>0)
					{
						title = Get_Token_Identifier(token);
						len = myfstrlen(title);
						/* we save the hot-key after the name's null */
						if(tlen+len < MAX_TITLE - 4) //+3  for parens + 1 for NULL
						{
							strfcpy(&SE->Program_Title[tlen+1]," (");
							strfcpy(&SE->Program_Title[tlen+3],title);
							strfcpy(&SE->Program_Title[tlen+3+len],")");
						}
					}
		
				}

				token = Get_KeyWord_Assignment(properties,TK_KBREQUIRED);
				if(token>0)
					title = Get_Token_Identifier(token);
				else
					title = NULL;
				if(title && title[0])
				{
					fstrncpy(temp,title,12);
					SE->Conv_Req = atoi(temp);
				}
				else
				{
						SE->Conv_Req = 0;
				}

				token = Get_KeyWord_Assignment(properties,TK_XMSREQUIRED);
				if(token>0)
					title = Get_Token_Identifier(token);
				else
					title = NULL;
				if(title && title[0])
				{
					fstrncpy(temp,title,12);
					SE->XMS_Req = atoi(temp);
				}
				else
				{
					SE->XMS_Req = 0;
				}

				token = Get_KeyWord_Assignment(properties,TK_XMSLIMIT);
				if(token > 0)
					title = Get_Token_Identifier(token);
				else
					title = NULL;
				if(title && title[0])
				{
					fstrncpy(temp,title,12);
					SE->XMS_Want = atoi(temp);
				}
				else
				{
					SE->XMS_Want = 0;
				}

				token = Get_KeyWord_Assignment(properties,TK_SCREENMODE);
				if(token == TK_GRAPHICS)
					SE->Program_Flags |= F_GRAPHICS;

				token = Get_KeyWord_Assignment(properties,TK_ALTTAB);
				if(token == TK_DISABLED)
					SE->Program_Flags |= F_NO_ALT_TAB;
				token = Get_KeyWord_Assignment(properties,TK_ALTESC);
				if(token == TK_DISABLED)
					SE->Program_Flags |= F_NO_ALT_ESC;
				token = Get_KeyWord_Assignment(properties,TK_CTRLESC);
				if(token == TK_DISABLED)
					SE->Program_Flags |= F_NO_CTRL_ESC;
				token = Get_KeyWord_Assignment(properties,TK_PREVENT);
				if(token == TK_ENABLED)
					SE->Program_Flags |= F_NO_SWITCH;

		token = Get_KeyWord_Assignment(properties,TK_SHORTCUTCODE);
				if(token > 0)
				{
					title = Get_Token_Identifier(token);
					hotkey = 0;
					if(title[0])
					{
						fstrncpy(temp,title,12);
						hotkey = atoi(temp);
					}
					SE->HK_Scan_Code_1 = (BYTE) (hotkey&0x1000?0x0E0:0); // tell switcher its on the extended keyboard
					SE->HK_Scan_Code_2 = LOBYTE(hotkey);
					SE->HK_Shift_State = HIBYTE(hotkey)&0x0F;       //hi nibble is special extended signature
				}
			}
		}
		else
		{

			/* alt-tabing to next guy in the list */
			C_GO_Z_NEXT();
			/* If the program has not been run yet, we must set up the parameters
			* again. So we use RestartTask.
			*/
   
			SE = (Switch_Entry far *) C_GET_ITH(0);
			if(SE->Program_Id == 0)
				ReInitTaskParams();

		}
		return(TRUE);

}

#endif
VOID LaunchProgram(char far *programname,char far *parameters,int magiccookie)
{
#if 0
		Switch_Info far *switchdata;
		int i;
#endif
#ifndef NOLOADER
	   int ind ;
#ifndef NOSWITCHER
	if(glob.InFileMgr)
	   DoSwapOut();

	if(gSwitchingEnabled)
	{
		/* add the program we are about to run to the global
	   * task list
	   */
		if (!AddTask(programname,parameters,gNext_Task_Name,gNext_Task_Info,magiccookie))
			return;
		/* we let the switcher do the pausing if it is around*/
		Set_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE,TK_DISABLED);
	 
	   ind = gStartUpDirEnd ;
#ifdef DBCS
	   if (gStartUpDir[ind-1] != '\\' || CheckDBCSTailByte(gStartUpDir,&gStartUpDir[ind-1]))
#else
	   if (gStartUpDir[ind-1] != '\\')
#endif
	   {
		 gStartUpDir[ind++] = '\\' ;
	   }
		strcpy(gStartUpDir+ind,szSwitcher);
		strfcpy(programname,(char far *)gStartUpDir);
	   parameters = szSwitcherMagic;
		gStartUpDir[gStartUpDirEnd]=0;
	}
	else
	{
#if 0
WE CANNOT DO THIS BECAUSE THE SWITCHDATA IS NO LONGER RESIDENT!
		/*  BUG BUG
		 * We still need to save the magic cookie, so we can delete the
	   * damn batch file
	   */

		switchdata = C_GET_GLOBAL_SWITCH_DATA();
		for(i=0;i<MAX_NUM_PROGRAMS;i++)
		{
			if(switchdata->Program_list[i].Program_Flags & F_FREE)
			{
				switchdata->Program_list[i].Shell_Cookie = magiccookie;
				break;
			}
		}
#endif
	}
#endif


	   realdma_ptr = GET_COMMAND_PTR();
	   fstrncpy((char far *)realdma_ptr,programname,64);
	   realdma_ptr = GET_ARGS_PTR();

	   fstrncpy((char far *)realdma_ptr+2,(char far *)parameters,53);
	   realdma_ptr[0] = (char) myfstrlen(parameters)+1;
	   realdma_ptr[1] = ' ';
	   realdma_ptr[myfstrlen(parameters)+2] = '\r';

		/* Store the FM state variables in the INI parsed variables so that they
		 * get written out to the INI file when we launch a program.
		 */ 
		StoreFMState() ;

	if(!Buffered_Write_Ini_File(TRUE))
	{
		ShellMessageBox(szNoIniTitle, szNoIniMsg1);
	}

	   /* Warning! can't make the following call after EndCow() etc as that guy will
		 * do an UnHookIS9() and the order in which we unhook will be messed
		 * up and the keyboard could lock up!!
		 */
		OurUnHookISR9() ;

	   // chdir(gStartInDir);  // DoCommand() sets the correct start up directory.
#ifdef KANJI
	TermKkc();
#endif
	   SetScreenMode(ReturnScreenMode);
	   FEnableMouse(FALSE);
	   EndScreen(TRUE);
	   EndCow(TRUE);
		if(gfSwapHandlerInstalled)
			RemoveSwapHandler() ;
	   //DisableUMBS();
	   exit(0);
#endif
}

PENTRY glaunchnode ; // File node to be launched.
PTREE glaunchtree ; // the tree to which above node belongs. This value is valid
					// only if glaunchNode is non-NULL!

/* Following specifies whether fn 'LaunchBox' was invoked from the menu or
 * thru a 'DoubleClick' on file -- i.e., an activate message!
 */
BOOL gfActivate = FALSE ;

VOID FAR LaunchBox(void)
{

	char programstring[256];
	char associated[80];
	char LaunchInDir[MAX_PATH+1];
	int dummylen ;

	char far * progrun;

	if (!gfActivate)
	{
		if (listinfo[glob.FocusBox].tree->NumSel > 0)
		{
			glaunchtree = listinfo[glob.FocusBox].tree ;
			glaunchnode = GetSelectedNode(glaunchtree->FirstFile);
		}
		else
			glaunchnode = NULL ;
	}
	else
	{
		/* We entered this fn from an Activate message in file listbox
		 * In this case, glaunchnode, glaunchtree are already set correctly
		 */
		gfActivate = FALSE ; // set it back to default state!!
	}
	if (glaunchnode)
	{
		progrun = Get_Association(glaunchnode->name+NAMELEN);
		if (progrun == NULL)
		{
		   /* File has no association with it! -- Is file not an executable
			* file (.COM, .EXE, or .BAT)? If it is a non-executable should
			* I beep at user as a warning?
			* ZZZZZ should a dialog box warn the user? -- a painful user
			* interface.
			*/
		   if (!FIsExecutableFile(glaunchnode->name+NAMELEN))
		   {
				Shell_Beep() ;
				return ;
		   }

		   Tree2Path(glaunchtree, glaunchnode, programstring, &dummylen);
		   associated[0] = NULL;
		}
		else
		{
		   strfcpy(programstring,(char far *)progrun);
		   Tree2Path(glaunchtree,glaunchnode,associated, &dummylen);
		}
		/* program string holds name of program, associated holds
		 * argument file name (association)
		 */

		strcat(programstring," ");
		strcat(programstring,associated);
		/*
		 * Always pause after file manager launch...
		 */
		Set_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE,TK_ENABLED);
		userPrompt[0] = 0;

		/* Note that LaunchBox can be called only from within the FM
		 * with a file in file listbox! SO FocusBox will be OK!
		 */
		Tree2Path(listinfo[glob.FocusBox].tree, listinfo[glob.FocusBox].files,
														 LaunchInDir, &dummylen) ;
		//DoCommand(programstring, gStartInDir);
		DoCommand(programstring, LaunchInDir);
	}
	else
		Shell_Beep() ;

} /* LaunchBox */


int AssociateBox(PTREE tree,PENTRY node,char *path, int count,
							   int total, BOOL verify)
{
	char tstr1[90];
	char tstr2[90];
	char buffer[90];
	char ext[EXTLEN+1] ;
	char statusline[STATUS_LEN] ;
	char statusline2[STATUS_LEN] ;
	char far *assoc_prog ;
	int ret ;
	TMC tmc ;
	int dummylen ;
	HCABassociate h ;
	HCABassoc2 h2 ;

	UnReferenced(path) ;
	UnReferenced(verify) ;

	Tree2Path(tree, node, buffer, &dummylen);
	FormCountStatusLine(statusline, szFileName, buffer, count, total,
							STATUS_COUNT_START) ;

	if (FIsExecutableFile(node->name+NAMELEN))
	{
		if (!(h = HcabAlloc(cabiCABassociate)))
		{
			OutOfMemory() ;
			return ACT_NOMEM;
		}
		InitCab(h, cabiCABassociate) ;


		/* It is a .EXE, .COM, or .BAT file -- ask user for extension list */
		QStatus = statusline ; /* So that FDlgAssociate can print this status */

		/* Display the current set of associate extensions */
		Get_Association_List(buffer, tstr1);
		SzToCab(h, tstr1, Iag(CABassociate, pszassocextensions));

		SzToCab(h,szEnterButton , Iag(CABassociate, pszassocEB));
		SzToCab(h,szCancelButton , Iag(CABassociate, pszassocCB));
		SzToCab(h,szHelpButton  , Iag(CABassociate, pszassocHB));

		if ( (tmc = MyTmcDoDlg(&dlgassociate,  h)) == tmcOK)
		{
			/* The +1 is for the EOS character ('\0') */
			SzFromCab(h, tstr2, ASSOC_EXT_LEN+1, 
										Iag(CABassociate, pszassocextensions));
			/* Perform the new associations only if the new assoc string
			 *is different. Quite often one just looks at the "associations"
			 * of a file and types "enter".
			 */
			if (strcmp(tstr1, tstr2) != 0)
			{
#ifdef DBCS
				DBCSstrupr(tstr2) ; /* to store in upper case! */
#else
				strupr(tstr2) ; /* to store in upper case! */
#endif

				/* It is so much cleaner & easier to just delete old assocs
				 * of 'buffer' and add these new associations, instead of
				 * checking for pre-existence of desired new associations and
				 * not deleting.
				 */
				Delete_Associations(buffer, TRUE) ;
				Make_Association_List(buffer,tstr2);
			}
			ret = ACT_OK ;
		}
		else
		if (tmc == tmcCancel)
			ret = ACT_CANCEL ;

		FreeCab(h) ;
	}
	else
	{
		/* we are trying to associate an extension with a program that the user
		 * will be prompted to supply now.
		 */

		/* ZZZZZ We now allow associating files that have no extension also. */
#if 0
		/* Does file have no extension? We don't allow this case!! */
		if ( *(node->name+NAMELEN) == '\0' )
		{
			/* ZZZZZ Should we have a special character for files with
			 * no extensions -- say '.' when trying to associate such
			 * files with an executable program??
			 */
			ret = GetResponse(statusline, szExtensionInvalid,
							  BT_FILESKIPQUIT, HELP_INVALIDASSOCEXT);
		}
		else
#endif
		{
			if (!(h2 = HcabAlloc(cabiCABassoc2)))
			{
				OutOfMemory() ;
				return ACT_NOMEM;
			}
			InitCab(h2, cabiCABassoc2) ;

			strfncpy(ext, node->name+NAMELEN, EXTLEN) ;
			ext[EXTLEN] = '\0' ; /* just to make sure there is an EOS */

			FormStringWithoutPlaceHolders(statusline2, szAreAssocLine,
																			(char far *) ext) ;

			QStatus = statusline2 ;

			if ( (assoc_prog = Get_Association(node->name+NAMELEN)) == NULL )
				tstr1[0] = '\0' ;
			else
				strfcpy(tstr1, assoc_prog) ; /* copy from far memory to near */

			SzToCab(h2, tstr1, Iag(CABassoc2, pszassoc2program));

			SzToCab(h2, szEnterButton, Iag(CABassoc2, pszassoc2EB));
			SzToCab(h2, szCancelButton, Iag(CABassoc2, pszassoc2CB));
			SzToCab(h2, szHelpButton, Iag(CABassoc2, pszassoc2HB));


			if ( (tmc = MyTmcDoDlg(&dlgassoc2, h2)) == tmcOK)
			{
				SzFromCab(h2, tstr2, sizeof(tstr2),
										Iag(CABassoc2, pszassoc2program));
				/* Perform the new associations only if the new assoc string
				 * is different. Quite often one just looks at the "associations"
				 * of a file and types "enter".
				 */
				if (strcmp(tstr1, tstr2) != 0)
				{
#ifdef DBCS
					DBCSstrupr(tstr2) ; /* to store in upper case! */
#else
					strupr(tstr2) ; /* to store in upper case! */
#endif
					/* Transform a NULL extension to '.' as that is how we store
					 * it in the INI file.
					 */
					if (ext[0] == '\0')
					{
						ext[0] = (char) NOEXT_CHAR ;
						ext[1] = '\0' ;
					}

					/* Delete any previous associations for extension 'ext' */
					Delete_Associations(ext, FALSE) ;

					/* Add new association, if tstr2 is not a NULL string */
					if (*tstr2)
					{
						Make_Association(tstr2, ext) ;
					}
				}
				ret = ACT_OK ;
			}
			else
				if (tmc == tmcCancel)
					ret = ACT_CANCEL ;

			FreeCab(h2);
		}
	}
	return ret ;
} /* AssociateBox */


VOID DoAssociateBox(void)
{
	gpszFileOpCaption = szAssociateCaption ;

	DoFileOp(OP_ASSOCIATE, NULL);
}


BOOL FAR PASCAL FDlgassoc2(WORD dlm, TMC tmc, WORD wNew,
													WORD wOld, WORD wParam)
{
	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK,szAssociateCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcassoc2help);
		SetUpEditBox(tmcassoc2program, TRUE,USERS_MAX_TYPEABLE_PATH, TRUE);
		Shell_SetTmcText(tmcassoc2status,QStatus);
	}
	else if (dlm == dlmSetFocus)
	{
		gCurrentTMC = tmc;
	}
	else if (dlm== dlmClick)
	{
		 if(tmc == tmcassoc2help)
			Help(hemDialog, hidASSOC2,NULL,0);

		 SetFocusTmc(gCurrentTMC) ;
	}

	return(TRUE);
}

BOOL FAR PASCAL FDlgassociate(WORD dlm, TMC tmc, WORD wNew,
													WORD wOld, WORD wParam)
{
	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK,szAssociateCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcassochelp);
		SetUpEditBox(tmcassocextensions, TRUE, ASSOC_EXT_LEN, TRUE);
		Shell_SetTmcText(tmcassocstatus,QStatus);
	}
	else if (dlm == dlmSetFocus)
	{
		gCurrentTMC = tmc;
	}
	else if (dlm== dlmClick)
	{
		 if(tmc == tmcassochelp)
			Help(hemDialog, hidASSOCIAT,NULL,0);

		 SetFocusTmc(gCurrentTMC) ;
	}

	return(TRUE);
}

BOOL FAR PASCAL FDlgrun(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	UnReferenced(wNew);
	UnReferenced(wOld);
	UnReferenced(wParam);

	if (dlm == dlmInit)
	{
		SetUpDialog(tmcOK,szRunCaption);
		SetUpButtonForGraphics(tmcOK);
		SetUpButtonForGraphics(tmcCancel);
		SetUpEditBox(tmccommandline, TRUE,255, TRUE);
	}
	else if (dlm == dlmSetFocus)
	{
		gCurrentTMC = tmc;
	}
	return(TRUE);
}

void Set_Task_Name(char far *name);
BOOL gfInRun = FALSE;
VOID FAR Run(void)
{
	HCABrun        h;
	TMC tmc;
	char commands[256];
	char RunInDir[MAX_PATH+1] ;
	char *pStartDir ;
	int dummylen ;

	h = HcabAlloc(cabiCABrun);
	if (!h)
	{
		OutOfMemory() ;
		return ;
	}
	InitCab(h, cabiCABrun) ;

	SzToCab(h, NullString, Iag(CABrun, pszcommandline));
	SzToCab(h, szEnterButton, Iag(CABrun, pszrunEB));
	SzToCab(h, szCancelButton, Iag(CABrun, pszrunCB));

	tmc = MyTmcDoDlg(&dlgrun, h);
	SzFromCab(h, commands, 256, Iag(CABrun, pszcommandline));
	FreeCab(h);
	if(tmc == tmcOK)
	{
		/*
		 * Always pause after run...
		 */
		Set_KeyWord_Assignment(TK_SAVESTATE,TK_PAUSE,TK_ENABLED);
		userPrompt[0] = 0;

#if 0
/* ZZZZZ Scott & I discussed this and decided that we won't do
 * "run" like "open/launch" as in run, we can execute commands internal to
 * command.com, etc
 */

		/* Now check for "commands" having any association!
		 * Note that if we had a space on this line, the command the user
		 * typed is probably something like "word f1.doc". In this case
		 * we don't need to check for associations.
		 */
		if (strchr(commands, ' ') == NULL)
		{
			ind = FindLastComponent(commands) ;
			if ( (pPeriod = strchr(commands+ind, '.')) != NULL)
			{
				strncpy(extension, (pPeriod+1), EXTLEN) ;
				extension[EXTLEN] = '\0' ; // Null-terminate just in case!

				if (!FIsExecutableFile(extension))
				{
					/* check for association! */
					progrun = Get_Association(extension);
					if (progrun == NULL)
					{
						/* ZZZZZ Put up a dialog saying can't run?? */
						Shell_Beep() ;
						return ;
					}
					else
					{
						Shell_Beep() ; Shell_Beep() ;
					}
				}
				/* else it is an executable file -- no problem! */
			}

		}
		/* else execute user typed command directly */
#endif

		/* By default we would want to use the directory in which the user
		 * was when he started the DOSSHELL. This will be valid if Run is
		 * done from PM and the FM has not been visited.
		 */
		pStartDir = gStartInDir ;

		if (gfFMVisited)
		{
			Tree2Path(listinfo[glob.FocusBox].tree,
							   listinfo[glob.FocusBox].files, RunInDir, &dummylen) ;
			pStartDir = RunInDir ;
		}
		Set_Task_Name(commands);
		gfInRun = TRUE;
		DoCommand(commands, pStartDir);
		/* we only get here in case of error condition */
		gfInRun = FALSE;
	}
} /* Run */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\manip.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <icons.h>
#include <text.h>
#include <assert.h>

extern void SetFocusDrive(WORD list, BYTE whichdriveicon) ;
extern int MouseConfirmationDialog(char *message, char *dpath) ;
extern VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen) ;
extern BOOL FIsExecutableFile(char far *ext) ;
extern unsigned CountFilesToOperateOn(void) ;

extern WORD gEditBoxModifier;
extern void ProgramCursor(void) ;
extern void Arrow(void) ;
extern void Set_Task_Name(char far *name);

BOOL gfManipulating = FALSE; /* is something being manipulated? */
BYTE gManipType = 0;
PTREE gSrcManipTree;
PTREE gDestManipTree;

PENTRY gSrcManipNode;
PENTRY gDestManipNode;

#define GetNumOfManipulatedFiles() gNumManipulatedFiles

unsigned int gNumManipulatedFiles ;

extern BOOL DestIsDir;

extern void Cancel(void);

int gTreeSaveFocus[2];
int gFileSaveFocus[2];
WORD gFocusBeforeManipStart ;
extern struct ListBoxData TreeList[2];
extern BOOL gNeedToUpdateFileList[2];

MCB gProgramCursor;

extern BOOL gNotMonochrome;

VOID Arrow(void)
{
		WORD fore,back;
	 
		/* Set the hot spot of the mouse to the tip of the cursor - top left */
      gProgramCursor.colHot = 0;
      gProgramCursor.rowHot = 0;

		/* first set up the graphics cursor to an Arrow symbol. */
      gProgramCursor.rgwXorMaskGfx[0]  = 0x0000;
      gProgramCursor.rgwXorMaskGfx[1]  = 0x0000;
      gProgramCursor.rgwXorMaskGfx[2]  = 0x4000;
      gProgramCursor.rgwXorMaskGfx[3]  = 0x6000;
      gProgramCursor.rgwXorMaskGfx[4]  = 0x7000;
      gProgramCursor.rgwXorMaskGfx[5]  = 0x7800;
      gProgramCursor.rgwXorMaskGfx[6]  = 0x7c00;
      gProgramCursor.rgwXorMaskGfx[7]  = 0x7e00;
      gProgramCursor.rgwXorMaskGfx[8]  = 0x7f00;
      gProgramCursor.rgwXorMaskGfx[9]  = 0x7c00;
      gProgramCursor.rgwXorMaskGfx[10] = 0x6c00;
      gProgramCursor.rgwXorMaskGfx[11] = 0x4600;
      gProgramCursor.rgwXorMaskGfx[12] = 0x0600;
      gProgramCursor.rgwXorMaskGfx[13] = 0x0300;
      gProgramCursor.rgwXorMaskGfx[14] = 0x0300;
      gProgramCursor.rgwXorMaskGfx[15] = 0x0000;


      gProgramCursor.rgwAndMaskGfx[0]  = ~0x0000;
      gProgramCursor.rgwAndMaskGfx[1]  = ~0xc000;
      gProgramCursor.rgwAndMaskGfx[2]  = ~0xe000;
      gProgramCursor.rgwAndMaskGfx[3]  = ~0xf000;
      gProgramCursor.rgwAndMaskGfx[4]  = ~0xf800;
      gProgramCursor.rgwAndMaskGfx[5]  = ~0xfc00;
      gProgramCursor.rgwAndMaskGfx[6]  = ~0xfe00;
      gProgramCursor.rgwAndMaskGfx[7]  = ~0xff00;
      gProgramCursor.rgwAndMaskGfx[8]  = ~0xff80;
      gProgramCursor.rgwAndMaskGfx[9]  = ~0xffc0;
      gProgramCursor.rgwAndMaskGfx[10] = ~0xfe00;
      gProgramCursor.rgwAndMaskGfx[11] = ~0xef00;
      gProgramCursor.rgwAndMaskGfx[12] = ~0xcf00;
      gProgramCursor.rgwAndMaskGfx[13] = ~0x0780;
      gProgramCursor.rgwAndMaskGfx[14] = ~0x0780;
      gProgramCursor.rgwAndMaskGfx[15] = ~0x0380;

		/* now set up the text cursor */
		if((ginst.coMac <= 2) || (!gNotMonochrome) || fMonochrome)       // in monochrome, we must use block
	   {
			GetIsaColor(isaBlackOnWhite,&fore,&back);
			gProgramCursor.wAndMaskText = 0;
#ifdef JAPAN
			gProgramCursor.wXorMaskText =   fore << 16 | back << 8 | '\x7f'; //? this is wrong'\xb0';
#else
			gProgramCursor.wXorMaskText =   fore << 16 | back << 8 | ''; //? this is wrong'\xb0';
#endif
	   }
	   else
	   {
	GetIsaColor(isaShellMouse, &fore, &back);
	gProgramCursor.wAndMaskText = 0x00FF;
	gProgramCursor.wXorMaskText = (back<<12) | (fore<<8);
	   }
      SetMouseCursor(&gProgramCursor);
}


#ifndef NODIRECT
#if 0
WORD CancelCursorData[] = 
{                                                               /* 1234123412341234     */
	0x03C0,                                 /*            XXXX                              */
	0x0C30,                                 /*     XX    XX            */
	0x1008,                            /*    X        X        */
   0x2804,                                      /*   X X        X       */
	0x2404,                                 /*   X  X       X       */
   0x4202,                                      /*  X    X       X      */
	0x4102,                                 /*  X     X      X      */
	0x4082,                       /*  X      X     X      */
	0x4042,                       /*  X       X    X      */
	0x2024,                       /*   X       X  X       */
	0x2014,                       /*   X        X X       */
	0x1008,                                 /*    X        X                */
	0x0C30,                                 /*     XX        XX                     */
	0x03C0,                                 /*              XXXX                            */
	0x0000,                                                                                                   
	0x0000
	
};

#endif

WORD CancelCursorData[] = 
{                                                               /* 1234123412341234     */
	0x03C0,                                 /*            XXXX                              */
	0x0FF0,                                 /*     XXXXXXXX            */
	0x1C38,                            /*    XXX    XXX        */
   0x381C,                                      /*   XXX      XXX       */
	0x340C,                                 /*   XX X      XX       */
   0x6206,                                      /*  XX   X      XX      */
	0x6106,                                 /*  XX    X     XX      */
	0x6086,                       /*  XX     X    XX      */
	0x6046,                       /*  XX      X   XX      */
	0x302C,                       /*   XX      X XX       */
	0x381C,                       /*   XXX      XXX       */
	0x1C38,                                 /*    XXX    XXX                */
	0x0FF0,                                 /*     XXXXXXXX                         */
	0x03C0,                                 /*              XXXX                            */
	0x0000,                                                                                                   
	0x0000
	
};


WORD CancelCursorMask[] = 
{                                                               /* 1234123412341234     */
	0x03C0,                                 /*            XXXX                              */
	0x0FF0,                                 /*     XXXXXXXX            */
	0x1FF8,                            /*    XXXXXXXXXX        */
   0x3FFC,                                      /*   XXXXXXXXXXXX       */
	0x3FFC,                                 /*   XXXXXXXXXXXX       */
   0x7FFE,                                      /*  XXXXXXXXXXXXXX      */
	0x7FFE,                                 /*  XXXXXXXXXXXXXX      */
	0x7FFE,                       /*  XXXXXXXXXXXXXX      */
	0x7FFE,                       /*  XXXXXXXXXXXXXX      */
	0x3FFC,                       /*   XXXXXXXXXXXX       */
	0x3FFC,                       /*   XXXXXXXXXXXX       */
	0x1FF8,                                 /*    XXXXXXXXXX                */
	0x0FF0,                                 /*     XXXXXXXX       */
	0x03C0,                                 /*              XXXX             */
	0x0000,                                                                                                   
	0x0000
	
};


WORD FileCursorData[] = 
{                                                               /* 1234123412341234     */
	0xFFC0,                                 /*      XXXXXXXXXX                              */
	0x8060,                                 /* X        XX                     */
	0xBB50,                            /* X XXX XX X X         */
   0x8048,                                      /* X        X  X        */
	0xB744,                                 /* X XX XXX X   X       */
   0x8042,                                      /* X        X    X      */
	0xBB7F,                                 /* X XXX XX XXXXXXX     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX             */
	0x0000,
	0x0000,
	0x0000,
	0x0000
	
};

WORD FileCursorMask[] = 
{                                                               /* 1234123412341234     */
	0xFFC0,                                 /*      XXXXXXXXXX                              */
	0xFFE0,                                 /* XXXXXXXXXXX                     */
	0xFFF0,                            /* XXXXXXXXXXXX         */
   0xFFF8,                                      /* XXXXXXXXXXXXX        */
	0xFFFC,                                 /* XXXXXXXXXXXXXX       */
   0xFFFE,                                      /* XXXXXXXXXXXXXXX      */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX             */
	0x0000,
	0x0000,
	0x0000,
	0x0000
	
};


WORD ProgramCursorData[] = 
{                                                               /* 1234123412341234     */
	0xFFFF,                                 /*      XXXXXXXXXXXXXXXX                */
	0x8001,                                 /* X                    X     */
	0x8001,                            /* X              X     */
   0xFFFF,                                      /* XXXXXXXXXXXXXXXX     */
	0x8001,                                 /* X              X     */
   0x8001,                                      /* X              X     */
	0x8001,                                 /* X              X     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0x8001,                       /* X              X     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX             */
	0x0000,
	0x0000,
	0x0000,
	0x0000
	
};

WORD ProgramCursorMask[] = 
{                                                               /* 1234123412341234     */
	0xFFFF,                                 /*      XXXXXXXXXXXXXXXX                */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                            /* XXXXXXXXXXXXXXXX     */
   0xFFFF,                                      /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX     */
   0xFFFF,                                      /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX             */
	0x0000,
	0x0000,
	0x0000,
	0x0000
	
};


WORD MultiCursorData[] = 
{                                                               /* 1234123412341234     */
	0x0FFF,                                 /*          XXXXXXXXXXXX                */
	0x0801,                                 /*     X                X     */
	0x0801,                            /*     X          X     */
   0x3801,                                      /*   XXX          X     */
	0x2801,                                 /*   X X          X     */
   0x2801,                                      /*   X X          X     */
	0xE801,                                 /* XXX X          X     */
	0xAFFF,                       /* X X XXXXXXXXXXXX     */
	0xA004,                       /* X X          X       */
	0xA004,                       /* X X          X       */
	0xBFFC,                       /* X XXXXXXXXXXXX       */
	0x8010,                                 /* X          X                 */
	0x8010,                                 /*      X                         X                     */
	0xFFF0,                                 /* XXXXXXXXXXXX                 */
	0x0000,
	0x0000
	
};

WORD MultiCursorMask[] = 
{                                                               /* 1234123412341234     */
	0x0FFF,                                 /*          XXXXXXXXXXXX                */
	0x0FFF,                                 /*     XXXXXXXXXXXX     */
	0x0FFF,                            /*     XXXXXXXXXXXX     */
   0x3FFF,                                      /*   XXXXXXXXXXXXXX     */
	0x3FFF,                                 /*   XXXXXXXXXXXXXX     */
   0x3FFF,                                      /*   XXXXXXXXXXXXXX     */
	0xFFFF,                                 /* XXXXXXXXXXXXXXXX     */
	0xFFFF,                       /* XXXXXXXXXXXXXXXX     */
	0xFFFC,                       /* XXXXXXXXXXXXXX       */
	0xFFFC,                       /* XXXXXXXXXXXXXX       */
	0xFFFC,                       /* XXXXXXXXXXXXXX       */
	0xFFF0,                                 /* XXXXXXXXXXXX                 */
	0xFFF0,                                 /*      XXXXXXXXXXXX                    */
	0xFFF0,                                 /*      XXXXXXXXXXXX                    */
	0x0000,                                                                                                 
	0x0000
	
};

VOID ProgramCursor(void)
{
		WORD fore,back;
		int i;
		WORD *thisicon;
		WORD *thismask;

		/* Make the hot spot of the program cursor its center */
      gProgramCursor.colHot = 8;
      gProgramCursor.rowHot = 8;

		
		if(GetNumOfManipulatedFiles() > 1)
		{
			thisicon = MultiCursorData;
			thismask = MultiCursorMask;
		}
		else
      if(FIsExecutableFile(gSrcManipNode->name+NAMELEN))
		{
			thisicon = ProgramCursorData;
			thismask = ProgramCursorMask;
		}
		else
		{
			thisicon = FileCursorData;
			thismask = FileCursorMask;
		}
		for(i=0;i<16;i++)
		{
			gProgramCursor.rgwXorMaskGfx[i] =  thisicon[i] ^ thismask[i];
			gProgramCursor.rgwAndMaskGfx[i] =  ~thismask[i];        
		}
    GetIsaColor(isaShellMouse, &fore, &back);
    gProgramCursor.wAndMaskText = 0;
#ifdef JAPAN
    gProgramCursor.wXorMaskText = (back<<12) | (fore<<8) | (BYTE)'\xa5';
#else
    gProgramCursor.wXorMaskText = (back<<12) | (fore<<8) | '';
#endif
      SetMouseCursor(&gProgramCursor);

}

VOID Cancel(void)
{
		WORD fore,back;
		int i;

		/* Set the hot spot of the Cancel cursor -- (a NOT circle) to the
		 * its center.
		 */
      gProgramCursor.colHot = 8;
      gProgramCursor.rowHot = 8;

		for(i=0;i<16;i++)
		{
			gProgramCursor.rgwXorMaskGfx[i] =  CancelCursorData[i] ^ CancelCursorMask[i];
			gProgramCursor.rgwAndMaskGfx[i] =  ~CancelCursorMask[i];        
		}

    GetIsaColor(isaShellMouse, &fore, &back);
    gProgramCursor.wAndMaskText = 0;
#ifdef JAPAN
    gProgramCursor.wXorMaskText = (back<<12) | (fore<<8) | '!';
#else
    gProgramCursor.wXorMaskText = (back<<12) | (fore<<8) | '';
#endif
      SetMouseCursor(&gProgramCursor);
}


#endif

/* sets the manipulation type to MANIP_MOVE or MANIP_COPY -- called by
 * fn MonitorManipulation().
 */
void SetMoveOrCopyManipulation(void)
{
	/* If destination tree is a different one, DEFAULT is copy, else move */
	if (gDestManipTree != gSrcManipTree)
	{
		if (gEditBoxModifier & KK_ALT) // is the alt key is pressed
			gManipType = MANIP_MOVE ;
		else
			gManipType = MANIP_COPY ;
	}
	else
	{
		if (gEditBoxModifier & KK_CONTROL) // is the ctrl key is pressed
			gManipType = MANIP_COPY ;
		else
			gManipType = MANIP_MOVE ;
	}
} /* SetMoveOrCopyManipulation */


VOID BeginManipulation(treehdr far *tree, PENTRY node)
{
	int i;

	if (gfManipulating)
		return;

	if ( (!node) || (node->attribs & _A_SUBDIR) )
	{
		return;
	}

	gfManipulating = TRUE;
	gSrcManipTree = tree;
	gSrcManipNode = node;

	gNumManipulatedFiles = CountFilesToOperateOn() ;

	for(i=0; i<=glob.MaxTree; ++i)
	{
	gTreeSaveFocus[i] = TreeList[i].focusitem;
	gFileSaveFocus[i] = FileList[i].focusitem;
    }
	 /* Remember the following, as we need to restore the focus location
	  * when we complete the direct manipulation operation.
	  */
	 gFocusBeforeManipStart = WhoHasGlobalFocus() ;
    ProgramCursor();
}

VOID EndManipulation(void)
{
	char cpath[MAX_PATH+1];
	char tempbuffer[256];
	char LaunchInDir[MAX_PATH+1];
	char ProgName[NAMELEN+EXTLEN+2] ;
	char ArgName[NAMELEN+EXTLEN+2] ;
	char ProgTitle[NAMELEN+EXTLEN+2];
	int i;
	int dummylen ;
	int ret ;

	if(!gfManipulating)
		return;

	Arrow();
	for(i=0; i<=glob.MaxTree; ++i)
	{
	TreeList[i].focusitem = gTreeSaveFocus[i];
	TreeList[i].ListProc(tmmSetFocus, NULL, gTreeSaveFocus[i],
												TreeList[i].tmc, 0, 0, 0);
	TreeList[i].update = TRUE;
	TreeList[i].nextlinetoupdate = 0;
	gNeedToUpdateFileList[i] = listinfo[i].UpdateFiles = FALSE;
	FileList[i].focusitem = gFileSaveFocus[i];
	FileList[i].ListProc(tmmSetFocus, NULL, gFileSaveFocus[i],
															FileList[i].tmc, 0, 0, 0);
	FileList[i].update = TRUE;
	FileList[i].nextlinetoupdate = 0;
	}

	/* Put back the focus to where it was before starting the direct
	 * manipulation. Also, in case we went through drive icons the focus
	 * and selection icons may be different. Fix these also.
	 */
   InitGlobalFocus(gFocusBeforeManipStart) ;

	SetFocusDrive(0, GetSelectedDrive(0) ) ;
	if (glob.MaxTree)
		SetFocusDrive(1, GetSelectedDrive(1) ) ;

	switch(gManipType)
	{
	  case MANIP_RUN:
			if (glob.MouseConfirm)
			{
				Internal2Normal(ProgName, gDestManipNode->name) ;
				Internal2Normal(ArgName, gSrcManipNode->name) ;
				FormStringWithoutPlaceHolders(tempbuffer,szMouseLaunchProgConfirm,
						(char far *)ProgName, (char far *)ArgName) ;

				/* Argument 2 -- destination path is dummy for this case! */
				if (!MouseConfirmationDialog(tempbuffer, NULL))
					break ;
			}
			
			/* Use tempbuffer to hold the programstring now. */
			Tree2Path(gDestManipTree, gDestManipNode, tempbuffer, &dummylen);
			strcat(tempbuffer,szBlank);
			Tree2Path(gSrcManipTree, gSrcManipNode, cpath, &dummylen);
			strcat(tempbuffer,cpath);

			/* ZZZZZ Is following correct?? */
			Tree2Path(gDestManipTree, FindParent(gDestManipNode),LaunchInDir, &dummylen);

			Internal2Normal(ProgTitle,gDestManipNode->name);
			Set_Task_Name(ProgTitle);

			DoCommand(tempbuffer, LaunchInDir);
			break;

	  case MANIP_MOVE:
	  case MANIP_COPY:
	     Tree2Path(gDestManipTree, gDestManipNode, cpath, &dummylen) ;

		  /* Put up confirmation dialog on direct manipulation before
			* performing the move or copy to the destination directory
			* if the user wants to be prompted for mouse confirm.
			*/
		  if (glob.MouseConfirm)
		  {
				/* The following code is optimized by the compiler correctly */
				if (gManipType == MANIP_MOVE)
					ret = MouseConfirmationDialog(szMouseMoveFilesConfirm, cpath) ;
				else
					ret = MouseConfirmationDialog(szMouseCopyFilesConfirm, cpath) ;
				
				/* Did the user cancel the mouse operation */
				if (!ret)
					break ;
		  }

		  /* We can only do direct manipulation of files right now!
			* fn DoFileOp() looks at who has focus before deciding whether to
			* perform file operation or directory operation.
			*/
		  if ((WhoHasGlobalFocus() != FILE0) && (WhoHasGlobalFocus() != FILE1))
		  {
				Shell_Beep() ;
		  }
		  else
		  {
				/* DoFileOp looks at this BOOL. This indicates whether the path
				 * we are passing to DoFileOp() is a directory or not.
				 */
				DestIsDir = TRUE ;
				if (gManipType == MANIP_MOVE)
				{
					gpszFileOpCaption = szMoveFileCaption ;
					DoFileOp(OP_MOVE, cpath) ;
				}
				else
				{
					gpszFileOpCaption = szCopyFileCaption ;
					DoFileOp(OP_COPY, cpath) ;
				}
		  }
		  break ;

	 default:
		 break ;
	} /* switch */

	MessageBar((glob.TreeMode == TR_SEARCH) ? szSearchMessage : szFileMessage,
																					isaMenu,TRUE);
	gfManipulating = FALSE;
	gManipType = 0;
}

extern BYTE GetFocusDrive(WORD list);
extern drivelist    gDriveList[NUMDRIVELISTS];
extern BOOL gfActivate;
extern BOOL FIsExecutableFile(char far *ext) ;


/* This function is invoked when the mouse is moved to a spot where the
 * file(s) that has(have) been dragged can't be dropped. The mouse cursor is
 * turned into a "Cancel" like symbol. A diagonal bar within a circle.
 */
void CancelDirectManipulation(char *Message)
{
	gManipType = 0;
	strcat(Message,szCancel);
	Cancel();
} /* CancelDirectManipulation */

/*      INTERNATIONALIZE HERE!!!
 * This the amount of columns reserved for the time string, manip
 * string's beginning section (namely "Copy file-name to") and the
 * message saying ADD mode or not at the right.
 */
#define STATUS_RESERVED 40

/* When one is performing direct manipulation, every time the mouse is moved
 * this routine is invoked. This sets up the mouse cursor appropriately
 * and also the status bar message at the bottom of the screen is also
 * updated to reflect what will happen if the mouse btton goes up.
 * (x, y) are the current mouse co-ordinates on the screen. Origin (0,0)
 * is the top left of screen.
 */
VOID MonitorManipulation(BYTE x, BYTE y)
{
	static char Message[91];
	char dest_path[MAX_PATH+1] ;
	char CompressedDirPath[65] ;
	int dummylen ;
	char Name1[15];
	char Name2[15] ;
	char *pszSrc, *pszDest ;
	int ith;
	int lastfocus;
	WORD GlobalFocus ;

	if(!gfManipulating)
		return;

	strcpy(Message,szBlank);

	GlobalFocus = WhoHasGlobalFocus() ;

	if(y <= 2)
	{
		CancelDirectManipulation(Message) ;
	}
	else
    switch (GlobalFocus)
    {
	   case DRIVELIST1:
	   case DRIVELIST0:
			if ( (GlobalFocus == DRIVELIST1) && (glob.TreeMode == TR_SHARE) )
			{
				CancelDirectManipulation(Message) ;
				break;
			}

			ith = WhoHasGlobalFocus() == DRIVELIST0 ? 0 : 1;
			lastfocus = GetFocusDrive(ith);

			/* Is the mouse outside the drive icon region? The drive icon in
			* question is the one that has the focus.
			*/
			if (    (gDriveList[ith][lastfocus].IconY != y)||
					(x < gDriveList[ith][lastfocus].IconX) ||
					(x >= (gDriveList[ith][lastfocus].IconX + (BYTE) (DRIVESHIFT-1)))
				)
			{
				CancelDirectManipulation(Message) ;
				break;
			}

			ProgramCursor();

			gDestManipTree = gDriveList[ith][lastfocus].tree;
			gDestManipNode = gDestManipTree->SelDir ;

			/* sets the variable gManipType */
			SetMoveOrCopyManipulation() ;

			Tree2Path(gDestManipTree, gDestManipNode, dest_path, &dummylen) ;
			MakeDirNameFit(dest_path, NULL, CompressedDirPath,
																	(axMac - STATUS_RESERVED));
			if (GetNumOfManipulatedFiles() > 1)
			{
				pszSrc = szFiles ;
			}
			else
			{
				Internal2Normal(Name1, gSrcManipNode->name) ;
				pszSrc = Name1 ;
			}

			dummylen = strlen(Message) ;

			FormStringWithoutPlaceHolders(Message+dummylen,
				(gManipType == MANIP_MOVE) ? szMoveStatusBarMsg : szCopyStatusBarMsg,
				(char far *)pszSrc, (char far *)CompressedDirPath) ;

			break;

	   case FILE1:
			if(glob.TreeMode == TR_SHARE)
			{
				CancelDirectManipulation(Message) ;
			break;
			}
		case FILE0:
			ith = ((GlobalFocus == FILE0) ? 0 : 1) ;

			/* Is the mouse outside the file listbox region? */
			if (    (y < Get_List_Rect(&FileList[ith]).ayTop) || 
					(y >= Get_List_Rect(&FileList[ith]).ayBottom)
				)
			{
				CancelDirectManipulation(Message) ;
				break;
			}

			gDestManipTree = listinfo[ith].tree;
			gDestManipNode = ( (glob.TreeMode == TR_SYSTEM) ||
					( (glob.TreeMode == TR_SEARCH) && (gfSearchDisk) ) ) ?
					GetNthFlatMatchedFile(gDestManipTree, Get_List_Focus(&FileList[ith])) :
					GetNthMatchedFile(listinfo[ith].files, Get_List_Focus(&FileList[ith]), gDestManipTree) ;

			if((!gDestManipNode) ||
			(!FIsExecutableFile(gDestManipNode->name+NAMELEN)) ||
				(gDestManipNode == gSrcManipNode))
			{
			/* is not executable (or null!) */
				CancelDirectManipulation(Message) ;
			}
			else
			{
				ProgramCursor();
				gManipType = MANIP_RUN;
				dummylen = strlen(Message) ;

				Internal2Normal(Name1, gDestManipNode->name) ;
				Internal2Normal(Name2, gSrcManipNode->name) ;
				FormStringWithoutPlaceHolders(Message+dummylen, szRunStatusBarMsg,
						(char far *)Name1, (char far *)Name2) ;
			}
			break;

		case TREE1:
			if(glob.TreeMode == TR_SHARE)
			{
				CancelDirectManipulation(Message) ;
				break;
			}

		case TREE0:

			ith = ( (GlobalFocus == TREE0) ? 0 : 1) ;

			/* Is the mouse outside the directory listbox region? */
			if (    (y < Get_List_Rect(&TreeList[ith]).ayTop) || 
					(y >= Get_List_Rect(&TreeList[ith]).ayBottom)
				)
			{
				CancelDirectManipulation(Message) ;
				break;
			}

			ProgramCursor();

			gDestManipTree = listinfo[ith].tree;
			gDestManipNode = Get_List_Focus(&TreeList[ith])?GetNthVisibleDir(gDestManipTree, Get_List_Focus(&TreeList[ith])) : NULL;

			/* sets the variable gManipType */
			SetMoveOrCopyManipulation() ;

			dummylen = strlen(Message) ;

			if(GetNumOfManipulatedFiles() > 1)
			{
				pszSrc = szFiles ;
			}
			else
			{
				Internal2Normal(Name1, gSrcManipNode->name) ;
				pszSrc = Name1 ;
			}

			if(gDestManipNode)
			{
			Internal2Normal(Name2, gDestManipNode->name) ;
				pszDest = Name2 ;
			}
			else
			{
				pszDest = RootName ;
			}

			FormStringWithoutPlaceHolders(Message+dummylen,
				(gManipType == MANIP_MOVE) ? szMoveStatusBarMsg : szCopyStatusBarMsg,
				(char far *)pszSrc, (char far *)pszDest) ;              
			break;

		default:
			CancelDirectManipulation(Message) ;
		break;
    } /* switch */

    MessageBar(Message, isaMenu,TRUE);

} /* MonitorManipulation */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\mousebug.asm ===
;/* Revision history since 5.0 Golden:
; *
; *  M013 SHK 10/02/91	Zero out BX before we make the call to detect mouse
; *			mouse version numbers.
; */


;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

?WIN = 0                ;Not windows;
?PLM = 1                ;DO use pl/m
include cmacros.inc

DOSARENA STRUC 
	Signature       db ?
	Owner           dw ?
	Paragraphs      dw ?
	Special         db 3 dup(?)
	OwnerName       db 8 dup(?)
DOSARENA ENDS

sBegin data
sEnd data

sBegin code
    assumes cs, code
    assumes ds, data

;;;RETURNS The mouse version ,
;;;major in hibyte, minor in lobyte
cProc  MouseVersion, PUBLIC , <si,di,ds,es>
cBegin MouseVersion
	xor bx,bx	; M013 older mouse versions may not set version, so
			;      zero here so we can detect "unknown" version	
	mov ax,0024h ;Get Mouse Information
	int 33h
	xchg ax,bx
cEnd   MouseVersion

is_system_chain db 0
myUmbLinkState  dw ?

;;; DetectLogitech
;;; FUNCTION 
;;;     detects the presence (in memory!) of a Logitech Mouse driver
;;; RETURNS 
;;;     if Logitech detected (numbers are binary) :
;;;             dh = 0
;;;             dl = major version
;;;             ah = minor version
;;;             al = incremental version
;;;           eg: Logitech version 5.01 -> dx=0005h:ax=0001h
;;;     if Not detected
;;;             dx:ax = 0
;;; EFFECTS
;;;     Temporarily links in UMBs, scans all memory arenas
;;; ALGORITHM
;;;
;;;     Link in UMBS, scan ALL memory arenas more name "MOUSE". Scan
;;;     all "MOUSE" arenas for the sequence "LOGITECH MOUSE DRIVER VX.XX"
;;;     
cProc DetectLogitech , PUBLIC,<si,di,ds,es>
cBegin DetectLogitech

	;;;     We must link in the UMBs for this search, since
	;;;     the mouse driver might be in a UMB!
	
	;;; first save state
	mov ax,5802h                        ; Get link state; output in ax
	int 21h
	mov WORD PTR cs:myUmbLinkState,ax   ; Save link state for restoration

	;;; now set state (umbs linked in)
	mov     ax,5803h         ; link/unlink UMBs bx = 0 is unlink,
	mov     bx,1            ; bx =1 is link
	int     21h

	;;; Get DOS memory arena pointer just above DBP
	mov     AH,52h                  ; "undocumented"
	int     21h                     ; ES:BX --> first DBP
	sub     bx,4                    ; ARENA HEAD POINTER is now in es:bx
	
	les    bx,es:[bx]               ; first arena -> es:bx
	mov    ax,es                    ; ax is temporary segment saver

	;;;    loop through all arenas...
nextarena:
	;;;    We use the same code to walk through regular arenas and
	;;;    system arenas, regular arena chains end with signature 'Z'
	;;;    while system arenas end with 'F'

	mov    cl,es:[bx].Signature     ; current arena the arena list tail?
	cmp    cl,'F'                   ; 'F' means we were in a system list
	je     end_system_chain 

	cmp    cl,'Z'                   ; 'Z' means there are no more arenas
	je     endofarenas1

	cmp    cl, 'M'                  ; sanity check--> valid 
	je     arena_valid              ; regular arenas are id 'M'
	cmp    cl, 'D'                  ; and system arenas are id 'D'
	je     arena_valid
	jmp    short endofarenas1       ; invalid arenas!
arena_valid:
	;;;    check for special system type of arena (UMBs,devices)
	cmp    es:[bx].owner,08h        ; system arenas have owner of 08h
	jne    find_a_regular_mouse_arena 
	cmp    WORD PTR es:[bx].ownername,'DS' ; system arenas have owner name of SD
	jne    find_a_regular_mouse_arena

	;;; here we set up for walking a system arena (UMB,device lists)
	cmp     cs:is_system_chain,0   ; if we are already in a system arena, 
	je      start_system_chain     ; something weird is going on fall through!

	;;; restore setup for walking regular arena chains  
end_system_chain:
	dec     cs:is_system_chain     ; no longer in a system chain
	pop     ax                     ; restore registers saved at chain start
	pop     bx                     ; 
	pop     es                     ; es:bx points to next arena
	jmp     short find_a_regular_mouse_arena ;continue arena walking
endofarenas1:   
	jmp endofarenas ; jump out of range, this is intermediate

start_system_chain:
	;;; here we setup for walking system chain
	inc     cs:is_system_chain    ; remember we are in a special chain
	push    es                    ; remember current arena
	push    bx                    ; is es:bx, as well as segment in ax
	push    ax
	add     bx,16                 ; system arena head starts at first
				      ; segment in this regular arena
      ; fall through to generic search code

find_a_regular_mouse_arena:

	;;;es:bx -> arena header
	cmp    WORD PTR es:[bx].OwnerName[0],'OM' ; is owner "MOUSE"?
	jne    continue_chain                     ; note we are doing
	cmp    WORD PTR es:[bx].OwnerName[2],'SU' ; double byte compares!
	jne    continue_chain
	cmp    BYTE PTR es:[bx].OwnerName[4],'E'
	jne    continue_chain

	;; found a MOUSE ARENA
	mov     di,bx                            ; get pointer to memory block
	mov     CX, es:[bx].paragraphs           ; lengths is in paragraphs
	shl     cx,1                             ; we need bytes
	shl     cx,1                             ; mul by 16
	shl     cx,1
	shl     cx,1
	cld                                      ; don't forget!
	
continue_this_scan:
;;; scanning for "LOGITECH MOUSE DRIVER VX.XX" in this es:di memory block
;;;               012345678901234567890123456
	mov     dx,ax
	mov     AX,'OL'
	repne   scasw
	or      cx,cx
	mov     ax,dx
	jz      continue_chain
	cmp     WORD PTR es:[di],'IG'
	jne     continue_this_scan
	cmp     WORD PTR es:[di+2],'ET'
	jne     continue_this_scan
	cmp     WORD PTR es:[di+4],'HC'
	jne     continue_this_scan
	cmp     WORD PTR es:[di+6],'M '
	jne     continue_this_scan
	;;;     note we don't check for "OUSE DRIVER", just too much
	cmp     WORD PTR es:[di+19],'V '
	jne     continue_this_scan

	;;;     found the signature, now get the version after the "V"
	;;;     WARNING assumes D.DD as version format, but we already 
	;;;     checked "real" version for less than 6.23 so we probably
	;;;     wouldn't get here...

	mov     dl,BYTE PTR es:[di+21] ; ascii major version
	mov     ah,BYTE PTR es:[di+23] ; ascii minor version
	mov     al,BYTE PTR es:[di+24] ; ascii incremental version
	mov     dh,'0'                 ; binarize the numbers ...
	sub     dl,dh
	sub     ah,dh
	sub     al,dh
	xor     dh,dh                  ; note dh = 0 on return!
	jmp short DetectLogictechReturn ; clean up and get out!
continue_chain:
	;;;    this arena has not logitech, go to next
	mov    es,ax                   ; restore arena segment 
	add    ax,es:[bx].paragraphs   ; skip the memory block to next arena
	inc    ax                      ; one paragraph for last header
	mov    es,ax                   ; save arena segment in ax
	jmp    nextarena               ; ready to search again
endofarenas:

	;;; If we get here, we did not find a logitech signature
	;;; in a "MOUSE" owned arena
	xor    ax,ax
	xor    dx,dx
DetectLogictechReturn:
	;;;     if we were in a system chain, we need to clean up
	;;;     the stuff (es,bx,ax = 6 bytes) we saved on the stack
	cmp     cs:is_system_chain,0
	je      no_cleanup
	add     sp,6
no_cleanup:

	;;;     we now need to restore the UMB link state

	push    ax              ; don't toast return value!
	;;; now re-set umb link state
	mov     ax,5803h         ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,cs:myUmbLinkState
	int     21h
	
	pop     ax      ;; restore return value
cEnd DetectLogictech

sEnd   code
end





















=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\memmgr.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <assert.h>
#include <malloc.h>             /* for malloc() / free() */
#include <text.h>
#include <outofmem.hs>
#include <outofmem.sdm>

extern void OurUnHookISR9(void) ;
extern BOOL gfOurISR9Installed ;
extern BOOL gfStillInitializing; /* used in allocs to bail if we're gonna toast */
extern Shell_TTY_Out(char *str);

BOOL FAR PASCAL FDlgOutOfMem(WORD dlm,TMC tmc,WORD wNew,WORD wOld,WORD wParam)
{
	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	if (dlm == dlmInit)
	{
		SetUpDialog(tmcoutofmementer, szCritWarning);
		SetUpButtonForGraphics(tmcoutofmementer);

		Shell_SetTmcText(tmcoutofmemmsg, szOutOfMemory) ;
		Shell_SetTmcText(tmcoutofmemmsg2,szOutOfMemory2);
		SetTmcText(tmcoutofmementer,szEnterButton);
	}
	return TRUE ;

} /* FDlgOutOfMem */

HCABOutOfMem gHcabOutOfMem;  // storage for the OutOfMem dialog box!

/* Tries to allocate memory for the OutOfMemory dialog box. If un-successful,
 * it puts up a CW message saying "Out Of Memory" -- an ugly box!! and then
 * returns FALSE. If succesful allocation, it initializes this chunk of mem
 * correctly and returns TRUE
 */
BOOL AllocateHcabForOutOfMem(void)
{
	gHcabOutOfMem = HcabAlloc(cabiCABOutOfMem);

	if (!gHcabOutOfMem)
		MessageBox(szShortOutOfMemoryTitle, NULL, NULL, MB_OK | MB_BEEP);
	else
		InitCab(gHcabOutOfMem, cabiCABOutOfMem) ;
	return (gHcabOutOfMem != NULL) ;
} /* AllocateHcabForOutOfMem */

extern char *szCurDialogCaption ;
extern BYTE ErrorCrit;

/* specifies whether we are processing an out of memory condition */
BOOL fProcessingOutOfMemory = FALSE ;

VOID FAR PASCAL OutOfMemory()
/*
  -- this is called on an out-of-memory condition
*/
{
	BYTE savecrit;
	char *saveDialogCaption ;

	/* sanity check -- can't call OutOfmemory() when already processing
	 * an Outofmemory() situation. ZZZZZZ Maybe I can do a NoMembailOut() call
	 * now!
	 */
	if (fProcessingOutOfMemory)
	{
		Beep() ; Beep() ;
		return ;
	}

	fProcessingOutOfMemory = TRUE ;

	DialogIsAlert(TRUE) ;

	/* Save the current dialog caption (szCurDialogCaption) as this
	 * OutOfMemory dialog box could pop up on top of another dialog.
	 *	MyTmcDoDlg() call below will change this string to the
	 * "Out Of Memory" caption and we need to restore it when we are done.
	 */
	saveDialogCaption = szCurDialogCaption ;

	/* Make it look like we are in the middle of a critical error handler.
	 * (i.e., assign to ErrorCrit a value other than 0xFF). This will
	 * ensure that we don't do our idle processing stuff while this
	 * OutOfMemory dialog box is put up.
	 * scottq uses the value 0x34 as the magic value and the same value
	 * is being used here for consistency.
	 */
	savecrit = ErrorCrit;
	ErrorCrit=0x34;
	// Run dlg box.
	MyTmcDoDlg(&dlgOutOfMem, gHcabOutOfMem);
	ErrorCrit=savecrit;

	szCurDialogCaption = saveDialogCaption ;

	DialogIsAlert(FALSE) ;

	fProcessingOutOfMemory = FALSE ;
} /* OutOfMemory */

/*
	Work Buffer Routines
  -- a near work buffer MUST be provided by the application
  -- This assumes a stack like allocation/freeing!!
*/

#define NEARBUFFERMAX   10000

BYTE rgbBuffer[NEARBUFFERMAX];
BYTE *pbBuffer = rgbBuffer;

/* This guarantees that we know the end of the near heap; */
BYTE *pbBufferEnd = rgbBuffer + NEARBUFFERMAX - 1; 

extern VOID NoMemBailOut(void) ;

VOID * FAR PASCAL PbAllocWork(WORD cb)
{
	BYTE *pbRet = pbBuffer;

	pbBuffer += cb+(cb&1); // always even
	if (pbBuffer > (pbBufferEnd+1))
	{
		OutOfMemory();
		// DoExit() ;
		NoMemBailOut() ;
	}
	return pbRet;
}

VOID FAR PASCAL FreeWork(VOID *pv)
{
	assert(pv != NULL) ;

	if(pv)
	   pbBuffer = pv;
}


extern VOID SetUpExitToDos(void); /* see init.c */

extern BOOL gfScreenModeChanged;
extern BOOL gfSwapHandlerInstalled;
extern WORD ReturnScreenMode;
extern void RemoveSwapHandler(void) ;

VOID NoMemBailOut(void)
{
	SetUpExitToDos();

	 /* Warning! can't make the following call after EndCow() etc as that guy will
	  * do an UnHookIS9() and the order in which we unhook will be messed
	  * up and the keyboard could lock up!!
	  */
	OurUnHookISR9() ;

	if (gfScreenModeChanged)
	{
		if (FQueryInst(&ginst, ReturnScreenMode))
		{
			FInitScreen(&ginst,0);
		}

		EndScreen(TRUE);
		EndCow(TRUE);
	}
	if (gfSwapHandlerInstalled)
		RemoveSwapHandler() ;


	Shell_TTY_Out(szBailOutNoMem);
	exit(-1);

}
/*
  -- allocation for screen saves, etc.
  -- NOTE : If this fails on screen saves, we have some screen refresh problems
*/
VOID FAR * FAR PASCAL LpbAllocWorkFar(WORD cb)
{
	WORD FAR *lpw;
	HANDLE hmem;

	if ((hmem = GlobalAlloc(0, (DWORD) (cb+2))) == NULL)
	{
		if(gfStillInitializing)
		{
			NoMemBailOut();

		}

		return NULL ;
	}
	lpw = (WORD FAR *) GlobalLock(hmem);
	*lpw++ = hmem;   /* save handle */
	return (lpw);
}

VOID FAR PASCAL FreeWorkFar(VOID FAR *lpb)
{
	HANDLE hmem = *(((WORD FAR *)lpb) - 1);

	/* ZZZZZ remove assert before shipping! */
	assert(lpb != NULL) ;

	if (lpb != NULL)
	{
		GlobalUnlock(hmem);                     /* not really needed */
		GlobalFree(hmem);
	}
}

/*
  -- fake local memory handler : for SDM
  -- in the future we may "fix" SDM so that near pointers will be used
	instead of handles
*/
VOID ** FAR PASCAL PpvAllocCb(WORD sb, WORD cb)
/*
  -- return handle to a memory block
*/
{
	WORD *pw;

	UnReferenced(sb) ;

	if ((pw = (WORD *) PbAllocWork(cb+(cb&1) + 2*sizeof(WORD))) != NULL)
		*pw = (WORD) (pw+2+((WORD)pw&1));
		*(pw+1) = (WORD) cb;

	return ((VOID **) pw);
}

VOID FAR PASCAL FreePpv(WORD sb, VOID **ppv)
{
	WORD *pw ;

	UnReferenced(sb) ;

	pw = (WORD *)ppv;
	FreeWork(pw);
}

/* The following is a define for CW...This may no longer be necessary?
 * BUG BUG
 */
unsigned long pwndCur;

WORD FAR PASCAL cbSizePpv(WORD sb, VOID **ppv)
{
	WORD *pw = (WORD *)ppv;

	UnReferenced(sb) ;
	return(*pw+1);
}

BOOL FAR PASCAL Fcheckhandle(WORD sb, VOID **ppv)
{
	UnReferenced(sb) ;
	UnReferenced(ppv) ;

    return(FALSE);
}

VOID ** FAR PASCAL FReAllocPpv(WORD sb, WORD **ppv, WORD size)
{
	VOID **tppv;

    FreePpv(sb,ppv);
    tppv = (PpvAllocCb(sb,size));
    if (tppv)
	{
	  strncpy((uchar *)*tppv, (uchar *) *ppv, size);
	  return(tppv);
    }
    else
       return(NULL);
}

/* BUG BUG this should no longer be necessary?
 */
VOID FAR PASCAL addchildhead()
{
}

/* ZZZZZZZ */
/* WARNING!! Major hack from hell to get past CW's problem. CW does not free
 * previously allocated unused graphics driver memory when we call
 * TermGraphics() and then set the screen mode to the new mode.
 *
 * Right now we are using the fact that the current version of the library
 * does 3 far allocs at start up irrespective of whether it is text
 * mode or graphics mode.
 * Any further allocs are specific to whether it is text/graphics mode
 * or whether it is CGA driver or any other one.
 * Later on, whenever we perform a screen mode change it allocates
 * more without freeing the previously allocated extra buffers.
 * We are also using the fact that the number of extra buffers it
 * requests is 1 or 2 far allocs -- no more than 2.
 * Thus at all times, CW should have a maximum of 5 far allocations (and 1
 * near allocation)! We store the last 2 far allocations that it should be
 * freeing on a screen mode change and get rid of them whenever we
 * try to change screen modes using fn SetScreenMode() in INIT.C
 */

/* Following two will have the handles of the screen driver allocated memories
 * that are special to graphics mode. "ghackDriverFarAllocCount" is also part
 * of the hack to free the unused memories.
 */
HANDLE gDriverMemHandle1 ;
HANDLE gDriverMemHandle2 ;
int ghackDriverFarAllocCount = 0 ;

/**** for DOSSHELL ***/
/* The memory this function allocates should be paragraph aligned */
/* This is the reason we don't call LpbAllocWorkFar!!             */
WORD FAR *PASCAL LpwAllocDriverMem(WORD cw,WORD fmem)
{
	   HANDLE hmem ;

	   if (fmem == fmemNear)
	   {
#ifdef DEBUG
			com1("near alloc of:") ;
			com1i(cw) ;
			com1("\n") ;
#endif

		   /* CW asks for 14 bytes or so of this memory just once!!
			* God knows why??
			*/
		  /* WARNING! This will be the first near memory allocation! That
		   * is, it will be invoked before any other calls to PbAllocWork
		   * this is important as we perform stack wise allocs & frees of
		   * near memory!
		   */
		  return((WORD FAR *)PbAllocWork(cw<<1)) ;
	   }

#ifdef DEBUG
	com1("far alloc of:") ;
	com1i(cw) ;
	com1("\n") ;
	Beep() ;
#endif

	ghackDriverFarAllocCount++ ;

#ifdef DEBUG
	/* CW should not be needing more than 5 far buffers for drivers!! */
	/* ZZZZZZZZ Remove before shipping */
	if (ghackDriverFarAllocCount > 5)
	{
		ShellMessageBox("Driver Error", "More far memory allocations requested by driver -- report to Microsoft") ;
		DoExit() ;
	}
#endif
	hmem = GlobalAlloc(0, (DWORD)cw<<1);

	if (ghackDriverFarAllocCount == 4)
		gDriverMemHandle1 = hmem ;
	else
	if (ghackDriverFarAllocCount == 5)
		gDriverMemHandle2 = hmem ;

	if(!hmem)
		NoMemBailOut();

	return((WORD FAR *)GlobalLock(hmem));
} /* LpwAllocDriverMem */

/* ZZZZZZZ This routine is never called by CW right now, as we don't use
 * FreeInstBuffers()!
 */
VOID FAR PASCAL FreeDriverMem(WORD FAR *lpw)
{
#ifdef KANJI
	if (HIWORD((WORD FAR * )&lpw) == HIWORD(lpw))
		FreeWork((WORD *)lpw);
	else
	{
		GlobalUnlock(HIWORD(lpw));              /* not really needed */
		GlobalFree(HIWORD(lpw));
	}
#else
	UnReferenced(lpw) ;

	/* We can't free the near memory that we may have given to CW as
	 * fn PbAllocWork() does a stack based alloc and we may not free
	 * in that manner. If we can figure out whether lpw is near or
	 * far memory, we can free it!!
	 */
	 /* Basically we don't free right now using this function!! */

	assert(TRUE) ;
#endif /* KANJI */

} /* FreeDriverMem */


/* Our version of function FreeInstBuffers() to free the extra far memory
 * allocations for screen modes (INST buffers)
 */
void OurHackFreeDriverMem(void)
{
	if (ghackDriverFarAllocCount < 4)
		return ;

	GlobalUnlock(gDriverMemHandle1);                /* not really needed */
	GlobalFree(gDriverMemHandle1);

	if (ghackDriverFarAllocCount == 5)
	{
		GlobalUnlock(gDriverMemHandle2);                /* not really needed */
		GlobalFree(gDriverMemHandle2);
	}
	
	ghackDriverFarAllocCount = 3 ;
} /* OurHackFreeDriverMem */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\pfiles.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

?WIN = 0                ;Not windows;
?PLM = 1		;DO use pl/m
include cmacros.inc


; 5 byte packet for int 2f to print a file.
sBegin data
packet	label BYTE
	version			db	0 		; the first byte of the packet should have 0
	file_offset		dw	?		; offset of file name (to be printed)
	file_segment	dw	?		; segment of file name (to be printed)
sEnd data

sBegin code
    assumes cs, code
    assumes ds, DGROUP

;
; int pascal check_spooler() ;
;	returns 
;	        0 if print spooler installed.
;			1 if print spooler not installed  
;
cProc  check_spooler, PUBLIC,  <si,di,ds,es>
cBegin	check_spooler
	mov	ax, 0100h		; ah=01, al=00 Get printer installed state.
	int	2fh
	jc	short CS_Error	; function unsuccesful

	; function call was succesful
	; AL gives us the spooler state
	; = 00H if not installed, OK to install
	; = 01H if not installed, NOT OK to install
	; = FFH if installed

	xor ah, ah
	inc	al
	jz	CS_End

	; We get here if function unsuccesful or if spooler not installed.
	; al was not FFH at function return.
CS_Error:
	mov	ax, 1

CS_End:
	; ax is 0 at this point if we jumped to this label!!

cEnd  check_spooler

;
; int pascal a_print_file(char *name) ;
;	input: full path name of file to be printed.
;	returns 
;	        0 if file submitted for printing succesfully
;			1 if file could not be submitted.
;
cProc  a_print_file, PUBLIC,  <si,di,ds,es>
parmW string_segment
parmW string_offset
cBegin	a_print_file

	lea  dx, packet		; DS:DX = ptr to print packet

	; the 4 bytes after the first one in packet should have the 
	; segment:offset of the ASCIIZ filename.
	mov	ax, string_segment
	mov	file_segment, ax

	mov	ax, string_offset
	mov	file_offset, ax

	mov	ax, 0101h		; ah=01, al=01 File to be submitted for printing

	int	2fh

	; Carry set implies error and ax = error code.
	jc	err_exit

	xor	ax, ax		; Mark return status specifying file submitted succesfully

err_exit:

cEnd  a_print_file



sEnd   code


end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\scancode.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

?WIN = 0                ;Not windows;
?PLM =    1             ;DO use PL/M calling conventions

;This hook is used only when the user is entering a hotkey for the
;switcher.  Thus, int 9 is hooked when the properties dialog is put up,
;and unhooked when the properties dialog is taken down.
;The hook stores the scancode and shift state of the key sequence
;in global (cs) variables. 
;NOTE: this method was suggested by the CW developers on recognition
;that the keydown/keyup documentation is incorrect; this is the only
;way to get the codes they say.

include cmacros.inc
sBegin code

    assumes cs, code
    assumes ds, code

extrn scLatest:FAR 

;;;WARNING gscancode should not initialize to zero! (compares to null hot key)
gscancode       db      0FFh            ; scan code of key just hit
gkeyup          db      1               ; startup is "last key down is up"
gshiftstate     db      0               ; shift state of key just hit
ISR9            dd      ?               ; ptr to old int 9 function

;INPUT none 
;RETURNS scancode in al,shiftstate in ah of last int9 event
;
cProc  GetLastScanCode, PUBLIC,  <si,di,ds,es>
cBegin GetLastScanCode
	mov     al,cs:gscancode
	mov     ah,cs:gshiftstate
	;;;     treat shift as right+left
	test    ah,3 ;; either shift down?
	jz      no_shift
	or      ah,3 ;; set both states as down
no_shift:
cEnd  GetLastScanCode

;INPUT none 
;RETURNS 0 if last key was key down, non zero if last key
;       was key up
;
cProc  GetLastKeyState, PUBLIC,  <si,di,ds,es>
cBegin GetLastKeyState
	mov     al,cs:gkeyup
	xor     ah,ah
cEnd  GetLastKeyState


;INPUT none
;RETURNS none
;FUNCTION places our keyboard hook in the int9 chain
cProc  HookISR9, PUBLIC,  <si,di,ds,es>
cBegin HookISR9
	    push cs
	    pop  ds

	    mov ax,3509h                 ; save interrupt 09 location
	    int 21h

	    mov WORD PTR ISR9,bx
	    mov ax,es
	    mov WORD PTR ISR9[2],ax

	    mov dx,offset cs:int9hook       ;patch interrupt 09 vector with
	    ;;; ds already holds code segment
	    mov ax,2509h                 ;our own routine
	    int 21h
cEnd  HookISR9

;INPUT none
;RETURNS none
;FUNCTION takes our int 9 hook out of the chain
;WARNING must be preceded by a HookISR9!
cProc  UnHookISR9, PUBLIC,  <si,di,ds,es>
cBegin UnHookISR9

	    mov dx,WORD PTR cs:ISR9      ;patch interrupt 09 vector with
	    mov ds,WORD PTR cs:ISR9[2]
	    mov ax,2509h                 ;the old handler
	    int 21h

cEnd  UnHookISR9

;This is the int 9 hardware hook.
;All it does is record the scan code and shift state of the last
;keyboard event.

int9hook        proc    far

	pushf                           ; simulate the real interrupt:
	call    cs:ISR9                 ; call real int 9

	push ax                         ; save registers
	push ds

	;;; We can tell that this is a keyup in two ways, depending
	;;; on the machine (XT,AT)
	;;; Docs say that F0 scan code means that the next action is
	;;; a keyup. This is for XTs. For ATs, the high bit is set
	;;; in the scancode to mean key up.
	;;; so, our algorithm is this:
	;;;     if ((lastscancode == F0h) || (thiscancode & 0x80))
	;;;             its a key up
	;;;     else  its a keydown
	mov     ax,DGROUP
	mov     ds,ax
	assumes ds , DGROUP
	mov     al,byte ptr ds:scLatest
	;;in      al,60h                  ; put scan code into al

	push    bx
	xor     bx,bx
	cmp     cs:gscancode,0F0h       ;gscancode has last int 9 code
	jne     XTlastwasnotbreak       ;if it was an XT style break sequence
	inc     bl                      ;set break bool in bl
XTlastwasnotbreak:
	test    al,080h                 ;this scancode is in al now
	jz      ATlastwasnotbreak       ;if it has an AT style break
	cmp     al,0E0h
	je      ATlastwasnotbreak
	inc     bl                      ;set break bool in bl
ATlastwasnotbreak:      
	mov     cs:gscancode,al         ; save in scancode global
	mov     cs:gkeyup,bl            ; save keyup/down state
	pop     bx      

	push    es
	mov     ax, 40h
	mov     es, ax

	or     byte ptr es:[17h],80h    ; set insert flag as we are always insert
	mov     al, byte ptr es:[17h]   ; bios location of keyboard state and status flags
	pop     es
	mov     cs:gshiftstate,al       ; save keyboard state into global

	pop     ds
	pop     ax
	iret

int9hook        endp


sEnd   code
end





















=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\menus.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****   menus.c - fns for creating menu bars
** This file contains Scottq's "easy" menu functions for more easily
** constructing menu bars.  It also contains the global menu bar structures,
** and the fn which initialises the menu bars.
**
**   Date      Author   Modification
** --------   --------  ------------------------------------------------
**  ?/??/87   scottq    wrote easymenu() and friends
**  7/17/89   t-jeffro  FileMgrBar has entry to exit to main menu.
**  8/??/89   harikris  Added Exit, History menu items.
*/


#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
extern VOID HelpBox(void);
extern VOID KeyBox(void);
extern VOID IndexBox(void);
extern VOID BasicsBox(void);
extern VOID CommandsBox(void);
extern VOID ProceduresBox(void);
extern VOID UsingHelpBox(void);

extern VOID CopyProgram(void);
extern VOID ReorderGroup(void);
extern VOID Run(void);
extern void DoFullRefresh(void) ;
extern void DoDiskReread(void) ;
extern VOID DoShareMode(void);
extern char gStartInDir[] ;
extern BOOL gfFMVisited ;

extern VOID PDoSingleTree(void);
extern VOID PDoDoubleTree(void);
extern VOID PDoFlatDisplay(void);
extern VOID PDoShareMode(void);

extern VOID DisableTaskList(void);
extern VOID EnableTaskList(void);
extern VOID DisableSwitching(void);
extern VOID EnableSwitching(void);
extern VOID ColorBox(void);
extern VOID ScreenBox(void);
extern VOID SelectAcrossDirs(void) ;

extern VOID AsciiFileView(void) ;
extern VOID HexFileView(void) ;
extern VOID ExitFileView(void) ;

extern BOOL FPerformDirOperation(void) ;
extern unsigned int CountFilesToOperateOn(void) ;
extern VOID ShellAboutBox(void);
char far cdecl C_GET_LIST_LENGTH(void);

extern VOID RereadSelectedDir(void) ;

extern BOOL gInReorder, gInCopy;
extern BOOL ascii ; /* mode in which file is being viewed in ViewFile */
extern BOOL gTaskListEnabled;
extern BOOL gSwitchingEnabled;
extern TOKEN gGroupLevel;
extern struct ListBoxData ProgramList;

VOID  MySetColor(WORD color);

extern BOOL gAlreadyTasking;
/* ZZZZZ following fn needed?? */
VOID FAR DoNothing(VOID)
{
}


PMTM FAR PASCAL PmtmAddItem(HMNU hmnu, WORD idBefore, WORD idNew,
							CHAR *sid, HMNU hmnuSub, WORD cwExtra, BYTE bFlags)
/*
  -- create new item in menu
  -- put all specified information into it
*/
{
	WORD    cb;
	HMNU    hmnuNew;
	register PMTM   pmtmItem;

	cb = cbMTM + cwExtra * sizeof(WORD);
	if (bFlags & MM_STRING)
		cb += (strlen(sid) & 0xFFFE) + 2;
	if (hmnuSub != NULL)
		cb += sizeof(HANDLE);

	/* idBefore must be idNil!!*/
		if(idBefore == idNil)
		{
		while ((*hmnu)->hmnuNext != NULL)
			hmnu = (*hmnu)->hmnuNext;

			{
			hmnuNew = HmnuNewMenu();

			if (!FReAllocPpv(NULL, (WORD **)hmnuNew, cbMNU + cb))
				return(NULL);

			(*hmnu)->hmnuNext = hmnuNew;
			pmtmItem = &(*hmnuNew)->grmtm;
			(*hmnuNew)->cmtm = 1;
			}
		}

	pmtmItem->bFlags = bFlags & ~MM_SUBMENU;

	pmtmItem->id = idNew;
	pmtmItem->cwTotal = (BYTE) (cb/2 - cwMTM) ;

	if (bFlags & MM_STRING)
	{
		pmtmItem->u.iwString = cwExtra;
		strcpy((char *)&pmtmItem->rgwExtra[cwExtra], sid);
	}
	 else
		pmtmItem->u.sid = (WORD) sid;

	if (hmnuSub != NULL)
	{
		pmtmItem->bFlags |= MM_SUBMENU;
		pmtmItem->rgwExtra[pmtmItem->cwTotal-1] = (WORD) hmnuSub;
	}

	return(pmtmItem);
}

/* Functions called by menu items */

/* Menu bar structures */
MENUINFO MainMenuBar;
MENUINFO FileMgrMenuBar;
MENUINFO ViewMenuBar;

#define MENUBARY 1     /* y location of the menu bar */
#define MENUGAP 2
#define MENUBORDER 5
#define MENUTOPBOTTOM 2

#define NUMMENUS 115
int       (FAR *menuproc[NUMMENUS])(void);
BYTE      emenustate[NUMMENUS];
#define NUMDROPDOWNS 12
ARC       menurect[NUMDROPDOWNS];
BYTE      rectindex[NUMMENUS];
int       gNthmenu = 0;
int       gNthdropdown = 0;
int       gCurMenuX;    /* start of next menu */
int       gFMfilestart;
int       gPMfilestart;
int   gViewstart;

/* These menu-id's are used to implement key board accelerators. These need
 * to be the 'id's of menus that remain always enabled. In our case we are
 * guaranteed that the help menu items under the program-manager and the
 * file-manager are never disabled!!
 */
int     gPMMagicShiftF9, gFMMagicShiftF9 ;
int     gFMMagicTab, gPMMagicTab ;
int     gPMMagicShiftTab, gFMMagicShiftTab ;
int     gPMMagicAltTab, gFMMagicAltTab ;
int     gFMMagicCtrlF5 ;

VOID initbar(MENUINFO *amenu)
{
    *amenu = HmnuNewMenu();
    gCurMenuX = 0;
}

HMNU gCurmen;

VOID easyitem(MENUINFO *amenu,char *name,int keyequiv,int (FAR *theproc)())
{
	int temp;
	int slen;

	UnReferenced(amenu) ;
	UnReferenced(keyequiv) ;

	menuproc[gNthmenu] = theproc;
	emenustate[gNthmenu] = MM_ENABLED;
	PmtmAddItem(gCurmen,idNil,gNthmenu,name,NULL,0,MM_ENABLED);
	/*
	 * calculate the length of the longest string in popdown menu
	 * and update the graphic rectangle's width
	 */
	temp = menurect[gNthdropdown-1].axRight -
	       menurect[gNthdropdown-1].axLeft - MENUBORDER;
#ifdef KANJI
	slen = strlen(name)-1-1; /* for ~ */
#else
	slen = strlen(name)-1; /* for ~ */
#endif
	if (slen > temp)
	{
	    menurect[gNthdropdown-1].axRight =
	    menurect[gNthdropdown-1].axLeft + MENUBORDER + slen;
	}
	menurect[gNthdropdown-1].ayBottom += 1;
	rectindex[gNthmenu] = (BYTE) gNthdropdown-1;

	++gNthmenu;
}

VOID makeamenu(MENUINFO *amenu, char *name, int keyequiv)
{
	HMNU hmnunew;

	UnReferenced(keyequiv) ;

	hmnunew = HmnuNewMenu();
	gCurmen = hmnunew;
	PmtmAddItem(*amenu,idNil,(gNthdropdown+NUMMENUS), name, hmnunew,
												0, (BYTE)MM_ENABLED);
	menurect[gNthdropdown].ayTop   = MENUBARY+1;
	menurect[gNthdropdown].ayBottom= MENUBARY+1+MENUTOPBOTTOM;
	menurect[gNthdropdown].axLeft  = (BYTE) gCurMenuX;
	menurect[gNthdropdown].axRight = (BYTE) gCurMenuX+MENUBORDER; /* updated in easyitem */

	++gNthdropdown;
#ifdef KANJI
	gCurMenuX += MENUGAP + strlen(name) - 1 - 1;
#else
	gCurMenuX += MENUGAP + strlen(name) - 1;
#endif
}

#define easymenu(amenu,name,keyequiv) makeamenu(amenu,name,keyequiv)

VOID easyseparator(MENUINFO *amenu)
{
	UnReferenced(amenu) ;

	PmtmAddItem(gCurmen,idNil,gNthmenu,"",NULL,2,MM_SEPARATOR);
	menurect[gNthdropdown-1].ayBottom += 1;
	emenustate[gNthmenu] = MM_SEPARATOR;

	++gNthmenu;
}

VOID easycheck(int (FAR *theproc)(), BOOL docheck)
{
   int i;

	for(i = 0; i<gNthmenu; i++)
	{
		if (menuproc[i] == theproc)
		{
			CheckMenuItem(i,docheck);
		}
	}
}

VOID easyenable(MENUINFO *amenu, int (FAR *theproc)(), BOOL doenable)
{
   int i;

	UnReferenced(amenu) ;

	for(i = 0; i<gNthmenu; i++)
	{
		if (menuproc[i] == theproc)
		{
			if(doenable)
			emenustate[i] = emenustate[i] & (~MM_DISABLED);
			else
			emenustate[i] |= MM_DISABLED;
			EnableMenuItem(i, doenable);
		}
	}
}


#define KEY_DELETE 127

MPVKEYID gAccelerators[25];
MPVKEYID *pAccel;

void InitAccelerators(void)
{
    pAccel = gAccelerators;

    /* first entry is dummy according to addacceltable spec */
    //gAccelerators[0].vkey = ;
    //gAccelerators[0].idItem = ;
    gAccelerators[1].vkey = 0;
    gAccelerators[1].idItem = 0;
    AddAccelTable(&pAccel);

}

void AddViewAccelerators(void)
{

    pAccel = gAccelerators;

    DeleteAccelTable(&pAccel);

    /* first entry is dummy according to addacceltable spec */
    //gAccelerators[0].vkey = ;
	//gAccelerators[0].idItem = ;

	gAccelerators[1].vkey = VK_F1;
	gAccelerators[1].idItem = gViewstart+3;

	gAccelerators[2].vkey = 0;
	gAccelerators[2].idItem = 0;

} /* AddViewAccelerators */

void AddProgManAccelerators(void)
{

    pAccel = gAccelerators;

    DeleteAccelTable(&pAccel);

    /* first entry is dummy according to addacceltable spec */
    //gAccelerators[0].vkey = ;
    //gAccelerators[0].idItem = ;

    /* The next are for our "special" accelerators that
     * don't have menu items. We need these since they
     * must also work when a menu is poped-down, or alted.
     */
	gAccelerators[1].vkey = VK_F9|KK_SHIFT;
	gAccelerators[1].idItem = gPMMagicShiftF9 ;
#define PMOPEN 1
#define PMDELETE 3
#define PMEXIT   PMDELETE+6
#define PMREFRESH PMEXIT + 7+7
#define PMHELP   PMREFRESH+1
    /* The actual one-for-one accelerators */
	gAccelerators[2].vkey = KK_ALT+VK_F4;
	gAccelerators[2].idItem = gPMfilestart+9;
	// gAccelerators[3].vkey = VK_DELETE;
	gAccelerators[3].vkey = KEY_DELETE ; /* ZZZZ VK_DELETE doesn't work!! */
	gAccelerators[3].idItem = gPMfilestart+PMDELETE ;
	gAccelerators[4].vkey = VK_F3 ;
	gAccelerators[4].idItem = gPMfilestart+PMEXIT;
	gAccelerators[5].vkey = VK_F1 ;
	gAccelerators[5].idItem = gPMfilestart+PMHELP;
	gAccelerators[6].vkey = 127;/* 127 ==delete */
	gAccelerators[6].idItem = gPMfilestart+PMDELETE;

	gAccelerators[7].vkey = '\t'/*VK_TAB*/|KK_ALT;
	gAccelerators[7].idItem = gPMMagicAltTab ;
	gAccelerators[8].vkey = VK_F5|KK_SHIFT;
	gAccelerators[8].idItem = gPMfilestart+PMREFRESH;
	gAccelerators[9].vkey = '\t';
	gAccelerators[9].idItem = gPMMagicTab ;
	gAccelerators[10].vkey = '\t'|KK_SHIFT;
	gAccelerators[10].idItem = gPMMagicShiftTab ;
	gAccelerators[11].vkey = '\n'|KK_SHIFT|KK_CONTROL;
	gAccelerators[11].idItem = PMOPEN ;
	gAccelerators[12].vkey = 0 ;
	gAccelerators[12].idItem = 0 ;

    AddAccelTable(&pAccel);
}

void AddFileManAccelerators(void)
{
    pAccel = gAccelerators;

    DeleteAccelTable(&pAccel);

    /* first entry is dummy according to addacceltable spec */
    //gAccelerators[0].vkey = ;
    //gAccelerators[0].idItem = ;

    /* The next are for our "special" accelerators that
     * don't have menu items. We need these since they
     * must also work when a menu is poped-down, or alted.
     */
    gAccelerators[1].vkey = '\t';
	gAccelerators[1].idItem = gFMMagicTab ;
    gAccelerators[2].vkey =  '\t'/*VK_TAB*/|KK_ALT;
	gAccelerators[2].idItem = gFMMagicAltTab ;
    gAccelerators[3].vkey = VK_F9|KK_SHIFT;
	gAccelerators[3].idItem = gFMMagicShiftF9 ;
#define FMVIEWFILE 5
#define FMMOVE FMVIEWFILE + 2
#define FMCOPY FMMOVE+1
#define FMDELETE FMCOPY+1
#define FMSELECTALL FMDELETE+6
#define FMDESELECTALL FMSELECTALL + 1
#define FMEXIT FMDESELECTALL+2
#define FMREPAINT FMEXIT + 7+7
#define FMREFRESH FMREPAINT+1
#define FMEXPAND1 FMREPAINT+2
#define FMEXPANDBRANCH FMEXPAND1+1
#define FMEXPANDALL FMEXPANDBRANCH+1
#define FMCOLLAPSE FMEXPANDALL+1
#define FMHELP FMCOLLAPSE+1
    /* The actual one-for-one accelerators */
	gAccelerators[4].vkey = VK_F7;
	gAccelerators[4].idItem = gFMfilestart+FMMOVE;
	gAccelerators[5].vkey = VK_F8;
	gAccelerators[5].idItem = gFMfilestart+FMCOPY;
	// gAccelerators[6].vkey = VK_DELETE;
	gAccelerators[6].vkey = KEY_DELETE ; /* ZZZZZ VK_DELETE doesn't work!! */
	gAccelerators[6].idItem = gFMfilestart+FMDELETE;
	gAccelerators[7].vkey = KK_CONTROL | '/';
	gAccelerators[7].idItem = gFMfilestart+FMSELECTALL;
	gAccelerators[8].vkey = KK_CONTROL|28;/* 92 == cntrl+\ */
	gAccelerators[8].idItem = gFMfilestart+FMDESELECTALL;
	gAccelerators[9].vkey = KK_ALT|VK_F4;
	gAccelerators[9].idItem = gFMfilestart+FMEXIT;
    /* last entry is zeros */
	gAccelerators[10].vkey = '+' ;
	gAccelerators[10].idItem = gFMfilestart+FMEXPAND1;
	gAccelerators[11].vkey = '*' ;
	gAccelerators[11].idItem = gFMfilestart+FMEXPANDBRANCH;
	gAccelerators[12].vkey = KK_CONTROL|'*' ;
	gAccelerators[12].idItem = gFMfilestart+FMEXPANDALL;
	gAccelerators[13].vkey = '-';
	gAccelerators[13].idItem = gFMfilestart+FMCOLLAPSE;
	gAccelerators[14].vkey = VK_F3;
	gAccelerators[14].idItem =gFMfilestart+FMEXIT;
	gAccelerators[15].vkey = VK_F1 ;
	gAccelerators[15].idItem = gFMfilestart+FMHELP;
	gAccelerators[16].vkey = KK_SHIFT|'+' ;
	gAccelerators[16].idItem = gFMfilestart+FMEXPAND1;
	gAccelerators[17].vkey = KK_SHIFT|'*' ;
	gAccelerators[17].idItem = gFMfilestart+FMEXPANDBRANCH;
	gAccelerators[18].vkey = KK_SHIFT|KK_CONTROL|'*' ;
	gAccelerators[18].idItem = gFMfilestart+FMEXPANDALL;

	gAccelerators[19].vkey = VK_F5|KK_SHIFT ;
	gAccelerators[19].idItem = gFMfilestart+FMREPAINT;

	gAccelerators[20].vkey = VK_F9 ;
	gAccelerators[20].idItem = gFMfilestart+FMVIEWFILE; /* viewfile */

    gAccelerators[21].vkey =  '\t'|KK_SHIFT ;
	gAccelerators[21].idItem = gFMMagicShiftTab ;
    gAccelerators[22].vkey =  VK_F5 ;
	gAccelerators[22].idItem = gFMfilestart+FMREFRESH ;
	gAccelerators[23].vkey = KK_CONTROL|VK_F5 ;
	gAccelerators[23].idItem = gFMMagicCtrlF5 ;

	gAccelerators[24].vkey = 0 ;
	gAccelerators[24].idItem = 0 ;

    AddAccelTable(&pAccel);
}


VOID setmenubar(MENUINFO *amenu, PWND towind)
{
	   ARC arcMenubar;

       arcMenubar.axLeft = 0;
       arcMenubar.axRight = axMac;
       arcMenubar.ayTop = MENUBARY;
       arcMenubar.ayBottom = MENUBARY+1;
       InitMenubar(towind, *amenu, &arcMenubar, MENUGAP);

}


VOID MenuCommand(PWND pwnd, WORD mid)
{
	char *pStartDir ;
	char RunInDir[MAX_PATH+1] ;
	int dummylen ;
	BOOL fHandled = TRUE ;

	UnReferenced(pwnd) ;

    if(gInReorder || gInCopy) {
	if(mid == ((gPMfilestart+PMHELP)|0xF000))
	    HelpBox();
	else if(mid>=(gPMfilestart+PMHELP) && mid<=(gPMfilestart+PMHELP+5))
	    (*menuproc[mid])();
	else
	    ShellMessageBox(szInRCTitle, szInRCText);
	return;
    }

	      if((mid & 0xF000) == 0xF000) /* is an acceleration */
	      {
			mid = mid & 0xFFF ;


			if (mid == gFMMagicTab || mid == gPMMagicTab)            /* TAB */
			{
				NextGlobalFocus();

			}
			else if ((mid == gFMMagicShiftTab) ||
				 (mid ==gPMMagicShiftTab))/* Shift+TAB */
				 {
					PrevGlobalFocus();
			}
			else if ((mid == gFMMagicAltTab) ||
				 (mid ==gPMMagicAltTab))/* Shift+TAB */
				 {
#ifndef NOSWITCHER
					if (gSwitchingEnabled && C_GET_LIST_LENGTH()) //number of tasks is 0 based, one is shell
					{
				       LaunchProgram(NullString,NullString,0);
					}       
					else
					{
						Shell_Beep();
					}
#endif
				 }
			else if ( (mid == gFMMagicShiftF9) || /* Shift+F9 */
					  (mid == gPMMagicShiftF9) )
			{
				
				/* By default we would want to use the directory in which the user
				 * was when he started the DOSSHELL. This will be valid if Run is
				 * done from PM and the FM has not been visited.
				 */
				pStartDir = gStartInDir ;

				if (gfFMVisited)
				{
					Tree2Path(listinfo[glob.FocusBox].tree,
							   listinfo[glob.FocusBox].files, RunInDir, &dummylen) ;
					pStartDir = RunInDir ;
				}
				DoCommand(NULL, pStartDir);
			}
			else if ( (mid == gFMfilestart+FMHELP) ||
					  (mid == gPMfilestart+PMHELP) )
				HelpBox();
			else if ( mid == gFMMagicCtrlF5)
				RereadSelectedDir() ;
			else
				fHandled = FALSE ;
			/* else, it's not one our our "special" keys */
			/* fall through, mid is already "fixed" */
		  }
		  else
				fHandled = FALSE ;
	if (!fHandled)
	{
		if(emenustate[mid] & MM_DISABLED)
		{
			Shell_Beep();
		}
	    else
		{
			if ((mid >= 0) && (mid < gNthmenu) && (menuproc[mid] != NULL))
				(*menuproc[mid])();
	    }
	}
}


/***/
/***/


VOID FrameMenu(PWND pwnd,WORD mid)
{

   RECT lRect;
   int whichmenu;
   WORD fore,back;
	int i;
	int firstid;

	if (mid >= NUMMENUS)
	{
		whichmenu = mid - NUMMENUS;
		firstid = whichmenu;
	}
   else
	{
		firstid = mid;
		whichmenu = rectindex[mid];
	}
   if (gisgraph)
   {
		FEnableMouseNest(FALSE) ;

		lRect.xLeft =    menurect[whichmenu].axLeft * CWIDTH;
		lRect.yTop  =    menurect[whichmenu].ayTop * CHEIGHT;
		lRect.xRight =  (menurect[whichmenu].axRight -1) * CWIDTH;
		lRect.yBottom = menurect[whichmenu].ayBottom *CHEIGHT;

		GetIsaColor(isaBorders,&fore,&back);
		MySetColor(fore);
		SetAreaPat(0);
		SetLinePat(1);
		Rectangle(&lRect);
		
		if(firstid != whichmenu)
		{
			while(rectindex[firstid-1] != rectindex[firstid])
				--firstid;
		}
		else
		{
			for(i=0;i<NUMMENUS;i++)
			{
				if(rectindex[i] == (BYTE) whichmenu)
				{
					firstid = i;
					break;
				}
			}
		}               
		for(i=0;i<menurect[whichmenu].ayBottom - menurect[whichmenu].ayTop;i++)
		{
			if(emenustate[firstid+i-1] & MM_SEPARATOR)
			{
				Move(lRect.xLeft,lRect.yTop+i*CHEIGHT+CHEIGHT/2);
				Draw(lRect.xRight-1,lRect.yTop+i*CHEIGHT+CHEIGHT/2);
			}
		}
		FrameMenuBar(pwnd);
		FEnableMouseNest(TRUE) ;
   }
}


VOID FrameMenuBar(PWND pwnd)
{
   WORD fore,back;
   UnReferenced(pwnd) ;

   if((gisgraph)&&(CHEIGHT > SMALLHEIGHT))
   {
       FEnableMouseNest(FALSE);
       SetAreaPat(0);
       SetLinePat(1);
       GetIsaColor(isaBorders,&fore,&back);
       MySetColor(fore);
       Move(0,CHEIGHT-1);
       Draw(axMac*CWIDTH-1,CHEIGHT-1);
       Move(0,2*CHEIGHT);
       Draw(axMac*CWIDTH-1,2*CHEIGHT);
       FEnableMouseNest(TRUE);
   }
}


VOID DoInitMenus()
/*
 *  Construct menus.
 *  MenuBar is the main menu
 *  OtherMenu is an extended menu (example)
 */
{
	/* Set up the Main menu */

	initbar(&MainMenuBar);

	easymenu(&MainMenuBar,szmFile,0);
	gPMfilestart = gNthmenu;
	easyitem(&MainMenuBar,szmNew,0,AddProgram);
	easyitem(&MainMenuBar,szmOpenEnter,0,StartAProgram);
	easyitem(&MainMenuBar,szmCopy,0,CopyProgram);
	easyitem(&MainMenuBar,szmPMDelete,0,DeleteProgram);
	easyitem(&MainMenuBar,szmProperties,0,ChangeProgram);
	easyitem(&MainMenuBar,szmReorder,0,ReorderGroup);

	easyseparator(&MainMenuBar);
	easyitem(&MainMenuBar, szmRun, 0, Run);
	easyseparator(&MainMenuBar);

	easyitem(&MainMenuBar,szmPMExit,1,DoExit);

	easymenu(&MainMenuBar, szmOptions,0);
	easyitem(&MainMenuBar, szmFileOptions, 0, DoFileOptions);
	easyitem(&MainMenuBar, szmDispOptions, 0, DisplayOptions);
	easyitem(&MainMenuBar, szmSelectAcrossDirectories,0, SelectAcrossDirs);
	easyitem(&MainMenuBar, szmShowInfo, 0, ShowInfo);
	easyitem(&MainMenuBar, szmEnableSwitching,0,EnableSwitching);
	//easyitem(&MainMenuBar, szmDisableSwitching,0,DisableSwitching);
	//easyitem(&MainMenuBar, szmEnableTaskList,0,EnableTaskList);
	//easyitem(&MainMenuBar, szmDisableTaskList,0,DisableTaskList);
	easyitem(&FileMgrMenuBar, szmChangeScreen, 0, ScreenBox);
	easyitem(&FileMgrMenuBar, szmChangeColors, 0, ColorBox);

	easymenu(&MainMenuBar, szmView,0);

	/* View Menu */
	easyitem(&MainMenuBar, szmSingleFile, 0, PDoSingleTree);
	easyitem(&MainMenuBar, szmDualFile, 0, PDoDoubleTree);
	easyitem(&MainMenuBar, szmSystemFile, 3, PDoFlatDisplay);
#ifndef NOGROUPINFILE
	easyitem(&MainMenuBar,szmProgMan, 8, PDoShareMode);
#endif
	easyitem(&MainMenuBar,szmSoloProgMan, 0,ExitFileMgr);
	easyseparator(&MainMenuBar);
	easyitem(&MainMenuBar, szmRepaint, 1, DoFullRefresh);

	easymenu(&MainMenuBar, szmHelp, 0);
	easyitem(&MainMenuBar, szmHelpIndex,0,IndexBox);
	gPMMagicShiftF9 = gNthmenu;
	easyitem(&MainMenuBar, szmHelpKeys,0,KeyBox);
	gPMMagicAltTab = gNthmenu;
	easyitem(&MainMenuBar, szmHelpBasics,0,BasicsBox);
	gPMMagicTab = gNthmenu;
	easyitem(&MainMenuBar, szmHelpCommands,0,CommandsBox);
	gPMMagicShiftTab = gNthmenu;
	easyitem(&MainMenuBar, szmHelpProcedures,0,ProceduresBox);
	easyitem(&MainMenuBar, szmHelpF1,0, UsingHelpBox);
	easyseparator(&MainMenuBar);
	easyitem(&MainMenuBar, szmHelpAbout,0,ShellAboutBox);

/** initialize filemanager menus*/
	initbar(&FileMgrMenuBar);

	easymenu(&FileMgrMenuBar, szmFile, 0);
	gFMfilestart = gNthmenu;

	easyitem(&FileMgrMenuBar, szmOpen, 0, LaunchBox);
	easyitem(&FileMgrMenuBar, szmRun, 0, Run);
	easyitem(&FileMgrMenuBar, szmPrint, 0, DoPrintFiles);
	easyitem(&FileMgrMenuBar, szmAssociate, 0, DoAssociateBox);
	easyitem(&FileMgrMenuBar, szmSearchFor, 0, FileLocateBox);
	easyitem(&FileMgrMenuBar, szmViewF9, 0, DoViewFile);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmMove, 0, DoMoveFiles);
	easyitem(&FileMgrMenuBar, szmCopyF8, 0, DoCopyFiles);
	easyitem(&FileMgrMenuBar, szmFMDelete, 0, DoDelFiles);
	easyitem(&FileMgrMenuBar, szmRename, 0, DoRenameFiles);
	easyitem(&FileMgrMenuBar, szmChangeAttr, 1, DoChangeAttributes);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmCreateDir, 2, DoCreateDirectory);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmSelectAll, 0, DoSelectAll);
	easyitem(&FileMgrMenuBar, szmDeselectAll, 4, DoDeselectAll);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmFMExit, 1, DoExit);


	easymenu(&FileMgrMenuBar, szmOptions,0);
	easyitem(&FileMgrMenuBar, szmFileOptions, 0, DoFileOptions);
	easyitem(&FileMgrMenuBar, szmDispOptions, 0, DisplayOptions);
	easyitem(&MainMenuBar, szmSelectAcrossDirectories,0, SelectAcrossDirs);
	easyitem(&FileMgrMenuBar, szmShowInfo, 0, ShowInfo);
	easyitem(&FileMgrMenuBar, szmEnableSwitching,0,EnableSwitching);
	//easyitem(&FileMgrMenuBar, szmDisableSwitching,0,DisableSwitching);
	//easyitem(&FileMgrMenuBar, szmEnableTaskList,0,EnableTaskList);
	//easyitem(&FileMgrMenuBar, szmDisableTaskList,0,DisableTaskList);
	easyitem(&FileMgrMenuBar, szmChangeScreen, 0, ScreenBox);
	easyitem(&FileMgrMenuBar, szmChangeColors,0,ColorBox);

	easymenu(&FileMgrMenuBar, szmView,0);

	easyitem(&FileMgrMenuBar, szmSingleFile, 0, DoSingleTree);
	easyitem(&FileMgrMenuBar, szmDualFile, 0, DoDoubleTree);
	easyitem(&FileMgrMenuBar, szmSystemFile, 3, DoFlatDisplay);
#ifndef NOGROUPINFILE
	easyitem(&FileMgrMenuBar,szmProgMan, 8, DoShareMode);
#endif
	easyitem(&MainMenuBar,szmSoloProgMan, 0, ExitFileMgr);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmRepaint, 1, DoFullRefresh);
	easyitem(&FileMgrMenuBar, szmRefresh, 0, DoDiskReread);


	easymenu(&FileMgrMenuBar, szmTree,0);
	easyitem(&FileMgrMenuBar, szmExpOne, 1, DoExpand1Level);
	easyitem(&FileMgrMenuBar, szmExpBranch, 7, DoExpandBranch);
	easyitem(&FileMgrMenuBar, szmExpAll, 7, DoExpandAll);
	easyitem(&FileMgrMenuBar, szmCollBranch, 0, DoCollapse);

	easymenu(&FileMgrMenuBar, szmHelp, 0);
	easyitem(&FileMgrMenuBar, szmHelpIndex,0,IndexBox);
	gFMMagicShiftF9 = gNthmenu;
	easyitem(&FileMgrMenuBar, szmHelpKeys,0,KeyBox);
	gFMMagicAltTab = gNthmenu;
	easyitem(&FileMgrMenuBar, szmHelpBasics,0,BasicsBox);
	gFMMagicTab = gNthmenu;
	easyitem(&FileMgrMenuBar, szmHelpCommands,0,CommandsBox);
	gFMMagicShiftTab = gNthmenu;
	easyitem(&FileMgrMenuBar, szmHelpProcedures,0,ProceduresBox);
	gFMMagicCtrlF5 = gNthmenu;
	easyitem(&FileMgrMenuBar, szmHelpF1,0, UsingHelpBox);
	easyseparator(&FileMgrMenuBar);
	easyitem(&FileMgrMenuBar, szmHelpAbout,0,ShellAboutBox);

	/* Menu Bar with only "Help" menu in it */
	initbar(&ViewMenuBar);

	easymenu(&ViewMenuBar, szmDisplay, 0);
	gViewstart =  gNthmenu;
	easyitem(&ViewMenuBar,szmAscii,0,AsciiFileView);
	easyitem(&ViewMenuBar,szmHex,0,HexFileView);

	easymenu(&ViewMenuBar, szmView,0);
	easyitem(&ViewMenuBar, szmRepaint, 1, DoFullRefresh);
	easyitem(&ViewMenuBar,szmRestoreView,0,ExitFileView);

	easymenu(&ViewMenuBar, szmHelp, 0);
	easyitem(&ViewMenuBar, szmHelpIndex,0,IndexBox);
	easyitem(&ViewMenuBar, szmHelpKeys,0,KeyBox);
	easyitem(&ViewMenuBar, szmHelpBasics,0,BasicsBox);
	easyitem(&ViewMenuBar, szmHelpCommands,0,CommandsBox);
	easyitem(&ViewMenuBar, szmHelpProcedures,0,ProceduresBox);
	easyitem(&ViewMenuBar, szmHelpF1,0,UsingHelpBox);
	easyseparator(&ViewMenuBar);
	easyitem(&ViewMenuBar, szmHelpAbout,0,ShellAboutBox);

	/* ZZZZZZ Following two fn calls should not be needed before shipping!!
	 * as we should not have NULL functions then!!
	 */
	/* Disable all menu items which have NULL fn to perform tasks!! */
	easyenable(&MainMenuBar,NULL,FALSE);
	easyenable(&FileMgrMenuBar,NULL,FALSE);

	InitAccelerators();
}

/* Returns a BOOL as to whether the FileManager menu is put up! This is
 * especially important only when we are in TR_SHARE mode, where we have
 * both the File Manager and Program Manager displayed on the screen.
 */ 
BOOL IsFMMenuPutUp(void)
{
	BOOL ret ;

	if (!glob.InFileMgr)
		ret = FALSE ;
	else
	{
		if (glob.TreeMode == TR_SHARE)
		{
			ret = (WhoHasGlobalFocus() == DRIVELIST0) ||
					(WhoHasGlobalFocus() == TREE0) ||
					(WhoHasGlobalFocus() == FILE0) ;
		}
		else
			ret = TRUE ;
	}

	return ret ;

} /* IsFMMenuPutUp  */

extern ListBoxData TaskList;
/* BUG BUG you know, easyenable ignores its first parameter, so
 * we don't need all these routines separate...
 */

void TaskMenuEnable(void)
{
	BOOL allowexit;
	BOOL allowswitchmodechange;

	allowexit = !(gTaskListEnabled && (GetNumItems(&TaskList) > 0));
	allowswitchmodechange = (!gAlreadyTasking) && (allowexit);

	/* We now always keep the Exit menu item enabled. We check and
	 * warn the user that he has tasks running in case we shouldn't
	 * allow him to exit and he chooses the exit menu item.
	 */
	// easyenable(&FileMgrMenuBar,DoExit,allowexit);
	easyenable(&FileMgrMenuBar, DoExit, TRUE);
	easyenable(&FileMgrMenuBar,EnableSwitching,allowswitchmodechange);
}

/* This function, enables/disables the following file operations:
*** move, copy, delete, rename, change-attribute, view,
*** select-all, deselect-all.
*** create-directory is always on! 
*** delete and rename are on even when no files are selected if focus is
***     not on the root directory in tree list box.
***     open, associate also handled.
*/
/* ZZZZ Maybe delete should not be enabled if no files selected
   and directory with focus isn't empty -- What is the fastest way to tell
   this?? */

void EnableDisableFileOps(void)
{
	PTREE tree ;
	PENTRY dir ;
	BOOL prmvcpchas, del, ren, viop, sall, dall ;
	BOOL creatdir ;
	unsigned count ;
	BOOL fIsDirOperation ;
	// extern BOOL PDisable ; /* Says if print.com is not resident */

	tree = listinfo[glob.FocusBox].tree ;
	dir  = listinfo[glob.FocusBox].files ;
	
	fIsDirOperation = FPerformDirOperation() ;

	creatdir = FALSE ;

	if (fIsDirOperation)
	{
		prmvcpchas = viop = sall = dall = FALSE ;
		del = ren = (dir != NULL) ;
		if (    (glob.TreeMode == TR_SINGLE) ||
				(glob.TreeMode == TR_DOUBLE) ||
				(glob.TreeMode == TR_SHARE)
			)
			creatdir = !(tree->ContinueTree) ; // tree is built completely.
	}
	else
	{
		count = CountFilesToOperateOn() ;
		del = ren = (count > 0) ;
		viop = (count == 1) ;
		prmvcpchas = dall = (count > 0) ;
		sall = !AreAllMatchedSelected(dir, tree) ;
	}

	easyenable(&FileMgrMenuBar, LaunchBox, viop) ;

	// easyenable(&FileMgrMenuBar, DoPrintFiles, (!PDisable) && prmvcpchas) ;
	/* We now always have print menu item enabled if there are selected files.
	 * The Print function decides whether "print.com" has been loaded or not
	 * and then decides to print or puts up its message.
	 */
	easyenable(&FileMgrMenuBar, DoPrintFiles, prmvcpchas) ;


	easyenable(&FileMgrMenuBar, DoAssociateBox, prmvcpchas) ;

	easyenable(&FileMgrMenuBar, DoMoveFiles, prmvcpchas) ;
	easyenable(&FileMgrMenuBar, DoCopyFiles, prmvcpchas) ;
	easyenable(&FileMgrMenuBar, DoChangeAttributes, prmvcpchas) ;

	easyenable(&FileMgrMenuBar, DoDelFiles, del) ;
	easyenable(&FileMgrMenuBar, DoRenameFiles, ren) ;

	easyenable(&FileMgrMenuBar, DoViewFile, viop) ;

	easyenable(&FileMgrMenuBar, DoDeselectAll, dall) ;
	easyenable(&FileMgrMenuBar, DoSelectAll, sall) ;

	EnableDisableTreeMenu() ;
	if (glob.TreeMode != TR_SEARCH)
	{
		/* Following enables: Search For, Display-options,
		 *  Arrange-options.
		 */
		EnableDisableForSearchMode(TRUE, TRUE) ;

		/* Note that in case the menu was pulled down while tree was being
		 * built, we would have disable Flat Display mode, so enable it now.
		 * the code below will disable it if that is the case!
		 */
		easyenable(&FileMgrMenuBar, DoFlatDisplay, TRUE) ;

		easyenable(&FileMgrMenuBar, DoFileOptions, TRUE) ;

		/* At this point the prev. call would have enabled all the arrange-opts
		*  We need to disable the appropriate one based on which mode we are in.
		*/
		switch (glob.TreeMode)
		{
			case TR_SINGLE:
				easyenable(&FileMgrMenuBar, DoSingleTree, FALSE) ;
				easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
				break ;
			case TR_DOUBLE:
				easyenable(&FileMgrMenuBar, DoDoubleTree, FALSE) ;
				easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
				break ;
			case TR_SYSTEM:
				easyenable(&FileMgrMenuBar, DoFlatDisplay, FALSE) ;
				easyenable(&FileMgrMenuBar, ShowInfo, FALSE) ;
				break ;
#ifndef NOGROUPINFILE
			case TR_SHARE:
				easyenable(&FileMgrMenuBar, DoShareMode, FALSE) ;
				easyenable(&FileMgrMenuBar, ShowInfo, TRUE) ;
				break;
#endif

		} /* switch */
	}
	else
		EnableDisableForSearchMode(FALSE, TRUE) ;

	/* allow going back to PM */
	easyenable(&MainMenuBar,ExitFileMgr,TRUE);

	/* CreateDirectory is a special case -- Disable it if the listbox
	 * with focus is still being read in.
	 */
	easyenable(&FileMgrMenuBar, DoCreateDirectory, creatdir) ;

	TaskMenuEnable();
	easycheck(EnableSwitching,gSwitchingEnabled);

	/* The following item could have been disabled if one went to the plain
	 * PM view. So, re-enable it now!
	 */
	easyenable(&FileMgrMenuBar, SelectAcrossDirs, TRUE) ;
	easycheck(SelectAcrossDirs, glob.CrossDirSel) ;

	/* ZZZZZZZZ */
	/* WARNING!!! MAJOR HACK to get the keyboard accelerators
	 * to work right! If the last thing we did is a disable
	 * menu item rather than a enable menu item, CW seems
	 * to set a flag to disable KeyBoard accelerators from
	 * then on -- Don't know why!!!!!!
	 */
	easyenable(&FileMgrMenuBar, HelpBox, TRUE) ;

} /* EnableDisableFileOps */

extern TOKEN Get_Focus_Item(void);


void EnableDisablePMMenu(void)
{
	TOKEN curitem;
	BOOL fEnable, bDoor ;

	/* Enable/Disable all the "Options"/ "view" menu items based on
	 * whether we are in TR_SHARE mode or in basic program manager mode.
	 */
	fEnable = (glob.InFileMgr) && (glob.TreeMode == TR_SHARE) && 
																	(!IsTreeBeingBuilt()) ;
	easyenable(&MainMenuBar, DoFileOptions, fEnable) ;
	easyenable(&MainMenuBar, DisplayOptions, fEnable) ;
	easyenable(&MainMenuBar, SelectAcrossDirs, fEnable) ;
	easyenable(&MainMenuBar, PDoShareMode, !glob.InFileMgr) ;
	easyenable(&MainMenuBar, ExitFileMgr, glob.InFileMgr) ;

	/* In case the menu was crippled, i.e., the menu was pulled down when the
	 * tree was being built, "All Files" display is greyed out! Re-enable it
	 */
	easyenable(&MainMenuBar, PDoFlatDisplay, TRUE) ;

	/* When we are in PM menu, don't have ShowInfo ever activated! */
	easyenable(&MainMenuBar, ShowInfo, FALSE) ;

	if(gTaskListEnabled && TaskList.hasglobalfocus) // focus is in task list
	{
			easyenable(&MainMenuBar, AddProgram, FALSE);
			// never disabled easyenable(&MainMenuBar, StartAProgram, TRUE);
			easyenable(&MainMenuBar, CopyProgram, FALSE);
			// never disabled easyenable(&MainMenuBar, DeleteProgram, TRUE);
		easyenable(&MainMenuBar, ChangeProgram, FALSE);         
		easyenable(&MainMenuBar, ReorderGroup, FALSE);          
	}
	else
	{
		if((curitem=Get_Focus_Item()) > 0) {
			bDoor = gGroupLevel!=TK_PROGRAMSTARTER &&
					!Get_List_Focus(&ProgramList);

			easyenable(&MainMenuBar, CopyProgram, curitem!=TK_PROGRAMSTARTER &&
					Get_Symbol_Type(Token_To_Symbol(curitem))!=TK_GROUP);

			easyenable(&MainMenuBar, DeleteProgram, !bDoor);

			easyenable(&MainMenuBar, ChangeProgram, curitem!=TK_PROGRAMSTARTER);

			easyenable(&MainMenuBar, ReorderGroup, !bDoor);
		 
			easyenable(&MainMenuBar, AddProgram, TRUE);             
		}
	}
	/* If there are tasks switched out, grey exit menu! */

	TaskMenuEnable();
	easycheck(EnableSwitching,gSwitchingEnabled);
	easycheck(SelectAcrossDirs, glob.CrossDirSel) ;

/* ZZZZZZZZ */
	/* WARNING!!! MAJOR HACK to get the keyboard accelerators
	 * to work right! If the last thing we did is a disable
	 * menu item rather than a enable menu item, CW seems
	 * to set a flag to disable KeyBoard accelerators from
	 * then on -- Don't know why!!!!!!
	 */

	easyenable(&MainMenuBar, HelpBox, TRUE) ;

} /* EnableDisablePMMenu */

/* Enable/Disable Menu items in the View File menu */
void EnableDisableViewMenu(void)
{
	easyenable(&ViewMenuBar, AsciiFileView, !(ascii)) ;
	easyenable(&ViewMenuBar, HexFileView, ascii) ;
} /* EnableDisableViewMenu */

/* This function enables/disables the menu operations in the file-manager
   when entering/leaving the search mode.
   ('doenable1', 'doenable2') == TRUE implies we are leaving the search-mode
   and want to re-enable the menus. If both are FALSE, it means we are
   entering search-mode and want to disable them all.
   Using just 'doenable1' == FALSE, 'doenable2' = TRUE, allows separate
   enabling/disabling "Arrange Menu" and the other two ("File", "Options").
   This kind of generic feature has been used to reduce code size!!
*/
  
void EnableDisableForSearchMode(BOOL doenable1, BOOL doenable2)
{
	/* Re-Think of design indicates that Search should work in search */
	/* FileLocateBox (search) can now handle search from within search */
	easyenable(&FileMgrMenuBar, FileLocateBox, TRUE) ;

	/* "Options" menu */
	easyenable(&FileMgrMenuBar, DisplayOptions, doenable1) ;

	/* "Arrange" menu */
	easyenable(&FileMgrMenuBar, DoSingleTree, doenable2) ;
	easyenable(&FileMgrMenuBar, DoDoubleTree, doenable2) ;
	easyenable(&FileMgrMenuBar, DoFlatDisplay, doenable2) ;
#ifndef NOGROUPINFILE
	easyenable(&FileMgrMenuBar, DoShareMode, doenable2) ;
#endif

} /* EnableDisableForSearch */


/*
*  This function is called when File System is still being read in --
*  Disable all menus except run...,exit, view menu and help menu
*/
void CrippleFileMenuBar(void)
{
	int i;

	/* ZZZZZZ We can be smart about these disabling operations by looking
	 * at what menu we have put up -- FM-Menu or PM-Menu. This is based
	 * on who has focus when we are in TR_SHARE mode.
	 */

/* ZZZZ If file manager menubar is changed, one may have to change the foll.
 * constants.
 */
#define BEGIN_DISABLE_MENUID 32 /* menu-id of "Open" menu item */
#define END_DISABLE_MENUID 70           /* menu-id of first help menu item */
	/* I am making use of the fact that the menu item id's are of the form j,
	 * j+1, j+2, etc. The fol1lowing makes code size pretty small -- only
	 * 1 loop as opposed to calling the 'easyeanble' for each individual item.
	 * We need to disable almost all file manager operations when the tree
	 * is being built!
	 */
	for(i = BEGIN_DISABLE_MENUID; i< END_DISABLE_MENUID ; i++)
	{
		 EnableMenuItem(i, FALSE);
		 /* Mark this menu item as disabled! -- This is used by us to
		  * to prevent keyboard accelerators from performing operations when
		  * the corresponding menu item is disabled
		  */
		 emenustate[i] |= MM_DISABLED;
	}

	/*      We always want to be able to use "Run", "Refresh" from the file-mgr menu! */
	easyenable(&FileMgrMenuBar, Run, TRUE) ;

	/* Scott wanted the following change, so I have implemented this!               */
	/* The following chain would enable user to read 2 trees at a time, etc */
	if (glob.TreeMode != TR_SINGLE)
		easyenable(&FileMgrMenuBar, DoSingleTree, TRUE) ;

	if (glob.TreeMode != TR_DOUBLE)
		easyenable(&FileMgrMenuBar, DoDoubleTree, TRUE) ;

	easyenable(&FileMgrMenuBar, ExitFileMgr, TRUE) ;

#ifndef NOGROUPINFILE
	if (glob.TreeMode != TR_SHARE)
		easyenable(&FileMgrMenuBar, DoShareMode, TRUE) ;
#endif

	/* ZZZZ */
	/* When the tree is being built -- this is the time when this function
	 * is ever invoked, we don't want to allow the user to switch to 
	 * System Tree modfe, as there is a potential for getting into compact
	 * mode and it is a big pain to get out of System Tree mode!
	 */

	/* Disable exit if there are tasks swapped out ! */
	TaskMenuEnable();

	/* enable some of the Harmless FM menu items */
	easyenable(&FileMgrMenuBar, SelectAcrossDirs, TRUE) ;
	easyenable(&FileMgrMenuBar, DoFileOptions, TRUE) ;
	easyenable(&FileMgrMenuBar, ScreenBox, TRUE) ;
	easyenable(&FileMgrMenuBar, ColorBox, TRUE) ;
	easyenable(&FileMgrMenuBar, DoFullRefresh, TRUE) ;
	easyenable(&FileMgrMenuBar, DoDiskReread, TRUE) ;

	/* Don't let user to switch to all tree mode when tree being built! */
	easyenable(&MainMenuBar, PDoFlatDisplay, FALSE) ;

	/* We must already be in SHARE mode, if this menu item greying is seen
	 * by the user.
	 */
	easyenable(&MainMenuBar, PDoShareMode, FALSE) ;
	easyenable(&MainMenuBar, DisplayOptions, FALSE) ;
	easyenable(&MainMenuBar, ShowInfo, FALSE) ;

	easycheck(EnableSwitching,gSwitchingEnabled);
	easycheck(SelectAcrossDirs, glob.CrossDirSel) ;

} /* CrippleFileMenuBar */



/* This routine enables/disables the four menu items under the 'Tree' menu
 * that deals with collapsed directories
 */
void EnableDisableTreeMenu(void)
{
	PTREE tree ;
	BOOL fDoIt ; /* whether to find out about enabling/disabling */
	BOOL col, exp1, expall ;
	unsigned char exp_ch ;

	tree = listinfo[glob.FocusBox].tree ;

	/* In Search mode/System mode, or if tree with focus is still being read in,
	 * we want disable ALL of the following!
	 */
	fDoIt = (glob.TreeMode != TR_SEARCH) && (glob.TreeMode != TR_SYSTEM) &&
			(!(tree->ContinueTree)) ;
		
	if (fDoIt)
	{
		exp_ch = GetCollapseChar(tree, listinfo[glob.FocusBox].files) ;

		col = (exp_ch == COLLAPSE_CHAR) ;
		exp1 = (exp_ch == EXPANSION_CHAR) ;

		/* actually '<' is a strong check -- '!=' should be good enuf!! */
		expall = (tree->VisibleDirCount < tree->DirCount) ;
	}
	else
		exp1 = expall = col = FALSE ;
	
	easyenable(&FileMgrMenuBar, DoExpand1Level, exp1) ;

	/* ZZZZZZZ Figuring out foll. exactly will make disabling menu slow, 
	 * so not done! - Not very important either.
	 */
	easyenable(&FileMgrMenuBar, DoExpandBranch, 
							(exp_ch != NOZOOM_CHAR) && expall && fDoIt);

	easyenable(&FileMgrMenuBar, DoExpandAll, expall) ;
	easyenable(&FileMgrMenuBar, DoCollapse, col) ;
} /*EnableDisableTreeMenu */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\showinfo.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <ctype.h>
#include "common.h"
#include "menus.h"
#include "filemgr.h"
#include "prot.h"
#include "text.h"
#include "showinfo.hs"
#include "showinfo.sdm"

DWORD FAR PASCAL PfnShowInfoInfo(PWND pwnd, WORD message, WORD wParam,
		DWORD lParam)
{
    PENTRY node ;

    UnReferenced(lParam) ;
    UnReferenced(wParam) ;

    switch(message) {
    case WM_PAINT:
/* Compiler should hopefully optimize CSEs below */
        node = (glob.TreeMode==TR_SEARCH && gfSearchDisk) ?
                GetNthFlatMatchedFile( listinfo[glob.FocusBox].tree,
                    Get_List_Focus(&FileList[glob.FocusBox]) ) :
                GetNthMatchedFile( listinfo[glob.FocusBox].files,
                    Get_List_Focus(&FileList[glob.FocusBox]), 
                    listinfo[glob.FocusBox].tree) ;
        DispFlatLeft(node, listinfo[glob.FocusBox].tree, pwnd,0,0,isaDialogBox);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

VOID FAR ShowInfo(VOID)
{
	HCABshowinfo	  h;
	PTREE tree ;
	BOOL fFakingDiskInfoKnown = FALSE ;

	h = HcabAlloc(cabiCABshowinfo);

	if (!h)
	{
		OutOfMemory() ;
		return ;
	}

	tree = listinfo[glob.FocusBox].tree ;

	if (!tree->fdiskinfoknown)
	{
		if (!GetDiskInfo(tree, tree->VolLabel, &tree->SizeTotal,
				       										&tree->SizeAvail))
		{
			fFakingDiskInfoKnown = TRUE ;
		}

		/* Set the following field to TRUE anyway, otherwise when the
		 * dialog procedure causes an invocation of DispFlatLeft() thru
		 * fn pfnShowInfoInfo, the disk will be touched again when it
		 * does not have to! We will set the field back to FALSE in
		 * case GetDiskInfo() failed, i.e., variable fFakingDiskInfoKnown
		 * being true ;
		 */
		tree->fdiskinfoknown = TRUE ;
	}
	
	InitCab(h, cabiCABshowinfo) ;

	SzToCab(h, szClose, Iag(CABshowinfo, pszshowinfoCB));
	SzToCab(h, szHelpButton, Iag(CABshowinfo, pszshowinfoHB));

	MyTmcDoDlg(&dlgshowinfo,  h);

	if (fFakingDiskInfoKnown)
		tree->fdiskinfoknown = FALSE ;

	FreeCab(h);

}

BOOL FAR PASCAL FDlgshowinfo(WORD dlm, TMC tmc, WORD wNew,
		WORD wOld, WORD wParam)
{
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch (dlm) {
	case dlmInit:
		SetUpDialog(tmcCancel, szShowInformationCaption);

		SetWindowProc(PwndOfTmc(tmcshowinfoinfo), PfnShowInfoInfo);
		SetUpButtonForGraphics(tmcCancel);
		SetUpButtonForGraphics(tmcshowinfohelp);
		break;

	case dlmClick:
		if (tmc == tmcCancel)
			break ;

		if(tmc == tmcshowinfohelp)
			Help(hemDialog, hidSHOWINFO, NULL, 0);

		SetFocusTmc(tmcCancel) ;
		break ;

	}
	return(TRUE);
} /* FDlgshowinfo */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\screen.c ===
/* Revision history since 5.0 Golden:
 *
 *  M011 SHK 07/17/91 New mouse compatibilty message added. This
 *							 now displays the mouse version number also.
 *  M014 SHK 10/03/91 Mouse Version number in the "old-mouse"
 *							 warning	message is printed in hex now!
 *
 */


;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <groups.h>
#include <icons.h>
#include <text.h>
#include <assert.h>

extern BOOL gInReorder, gInCopy;
extern BOOL gTaskListEnabled;
extern BOOL gSwitchingEnabled;
extern WORD gCnx;

extern MENUINFO ViewMenuBar ;

long far pascal WindProc(PWND, WORD, WORD, DWORD);
extern WND ViewWind;                            // window used by view file
extern MENUINFO MainMenuBar;
extern MENUINFO FileMgrMenuBar;
extern void EnableDisablePMMenu(void) ;
extern void EnableDisableViewMenu(void) ;
extern VOID RefreshStartPrograms(VOID);
extern void ClearHelpContext(void) ;

extern WORD gscreenmode; /* mode the screen is in now */

extern BOOL gfDisplayDelayedHelp ;

#define INVALID_TMC 0

#if 0 
	not needed
/* In edit boxes the one which initially has focus so that we can
 * draw it in hilited mode.
 */
TMC gInitialHiliteTMC = INVALID_TMC ;
#endif 

/* The sizes 80, 23 don't really matter -- See InitWindows() which initializes
   the size of MainWind. The following macro call is only to get a window */
WND MainWind = wndGeneric(1,WS_TILED /*| WS_BORDER */,TRUE,0,0,80,23,
			 WindProc,&ViewWind, NULL, NULL)
   endWndGeneric;

#define CISA  (dmNormal | 20)
#define MAXUSERPASSWORD 20

BOOL gMouseDown;
BYTE gMouseX;   /* X value of last mouse-down */
BYTE gMouseY;   /* Y value of last mouse-down */
BYTE gMouseDownX, gMouseDownY;
WORD gAutoMouseRatio;
WORD gAutoMouse=0;
BOOL gfRepaintonidle=FALSE;
TMC gPrevTmc ;
TMC gNextTmc ;

extern void AddProgManAccelerators(void);
extern void AddFileManAccelerators(void);

extern VOID strfcat(char far *dest,char far *src);
extern char NullString[];
extern char szViewFileCaption[] ;

char *szCurDialogCaption = NullString ;
extern BOOL fDrawItem;
extern BOOL fRedrawItem;
extern void UpLevel(void);

TMC gCurRadioGroup;

#define DONTTURNONMOUSE -99
int gNestCount = DONTTURNONMOUSE; /* This has to be a signed value! */

extern TMC WarnMouseIsOld(char *pszMouseVersion); // M011
extern BOOL ErrorCrit;
extern TOKEN Get_Identifier_Token(char far *identifier);

#define MINMAJORMOUSEVER 6
#define MINMINORMOUSEVER 21
/* logictech number is returned in dx:ax, so version 5.01 is 0005:0001 */
#define MINLOGITECHMAGICVERSION 0x050001

extern WORD MouseVersion(void);
extern DWORD DetectLogitech(void);

VOID FirstMouseInit(void)
{
	WORD thisversion;
	TOKEN lastresponse;
	char far *lastresstr;
	char thisvertemp[20];

	if(fMousePresent)
	{
		thisversion = MouseVersion();
		
	   if( (HIBYTE(thisversion) < MINMAJORMOUSEVER) ||
		  ((HIBYTE(thisversion) == MINMAJORMOUSEVER) && (LOBYTE(thisversion) < MINMINORMOUSEVER)))
	   {

		   lastresponse = Get_KeyWord_Assignment(TK_SAVESTATE,TK_MOUSEINFO);
			if(lastresponse > 0)
			{
				lastresstr = Get_Token_Identifier(lastresponse);

				if( ((lastresstr[0]-'0') == (HIBYTE(thisversion))) &&
				  ( (lastresstr[2]-'0') == (LOBYTE(thisversion)/10)) &&
				  ( (lastresstr[3]-'0') == (LOBYTE(thisversion)%10)) )
				  {
						/* versions match */
					   if(lastresstr[5]=='i')
						{
							gNestCount = 0;
						}
						return;
						
				  }
			}



			thisvertemp[0] = HIBYTE(thisversion)+'0';
			thisvertemp[1] = '.';

			/* M014 -- MS mice print out the version number in base 16.
			 * We do the same here, so that people see the same value!
			 */
			thisvertemp[2] = LOBYTE(thisversion)/16+'0'; // M014
			thisvertemp[3] = LOBYTE(thisversion)%16+'0'; // M014


			thisvertemp[4] = 0;	// M011


			ErrorCrit = 34;  // BUG BUG set to keep tasking out until done here

			/* ok, looks like a baddy to us, but logitech works
			 * on 5.01+, so detect it. Do this as rarely as possible
			 * since the code is really really dirty
			 */

			// M011 Changed the structure to make it cleaner and without a GOTO!
			if (	(DetectLogitech() >= MINLOGITECHMAGICVERSION) ||
				 	(WarnMouseIsOld(thisvertemp) != tmcCancel) )
			{
				gNestCount = 0;
				thisvertemp[4] = ',';	// M011
				thisvertemp[5] = 0;		// M011
				strfcat(thisvertemp,Get_Token_Identifier(TK_IGNORE));

			}
		   else
			{
				thisvertemp[4] = ',';	// M011
				thisvertemp[5] = 0;		// M011
			   strfcat(thisvertemp,Get_Token_Identifier(TK_DISABLED));
			}
			Set_KeyWord_Assignment(TK_SAVESTATE,TK_MOUSEINFO,Get_Identifier_Token(thisvertemp));
			ErrorCrit = 0xFF;       
	  }
	  else
	  {
		  gNestCount = 0;
		  if(Get_KeyWord_Assignment(TK_SAVESTATE,TK_MOUSEINFO) > 0)
			Set_KeyWord_Assignment(TK_SAVESTATE,TK_MOUSEINFO,TK_NOTHING);
	  }
	}
}

VOID FInitMouseNest(void)
{
	 if(gNestCount == DONTTURNONMOUSE)
		return;
    gNestCount = 0;
    FEnableMouse(TRUE);
} /* FInitMouseNest */


/*
 * This call enables and disables the mouse.
 * It nests calls so the mouse will not flicker too much
 */
VOID FEnableMouseNest(BOOL onoroff)
{
	if(gNestCount == DONTTURNONMOUSE)
		return;  // finitmousenext has not been called yet.
				   // we use this "feature" at start-up to delay mouse turn on
	if (onoroff)
	{
		--gNestCount;
		if(gNestCount <= 0)
		{
			FInitMouseNest() ;
		}
	}
	else
	{
		++gNestCount;
		if(gNestCount == 1)
		{
			FEnableMouse(FALSE);
		}
	}
} /* FEnableMouseNest */

#ifndef NORESIZE
void EasyDrawBox(PWND pwd, BYTE top, BYTE left, BYTE bottom, BYTE right,ISA isa);
BOOL gDraggingrect;
BYTE gDragX;
BYTE gDragY;
BYTE gLinebuf[500];
VOID DoBeginResize(BYTE x, BYTE y)
{
    RRC trect;

    gDraggingrect = TRUE;
    gDragX = x;
    gDragY = y;

	trect.ryTop = y ;
	trect.ryBottom = y+1 ;
    trect.rxLeft = 0;
    trect.rxRight = axMac;

	SaveRrc(&MainWind,&trect,gLinebuf);
    FillRrc(&MainWind,&trect,' ',dmAttrOnly|isaBlackOnWhite);
}
VOID DoResize(BYTE x, BYTE y)
{
    RRC trect;

    trect.ryTop = gDragY;
    trect.ryBottom = gDragY+1;
    trect.rxLeft = 0;
    trect.rxRight = axMac;

	RestoreRrc(&MainWind, &trect, gLinebuf);

    gDragX = x;
    gDragY = y;
    trect.ryTop = gDragY;
    trect.ryBottom = gDragY+1;
    trect.rxLeft = 0;
    trect.rxRight = axMac;

	SaveRrc(&MainWind,&trect,gLinebuf);
    FillRrc(&MainWind,&trect,' ',dmAttrOnly|isaBlackOnWhite);

}
VOID DoEndResize(BYTE x, BYTE y)
{
    RRC trect;

    trect.ryTop = gDragY;
    trect.ryBottom = gDragY+1;
    trect.rxLeft = 0;
    trect.rxRight = axMac;

	RestoreRrc(&MainWind,&trect,gLinebuf);
    gDraggingrect = FALSE;
}
#endif



#if 0
//VOID MyAltMenu(void);
//BOOL NEAR HiliteMenuMnem(BOOL);
//#pragma alloc_text(CW_USER,MyAltMenu)
BOOL gDoAltMenu = FALSE;
VOID MyAltMenu(void)
{
      gDoAltMenu = TRUE;
}
#endif

/* Assigns the correct value to the focus box "glob.FocusBox" -- This is
 * the focus box (0/1) that will be used to figure out the default
 * directory to copy or do a SelectAll, etc.
 */
void SetGlobalFocusBox(WORD GlobalFocus)
{
	if (glob.TreeMode == TR_DOUBLE)
	{
		switch (GlobalFocus)
		{
			case FILE1:
			case TREE1:
			case DRIVELIST1:
				glob.FocusBox = 1 ;
				break ;
			default:
				glob.FocusBox = 0 ;
		} /* switch */
	}
	else
		glob.FocusBox = 0 ;
} /* SetGlobalFocusBox */


BYTE GetFocusDrive(WORD list) ;
extern struct ListBoxData ProgramList;
extern char *gpszNonSwap ;

/* Fn to mark the Global Focus as being with the one passed in. Currently
 * called only from InitFileMgr()
 */
void MarkGlobalFocus(WORD focus)
{
	glob.FocusId = focus ;
} /* MarkGlobalFocus */

#ifndef NOSWITCHER
extern struct ListBoxData TaskList;
#endif
VOID InitGlobalFocus(WORD focusstart)
{
	SetGlobalFocusBox(glob.FocusId = focusstart) ;

	GlobalFocusBox(&TreeList[0],FALSE);
	GlobalFocusBox(&FileList[0],FALSE);
	if (glob.TreeMode == TR_DOUBLE)
	{
	   GlobalFocusBox(&TreeList[1],FALSE);
	   GlobalFocusBox(&FileList[1],FALSE);
	}
#ifndef NOGROUPINFILE
	if (glob.TreeMode == TR_SHARE)
	   GlobalFocusBox(&ProgramList,FALSE);
#endif
#ifndef NOSWITCHER
	if(gTaskListEnabled)
	{
		if (glob.TreeMode == TR_SHARE)
		GlobalFocusBox(&TaskList,FALSE);
	}
#endif
	HighlightDrive(0,GetFocusDrive(0),isaDriveicon);

	if((glob.TreeMode == TR_DOUBLE))
	   HighlightDrive(1,GetFocusDrive(1),isaDriveicon);

	switch(glob.FocusId)
    {
	   case MENUFOCUS:
#if 0
		MyAltMenu();
		//OpenMenu(80+7);
#endif
		break;
       case FILE0:
	  GlobalFocusBox(&FileList[0],TRUE);
	  break;
       case FILE1:
	  GlobalFocusBox(&FileList[1],TRUE);
	  break;
       case TREE0:
	  GlobalFocusBox(&TreeList[0],TRUE);
	  break;
       case TREE1:
#ifndef NOSWITCHER
       //case TASKBOX: same as TREE1!
		if(gTaskListEnabled && (glob.TreeMode == TR_SHARE))
		{
		GlobalFocusBox(&TaskList,TRUE);
		}
	  else
#endif

	  GlobalFocusBox(&TreeList[1],TRUE);
	/*  OpenMenu(80+7);*/
	  break;

	  break;
       case DRIVELIST0:
	  HighlightDrive(0,GetFocusDrive(0),isaHilite);
	  break;
       case DRIVELIST1:
#ifndef NOGROUPINFILE
       //case GROUPBOX: same as DRIVELIST!
	  if(glob.TreeMode == TR_SHARE)
	  {
	     GlobalFocusBox(&ProgramList,TRUE);
	  }
	  else
#endif
	  HighlightDrive(1,GetFocusDrive(1),isaHilite);
	  break;
    };
#ifndef NOGROUPINFILE
	  if (glob.TreeMode == TR_SHARE)
	  {
#ifndef NOSWITCHER
	       if((glob.FocusId == GROUPBOX)||(gTaskListEnabled && (glob.FocusId == TASKBOX)))
#else
	       if(glob.FocusId == GROUPBOX)
#endif
	       {
				setmenubar(&MainMenuBar,&MainWind);
				AddProgManAccelerators();
	       }
	       else
	       {
				setmenubar(&FileMgrMenuBar,&MainWind);
				AddFileManAccelerators();
	       }
	  }
#endif
			MessageBar(gpszNonSwap, isaMenu,TRUE);
}
VOID CalcNextFocus(int numfocusitems)
{
	     glob.FocusId = (glob.FocusId+1)%numfocusitems;
	     /* WARNING!!! assuming MENUFOCUS has #define of 0 */
	     if (glob.FocusId == MENUFOCUS)
		    glob.FocusId++ ;
}

VOID NextGlobalFocus()
{
      WORD numfocusitems;

      if(glob.InFileMgr) {
      switch(glob.TreeMode)
      {
		case TR_SYSTEM:
			switch (WhoHasGlobalFocus())
			{
				case DRIVELIST0:
					if (GetNumItems(&FileList[0])!=0)
					   InitGlobalFocus(FILE0);
					else
					   Shell_Beep();
					break;
				case FILE0:
				default:
					InitGlobalFocus(DRIVELIST0);
					break;
#if 0
				case MENUFOCUS:
					InitGlobalFocus(DRIVELIST0);
					break;
#endif
			}
		break;
		case TR_SEARCH:
			Shell_Beep() ;
			break ;
	    case TR_DOUBLE:
	    case TR_SINGLE:
	    default:
#ifndef NOGROUPINFILE
	    if(glob.TreeMode == TR_SHARE)
		 {
#ifndef NOSWITCHER
			if(gTaskListEnabled)
				numfocusitems = 6;
			else
#endif
				numfocusitems = 5;
		 }
	    else
#endif
		 numfocusitems = 2*(glob.MaxTree+1)+glob.MaxTree+2;

nextfocus:  /* WARNING! potential infinite loop! */
	    CalcNextFocus(numfocusitems);
	    switch(glob.FocusId) /* the new focus */
	    {
		case FILE0:
		{
// Beep() ; Beep() ; Beep() ;
		    if(GetNumItems(&FileList[0])==0)
			 goto nextfocus;
		}
		break;
		case FILE1:
		{
		    if(GetNumItems(&FileList[1])==0)
			 goto nextfocus;
		}
		break;
		case TREE0:
		{
		    if(GetNumItems(&TreeList[0])==0)
			 goto nextfocus;
		}
		break;
		case TREE1:
		{
// Beep() ; Beep() ;

#ifndef NOSWITCHER
		   if(gTaskListEnabled && (glob.TreeMode == TR_SHARE))
		   {
		    if(GetNumItems(&TaskList)==0)
		       goto nextfocus;
		   }
		   else
#endif
		    if(GetNumItems(&TreeList[1])==0)
			 goto nextfocus;
		}
		break;

	    }
	    InitGlobalFocus(glob.FocusId);
		 break;
	}
    } else {
	if(TaskList.hasglobalfocus ||
		(gTaskListEnabled && GetNumItems(&TaskList))) {
	    GlobalFocusBox(&TaskList,!TaskList.hasglobalfocus);
	    GlobalFocusBox(&ProgramList,!ProgramList.hasglobalfocus);
	}
    }
}

VOID CalcPrevFocus(int numfocusitems)
{
	     glob.FocusId = (glob.FocusId+numfocusitems-1)%numfocusitems;
	     if (glob.FocusId == MENUFOCUS)
	     {
#ifndef NOGROUPINFILE
		    if(glob.TreeMode == TR_SHARE)
		    {
#ifndef NOSWITCHER
				 if(gTaskListEnabled)
			       glob.FocusId = TASKBOX;
			    else
#endif  
		       glob.FocusId = GROUPBOX;
		    }
		    else
#endif
		    glob.FocusId = (glob.TreeMode == TR_DOUBLE) ? FILE1 : FILE0;
	     }
}

VOID PrevGlobalFocus()
{
      WORD numfocusitems;

      if(glob.InFileMgr) {
      switch(glob.TreeMode)
      {
		case TR_SYSTEM:
			switch (WhoHasGlobalFocus())
			{
				case DRIVELIST0:
					if (GetNumItems(&FileList[0])!=0)
					    InitGlobalFocus(FILE0);
					else
					    Shell_Beep();
					break;
				case FILE0:
				default:
					InitGlobalFocus(DRIVELIST0);
					break;
#if 0
				case MENUFOCUS:
					InitGlobalFocus(FILE0);
					break;
#endif
			}

		break;

		case TR_SEARCH:
			Shell_Beep() ;
			break ;

	    case TR_DOUBLE:
	    case TR_SINGLE:
		default:
#ifndef NOGROUPINFILE
	    if(glob.TreeMode == TR_SHARE)
#ifndef NOSWITCHER
		 if(gTaskListEnabled)
			 numfocusitems = 6;
		 else
#endif
		 numfocusitems = 5;
#endif
	    else
		 numfocusitems = 2*(glob.MaxTree+1)+glob.MaxTree+2;

prevfocus:
		 CalcPrevFocus(numfocusitems);
		 switch(glob.FocusId) /* the new focus */
		 {
			case FILE0:
			{
			    if(GetNumItems(&FileList[0])==0)
				 goto prevfocus;
			}
			break;
			case FILE1:
			{
			    if(GetNumItems(&FileList[1])==0)
				 goto prevfocus;
			}
			break;
			case TREE0:
			{
			    if(GetNumItems(&TreeList[0])==0)
				 goto prevfocus;
			}
			break;
			case TREE1:
			{
#ifndef NOSWITCHER
		   if(gTaskListEnabled && (glob.TreeMode == TR_SHARE))
		   {
		    if(GetNumItems(&TaskList)==0)
		       goto prevfocus;
		   }
		   else
#endif
			    if(GetNumItems(&TreeList[1])==0)
				 goto prevfocus;
			}
			break;
		 }
		 /* If we are moving focus away from the drive lists re-draw that list! */

		 InitGlobalFocus(glob.FocusId);
		 break;
      }
    } else
	NextGlobalFocus(); /* There are only two items, so next is last */
}

/*
 * handle keys in the filemanager
 * key is the key hit; state is the shift state
 */
VOID GroupManagerKey(WORD wParam,DWORD LParam);
VOID FileManagerKey(WORD key,WORD state)
{

	BYTE uppercasekey, driveind     ;
	PTREE seltree ;

	/* Control+letter selects appropriate drive */
	/* WARNING! The ctrl+letter check needs to be done before the VK_TAB
	 * stuff because "ctrl+I" is the TAB character and so we don't want the
	 * focus to tab around!
	 */
	if ( (state & KK_CONTROL) &&
		 ((uppercasekey = (BYTE) (key + 'A' - 1)) >= 'A' ) &&
		 (uppercasekey <= 'Z') )
	{
		seltree = FindTree(&uppercasekey, &driveind) ;
		if (seltree)
		{
			SelectDrive(glob.FocusBox, driveind) ;

		/* Move the focus to the drive icons! */
		InitGlobalFocus((glob.FocusBox == 0) ? DRIVELIST0 : DRIVELIST1) ;
		}
	}
	else
	if ((key == VK_TAB) || (key == '\t'))
	{
		/* when we are in the TR_SHARE mode aned the focus is in the prog
		 * man part of the screen, the menu is the program manager menu
		 * and TAB, Shift+TAB is not a keyboard accelerator there. These
		 * keys will come thru to this fn -- We handle them here.
		 */
		if (state & KK_SHIFT)
			PrevGlobalFocus();
		else
			NextGlobalFocus();
    }
	else
	{

       switch (WhoHasGlobalFocus())
       {
	    case TREE0:
		  {      
		    glob.FocusBox = 0;
		    ListKey(&TreeList[glob.FocusBox],key,state);
		  }
		    break;
	    case TREE1:

#ifndef NOGROUPINFILE
	    //case GROUPBOX:
		   if(glob.TreeMode == TR_SHARE)
		      GroupManagerKey(key,(DWORD)state);
		   else
#endif

		    {
		       glob.FocusBox = 1;
		       ListKey(&TreeList[glob.FocusBox],key,state);
		    }
		    break;
	    case FILE0:
		    glob.FocusBox = 0;
		    ListKey(&FileList[glob.FocusBox],key,state);
		    break;
	    case FILE1:
		    glob.FocusBox = 1;
		    ListKey(&FileList[glob.FocusBox],key,state);
		    break;
	    case DRIVELIST0:
			DriveListKey(0, key, state);
		    break;
	    case DRIVELIST1:
#ifndef NOGROUPINFILE
	    //case GROUPBOX:
		   if(glob.TreeMode == TR_SHARE)
		      GroupManagerKey(key,(DWORD)state);
		   else
#endif
			DriveListKey(1, key, state);
	  break;

       }
    }

}
#if 0
VOID MouseIdle(VOID)
{
	if (gMouseDown)
	{
		/* this should be a timer call!! */
		if (gAutoMouse == 0)
		{
			WindProc(&MainWind, WM_MOUSEIDLE, 1,((DWORD) gMouseY << 24) | ((DWORD) gMouseX << 16));
		}
	}
}
#endif
/*
 * UPDATE
 *      The latest CW build has pfnFilter be a far procedure, so this
 *  is no longer necessary. . .
 * WARNING WARNING!!!
 * THIS IS AN EVIL DEATH NIGHTMARE HACK FROM HELL!
 *
 * The following code exists soley to draw black borders around menus
 * when in graphics mode.
 *
 * The problem is that we need to draw the border after CW draws the
 * menu so it won't get erased (or saved by savegraphic arc)
 *
 * This is not so easy, as CW doesn't want to give us control at this
 * time if the mouse button is down (ie we don't get any messages)
 *
 * So here is what we do, in our infinite slimyness:
 *      When we get the WM_INITMENUPOPUP message indicating that a menu
 * is about to pop up, we save off info about which menu it is, and
 * save and modify one of CW's internal variables. This variable is
 * a function pointer to a menu-filter routine; what we want to do
 * is "hook" it so that we get called whenever it gets called so we
 * can get control to draw the menu border. Two things should be noted
 * here: one is that at the time we get the WM_INITMENUPOPUP message
 * we are actually inside the routine we want to hook; and the other is
 * that the routine is a near function inside the CW_USER segment.
 * It's ok that we are inside the routine since we are just changing
 * a function pointer which will be called again. To put our hook routine
 * inside the CW_USER segment (so it can be near), we use the alloc_text
 * pragma.
 * All out hook routine (MyMenuFilterProc) does is perhaps outline the
 * menu
*/

#define INVALIDPTR ((VOID *) -1)

WORD gwParam ;
PWND gMwnd = INVALIDPTR ;

//extern BOOL (NEAR *pfnFilter)(PMSG pmsg);
extern BOOL (FAR *pfnFilter)(PMSG pmsg);

//BOOL (NEAR *RealFilterProc)(PMSG pmsg) = NULL;
BOOL (FAR *RealFilterProc)(PMSG pmsg) = NULL;
//BOOL NEAR MyMenuFilterProc(PMSG pmsg);
BOOL FAR MyMenuFilterProc(PMSG pmsg);

extern BOOL IsFMMenuPutUp(void) ;

#pragma alloc_text(CW_USER,MyMenuFilterProc)
//BOOL NEAR MyMenuFilterProc(PMSG pmsg)
BOOL FAR MyMenuFilterProc(PMSG pmsg)
{
   if(gisgraph)
    {
	   if(gMwnd != INVALIDPTR)
       {
		  gMwnd = INVALIDPTR;
	      FrameMenu(gMwnd,gwParam);
       }
    }

    return(RealFilterProc(pmsg));
}

/* returns true if a menu is popped down; false otherwise
 * WARNING this is may only be valid for mainwind
 */
BOOL IsMenuDown(void)
{
	return(((pfnFilter == MyMenuFilterProc)) | (gCnx == cnxMenu));
}

extern VOID MonitorManipulation(BYTE,BYTE);
VOID GroupManagerMouse(WORD mx,WORD my,WORD message,BYTE state);
/*
 *      Handle messages sent to main window
 */
long far pascal WindProc(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	BYTE mx;
	BYTE my;
	BOOL ret;
	static isacceleration=FALSE;

	switch(message) {
		case WM_PAINT:
			break;
		case WM_MENUINACTIVE:
			/* Had the user hit F1 when the menu was active? If so, the menu
			 * has been closed now. Display help to the user at this time.
			 */
			if (gfDisplayDelayedHelp)
			{
				HelpBox() ;
				ClearHelpContext() ;
				gfDisplayDelayedHelp = FALSE ;
			}
			// Fall through!

		case WM_DIALOGINACTIVE:
			if(LParam) // if CWs redraw failed
			{
				gfRepaintonidle = TRUE;
			}
		break;
		case WM_CHAR:
			if (glob.InFileMgr)
			{
				if ( (glob.TreeMode == TR_SEARCH) && 
						( (wParam == ESCAPE) || (wParam == VK_ESCAPE) ) )
				{
					HandleSearchQuit() ;

					/* The following will make sure that the file with
					 * focus in each listbox gets selected by default.
					 */
					listinfo[0].UpdateFiles = TRUE ;

					if ( (glob.TreeMode == TR_DOUBLE) &&
										(listinfo[0].tree == listinfo[1].tree) )
						listinfo[1].UpdateFiles = TRUE ;

					DoFileMgr() ;
				}
				else
				FileManagerKey(wParam,HIWORD(LParam));
			}
			else
			{
			   GroupManagerKey(wParam,LParam);
			}
			break;

		case WM_LBUTTONDBLCLK:
		case WM_LBUTTONDOWN:
			gMouseDown = TRUE;
			gMouseDownX=LOBYTE(HIWORD((LParam)));
			gMouseDownY=HIBYTE(HIWORD((LParam)));
		case WM_MOUSEMOVE:
			gMouseX=LOBYTE(HIWORD((LParam)));
			gMouseY=HIBYTE(HIWORD((LParam)));
		case WM_MOUSEIDLE:
		case WM_LBUTTONUP:
			if (message == WM_LBUTTONUP)
			     gMouseDown = FALSE;
			/*
			 * do not handle mouse messages in the main window when
			 * a menu is down!
			 */
			if(gCnx == cnxMenu)
				return(TRUE);

			mx=LOBYTE(HIWORD((LParam)));
			my=HIBYTE(HIWORD((LParam)));

/* Following is a HACK to suppress mouse messages when in Reorder
 * or Copy mode.
 */
	    if(gInReorder || gInCopy) {
		if(!ListMouse(&ProgramList, mx, my, message, LOBYTE(wParam))
			&& message==WM_LBUTTONDOWN)
		    ShellMessageBox(szInRCTitle, szInRCText);
		break;
	    }

			/* Following is a HACK to get the mouse messages to the ViewWind.
			 * ViewWind is a child window of MainWind, but we don't set the
			 * Focus to ViewWind as we want to still be able to handle the
			 * boxes around menus, etc and keep it active.
			 */
			if (m_fPerformingViewFile())
				ViewWindProc(pwnd, message, wParam, LParam) ;
			else if (glob.InFileMgr)
			{
#ifndef NORESIZE
				if(gDraggingrect)
				{
				   if (message == WM_LBUTTONUP)
				       DoEndResize(mx,my);
				   else
				   if (message == WM_MOUSEMOVE)
				      DoResize(mx,my);
				   return(TRUE);
				}
				if((mx == 0) && (my == 0))
				{
				    if(message == WM_LBUTTONDOWN)
				       DoBeginResize(mx,my);
				   return(TRUE);
				}
#endif
				if (TreeList[0].scroll.dragging)
				{
					ListMouse(&TreeList[0],mx,my,message,LOBYTE(wParam));
				} else if (TreeList[1].scroll.dragging)
				{
			       ListMouse(&TreeList[1],mx,my,message,LOBYTE(wParam));
				} else
				{
					ret = DriveMouse(mx, my, message);
					if (!ret)
					{
						ret = ListMouse(&FileList[0], mx, my, message,
													LOBYTE(wParam));

						if ((ret) && (WhoHasGlobalFocus() != FILE0))
						{
							if (GetNumItems(&FileList[0]) > 0)
								InitGlobalFocus(FILE0);
						}
					}
					if (!ret)
					{
						ret = ListMouse(&TreeList[0],mx,my,message,
													LOBYTE(wParam));
						if ((ret) && (WhoHasGlobalFocus() != TREE0))
						{
							if (GetNumItems(&TreeList[0]) > 0)
								InitGlobalFocus(TREE0);
						}
					}
					if (!ret && glob.TreeMode == TR_DOUBLE)
					{
						ret = ListMouse(&FileList[1],mx,my,message,
													LOBYTE(wParam));
						if ((ret) && (WhoHasGlobalFocus() != FILE1))
						{
							if (GetNumItems(&FileList[1]) > 0)
								InitGlobalFocus(FILE1);
						}
					}
					if (!ret && glob.TreeMode == TR_DOUBLE)
					{
						ret = ListMouse(&TreeList[1],mx,my,message,LOBYTE(wParam));
						if ((ret) && (WhoHasGlobalFocus() != TREE1))
						{
							if (GetNumItems(&TreeList[1]) > 0)
								InitGlobalFocus(TREE1);
						}
					}
#ifndef NOGROUPINFILE
					if (!ret && glob.TreeMode == TR_SHARE)
					{
						ret = ListMouse(&ProgramList,mx,my,message,LOBYTE(wParam));
						if ((ret) && (WhoHasGlobalFocus() != GROUPBOX))
							InitGlobalFocus(GROUPBOX);
					}

#endif
#ifndef NOSWITCHER
					if (!ret && gTaskListEnabled && (glob.TreeMode == TR_SHARE))
					{
						ret = ListMouse(&TaskList,mx,my,message,LOBYTE(wParam));
						if ((ret) && (WhoHasGlobalFocus() != TASKBOX))
						{
							if (GetNumItems(&TaskList) > 0)
								InitGlobalFocus(TASKBOX);
						}
					}
#endif
				}

#ifndef NODIRECT
			if(message == WM_MOUSEMOVE)
			   MonitorManipulation(gMouseX,gMouseY);
#endif

			}  /* glob.InFileMgr */
			else
			{
				 GroupManagerMouse(mx,my,message,LOBYTE(wParam));
			}
			break;

		case WM_COMMAND:
		/* WARNING!!! We always reset the tree manipulation
		   optimization before any menu command. Any things
		   which manipulate the tree not under a menu item
		   must be sure the tree has not changed before
		   using these manipulations. Also, any manipulation
		   within one of these commands could modifiy the
		   tree so it too must call ResetTreeOptimizations
		*/
			ResetTreeOptimizations();
			/* make the separator character blank again */
			inch._chTopSide1 = ' ';

			MenuCommand(pwnd, wParam|(isacceleration?0xF000:0));
			break;

		case WM_INITMENUPOPUP:
		    /* Enable/Disable the file manager menu items. */
		    isacceleration = (HIWORD(LParam)==mmdAccel);
		    if (glob.InFileMgr)
		    {
					/* If focus is on the file manager protion of the screen and
					 * user is in SHARED mode, enable/disable FileManager menu
					 * items, else handle the ProgramManager items.
					 */
					if (IsFMMenuPutUp())
					{
						if (IsTreeBeingBuilt())
						CrippleFileMenuBar() ;
						else
						EnableDisableFileOps() ;
					}
					else
					{
						EnableDisablePMMenu() ;
					}
			}
			else
			{
				if (m_fPerformingViewFile())
				{
					EnableDisableViewMenu() ;
				}
				else
				{
					EnableDisablePMMenu() ;
				}
			}

		    if(!isacceleration)
		    {
				/* menu is just about to pop up */
				/* we need to restore the separator character
				 * which is used both for separator and that
				 * annoying bottom line in dialogs
				 */
				if(!gisgraph)
					inch._chTopSide1 = cinch._chTopSide1;
				gwParam = wParam;
				gMwnd = pwnd;
				if(gisgraph)
				{
					RealFilterProc = pfnFilter;
					pfnFilter = MyMenuFilterProc;
				}
		    }
			break;

		case WM_MENUSELECT:
		{
		   if ((LParam == 0) && (wParam == 0))
		   {
			if(gisgraph)
			{
			   if(RealFilterProc)
			      pfnFilter = RealFilterProc;
			}
			/* menu is coming down */
			/* make the separator character blank again */
			inch._chTopSide1 = ' ';
		   }
		}
		break;

		default:
			break;
		}
#if 0
	 if (gDoAltMenu)
	 {
		gDoAltMenu = FALSE;
		/* WARNING VK_MENU (VK_ALT) will not work here --don't know why! */
		PostMessage(NULL, WM_CHAR, VK_F10, 0L);
	 }
#endif

	  return(TRUE);
	}

/* We need to know when we are inside a dialog, so we won't do hotkeys
 * etc. gCnx is not enough, as it is only "active" when the dialog is
 * idle, which is exactly not when a key is pressed.
 */
BOOL gInDialog = FALSE;
BOOL gfMouseReEnableHack;

TMC     MyTmcDoDlg(VOID *pdlg, HCAB hcab)
{
	TMC tmc ;

	/* We want to disable mouse before a dialog pops up.
	 * we enable the mouse back again later after dialog has popped up!
	 */
	FEnableMouseNest(FALSE) ;
	++gInDialog;

	gfMouseReEnableHack = TRUE ;

	tmc = TmcDoDlgAxAy(pdlg, hcab,(AX) ((PDLG)pdlg)->crcDlg.x,
											 (AY) ((PDLG)pdlg)->crcDlg.y) ;
	--gInDialog;
	FEnableMouseNest(TRUE) ;

	/* Dialog has been dismissed, so mark the mouse are not being down!
	 * This variable gets set when we get a single/double click. Happens
	 * say when we try to launch a program in the PM which needs arguments.
	 */
	gMouseDown = FALSE ; 

	return tmc ;
} /* MyTmcDoDlg */


extern VOID Arrow(void);
void CalcDriveIconPositions(void) ;
WORD MouseVersion(void);

extern BOOL SetFAltGr(BOOL fTreatAltsDifferently) ;
extern int FTreatAltsDifferently(void) ;

 /*
 *      Draw main window, and menus
 */
/* fFirtTime specifies whether this routine is being called for the first time
 * or whether it is being called on a screen mode change.
 */
VOID FAR InitWindows(BOOL fFirstTime)
{
	/*
	 * suggested by kirkg to enable TSR pasteing.
	 * Here, we pretend we are WORKS
	 */
	SetTsrProtocol(0x55FE,5,0);
	EnableKeyboard(TRUE);

	SetFAltGr(FTreatAltsDifferently()) ;

	/* NOTE! setwindowsize must go before move window! */
	SetWindowSize(&MainWind, axMac, ayMac);
	MoveWindow(&MainWind, 0, 0);
	EnableWindow(&MainWind, TRUE);
	SetFocus(&MainWind);
	EnableCursor(&MainWind, FALSE);
	DrawWindow(&MainWind);

	Arrow(); /* set up the default cursor */

	/* If this is not the first time, this is happening. The screen mode has
	 * changed, so the rest of the world which initialized stuff based on
	 * axMac, ayMac might have to recalculate the values again.
	 */
	if (!fFirstTime)
	{
		/* The file manager needs to re-calculate where the drive icons are
		 * to be drawn if in double tree mode.
		 */
		 CalcDriveIconPositions() ;

		 /* We don't initialize the mouse first time so it won't get in the
		  * way during start-up. Thus, init does it.
		  */
		 FInitMouseNest();
	}
}



VOID DialogIsAlert(BOOL set)
{
    static WORD lastfore,lastback;
    WORD alertfore,alertback;

    if(set)
    {
       GetIsaColor(isaDialogBox, &lastfore, &lastback);
       GetIsaColor(isaAlert, &alertfore, &alertback);
       SetIsaColor(isaDialogBox,alertfore,alertback);
    }else
       SetIsaColor(isaDialogBox,lastfore,lastback);
}

VOID  MySetColor(WORD color) ;


void DrawDialogBorderAndTitle(PWND pwnd)
{
	RRC dr;
	RX x;
	int len;
	BOX  tboxinfo;
	WORD fore, back ;

	FEnableMouseNest(FALSE) ;
	if(!gisgraph)
	{
	GetClientRrc(pwnd,&dr);

		tboxinfo.chTopLeftCorner          = cinch._chTopLeftCorner1;
		tboxinfo.chTopRightCorner         = cinch._chTopRightCorner1;
		tboxinfo.chBottomLeftCorner   = cinch._chBottomLeftCorner1;
		tboxinfo.chBottomRightCorner  = cinch._chBottomRightCorner1;
		tboxinfo.chTopSide                = cinch._chTopSide1;
		tboxinfo.chBottomSide     = cinch._chBottomSide1;
	tboxinfo.chLeftSide       = cinch._chLeftSide1;
	tboxinfo.chRightSide      = cinch._chRightSide1;
	DrawBox(pwnd, &dr, &tboxinfo, isaDialogBox);                                            
	}
	else
	{
		FrameDialog(pwnd->arcWindow.ayTop,pwnd->arcWindow.axLeft,
						pwnd->arcWindow.ayBottom,pwnd->arcWindow.axRight);

		GetIsaColor(isaBorders,&fore,&back);
		MySetColor(fore);

		Move(pwnd->arcWindow.axLeft*CWIDTH+2,(pwnd->arcWindow.ayTop+1)*CHEIGHT);
		Draw(pwnd->arcWindow.axRight*CWIDTH-3,(pwnd->arcWindow.ayTop+1)*CHEIGHT);
	}

	len = strlen(szCurDialogCaption);
	x = (pwnd->arcWindow.axRight - pwnd->arcWindow.axLeft+1)/2;
	x = x-len/2;
	CharOut(pwnd,x-1,0,' ',isaWhiteOnBlack);
	TextOut(pwnd,x,0,szCurDialogCaption,-1,isaWhiteOnBlack);
	CharOut(pwnd,x+len,0,' ',isaWhiteOnBlack);

	FEnableMouseNest(TRUE) ;
} /* DrawDialogBorderAndTitle */

DWORD (FAR *Pfndialog_chain)(PWND,WORD,WORD,DWORD);
BOOL gDialogIgnoreNextPaint = FALSE;

DWORD FAR PASCAL Pfndialog(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	if ((gDialogIgnoreNextPaint) && (message == WM_PAINT))
	{
		gDialogIgnoreNextPaint = FALSE;
		return(TRUE);
	}
	Pfndialog_chain(pwnd,message,wParam,LParam);

	if (message == WM_PAINT)
	{
		DrawDialogBorderAndTitle(pwnd) ;
	} /* paint message */
	else
	{
		/* The mouse was disabled in fn MyTmcDoDlg(). It remains disabled
		 * until this moment. At this time, the dialog has been completely
		 * drawn (static text, edit boxes, etc). I can avoid this hack
		 * variable if CW always sent in a WM_SETFOCUS message after finishing
		 * all the draw operations. Unfortunately, they send this message
		 * only for certain dialogs (like Fdlgmessage).
		 */
		if ( (gfMouseReEnableHack) && (message == WM_DIALOGIDLE) )
		{
			gfMouseReEnableHack = FALSE ;
			FInitMouseNest() ;
		}
	}

	return(TRUE) ;
}
DWORD (FAR *Pfnnothing_chain)(PWND,WORD,WORD,DWORD);

DWORD FAR PASCAL Pfnnothing(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    switch(message)
    {
	case WM_SETFOCUS:
	case WM_KILLFOCUS:
	case WM_PAINT:
	  {
	     return(TRUE);
	  }
    }
	return(Pfnnothing_chain(pwnd,message,wParam,LParam)) ;
}

DWORD (FAR *Pfnpanel_chain)(PWND,WORD,WORD,DWORD);

DWORD FAR PASCAL Pfnpanel(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    DWORD retval;

    retval = Pfnpanel_chain(pwnd,message,wParam,LParam);

    if (message == WM_PAINT)
    {
	 FEnableMouseNest(FALSE);

	 FrameCharRect(pwnd->arcWindow.ayTop,pwnd->arcWindow.axLeft,
			 pwnd->arcWindow.ayBottom,pwnd->arcWindow.axRight, 1,isaDialogBox);
	 FEnableMouseNest(TRUE);
    }
    return(retval);
}


DWORD (FAR *Pfnbutton_chain)(PWND,WORD,WORD,DWORD);

DWORD FAR PASCAL Pfnbutton(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    char buttontext[20];
    DWORD retval;
    RX x;
	int len;

    switch(message)
    {
	case WM_SETFOCUS:
	    gCurrentTMC = pwnd->id;
	case WM_KILLFOCUS:
	case WM_PAINT:
	  {
	     if(fDrawItem && !fRedrawItem) /* not just initializing */
	     {
		 FEnableMouseNest(FALSE);
		 if(gisgraph)
		 {
			FrameButton(pwnd->arcWindow.ayTop,pwnd->arcWindow.axLeft,
						pwnd->arcWindow.ayBottom,pwnd->arcWindow.axRight);
		 }
		 GetTmcText(pwnd->id, buttontext, 20);
		 len = strlen(buttontext);
		 x = (pwnd->arcWindow.axRight - pwnd->arcWindow.axLeft)/2;
		 x = x-len/2;
		 if(!gisgraph)
		    CharOut(pwnd,(RX)x-1,(RY)0,' ',isaPushButton);
		 TextOut(pwnd,x,0,buttontext,-1,isaPushButton);
		 if(!gisgraph)
		    CharOut(pwnd,(RX)x+len,(RY)0,' ',isaPushButton);
		 MoveCursor(pwnd,x,0);
		 FEnableMouseNest(TRUE);
	     }
	     return(TRUE);
	  }
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	  retval = Pfnbutton_chain(pwnd,message,wParam,LParam);
	  retval = Pfnbutton_chain(pwnd,WM_LBUTTONUP,wParam,LParam);
	  gMouseDown=FALSE;
	  return(retval);
    }
    retval = Pfnbutton_chain(pwnd,message,wParam,LParam);
    return(retval);
}

/* ZZZ Without this fn, we get BLACK BLOBS for check boxes sometimes -- 
 * A CW bug??
 */
/* Check Box Left X-Coordinate relative to window. */
#define CB_X (0)
DWORD (FAR *Pfncheckbox_chain)(PWND,WORD,WORD,DWORD);
DWORD FAR PASCAL Pfncheckbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	switch (message)
	{
	char tstr[95]; // Check Box string storage -- won't exceed screen width

		case WM_PAINT:
			if(fDrawItem) /* not just initializing */
			{
				/* ZZZZ For Graphics mode, we can do special drawing of
				 * the check boxes if we want.
				 */
				FEnableMouseNest(FALSE);
				CharOut(pwnd,CB_X,0, CHECKBOX_LEFTCHAR,isaDialogBox);
				CharOut(pwnd,CB_X+1,0,
					GetTmcVal(pwnd->id&0xFF) ?      CHECKBOX_CHECKCHAR : ' ',
					isaDialogBox) ;
				CharOut(pwnd,CB_X+2,0, CHECKBOX_RIGHTCHAR,isaDialogBox);

			GetTmcText(pwnd->id&0xFF, tstr, 
							pwnd->arcWindow.axRight - pwnd->arcWindow.axLeft + 1);
				TextOut(pwnd,CB_X+4,0,tstr,-1,isaDialogBox);
				FEnableMouseNest(TRUE);
			}
			return(TRUE);

		case WM_SETFOCUS:
			/* Move the cursor to the center of the CheckBox. By default CW
			 * sends it to the left ('[' char).
			 */
			MoveCursor(pwnd, CB_X+1, 0) ;
			break ;
	}
   return Pfncheckbox_chain(pwnd,message,wParam,LParam);
} /* Pfncheckbox */


DWORD (FAR *Pfneditbox_chain)(PWND,WORD,WORD,DWORD);
DWORD FAR PASCAL Pfneditbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
   DWORD retval;
   char tstr[256];
	TMC tmc ;
	int edit_width ;
	int edit_scroll ;

   switch(message)
   {
		case WM_PAINT:
		{
			if(gisgraph)
			{
				if(fDrawItem) /* not just initializing */
				{
					
					FEnableMouseNest(FALSE);

					/* BUG BUG see below in setupeditbox */
					GetTmcText((tmc = pwnd->id&0xFF), tstr, sizeof(tstr)) ;

					edit_width = pwnd->arcWindow.axRight -
															pwnd->arcWindow.axLeft + 1 ;

					edit_scroll = strlen(tstr) - edit_width + 2 ;
					if (edit_scroll < 0) 
						edit_scroll = 0 ;

					/* If 'tmc' is the item that has initial focus -- saved in
					 * SetUpEditBox(), we display text in hilite mode.
					 */
					/* ZZZZ There should a better way to tell this using CW!!! */

					//if (tmc == gInitialHiliteTMC)
					if(GetFocus() ==pwnd)
					{
#if 0 
	not needed
						/* Set it back to the invalid TMC default value */
						gInitialHiliteTMC = INVALID_TMC ;
#endif
						TextOut(pwnd, 0, 0, tstr + edit_scroll, -1, isaHilite) ;
					}
					else
					{
						TextOut(pwnd, 0, 0, tstr + edit_scroll, -1, isaDialogBox) ;
					}

					FrameCharRectInset(pwnd->arcWindow.ayTop,pwnd->arcWindow.axLeft,
							pwnd->arcWindow.ayBottom,pwnd->arcWindow.axRight,1,1,isaDialogBox);
					FEnableMouseNest(TRUE);
				}
				return(TRUE);
		   }
		}
		break;
		case WM_CHAR:
		{
			GetTmcText(pwnd->id, tstr, 256);
			if(strlen(tstr)+1 > (pwnd->rgwExtra[0])) /* max len stored here */
			{
				switch(wParam)
				{
					case VK_DELETE:
					case 127: //also delete
					case VK_INSERT:
					case VK_HOME :
					case VK_END :
					case VK_LEFT:
					case VK_RIGHT:
					case VK_UP:
					case VK_DOWN:
					case VK_TAB:
					case KEY_TAB:
					case VK_ESCAPE:
					case ESCAPE:
					case '\b':
					case '\r':
						break; // fall through to normal handling
				   default:
						Shell_Beep() ;
						return TRUE     ;
				}       
			}
		}
		break;
	}
   retval = Pfneditbox_chain(pwnd,message,wParam,LParam);
   return(retval);
}

extern char currentPassword[MAXUSERPASSWORD];

DWORD FAR PASCAL Pfnpasswordbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
    DWORD retVal;
    int i;
    char tstr[MAXUSERPASSWORD];

    switch(message) {
    case WM_SETFOCUS:
	retVal = Pfneditbox(pwnd, message, wParam, LParam);
	GetTmcText(pwnd->id, tstr, MAXUSERPASSWORD);
	i = strlen(tstr);
	SetTmcSel(pwnd->id, i, i);
	return(retVal);

    case WM_LBUTTONDOWN:
	SetFocusTmc(pwnd->id);
    case WM_LBUTTONDBLCLK:
    case WM_MOUSEMOVE:
    case WM_LBUTTONUP:
	return(TRUE);

    case WM_CHAR:
	if(wParam == VK_DOWN)
	    break;
	if(wParam == 127 || wParam >= 0x100) {
	    Shell_Beep() ;
	    return(TRUE);
	}
	if(wParam >= ' ') {
	    GetTmcText(pwnd->id, tstr, MAXUSERPASSWORD);
	    i = strlen(tstr);
	    currentPassword[i] = LOBYTE(wParam);
	    wParam = '*';
	}
	break;
    }

    return(Pfneditbox(pwnd, message, wParam, LParam));
}

DWORD FAR PASCAL Pfnfakeeditbox(PWND pwnd, WORD message, WORD wParam, DWORD LParam)
{
	/* prevent the user from editing the items of this fake edit-box. */
	switch(message)
	{
		case WM_CHAR:
		{
			switch(wParam)
			{

				case VK_HOME :
				case VK_END :
				case VK_LEFT:
				case VK_RIGHT:
				case VK_UP:
				case VK_DOWN:
				case VK_TAB:
				case KEY_TAB:
				case VK_ESCAPE:
				case ESCAPE:
					break ;  /* pass these on to the Pfn function */
				default:
					Shell_Beep() ;
					return TRUE     ;
			}

		}
	   break;
	}
	return Pfneditbox(pwnd, message, wParam, LParam) ;
} /* Pfnfakeeditbox */


DWORD (FAR *Pfnradiobutton_chain)(PWND,WORD,WORD,DWORD);
DWORD (FAR *Pfnradiogroup_chain)(PWND,WORD,WORD,DWORD);
#define MAXRADIOS 6
PWND gRadioWind[MAXRADIOS];
BYTE numradios;
BYTE gNeedsUpdate;

VOID PASCAL DrawRadios(WORD item, BOOL bEraseBitmap)
{
    char tstr[20];

    if(item >= numradios)
	return;

    FEnableMouseNest(FALSE);

    GetTmcText((gCurRadioGroup&(~ftmcGrouped))+item, tstr, 20);
    TextOut(gRadioWind[item], 4, 0, tstr, -1, isaDialogBox);
    if(bEraseBitmap)
	TextOut(gRadioWind[item], 0, 0, "    ", -1, isaDialogBox);
    PlotBmp(GetTmcVal(gCurRadioGroup)==item ? RadioButtonSel : RadioButtonUnSel,
	    (gRadioWind[item]->arcWindow.axLeft)*CWIDTH+4,
	    gRadioWind[item]->arcWindow.ayTop*CHEIGHT, isaDialogBox);

    FEnableMouseNest(TRUE);
}

void PASCAL MySetTmcVal(TMC theTMC, WORD theVal)
{
    WORD oldVal;

    oldVal = GetTmcVal(theTMC);
    gCurrentTMC = (theTMC&(~ftmcGrouped)) + theVal;
    SetTmcVal(theTMC, theVal);

    DrawRadios(oldVal, FALSE);
    DrawRadios(theVal, FALSE);
}

DWORD FAR PASCAL Pfnradiobutton(PWND pwnd, WORD message, WORD wParam,
													DWORD LParam)
{
	UnReferenced(LParam) ;
    switch(message)
    {
		case WM_CHAR:
		{
			 switch(wParam)
			 {
				case '\t':
					if(HIWORD(LParam) & KK_SHIFT)
					   SetFocusTmc(gPrevTmc);
					else
					   SetFocusTmc(gNextTmc);
					return(TRUE); /* tab out */
				case VK_ESCAPE:
				case ESCAPE:
				case VK_RETURN:
				case '\r':
					return(FALSE); /* tab out */
				case VK_UP:
				case VK_PRIOR:
					MySetTmcVal(gCurRadioGroup,
					(GetTmcVal(gCurRadioGroup)+numradios-1)%numradios);
				break;
				case VK_NEXT:
				case VK_DOWN:
					MySetTmcVal(gCurRadioGroup,
						(GetTmcVal(gCurRadioGroup)+1)%numradios);
			 }

		}
	break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		 MySetTmcVal(gCurRadioGroup,pwnd->id);
		 break;

    case WM_SETFOCUS:
	gCurrentTMC = (gCurRadioGroup&(~ftmcGrouped))+GetTmcVal(gCurRadioGroup);
    case WM_KILLFOCUS:
	EnableCursor(pwnd,FALSE);
    case WM_WANTFOCUS:
	break;

    case WM_REPAINT:
    case WM_PAINT:
	DrawRadios(pwnd->id, TRUE);
	break;
    }
	return(TRUE);
}

/*
 * Just like SetTmcText, except we ensure that '~''s don't
 * get translated funny by SDM.
 */
VOID FARPUBLIC Shell_SetTmcText(TMC tmc, char *text)
{
	SetWindowStyle(PwndOfListbox(tmc),WS_STATIC_NOACCEL);
	SetTmcText(tmc,text);
}

VOID SetUpDialog(TMC tmcchild,char *title)
{
     PWND dwind;

	 szCurDialogCaption=title;

	 dwind = PwndParent(PwndOfListbox(tmcchild));
     SetWindowStyle(dwind,WS_TILED);
     Pfndialog_chain = GetWindowProc(dwind);
     SetWindowProc(dwind,Pfndialog);
}

VOID SetUpButtonForGraphics(TMC tmc)
{
     PWND dwind;

     dwind = PwndOfListbox(tmc);
     Pfnbutton_chain = GetWindowProc(dwind);
     dwind->id = tmc;
     SetWindowProc(dwind,Pfnbutton);
}

/*
 * tmc is the tmc of the edit box
 * fRealOrNot TRUE means the text can be edited, FALSE only cursor keys work
 * maxcount is the maximum allowable length of the text input (<=255!)
 */
VOID SetUpEditBox(TMC tmc, BOOL fRealOrNot, WORD maxcount, BOOL fHasInitialFocus)
{
	char tstr[256];
	PWND dwind;

	/* ZZZZZ Remove this parameter when time permits -- not needed anymore */
	UnReferenced(fHasInitialFocus) ;

	/* be sure we don't clip if we don't need to! */
	if(maxcount > 255)
		maxcount = 255;

#if 0
	not needed
	if (fHasInitialFocus)
		gInitialHiliteTMC = tmc ;
#endif
   dwind = PwndOfListbox(tmc);
   Pfneditbox_chain = GetWindowProc(dwind);
	/*BUG BUG BUG BUG can we do this? are tmc < 256 always?*/
	dwind->id = tmc; 
	dwind->rgwExtra[0] = (BYTE) maxcount;
	GetTmcText(tmc, tstr, 256);
	if(strlen(tstr)+1 > maxcount) {
		tstr[maxcount] = '\0';
		Shell_SetTmcText(tmc, tstr);
	}

	if (fRealOrNot)
	{
		SetWindowProc(dwind, Pfneditbox);
	}
	else
	{
		SetWindowProc(dwind, Pfnfakeeditbox) ;
	}
} /* SetUpEditBox*/

VOID SetUpCheckBox(TMC tmc)
{
	PWND dwind ;

	dwind = PwndOfListbox(tmc);
	Pfncheckbox_chain = GetWindowProc(dwind) ;
	dwind->id = tmc ;
	SetWindowProc(dwind, Pfncheckbox) ;
} /* SetUpCheckBox */


VOID SetUpRadioGroupForGraphics(TMC group, TMC prevtmc, TMC nexttmc)
{
     gNeedsUpdate = TRUE;
	 gCurRadioGroup=group;
	 gPrevTmc = prevtmc ;
	 gNextTmc = nexttmc ;
	 numradios = 0;
}

VOID SetUpRadiobuttonForGraphics(TMC tmc,int index)
{
     PWND dwind;

	 UnReferenced(index) ;

     dwind = PwndOfListbox(tmc);
     gRadioWind[numradios] = dwind;
     dwind->id = numradios;
     ++numradios;
     Pfnradiobutton_chain = GetWindowProc(dwind);
     SetWindowProc(dwind,Pfnradiobutton);
}

/* This is called from the menu -- Refresh -- to brings us out of the
 * stunned mode we get into if stupid APPS like LANMAN, SIDEKICK screw
 * the screen brightness attributes, etc and not reset it properly.
 */
extern void RefreshViewFileScreen(BOOL fClearAndRedraw) ;
void DoFullRefresh(void)
{
	/* Set screen mode -- hard reset! */
	SetScreenMode(gscreenmode) ;

	if (m_fPerformingViewFile())
	{
		FEnableMouseNest(FALSE) ;
		setmenubar(&ViewMenuBar, &MainWind) ;

		RefreshViewFileScreen(TRUE) ;

		/* We should not do InitWindows() in this case as that would cause
		 * MainWind to get the focus and not ViewWind!
		 */
		Arrow(); /* set up the default cursor */

		/* The help line for view at bottom of screen */
		MessageBar(szViewMessage, isaMenu,TRUE) ;
		FEnableMouseNest(TRUE) ;
		return ;
	}

	InitWindows(FALSE);

	FEnableMouseNest(FALSE) ;

	if (glob.InFileMgr)
	{
		if (glob.TreeMode == TR_SEARCH)
		{
			DoSearchDisplay(FALSE) ;
		}
		else
			DoFileMgr();
	}
	else
		InitializeStartPrograms();

	FEnableMouseNest(TRUE) ;
} /* DoFullRefresh */

#if 0
VOID SetUpPanelForGraphics(TMC tmc)
{
     PWND dwind;
     dwind = PwndParent(PwndOfListbox(tmc));

     Pfnpanel_chain = GetWindowProc(dwind);
     SetWindowStyle(dwind,WS_TILED);
     SetWindowProc(dwind,Pfnpanel);
}
VOID SetUpNothingButton(TMC tmc)
{
     PWND dwind;
     dwind = PwndOfListbox(tmc);
     Pfnnothing_chain = GetWindowProc(dwind);
     SetWindowProc(dwind,Pfnnothing);
}
 
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\sort.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* File "sort.c" ---- separated from add.c */

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <assert.h>


extern PENTRY GetLastsnextFile(PTREE tree) ;

/* Recursive routine called by FormDirectoryOrder to update the snext chain */
/* It invokes function Updatesnext for each file belonging to 'dir' of 'tree'*/
/* For sub-directories belonging to 'dir', it calls itself recursively and  */
/* gets the same job done for them too. It does this for each file/sub-dir  */
/* belonging to 'dir'.														*/
VOID WalkDirsnext(PTREE tree, PENTRY dir)
{
	PENTRY temp ;

	/* temp is updated to its next sibling in the body of the loop */
	for (temp = dir->x.d.child ; temp ; )
	{
		if (temp->attribs & _A_SUBDIR)
			WalkDirsnext(tree, temp) ;
		else
			Updatesnext(tree, dir, temp, TRUE) ;

		temp = (temp->nosib) ? NULL : temp->sibling ;
	}
}

VOID FormDirectoryOrder(PTREE tree, BOOL doit)
{
	PENTRY temp ;
	int t1, t2 ;

	/* If tree is still being built, don't do anything */
	if (tree->ContinueTree)
		return ;

	t1 = tree->skey ;
	t2 = tree->tmode ;
	tree->skey = glob.SortKey ;
	tree->tmode = glob.TreeMode ;

	tree->SortRequired = FALSE ;

	if ( doit || (t1 != glob.SortKey) || 
			((t2 == TR_SYSTEM) && (t1 != SORT_DISK)) )
	{

		if (!tree->FirstFile)
			return ; /* no files in tree -- so already in correct order */
		
#ifdef DBGBEEP
Beep() ;
#endif
		/* Initialize all directories as having no file based on snext */
		for (temp = tree->FirstDirectory ; temp ; temp = temp->x.d.dnext)
			temp->FIRSTFILEFOUND = FALSE ;

		/* Initialize the snext bits for all the files */
		for (temp = tree->FirstFile ; temp ; temp = temp->x.f.snext)
		{
			temp->FIRSTDIRFILE = temp->LASTDIRFILE = FALSE ;
		}

		tree->FirstFile = tree->LastFile = NULL ;

		/* Note that we don't have to check the temp->nosib field as we know
			that the parents of these files/directories is NULL and that is the
			terminating condition of the for loop. */
		for (temp = tree->head ; temp ; temp = temp->sibling)
		{
			if (temp->attribs & _A_SUBDIR)
				WalkDirsnext(tree, temp) ;
			else
				Updatesnext(tree, NULL, temp, TRUE) ;
		}
	}
}

VOID SystemSort(PTREE tree, BOOL doit)
{
	int t1, t2 ;

	/* If tree is still being built, don't do anything */
	if (tree->ContinueTree)
		return ;

#ifndef NOCONSISTENCY
	if (glob.TreeMode != TR_SYSTEM)
	{
		printf("** SystemSort CALLED IN NON TR_SYSTEM MODE DOSSHELL ERROR") ;
		exit(0) ;
	}
#endif

	t1 = tree->skey ;
	t2 = tree->tmode ;

	/* Mark all directories as being un-sorted */
	SetUpTreeForSort(tree) ;

	tree->skey = glob.SortKey ;
	tree->tmode = glob.TreeMode ; /* should be TR_SYSTEM */

	tree->SortRequired = FALSE ; /* Sort is going to be done now! */

	if (doit || (t1 != glob.SortKey))
	{

		/* SortKey changed or doit !! -- So we have to reorder the whole tree */
		if (glob.SortKey != SORT_DISK)
		{
			if (tree->filecount > 0)
		    {
#ifdef DBGBEEP
			   Beep() ;
#endif
			   tree->FirstFile = mergesort(tree->FirstFile, tree->filecount);
				tree->LastFile = GetLastsnextFile(tree) ;
		    }
			/* else can't mergesort if number of files <= 0 */
		}
		else /* Form Disk Order */
			FormDirectoryOrder(tree, TRUE) ;
	}
	else
			if ( (t1 != SORT_DISK) && (t2 != glob.TreeMode) && 
						(tree->filecount > 0) )
									
			/* Treemode has changed and it is not diskorder -- so we
			   need to sort the whole tree */
		    {
#ifdef DBGBEEP
			   Beep() ;
#endif
			   tree->FirstFile = mergesort(tree->FirstFile, tree->filecount);
				tree->LastFile = GetLastsnextFile(tree) ;
		    }
			/* else can't mergesort if number of files <= 0 */
} /* System Sort */


void SetUpTreeForSort(PTREE tree)
{
	PENTRY dir ;

	tree->SortRequired = TRUE ;

	for (dir = tree->FirstDirectory ; dir ; dir = dir->x.d.dnext)
		dir->DIRSORTED = FALSE ;

	tree->skey = -1 ; /* non-sort key */
	tree->tmode = -1 ; /* non-tree mode */

} /* SetUpTreeForSort */


void DeleteFilesFromsnextChain(PTREE tree, PENTRY dir) ;

void SortDirectory(PTREE tree, PENTRY dir)
{
	PENTRY prevfil, node ;

	/* If tree is still being built, don't do anything */
	if (tree->ContinueTree)
		return ;

	/* does 'dir' need sorting? */
	if ( (dir && (!dir->DIRSORTED)) || ((!dir) && (tree->SortRequired)) )
	{
#ifdef DBGBEEP
	Beep() ;
#endif
		DeleteFilesFromsnextChain(tree, dir) ;

		/* First mark all files belonging to 'dir' as deleted */
		node = (dir) ? dir->x.d.child : tree->head;
		prevfil = NULL ;
		while(node)
		{
			if (!(node->attribs & _A_SUBDIR))
			{
				UpdateLatesnext(tree, dir, node, prevfil, TRUE) ;
				prevfil = node ;
			}

			node = (node->nosib) ? NULL : node->sibling ;
		} /* while */

		if (!dir)
			tree->SortRequired = FALSE ;
		else
			dir->DIRSORTED = TRUE ;
	}
	/* else 'dir' was already in sorted order -- do nothing! */
} /* SortDirectory */

void ForceSortDirectory(PTREE tree, PENTRY dir)
{
	if (dir)
		dir->DIRSORTED = FALSE ;
	else
		tree->SortRequired = TRUE ;

	SortDirectory(tree, dir) ;
} /* ForceSortDirectory */

/* ZZZZZZ for sorting by this key, etc if key values same, do I then
display these in random order or disk order??? The way it is set up now
it will do it in the order it was sorted before and that is good!!.		*/

/* Usually people want reverse sorting by date -- This routine is optimized
 * for that case -- the "if !(gDescending)" will fail in that case.
 * RETURNS : -1 if (a < b), 0 if equal and +1 otherwise.
 *				 This is for ascending order sort, else negated value.
 */
int date_cmp(PENTRY a, PENTRY b)
{
	int ret ;

	ret = ( (b->dtlx.dt.date > a->dtlx.dt.date) -
			  (b->dtlx.dt.date < a->dtlx.dt.date)
			) ;

	/* If dates are the same, use the time field as the secondary key to
	 * compare.
	 */
	if (!ret)
	{
		ret = ( (b->dtlx.dt.time > a->dtlx.dt.time) -
				  (b->dtlx.dt.time < a->dtlx.dt.time)
				) ;
	}

	if (!gDescendingOrder)
		ret = -ret ;
	
	return ret ;

} /* date_cmp */

/* Usually people want reverse sorting by size -- This routine is optimized
 * for that case -- the "if" will fail in that case.
 * RETURNS : -1 if (a < b), 0 if equal and +1 otherwise.
 *				 This is for ascending order sort, else negated value.
 */
int size_cmp(PENTRY a, PENTRY b)
{

	int ret ;

	ret = ( (b->x.f.size > a->x.f.size) - (b->x.f.size < a->x.f.size) ) ;

	if (!gDescendingOrder)
		ret = -ret ;
	
	return ret ;

} /* size_cmp */

#ifndef NDEBUG
/* This function should not be invoked at all!						 */
int disk_cmp(PENTRY a, PENTRY b)
{
	UnReferenced(a) ;
	UnReferenced(b) ;

	assert(TRUE) ;
}
#endif

PENTRY merge(PENTRY a,PENTRY b)
{
    fileinfo z;
    PENTRY c;

    c = &z;
    do
    {
	if ((*SortCmp)(a,b)<1)
	{
	    c->x.f.snext = a;
	    c = a;
	    a = a->x.f.snext;
	}
	else
	{
	    c->x.f.snext = b;
	    c = b;
	    b = b->x.f.snext ;
	}
    }
    while(c->x.f.snext != NULL);
    if (a == NULL)
       c->x.f.snext = b;
    else
       c->x.f.snext = a;
    return(z.x.f.snext);
} /* merge */

PENTRY isort(PENTRY head)
{
    fileinfo a;
    PENTRY b;
    PENTRY c;
    PENTRY d;
    PENTRY e;
    a.x.f.snext = head;
    b = head;
    while(b->x.f.snext != NULL)
    {
	while((*SortCmp)(b,b->x.f.snext)<1)
	{
	    b=b->x.f.snext;
	    if (b->x.f.snext == NULL)
		break;
	}
	if (b->x.f.snext != NULL)
	{
	    c = b->x.f.snext;
	    b->x.f.snext = b->x.f.snext->x.f.snext; /* delete it */
	    /* insert it in correct place */
	    d = &a;
	    /* go until c > one in list */
	    while(!((*SortCmp)(c,d->x.f.snext)<1))
	    {
	       d = d->x.f.snext;
	    }
	    /* insert c after one in list */
	    e = d->x.f.snext;
	    d->x.f.snext = c;
	    c->x.f.snext = e;
	}
	else
	    break;
   }
   if(a.x.f.snext == NULL)
	return(head);
   return(a.x.f.snext);
} /* isort */

PENTRY mergesort(PENTRY c,WORD n)
{
    PENTRY a;
    PENTRY b;
    int i;

    if (n <= 10)
    {
	return(isort(c));
    }
    /*WARNING! following code will not work for very small n */
    a = c;
    for(i=1;i<=(n-1)/2;i++)
    {
	a=a->x.f.snext;
    }
    b = a->x.f.snext;
    a->x.f.snext = NULL;
    return(merge(mergesort(c,i),mergesort(b,n-i)));
} /* mergesort */

/* The reason we use "SortFnArr[SORT_NAME]" instead of the fn "name_cmp"
 * is because depending on whether we have a collating table or
 * whether it is USA/UK we use a slow/fast name compare routine .
 */
void InsertDir(PTREE tree, PENTRY parent, PENTRY dir)
{
	PENTRY after, temp ;
	PENTRY FirstSubDir, LastSubDir ;
	PENTRY prev_dfs_dir ;
	WORD TempDescendingOrder ;

	if (tree->FirstDirectory == NULL)
	{
		/* directory head needs initialization */
		tree->FirstDirectory = dir;
		dir->x.d.dnext = NULL ;
	}
	else
	{
		/* If a directory has subdirectories, we assume that they have
		 * already been inserted in sorted order. This happens right now
		 * only when one tries to rename a directory from within the DOSSHELL
		 * and the current request is to clone windows and insert the renamed
		 * directory in the appropriate sorted order.
		 */
		if (dir->HASSUBDIRS)
		{
			/* Now, temporarily unlink the sub-directory chain of 'dir' */
			LastSubDir = FirstSubDir = dir->x.d.dnext ;

			assert(FirstSubDir != NULL) ;
			
			while (LastSubDir->x.d.dnext)
			{
				if (LastSubDir->x.d.dnext->dtlx.lx.level > dir->dtlx.lx.level)
					LastSubDir = LastSubDir->x.d.dnext ;
				else
					break ;
			}

			assert(LastSubDir != NULL) ;
			
			/* Now, FirstSubDir and LastSubDir are the first and last sub-dirs
			 * of 'dir' in the chain.
			 */

			prev_dfs_dir = PrevDFSDir(tree, FirstSubDir) ;

			/* Unlink the sub-directory chain form the big chain */
			if (prev_dfs_dir)
				prev_dfs_dir->x.d.dnext = LastSubDir->x.d.dnext ;
			else
				tree->FirstDirectory = LastSubDir->x.d.dnext ;
		}

		/* Save the old sort order, as we want to always sort directories
		 * in ascending order.
		 */
		TempDescendingOrder = gDescendingOrder ;
		gDescendingOrder = 0 ; // for ascending order. This filed is looked
									  // at by the sort routines we invoke now.

		/* Actual insertion of 'dir' needs to be done here! */
		if ( (dir->dtlx.lx.level  == 1) && 
							((SortFnArr[SORT_NAME])(dir, tree->FirstDirectory)< 1))
		{
			dir->x.d.dnext = tree->FirstDirectory ;
			tree->FirstDirectory = dir ;

			/* Link the sub-directory chain of 'dir' back into global chain */
			if (dir->HASSUBDIRS)
			{
				LastSubDir->x.d.dnext = dir->x.d.dnext ;
				dir->x.d.dnext = FirstSubDir ;
			}
			gDescendingOrder = TempDescendingOrder ; // restore sort order
			return ;
		}

		/* If we get here, the new 'dir' to be added to the list will not
		 * affect tree->FirstDirectory (i.e., it will not be the first dir 
		 * in the directory chain). Now 'after' is guaranteed to be non-null.
		 */
		after = (parent) ? parent : tree->FirstDirectory ;

		temp = after->x.d.dnext ;

		while(TRUE)
		{
			if (!temp)
				break ;
			
			if (dir->dtlx.lx.level == temp->dtlx.lx.level)
			{
				if ((SortFnArr[SORT_NAME])(dir, temp) < 1)
					break ;
			}
			else if (dir->dtlx.lx.level > temp->dtlx.lx.level)
				break ;

			/* the '<' case can't happen for level, as we don't insert a dir's
			 * subdirectory before inserting it first!!
			 */

			after = temp ;
			temp = temp->x.d.dnext ;
			
		} /* while */

		dir->x.d.dnext = after->x.d.dnext ;
		after->x.d.dnext = dir ;

		/* Link the sub-directory chain of 'dir' back into global chain */
		if (dir->HASSUBDIRS)
		{
			LastSubDir->x.d.dnext = dir->x.d.dnext ;
			dir->x.d.dnext = FirstSubDir ;
		}

		gDescendingOrder = TempDescendingOrder ; // restore sort order
	} /* else */
} /* InsertDir */


/* ZZZZZZZZZZZZZZZZZZZZZZZZZZ Old code -- disk order insertion. */
#if 0
/* ZZZZZ Old code -- this fn action actually does not need 'parent'!! 
 * It just inserts at the end -- DiskOrder!
 */
void InsertDir(PTREE tree, PENTRY parent, PENTRY dir)
{
	if (tree->FirstDirectory == NULL)
		/* directory head needs initialization */
	    tree->FirstDirectory = dir;
	else
	    tree->LastDirectory->x.d.dnext = dir;

	/* ZZZ caller makes this assignment, so we need not do this! */
	// tree->LastDirectory = dir;

} /* InsertDir */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\taskman.c ===
/* Revision history since 5.0 Golden:
 *
 *  M010 SHK 08/13/91 		User can now control primary/secondary swap
 *							 		paths using the 'swapdisk' DOSSHELL.INI var.
 *							 		If this is not set, the DOSSHELL env variabl
 *							 		is used, if set. Else default 50 behaviour.
 *							 		This change was prompted by ROMDOS -- dir
 *							 		where DOSSHELL is residing might not be 
 *							 		write-able! Added fn SetUpSecondarySwapPath().
 */


;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 * This module holds the bulk of the code for the task list
 */

/* WARNING this is a hardcoded number for the number of bytes in the SFT
 */
#define DOS5SFTSIZE 0x3B

#include <common.h>
#include <filemgr.h>
#include <text.h>
#include <menus.h>
#include <prot.h>
#include <warn.hs>
#include <warn.sdm>
#include <tasklist.h>

extern char gStartUpDir[];
extern char gStartInDir[];
extern int gStartUpDirEnd; /* location where the NULL goes in the above name */
extern BYTE StartupNumLines; // number of screen lines at startup

extern BOOL VerifyTempPath(char *path) ;
VOID FarToNearsz(char *temp,char far *str,int max);
void strfcpy(char far *dst, char far *src);
VOID GetCommandString(char *commandstring,char *parameters,char *batname,int *magiccookie);
WORD DetectProcessor(void);
VOID InitGlobalSwitchData(BOOL setorgetscreenmode);

extern VOID FirstMouseInit(void);

extern WORD LinesToMode(WORD lines);
extern WORD ReturnScreenMode;
extern unsigned char far cdecl GET_WAIT_FLAG(void);

ListBoxData TaskList;

TOKEN gNext_Task_Info = TK_NOTHING;
char gNext_Task_Name[MAX_TITLE+2];

BOOL gTaskListEnabled = TRUE; 
BOOL gSwitchingEnabled = TRUE; 
BOOL gAlreadyTasking;

BOOL gfOurISR9Installed = FALSE ;

void DisableTaskList(void)
{ 
	if(gTaskListEnabled && TaskList.hasglobalfocus)
	{
		if(C_GET_LIST_LENGTH() <= 0)  //zero based, one is shell
				PrevGlobalFocus();  // go back to applist
	}

	gTaskListEnabled = FALSE; 
	if(glob.InFileMgr)
		DoFileMgr();
	else
	   InitializeStartPrograms();

   Set_KeyWord_Assignment(TK_SAVESTATE,TK_TASKLIST,TK_DISABLED);
}

void EnableTaskList(void)
{
	gTaskListEnabled = TRUE;
	C_INIT_PROGRAM_LIST();

	   
	InitGlobalSwitchData(TRUE);


	if(glob.InFileMgr)
		DoFileMgr();
	else
	   InitializeStartPrograms();
   Set_KeyWord_Assignment(TK_SAVESTATE,TK_TASKLIST,TK_ENABLED);
}
/* 
 * This function toggles the state of switcher enableing 
 */
void EnableSwitching(void)
{
   if(gSwitchingEnabled = !gSwitchingEnabled)
	{
		EnableTaskList();
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_SWITCHING,TK_ENABLED);
	}
	else
	{
		DisableTaskList();
	Set_KeyWord_Assignment(TK_SAVESTATE,TK_SWITCHING,TK_DISABLED);
	}
}

#if 0
// no longer used
void DisableSwitching(void)
{
   gSwitchingEnabled = FALSE;
   Set_KeyWord_Assignment(TK_SAVESTATE,TK_SWITCHING,TK_DISABLED);
}
#endif

void Set_Task_Info(TOKEN list)
{
	 gNext_Task_Info = list;
}
void Set_Task_Name(char far *name)
{
	if(name)
		FarToNearsz(gNext_Task_Name,name,MAX_TITLE);
	else
		gNext_Task_Name[0] = 0;
}

VOID ReInitTaskParams(void)
{
	char restartparameters[70];
	char batchname[70];
	int magiccookie;

	Switch_Entry far * SE;

	SE = (Switch_Entry far *) C_GET_ITH(0);
   if(SE->Program_Flags & FSHELL)
	{
		SE = (Switch_Entry far *) C_GET_ITH(1);   
	}
	
	magiccookie = SE->Shell_Cookie; //near!
	GetCommandString(NULL,restartparameters,batchname,&magiccookie);
	C_ADD_PARAMS(restartparameters,strlen(restartparameters));

}



VOID Switch_To_Ith_Task(int isz)
{
	Switch_Entry far * SE;
	int i;

	SE = (Switch_Entry far *) C_GET_ITH(0);
	if(SE->Program_Flags & FSHELL)
	{
		C_GO_NEXT();
	}        

	for(i=0;i<isz;i++)
	{
		 C_GO_NEXT();                    
		 SE = (Switch_Entry far *) C_GET_ITH(0);
		 if(SE->Program_Flags & FSHELL)
		 {
				C_GO_NEXT();
		 }       

	}
	C_GO_Z_NEXT(); /* Lauch will undo this! BUG BUG from hell */
	LaunchProgram(NullString,NullString,0);
}

WORD PASCAL ListProcTaskList(WORD tmm, char *sz, WORD isz, TMC tmc,WORD x, WORD y, WORD bArg)
{
	RX xval;
	char temp[256];
	Switch_Entry far * SE;
	int i;
	int aftershell;
	int num;
	int len;

	UnReferenced(sz);
	UnReferenced(tmc);
	UnReferenced(x);
	UnReferenced(bArg);

	xval = Get_List_Rect(&TaskList).axLeft;
	switch (tmm) {
		case tmmCount:
			if(gTaskListEnabled)
			{
			   
	   len = C_GET_LIST_LENGTH()+1-1; //zero based, but one is shell

			  if(TaskList.hasglobalfocus && (len == 0))
				PrevGlobalFocus(); //*
			  return(len);
			}
			else
			{
				return(0);
			}
		break;
		case tmmSetFocus:
			 break;
		case tmmSelect:
			 break;
		case tmmActivate:
			 if(isz < (num=C_GET_LIST_LENGTH())+1-1)
			 {
					Switch_To_Ith_Task(isz);
			 }
			 break;
		case tmmDrawItem:
	  case tmmGetItemString:
		{
			  if(isz < C_GET_LIST_LENGTH()+1-1) // zero base, one is shell
			  {

				  /* we need to be sure we skip the dosshell, so we walk
				   * list to see if it was before or after in the list
				   * so we will be sure to skip it!
					*/
					aftershell = 0;
					for(i=0;i<=isz;i++)
					{
						 SE = (Switch_Entry far *) C_GET_ITH(i);
						 if(SE->Program_Flags & FSHELL)
						 {
							 ++aftershell;
							 break;
						 }
					}

					SE = (Switch_Entry far *) C_GET_ITH(isz+aftershell);
					fstrncpy((char far *)temp, SE->Program_Title,MAX_TITLE);
					len = strlen(temp); // get length of title; 
					if(SE->HK_Scan_Code_2) // there is a hot key
					{
						temp[len] = ' ';
					   len = strlen(temp); // get length of title; hot key follows

					}
				   if(tmm == tmmGetItemString)
				{
						strcpy(sz,temp);
						return(TRUE);
					}

					for(i=strlen(temp);i<Get_List_Rect(&TaskList).axRight - Get_List_Rect(&TaskList).axLeft - 4;i++)
						temp[i] = ' ';
					temp[i] =0;

					TextOut(TaskList.pwd, (RX) xval+2,(RY) y,temp,len, bArg);
					TextOut(TaskList.pwd, (RX) xval+2+len,(RY) y,&temp[len],-1, isaBackground);

				   DrawFocusMarker(&MainWind, (RX)xval+1+2*gisgraph, (RY)y, (RX)xval+2, (RY)y, len, bArg&TF_ISFOCUS,
													FALSE, isaBackground) ;

			  }
				else
				{
					for(i=0;i<Get_List_Rect(&TaskList).axRight - Get_List_Rect(&TaskList).axLeft - 3;i++)
						temp[i] = ' ';
					temp[i] =0;
					TextOut(TaskList.pwd, (RX) xval+1,(RY) y,temp,-1, isaBackground);
				}
		}
			break;
		default:
			break;
	}
	return TRUE;
}
BOOL TaskManIdle(void)
{
	   return(ListBoxIdle(&TaskList));
}

BOOL TaskManKey(WORD wParam,DWORD LParam)
{
	if(TaskList.hasglobalfocus)
	{
	   ListKey(&TaskList,wParam,HIWORD(LParam));
	   return(TRUE);
	}
	return(FALSE);
}

BOOL TaskManMouse(WORD mx,WORD my,WORD message,BYTE state)
{
	return(ListMouse(&TaskList,mx,my,message,state));
}

/* M010 -- added this function to support user control of the
 * primary/secondary swap paths thru the INI file/DOSSHELL
 * environment variable.
 */

/* The swappath is expected to have a '\\' at its end. */
void SetUpSecondarySwapPath(char far *swappath, char *default_path)
{
	TOKEN swapdisk_tok ;
	char buffer[257] ;
	char *p ;
	int len ;

	swappath[0] = '\0' ;

	swapdisk_tok = Get_KeyWord_Assignment(TK_SAVESTATE, TK_SWAPDISK) ;
	if (swapdisk_tok >= 0)
	{
		/* copy from far memory to near memory and NULL terminate it
		 * so that we can use C-functions like strtok(), etc.
		 */
		strfncpy(buffer, Get_Token_Identifier(swapdisk_tok), 256) ;
		buffer[256] = '\0' ; /* Null terminate, just in case */

		/* Note that swapdisk variable in the INI file can have two paths
		 * in it -- the primary swap path followed by the secondary path.
		 * We are interested in the optional second path!
		 */
		if (strtok(buffer, " \t"))
		{
			if ( (p = strtok(NULL, " \t")) && VerifyTempPath(p) )
				strfcpy(swappath, p) ;
		}

	}

	/* if the path has not been set yet, look at the DOSSHELL env variable! */
	if (swappath[0] == '\0')
	{
		/* See if DOSSHELL is set to a valid dir! */
		p = getenv(szIniFileEnvVar);
		if (p && VerifyTempPath(p) )
				strfcpy(swappath, p);
	}

	/* if the path is still not set, use the default value passed in! */
	if (swappath[0] == '\0')
	{
		strfcpy(swappath, default_path) ;
	}

	/* Make sure that we put a terminating '\\' as expected by the caller */
	len = myfstrlen(swappath) ;

	if (swappath[len-1] != '\\')
	{
	   swappath[len++] = '\\' ;
		swappath[len] = '\0';
	}

} /* SetUpSecondarySwapPath */


VOID InitGlobalSwitchData(BOOL setorgetscreenmode)
{
	char tempdir[256];
	int ind;
	TOKEN minpath;  
	char far *minpathident;
	TOKEN grabdir;

	Switch_Info far * Switchdata;
	Switchdata = C_GET_GLOBAL_SWITCH_DATA();

	ind = gStartUpDirEnd ;
	strcpy(tempdir,gStartUpDir);

#ifdef DBCS
	if (tempdir[ind-1] != '\\' || CheckDBCSTailByte(tempdir,&tempdir[ind-1]))
#else
	if (tempdir[ind-1] != '\\')
#endif
	{
	   tempdir[ind++] = '\\' ;
		tempdir[ind] = 0;
	}

	/* Now set up secondary swap path -- Note that we expect it to have
	 * a '\\' char at its end.
	 */
	SetUpSecondarySwapPath(Switchdata->Swap_Path2, tempdir) ; /* M010 */

	/* tell switcher where the grabber is */
	/* WARNING tempdir is trashed after setting up grabber! */
	grabdir = Get_KeyWord_Assignment(TK_SAVESTATE,TK_VIDEODIR);
	if(grabdir > 0)
	{
		strfcpy(tempdir,Get_Token_Identifier(grabdir));
		ind = strlen(tempdir);
		if (tempdir[ind-1] != '\\')
		{
			tempdir[ind++] = '\\' ;
			tempdir[ind] = 0;
		}
	}
	strcpy(tempdir+ind,szGrabberName);
	strfcpy(Switchdata->Grabber_Name,tempdir);
	/* WARNING tempdir may not be correct now! */

	/* tell switcher were primary swap path is */
   get_temp_dir(tempdir,TRUE); /* get TMP= path */
	ind = strlen(tempdir) ;
#ifdef DBCS
	if (tempdir[ind-1] != '\\' || CheckDBCSTailByte(tempdir,&tempdir[ind-1]))
#else
	if (tempdir[ind-1] != '\\')
#endif
   {
		tempdir[ind++] = '\\' ;
	   tempdir[ind] = 0;
	}
	strfcpy(Switchdata->Swap_Path1,tempdir);

	minpath = Get_KeyWord_Assignment(TK_SAVESTATE,TK_RESERVETEMP);
	if(minpath >0) //if user has specified this variable
	{
		minpathident = Get_Token_Identifier(minpath);
		fstrncpy(tempdir,minpathident,12);              
		Switchdata->Min_Path1 = atoi(tempdir);
	}
	else
	{
		/* use up all of primary swap path before reverting to secondary */
		Switchdata->Min_Path1 = 0;
	}
	/* detect CPU */
	Switchdata->CPU_Type = DetectProcessor();
	/* always allow use of all of secondary swap path */
	Switchdata->Min_Path2 = 0;
	Switchdata->SFT_Size = DOS5SFTSIZE;
	if(setorgetscreenmode)
	{
		Switchdata->Num_Lines = StartupNumLines; 
		//return screenmode is correct
	}
	else
	{
		StartupNumLines = Switchdata->Num_Lines; 
		//returnscreenmode needs adjusting
		ReturnScreenMode =  LinesToMode(StartupNumLines);
	}
}

VOID RefreshTaskMan(VOID)
{
		if(gTaskListEnabled)
		{
	//DoRedisplayList(&TaskList);
			InsertListItem(&TaskList,0);
	UpdateListBox(&TaskList);
		}
}


VOID InitTaskMan(WORD top,WORD left,WORD bottom,WORD right)
{
   ListBoxInit(&TaskList,ListProcTaskList,&MainWind,top,left,bottom,right,
																szActiveTaskList,666,0,0);
}

extern WORD gCnx;
extern WORD gScanInfo;
extern WORD GetLastScanCode(void);
/* If the hotkey is handled, then we don't return from this
 * routine at all, but rather go to the appropriate app
 */
extern BOOL gInDialog;
VOID FAR PASCAL HotKeyCheck(WORD message,WORD wParam,DWORD lParam)
{
	Switch_Entry far * SE;
	int numtasks;
	int i;
	WORD scaninfo;
	int wasshell;

	/* if no dialog is popped up, see if hot key was pressed */
	if(gInDialog <= 0)
	{
	scaninfo = GetLastScanCode() & 0xFFF;
		if(gSwitchingEnabled)
		{
			wasshell = 0;
			numtasks = C_GET_LIST_LENGTH(); // zero based, one is shell
			for(i=0;i<=numtasks;i++)
			{
				SE = (Switch_Entry far *) C_GET_ITH(i);
		if(SE->Program_Flags & FSHELL)
				{
					wasshell = 1;
				}
				else
				{
					if( (SE->HK_Shift_State==HIBYTE(scaninfo) ) && 
				(SE->HK_Scan_Code_2 == LOBYTE(scaninfo)) )
					{
						/*user hit hotkey for this app, switch to it! */
						Switch_To_Ith_Task(i-wasshell); 
					}
				}
			}
		}
	}
	InsertKeyboardMessage(message,wParam,lParam);
}

VOID RestartTask(void)
{
	ReInitTaskParams();
	Switch_To_Ith_Task(0);
}

VOID HookISR9(void);

/*
 * FirstInitTaskMan initializes all global task manager variables,
 * Also, it checks for errors from the last switch out, and puts
 * up dialog with appropriate message before continuing on.
 * Finally, In the event the error code indicates that the program
 * had not been run yet, we run that program. This case happens
 * when there are programs with load= set and the user has
 * hot-keyed to that program from within the switcher. 
 */
VOID FirstInitTaskMan(void)
{
	char szErrorMessage[150];
	WORD ec;
	RRC rrcClient;
	

	gAlreadyTasking = RunningUnderMStasker();
   if((!gAlreadyTasking) && (Get_KeyWord_Assignment(TK_SAVESTATE,TK_SWITCHING) == TK_ENABLED))
	{
		gSwitchingEnabled = TRUE;
		gTaskListEnabled = TRUE;
		/* only clear the program list on first initialization if
		 * tasking is set; otherwise we just swapped back to shell
		 */
		if(!GET_WAIT_FLAG())
		{
			/* returnscreenmode is correct from startup */
			C_INIT_PROGRAM_LIST();
			InitGlobalSwitchData(TRUE);
		}
		else
		{
			/* returnscreenmode is not correct, get global */
			InitGlobalSwitchData(FALSE);
		}
		
	}
	else
	{
		/* returnscreenmode is correct from startup */
		gSwitchingEnabled = FALSE;
		gTaskListEnabled = FALSE;
	}
	/* if the last program launch to switcher failed, put up a
	* dialog box saying why.
	*/
	if(gSwitchingEnabled) /* we think switcher is running */
	{
#ifndef NOLOADER
		if (GET_WAIT_FLAG())    /* this is not the first run */
#endif
		{
/*BUG BUG set the contexts? */
			ec = C_GET_EXITCODE();
			if(ec) /* there was an error .... */
			{
			   /* This next means the task was not started before
			* hot-keyed too; we need to start it now. It is already
				 * the first task in the list
				*/
				if((ec>>8) == ER_APP_NOT_STARTED_YET)
				{
					RestartTask();
					//no fall through!              
				}
				C_DELETE_PROGRAM(0);/* take bogus program from list */

				/* We are going to put up an error message dialog box up.
				 * The screen has not been initialized as yet and so, in
				 * graphics mode, if we put up the error dialog and then take
				 * it down, the region behind the dialog will have garbage --
				 * This is soon cleared up but it looks ugly.
				 * So, we, now, clear the screen before putting up the
				 * dialog. Also, we need to initialize the mouse now as it
				 * has not yet been initialized.
				 */
				GetClientRrc(&MainWind,&rrcClient);
				FillRrc(&MainWind,&rrcClient,' ',isaBackground);
				FirstMouseInit();
				FInitMouseNest();
				switch(ec>>8)
				{
					case ER_NO_MEMORY:         
					case ER_NO_LIST_MEMORY: 
					case ER_LOW_MEMORY:        
					ShellMessageBox(szSwitchErrTitle, szSwitchLowMem1);
						break;

					case ER_NO_XMS_DRV:        
					case ER_LOW_XMS_MEM:       
					ShellMessageBox(szSwitchErrTitle, szSwitchLowXMS1);
						break;
					case ER_GRABBER_LOAD:           
						FormStringWithoutPlaceHolders(szErrorMessage,
				szShellFileNotFound, (char far *)szGrabberName);
						ShellMessageBox(szSwitchErrTitle, szErrorMessage);
						break;

					case ER_WND_SWAP_IN:       
					case ER_APP_SWAP_OUT:           
					case ER_APP_SWAP_IN:            

					case ER_EXEC_FAILS:        
						ShellMessageBox(szSwitchErrTitle, szSwitchFailed);
						break;
					case ER_LIST_SWAP:         
					case ER_WND_SWAP_OUT:      
					case ER_RELOCATE:        
					case ER_WINOLDAP_ACTIVE:
					case ER_BAD_INIT_DIR:      
					case ER_COMM_NOLOAD:     
					default:
						ShellMessageBox(szSwitchErrTitle, szSwitchGeneral);
						break;
				}
			}
		}
	}
	HookKeyboardMessage(TRUE,HotKeyCheck);
	HookISR9();
	gfOurISR9Installed = TRUE ; // By default initialized to FALSE!

	/* We must have the TaskList initialized because calls will go to it
	* to determine the number of items in the task list, even when the
	* task list is not on the screen. Here, we just initialize with 
	* some random values -- all we really want to get set is the task lists
	* function pointer!
	*/
   ListBoxInit(&TaskList,ListProcTaskList,&MainWind,0,0,1,1,NullString,666,0,0);
	Halt_Listbox(&TaskList);
	TaskList.hasglobalfocus = FALSE; //WARNING must do this
}

BOOL FAR PASCAL FDlgwarn(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch(dlm) {
	case dlmInit:
	SetUpDialog(tmcOK, szCritWarning);
	SetUpButtonForGraphics(tmcOK);
	SetUpButtonForGraphics(tmcCancel);

	Shell_SetTmcText(tmcwarnline1, szWarnLine1);
	Shell_SetTmcText(tmcwarnline2, szWarnLine2);
	Shell_SetTmcText(tmcwarnline3, szWarnLine3);
	break;

	case dlmSetFocus:
	gCurrentTMC = tmc;
	break;
	}
	return(TRUE);
}

/* WARNING this generates a name created by the dosswap.exe
 * If that code changes this will be incorrect!
 * BUG BUG
 */
VOID MakeSwapName(char *name,BYTE Switcher_Id,WORD Entry_Index)
{
		strcpy(name,"~DOS");
	   if((name[4] = Switcher_Id + '0')> '9')
			name[4]+= 7;
	   name[5] = '0';
	   name[6] = '0';
	   if((name[7] = (char) (Entry_Index + '0'))> '9')
			name[7]+= 7;
	   name[8] = 0;
		strcat(name,".TMP");            
}

extern VOID DeleteBatchFile(void);
extern BOOL InitXMS(void);
extern WORD FreeXMSHandle(WORD handle);

VOID DeleteTask(void)
{

	HCABwarn h;
	Switch_Entry far * SE;
	int numtasks;
	int i;
	int wasshell;
	int delindex;
	char swapfile[67];
	char name[13];
	Switch_Info far * Switchdata;

	if(C_GET_LIST_LENGTH() <= 0) //zero based
	{
		Shell_Beep();
		return;
	}
   h = HcabAlloc(cabiCABwarn);
	if (!h)
	{
		OutOfMemory() ;
		return;
	}
	SzToCab(h, szEnterButton, Iag(CABwarn, pszwarnEB));
	SzToCab(h, szCancelButton, Iag(CABwarn, pszwarnCB));

	szWarnLine1 = szTaskWarnLine1;
	szWarnLine2 = szTaskWarnLine2;
	szWarnLine3 = szTaskWarnLine3;

	if (MyTmcDoDlg(&dlgwarn,  h) == tmcOK)
	{
		wasshell = 0;
		numtasks = C_GET_LIST_LENGTH(); // zero based, one is shell
		for(i=0;i<=(Get_List_Focus(&TaskList));i++)
		{
			SE = (Switch_Entry far *) C_GET_ITH(i);
	 if(SE->Program_Flags & FSHELL)
			{
				wasshell = 1;
			}
		}
	   delindex = Get_List_Focus(&TaskList)+wasshell;
		SE = (Switch_Entry far *) C_GET_ITH(delindex);
		

		Switchdata = C_GET_GLOBAL_SWITCH_DATA();

		/* Kind of hacky here; we need the table index 
	   * of the item to generate the name the dosswap uses
		 * dosswap uses it to ensure unique ids
		*/
		for(i=0;i<MAX_NUM_PROGRAMS;i++)
		{
			if(Switchdata->Program_list[i].Program_Id == SE->Program_Id)
				break;
		}

		strfcpy(swapfile,Switchdata->Swap_Path1); //always ends in '\' !
		MakeSwapName(name,Switchdata->Switcher_Id,i);
	   strcat(swapfile,name);

	  _dos_setfileattr(swapfile, 0); /* Remove any attribs */
		if(unlink(swapfile) != 0)
		{
				strfcpy(swapfile,Switchdata->Swap_Path2); //always ends in '\' !
				MakeSwapName(name,Switchdata->Switcher_Id,i);
			strcat(swapfile,name);
			_dos_setfileattr(swapfile, 0); /* Remove any attribs */
				unlink(swapfile);
		}
		
		C_DELETE_PROGRAM(delindex);
		DeleteBatchFile();
	
	/* update listbox */     
		InsertListItem(&TaskList,0);
		if(C_GET_LIST_LENGTH() <= 0)  //zero based, one is shell
	   {
			/* Delete global XMS handle if allocated */
			if(Switchdata->XMS_Handle)
			{
				if(InitXMS())
					FreeXMSHandle(Switchdata->XMS_Handle);
			}
			
			/* ZZZZ The ListProctaskList() would make sure that the task list
			 * will not have the focus if it has 0 items in the list. see the
			 * tmmCount case of the switch there! The InsertListItem() call
			 * above will make the listbox ask for the count of lbox items.
			 */
			// PrevGlobalFocus();  // go back to applist
	   }
	}

	FreeCab(h);
} 


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\snext.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/****	file snext.c: routines to add/remove 'snext' linkages of files.
**  The operations done are not trivial, as the snext chain behaves differently
**  in different modes. In any case, all files belonging to a tree form one
**  singly linked huge chain. In System Tree Mode, they are linked so that
**  all files are in the appropriate sort order (NAME, DATE, SIZE, etc). In
**  Single/Double Tree Mode, all files belonging to each directory are in the
**  appropriate sort order. The global 'snext' chain is actually a linkage
**  of these smaller 'snext' chains.
**
**  Global snext Chain = dir1 chain-->dir2 chain-->...-->dirn chain-->NULL.
**		where dir1, dir2, ..., dirn are directories in the order shown in the
**	    directory list box.
**
**	Note that DISK order is the mode in which we have the same snext chain
**  in all three tree modes!
**
**	We don't have the luxury of a lot of memory, so we store the bare minimum
**	information along with each node. So when we change tree modes, info
**  like 'snext' may have to be recalculated!!
**
**	A fairly MODULAR approach has been taken towards the snext manipulating
**	routines, so I guess there should be quite some scope for improvement
**	in speed, reducing code size.
/*
**    Date	Name	Modification
**  --------  --------	---------------------------------------------------
**   9/30/89  harikris	wrote all the snext routines.
**	11/??/89  harikris	fixed bugs!
*/

#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>

// Uncomment out this #define if you want consistency checks turned on.
// #define DEBUG 1  

/* Used in fn DoFileOp() to traverse snext chain to perform fileop! */
extern PENTRY gNextFileNode ;


extern PENTRY GetPrevsnextFile(PTREE tree, PENTRY fil) ;
extern PENTRY GetLastsnextFile(PTREE tree) ;

/****	Updatesnext - Functions links 'fil' in the 'snext' chain appropriately.
**
**	ENTRY
**			tree   - tree to which 'fil' belongs
**			parent - parent directory of 'fil'
**			fil    - the file node to be added to the snext chain.
**
**	EXIT
**			'fil' linked up correctly, 'parent' has 'FIRSTFILEFOUND' bit
**			set correctly, 'fil' has 'FIRSTDIRFILE', 'LASTDIRFILE' bits set
**			correctly.
*/
void Updatesnext(PTREE tree, PENTRY parent, PENTRY fil, BOOL fDoSortedInsertion)
{
	/* This routine is not called if we can do SystemSort!! - Merge sort!! */

	/* At start up fil->FIRSTDIRFILE = fil->LASTDIRFILE = FALSE ; */

#ifdef DEBUG
	/* ZZZZZZZZ remove before shipping!!! */
	if ( tree->LastFile && (tree->LastFile->x.f.snext) )
	{
		ShellMessageBox("Non-null LastFile", "Last file non-null\nIn fn Updatesnext") ;
	}
#endif
	if (!parent)
	{
		/* File is part of the root directory, as parent == NULL! 		*/
		/* Now check to see if 'fil' is the first file of the root dir	*/
		/* encountered so far.											*/
		if ( (!tree->FirstFile) || (FindParent(tree->FirstFile)) )
		{
			fil->x.f.snext = tree->FirstFile ;
			tree->FirstFile = fil ;
			fil->FIRSTDIRFILE = fil->LASTDIRFILE = TRUE ;
		}
		else
			/* if we are here => fil is not the first root file */
			snextRootNotFirstUpdate(tree, fil) ;
	}
	else
	{
		/* if we are here => the file is part of some sub-directory */

		/* If asked to do Sorted Insertion or if the directory is already in
		 * sorted order do sorted insertion.
		 */
		if ( (fDoSortedInsertion) || (parent->DIRSORTED) )
		{
			if (!parent->FIRSTFILEFOUND)
				/* 'fil' is the first file encountered of 'parent' so far */
				snextDirFirstUpdate(tree, parent, fil) ;
			else
				/* 'fil' is not the first file of the directory */
				snextDirNotFirstUpdate(tree, parent, fil) ;
		}
		else
		{
			parent->DIRSORTED = FALSE ;

			/* Add this file 'fil' as the last file in the 'snext' chain */
			if (!tree->FirstFile)
			{
				tree->FirstFile = fil ;
			}
			else
			{
				/* Just in case tree->LastFile has not been updated right.
				 * we calculate it again here.
				 */
				if (tree->LastFile->x.f.snext != NULL)
					tree->LastFile = GetLastsnextFile(tree) ;

				(tree->LastFile)->x.f.snext = fil ;
			}

			fil->x.f.snext = NULL ;
		}
	}

	/* Update the field tree->LastFile correctly */
	if (fil->x.f.snext == NULL)
		tree->LastFile = fil ;

} /* fn Updatesnext */

/*** snextRootNotFirstUpdate -- Handles the snext linking when 'fil' belongs
*	to the root directory. It is guaranteed that we have already encountered
*	a file belonging to the root directory. That is, 'fil' is not the first
*	file of root in Disk Order.
***/
void snextRootNotFirstUpdate(PTREE tree, PENTRY fil)
{
	PENTRY prev, curr ;

	prev = tree->FirstFile ;

	/* We know prev is NOT NULL now!! */
	curr = prev->x.f.snext ;

	if (glob.SortKey == SORT_DISK)
	{
		/* go to last file at root level -- All files at root level have
		 * parent == NULL.
		*/
		while (curr && !FindParent(curr)) 
		{
			prev = curr ;
			curr = curr->x.f.snext ;
		}
		prev->LASTDIRFILE = FALSE ;
		fil->LASTDIRFILE = TRUE ;
		fil->x.f.snext = prev->x.f.snext ;
		prev->x.f.snext = fil ;
	} /* SORT_DISK order */
	else 
		/* Handle Non-Disk Order!! */
		InsertNotRootFirst(tree, fil) ;
} /* snextRootNotFirstUpdate */

/*** snextDirFirstUpdate -- Handles the snext linking when 'fil' belongs
*	to a non-root directory (a sub-directory). 'fil' is guaranteed to be
*	the first file of its parent directory 'parent' in Disk Order.
***/
void snextDirFirstUpdate(PTREE tree, PENTRY parent, PENTRY fil)
{
	PENTRY after, prev ;

	parent->FIRSTFILEFOUND = fil->FIRSTDIRFILE = fil->LASTDIRFILE = TRUE ;

	if (!tree->FirstFile)
	{
		tree->FirstFile = fil ;
		fil->x.f.snext = NULL ;
		return ;
	}

	if (glob.TreeMode == TR_SYSTEM)
	{
		/* It is only in DISK_ORDER in SYSTEM tree mode that this code path
		 * will get executed.
		 */

		/* there is atleast 1 file already found in the file system */
		after = parent ;

		/* If we wanted Breadth First Display use fn GetLeftBrother instead 
		 * of fn PrevDFSDir.
		 */
		/* Now, get the directory which has atleast 1 file in it - after whose 
		 * files we need to append this file.
		 */
		while ((after = PrevDFSDir(tree, after)) && 
										!(after->FIRSTFILEFOUND))
			/* Do nothing -- the repeated fn call does the job */ ;

		if (!after)
			/* The root directory is the left brother with files in it */
			prev = GetLastRootFile(tree) ;
		else
			prev = GetLastDirFile(after) ;

	}
	else
		/* Files belonging to root directory are always in sorted order!! */
		prev = GetLastRootFile(tree) ;

	if(!prev)
	{
	    /* This is the new first file in the tree */
	    fil->x.f.snext = tree->FirstFile ;
	    tree->FirstFile = fil;
	}
	else
	{
	    fil->x.f.snext = prev->x.f.snext ;
	    prev->x.f.snext = fil ;
	}
} /* snextDirFirstUpdate */

/*** snextDirNotFirstUpdate -- Handles the snext linking when 'fil' belongs
*	to a non-root directory (a sub-directory). 'fil' is guaranteed NOT to be
*	the first file of its parent directory 'parent' in Disk Order.
***/
void snextDirNotFirstUpdate(PTREE tree, PENTRY parent, PENTRY fil)
{
	PENTRY prev ;

	if (glob.SortKey == SORT_DISK)
	{
		prev = GetLastDirFile(parent) ;
		prev->LASTDIRFILE = FALSE ;
		fil->LASTDIRFILE = TRUE ;
		fil->x.f.snext = prev->x.f.snext ;
		prev->x.f.snext = fil ;
	}
	else
		/* Handle Non-Disk Order */
		InsertNotDirFirst(tree, parent, fil) ;
} /* snextDirNotFirstUpdate */

/*** PrevDFSDir -- Given a directory 'dir' belonging to tree 'tree', it 
*	returns the directory that is the predecessor of 'dir' in DFS order
*	the first file of its parent directory 'parent' in Disk Order -- That
*	is, the directory that will be just above 'dir' in the tree list box!
***/
PENTRY PrevDFSDir(PTREE tree, PENTRY dir)
{
	PENTRY temp ;

	if (dir == tree->FirstDirectory)
		return (NULL) ; /* root is the Prev directory of the first directory */

	for (temp = tree->FirstDirectory ; temp ; temp = temp->x.d.dnext )
		if (temp->x.d.dnext == dir)
			return temp ;

#ifndef NOCONSISTENCY
	/* Actually, if the directory node belongs to this tree, it should
		not execute the following statement */
	printf("*** PrevDFSDir -- directory doesn't belong to this tree\n") ;
	exit(0) ;
#endif
} /* PrevDFSDir */


/* Function returns as its value the prev sibling directory of dir, the
*   prev_dfs directory is passed back by reference
*/
/* ZZZ If we wanted to reduce code size we could have only this function
*  and remove fn PrevDFSDir but pay the price of finding both even though
*  we want only the prev_dfs_dir!!
*/
/* Warning! 'dir' is expected to be a directory in tree other than the ROOT */

PENTRY PrevSibAndDFSDir(PTREE tree, PENTRY dir, PENTRY *prev_dfs_dir)
{
	PENTRY prev_sib_dir ;

	*prev_dfs_dir = NULL ;

	/* ZZZZ this function can be re-structured to have just 1 return */
	if (dir == tree->FirstDirectory)
		return (NULL) ; /* No prev_sib_dir for first directory */

	prev_sib_dir = NULL ;

	for (*prev_dfs_dir = tree->FirstDirectory ; *prev_dfs_dir ;
				 *prev_dfs_dir = (*prev_dfs_dir)->x.d.dnext )
	{

		/* Note: ((*prev_dfs_dir) != dir) will hold in this loop!! */
		if ((*prev_dfs_dir)->dtlx.lx.level == dir->dtlx.lx.level)
		    prev_sib_dir = *prev_dfs_dir ;

		if ((*prev_dfs_dir)->x.d.dnext == dir)
			return prev_sib_dir ;
	 }
#ifndef NOCONSISTENCY
	/* Actually, if the directory node belongs to this tree, it should
		not execute the following statement */
	printf("*** PrevDFSDir -- directory doesn't belong to this tree\n") ;
	exit(0) ;
#endif
} /* PrevDFSDir */

PENTRY HandleDeletednext(PTREE tree, PENTRY deldir)
{
	PENTRY prev_sib_dir, prev_dfs_dir ;

    /* ZZZZ We have the routine to find PrevDFS dir, but we need
       to know both the prev_dfs and prev_sib directories here.
       Both these can be done in 1 pass, so I have a new routine */
    prev_sib_dir = PrevSibAndDFSDir(tree, deldir, &prev_dfs_dir) ;

    if (prev_sib_dir)
    {
		prev_sib_dir->LASTDIR = deldir->LASTDIR ;
    }
    if (prev_dfs_dir)
    {
		prev_dfs_dir->x.d.dnext = deldir->x.d.dnext ;
    }
    else
    {
		/* root was it's prev DFS directory */
		tree->FirstDirectory = deldir->x.d.dnext ;
    }

	 return prev_dfs_dir ;

} /* HandleDeletednext */

/*** GetLastDirFile -- Given a directory 'dir' (not the root), it returns
*	the last file belonging to that directory in appropriate Sort Order.
***/
PENTRY GetLastDirFile(PENTRY dir)
{
	PENTRY temp ;

	if (!dir->FIRSTFILEFOUND)
		return NULL ;

	/* We know that there is at least 1 file, so temp can't be NULL at all */
	for (temp = dir->x.d.child ; 
			(temp->attribs & _A_SUBDIR) || (!temp->LASTDIRFILE) ;
				temp = temp->sibling )
		/* Do nothing */ ;

	return temp ;
} /* GetLastDirFile */

/*** GetFirstDirFile -- Given a directory 'dir' (not the root), it returns
*	the first file belonging to that directory in appropriate Sort Order.
*	Note that there is very little difference between this fn & prev one!
***/
PENTRY GetFirstDirFile(PENTRY dir)
{
	PENTRY temp ;

	if (!dir->FIRSTFILEFOUND)
		return NULL ;

	/* We know that there is at least 1 file, so temp can't be NULL at all */
	for (temp = dir->x.d.child ; 
			(temp->attribs & _A_SUBDIR) || (!temp->FIRSTDIRFILE) ;
				temp = temp->sibling )
		/* Do nothing */ ;

	return temp ;
} /* GetFirstDirFile */

/*** GetLastRootFile --   Get the last file belonging to the root directory
* 	of 'tree'.
***/
PENTRY GetLastRootFile(PTREE tree)
{
	PENTRY temp ;

	/* Files belonging to root have NULL as their parent */
	if ( (!tree->FirstFile) || FindParent(tree->FirstFile) )
		return NULL ;

	for (temp = tree->FirstFile ; !(temp->LASTDIRFILE) ; temp = temp->x.f.snext)
		/* Do Nothing */ ;

	return temp ;
} /* GetLastRootFile */

/*** GetFirstRootFile --   Get the first file belonging to the root directory
* 	of 'tree'.
***/
PENTRY GetFirstRootFile(PTREE tree)
{
	return (FindParent(tree->FirstFile) ? NULL : tree->FirstFile) ;
}

/*** InsertSystemOrder -- Inserts file 'fil' in the chain in appropriate
*	location based on Sort Order. The tree is in System Tree Mode.	
* The fields FIRSTFILEFOUND, FIRSTDIRFILE, LASTDIRFILE are meaningless in 
*	system mode display -- So they are not updated in this function.	
* 
***/
void InsertSystemOrder(PTREE tree, PENTRY fil)
{
	PENTRY prev, curr ;

	if (!tree->FirstFile)
	{
		tree->FirstFile = fil ;
		fil->x.f.snext = NULL ;
		return ;
	}

#ifndef NOCONSISTENCY
	if (glob.SortKey == SORT_DISK)
		 /* This fn should not be called for Disk Sorting order -- that should
			be done by FormDirectoryOrder and then normal Updatesnext */
	{
		printf("*** BUG! InsertSystemOrder called with SORT_DISK\n") ;
		exit(0) ;
	}
#endif

	prev = NULL ;
	curr = tree->FirstFile ;

	while (curr && ((*SortCmp)(fil, curr) > 0))
	{
		/* 'fil' should not be before 'curr'in the system list */
		prev = curr ;
		curr = curr->x.f.snext ;
	}

	if (!prev)
	{
		/* this file should be the new tree->FirstFile as 
			it is <= tree->FirstFile */
		fil->x.f.snext = tree->FirstFile ;
		tree->FirstFile = fil ;
	}
	else
	{
		/* prev != Null and file goes after prev in the list */
		fil->x.f.snext = prev->x.f.snext ;
		prev->x.f.snext = fil ;
	}

	/* Update this field correctly */
	if (fil->x.f.snext == NULL)
		tree->LastFile = fil ;
} /* InsertSystemOrder */

/*** InsertNotRootFirst -- Inserts file 'fil' in the chain in appropriate
*	location based on Sort Order. The tree is in NON-System Tree Mode.	
*	'fil' is known to be part of the ROOT directory and is NOT its first
*	file in Disk Order.
***/
void InsertNotRootFirst( PTREE tree, PENTRY fil)
{
	PENTRY prev ;

	prev = tree->FirstFile ;

	if ((*SortCmp)(fil, prev) < 1)
	{
		/* 'fil' is now tree's new first file as it goes before 'prev' */
		fil->FIRSTDIRFILE = TRUE ;
		prev->FIRSTDIRFILE = FALSE ;
		fil->x.f.snext = prev ;
		tree->FirstFile = fil ;
	}
	else
		InsertAfter(fil, prev) ;
} /* InsertNotRootFirst */

/*** InsertNotDirFirst -- Inserts file 'fil' in the chain in appropriate
*	location based on Sort Order. The tree is in NON-System Tree Mode.	
*	'fil' is known to be part of a NON-ROOT directory and is NOT its first
*	file in Disk Order.
***/
void InsertNotDirFirst(PTREE tree, PENTRY parent, PENTRY fil)
{
	PENTRY firstparentfile ;
	PENTRY prevfile ;

	firstparentfile = GetFirstDirFile(parent) ;

	/* Note that "firstparentfile" is guaranteed to be non-NULL as 'fil'
	 *	is not the first file to be added to directory 'parent'
	 */
#ifdef DEBUG
	/* ZZZZZZZZZ Delete before shipping */
	/* ZZZZZZZZ remove before shipping!!! */
	if ( !firstparentfile )
	{
		ShellMessageBox("No file in parent dir", "to insert in front of.\nIn fn InsertNotDirFirst") ;
	}
#endif
	/* Is 'fil' to be added, to be inserted before the first file currently
	 * in 'dir'?
	 */
	if ((*SortCmp)(fil, firstparentfile) < 1)
	{
		fil->FIRSTDIRFILE = TRUE ;
		firstparentfile->FIRSTDIRFILE = FALSE ;

		prevfile = GetPrevsnextFile(tree, firstparentfile) ;
		if (!prevfile)
		{
			tree->FirstFile = fil ;
			fil->x.f.snext = firstparentfile ;
		}
		else
		{
			prevfile->x.f.snext = fil ;
			fil->x.f.snext = firstparentfile ;
		}
	}
	else
		/*  'fil' does not go before 'firstparentfile'. */
		InsertAfter(fil, firstparentfile) ;
} /* InsertNotDirFirst */

/*** InsertAfter -- Inserts file 'fil' in the chain in appropriate
*	location based on Sort Order. It doesn't matter if tree is in System Tree
*	mode or not. It is guaranteed that 'prev' <= 'fil' based on the sort order
*	and so 'fil' goes AFTER (not necessarily immediately after) 'prev' in
*	the 'snext' chain.
***/
void InsertAfter(PENTRY fil, PENTRY prev)
{
	struct fi_t far *thenext;
	/* loop until we find the file ('prev') after which 'fil' goes */

	while (!prev->LASTDIRFILE)
	{
		if ((*SortCmp)(fil, thenext=prev->x.f.snext) > 0)
				prev = thenext;
		else
			break ;
	}
	if (prev->LASTDIRFILE)
	{
		prev->LASTDIRFILE = FALSE ;
		fil->LASTDIRFILE = TRUE ;
	}
	fil->x.f.snext = prev->x.f.snext ;
	prev->x.f.snext = fil ;
} /* InsertAfter */

/*** UpdateLatesnext -- Routine called when a new file is added by a fileop.
*	Similar to Updatesnext for non-disk order, system order. For disk
*	order, 'prev' is the file before 'fil' in 'parent' directory. If 'prev'
*	is NULL, 'fil' is the first file in this directory. This routine will be
*	called during file opearations like COPY, etc.
***/
void UpdateLatesnext(PTREE tree, PENTRY parent, PENTRY fil, PENTRY prev,
																BOOL fDoSortedInsertion)
{
#ifdef DEBUG
	/* ZZZZZZZZ remove before shipping!!! */
	if ( tree->LastFile && (tree->LastFile->x.f.snext) )
	{
		ShellMessageBox("Non-null LastFile", "Last file non-null\nIn fn UpdateLatesnext") ;
	}
#endif
	fil->FIRSTDIRFILE = fil->LASTDIRFILE = FALSE ; /* default state */

	fil->DELMARKER = FALSE ; /* default state */

	if ( (glob.TreeMode == TR_SYSTEM) && (glob.SortKey != SORT_DISK) )
		InsertSystemOrder(tree, fil) ;
	else
	{
		/* Files have to be in directory order -- Files within each
			directory are to be sorted by appropriate SortKey */
		if (glob.SortKey != SORT_DISK)
		{
			/* Only DISK_ORDER can screw us up, as this file could be in
				any random order in the disk in this directory, else
				old insertions are fine. */
			Updatesnext(tree, parent, fil, fDoSortedInsertion) ;
		}
		else
		{
			/* Handle complex case of Inserting in disk order */
			if (prev)
			{
				/* there is a file in this directory which occurs before
					'fil' in disk order -- easy case to handle */
				fil->x.f.snext = prev->x.f.snext ;
				prev->x.f.snext = fil ;
				if (prev->LASTDIRFILE)
				{
					prev->LASTDIRFILE = FALSE ;
					fil->LASTDIRFILE = TRUE ;
				}
			}
			else
			{
				/* (prev == NULL) -- complex case */
				if (!parent)
				{
					/* This implies that this is a file in the root directory */
					/* Hence, it is the first file on the disk */
					fil->x.f.snext = tree->FirstFile ;
					tree->FirstFile = fil ;
				} /* !parent -- i.e, case when 'fil' is part of root */
				else
					/* file is part of a non-root directory */
					snextDirFirstUpdate(tree, parent, fil) ;

				/* This is the first file in Disk Order in the directory */
				fil->FIRSTDIRFILE = TRUE ;

				/* If there is no file after 'fil' or if file following it	*/
				/*	is not a part of parent, 'fil' is LASTDIRFILE else		*/
				/*	not so. Reset the subsequent file's first dir file		*/
				/*	if it belongs to parent.								*/

				if (!fil->x.f.snext) 
					fil->LASTDIRFILE = TRUE ;
				else
				{
					if ( FindParent(fil->x.f.snext) != parent )
						fil->LASTDIRFILE = TRUE ;
					else
					{
						/* We need to set fil->LASTDIRFILE to false, because
						   snextDirFirstUpdate fn call above, as a side-effect
						   sets the LASTDIRFILE bit to TRUE always */
						fil->LASTDIRFILE = FALSE ;

						fil->x.f.snext->FIRSTDIRFILE = FALSE ;
					}
				}
			} /* complex case -- prev == NULL */
		} /* SortKey == SORT_DISK handled */
	} /* Non System Mode or DISK_ORDER updates */

	/* Update this field right! */
	if ( (!tree->LastFile) || (tree->LastFile->x.f.snext != NULL) )
		tree->LastFile = GetLastsnextFile(tree) ;

} /* proc UpdateLatesnext */

/* node is the file node to be deleted, 'parent' is its parent directory
	and it belongs to tree 'tree'.	*/
void HandleDeletesnext(PTREE tree, PENTRY parent, PENTRY node)
{
	PENTRY prev ;
	BOOL fLastFileBeingDeleted ;
	BOOL fNextFileNodeBeingDeleted ;

#ifdef DEBUG
	/* ZZZZZZZZ remove before shipping!!! */
	if ( tree->LastFile && (tree->LastFile->x.f.snext) )
	{
		ShellMessageBox("Non-null LastFile", "Last file non-null\nIn fn HandleDeletesnext") ;
	}
#endif
	fNextFileNodeBeingDeleted = (node == gNextFileNode) ;
	fLastFileBeingDeleted = (node->x.f.snext == NULL) ;

	prev = tree->FirstFile;
	if (prev == node)
	{
		/* We are deleting the first file of the tree -- easy case! */
		tree->FirstFile = node->x.f.snext;
	} else
	{
		while (prev->x.f.snext != node)
			prev = prev->x.f.snext;
		prev->x.f.snext = node->x.f.snext;
	}

	if (fLastFileBeingDeleted)
	{
		if (!tree->FirstFile)
			tree->LastFile = NULL ;
		else
			tree->LastFile = prev ;
	}

	/* If "gNextFileNode" has just been deleted, we need to update it
	 * appropriately as this is the next node that fn DoFileOp() will use
	 * to perform file operation on next.
	 */
	if (fNextFileNodeBeingDeleted)
	{
		gNextFileNode = node->x.f.snext ;
	}

	/* If treemode is the system mode, we need to only update the
		snext linked list which has just been done. So return */
	if (glob.TreeMode == TR_SYSTEM)
		return ;

#ifdef DEBUG
	/* ZZZZZZZ Remove this assertion before shipping */
if (!parent && tree->SortRequired)
{
	ShellMessageBox("FM CONFUSED!!!", "Please exit FM right away\nReport this message to harikris\nROOT dir un-sorted!!") ;
	DoExit() ;
}
#endif

	/* If "parent" is not sorted, we don't have to update any special bits
	 * These bits will be taken care of when this directory is sorted.
	 */
	if (parent && (!parent->DIRSORTED))
	{
		return ;
	}

	/* Note that ROOT (parent == NULL) is always maintained in sorted order */

	/* In non-system tree mode, the 3 bits FIRSTFILEFOUND, FIRSTDIRFILE,
		LASTDIRFILE need to set appropriately */
	/* fix the 'FIRSTFILEFOUND', 'FIRSTDIRFILE', 'LASTDIRFILE' */
	if (node->LASTDIRFILE) 
	{
		if ( (node->FIRSTDIRFILE) && parent )
		{
			/* node is the only file of 'parent' and is being deleted*/
			parent->FIRSTFILEFOUND = FALSE ;
		}
		else
		{
				/* 'node' has a prev file in the same directory as itself. Since
				node was the lastfile in parent, 'prev' takes its place now. */
				prev->LASTDIRFILE = TRUE ;
		}
	}
	else /* node is not the lastfile in 'parent' -- implies there is a file
		after it in 'parent' -- implies node->x.f.snext != NULL */
	{
		if ( node->FIRSTDIRFILE )
			node->x.f.snext->FIRSTDIRFILE = TRUE ;
	}

} /* proc HandleDeletesnext */

#define MAXNESTING 32  /* Max directory nesting */

/* MarkLastDir --															*/
/* Function marks the LASTDIR bit for all dir nodes belonging to tree 		*/
/* This bit is used to draw the tree list box correctly!! I personally like */
/* this algorithm very much -- it is linear in time (on number of dirs)		*/
/* and simulates the kind of recursion needed, using a local stack!			*/
void Marklastdir(PTREE tree)
{
	int stacktop ; 
	PENTRY node ;
	fileinfo dummy ;  /* dummy fileinfo node */
	PENTRY DStack[MAXNESTING+1] ; /* 0 -- used for root. Directory node stack */

	dummy.dtlx.lx.level = 0 ; /* level is the only field we are interested in */
	/* Initialize stack with a dummy node for root dir */
	DStack[stacktop = 0] = &dummy ; 
	
	/* Claim: Following algorithm marks all directory nodes correctly.
	*  Main reason: Every directory node gets on the stack once and any
	*				entry in stack is marked.
	*/
	for ( node = tree->FirstDirectory ; node ; node = node->x.d.dnext )
	{
		if ( node->dtlx.lx.level > DStack[stacktop]->dtlx.lx.level )
		{
			DStack[++stacktop] = node ;  /* push onto stack */
		}
		else
		if ( node->dtlx.lx.level == DStack[stacktop]->dtlx.lx.level )
		{
			/* the replaced node is not the LASTDIR  node */
			DStack[stacktop]->LASTDIR = FALSE ;
			DStack[stacktop] = node ; /* replace top of stack */
		}
		else
		{
			/* we have to mark off all nodes in stack with level > node's level
			   as being last dir nodes. Note that there has to be a node on
			   the stack which has the same level as node. Node should
			   replace that node. It's true -- think about it!!*/
			while (DStack[stacktop]->dtlx.lx.level > node->dtlx.lx.level)
			{
				DStack[stacktop--]->LASTDIR = TRUE ;
			}
			DStack[stacktop]->LASTDIR = FALSE ;
			DStack[stacktop] = node ; /* replace current stacktop */
		}
	} /* for loop */

	/* Now all nodes on top of stack are LASTDIR nodes */
	while (stacktop)
	{
		DStack[stacktop--]->LASTDIR = TRUE ;
	}

} /* Marklastdir */

/* Inserts directory 'newdir' in sorted order in 'dnext' chain as a sub-dir
 * of parent. It also updates all the LASTDIR bits of the sub directories
 * of 'parent' so that they are displayed right on the screen.
 */
void InsertDirAndMarkLastDirBits(PTREE tree, PENTRY parent, PENTRY newdir)
{
	PENTRY tempdir, nextdir ;

	InsertDir(tree, parent, newdir) ;

	tempdir = (!parent) ? tree->FirstDirectory : parent->x.d.dnext ;

	/* Note that we should always be able to find 'newdir' in the chain now */
	while (tempdir != newdir)
	{
#ifdef DEBUG
		/* ZZZZZ Safety feature -- Delete before shipping! */
		if (!tempdir)
		{
			ShellMessageBox("InsertDirAndMarkLastDirBits", "dnext chain broken!!\nnewly created dir not found!\nIn fn CreateDirectory") ;
			break ;
		}
#endif
		if (tempdir->dtlx.lx.level == newdir->dtlx.lx.level)
			tempdir->LASTDIR = FALSE ;
		
		tempdir = tempdir->x.d.dnext ;
	}

	nextdir = newdir->x.d.dnext ;
	/* Is there no directory after 'newdir' or is that directory not
	 * part of 'parent', i.e., is it at a different level. In that
	 * case 'newdir' is the LASTDIR of its parent when being displayed.
	 */
	newdir->LASTDIR = (!nextdir) ||
								(nextdir->dtlx.lx.level != newdir->dtlx.lx.level) ;
		
} /* InsertDirAndMarkLAstDirBits */

#ifdef DONT_DO_ANY_INSERTION_SORT
/*** HasNoSubDir -- Returns a BOOL as to whether the directory 'parent' has
*	any sub directories.
*/
BOOL HasNoSubDir(PTREE tree, PENTRY parent)
{
    PENTRY temp ;

    if (!parent)
    {
	return (tree->FirstDirectory ? FALSE : TRUE ) ;
    }

    /* => parent is not the root directory */
    for (temp = parent->x.d.dnext ; temp ; temp = temp->x.d.dnext)
    {

	if (temp->dtlx.lx.level == parent->dtlx.lx.level+1)
	    /* sub-dir of parent found as its level is one more */
	    return FALSE ;

	if (temp->dtlx.lx.level == parent->dtlx.lx.level)
	     /* we have seen a sibling directory without seeing a sub-dir */
	    break ; /* => no sub-dir */
    }

    return TRUE ; /* No sub-dirs in parent */
} /* HasNoSubDir */

#endif
/* This function retrieves the file that is the TAIL of the 'snext' chain */
PENTRY GetLastsnextFile(PTREE tree)
{
	PENTRY fil;

	if ((fil = tree->FirstFile) == NULL)
		return NULL ;

	/* fil is guaranteed to be non-null now! */
	while(fil->x.f.snext != NULL)
	{
		fil = fil->x.f.snext ;
	}

	return fil ;

} /* GetLastsnextFile */


/* This function returns the file node that is just in front of "fil" in
 * the 'snext' chain.
 */
PENTRY GetPrevsnextFile(PTREE tree, PENTRY fil)
{
	PENTRY temp ;

	if ( (!(temp = tree->FirstFile)) || (temp == fil) )
		return NULL ;

	/* 'temp' is guaranteed to be non-NULL when we do this check! */
	while (temp->x.f.snext != fil)
	{
		temp = temp->x.f.snext ;
		if (!temp)
			break ;
	}

	return temp ;

} /* GetPrevsnextFile */

/* This function deletes all files belonging to directory 'dir' from the
 * snext chain.
 */
void DeleteFilesFromsnextChain(PTREE tree, PENTRY dir)
{
	PENTRY node ;
	PENTRY prev, fil ;

	/* First mark all files belonging to 'dir' as deleted */
	node = (dir) ? dir->x.d.child : tree->head;
	while(node)
	{
		if (!(node->attribs & _A_SUBDIR))
			node->DELMARKER = TRUE ;

		node = (node->nosib) ? NULL : node->sibling ;
	} /* while */

	/* Now delete all marked files from snext chain -- can be done in 1 pass */
	fil = tree->FirstFile ;
	prev = NULL ; 
	while (fil)
	{
		if (fil->DELMARKER)
		{
			// clear the foll. bit and leave in default state
			fil->DELMARKER = FALSE ; 

			if (prev)
				prev->x.f.snext = fil->x.f.snext;
			else
				/* tree->FirstFile == fil */
				tree->FirstFile = fil->x.f.snext ;
		}
		else
			prev = (prev == NULL) ? tree->FirstFile : prev->x.f.snext ;

		fil = (prev == NULL) ? tree->FirstFile : prev->x.f.snext ;
	} /* while */

	/* Mark 'dir' as having no files */
	if (dir)
		dir->FIRSTFILEFOUND = FALSE ;

	tree->LastFile = GetLastsnextFile(tree) ;

} /* DeleteFilesFromsnextChain */


#if 0
/* fn is not used anymore! -- Could be pretty useful!! */
PENTRY GetLeftBrother(PTREE tree, PENTRY dir)
{
	PENTRY lbr, temp ;

	lbr = NULL ;

	for (temp = tree->FirstDirectory ; temp && (temp != dir) ;
											temp = temp->x.d.dnext ) 
		if (temp->dtlx.lx.level <= dir->dtlx.lx.level)
					lbr = temp ;

	return lbr ;

} /* GetLeftBrother */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\swapdisk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

?WIN = 0                ;Not windows;
?PLM =	  1		;DO use PL/M calling conventions

include cmacros.inc

; Following are C-fns that use CW to put up/take down swap message
extrn	PutUpSwapMsg:far
extrn	TakeDownSwapMsg:far

ifdef	KANJI

extrn	PeekMessage:far
extrn	HookKeyboardMessage:far
extrn	InsertKeyboardMessage:far

extrn	msg:word

;*
;*	CW : Character Windows
;*
;*	cwindows.inc : public include file for CW routines/structures
; Created Mon Feb 18 00:10:50 1991 */ 

pwndMsg		equ	[word ptr 00000h]
messageMsg	equ	[word ptr 00002h]
wParamMsg	equ	[word ptr 00004h]
lParamMsg	equ	[dword ptr 00006h]
LO_lParamMsg	equ	[word ptr 00006h]
HI_lParamMsg	equ	[word ptr 00008h]
timeMsg		equ	[dword ptr 0000Ah]
LO_timeMsg		equ	[word ptr 0000Ah]
HI_timeMsg		equ	[word ptr 0000Ch]

WM_CHAR		equ	258
WM_LBUTTONDOWN	equ	513
WM_LBUTTONUP	equ	514
WM_LBUTTONDBLCLK	equ	515
WM_RBUTTONDOWN	equ	516
WM_RBUTTONUP	equ	517
WM_RBUTTONDBLCLK	equ	518

endif

; Pointers to our near buffer -- multiplexed -- used in C & for temp stack here
extrn	pbBuffer:near
extrn	pbBufferEnd:near


STACKREQ EQU 512		; Stack size requested so that we can make C-calls from
						; the int 2f handler and not worry about stack overflows

sBegin	data
	OldSP			DW	?
	OldSS			DW	?
sEnd	data

sBegin code
    assumes cs, code
    assumes ds, DGROUP

OldInt2fVector	DD	 ?			; Location to store old int 2f vector

;
;
;
int2fswaphandler	proc
	cmp		ax, 4A00h		; Is this a swap disk call?
	je		DoDialog

ChainThru:
	jmp		[OldInt2fVector]

DoDialog:
	or		cx, cx			; Has any one already interacted with user?
	jnz		ChainThru		; YES, Some one else has handled it!

	sti						; BUGBUG -- can I be restore interrupts now? - hari

	;; Try to switch stacks by checking if we have a big enuf stack
	push	bx
	push	es
	push	ds
	mov		ax, DGROUP
	mov		ds, ax
	assumes	ds, DGROUP
	mov		es, ax		; for safety make ES = DS

	mov		ax, word ptr pbBufferEnd	; AX = ptr to last char of our near buf
	mov		bx, word ptr pbBuffer		; BX = ptr to free loc of near buffer
	add		bx, (STACKREQ-1)			; We might need all of STACKREQ bytes!
	cmp		ax, bx						; Is this stack big enuf?

	jb 		NoMessage					; NO, We can't handle swap msg as C-fn
										; call later might need big stack!

	dec		cx							; Mark that we handled swap message!!

	;;;; Put up message to swap disks -- a C-function call to be made!

	; Save all registers, as C-fn call will screw them up!
	; Note that BX, ES, DS have already been saved!!	
	push	cx
	push	dx
	push	bp
	push	si
	push	di

	mov		OldSP,	sp	; Store old stack ptr (SS:SP) in our temp location
	mov		OldSS,	ss

	push	ds			; Perform stack switch
	pop		ss
    mov		sp, ax		; SS:SP points to our near stack now!

	;;;; Push in parameter to the C-fn call below
	push	dx		; DH has drive letter for disk in drive
					; DL has requested drive letter 0 for A, 1 for B, etc

	call	far ptr PutUpSwapMsg	; C-fn call! PLM calling convention

	; flush all characters from keyboard queue

ifdef	KANJI
	push	bx			; save
	mov	ax,1			; TRUE
	lea	bx,KeyboardHook		;
	cCall	HookKeyboardMessage,<ax,cs,bx>	; Hook keyboard input

WaitKeyInput:
	lea	ax,msg			;
	push	ax			; save
	cCall	PeekMessage,<ax>	; get key
	pop	bx			; restore
	or	ax,ax			;
	jz	WaitKeyInput		; key input, FALSE

	mov	ax,[bx].messageMsg	;
	cmp	ax,WM_CHAR		; charactor input ?
	jz	KeyIn			; yes
	cmp	ax,WM_LBUTTONDOWN	; mouse L button ?
	jz	KeyIn			; yes
	cmp	ax,WM_RBUTTONDOWN	; mouse R button ?
	jnz	WaitKeyInput		; no
KeyIn:
	xor	ax,ax			; FALSE
	lea	bx,KeyboardHook		;
	cCall	HookKeyboardMessage,<ax,cs,bx>	; Unhook keyboard input
	pop	bx			;
else

FlushKbdLoop:
	mov	ah,1			; command code for check status
	int	16h				; Is there a char in the key board buffer?
	jz	FlushDone		; No, Flush complete

	xor	ah,ah			; Remove the character from Keyboard buffer
	int	16h				; Get char
	jmp	FlushKbdLoop

FlushDone:
	; Wait till user hits any key -- He is expected to do this after
	; the floppy for the new drive is in place.
	xor	ah,ah				; set command to read character
	int	16h					; Wait  until a key board char hit
endif

	;;;; Take down swap disk message and restore screen -- a C-function
	call	far	ptr	TakeDownSwapMsg	; C-fn call
	
	mov		ss,	OldSS		; Restore DOS' old stack ptr
	mov		sp,	OldSP

	;;;; Restore all registers now
	pop		di
	pop		si
	pop		bp
	pop		dx
	pop		cx

NoMessage:
	pop		ds
	pop		es
	pop		bx

	mov		ax, 4A00h		; Restore original function value to chain thru
	jmp		[OldInt2fVector];

int2fswaphandler	endp


;
; void InstallSwapHandler(void)
;
cProc  InstallSwapHandler, PUBLIC,  <si,di,ds,es>
cBegin	InstallSwapHandler

	mov		ax, 352fh		; Get current contents of
	int		21h				; int 2f vector in ES:BX

	; Save this vector so that we can restore it when our program terminates
	mov		word ptr OldInt2fVector, bx
	mov		word ptr OldInt2fVector+2, es

	; Set our int 2f handler in place
	mov		dx, offset int2fswaphandler
	push	cs
	pop		ds				; DS:DX = address of our int 2f handler
	assumes	ds, nothing

	mov		ax, 252fh		; Set new int 2f vector 
	int		21h				; that is, the one in DS:DX

cEnd	InstallSwapHandler

;
; void RemoveSwapHandler(void)
;
cProc  RemoveSwapHandler, PUBLIC,  <si,di,ds,es>
cBegin	RemoveSwapHandler
		lds		dx, OldInt2fVector
		assumes	ds, nothing

		mov		ax, 252fh
		int		21h							; Restore old int 2f handler
cEnd	RemoveSwapHandler

ifdef	KANJI
cProc	KeyboardHook,FAR,PUBLIC,<ax>
	parmW	message
	parmW	wParam
	parmD	lParam

cBegin
	mov	ax,WM_CHAR		; convert to space code
	mov	message,ax		;
	mov	ax,' '			;
	mov	wParam,ax		;
	cCall	InsertKeyBoardMessage,<message, wParam, lParam>
cEnd	KeyboardHook
endif
sEnd   code

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\utils.c ===
/* Revision history since 5.0 Golden:
 *
/* M010 SHK	08/13/91	Modified this function to support user control of the
 * 						primary swap path thru the INI file/DOSSHELL environment
 *							variable.
 *
 * M011 SHK	07/31/91	Modified fns FDlgmswarn() and WarnMouseIsOld()
 *							to put up our new mouse compatibility message.
 *
 *	M013 SHK 10/02/91 If mouse version number is unknown, we print appr. msg.
 *
 */

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* harikris: created Sep. 25, '89                       */
/* Added function pmatch - Sep. 26 '89                  */
#include <common.h>
#include <filemgr.h>
#include <menus.h>
#include <prot.h>
#include <text.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>
#include <message.hs>
#include <message.sdm>
#include <about.hs>
#include <about.sdm>
#include <mswarn.hs>
#include <mswarn.sdm>

extern BOOL gfRepaintonidle;
extern char gStartUpDir[] ;
extern int gStartUpDirEnd ;


extern BOOL fgSymbolTableModified ;
extern BOOL fNoEffectiveChange(void) ;
extern void FreeFMMemory(void) ;

#ifdef KANJI
extern char szmHelpShellAbout[] ;
#endif

void strfcpy(char far *dst, char far *src)
{
	for ( ; *src ; )
		*(dst++) = *(src++) ;
	
	*dst = '\0' ;
}

void strfncpy(char far *dst, char far *src, unsigned cnt)
{
	/* Assumption is that cnt is not negative */
	for ( ;  cnt ; cnt-- )
		*(dst++) = *(src++) ;
}

/****************************************************************/
/* INPUT :                                                                                                              */
/* 'pat' is a null terminated pattern possibly having the meta  */
/*      characters '?' and '*'.                                                                         */
/* 'mode' indicates whether to match extensions or name + extension*/
/* 'str' is the name/extension of file to be matched.                   */
/*      It is null terminated or not depending on its length -- see */
/*      the data structure associated with each file in our tree        */
/* OUTPUT:                                                                                                              */
/*      TRUE on succesful match, else FALSE                                                     */
/****************************************************************/
BOOL pmatch(char far *pat, char far *str, BYTE mode)
{
	int i ;
	char far *ext_start ;

	if (mode == FULLNAME)
	{
		i = NAMELEN ;
		ext_start = str + NAMELEN ;
	}
	else
		i = EXTLEN ;

	/* loop as many times as the lengths or until match over */
	for (; (*pat != '*') && i ; i-- )
	{
		switch (*pat) {

		case '?' :
			/* '?' matches a null character too -- so don't advance our
				string only if *str is non-null. We have only one NULL character
				in string if at all any */
			if (*str)
				str++ ;
			pat++ ;
			break ;

		case '.' :
			if (mode == EXTENSION) 
				/* ZZZZ Actually we shouldn't have a '.' in pattern to match
				extensions -- ill-formed pattern but we ignore it and say
				that the pattern matches the string!!! */
				return(TRUE) ;
			else
			{
				/* The '.' is treated as "*." if it is the first character in
					the pattern. */
				if ((i == NAMELEN) || (!*str))
					return(pmatch(pat+1, ext_start, EXTENSION)) ;
				else
					return(FALSE) ;
			}       

		case NULL :
			/* NULL character in pattern -- only matches null in string */
			return (!*str) ;

		default :
#ifdef DBCS
			if (IsDBCSLeadByte(*pat) || IsDBCSLeadByte(*str))
			{
				if (*(pat++) != *(str++) || *(pat++) != *(str++))
					return (FALSE);
			}
			else
#endif
			if (toupper(*pat) != toupper(*str))
				return (FALSE) ;
			else 
			{
				pat++ ; str++  ;
			}
		} /* switch */
	} /* for */

	/* if we are here pattern has been succesfully matched so far */
	if (mode == EXTENSION)
		return(TRUE) ;

	/* else skip forward in pattern until EOS or until '.' and then
		match extensions.                                                                                       */
	while (*pat)
	{
		if (*(pat++) == '.')
			return (pmatch(pat, ext_start, EXTENSION)) ;
	}
	return (TRUE) ;
}


VOID get_comspec(char *buffer)
{
   char *envptr;

   envptr = getenv(szComSpec);
   if(envptr)
	 strcpy(buffer,envptr);
   else
   /* BUGBUG can this ever happen?
   */
	buffer[0] = 0;
}

/* Function verifies whether full path name specified by "path" is a valid
 * directory that we can use to create some temp files fast!! So, we don't
 * want to use floppies ('A', 'B'). If it is some other drive, we make sure
 * that the path exists. This routine should NOT change directories as
 * the caller has set up the directory right to do a launch of a program, etc.
 */
BOOL VerifyTempPath(char *path)
{
	char uppercasedrive ;
	unsigned attribs ;
	char TrueName[128] ;
	int result ;
	int temp ;

	BOOL ret = TRUE ;

	uppercasedrive = (char) toupper(*path) ;

	/* We don't want floppies to be our temp paths */
	if (getdrivetype(uppercasedrive - 'A' + 1) == FLOPPY_TYPE)
		ret = FALSE;
	else
	{
		/* If we can't get the attributes of the path, it doesn't exist! */
		if ( (result = _dos_getfileattr(path, &attribs)) != 0 )
		{
			/* Is parent the ROOT dir? If so, _dos_getfileattr call
			 * fails on networks like NOVELL! The root is always a
			 * valid directory! Note that if path E:\  or some such stuff
			 * was specified and drive E: were invalid result will not
			 * be ENOENT!
			 */
			temp = strlen(path) ;
#ifdef DBCS
			if ((result == ENOENT) && (temp == 3) && (path[temp-1] == PATHCHAR) && !CheckDBCSTailByte(path,&path[temp-1]))
#else
			if ((result == ENOENT) && (temp == 3) && (path[temp-1] == PATHCHAR))
#endif
			{
				ret = TRUE ;
			}
			else
			{
				ret = FALSE ;
			}
		}
		else
		{
			/* ZZZZZZZZZZZZZ */
			/* path exists, but for root directory DOS screws up on get_attr!
			 * The attrib field is garbage in this case!!
			 * So, we get true name, to get rid of '.', '..', etc. After this
			 * if we find the last character a '\\' it is the root directory.
			 */
			if (translate_name(path, TrueName))
				strcpy(TrueName, path) ;

#ifdef DBCS
			if (TrueName[strlen(TrueName)-1] == '\\' && !CheckDBCSTailByte(TrueName,&TrueName[strlen(TrueName)-1]))
#else
			if (TrueName[strlen(TrueName)-1] == '\\')
#endif
				ret = TRUE ;
			else
				ret = (attribs & _A_SUBDIR) ;
		}
	}

	return ret ;
}

/* M010 -- modified this function to support user control of the
 * primary swap path thru the INI file/DOSSHELL environment variable.
 */
VOID get_temp_dir(char *buffer, BOOL UseTemp)
{
	char *envptr;
	TOKEN swapdisk_tok ;

	buffer[0] = 0;

	if(UseTemp)
	{
		swapdisk_tok = Get_KeyWord_Assignment(TK_SAVESTATE, TK_SWAPDISK) ;
		if (swapdisk_tok >= 0)
		{
			strfncpy(buffer, Get_Token_Identifier(swapdisk_tok), ALLOWED_PATH) ;
			buffer[ALLOWED_PATH] = '\0' ; /* Null terminate just in case */

			/* Note that swapdisk variable in the INI file can have two paths
			 * in it -- the primary swap path followed by the secondary path.
			 * Make buffer point to only to the null terminated primary
			 * swap path.
			 */
			/* note that return value of foll. call will be buffer itself! */
			strtok(buffer, " \t") ;

			/* Make sure that it is a valid path. If not, don't use it! */
			if (!VerifyTempPath(buffer))
				buffer[0] = '\0' ;
		}

		if (buffer[0] == 0)
		{
			/* See if TEMP is set to a valid dir! */
	   	envptr = getenv(szTempEnvDirectory);
	   	if ( (envptr) && VerifyTempPath(envptr) )
				strcpy(buffer,envptr);
	   	else
	   	{
				/* See if TMP is set to a valid dir! */
				envptr = getenv(szTmpEnvDirectory);
				if (envptr && VerifyTempPath(envptr) )
					strcpy(buffer,envptr);
				else
				{
					/* See if DOSSHELL is set to a valid dir! */
					envptr = getenv(szIniFileEnvVar);
					if (envptr && VerifyTempPath(envptr) )
						strcpy(buffer,envptr);
				}
	   	}
		}
	}

	/* If swapdisk is not set in the INI file, or if there is no TEMP, TMP,
	 * DOSSHELL vars set in the environment, use the startup directory!
	 */

	if(buffer[0] == 0)
	{
		strcpy(buffer,gStartUpDir);
	}
} /* get_temp_dir */

/*
NOTE:   The following two routines exist only because LpbSaveGraphicArc
*               and RestoreGraphicArc are declared as NEAR PASCAL routines in the
*               CW library. In order to access them, we have these two intermediate
*               routines "MyLpbSave..." and "MyRestore..." that are placed in the
*               same segment as the CW library routines (using the alloc_text pragma). 
*               These in turn make near calls to these routines and we are able to use
*               the routines that CW does not give us direct access to. This indirection
*               is not too bad, as speed is not critical here.
*/
// #pragma alloc_text(CW_USER,MyLpbSaveGraphicArc)
BYTE FAR *MyLpbSaveGraphicArc(LPFN_LPB pfn, WORD cbSGA, AX left, AY top,
						  AX right, AY bottom)
{
	UnReferenced(cbSGA) ; /* Was used ina previous CW version */

	return LpbSaveGraphicArc(pfn, left, top, right, bottom) ;
	// return LpbSaveGraphicArc(pfn, cbSGA, left, top, right, bottom) ;
} /* MyLpbSaveGraphicArc */


// #pragma alloc_text(CW_USER,MyRestoreGraphicArc)
VOID MyRestoreGraphicArc(LPFN pfn, AX left, AY top, AX right, AY bottom, 
						   BYTE FAR *lpbSGA)
{
	RestoreGraphicArc(pfn, left, top, right, bottom, lpbSGA) ;
} /* MyRestoreGraphicArc */

/*
*   'glpbSGA' is pointer to the saved graphics rectangle. Used by routines
*       PutUpStatusMessage and TakeDownStatusMessage only!
*/
BYTE FAR *glpbSGA ;
BOOL gfStatusMsgUp = FALSE ;

RRC grrc = {STATUSMSGLEFT, STATUSMSGTOP, STATUSMSGRIGHT, STATUSMSGBOTTOM} ;

void DrawStatusMessageBackGround(int len)
{
	FillRrc(&MainWind, &grrc, ' ', isaDialogBox) ;

	if (gisgraph)
		FrameCharRect(grrc.ryTop, grrc.rxLeft, grrc.ryBottom, 
								grrc.rxLeft+len, 1,isaBorders) ;
	else
		EasyDrawBox(&MainWind, grrc.ryTop, grrc.rxLeft, grrc.ryBottom,
							grrc.rxLeft+len, isaDialogBox) ;
} /* DrawStatusMessageBackGround */


/*
*  These two routines: 'PutUpStatusMessage' & 'TakeDownStatusMessage' are not
*  re-entrant as they use the global variables 'glpbSGA', 'gfStatusMsgUp'.
*  This is perefectly acceptable in our context.
*  It draws the message-box only if (count == 1), i.e., when file-op is
*  being performed on the first selected file. When (count > 1), it assumes
*  that the box is up and so it only does 'TextOut' of 'msg'.
*/
VOID PutUpStatusMessage(char *msg, int count)
{
	WORD cbSave ;
	BYTE len ;

	/* If count == 1, this is the first time, a call to "PutUpStatusMessage()"
	 * has been made, so put it up! It is possible that the user skipped
	 * performing the operation on file 1 but went thru with the rest!
	 */
	if ( (count == 1) || (!gfStatusMsgUp) )
	{
		gfStatusMsgUp = TRUE ; /* indication to others that message put up */
	
		/*len can't exceed screen width, hence OK. +4 is for the filler blanks*/
		len = (BYTE) strlen(msg)+4 ; 
		grrc.rxRight = grrc.rxLeft + len ;
	
		cbSave = len * (grrc.ryBottom - grrc.ryTop);
		
		if (gisgraph)
		{
			glpbSGA = MyLpbSaveGraphicArc(LpbAllocWorkFar, cbSave, grrc.rxLeft,
								grrc.ryTop, grrc.rxLeft+len, grrc.ryBottom);
			/* if glpbSGA is NULL no memory available -- problem!! */
			/* Take down status message will repaint screen properly */
		}
		else
		{
			cbSave = CbSizeRrc(&grrc) ;
			if (glpbSGA = LpbAllocWorkFar(cbSave))
			{
				SaveRrc(&MainWind, &grrc, glpbSGA) ;
			}
			/* else no memory available -- problem!! */
			/* Take down status message will repaint screen properly */
		}
		DrawStatusMessageBackGround(len) ;
	}
	else
	{
		/* Did a dialog pop up and not restore stuff behind it when it was
		 * dismissed? In this case, the background might not be restored.
		 * Som redraw it now.
		 */
		if (gfRepaintonidle)
		{
			DrawStatusMessageBackGround(strlen(msg)+4) ;
		}
	}

	/* Disable mouse, as file-op is being performed! */
	FEnableMouseNest(FALSE) ;
	/*
		Note that the Mouse in not turned back ON in this routine! It will be
		turned ON by TakeDownStatusMessage. If needed before then,
		it should be turned on specifically , ex: by dialog box routines!
	*/

	TextOut(&MainWind, grrc.rxLeft+2, grrc.ryTop+2, msg, -1, isaDialogBox) ;

} /* PutUpStatusMessage */

/*
*   Takes down the Status Message that is curently on the screen, if possible.
*   If it cannot restore the screen to its original state, it returns FALSE,
*   else TRUE.
*       Actually does the above, only when (count == total), i.e., the file-op
*       has been performed on the last of a bunch of selected files. Otherwise,
*       the message is left up with only the Mouse being turned back ON.
*/
BOOL TakeDownStatusMessage(int count, int total)
{
	if (count == total)
	{
		gfStatusMsgUp = FALSE ;
	
		/* ZZZZZZ Hack to get around a CW problem!!! If I do not erase this
		 * stuff before restoring the graphics, when I pull down the menu
		 * and ESC to dismiss it, there is an ugly repaint problem!
		 */
		FillRrc(&MainWind, &grrc, ' ', isaBackground) ;

		/* ZZZZZ If (glpbSGA == NULL), we cannot use MyRestore... as the 
			SaveGraphicsArc didn't get enuf memory to save the screen.
		   It is the caller's responsibility to redraw the screen?!
		*/
		if (glpbSGA)
		{
			if (gisgraph)
			{
				MyRestoreGraphicArc(FreeWorkFar,grrc.rxLeft, grrc.ryTop,
									grrc.rxRight, grrc.ryBottom, glpbSGA);
			}
			else
			{
				RestoreRrc(&MainWind, &grrc, glpbSGA) ;
				FreeWorkFar(glpbSGA) ;
	
			}
		}
		else
		{
			// This is being done in the Hack above!
			// FillRrc(&MainWind, &grrc, ' ', isaBackground) ;
			gfRepaintonidle = TRUE ;
		}
	}

	FEnableMouseNest(TRUE) ;

	return (glpbSGA != NULL) ;
} /* TakeDownMessage */


/* Finds the length of the longest name for directories under 'dir'.
 * This lenght includes the '\\' char that will precede the sub-dirs in
 * the complete path name. This is a recursive routine.
 */
int find_longest(PENTRY dirnode)
{
	int temp_len, max_len ;
	PENTRY node ;
	char temp_normal_name[NAMELEN+EXTLEN+2] ;

	max_len = 0 ;
	node = dirnode->x.d.child ;
	while(node)
	{
		if (node->attribs & _A_SUBDIR)
		{
			/* the '1' is for the '\' that will precede node name in path */
			temp_len = 1 + Internal2Normal(temp_normal_name, node->name) +
							find_longest(node) ;

			if (temp_len > max_len)
				max_len = temp_len ;
		}

		node = (node->nosib) ? NULL : node->sibling ;
	}
	return max_len ;
} /* find_longest */

/* 'dirpath' is the full path name of the directory that is to be renamed by the
 * caller. Actually, 'dirpath' is the translated path name, i.e., substs, 
 * network names, etc have been un-referenced!
 * 'dirnode' is the PENTRY node in the tree. Note that it can't be NULL
 * as a root directory can't be renamed!!
 * 'len_difference' is the length difference between new name and old name!
 * On renaming a directory, certain deeply nested directories/files under
 * it might become un-accessible. This routine makes sure that such badness
 * won't ensue.
 */
BOOL path_len_check(char *dirpath, PENTRY dirnode, int len_difference)
{
	/* Is new_name_length > old_name_length? In this case, we
	 * have to worry about nesting problems ELSE if the problem was
	 * not existent before the rename, it won't be there now.
	 */
	if (len_difference > 0)
	{
		/* complex case, perform actual testing using tree traversals. */
		if (len_difference + strlen(dirpath) + find_longest(dirnode) > 
																ALLOWED_PATH)
			return FALSE ;
	}
	return TRUE ;
} /* path_len_check */

char far *gWriteBuffer ;
unsigned gWriteBufferSize ;
unsigned gWriteBufferFreeInd ;
unsigned gWriteErrs;

void SetUpWriteBuffer(unsigned low, unsigned high)
{
	gWriteBufferSize = AllocClosestTo1K(&gWriteBuffer, low, high) ;
	gWriteBufferFreeInd = 0 ;
} /* SetUpWriteBuffer */


/* Writes out any last piece that was still in buffer that needs to be written
 * out to disk.
 */
unsigned FlushBufferedWrite(int fhandle)
{
	unsigned dummy ;
	unsigned ret ;

	if (gWriteBuffer && (gWriteBufferFreeInd > 0) )
	{
		if((ret=_dos_write(fhandle, gWriteBuffer, gWriteBufferFreeInd, &dummy))
				|| dummy<gWriteBufferFreeInd)
			++gWriteErrs;
		gWriteBufferFreeInd = 0 ;
	}
	return ret ;

} /* FlushBufferedWrite */

unsigned Buffered_dos_write(int fhandle, char far *str, unsigned count,
		unsigned *pbytes)
{
	unsigned ret ;
	unsigned nLeft;

/* Were we un-successful in allocating storage to buffer writes? */
/* If so, do a direct write to disk.                                                     */
	if (!gWriteBuffer) {
		if((ret=_dos_write(fhandle, str, count, pbytes)) || *pbytes<count)
			++gWriteErrs;
		return(ret);
	}

	*pbytes = count;

/* While the new string to be added exceeds buffer bounds */
	nLeft = gWriteBufferSize - gWriteBufferFreeInd;
	while(count > nLeft) {
/* Add what we can to the string and flush the buffer */
		RepeatMove(gWriteBuffer+gWriteBufferFreeInd, str, nLeft);
		count -= nLeft;
		str += nLeft;
		gWriteBufferFreeInd = gWriteBufferSize;

		if(ret = FlushBufferedWrite(fhandle)) {
			*pbytes = 0 ;
			return(ret);
		}
		nLeft = gWriteBufferSize;
	}

	RepeatMove(gWriteBuffer+gWriteBufferFreeInd, str, count);
	gWriteBufferFreeInd += count ;
	return(0); /* indicate succesful write to caller. */
} /* Buffered_dos_write */


void Set_StartupItem(void);

/* INI file size buffer we try to allocate -- This is in Kbytes. Our test
 * INI file is less than 16K -- so this number should be good enuf. Of course
 * if the INI file happens to be larger than 20K, we would re-use this
 * buffer more than once.
 */
#define INI_SIZE_IN_K  20

BOOL gfUseINITdir; // write to INIT directory, or dosshell directory

/* This the routine that sets up the buffer to do the buffered writes and
 * the writes out the INI file.
 * WARNING! It is being assumed that the INI file will be written out at the
 * time of exiting the shell or launching a program -- In both cases the
 * shell relinquishes control to some other program. So, we can free up
 * almost all the memory that has been allocated to the shell at this point.
 * That way, we will be able to allocate a big enuf buffer to do the buffered
 * writes. Most of the memory that we allocate dynamically is being used
 * to store the tree/file data structures in the file manager.
 */
BOOL Buffered_Write_Ini_File(BOOL bFreeFM)
{
	unsigned wSaveAttr;
	int ind;
	char *envptr;
	char inifilename[128];
	char tchar;
	int tlen;

	Set_StartupItem();

/* If symbol table is not changed from what it was at startup, we don't
 * write it out!
 */
	if(!fgSymbolTableModified && fNoEffectiveChange())
	return(TRUE);

	if(!gfUseINITdir)
	{
usedefaultlocation:
	strfcpy(inifilename,gStartUpDir);
	ind = gStartUpDirEnd ;
#ifdef DBCS
	if(inifilename[ind-1] != '\\' || CheckDBCSTailByte(inifilename,&inifilename[ind-1]))
#else
	if(inifilename[ind-1] != '\\')
#endif
		inifilename[ind++] = '\\';
	strcpy(inifilename+ind, szShellIni);
	}
	else
	{
	
	envptr = getenv(szIniFileEnvVar);
	/* this should never fail since we have the gfUseINITdir var, but
	 * lets be sure!
	 */
	if(!envptr)
		goto usedefaultlocation;
	strfcpy(inifilename,envptr);
	/* be sure there is a trainling '\'! */
	tchar = inifilename[(tlen=strlen(inifilename))-1];
#ifdef DBCS
	if(((tchar != '\\') && (tchar != '/')) || CheckDBCSTailByte(inifilename,&inifilename[tlen-1]))
#else
	if((tchar != '\\') && (tchar != '/'))
#endif
	{
		inifilename[tlen] = '\\';
		inifilename[tlen+1] = 0;
	}
	strcat(inifilename,szShellIni);

	}
	if(_dos_getfileattr(inifilename, &wSaveAttr))
		wSaveAttr = 0;
	_dos_setfileattr(inifilename, 0);

/* If we are here, we are forced to write out INI file. We want to
 * have buffered writes to speed it up!
 */

/* Now free up the tree/file data structures */
	if(bFreeFM)
	FreeFMMemory() ;

	SetUpWriteBuffer(1, INI_SIZE_IN_K) ;
	if(!Write_Ini_File(inifilename))
	goto Error1;

	fgSymbolTableModified = FALSE;

Error1:
	FreeWorkFar(gWriteBuffer);
	gWriteBuffer = NULL;

	_dos_setfileattr(inifilename, wSaveAttr);

	return(!fgSymbolTableModified);
} /* Buffered_Write_Ini_File */

VOID Do_Read_Ini_File(void)
{
	int ind;
	char *envptr;
	char ininame[128];
	char tchar;
	int tlen;

	gfUseINITdir = TRUE;

	envptr = getenv(szIniFileEnvVar);
	if(envptr)
	{
		strfcpy(ininame,envptr);
		/* be sure there is a trainling '\'! */
		tchar = ininame[(tlen=strlen(ininame))-1];
#ifdef DBCS
		if(((tchar != '\\') && (tchar != '/')) || CheckDBCSTailByte(ininame,&ininame[tlen-1]))
#else
		if((tchar != '\\') && (tchar != '/'))
#endif
		{
			ininame[tlen] = '\\';
			ininame[tlen+1] = 0;
		}
		strcat(ininame,szShellIni);

	}
	if(!envptr || !Read_Ini_File(ininame))
	{
		gfUseINITdir = FALSE;
		ind = gStartUpDirEnd ;
#ifdef DBCS
		if(gStartUpDir[ind-1] != '\\' || CheckDBCSTailByte(gStartUpDir,&gStartUpDir[ind-1]))
#else
		if (gStartUpDir[ind-1] != '\\')
#endif
		{
			gStartUpDir[ind++] = '\\' ;
		}
		strcpy(gStartUpDir+ind,szShellIni);

		if(!Read_Ini_File(gStartUpDir))
			Read_Ini_File(NULL); //use defaults
		gStartUpDir[gStartUpDirEnd]=0;
	}
}

extern Shell_TTY_Out(char *str);

/* Prints the help text in response to the /H, /? option to the DOSSHELL */
void PrintHelpText(void)
{
	Shell_TTY_Out(szShellHelp1) ;
	Shell_TTY_Out(szShellHelp2) ;
	Shell_TTY_Out(szShellHelp3) ;
	Shell_TTY_Out(szShellHelp4) ;
	Shell_TTY_Out(szShellHelp5) ;   
   //no longer used Shell_TTY_Out(szShellHelp6) ;
} /* PrintHelpText */


/* This function returns whether extension 'ext' is a valid executable file.
 * It says whether "ext" refers to a .EXE, .COM, or .BAT file
 */
BOOL FIsExecutableFile(char far *ext)
{
	return ( (fstrncmp(ExeStr, ext, 3) == 0) ||
			 (fstrncmp(ComStr, ext, 3) == 0) ||
			 (fstrncmp(BatStr, ext, 3) == 0)
		   ) ;
} /* FIsExecutableFile */

#ifdef DBCS
/*
	DBCS enabled strupr
*/
unsigned char   *DBCSstrupr(unsigned char *str)
{
	unsigned char   *s;

	s = str;
	while (*s)
	{
		if (IsDBCSLeadByte(*s))
			s++;
		else
			*s = toupper(*s);
		s++;
	}
	return (str);
}

/*
	DBCS enabled strchr
*/
unsigned char   *DBCSstrchr(unsigned char *str,unsigned char c)
{
	while (*str)
	{
		if (IsDBCSLeadByte(*str))
			str++;
		else if (*str == c)
			return (str);
		str++;
	}
	if (c == '\0')
		return (str);
	else
		return 0;
}
#endif

char * PASCAL MySetMessageText(TMC tmc, char *message, int nWid)
{
	 int nLineLen ;
	char cSave;

	if((nLineLen=TextLineLen(message, nWid, '\0')) < 0)
	return(message);

	cSave = message[nLineLen];
	message[nLineLen] = '\0';
	Shell_SetTmcText(tmc, message);
	message += nLineLen;
	*message = cSave;

	while(*message=='\n' || *message=='\r')
	++message;
	return(message);
}

char *gMessageTitle; /* title to the message dialog box */
char *gMessage1;
BOOL FAR PASCAL FDlgmessage(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	PWND lwind;
	int nWid;

	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch(dlm) {
	case dlmInit:
	SetUpDialog(tmcmessage1, gMessageTitle) ;

	SetUpButtonForGraphics(tmcCancel); /* this is called the enter button */

	lwind = PwndOfListbox(tmcmessage1);
	nWid = lwind->arcWindow.axRight - lwind->arcWindow.axLeft + 1;

	gMessage1 = MySetMessageText(tmcmessage1, gMessage1, nWid);
	gMessage1 = MySetMessageText(tmcmessage2, gMessage1, nWid);
	MySetMessageText(tmcmessage3, gMessage1, nWid);
	break;

	case dlmSetFocus:
	gCurrentTMC = tmc;
	break ;
	}
	return(TRUE);
}

/*
 * Generic message box. Input title and message
 */
VOID ShellMessageBox(char *messagetitle, char *message)
{
	HCABmessage h;

	if(!(h=HcabAlloc(cabiCABmessage))) {
	OutOfMemory();
	return;
	}
	InitCab(h, cabiCABmessage) ;

	gMessageTitle = messagetitle;
	gMessage1 = message;

	SzToCab(h, szClose, Iag(CABmessage, pszmessageEB));

	MyTmcDoDlg(&dlgmessage, h); 

	FreeCab(h);
} 

BOOL FAR PASCAL FDlgabout(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch(dlm)
	{
		case dlmInit:
		 {
			// WARNING see text.c (to skip a ~)
#ifdef KANJI
		   SetUpDialog(tmcCancel,szmHelpShellAbout) ;
#else
		   SetUpDialog(tmcCancel,&szmHelpAbout[1]) ;
#endif
		   SetUpButtonForGraphics(tmcCancel) ; /* this is called the enter button */
		 }
		case dlmSetFocus:
			gCurrentTMC = tmc;
			break ;
	}
	return(TRUE);
}

/*
 * About BOX
 * This is different from message because the spacing is wierdo
 */
VOID ShellAboutBox(void)
{
	HCABmessage h;

   h = HcabAlloc(cabiCABabout);
	if (!h)
	{
		OutOfMemory() ;
		return;
	}
	InitCab(h, cabiCABabout) ;

	SzToCab(h, szClose, Iag(CABabout, pszaboutEB));

	MyTmcDoDlg(&dlgabout,  h); 
	FreeCab(h);
} 


/* This function does a change directory to the directory specified by
 * 'dir'. Note that 'dir' needs to be a complete path name. For example,
 * a valid 'dir' is "C:\LSH\SHELL"
 * The reason for this is that the C-function "chdir()" does not do a
 * real change directory across drives but a UNIX' "cd" does this!
 */
int UnixChdir(char *dir)
{
	int TotalNumDrives ;
	int drive_ind ;

	/* Set drive ind by converting the drive letter to the appropriate
	 * drive number: 1 = drive A, 2 = drive B, etc.
	 */
	drive_ind = toupper(*dir) - 'A' + 1 ; // OK even if dir is NULL - see below

	/* Try to change to the directory only if we think the user has
	 * specified a valid absolute path -- DriveLetter followed by a COLON.
	 */
	if (dir && (drive_ind > 0) && (drive_ind < 27) && (dir[1] == ':') )
	{
		_dos_setdrive(drive_ind, &TotalNumDrives) ;

		return chdir(dir) ;
	}

	return -1 ; /* error */

} /* UnixChdir */

/*
 *      MakeDirNameFit translates a directory name and match pattern into
 * a string that will fit in maxlen characters.
 * The algorithm clips the end of the path name and puts in ellipses.
 * Thus, c:\foo\bar\cabbage\rabbits\*.foo fit in 16 characters goes to
 *       c:\foo\b..\*.foo
 * NOTE:
 *      pattern can be NULL; thus either no pattern or pattern is already
 *      
 * WARNING don't forget that this is characters displayed, not bytes used,
 * so destination must have room for NULL character!
 * WARNING! maxlen must never be < 8+3+1!
 */
VOID MakeDirNameFit(char *longname,char *pattern,char *destination,int maxlen)
{
	char    tempspace[128]; //be sure we don't tromp!
	int     longlen;
	int     templen;
	int     patternlen;
	int     outputlen;
	int     lasttermpathcharoffset,lasttermoffset;

	longlen = strlen(longname);
	strcpy(tempspace,longname);
	if(!pattern)
	{
		/* Is the name already within the bounds? If so trivial case! */
		if (longlen <= maxlen)
		{
			strcpy(destination,tempspace);
			return ;
		}

		/* pattern is NULL, so we figure out what the parent directory is and
		 * hence the pattern -- simplifies matters as we can follow our
		 * usual algorithm when the pattern is Non-Null.
		 */
		lasttermpathcharoffset = FindLastComponent(longname);
		if(longname[lasttermpathcharoffset] == PATHCHAR)
			lasttermoffset = lasttermpathcharoffset+1;
		else
			lasttermoffset = lasttermpathcharoffset;
		tempspace[lasttermpathcharoffset] = NULL;
		longlen = lasttermpathcharoffset;
		pattern = &longname[lasttermoffset];
	}
	patternlen = strlen(pattern);

	templen = longlen+patternlen+1; /* +1 for pathchar */
	if(templen > maxlen)
	{
		outputlen = patternlen+1+3; /* +1 for '\', +3 for '...' */

		assert(outputlen <= maxlen);

		/* put in ellipses */
		strcpy(&tempspace[maxlen-outputlen],szEllipses);
		tempspace[maxlen-outputlen+3] = (char) PATHCHAR ;
		tempspace[maxlen-outputlen+4] = '\0' ;
		if(pattern)
			strcpy(&tempspace[maxlen-outputlen+3+1],pattern);
	}
   else
	{
		if(pattern != NULL)     /* if there is a path to be appended */
		{
			/* put a '/' character at the end */
#ifdef DBCS
			if(tempspace[longlen-1] != PATHCHAR || CheckDBCSTailByte(tempspace,&tempspace[longlen-1]))
#else
			if(tempspace[longlen-1] != PATHCHAR)
#endif
			{
				tempspace[longlen] = PATHCHAR;
				++longlen;
			}
			strcpy(&tempspace[longlen],pattern);
		}
	}
	strcpy(destination,tempspace);
}


void Convert2AbsolutePath(char *dest, char *src)
{
	char *psz ;
	int pathlen ;
	PTREE tree ;
	BYTE dummy_driveind ;
	PENTRY dest_dir ;
	char TrueName[MAX_PATH+1] ;
	char *ptr ;
	int fTrailingPathChar;
	int len ;

	/* skip any leading spaces. */
	while ((*src == ' ') && (*src) )
		src++ ;

	/* remove any trailing blanks -- actually if path were of the form
	 * "ABC  DEF", etc this will cause it to become "ABC" which is fine.
	 */
	if (psz = strchr(src, ' '))
		*psz = '\0' ;

	/* Remember whether there was a trailing PATHCHAR in the path */
	len = strlen(src) ;
	fTrailingPathChar = FALSE ;
#ifdef DBCS
	if (len && (src[len-1] ==  '\\' && !CheckDBCSTailByte(src,&src[len-1])))
#else
	if (len && (src[len-1] ==  '\\'))
#endif
		fTrailingPathChar = TRUE ;

	/* Convert to upper case -- all path names, etc in DOS are upper case */
#ifdef DBCS
	DBCSstrupr(src) ;
#else
	strupr(src) ;
#endif

	/* Has the user specified a path like "\abc\cde", etc. In this case get
	 * the drive letter from the focus/selected dir.
	 */
	if (*src == '\\')
	{
		/* get the drive letter from tree */
		dest[0] = listinfo[glob.FocusBox].tree->root[0] ;
		dest[1] = ':' ;
		strcpy(dest+2, src) ;
	}
	/* If the user has specified a relative path. examples: "abc", "abc\def",
	 * "" (empty string), get selected/focus dir and create abs path.
	 */
	else if (!(*src) || (src[1] != ':') )
	{
		Tree2Path(listinfo[glob.FocusBox].tree, listinfo[glob.FocusBox].files,
														dest, &pathlen) ;

#ifdef DBCS
		if ( (dest[pathlen-1] != '\\' || CheckDBCSTailByte(dest,&dest[pathlen-1])) && (*src) )
#else
		if ( (dest[pathlen-1] != '\\') && (*src) )
#endif
			dest[pathlen++] = '\\' ;

		strcpy(dest+pathlen, src) ;
	}
	/* Has the user specified a drive letter? examples:
	 * "a:", "a:abcd", "a:\abc\def". Convert cases 1 and 2 to full path
	 * names, case 3 is already OK.
	 */
	else if (src[1] == ':')
	{
		tree = FindTree(src, &dummy_driveind) ;
		if (!tree)
		{
			/* tree not found! Just use root on that drive! */
			dest[0] = src[0] ; dest[1] = ':' ; dest[2] = '\\' ; dest[4] = '\0' ;
		}
		else
		{
			/* Is it already a full path specification (case 3 above)? Don't have
			 * to do anything special. Just copy src to dest.
			 */
			if (src[2] == '\\')
			{
				strcpy(dest, src) ;
			}
			else // convert relative path to full path (cases 1 and 2 above)
			{
				/* If the tree to which copy is requested is not the one in
				 * focus, use the default directory on that tree.
				 */
				if ( !(listinfo[glob.FocusBox].tree == tree) )
					dest_dir = tree->SelDir ; // default directory for tree
				else
					dest_dir = listinfo[glob.FocusBox].files ;

				Tree2Path(tree, dest_dir, dest, &pathlen);

				/* Is it of the form "a:abcd" (case 2 above)? */
				if (src[2])
				{
					/* If it is not the root directory append \ to it */
#ifdef DBCS
					if (dest[pathlen-1] != '\\' || CheckDBCSTailByte(dest,&dest[pathlen-1]))
#else
					if (dest[pathlen-1] != '\\')
#endif
						dest[pathlen++] = '\\' ;

					/* Copy all the stuff after the ':' from src */
					strcpy(dest+pathlen, src+2) ;
				}
				/* else path is of the form "a:" (case 1 above)! -- Don't
				 * have to do anything extra for this case. 'dest' is already
				 * set up right.
				 */
			
			} /* (src[2] == '\\') else */

		} /* if (!tree) else */
	}
	else
	{
		strcpy(dest, src) ;
	}

	/* Now this path in "dest" could still have '.' and '..' Get rid of these
	 * and handle this right.
	 */
	/* If translate name was succesful, remove the server name, if any
	 * and put back the drive letter.
	 */
	if (!translate_name(dest, TrueName))
	{
		/* Is there a server name in the beginning like \\trojan\os1?
		 * that is, are the first 2 chars \\?
		 */
		if ( (* ((WORD *)TrueName)) == 0x5C5C )
		{
#ifdef DBCS
			ptr = DBCSstrchr(TrueName+2, '\\') ;
#else
			ptr = strchr(TrueName+2, '\\') ;
#endif

			assert(ptr != NULL) ;

#ifdef DBCS
			ptr = DBCSstrchr(ptr+1, '\\') ;
#else
			ptr = strchr(ptr+1, '\\') ;
#endif
			if (!ptr)
			{
				// The first 3 chars are already OK as 'dest' is an abs path!
				dest[3] = '\0' ; // ROOT dir case.
			}
			else
				strcpy(dest+2, ptr) ; // replace server name by drive letter!
		}
		else
			strcpy(dest, TrueName) ; // got rid of '.' and '..' if any!
	}
	/* else translate_name failed -- leave dest alone */
	
	/* If the source had a trailing PATHCHAR and after the name translation
	 * this character is lost, put it back at the end.
	 */
	if (fTrailingPathChar)
	{
		len = strlen(dest) ;
#ifdef DBCS
		if (dest[len-1] != '\\' || CheckDBCSTailByte(dest,&dest[len-1]))
#else
		if (dest[len-1] != '\\')
#endif
		{
			dest[len++] = '\\' ;
			dest[len] = '\0' ;
		}
	}

} /* Convert2AbsolutePath */

/* This function decides whether we need to perform the requested file
 * operation (like delete, copy, move, etc) on the files selected in the
 * file listbox with focus or on the files selected in the entire tree.
 */
#if 0
BOOL FPerformOpOnDirFilesAlone(void)
{
	return (	(glob.TreeMode == TR_DOUBLE) &&
				(listinfo[0].tree == listinfo[1].tree) &&
				(!glob.CrossDirSel)
			 ) ;
} /* FPerformOpOnDirFilesAlone */
#else
BOOL FPerformOpOnDirFilesAlone(void)
{
	return (	(!glob.CrossDirSel) &&
				(glob.TreeMode != TR_SYSTEM) &&
				( (glob.TreeMode != TR_SEARCH) || (!gfSearchDisk) )
			 ) ;
} /* FPerformOpOnDirFilesAlone */
#endif


/* This function decides whether to perform a directory operation or not.
 * In general, if the focus is in the directory listbox or on the
 * drive lists, we say that it is a directory operation.
 */
BOOL FPerformDirOperation(void)
{
	BOOL ret ;
	WORD FocusList ;

	FocusList = WhoHasGlobalFocus() ;
	
	/* Don't allow performing of directory ops in SYSTEM/SEARCH mode! */
	if ( (glob.TreeMode == TR_SYSTEM) || (glob.TreeMode == TR_SEARCH) )
		return FALSE ;

	ret = (FocusList == DRIVELIST0) || (FocusList == TREE0) ;

	if ( (!ret) && (glob.TreeMode == TR_DOUBLE) )
	{
		ret = (FocusList == DRIVELIST1) || (FocusList == TREE1) ;
	}

	return ret ;

} /* FPerformDirOperation */

/* If we have an empty file listbox, move focus to the corresponding
 * directory listbox. This can happen after file operations, like
 * Move, Delete, File Display Options, Change Attributes.
 */
void HandleEmptyFileListBoxes(void)
{
	if (WhoHasGlobalFocus() == FILE0)
	{
		if (GetNumItems(&FileList[0]) == 0)
			InitGlobalFocus(TREE0) ;
	}
	else if ( (glob.TreeMode == TR_DOUBLE) && (WhoHasGlobalFocus() == FILE1) )
	{
		if (GetNumItems(&FileList[1]) == 0)
			InitGlobalFocus(TREE1) ;
	}
	
} /* HandleEmptyFileListBoxes */

/* This function can be easily described by giving examples of what it
 * does:
 *        Input:        FormStringWithoutPlaceHolders(dest,"%1 loves %2",(char far *)"Rama",(char far *)"Sita") ;
 *        Output: "Rama loves Sita"
 *        Input:        FormStringWithoutPlaceHolders(dest,"%2 %1 loves",(char far *)"Rama",(char far *)"Sita") ;
 *   Output: "Sita Rama loves"
 *
 * Note that there is really no limit on the number of replaceable arguments
 * However, all replaceable parameters need to be strings (far pointers)
 * and say there is a %5 there should be atleast 5 replaceable arguments
 * otherwise, this function will use garbage from the stack!
 * dest is the location where the string formed is placed.
 * src can be without any placeholders (%1, %2, etc)
 */
void cdecl FormStringWithoutPlaceHolders(char far *dest, char far *src, ...)
{
	int IthArg ;
	char far *replacestr ;

	/* Do until we reach the end of source (EOS (null) char) */
	while(*dest++ = *src)
	{
		// Increment source as we have only incremented destination above
		if(*src++ == '%')
		{
			if (*src == '%')
			{
				/* One can use %% to get a single percentage char in message */
				src++ ;
				continue ;
			}

			dest--; // dest has been INCed one too much.

			// Get which argument it is: like 2 for %2
			IthArg = *src++ - '0' + 1 ;

			/* Get the address of the replacing string from the stack.
			* Note that in 'C' the last argument is pushed first. Also,
			* here, the stack grows from high address to low address.
			*/
			replacestr = *((&dest)+ IthArg) ;

			// Copy the replacement string into destination
			while (*replacestr)
				*dest++ = *replacestr++ ;
		}
	} /* while */
} /* FormStringWithoutPlaceHolders */

char *gpszMouseVerMsg ;

// M011 Modified this function to put up our new mouse compatibility message!

BOOL FAR PASCAL FDlgmswarn(WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
	PWND lwind ;
	char *psztemp ;
	int itemwidth ;

	UnReferenced(tmc) ;
	UnReferenced(wNew) ;
	UnReferenced(wOld) ;
	UnReferenced(wParam) ;

	switch(dlm)
	{
		case dlmInit:
		 {
		   SetUpDialog(tmcCancel,szCritWarning) ;
		   SetUpButtonForGraphics(tmcCancel) ; /* this is called the enter button */
		   SetUpButtonForGraphics(tmcenablemouse) ; /* this is called the enter button */

			lwind = PwndOfTmc(tmcmousevermsg1);
			itemwidth = lwind->arcWindow.axRight - lwind->arcWindow.axLeft ;

			/* This message is allowed to overflow onto a 2nd line */
	      psztemp = MySetMessageText(tmcmousevermsg1, gpszMouseVerMsg,
																					itemwidth);
			MySetMessageText(tmcmousevermsg2, psztemp, itemwidth) ;
		 }
		case dlmSetFocus:
			gCurrentTMC = tmc;
			break ;
	}
	return(TRUE);
}

// M011 Modified this function to put up our new mouse compatibility message!

TMC WarnMouseIsOld(char *pszMouseVersion)
{
	HCABmswarn h;
	TMC  retval;
	char MouseVersionMsg[161] ;
	
	if(!(h=HcabAlloc(cabiCABmswarn))) {
	OutOfMemory();
	return tmcCancel ; // don't use the mouse!
	}
	InitCab(h, cabiCABmswarn) ;

	// M013 If mouse version is unknown -- Major version number is 0, we
	// we use the string unknown for the version number!
	if(pszMouseVersion[0] == '0')
		pszMouseVersion = UnknownMouse;

	FormStringWithoutPlaceHolders(MouseVersionMsg, MouseVersionMsgTemplate,
											(char far *)pszMouseVersion ) ;

	/* use the following to pass this string to dilaog proc FDlgmswarn */
	gpszMouseVerMsg = MouseVersionMsg ;

	retval = MyTmcDoDlg(&dlgmswarn, h); 

	FreeCab(h);
	 return(retval);
} 



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\view.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/* ZZZZZZ There are some variables which need to be unsigned long, unsigned
	int instead of plain long, int -- Otherwise close to 2**32 problems may
	occur!! */

/* ZZZZ The message queue is not flushed by DosErrorBox?? Retry problem!! */

/****	view.c - implements "view file" command for file manager
**	
*/
#include <common.h>
#include <menus.h>
#include <filemgr.h>
#include <prot.h>
#include <dos.h>
#include <share.h>
#include <text.h>
#include <help.h>
#include <icons.h>
#include <ctype.h>
#include <assert.h>

extern MPVKEYID gAccelerators[];
extern MPVKEYID *pAccel;

extern VOID FAR *	FAR PASCAL LpbAllocWorkFar(WORD) ;
extern BOOL FreeUnusedFMMemory(void) ;
extern void DoFullRefresh(void) ;

extern BOOL ScrollPause(BOOL reset) ;

extern MENUINFO ViewMenuBar ;
extern MENUINFO FileMgrMenuBar ;
extern BOOL isup[2];

#define HexDigit(i) ((unsigned char) ((i) < 10 ? '0' + (i) : 'A' + (i)-10))

//	This is a full-screen child of the file mgr window.
WND ViewWind = wndGeneric(2, WS_CHILD, TRUE, 0, 0, 0, 0,
			ViewWindProc, &MainWind, NULL, NULL)
			{ 0 }
endWndGeneric;
extern BOOL ViewRead(long start_fpos) ;
extern void AddViewAccelerators(void);

/* MAXPAGES determines the max number of pages of text that can be viewed.
** It needs to be high enough that users don't complain much.
** MAXPAGELINES is the highest number of lines of the file which can
** be displayed at a time.
** GRANULARITY: assume that GRANULARITY == 20.  Then offsets[0] is the number
** of bytes between the start of line 0 and the start of line 20, offset[1]
** contains the byte count between line 20 and line 40, etc.
** WARNING! v_buffer[] must be able to hold at least GRANULARITY lines at a time
** in both hex and ASCII modes.
** VIEWBUFSIZE is the size of v_buffer[].
*/

#define FILETEXTY 2 /* Y-coordinate at which the first file text line begins */

/* 7 lines are lost 4 header lines + 2 on top and 1 at bottom */
#define LINESLOST 5

// #define VIEWBUFSIZE		4096
unsigned VIEWBUFSIZE ;

// #define MAXPAGES		100
// #define MAXPAGELINES		42  
// ZZZZ Actually MAXPAGELINES should be 50-LINESLOST = 38!!
// #define GRANULARITY		32					
// #define OFFSETSIZE		((MAXPAGES*MAXPAGELINES)/GRANULARITY+1)
#define OFFSETSIZE 			60
/*
* An OFFSETSIZE of 60 will allow us an indexed line accesses in files that
* have a maximum of 60*GRANULARITY lines. In the worst case GRANULARITY will
* be 36. See the calculations in fn ViewFile. The case when the whole file
* fits into the buffer, GRANULARITY is useless!!
*/
unsigned GRANULARITY ;
#define GR_MARGIN 		8

#define KEY_CR			13
#define KEY_LF			10
#define KEY_FILLER	'.'
#define KEY_CTRL_Z		26

unsigned long ViewFileSize ;
BOOL ascii;	// TRUE=ASCII display, FALSE=hex

static unsigned offsets[OFFSETSIZE];
static int lastoffset;					// last valid offset

static RY linesperpage;						// lines per page
static long  bufbeginline ;	/* the line that begins at &v_buffer[0] */
static long  buffocusline ; /* the line that is at loc >= &v_buffer[0] */
static long  buffocuspos ;  /* the offset into the v_buffer of bufposline */
static long curline;				// first displayed line of curpage

/* After every dos-read, VerifyPage sets bufbeginline, buffocusline,
	buffocuspos! Note that only if bufbeginline!=-1, the other two
	have meaningful values */

#if DEBUG
static long lastline;		// last line of file ZZZ unused at present.
#endif

unsigned char far *v_buffer;		// pointer to file data.
static unsigned buflen;				// # of valid chars in v_buffer
static long filepos;				// file position of start of v_buffer

/* following two variables store the linenumber and its filepos -- when
	we run out of our array of offsets for line boundaries! */
static long cachedline ;
static long cachedfilepos ;

static int handle;							// file handle for reads
static unsigned char path[1+MAX_PATH];		// the file itself

/* Following are relative co-ordinates in ViewWind as to where the first
   non-blank characters go on left and top */
#define TITLE_RX   4
#define TITLE_RY   0
#define  HEADER_SEPY 5

/****	Printable - is given character printable?
**
**	ENTRY
**			c - character to examine
**	EXIT
**			TRUE if printable, FALSE if not.
**	WARNING
**		This will need to be changed for internationalization.
*/
BOOL FAR Printable(c)
unsigned char c;
{
	switch (c)
	{
		case KEY_TAB:
		case KEY_CR:
		case KEY_LF:
		case KEY_BS:
		case KEY_CTRL_Z:
			return TRUE;
		default:
			if (c >= 32 && c <= 254 && c != 127)
				return TRUE;
			else
				return FALSE;
	}
} /* proc Printable */

/* Atleast 'low' KBytes are required! -- Allocate close to 1K of Max
	allocation possible. Max of 'highend'Kbytes is what it tries!!  */
unsigned FAR AllocClosestTo1K(unsigned char far **buffer, unsigned lowend,
														unsigned highend)
{
	unsigned prevhighend ;
	BOOL not_satisfied ;

	/* Make sure that we can allocate at least as many bytes as the lowest
	 * bound requested. If not we just say sorry, right away. This makes
	 * our loop later on always succeeed.
	 */
	if  (!(*buffer = LpbAllocWorkFar(lowend<<10)))
	{
		*buffer = NULL ;
		return 0 ;
	}

	FreeWorkFar(*buffer) ;
	prevhighend = highend+1 ;
	not_satisfied = TRUE ;
	while (not_satisfied)
	{
		if ( !(*buffer = LpbAllocWorkFar(highend<<10)) )
		{
				prevhighend = highend ;
				highend = (highend + lowend) / 2  ;			
				if (highend <= (lowend+1) )
					not_satisfied = FALSE ;
		}
		else
		{
			FreeWorkFar(*buffer) ;
			if (highend < (prevhighend - 1))
			{
				lowend = highend ; 
				highend = prevhighend-1 ;
			}
			else
			{
				lowend = highend ;
				not_satisfied = FALSE ;
			}
		}
	} /* while */
	*buffer = (unsigned char far *) LpbAllocWorkFar(lowend<<10) ;
	return (lowend<<10) ;
} /* AllocClosestTo1K */
		
/****	ViewFile - view the selected file in either hex or ASCII form
**		This fn, only called when a single file is selected, implements
**	the View File command, allowing the user to examine the contents of a
**	file.  Active keys are up and down arrow, which scroll by one line,
**	and page up/page down which scroll by a screenful less one line.
**	ENTRY
**		no parms
**	EXIT
**		no return
**	RESTRICTION:
**		As currently implemented, the fn uses a fixed-size table to store
**	the size of each page of text in ASCII mode.  There are MAXVIEWPAGES
**	entries in this table; thus this is the number of pages which can be
**	viewed in ASCII mode.  Trying to go beyond this point produces...what?
*/
BOOL ViewFile(PTREE tree, PENTRY node, char *unused1, int count, 
												int total, BOOL unused2)
{
	unsigned l, h ;
	char statusline[STATUS_LEN] ;
	struct find_t findinfo;
	int ret ;
	int dummylen ;

	UnReferenced(unused1) ;
	UnReferenced(unused2) ;

	Tree2Path(tree, node, path, &dummylen) ;

	/* Put up dialog box saying file of size 0 can't be viewed */
	FormCountStatusLine(statusline, szOpViewFile, path, count, total,
																			STATUS_COUNT_START) ;

	do
	{
		ret = shell_findfirst(path, _A_HIDDEN | _A_SYSTEM,	&findinfo);
		if (ret)
			// ZZZZZ modify HELP_VIEWOPEN to be appropriate one!
			ret = GetResponse(statusline, szFileNotFound, BT_FILERETRYSKIPQUIT,
																			HELP_VIEWOPEN) ;
		else
			ret = ACT_OK ;
	}  while (ret == ACT_RETRY) ;

	if (ret != ACT_OK)
	{
		/* Mark that we are not in ViewFile! Checked in WindProc!! */
		gpszFileOpCaption = NullString ;
		return ret ;
	}

	ViewFileSize = findinfo.size ;

	if (ViewFileSize != node->x.f.size)
	{
		/* The file's size changed behind our back. The user changed this
		 * info when outside the shell and the shell does not re-read the
		 * directory structure in these cases unless specifically forced
		 * by the user.
		 */
		node->x.f.size = ViewFileSize ;
		node->dtlx.dt.time = findinfo.wr_time;
		node->dtlx.dt.date = findinfo.wr_date;

		/* ZZZ We don't update the atributes field as if it was not a hidden
		 * or system file and now became one, it should be made to disappear
		 * from the file list (if display hidden/system files is turned off).
		 * This will confuse users.
		 */
	}

	if (ViewFileSize == 0)
	{
		/* Use BT_QUIT if we don't want to provide the user any choices to	*/
		/* select, except to to click on the dialog box button.				*/
		/* return GetResponse(statusline, szFileEmpty, BT_QUIT, 0) ; */
		ret = GetResponse(statusline, szFileEmpty, BT_FILESKIPQUIT, HELP_VIEWEMPTYFILE) ;

		/* Mark that we are not in ViewFile! Checked in WindProc!! */
		gpszFileOpCaption = NullString ;

		return ret ;
	}

	if (ViewFileSize >= ((unsigned) 32 << 10))
		h = 32 ;
	else
	if (ViewFileSize <= 1024)
		h = 1 ;
	else
		h =  (unsigned) ( (ViewFileSize - 1)/1024 + 1 ) ; 

	/*  lower bound need not exceed 4K bytes!! -- 1 page will fit in this! */
	if (h <= 4)
		l = h ;
	else
		l = 4 ; /* 4K is the minimum we want as it can fit 1 page of display */

	while (1)
	{
		/* try to get 4K or greater */
		VIEWBUFSIZE = AllocClosestTo1K(&v_buffer, l, h) ;

		if (!VIEWBUFSIZE)
		{
			if (!FreeUnusedFMMemory())
			{
				OutOfMemory() ;
				/* Mark that we are not in ViewFile! Checked in WindProc!! */
				gpszFileOpCaption = NullString ;
				return ACT_CANCEL ;
			}
			// else retry alloc, as we just freed some mem -- stay in while loop!
		}
		else
			break ; // Our alloc succeeded, proceed with ViewFile
	} /* while */	

	/* Note that we want to make sure that v_buffer can hold atleast
		GRANULARITY lines. Each line can be a max of (axMac+2) chars long!!
		We give ourselves a safety margin of GR_MARGIN in buffer */
	/* When we get a buffer of only 4K and filesize > 4K, GRANULARITY will
		be = 36. Even in this case, since OFFSETSIZE=60, we can have indexed
		access to start of the first 2160 (=36*60) lines of any file, which
		is very good by any standards */
	GRANULARITY = (VIEWBUFSIZE/(axMac+2)) - GR_MARGIN ;

	/* The help line for view at bottom of screen */
	MessageBar(szViewMessage, isaMenu,TRUE) ;

	glob.InFileMgr = FALSE;				// turn off list box updates

	MoveWindow(&ViewWind, 0, 2);
	SetWindowSize(&ViewWind, axMac, ayMac-3); // expand to full screen

	EnableWindow(&ViewWind, TRUE);

	// SetCapture(&ViewWind);

	/* Set menu bar to MainWind itself instead of ViewWind, as MainWind's
	 * WindProc routine draws boxes around popped down menus, etc. We
	 * don't want to duplicate that code here.
	 */
	setmenubar(&ViewMenuBar, &MainWind) ;

	/* ZZZZZ for some reason these accelerators don't work! */
	/* these is code in the WIndProc later to handle F1 key! -- Remove
	 * it when this is figured out.
	 */
	AddViewAccelerators();

	SetFocus(&ViewWind);
	/* BUG BUG WARNING THIS IS LAZY SLIME FROM BUSYDLG.C! */
	isup[0] = FALSE;
	isup[1] = FALSE;
	/***/

	return ACT_CANCEL;
} /* proc ViewFile */

extern void AddFileManAccelerators(void) ;
extern void RefreshFMScreen(BOOL erase);

void FAR WrapUpView(void)
{
	FreeWorkFar(v_buffer) ;

	/* ZZZZ No error checking done here */
	_dos_close(handle);

	/*
	 * Back to Filemanager state
	 */
	// ReleaseCapture();
	EnableWindow(&ViewWind, FALSE);
	EnableWindow(&MainWind, TRUE);
	SetWindowSize(&ViewWind, 0, 0);
	SetFocus(&MainWind);

	glob.InFileMgr = TRUE; // Turn on listBox updates!

	/* Put back file manager accelerators */
	AddFileManAccelerators() ;

	RefreshFMScreen(TRUE);
	/* Mark that we are not in ViewFile! Checked in WindProc!! */
	gpszFileOpCaption = NullString ;

} /* WrapUpView */

/* ZZZZZ  This proc is called from MainWind's WindProc also. It is called
 * by CW for WM_SETFOCUS and a few other messages. If we do a 
 * SetCapture(&ViewWind), then CW sends the mouse messages, etc but then
 * the View Menu Bar doesn't work!! So, the kludged way it has been got working
 * is to have the MainWind's WindProc to pass on its message to this routine
 * in case we are in "ViewFile". So these params are those sent to MainWind!
 * Thus the RX, RY, etc are relative to MainWind and not ViewWind!!!!
 */
long FAR PASCAL ViewWindProc(PWND pwnd, WORD message, WORD wParam,
																					DWORD lParam)
{
	long bufpos;						// offset of current page in v_buffer[]
	long oldcurline;
	int action;							// result of error handling
	BOOL update;						// time to print, or Beep
	int ret;							// dos call return
	long i;
	RX rx ;
	RY ry ;
	RRC rrcClient ;	/* temp */
	static WORD scroll_key = 0 ; /* the key to repeat when mouse held down! */
	WORD state ;

	update = FALSE ;

	switch (message)
	{
		case WM_SETFOCUS:
			GetClientRrc(&ViewWind,&rrcClient);
			FillRrc(&ViewWind,&rrcClient,' ',isaBackground);

			DisplayHeader(path);	// put some info at the top

			// FrameMenuBar doesn't care about window.
			FrameMenuBar(&MainWind) ;

			// open selected file
			do {
				action = ACT_OK;
				ret = _dos_open(path, O_RDONLY | SH_DENYWR, &handle);
				if (ret)
					action = DOSErrorBox(szErrorOpen, ret, HELP_VIEWOPEN);
			} while (action == ACT_RETRY);

			if ( (action == ACT_CANCEL) || (action == ACT_SKIP) )
			{
				WrapUpView() ;
				return TRUE ;
			}

			linesperpage = ayMac-LINESLOST;
			lastoffset = -1;
#ifdef DEBUG
			lastline = -1 ;
#endif
			curline = 0;					// first line of file
			bufbeginline = -1 ; /* Initialized with trash line number */

			/* default initializations */
			cachedfilepos = 0 ;
			cachedline = 0 ;

			/* Read in a page's worth.  Since curline == 0, this will contain
			** the correct page, whether the file is text or binary.
			*/
			bufpos = VerifyPage(curline, TRUE);

			/* Error during read? */
			if (bufpos == -3)
				return TRUE ;

			/* ZZZZZ Remove this Printable stuff if found not very useful! */
			// Determine whether it's a text file
			ascii = TRUE;
			for (i=0; i < 128 && i < buflen; i++)
			{
				if (!Printable(v_buffer[i]))
				{
					ascii = FALSE;
					break;
				}
			}
			DisplayPage(bufpos, linesperpage, ascii); // put onscreen
			break;
#if 0
		case WM_KILLFOCUS:
			/* ZZZ error checks not needed here?! */
			_dos_close(handle);

			ReleaseCapture();
			EnableWindow(&ViewWind, FALSE);
			SetWindowSize(&ViewWind, 0, 0);

			break;
#endif
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:

			ScrollPause(TRUE) ;

			rx = LOBYTE(lParam) ;
			ry = HIBYTE(lParam) ;
			wParam = 0 ; /* A dummy key -- a value that won't be set below */
			/*  (TITLE_RY+2) is the y-coord of the PgUp, PgDn Icons */
			if (ry == (TITLE_RY+2))
			{
				if ( (rx >= (RX)TITLE_RX+PGUPSTARTIND) && (rx < (RX)TITLE_RX+PGUPSTARTIND+PGUPLEN) )
					scroll_key = wParam = VK_PRIOR ;
				else
				if ( (rx >= (RX)TITLE_RX+PGDNSTARTIND) && (rx < (RX)TITLE_RX+PGDNSTARTIND+PGDNLEN) )
					scroll_key = wParam = VK_NEXT ;
				else
				if ( (rx >= (RX)TITLE_RX+LINEUPSTARTIND) && (rx < (RX)TITLE_RX+LINEUPSTARTIND+LINEUPLEN) )
					scroll_key = wParam = VK_UP ;
				else
				if ( (rx >= (RX)TITLE_RX+LINEDNSTARTIND) && (rx < (RX)TITLE_RX+LINEDNSTARTIND+LINEDNLEN) )
					scroll_key = wParam = VK_DOWN ;
				else
					scroll_key = 0 ;
			}
			else
			{
				scroll_key = 0 ;
			}
#if 0
// Following code handles mouse clicks on the bottom status line on the screen
// This refers to the Enter, ESC, F9 messages!
			else
			/* (ayMac-1) is the y-coord line that has the Enter, Esc, F9 line */
			if (ry == (ayMac-1))
			{
				/* Now figure out the coordinates of Enter, Esc, F9 */
				if ( (rx >= (RX) 2) && (rx <= (RX)10) )
					wParam = VK_NEXT ;
				else
				if ( (rx >= (RX)13) && (rx <= (RX)22) )
					wParam = ESCAPE ;
				else
				if ( (rx >= (RX)25) && (rx <= (RX)36) )
					wParam = VK_F9 ;
			}
#endif
			/* recursive call! -- send equivalent keyboard character message */
			if (wParam != 0) 
				ViewWindProc(pwnd, WM_CHAR, wParam, lParam) ;
			break ;

		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
			scroll_key = 0 ;
			break ;

		case WM_CHAR:
			oldcurline = curline ;
			state = HIWORD(lParam) ; /* state of the keyboard's shift/alt/ctrl */

			switch (wParam)
			{
				case VK_HOME:
					if (curline > 0)
					{
						/* ZZZZZ fix this to prevent re-reading disk on HOME key*/
						bufbeginline = -1 ;
						curline = 0 ;
						update = TRUE ;
					}
					break ;
				case VK_UP:
					if (curline > 0)
					{
						curline--;
						update = TRUE;
					}
					break;
				case VK_DOWN:
						curline++;
						update = TRUE;
					break;
				case VK_PRIOR:					// page up
					if (curline >= linesperpage)
					{
						update = TRUE;
						/* Scroll up 1 line less than a full page */
						curline -= (linesperpage-1) ;
					} else if (curline > 0)
					{
						update = TRUE;
						curline = 0;
					}
					break;
				case 13:  // ZZZZ enter also behaves like pagedown???
				case VK_NEXT:					// page down
					/* Scroll down 1 line less than a full page */
					curline += (linesperpage - 1) ;
					update = TRUE ;
					break ;
				case VK_ESCAPE:
				case ESCAPE:
					WrapUpView() ;
					return TRUE ;

				case VK_F5:
					if (state & KK_SHIFT)
					{
						DoFullRefresh() ;
					}
					return TRUE ;

				case VK_F1:
					HelpBox() ;
					return TRUE ;

				case VK_F9:					// toggle hex/ascii
					/* Ignore Shift+F9 and Ctrl+F9 and Alt+F9 */
					if (	(state & KK_CONTROL) || (state & KK_SHIFT) ||
							(state & KK_ALT) )
					{
						break ;
					}

					bufpos = VerifyPage(curline, ascii);

					/* Error during read? */
					if (bufpos == -3)
						return TRUE ;

#ifndef NOCONSISTENCY
					if (bufpos < 0)
					{
						printf("***VK_F9 -- bufpos = %d\n", bufpos) ;
						exit(0) ;
					}
#endif
					if (ascii)
					{
						ascii = FALSE;
						curline = (filepos+bufpos) / 16 ;
					} else
					{
						long l = 0;
						long goal ;

						goal = filepos+bufpos ;

						/* ZZZZ Hack to get repeated switching between modes
							working correctly -- If cachedfilepos is not too
							far ahead make it the goal */
						if ( ( (cachedfilepos-goal) >= 0 ) && 
								( (cachedfilepos-goal) < 16 ) )
							goal = cachedfilepos ;
						else
						{

							/* If our goal is too close to EOF -- we should
								move back atleast 1 line from EOF! In worst
								case it will be axMac chars followed by \r, \l*/
							if ( goal > ((ViewFileSize-1) - (axMac+2)) )
							{
								goal = (ViewFileSize-1) - (axMac+2) ;
								if (cachedfilepos > goal)
									goal = cachedfilepos ; 
							}
							else
								/* case when we are too close to file start
									and say there is just 1 long line 
									in file. We don't want to hit EOF!! */
								if (goal < (axMac+2))
									goal = 0 ;
						}
						// Get to within GRANULARITY lines of the same offset.
						ascii = TRUE;
						curline = 0;
						for (i=0; i <= lastoffset; i++)
						{
							if (l+offsets[i] <= goal)
							{
								l += offsets[i];
								curline += GRANULARITY;
							} else
								break;
						}
						
						// Get to within one line of the same offset.
						if (l < goal)
						{
							if ((goal >= cachedfilepos) && (cachedfilepos > l))
							{
								curline = cachedline ;
							}
							/* Dummy first argument */
							bufpos = VerifyPage(curline, ascii);

							/* Error during read? */
							if (bufpos == -3)
								return TRUE ;

							/* if goal is same as cachedfilepos, fn VerifyPage
								would have loaded it correctly, else we need
								to do the following loop! */
							if (goal != cachedfilepos)
							{
								do {
									i = SeekFwd(bufpos, (long)1);
#ifndef NOCONSISTENCY
					if (bufpos == -2)
					{
						printf("***goal reaching -- bufpos = %d\n", bufpos) ;
						exit(0) ;
					}
#endif
									if (i != -1)
									{
										bufpos = i;
										curline++;
									}
									else
									{
										/* Dummy first argument */
										bufpos=VerifyPage(curline, ascii);

										/* Error during read? */
										if (bufpos == -3)
											return TRUE ;
									}
								} while (filepos+bufpos < goal);
							}
						} /* if part of reaching goal */
					} /* else part of switching view modes */
					update = TRUE;
					break;

				default:
					break ;
			}

			if (update)
			{
				update = FALSE;
				bufpos = VerifyPage(curline, ascii);

				/* Error during read? */
				if (bufpos == -3)
					return TRUE ;

				if (bufpos == -2)
				{
					curline = oldcurline ;
					Shell_Beep() ;
					return TRUE ;
				}

#ifndef NOCONSISTENCY
				if (bufpos == -1)
				{
					printf("***ViewFile-- bufpos = -1\n") ;
					exit(0) ;
				}
#endif

				DisplayPage(bufpos, linesperpage, ascii);
			}
			else
				Shell_Beep() ;

			break ;

		case WM_MOUSEIDLE:
			if (scroll_key != 0)
			{
				/* Delayed scroll repetition */
				if (ScrollPause(FALSE))
					ViewWindProc(pwnd, WM_CHAR, scroll_key, (DWORD)0) ;
			}
			break ;

	} /* message switch */

	return TRUE ;
} /* proc ViewWindProc */

/****	VerifyPage - load in the appropriate page if it's not already in memory
**
**	ENTRY
**			the_line - first line of the page you want
**			ascii    - TRUE for ascii display mode, FALSE for hex mode
**	EXIT
**		Returns the offset of the page within v_buffer[].
*/
long FAR VerifyPage(long line, BOOL ascii)
{
	long begin;				// file position of page start
	long end;				// file position of page end
	int i;					// counter

	if (!ascii)
	{
		long tbegin ;

		// hex display lines are always 16 bytes long - very easy.
		begin = line * 16;

		if (begin >= ViewFileSize)
		{
			return -2 ;
		}

		end = begin + linesperpage * 16;

		if (end >= ViewFileSize)
			end = ViewFileSize-1 ;

		if (begin < filepos || end >= filepos+buflen)
		{
			/* tbegin is used to determine where to start loading data
				from the file */
			tbegin = begin ;
			if ( tbegin < filepos )
			{
				/* seeking backwards -- Keep it so that we keep the location we
					want -- (i.e., old value of begin) in the middle of
					buffer so that scanning further backward won't necessarily
					touch the disk */
				tbegin = tbegin - VIEWBUFSIZE/2 ;
				if (tbegin < 0)
					tbegin = 0 ;
			}

			/* load so that we don't waste buffer space when close to EOF */
			if (tbegin > (ViewFileSize-VIEWBUFSIZE+1))
				tbegin = ViewFileSize-VIEWBUFSIZE+1 ;

			// Load in desired chunk.
			if (!ViewRead(tbegin))
				return -3; /* junk value */
			/* trash the v_buffer line information as we are in hex mode */
			/* It is quite a pain to keep track of line info in hex mode */
			/* It will slow down hex mode unnecessarily. The assumption is */
			/* that too many view mode switches won't happen. */
			bufbeginline = -1 ;
		}
		return (begin - filepos);
	} else
	{
		long bufpos;				// current point in v_buffer
		long tbufpos ;
		long templine ;
		long prevoffset;		// old file position

		/* First check to see if requested page is within our v_buffer */
		/* if so we don't have to hit the disk, else we need to load in */
		/* data from the disk */
		if ( (bufbeginline != -1) && (bufbeginline <= line) )
		{
			/* Requested line could be in our v_buffer */
			if (line == bufbeginline)
				return (long) 0 ;
		
			if (line == buffocusline)
				return buffocuspos ;

			/* buffocusline is >= buf beginline, so we should start at 
				buffocusline, if possible!! */
			if (line > buffocusline)
			{
				templine = buffocusline ;
				bufpos = buffocuspos ;
			}
			else
			{
				templine = bufbeginline ;
				bufpos = 0 ;
			}
			bufpos = SeekFwd(bufpos, line-templine) ;
			if (bufpos == -2)
				return -2 ;

			if (bufpos != -1)
			{
				/* v_buffer has the start of 'line' */
				/* now check to see if this whole page is in memory */
				tbufpos = SeekFwd(bufpos, (long) linesperpage) ;
				if (tbufpos != -1)
				{
					/* -2 is also acceptable as full page is in v_buffer */
					buffocusline = line ;
					buffocuspos = bufpos ;

					return buffocuspos ;
				}
				/* else 'line' begins in v_buffer but full page not present */
				/* ZZZZ Maybe we should load starting at this line here instead
					of flowing thru to the code below */
			}
			/* else 'line' starts beyond our v_buffer */ 
		} 
		/* else 'line' is in fileposition prior to what v_buffer holds */

		/* If the requested line is within the area we have covered before,
		** the offset can be found directly, modulo GRANULARITY.  Otherwise,
		** we need to count forward from the last offset entry a line at a
		** time, making sure to load new data into v_buffer when necessary.
		*/
		if (line < (lastoffset+1) * GRANULARITY)
		{
			// Go to nearest anchor point before desired line.
			bufbeginline = filepos = 0;
			for (i=(int)(line/GRANULARITY)-1; i >= 0; i--)
			{
				bufbeginline += GRANULARITY ;
				filepos += offsets[i];
			}
			if (!ViewRead(filepos))
				return -3; /* junk value */

			buffocusline = bufbeginline ;
			buffocuspos = 0 ;

			/* Manually count out the remaining lines.  The desired start line
			** will be in the v_buffer because it is less than GRANULARITY lines
			** from the start; this is why v_buffer[] must be big enough to store
			** GRANULARITY lines.
			*/
			bufpos = SeekFwd((long) 0, (long) (line % GRANULARITY));

#ifndef NOCONSISTENCY
			if (bufpos < 0)
			{
				printf("*** Within granularity -- bufpos = %d\n", bufpos) ;
				exit(0) ;
				// return -2 ;
			}
#endif
			tbufpos = SeekFwd(bufpos, (long) linesperpage) ;
			if (tbufpos != -1)
			{
				/* -2 is also acceptable */
				buffocusline = line ;
				return (buffocuspos = bufpos) ;
			}
			/* else page starts in our buffer but full page doesn't exist */
			/* so load so that this page begins our buffer */

			lseek(handle, bufpos+filepos, SEEK_SET);
			filepos += bufpos;
			
			if (!ViewRead(filepos))
				return -3; /* junk value */

			/* We don't store the cachedfilepos, cachedline here as we are
				still within our array of offsets!! */

			bufbeginline = buffocusline = line ;

			return (buffocuspos=0) ;
		} else
		{
			long next;				// next line offset
			long anchorline;

			// Go to last anchor point.
			filepos = 0;

			for (i=lastoffset; i >= 0; i--)
				filepos += offsets[i];

			anchorline = (1+lastoffset) * GRANULARITY;
			if  ( (line > anchorline) && (lastoffset >= OFFSETSIZE-1) &&
						(cachedline <= line) )
			{
				anchorline = cachedline ;
				filepos = cachedfilepos ;
			}

			if (!ViewRead(filepos))
				return -3; /* junk value */

			bufbeginline = buffocusline = anchorline ;
			buffocuspos = 0 ;

			prevoffset = filepos;

			/* Count forward the remaining lines.  We may need to read in new
			** data.
			*/
			if (line > anchorline)
			{
				long bufposline = 0;

				bufpos = 0;					// start at beginning of v_buffer
				do {
					next = SeekFwd(bufpos, (long)1);
					if ( next == -2 )
					{
						/* EOF reached */
#ifdef DEBUG
						lastline = anchorline+bufposline;
#endif
						return -2 ;
					}
					if (next == -1)			// overflowed v_buffer
					{
						if (!ViewRead(bufpos+filepos))
							return -3; /* junk value */
						bufbeginline = buffocusline = (anchorline+bufposline);
						buffocuspos = 0 ;
						bufpos = 0;
						next = SeekFwd((long) 0, (long) 1); // 1 line fwd

#ifndef NOCONSISTENCY
						if (next < 0)
						{
							printf("*** Seeking shouldn't return %d\n", next) ;
							exit(0) ;
						}
#endif

					}
					bufpos = next;
					
					/* If we just crossed a new anchor point, record the file
					** position.  Don't record if it would overflow the table.
					*/
					if (++bufposline % GRANULARITY == 0 && lastoffset < OFFSETSIZE-1)
					{
						offsets[++lastoffset] = (unsigned) (filepos + bufpos - prevoffset);
						prevoffset = filepos + bufpos;
					}
				} while (line > anchorline+bufposline);

				/* Have located offset of requested line. If a full page
					is present in buffer starting here, we don't have to
					reload data from disk! */
				tbufpos = SeekFwd(bufpos, (long)linesperpage) ;
				if (tbufpos != -1)
				{
					/* -2 is also acceptable */
					buffocusline = line ;
					cachedline = line ;
					cachedfilepos = filepos+bufpos ;
					return (buffocuspos = bufpos) ;
				}
				/* else page starts in our buffer but full page doesn't exist */
				/* so load so that this page begins our buffer */

				if (!ViewRead(bufpos+filepos))
					return -3; /* junk value */

				bufpos = 0;

				/* store this line info in our cache for future use! */
				cachedline = line ;
				cachedfilepos = filepos ;
			}
			bufbeginline = buffocusline = line ;
			return (buffocuspos = 0) ;
		} /* else part of out of array offsets */
	} /* else part of text mode */
} /* proc VerifyPage */

/****	SeekFwd - count forward the given number of lines in the v_buffer
**
**	ENTRY
**			bufpos - offset of start of current line (in v_buffer[])
**			lines  - number of lines to move forward
**	EXIT
**		Returns the offset of the new line, or -1 if the given line is not
**	completely contained in v_buffer[], or -2 if EOF is reached.
*/
long FAR SeekFwd(bufpos, lines)
long bufpos;
long lines;
{
	unsigned char far *p = v_buffer+bufpos;		// ptr to step through v_buffer
	unsigned char far *boundary = v_buffer+buflen;// end of useful v_buffer data
	long curline = 0;						// which line are we on now
	int curchar = 0;						// character position

#ifndef NOCONSISTENCY
	if (bufpos < 0)
	{
		printf("***SeekFwd called with bufpos = %d\n", bufpos) ;
		exit(0) ;
	}
#endif
	
	/* seeking forward 0 lines leves you at the same line position */
	if (lines == (long) 0)
		return bufpos ;

	while (p < boundary)
	{
		if (lines <= curline)
			break;

		switch (*p)
		{
			case KEY_TAB:
				curchar += TABSIZE - (curchar % TABSIZE); // move to next tab stop
				break;
			case KEY_CR:
				curchar = 0;
				curline++;
				if (p[1] == KEY_LF)			// skip over newline after cr
					p++;
				break;

#if 0
/* ZZZZZZ KEY_LF is treated as just another control character */
			case KEY_LF:	// LF is treated as CR-LF
				curchar = 0;
				curline++;
				break;
#endif

			default:
#ifdef DBCS
				if (IsDBCSLeadByte(*p))
				{
					if (curchar+1 < axMac)
					{
						curchar++;
						p++;
					}
					else
					{
						curchar = 0;
						curline++;
						p--;
					}
				}
#endif
				curchar++;
				break;
		}
		p++;
		
		if (curchar >= axMac)
		{
			/* ZZZZZ possible bug when running off boundary! Note: DisplayPage
				handles this correctly. But we can't do it here as we may
				not have cushion space at the end of v_buffer! */
			if ( (*(p-1) != KEY_CR) && (*(p-2) != KEY_CR) )
			{
				/* We ran out of the screen boundary but without seeing
				a newline or CR. So If we now see a nl or CR skip past
				them */
				if (*p == KEY_CR)
				{
					p++ ;
					if (*p == KEY_LF)
						p++ ;
				}
			}
			curchar = 0;
			curline++;
		}
	} /* while */
	if (curline == lines) 
	{
		if ( (p >= boundary) && ((filepos+buflen) >= ViewFileSize) )
			/* the current line (terminated by nl or cr) ends exactly at EOF */
			return -2 ;
		else
			/* If I don't do the following casting, the compiler would
			 * generate the wrong code for the return value. The boundary
			 * case is when (p-v_buffer) is exactly = 8000h in which case
			 * the return value generated is FFFF8000h (as the compiler
			 * generates a CWD instruction). I am guaranteed that the buffer
			 * we use does not exceed 32K bytes.
			 */
			return ((long) ( (unsigned) (p-v_buffer)) );
	}
	else
	{
		if ( (filepos+buflen) >= ViewFileSize )
			/* current line is terminated by EOF */
			return -2 ;
		else
			return -1;
	}
} /* proc SeekFwd */

#ifdef CLONEVIEW
	#define HexModeDispChar(c) ( isalnum(c) ? (c) : KEY_FILLER )
	#define NormalModeDispChar(c) ( (((c) >= 32) && ((c) < 127) ) ? (c) : ' ' )
#else
	#define HexModeDispChar(c) ( ((c) >= 32) ? (c) : KEY_FILLER )
	#define NormalModeDispChar(c) ( ((c) >= 32)  ? (c) : ' ' )
#endif

/****	DisplayPage - put a page of the file onscreen
**
**	ENTRY
**			bufpos - starting position of the page
**			lines  - number of lines to display
**			ascii  - TRUE to display in ASCII mode, FALSE for hex mode
**	EXIT
**			none
*/
void FAR DisplayPage(bufpos, lines, ascii)
long bufpos;
RY lines;
BOOL ascii;
{
	unsigned char line[1+MAXCOLS];			// image of the current line
	unsigned char far *p = v_buffer+bufpos;		// ptr to step through v_buffer
	RY curline = 0;							// which line are we on now
	int byteidx;							// index of byte w/in row (hex only)
	unsigned char *linep = line;			// ptr within line[]
	unsigned char far *boundary = v_buffer+buflen;// far edge of valid v_buffer chars
	BOOL print = FALSE;						// time to print the line
	BOOL newline = FALSE;					// new line; form file position
	int i;									// junk integer

#ifdef DBCS
	int	dbcs_flag = 0;
	BOOL	dbcs_adj = FALSE;
#endif

	FEnableMouseNest(FALSE) ;

	if (ascii)
	{
		
		if (buflen < VIEWBUFSIZE)
		{
			/* The v_buffer is not full! We always try to read VIEWBUFSIZE 
				characters from start. Note that v_buffer beginning is a line
				beginning in ASCII mode! Also note that v_buffersize is atleast
				1 page big with a few extra bytes (atleast 2)  of 
				cushioning!! */
			/* The following initializations saves us on look aheads like p[1],
			etc when we are at boundaries!! */
			v_buffer[buflen] = v_buffer[buflen+1] = 0 ; /* any value that is not
										a KEY_LF or KEY_CR */
		}

		while (p < boundary)
		{
			if (curline >= lines)
				break;

			switch (*p)
			{
				case KEY_TAB:
					byteidx = TABSIZE - ((linep-line) % TABSIZE);
					for (i=0; i < byteidx; i++)
						*(linep++) = ' ';
					break;
				case KEY_CR:
#ifdef OUR_LF
				case KEY_LF:
#endif
					// This handles lines ending in cr, lf, and cr/lf.
					if (*p == KEY_CR && p[1] == KEY_LF)
						p++;
					print = TRUE;
					break;
				default:
#ifdef DBCS
					if (IsDBCSLeadByte(*p))
					{
						if (linep-line+1 < axMac)
						{
							*(linep++) = *p;
							p++;
							*(linep++) = *p;
						}
						else
						{
							*(linep++) = ' ';
							p--;
						}
					}
					else
#endif
					*(linep++) = NormalModeDispChar(*p) ;
					break;
			}
			p++;

			if (linep-line >= axMac)		// line is running off screen
			{
				if ( (*(p-1) != KEY_CR) && (*(p-2) != KEY_CR) )
				{
					/* Screen boundary determined the end of this line.
					If we now find a nl or CR skip past them */
					if (*p == KEY_CR)
					{
						p++ ;
						if (*p == KEY_LF)
							p++ ;
					}
				}
				print = TRUE;
			}
			if (p >= boundary)				// ready to exit loop
				print = TRUE;

			if (print)
			{
				print = FALSE;
				while (linep-line < axMac)
					*(linep++) = ' ';
				TextOut(&ViewWind, 0, curline+FILETEXTY, line, axMac, 0);
			 	curline++;
				linep = line;
			}
		} /* while */
	} else
	{
		// Hex display.  Init the fixed characters in line.
		for (linep=line; linep < (line+axMac); linep++)
			*linep = ' ' ;
		line[0] = line[11] = line[79] = line[58] = VERTLINE;
		*linep = EOS;

		newline = TRUE;
		while (p < boundary)
		{
			if (curline >= lines)
				break;
			if (newline)
			{
				long l;

				newline = FALSE;
				l = filepos + (p-v_buffer);	// file position of current byte
				for (i=6; i >= 1; i--)		// show current position in file
				{
					line[2+i] = HexDigit(l % 16);
					l /= 16;
				}
				byteidx = 0;
				linep = line+14;
			}
			
#ifdef DBCS
			if (dbcs_flag == 1)
				dbcs_flag++;
			else
				dbcs_flag = IsDBCSLeadByte(*p) ? 1 : 0;
#endif
			
			*linep++ = HexDigit(*p / 16);
			*linep++ = HexDigit(*p % 16);
			if (byteidx % 4 == 3)
				linep += 3;
#ifdef DBCS
			if (!dbcs_adj)
				line[61+byteidx] = HexModeDispChar(*p) ;
			else
			{
				line[61+byteidx] = ' ';
				dbcs_adj = FALSE;
			}
#else
			line[61+byteidx] = HexModeDispChar(*p) ;
#endif
			byteidx++;
			p++;
			if (byteidx >= 16)
			{
#ifdef DBCS
				if (dbcs_flag == 1)
				{
					line[61+byteidx] = HexModeDispChar(*p) ;
					dbcs_adj = TRUE;
				}
				else
					line[61+byteidx] = ' ';
#endif
				byteidx = 0;
				TextOut(&ViewWind, 0, curline+FILETEXTY, line, axMac, 0);
				curline++;
				newline = TRUE;
			}
		} /* while */

		// Finish the last line and print it.
		if (byteidx)
		{
			linep = line+14+2*byteidx+3*(byteidx/4);
			while (byteidx < 16)
			{
				*linep++ = ' ';
				*linep++ = ' ';

				if (byteidx % 4 == 3)
					linep += 3;
				line[61+byteidx] = ' ';
				byteidx++;
			}
			TextOut(&ViewWind, 0, curline+FILETEXTY, line, axMac, 0);
			curline++ ;
		}
	} /* Hex mode */

	// clear any lines which were not drawn (occurs only at EOF)
	if (curline < lines)
	{
		for (linep=line+axMac-1; linep >= line; linep--)
			*linep = ' ';
		if (!ascii)
		{
			line[0] = line[11] = line[79] = line[58] = VERTLINE;
		}
		do {
			TextOut(&ViewWind, 0, curline+FILETEXTY, line, axMac, 0);
		} while (++curline < lines);
	}

	FEnableMouseNest(TRUE) ;

} /* proc DisplayPage */

/****	DisplayHeader - display the header for the File...View command
**
**	ENTRY
**			file - path of file to display
**	EXIT
**			none
*/

#define BOX_MARGIN 1

VOID FAR DisplayHeader(char *file)
{
	unsigned len ;
	char szViewTitle[64] ;
	int filenamestart ;
	int i ;
	char blanks[91] ;

#if 0
	char statusline[STATUS_LEN] ;
#endif

	assert(axMac < 91) ;

	for (i=0 ; i < axMac ; i++)
	{
		blanks[i] = ' ' ;
	}

	/* Note that this box needs to be drawn before the header lines in text
	 * mode and after the header lines in graphics mode because of the top line
	 * getting screwed up!
	 */
	// if (!gisgraph)
	// {
	    EasyDrawBox(&ViewWind, TITLE_RY, 0, TITLE_RY+2, axMac, 0) ;
		 /* Now erase the top line in this box, as it looks bad, when
		  * we put our text message on this line.
		  */
		 TextOut(&ViewWind, (RX)BOX_MARGIN, TITLE_RY, blanks, axMac-(BOX_MARGIN*2), 0) ; 
	// }

	len = strlen(szViewFileMsg1) ;

	FEnableMouseNest(FALSE) ;

	TextOut(&ViewWind, TITLE_RX, TITLE_RY, szViewFileMsg1, -1, 0);

#if 0
	FormStringStatusLine(statusline, szOpViewFile, file, STATUS_LEN) ;
	TextOut(&ViewWind, TITLE_RX, TITLE_RY+2, statusline, -1, 0);
#else
	/* Now, form the ViewFile title --- "DOSShell - filename" */
	strcpy(szViewTitle, szDOSShellTitle) ;
	len = strlen(szViewTitle) ;
	szViewTitle[len++] = (char) ViewTitleSep ;
	szViewTitle[len++] = ' ' ;

	filenamestart = FindLastComponent(file) ;
	if (file[filenamestart] == '\\')
		filenamestart++ ;

	strcpy(szViewTitle+len, file+filenamestart) ;

	/* we need to add a trailing blank, as we have a leading blank */
	len = strlen(szViewTitle) ;
	szViewTitle[len++] = ' ' ;
	szViewTitle[len] = '\0' ;

	UpdateMainTitleBar(szViewTitle) ;
#endif

	FEnableMouseNest(TRUE) ;

#if 0
	if (gisgraph)
	{
		FrameCharRect(TITLE_RY+2, 0, TITLE_RY+4, axMac, 1,isaBackground) ;
	}
#endif

} /* fn DisplayHeader */

/* This function is invoked from the menu to display file in Hex Mode! */
VOID HexFileView(void)
{
	/* This fn should not be called if already in Hex mode! */
	/* The menu should be disabled!!								  */
	assert(ascii) ;

	/* Basically, toggle file view!! -- treat like F9 from key board! */
	ViewWindProc(&ViewWind, WM_CHAR, VK_F9, (DWORD)0) ;
} /* HexFileView */

/* This function is invoked from the menu to display file in ASCII Mode! */
VOID AsciiFileView(void)
{
	/* This fn should not be called if already in ASCII mode! */
	/* The menu should be disabled!!								    */
	assert(!ascii) ;

	/* Basically, toggle file view!! -- treat like F9 key from keyboard! */
	ViewWindProc(&ViewWind, WM_CHAR, VK_F9, (DWORD)0) ;
} /* AsciiFileView */

VOID ExitFileView(void)
{
	/* Basically, treat like ESC key from keyboard! */
	ViewWindProc(&ViewWind, WM_CHAR, VK_ESCAPE, (DWORD)0) ;
} /* ExitFileView */

BOOL ViewRead(long start_fpos)
{
	int action, ret ;
	BOOL do_lseek = TRUE ;
	BOOL read_attempted = FALSE ;

	do
	{
		if (do_lseek)
		{
			if (lseek(handle, start_fpos, SEEK_SET) != -1L)
			{
				ret = 0 ; /* succesful lseek */
				filepos = start_fpos ;
				do_lseek = FALSE ;
			}
			else
				ret = errno ;
		}
		else
		{
			ret = _dos_read(handle, v_buffer, VIEWBUFSIZE, &buflen);
			read_attempted = TRUE ;
		}

		if (ret)
			action = DOSErrorBox(szReadError, ret, HELP_VIEWREAD);
		else
			action = ACT_OK ;

	/* Keep retrying, if action is ACT_RETRY or if the lseek was succesful
	 * (in which case do_lseek would be FALSE) and read has not yet been
	 * attempted.
	 */
	} while ( (action == ACT_RETRY) || ((!do_lseek) && (!read_attempted)) );

	if (action != ACT_OK)
	{
		WrapUpView() ;
		return FALSE ; 
	}
	return TRUE ;
} /* fn ViewRead */

void RefreshViewFileScreen(BOOL fClearAndRedraw)
{
	RRC rrcClient ;
	long bufpos ;

	if (fClearAndRedraw)
	{
		GetClientRrc(&ViewWind,&rrcClient);
		FillRrc(&ViewWind,&rrcClient,' ',isaBackground);

		DisplayHeader(path);	// put some info at the top

		// FrameMenuBar doesn't care about window.
		FrameMenuBar(&MainWind) ;
	}

	bufpos = VerifyPage(curline, ascii) ;

	if (bufpos == -3)
		return ;

	DisplayPage(bufpos, linesperpage, ascii) ;

} /* RefreshViewFileScreen */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\winidle.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;  Tell forces greater than ourselves that we are idle so we
;  don't pig up system time doing nothing. 1680 call is for
;  Windows 3.0+ and OS/2, int 28 for TSRS, and int 15 is for
;  power savings(see PC convertible tech ref)
;

?WIN = 0                ;Not windows;
?PLM = 1                ;DO use pl/m
include cmacros.inc

sBegin data
sEnd data

sBegin code
    assumes cs, code
    assumes ds, data

cProc  GlobalIdle, PUBLIC , <si,di,ds,es>
cBegin  GlobalIdle
	;;; do windows and dos idle calls.
	;;; BX,CX are only filled in as signatures just in case
	;;; some-one needs to know
	mov bx,0FEEDh
	mov cx,0FACEh
	mov ax,1680h
	int 2Fh
	mov bx,0FEEDh
	mov cx,0FACEh
	int 28h
	;;;Power down
	mov ax,4100h ;;; wait until any event
	xor bx,bx    ;;; no time limit
	int 15h
	
cEnd  GlobalIdle
sEnd   code
end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\pdb.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;
; MSDOS 2.xx Process Data Block
;
;   Contains all DOS specific data.
;

FilPerProc      EQU     20

; Process Data located in the Program Segment Prefix, just before the
; code and data for the loaded program.
;
; This IS the whole PSP
;
PDB             STRUC
PDB_Exit_Call   DW  ?
PDB_block_len   DW  ?
                DB  ?
PDB_CPM_Call    DB  5 DUP (?)
PDB_Exit        DD  ?
PDB_Ctrl_C      DD  ?
PDB_Fatal_Abort DD  ?
PDB_Parent_PID  DW  ?
PDB_JFN_Table   DB  FilPerProc DUP (?)
PDB_environ     DW  ?
PDB_User_stack  DD  ?
PDB_JFN_Length  DW  ?               ; DOS 3.x only
PDB_JFN_Pointer DD  ?               ; DOS 3.x only
PDB_Next_PDB    DD  ?               ; DOS 3.x only
PDB_PAD1        DB  06h DUP (?)
PDB_Chain       DW  ?               ; Windows only
PDB_Partition   DW  ?               ; Windows only
PDB_NextPDB     DW  ?               ; Windows only
PDB_GlobalHeap  DD  ?               ; Windows only
PDB_Entry_stack DD  ?               ; Windows only
PDB_Call_system DB  5h DUP (?)
PDB_PAD2        DB  7h DUP (?)
PDB_5C_FCB      DB  10h DUP (?)
PDB_6C_FCB      DB  14h DUP (?)
PDB_DEF_DTA     DB  80h DUP (?)
PDB             ENDS


; system file table
;
SFT             STRUC
sftLink         DD      ?
sftCount        DW      ?               ; number of entries
sftFile 	DB	?		; start of entries
SFT             ENDS

; Following SFT Entry structure taken from DOS 4 sources, but used offsets
; are compatible with DOS 3.1+

SFT_ENTRY	STRUC
sf_ref_count	DW	?		; number of processes sharing entry
					;   if FCB then ref count
sf_mode 	DW	?		; mode of access or high bit on if FCB
sf_attr 	DB	?		; attribute of file
sf_flags	DW	?		;Bits 8-15
					; Bit 15 = 1 if remote file
					;	 = 0 if local file or device
					; Bit 14 = 1 if date/time is not to be
					;   set from clock at CLOSE.  Set by
					;   FILETIMES and FCB_CLOSE.  Reset by
					;   other reseters of the dirty bit
					;   (WRITE)
					; Bit 13 = Pipe bit (reserved)
					;
					; Bits 0-7 (old FCB_devid bits)
					; If remote file or local file, bit
					; 6=0 if dirty Device ID number, bits
					; 0-5 if local file.
					; bit 7=0 for local file, bit 7
					;      =1 for local I/O device
					; If local I/O device, bit 6=0 if EOF (input)
					;		Bit 5=1 if Raw mode
					;		Bit 0=1 if console input device
					;		Bit 1=1 if console output device
					;		Bit 2=1 if null device
					;		Bit 3=1 if clock device
sf_devptr	DD	?		; Points to DPB if local file, points
					; to device header if local device,
					; points to net device header if
					; remote
sf_firclus	DW	?		; First cluster of file (bit 15 = 0)
sf_time 	DW	?		; Time associated with file
sf_date 	DW	?		; Date associated with file
sf_size 	DD	?		; Size associated with file
sf_position	DD	?		; Read/Write pointer or LRU count for FCBs
;
; Starting here, the next 7 bytes may be used by the file system to store an
; ID
;
sf_cluspos	DW	?		; Position of last cluster accessed
sf_dirsec	DD	?		; Sector number of directory sector for
					; for this file
sf_dirpos	DB	?		; Offset of this entry in the above
;
; End of 7 bytes of file-system specific info.
;
sf_name 	DB	11 DUP (?)	; 11 character name that is in the
					; directory entry.  This is used by
					; close to detect file deleted and
					; disk changed errors.

; SHARING INFO
sf_chain	DD	?		; link to next SF
sf_UID		DW	?
sf_PID		DW	?
sf_MFT		DW	?
sf_lstclus	DW	?		;AN009; Last cluster accessed
sf_IFS_HDR	DD	?
SFT_ENTRY	ENDS

DPB     STRUC
dpb_drive       DB      ?       ; Logical drive # assoc with DPB (A=0,B=1,...)
DPB     ENDS

devid_device	EQU	0080H	; true if a device
sf_isnet	EQU	8000H	; true if network drive

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\int31.inc ===
;******************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989-1991
; *                      All Rights Reserved.
; */

;
;
;   Title:	INT31.INC - Equates and Structures for Int 31h Interface
;
;   Version:	3.00
;
;   Date:	22-May-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-May-1989 RAL Original
;
;==============================================================================



Int31_Sel_Mgt		EQU	00h
    SelMgt_Alloc_Sel	EQU	00h
    SelMgt_Free_Sel	EQU	01h
    SelMgt_Seg_To_Sel	EQU	02h
    SelMgt_Get_LDT_Base EQU	03h
    SelMgt_Lock_Sel	EQU	04h
    SelMgt_Unlock_Sel	EQU	05h
    SelMgt_Get_Base	EQU	06h
    SelMgt_Set_Base	EQU	07h
    SelMgt_Set_Limit	EQU	08h
    SelMgt_Set_Acc_Bits EQU	09h
    SelMgt_Alias_Sel	EQU	0Ah
    SelMgt_Get_Desc	EQU	0Bh
    SelMgt_Set_Desc	EQU	0Ch
    SelMgt_Get_Spec_Sel EQU	0Dh

Int31_DOS_Mem_Mgt	EQU	01h
    DOSMem_Allocate	EQU	00h
    DOSMem_Free 	EQU	01h
    DOSMem_Resize	EQU	02h

Int31_Int_Serv		EQU	02h
    Int_Get_Real_Vec	EQU	00h
    Int_Set_Real_Vec	EQU	01h
    Int_Get_Excep_Vec	EQU	02h
    Int_Set_Excep_Vec	EQU	03h
    Int_Get_PMode_Vec	EQU	04h
    Int_Set_PMode_Vec	EQU	05h

Int31_Trans_Serv	EQU	03h
    Trans_Sim_Int	EQU	00h
    Trans_Far_Call	EQU	01h
    Trans_Call_Int_Proc EQU	02h
    Trans_Call_Back	EQU	03h
    Trans_Free_CB	EQU	04h
    Trans_Get_Save_Addr EQU	05h
    Trans_Get_Sw_Addr	EQU	06h

Int31_Get_Version	EQU	04h

Int31_Mem_Mgt		EQU	05h
    MemMgt_Get_Info	EQU	00h
    MemMgt_Allocate	EQU	01h
    MemMgt_Free 	EQU	02h
    MemMgt_Resize	EQU	03h

Int31_Page_Lock 	EQU	06h
    Lock_Region 	EQU	00h
    Unlock_Region	EQU	01h
    Mark_Pageable	EQU	02h
    Mark_Not_Pageable	EQU	03h
    Get_Page_Size	EQU	04h

Int31_Demand_Page_Tune	EQU	07h
    Page_Candidate	EQU	00h
    Page_Discard	EQU	01h
    DPMI_Candidate	EQU	02h
    DPMI_Discard	EQU	03h

Int31_Map_Phys_Addr	EQU	08h

Int31_Virt_Int_State	EQU	09h
    Get_Clear_Int_State EQU	00h
    Get_Set_Int_State	EQU	01h
    Get_Int_State	EQU	02h


Real_Mode_Call_Struc	STRUC
RealMode_EDI	dd	?
RealMode_ESI	dd	?
RealMode_EBP	dd	?
		dd	?
RealMode_EBX	dd	?
RealMode_EDX	dd	?
RealMode_ECX	dd	?
RealMode_EAX	dd	?
RealMode_Flags	dw	?
RealMode_ES	dw	?
RealMode_DS	dw	?
RealMode_FS	dw	?
RealMode_GS	dw	?
RealMode_IP	dw	?
RealMode_CS	dw	?
RealMode_SP	dw	?
RealMode_SS	dw	?
Real_Mode_Call_Struc	ENDS


Real_Mode_Word_Regs	STRUC
RealMode_DI	dw	?
		dw	?
RealMode_SI	dw	?
		dw	?
RealMode_BP	dw	?
		dw	?
		dd	?
RealMode_BX	dw	?
		dw	?
RealMode_DX	dw	?
		dw	?
RealMode_CX	dw	?
		dw	?
RealMode_AX	dw	?
Real_Mode_Word_Regs	ENDS


Real_Mode_Byte_Regs	STRUC
		dd	4 dup (?)
RealMode_BL	db	?
RealMode_BH	db	?
		dw	?
RealMode_DL	db	?
RealMode_DH	db	?
		dw	?
RealMode_CL	db	?
RealMode_CH	db	?
		dw	?
RealMode_AL	db	?
RealMode_AH	db	?
Real_Mode_Byte_Regs	ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\grabber.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

;
; NAME
;	GRABBER.INC
;
; DESCRIPTION
;	This file defines various grabber entrypoints, functions, subfunctions
;	and constants shared by the grabbers and winoldap.
;
;	If defined, the following flags inhibit definition of the corresponding
;	symbols:
;
;	NO_STDGRABENTRY
;	NO_EXTGRABENTRY
;	NO_GRABINFO
;	NO_GRABREQUEST
;	NO_LC
;	NO_GRABBUF
;
; AUTHOR
;	Jim Christy
;
; HISTORY
;	1.00	060187	jhc	Epoch
;	1.01	100887	jhc	Added constants (DI_OLIVETTI and ST_SPECGRAB)
;				per Bill Hall's request at Olivetti.
;



;
; Define the offsets from the grabber code segment for the standard
; grabber entrypoints.	Used only by winoldap since grabbers create them.
;
			ifndef	NO_STDGRABENTRY
InquireGrab		=	000h
EnableGrab		=	003h
DisableGrab		=	006h
PromptGrab		=	009h		;OBSOLETE
InquireSave		=	00Ch
SaveScreen		=	00Fh
RestoreScreen		=	012h
InitScreen		=	015h		;OPTIONAL
			endif


			ifndef	NO_EXTGRABENTRY
;
; Define standard subfunction numbers for InquireGrab
;

GRAB_INQUIRETEXT	=	00001h
GRAB_INQUIREGRPH	=	00002h

MAX_STDCALL		=	GRAB_INQUIREGRPH


;
; Define extended subfunction numbers for InquireGrab
;

GRAB_ENDPAINT		=	0FFF4h
GRAB_BEGINPAINT 	=	0FFF5h
GRAB_MARKBLOCK		=	0FFF6h
GRAB_PUTBLOCK		=	0FFF7h
GRAB_GETBLOCK		=	0FFF8h
GRAB_REALIZECOLOR	=	0FFF9h
GRAB_GETVERSION 	=	0FFFAh
GRAB_DISABLESAVE	=	0FFFBh
GRAB_ENABLESAVE 	=	0FFFCh
GRAB_SETSWAPDRIVE	=	0FFFDh
GRAB_GETINFO		=	0FFFEh
GRAB_GETID		=	0FFFFh

MIN_EXTCALL		=	GRAB_ENDPAINT
			endif


			ifndef	NO_GRABINFO
;
; GRABINFO STRUCTURE
;
;	The extended grabber call GRAB_GETINFO fills a structure provided by
;	Winoldap with the current video state information.  This information
;	can then be used by Winoldap to aid in mark/copy/paste operations, to
;	determine the current display adapter in use, etc.  All
;	non-dimensionless quantities are 1-based.
;

GrabInfo		struc
  giDisplayId		db	?		;see below
  giScrType		db	?		;see below
  giSizeX		dw	?		;X raster size in .1mm units
  giSizeY		dw	?		;Y raster size in .1mm units
  giCharsX		db	?		;# X char cells (columns)
  giCharsY		db	?		;# Y char cells (rows)
  giMouseScaleX 	db	?		;X transform for MS-MOUSE
  giMouseScaleY 	db	?		;Y transform for MS-MOUSE
  giReserved		db	38	dup (?)
GrabInfo		ends

GRABINFOLEN		=	SIZE GrabInfo


;
; Define codes for giDisplayId field in GrabInfo structure
;

DI_CGA			=	000h
DI_EGA			=	001h
DI_HERCULES		=	002h
DI_MULTIMODE		=	003h
DI_VGA			=	004h
DI_OLIVETTI		=	005h


;
; Define bitmaped codes for giScrType field in GrabInfo structure
;

ST_TEXT 		=	00000000b
ST_GRPH 		=	00000001b
ST_LARGE		=	00000010b
ST_SPECGRAB		=	00000100b
			endif


			ifndef	NO_GRABREQUEST
;
; GRABREQUEST STRUCTURE
;
;	Upon entry, all block operations expect es:di to point to a
;	GrabRequest structure of the format below.  Since not all fields are
;	used by some functions, field usage is detailed in the header for each
;	function.
;

GrabRequest		struc
  grlpData		dd	?		;long ptr to I/O buffer
  grXorg		db	?		;x origin (unsigned)
  grYorg		db	?		;y origin (unsigned)
  grXext		db	?		;x extent (unsigned)
  grYext		db	?		;y extent (unsigned)
  grStyle		db	?		;style flags
  grChar		db	?		;char code for fill ops
  grAttr		db	?		;attribute for fill ops
GrabRequest		ends

GRABREQUESTLEN		=	SIZE GrabRequest


;
; Define codes for fScreenOps field of GrabRequest.Style
;

SCR_OP_MASK		=	00000111b

F_BOTH			=	000h		;fill w/ single char and attr
F_CHAR			=	001h		;fill w/ single char only
F_ATTR			=	002h		;fill w/ single attr only
C_BOTH			=	003h		;copy chars and attrs from lpData
C_CHAR			=	004h		;copy chars only from lpData
C_ATTR			=	005h		;copy attrs only from lpData
C_CHAR_F_ATTR		=	006h		;copy chars from lpData, fill w/ attr
C_ATTR_F_CHAR		=	007h		;copy attrs from lpData, fill w/ char


;
; Define bitmapped codes for fFormat field of GrabRequest.Style
;

FORMAT_MASK		=	10000000b

FMT_NATIVE		=	00000000b
FMT_OTHER		=	10000000b


;
; Define error codes for block operations
;

ERR_UNSUPPORTED 	=	0FFh
ERR_BOUNDARY		=	0FEh
			endif


			ifndef	NO_LC
;
; Define logical colors for GRAB_REALIZECOLOR
;

LC_SELECTED		=	000h
LC_UNSELECTED		=	001h
LC_GRAYED		=	002h
LC_SELECTGRAY		=	003h
LC_TITLEBAR		=	004h
LC_SYSTEMUNSELECT	=	005h
LC_SYSTEMSELECT 	=	006h
LC_APPTITLE		=	007h
LC_MNEMONIC		=	008h

MAX_LC_COLOR		=	LC_MNEMONIC
			endif


			ifndef	NO_GRABBUF
;
; GRAB BUFFER STRUCTURE
;

GrabSt			struc
  gbType		dw	?		;see below
  gbSize		dw	?		;length (not including first four bytes)
  gbWidth		dw	?		;width of bitmap in pixels
  gbHeight		dw	?		;height of bitmap in raster lines
  gbPlanes		dw	?		;# of color planes in the bitmap
  gbPixel		dw	?		;# of adjacent color bits on each plane
  gbWidth2		dw	?		;width of bitmap in 0.1 mm units
  gbHeigh2		dw	?		;height of bitmap in 0.1 mm units
  gbBits		dw	?		;the actual bits
GrabSt			ends

GRABSTLEN		=	SIZE GrabSt


;
; Define codes for gbType field of GrabSt
;

GT_TEXT 		=	1
GT_OLDBITMAP		=	2
GT_NEWBITMAP		=	3
GT_RESERVED4		=	4
GT_RESERVED5		=	5


;
; Define alias fieldname in case of GT_OLDBITMAP
;

gbOldBits		equ	word ptr gbWidth2
			endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\dosx.inc ===
;******************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989-1991
; *                      All Rights Reserved.
; */
;
;
;   Title:	DOSX.INC - Equates and Structures for 286 DOS Extender
;			   Int 2Fh Interface
;
;   Version:	3.00
;
;   Date:	27-Jun-1989
;
;   Author:	JEM
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   27-Jun-1989 JEM Original
;
;==============================================================================


DOSXFunc	EQU	46h		;286 DOS Extender Int 2Fh Multiplex ID


; DOSX Int 2Fh subfunctions

DOSXQuery	EQU	00h		;Query DOS Extender installation
DOSXSuspend	EQU	01h		;Suspend Network posting call
DOSXResume	EQU	02h		;Resume Network posting call
DOSXAbort	EQU	03h		;Abort Child application call
DOSXInfo	EQU	04h		;Get Info structure pointer call

DOSXLast	EQU	DOSXInfo	;Last valid Int 2Fh request


; Structure returned in ES:BX by DOSXInfo call

DOSXInfoTbl	struc
DOSXInfoVer	dw	?		;version # of info structure
hXMSHeap	dw	?		;XMS handle to DOSX heap block
selAppBlk	dw	?		;1st selector to application memory blk
cbAppBlk	dd	?		;size in bytes of app memory block
ckReservedLow	dw	?		;size in K of low memory to reserve
DOSXInfoTbl	ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\typedefs.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*--------------------------------------------------------------------------*/
/*  General Purpose Defines															    */
/*--------------------------------------------------------------------------*/

#define NULL		    0
#define FALSE		    0
#define TRUE		    1

#define FAR		    	 far
#define NEAR		    near
#define LONG		    long
#define VOID		    void
#define PASCAL		    pascal


#define MAKELONG(a, b)	    ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)	    ((WORD)(l))
#define HIWORD(l)	    ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)	    ((BYTE)(((WORD)(w) >> 8) & 0xFF))

typedef int		   	  BOOL;
typedef unsigned char  BYTE;
typedef unsigned int	  WORD;
typedef unsigned long  DWORD;
typedef char near	    *PSTR;
typedef char near	    *NPSTR;
typedef char far	    *LPSTR;
typedef BYTE near	    *PBYTE;
typedef BYTE far	    *LPBYTE;
typedef int near	    *PINT;
typedef int far 	    *LPINT;
typedef WORD near	    *PWORD;
typedef WORD far	    *LPWORD;
typedef long near	    *PLONG;
typedef long far	    *LPLONG;
typedef DWORD near	 *PDWORD;
typedef DWORD far	    *LPDWORD;
typedef void far	    *LPVOID;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaarena.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file defines the structure for windows arena header and related       ;
; constants.								     ;
;----------------------------------------------------------------------------;

WinArena STRUC

ARENA_LOCK_COUNT	db	?	;arena lock count
ARENA_OWNER		dw	?	;owner of the arena
ARENA_SIZE		dw	?	;size in paragraphs
ARENA_FLAGS		db	?	;flag byte (type of block)
ARENA_PREV		dw	?	;selector for the previous arena
ARENA_NEXT		dw	?	;selector for next arena
ARENA_HANDLE		dw	?	;handle of the associated block
ARENA_FPREV		dw	?	;previous free arena
ARENA_FNEXT		dw	?	;next free arena

WinArena ENDS

SENTINNEL_ARENA		equ	-1	;sentinnel marker in owner field

;----------------------------------------------------------------------------;	

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1991
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woagrab.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; define the function number for the grabber calls that we need.	     ;
;----------------------------------------------------------------------------;

; main functions

GR_INQUIREGRAB		equ	0
GR_ENABLEGRAB		equ	3
GR_DISABLEGRAB		equ	6
GR_PROMPTGRAB		equ	9
GR_INQUIRESAVE		equ	12
GR_SAVESCREEN		equ	15
GR_RESTORESCREEN	equ	18
GR_INITSCREEN		equ	21

; sub functions

GR_DISABLESAVE		equ	0fffbh
GR_ENABLESAVE		equ	0fffch
GR_SETSWAPDRIVE		equ	0fffdh
GR_GETBLOCK		equ	0fff8h
GR_GETINFO		equ	0fffeh
GR_ENDPAINT		equ	0fff4h
GR_BEGINPAINT 		equ	0fff5h


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaerr.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This is the erroe manager module. Control is transferred to the error mana-;
; -ger when ever any non recoverable error is encountered. The error type is ;
; set in the 'ErrorType' global variable. This routine does the necessary    ;
; tidy up operations before exiting to win main with the error code. In case ;
; a 'window swap in error' happens, a dos exit is called.		     ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)      		     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	woaerr.inc
	.list

	;-----------------------------------------------------;
	; declare any external WINDOWS procedures used here.  ;
	;-----------------------------------------------------;


	;-----------------------------------------------------;
	; declare any FAR external Winoldap procedures.       ;
	;-----------------------------------------------------;


	;-----------------------------------------------------;
	; define any public labels,names here.		      ;
	;-----------------------------------------------------;

	public	ErrorManager
	public	WoaAppSwapErr
	public	RecoverWindows
	public	DeleteFilesAndResources


sBegin	Data

	;----------------------------------------------------;
	; declare the global variables to be accessed        ;
	;----------------------------------------------------;

externB		ErrorType		;type of error to handle
externW		WinMainSP		;sp needed to return to WinMain
externW		LowMemArenaSel		;selector for low heap arena
externW		LowMemParaSize		;size of windows low heap
externB		LowMemBlockType		;type of the low heap block
externW 	hApp		   	;windows handle for this instance

	;----------------------------------------------------;
	; define any variables used internally		     ;
	;----------------------------------------------------;

	;----------------------------------------------------;
	; include a file with additional messages. This is in;
	; an incluse file for ease in internationalization.  ;
	;----------------------------------------------------;

		include	woamsg1.inc

sEnd	Data
;----------------------------------------------------------------------------;
sBegin	Code

 	assumes	cs,Code
	assumes	ds,Data
	assumes	es,nothing

	;-----------------------------------------------------;
	; declare any external WOA procedures used here.      ;
	;-----------------------------------------------------;

	externNP	SwapWindowsIn		;(WOAMGR.ASM)
	externNP	RestoreSwapBlock	;(WOAMGR.ASM)
	externNP	OldAppManagerEnd	;(WOAMGR.ASM)
	externNP	EmergencyExit		;(WOAPMRM.ASM)
	externNP	GetDosAppSwapFileName	;(WOAMGR.ASM)
	externNP 	RestoreCtrlCFlag	;(WOAUTILS.ASM)
	externNP	ResetClassInt15Word	;(WOAUTILS.ASM)

;----------------------------------------------------------------------------;

ErrorManager proc near

	mov	al,ErrorType		;load the error type

; isolate 'windows swap in error '

	cmp	al,ER_WND_SWAP_IN	;windows cant be swapped in
	jnz	not_critical_error	;no, we can still recover

; we have crtical error. Clean up as much as possible and exit.

; restore the type and size of the low heap windows block and mark it as
; free.

	mov	es,LowMemArenaSel	;sel for low heap dos block
	mov	al,LowMemBlockType	;get the type of the block
	mov	es:[0],al		;reset it
	mov	ax,LowMemParaSize	;get the original size
	mov	es:[3],ax		;set the size back
	mov	word ptr es:[1],0 	;mark it as free

; now exit back to dos.

	mov	sp,WinMainSP		;load the entry sp value
	jmp	OldAppManagerEnd	;go back to winmain

not_critical_error:

; isolate the routines which occur when window is active, OEM is active

	cmp	al,ER_WND_OK_SCR_OK	;compare against the barrier
	jb	proper_window_active	

; Windows must have been partially or totally been swapped out. We must restore
; it.

	call	RecoverWindows		;restore window after error

; now tidy up and exit to WinMain by reloding the entry stack pointer and doing
; a 'ret'. Also clean up all file that we might have created.

proper_window_active:

; if the instance that is being force-terminated was using INT 15 memory then
; reset the ID in the class word.

	cCall	ResetClassInt15Word,<hApp>

; now delete Files and Resources.

	call	DeleteFilesAndResources

	xor	ah,ah			;zero out ah
	mov	al,ErrorType		;load the error code before exit
	mov	sp,WinMainSP		;load the entry sp value
	jmp	OldAppManagerEnd	;go back to winmain

ErrorManager endp
;----------------------------------------------------------------------------;
; RecoverWindows:							     ;
;									     ;
; This routine retrieves the Windows context when an error occurs. The error ;
; might occur when we are swapping windows out, in which case the swap out   ;
; might be partial. The error might occur after Windows had been swapped out ;
; totally.								     ;
;----------------------------------------------------------------------------;

RecoverWindows proc near

; we have a windows swap out failure. 

	push	ax			;save the code

; now isolate errors where windows code is there, but OEM swapped out

	cmp	al,ER_WND_OK_SCR_GONE	;compare against the barrier
	jae	windows_code_thrashed	;windows code has been overwritten.

	jmp	short windows_code_ok

windows_code_thrashed:

	cmp	al,ER_WND_SWAP_OUT_BAD	;win swap fail after memory thrashed ?
	jnz	not_bad_win_swap_err	;no.

; we have a bad windows swap out error. The memory has been thrashed but 
; swap out fails. In this case windows must be read back. Change the error
; code though.

	pop	ax			;get back the error code
	mov	al,ER_WND_SWAP_OUT	;windows swap out failure
	push	ax			;push it back
	mov	ErrorType,al		;update the error type

not_bad_win_swap_err:

; first get back windows in.
	
	cCall	SwapWindowsIn		;get back windows

windows_code_ok:

	cCall	RestoreSwapBlock	;restore low memory IDT

; re-enable kernels dos traps, before this we must return the state of the
; CTRL+C flag. This had been saved after doing the DisableDos call.

	cCall	RestoreCtrlCFlag	;resturn original state

	pop	ax			;get back error type in al
	mov	ErrorType,al		;save the error type
	ret

RecoverWindows endp
;----------------------------------------------------------------------------;
; DeleteFilesAndResources:						     ;
;									     ;
; Delete all temp files and free up selectors:				     ;
;----------------------------------------------------------------------------;

DeleteFilesAndResources proc near

; free up all work selectors


; clean up files.

	call	GetDosAppSwapFileName	;get the dos swap file name
	call	ErrDeleteFile		;delete it

	ret

DeleteFilesAndResources endp
;----------------------------------------------------------------------------;
; ErrDeleteFile:							     ;
;									     ;
; This routine takes a pointer to a file name in ds:si and deletes the file. ;
; Some of the swap files may have read-only/hidden attributes set.           ;
;----------------------------------------------------------------------------;

ErrDeleteFile  proc  near

	mov	dx,si			;ds:dx has the pointer
	mov	ax,4301h		;set file attributes
	xor	cx,cx			;normal attributes
	int	21h			;normal attributes set
	mov	ah,41h			;delete file code
	int	21h
	ret

ErrDeleteFile  endp
;----------------------------------------------------------------------------;

sEnd	Code

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woafile.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file has file handling routine to be used for the windows environment ;
; These routines for OPEN,CLOSE,READ and LSEEK are similar to the undocume-  ;
; -nted file i-o routines but will take care of segment crossing and >64k    ;
; bytes i-o. 						                     ;
;									     ;
; History:	  							     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)	   	     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	.list


;	The jmpnext macro and associated symbols are used to generate
;	the fall-through chain and generate the labels required for
;	error checking.

??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e> 				;;If not the end of the chain
	db	03dh			;;mov bx, next two bytes
errn$	??ji&j,+2			;;mext lable must be two bytes away
endif
??ji=j					;;increment counter
endm


sBegin	Data


sEnd 	Data
;----------------------------------------------------------------------------;
sBegin	Code

;----------------------------------------------------------------------------;
; declare all external functions here.					     ;
;----------------------------------------------------------------------------;


;-----------------------------------------------------------------------------;

assumes	cs,Code
assumes ds,Data

;----------------------------------------------------------------------------;
;                  OpnFile (LPSTR,BYTE)			             ;
;----------------------------------------------------------------------------;

cProc	OpnFile,<NEAR,PUBLIC,PASCAL>
	parmD	FileNameString
	parmB	AccessMode

cBegin
	lds	dx,FileNameString	; load the pointer to the string
	assumes	ds,nothing

	mov	al,AccessMode		; type of i-o desired
	mov	ah,3dh			; OPEN FILE MSDOS code
	int	21h			; do int21
	jnc	open_good		; successful
	mov	ax,-1			; error code
open_good:				; go back to caller

cEnd

;----------------------------------------------------------------------------;
;                  CreateFile (LPSTR,BYTE)			             ;
;----------------------------------------------------------------------------;

cProc	CreateFile,<NEAR,PUBLIC,PASCAL>

	parmD	FileNameString
	parmW	Attribute

cBegin
	lds	bx,FileNameString	; load the pointer to the string
	assumes	ds,nothing

	mov	dx,bx			; DS:DX points to ASCIIZ name string
	mov	cx,Attribute		; type of i-o desired
	mov	ah,3ch			; OPEN FILE MSDOS code
	int	21h			; open the file
	jnc	create_good		; successful
	mov	ax,-1			; error code
create_good:				; go back to caller

cEnd
;----------------------------------------------------------------------------;
;                  DeleteFile (LPSTR)				             ;
;----------------------------------------------------------------------------;

cProc	DeleteFile,<NEAR,PUBLIC,PASCAL>
	parmD	FileNameString

cBegin

	lds	bx,FileNameString	; load the pointer to the string
	assumes	ds,nothing

	mov	dx,bx			; DS:DX points to ASCIIZ name string
	mov	ah,41h			; delete file code
	int	21h			; open the file
	jnc	delete_good       	; successful
	mov	ax,-1			; error code
delete_good:				; go back to caller

cEnd
;----------------------------------------------------------------------------;
;                  LseekFile (HANDLE,DWORD,BYTE)			     ;
;----------------------------------------------------------------------------;

cProc	LseekFile,<NEAR,PUBLIC,PASCAL>

	parmW	FileHandle
	parmD	Position
	parmB	Origin

cBegin
	
	mov	cx,seg_Position		; get hiword of offset
	mov	dx,off_Position		; get low word of offset
	mov	bx,FileHandle		; the file handle
	mov	al,Origin
	mov	ah,42h			; lseek code in MSDOS
	int	21h
	jnc	seek_good		; successful
	mov	dx,-1
	mov	ax,-1			; error code
seek_good:

cEnd

;----------------------------------------------------------------------------;
;                  ReadFile (HANDLE,LPSTR,DWORD)		             ;
;----------------------------------------------------------------------------;

cProc	ReadFile,<NEAR,PUBLIC,PASCAL>,<ds>

;	parmW	FileHandle
;	parmD	Buffer
;	parmD	Count

cBegin	nogen

	mov	cl,3fh			; read code
	jmp     short ReadWriteFile	;prepare to merge into FAR proc

cEnd	nogen			   
	
	;--------------------------------------------;
	; near entry point WriteFile.		     ;
	;--------------------------------------------;

cProc	WriteFile,<NEAR,PUBLIC,PASCAL>,<ds>

;	parmW	FileHandle
;	parmD	Buffer
;	parmD	Count

cBegin	nogen


	mov	cl,40h			;write code
	jmp     short ReadWriteFile	;prepare to merge into the FAR proc

cEnd	nogen			   

;----------------------------------------------------------------------------;
;                  ReadWriteFile (HANDLE,LPSTR,DWORD)		             ;
;----------------------------------------------------------------------------;

cProc	ReadWriteFile,<NEAR,PUBLIC,PASCAL>,<ds>

	parmW	FileHandle
	parmD	Buffer
	parmD	Count

	localB	rwcode
	localW	EntrySP		

cBegin	

	
	mov	EntrySP,sp		;save in case we hit an error
	mov 	rwcode,cl
	mov	bx,FileHandle
	mov	di,seg_Count
	mov	cx,off_Count		;DI:CX has the count of bytes to read/write
	lds	si,Buffer		;DS:SI points to buffer
	assumes	ds,nothing

; DI:CX has the number of bytes to read/write
; DS:SI points to next position in buffer

; if we are not at the start of a segment, complete the i/o for the segment

	or	si,si			;start of a segment ?
	jz	iterate			;yes.
	mov	ax,0ffffh		;last offset in segment
	sub	ax,si			
	inc	ax			;no of bytes till end of segment
	or	di,di			;how much do we have to read ?
	jnz	special_io		;lots, do a special io
	cmp	ax,cx			;is no to read less than till seg end ?
	jae	last_io			;one i/o will do

special_io:

	push	cx			;save count
	push	di			;save
	push	ax			;save amount of io being done
	mov	dx,si			;ds:si points to buffer
	mov	cx,ax			;amount to read till segment end
	mov	ah,rwcode		;read or write
	int	21h			;do the io
	call	GetOutOnError		;exit in case of error
	mov	ax,ds			;get the segment
	add	ax,1000h		;next segment
	mov	ds,ax			;next segment
	xor	si,si			; DS:SI points to next segment
	pop	ax			;restore amount of io done
	pop	di
	pop	cx			;restore counts
	sub	cx,ax			;update count left
	sbb	di,0			;update high word



iterate:

; test to see if the read/write can be satisfied in the current segment

	or	di,di			;no left >= 64k
	jnz	will_cross_segment	;have to break up in chunks of 65535
	cmp	cx,0fff0h		
	ja	will_cross_segment

last_io:

; the last read/write will complete the job

	mov	dx,si			; DS:DX has buffer
	mov	ah,rwcode		; read/write code
	int	21h	
	call	GetOutOnError		;exit in case of error
	jmp	short read_ret		; go back

will_cross_segment:

; read one hunk of 65,535 bytes

	push	di
	push	cx			; save the counts

	mov	dx,si			; DS:DX points to buffer
	mov	cx,0fff0h		; read/write 65535 bytes
	mov	ah,rwcode
	int	21h
	call	GetOutOnError		;exit on error

reduce_count:

;----------------------------------------------------------------------------;
; now we need to go to the next segment.				     ;
;----------------------------------------------------------------------------;

	mov	ax,ds			;get the segment
	add	ax,0fffh		;next segment
	mov	ds,ax
	xor	si,si			; DS:SI points to next segment

; get back counts and reduce no of bytes to read/write

	pop	cx
	pop	di

	sub	cx,0fff0h		;we just read 65,535 bytes
	sbb	di,0			;update high word

; DI:CX has bytes left to read/write
; DS:SI has the pointer to the next byte to read/write

	jmp	iterate			; iterate till all bytes are read/write

GetOutOnError proc near

	jc	ExitWithError		;cannot proceed
	cmp	ax,cx			;was the required amout read or written
	jb	ExitWithError		;no.
	ret				;all is OK

GetOutOnError endp

ExitWithError:

; close the file first

	mov	ah,3eh			;BX has the handle
	int	21h			;closes the file
	stc				;error while read/write
	mov	sp,EntrySp		;clean up stack

read_ret:
cEnd

;----------------------------------------------------------------------------;
;		    CloseFile (HANDLE)	         		             ;
;----------------------------------------------------------------------------;

cProc	CloseFile,<NEAR,PUBLIC,PASCAL>
	
 	parmW	FileHandle

cBegin
	
	mov	bx,FileHandle
	mov	ah,3eh			; close code
	int	21h

cEnd
;----------------------------------------------------------------------------;
;		   SetNormalAttributes (LPSTR)				     ;
;----------------------------------------------------------------------------;

cProc	SetNormalAttributes,<NEAR,PUBLIC,PASCAL>,<ds>

;	parmD	lpFileName

cBegin	nogen
 
	mov	cl,0			;normal attributes
	jmpnext

cEnd	nogen
;----------------------------------------------------------------------------;
;		   SetHiddenAttributes (LPSTR)				     ;
;----------------------------------------------------------------------------;


cProc	SetHiddenAttributes,<NEAR,PUBLIC,PASCAL>,<ds>

;	parmD	lpFileName

cBegin	nogen

	mov	cl,3			;hidden and readonly attributes
	jmpnext	stop

cEnd	nogen
;----------------------------------------------------------------------------;
;		SetAttributes (LPSTR)					     ;
;----------------------------------------------------------------------------;

cProc	SetAttributes,<NEAR,PUBLIC,PASCAL>,<ds>

	parmD	lpFileName

cBegin

	mov	ds,seg_lpFileName	;load the seg of the pointer
	mov	dx,off_lpFileName	;ds:dx points to file name
	mov	ax,4301h		;set file attributes function code
	xor	ch,ch			;cl has bits to set
	int	21h			;file attributes set

cEnd
;----------------------------------------------------------------------------;

sEnd  	Code

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woados.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This module contains the read key borad buffer routines needed for function;
; 0ah and function 3fh (when the file is a console device)		     ;
;									     ;
; Here are some of the problems and related issues:			     ;
;									     ;
;	  (1) In case the handle points to COMMn, we should ideally like to  ;
;	      trap the call as a wait will be involved. However, there is no ;
;             provision in Dos to do a 'GetStatus' call on a given file      ;
;	      handle.							     ;
;									     ;
;	      In the above case, we will let the call go through to Dos and  ;
;	      will not be able to switch out till the 3FH read on an handle  ;
;	      redirected to COMMn or AUX is satisfied.		             ;
;									     ;
;	  (2) The 3FH call provides a file handle, where as the INT 21H      ;
;	      'GetStatus' calls assume a file handle of 0 implicitly. Thus   ;
;	      we should not use INT 21H 'GetStatus'/'ReadKey (low #s)' calls ;
;	      when trapping a 3FH call. INT 16H would be fine as we would    ;
;	      never get to our trap if the handle does not point to a CON    ;
;	      device.  							     ;
;									     ;
;	  (3) The trap for INT 21H/AH=0AH call would work fine. Here we do   ;
;	      not check to see whether handle 0 has been redirected or not,  ;
;	      but we still work OK because the INT 21H/'GetStatus' and low   ;
;	      numbered 'ReadKey' calls take care of redirection themselves.  ;
;									     ;
; History:								     ;
;									     ;
;	 Thu May-10-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Added the 'DoDosWait' routine in place of the 'DoInt16' routine.    ;
;	 This is necessary because the console input might be redirected     ;
;        before an INT 21H/AH=0AH call is made and INT 16H calls do not      ;
;	 support redirection while Dos calls do. (Fix for bug # 1334 (new)   ;
;	 in Windows 3.0).						     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created. (Added the History legend)				     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include njmp.mac
	include	woakeys.inc
	.list

	.286

;----------------------------------------------------------------------------;
; declare all public names here.					     ;
;----------------------------------------------------------------------------;

	public	XenixRead
	public	ReadConsoleBuffer
	public	DoDosWait

;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,Data

;----------------------------------------------------------------------------;
; declare external functions defined elsewhere.				     ;
;----------------------------------------------------------------------------;

	externNP	SwitchIfPossible	;(WOARLM.ASM)
	externNP	DosCall			;(WOARLM.ASM)
	externNP	DoInt28			;(WOARLM.ASM)

;----------------------------------------------------------------------------;
; declare external StubSeg variables that are defined elsewhere		     ;
;----------------------------------------------------------------------------;

externD		ActualInt21   		;original INT 21 vector
externD		ActualInt16		;original INT 16 vector
externB		ConsoleRawMode		;console in raw or cooked mode
externB		WOAsInt16		;chain down our own int 16


;----------------------------------------------------------------------------;
; have any variables needed by the trap routines			     ;
;----------------------------------------------------------------------------;

		public	RCB_FileHandle
		public  b3fRCB
		public	lp3fMode

KeyBoardBuf	label	byte		;place where we will have our traps
		db	256 dup (?)	;max size of buffer for function 0ah
ReadFileBuf	label	byte
		db	128 dup (?)	;max size of buffer for func 3fh
TempReadFileBuf	label	byte
		db	128 dup (?)	;max size of buffer for func 3fh
StartCol	db	?		;start cursor coloumn
InsertMode	db	0		;insert mode indicator (toggle)
LastXenixCount  db	0		;used by Xenix Read,length of last line
XenixBufPos	dw	0		;used by Xenix Read,ptr in last line
b3fRCB		db	0		;ReadConBuffer from 3fH trap or not
RCB_FileHandle	dw	1		;handle of STDOUT (or for 3FH call)
lp3fMode	dd	?		;pointer to mode word in SFT
BufferedExtKey  db	0		;key buffered or not

;----------------------------------------------------------------------------;
; define the two tables for handling the edit characters.		     ;
;----------------------------------------------------------------------------;

; define the allowable edit character codes

EscTable  label byte

	db	ED_F6			;F6
	db	ED_RIGHT_ARROW		;-->
	db	ED_F1			;F1
	db	ED_DEL			;DEL
	db	ED_F2			;F2
	db	ED_F4			;F4
	db	ED_F3			;F3
	db	ED_F5			;F5
	db	ED_LEFT_ARROW		;<--
	db	ED_INS			;INS
	db	ED_F7			;F7
	db	ED_F7			;to terminate table

EscTableLength  equ $-EscTable

; store the offset of the corresponding handler routines in reverse order

EscFunction	label word

	dw	RCB_ReadLoop		;ignore the character
	dw	RCB_TwoEsc		;handles F7
	dw	RCB_Insert		;handles INS
	dw	RCB_BackSpace		;handles left arror
	dw	RCB_ReEdit		;handles F5
	dw	RCB_CopyLine		;handles F3
	dw	RCB_SkipStr		;handles F4
	dw	RCB_CopyStr		;handles F2
	dw	RCB_SkipOne		;handles DEL
	dw	RCB_CopyOne		;handles F1
	dw	RCB_CopyOne		;handles right arrow
	dw	RCB_CtrlZ		;handles F6

;----------------------------------------------------------------------------;
; XenixRead:								     ;
;  									     ;
; This routine reads the console device like a file. It maintains a line     ;
; buffer upto a length of 128 bytes. When the buffer is empty, it fills it   ;
; up by a 'ReadConsoleBuffer' call. It then transfers the user requested #   ;
; of bytes from this buffer. The local buffer stays intact accross call and  ;
; if it is not empty, the requests are satisfied from there.		     ;
;									     ;
; However, if the console is set into raw mode, then just the required # of  ;
; characters are obtained using a direct console input without echo and saved;
; into the buffer.							     ;
;								             ;
;                 ES:DX  -- has user buffer long pointer		     ;
;		     CX  -- # of characters requested			     ;
;----------------------------------------------------------------------------;

XenixRead  proc  near

	assumes	cs,StubSeg
	assumes	ds,StubSeg
	assumes es,nothing

	cmp	ConsoleRawMode,0ffh	;is the console in raw mode ?
	jnz	@f			;no, do a buffered read

; console is in raw mode, do a raw read

	call	RawRead			;do a raw read
	jmp	short XenixReadRet	;return back

@@:
	mov	di,dx			;ES:DI -> buffer
	push	dx			;Save start of buffer to compute count
	mov	si,XenixBufPos		;# of characters left in buffer
	or	si,si			;Buffer left from last call?
	jnz	XenixXferFromBuffer	;try to satisfy the req. from the buffer

; XenixBuffer is empty, or we have taken up all characters that it had. In any 
; case we need to get a new line from the console. However, if there is a buffer
; then it will serve as the editing template.					


	pushem	es,di,cx	       	;save the trasfer address
	smov	es,ds			;es is stubseg, which has local buffer
	mov	cx,128			;Xenix line buffer size is atbest 128
	xchg	ch,LastXenixCount	;get former length of buffer

; if we do have a buffer left from a previous call, that will serve as the
; template. Note that the 0aH and 3fh Dos calls will have different buffers.

	mov	dx,StubSegOFFSET TempReadFileBuf
	call	ReadConsoleBuffer	;get a new line.
	mov	XenixBufPos,0		;current position in buffer

; the local buffer possibly has a new line now.

	popem	es,di,cx		;get back lptr to users buffer
	mov	si,StubSegOFFSET ReadFileBuf
	or	al,al			;Empty?
	jz	XenixXferFromBuffer	;Yes, LastXenixCount left at 0
	dec	al			;Don't include CR

; set the length of the template for the next call to be the length of the 
; line just read.

	mov	[LastXenixCount],al	;Length of next template for next call

XenixXferFromBuffer:

	cmp	byte ptr [si],1ah	;^Z?
	jnz	XenixTransferLoop	;no, trasfer the characters
	mov	byte ptr es:[di],1ah	;^Z to output buffer (no inc of DI)
	jmp	short XenixReadDone	;all done, finish up

; transfer characters from local to the users buffer

XenixTransferLoop:

	lodsb				;load the next char from local buffer
	stosb				;place it in users buffer
	cmp	al,0dh			;dis we just transfer a CR ?
	jnz	@f			;No
	mov	bptr [si],0ah		;insert LF after CR to simulate file
@@:
	cmp	al,0ah			;was the last char a LF ?
	loopnz	XenixTRansferLoop	;Continue while chars and NOT LF
	jnz	@f			;Stopped due to CX = 0, still have buffer

; data transfer completed

XenixReadDone:

	mov	al,0ah			;echo LF to stdout
	call	OutChar			;display the character
	xor	si,si			;nothing in internal buffer
@@:
	mov	[XenixBufPos],si	;Set internal buffer ptr for next call
	pop	dx			;Recover start of xfer buffer
	mov	ax,di			;posn of last char in users buffer
	sub	ax,dx			;diff is count of chars transfered

XenixReadRet:

	clc				;show success
	ret

XenixRead  endp
;----------------------------------------------------------------------------;
; RawRead:								     ;
;									     ;
; This routine waits for keystrokes, and once it gets them it filles them up ;
; in the user provided buffer at es:dx. It will fill CX number of characters ;
; into the buffer. While it is waiting for characters, it tests to see if a  ;
; context switch can be done or not. (characters are not echoed by this call);
;									     ;
; As noted in the header, we must do INT 16 get-status and read calls.	     ;
;----------------------------------------------------------------------------;

RawRead	proc near

	mov	ax,cx			;set up return value.
	mov	di,dx			;get ES:DI to point to the buffer
	push	ax			;save value

RawReadLoop:

RawReadFromKeyBoard:

	call	GetInt16KeyFromDos	;get a character in AL

RawKeyInAl:

	stosb				;save it in the buffer
	loop	RawReadLoop		;read requested number of characters

	pop	ax			;get back no of characters read
	ret

RawRead endp
;----------------------------------------------------------------------------;
; ReadConsoleBuffer:							     ;
;									     ;
; This routine is called to fill a buffer with a line obtained from the cons-;
; -ole. It allows full editing support exactly like dos, based on a template ;
; which is nothing but the buffers previous contents.			     ;
;									     ;
; Dos Functions 0ah and 3fh use this call to read the next line from console ;
;									     ;
; On Entry:								     ;
;	     ES:DX  --  users buffer past the 1st two bytes		     ;
;		CL  --  user buffer size.				     ;
;		CH  --  number of characters already in buffer (if the user  ;
;			had done the same call earlier on the same buffer).  ;
;----------------------------------------------------------------------------;

ReadConsoleBuffer proc near

	assumes	cs,StubSeg
	assumes	ds,StubSeg
	assumes	es,nothing

	mov	di,dx			;this will be our work pointer
	mov	si,dx			;si will point to the start
	mov	ax,cx			;al is buffer length, ah template length
	xor	ch,ch			;cx will hold final length of input
	
; we are done if a zero length buffer is specified.

	or	al,al			;test length of buffer
	njz	ReadConsoleBufferRet	;return back

; in BL we will hold position in buffer and BH will have previous template 
; length.

	xor	bx,bx
	mov	bl,ah			;bl = template length, current pos=bh=0

;----------------------------------------------------------------------------;
; this call allows the user to edit the previous buffer. We allow edit only  ;
; when we have a valid prior template. Two conditions must be met:	     ;
;	1. length of buffer specified must not be less than or equal to the  ;
;	   template length, and						     ;
;	2. there must be a carriage return at the end of the template	     ;
;----------------------------------------------------------------------------;

	cmp	al,bl			;check length consistency
	jbe	ReadConsoleNoEdit	;editing functions not allowed
	cmp	bptr es:[bx+si],0dh	;carriage return at end ?
	jz	@f			;template is valid, it's length in BL

ReadConsoleNoEdit:
	xor	bx,bx			;throw away previous template length
@@:
	mov	dl,al			;size of buffer
	dec	dl			;no of characters we can put

;----------------------------------------------------------------------------;
; we must get the exact cursor position on the screen for the editing, do an ;
; int 10h call to get the current cursor position.			     ;
;----------------------------------------------------------------------------;

	pushem	bx,cx,dx		;save relevant registers
	mov	ah,15			;get active page call
	int	10h			;bh has current page
	mov	ah,3			;read cursor position call
	int	10h			;cursor position in dl
	mov	StartCol,dl		;save it
	popem	bx,cx,dx		;restore the saved registers

RCB_StartNewLine:

; do initializations

	push	si			;save start of user buffer
	mov	di,StubSegOFFSET KeyBoardBuf
	cmp	b3fRCB,0		;is it from a 3FH trap ?
	jz	RCB_SNL_DI_OK		;no, DI is correct
	mov	di,StubSegOFFSET ReadFileBuf

RCB_SNL_DI_OK:

	mov	InsertMode,0		;reset insert mode toggle
 	mov	bh,0			;no characters from template yet
	mov	dh,0			;# of characters in buffer
	
	call	GetChar			;get the first character
	cmp	al,0ah			;LF ?
	jnz	RCB_CharacterInAL	;no!, a valid character

; we will filter out the first LF, so that inut redirection will work.

;----------------------------------------------------------------------------;
; The main read loop starts now. We read and process characters. The charact-;
; -ers could be normal characters which go into the buffer, normal edit char-;
; -cters like backspace,etc., or they could be 2 byte template edit characte-;
; -rs. We get out of the loop,once we read a CR or we reach the end of the   ;
; buffer.								     ;
;----------------------------------------------------------------------------;

RCB_ReadLoop:

	call	GetChar			;get the next character

RCB_CharacterInAL:

; take action depending on the type of the character.

	cmp	al,"F"-"@"		;^F ?
	jz	RCB_ReadLoop		;ignore ^F
	cmp	al,ED_STARTEDIT		;start of EDIT cgaracter
	jz	RCB_ProcessEdit		;yes, process the next edit key
	cmp	al,127			;DEL key ?
	njz	RCB_BackSpace		;treat as backspace character
	cmp	al,08			;backspace character
	njz	RCB_BackSpace		;process backspace
	cmp	al,0dh			;CR?
	jz	RCB_EndLine		;Yes, finished
	cmp	al,0ah			;LF?
	jz	RCB_NewLine 		;Yes, new line and keep reading
	cmp	al,ED_CANCELEDIT	;CANCEL? (Esc for IBM)
	jz	RCB_KillNew		;yes, kill line and start over

; we have a normal character to stuff into the buffer.

RCB_SaveChar:

	cmp	dh,dl			;Room for char?
	jae	RCB_BufFul		;no room, buffer is full
	mov	[di],al 		;Char into buffer
	inc	di			;update buffer pointer
	inc	dh			;got a char
	call	OutAnyChar		;ouput the character

; one character processed.

	cmp	InsertMode,0		;are we insert mode ?

; if insert mode is on, get more characters but do not advance the template

	jnz	RCB_ReadLoop		;read more, insert is on.

; advance template

	cmp	bh,bl			;Past end of template or no template ?
	jae	RCB_ReadLoop        	;yes, we are out of chars in template
	inc	si		   	;skip to next char in template
	inc	bh			;one more character seen in template
	jmp	short RCB_ReadLoop	;continue till EOB or CR

ReadConsoleBufferRet:

	mov	ax,cx			;get return count in AX
	clc				;for success
	ret

ReadConsoleBuffer endp
;----------------------------------------------------------------------------;
; 		ROUTINES NEEDED BY READ CONSOLE BUFFER CODE		     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; When the end of the buffer is reached, sound the beep and continue looking ;
; for CR.								     ;
;----------------------------------------------------------------------------;

RCB_BufFul:

	mov	al,7			;code for bell
	call	OutChar			;output character in AL
	jmp	short RCB_ReadLoop	;Keep looking for CR

;----------------------------------------------------------------------------;
; We hev obtained the first character of a two character escape sequence.    ;
; We get the second character and process the chracter based on a table of   ;
; routines indexed by the second character.			             ;
;----------------------------------------------------------------------------;
	
RCB_ProcessEdit:

	push	di			;save DI (cannot change it!)
	push	es			;save users segment
	call	GetExtChar		;get the key
	smov	es,cs			;load segment for jump table
	mov	cx,EscTableLength	;length of table for scan
	mov	di,StubSegOFFSET EscTable;offset of second byte table
	repnz	scasb			;Look it up in the table
	shl	cx,1			;convert byte offset to word
	mov	bp,cx			;move to BP to index function table
	pop	es			;get back users segment
	pop	di			;restore DI
	jmp	cs:[bp+EscFunction] 	;Go to the right routine

;----------------------------------------------------------------------------;
; Process the carriage return character.				     ;
;----------------------------------------------------------------------------;

RCB_EndLine:

	mov	[di],al 		;put the cr in the buffer
	call	OutChar			;echo it
	pop	di		        ;get start of user buffer
	inc	dh      		;dh is length including CR

; fall into the re-edit command.

;----------------------------------------------------------------------------;
; RCB_CopyNew is used when the reedit command is detected		     ;
;----------------------------------------------------------------------------;

RCB_CopyNew:

	mov	si,StubSegOFFSET KeyBoardBuf;DS:SI -> local buffer
	cmp	b3fRCB,0		;is it from a 3FH trap ?
	jz	RCB_CN_SI_OK		;no, SI is correct
	mov	si,StubSegOFFSET ReadFileBuf

RCB_CN_SI_OK:

	mov	cl,dh			;get number of characters including CR
	push	cx			;save count for return
	rep	movsb			;copy final line to user buffer
	pop	ax			;get back count in ax for return
	ret				;all done

;----------------------------------------------------------------------------;
; This routine outputs a CR,LF pair onto the screen.			     ;
;----------------------------------------------------------------------------;

RCB_OutCRLF:

	mov	al,0dh			;code for CR
	call	OutChar			;output CR
	mov	al,0ah			;code for LF
	jmp	OutChar			;output and return to caller

;----------------------------------------------------------------------------;
; this code is executed when we get an LF, it outputs a CR,LF pair and goes  ;
; back to the main read loop.						     ;
;----------------------------------------------------------------------------;

RCB_NewLine:

	call	RCB_OutCRLF    		;go to next line
	jmp	RCB_ReadLoop		;go back to main read loop

;----------------------------------------------------------------------------;
; This function	flushes the inputs obtained till now but retains the template;
;----------------------------------------------------------------------------;

RCB_KillNew:

	mov	al,'\'			;code for cancel indicator
	call	OutChar		    	;print the cancel indicator
	pop	si			;remember start of edit buffer

; fall into the putnew code.

;----------------------------------------------------------------------------;
; following code fragment is used by the reedit command			     ;
;----------------------------------------------------------------------------;

RCB_PutNew:

	call	RCB_OutCRLF		;go to next line on screen
	pushem	ax,bx,cx		;save important registers
	xor	cx,cx
	mov	cl,StartCol		;get the start coloumn at command start

; we must outout a series of spaces to get to the correct starting coloumn

RCB_OutSpaces:
	jcxz	RCB_OutSpacesDone      	;we are now at correct coloumn
	mov	al, 20h			;code for space character

RCB_OutSpacesLoop:
	call	OutChar			;output the next space
	loop	RCB_OutSpacesLoop	;till we reach correct cursor position

RCB_OutSpacesDone:
	popem	ax,bx,cx		;restore registers
	jmp	RCB_StartNewLine	;start all over again

;----------------------------------------------------------------------------;
; process BACKSPACE.							     ;
;----------------------------------------------------------------------------;

RCB_BackSpace:

	or	dh,dh			;test no of characters in line
	jz	RCB_BackUpDone		;no chars in line, do nothing to line
	call	RCB_BackUp    		;do one char backup
	mov	al,[di] 		;get the deleted char
	cmp	al,' '			;test for characters below space
	jae	RCB_BackUpDone		;was a normal char
	cmp	al,9			;was it a tab ?
	jz	RCB_BackTab		;was a tab, fix up users display
	call	RCB_BackOnScreen 	;was a control char, zap the '^'

RCB_BackUpDone:

	cmp	InsertMode,0		;insert on or off ?
	njnz	RCB_ReadLoop        	;in insert mode, get more chars
	or	bh,bh	    		;test for position in template
	njz	RCB_ReadLoop		;cant go back, we are at start
	dec	bh			;go back in template ,dec count
	dec	si			;decrement pointer in template
	jmp	RCB_ReadLoop		;continue in main read loop

;----------------------------------------------------------------------------;
; This fragment backs up over a tab, with the first character already beacked;
; over.									     ;
;----------------------------------------------------------------------------;

RCB_BackTab:

	push	di			;save poistion in local buffer
	dec	di			;back up one char
	mov	cl,dh			;number of chars currently in line
	mov	al,' '			;we look for spaces
	push	bx			;save template context
	mov	bl,7			;at best we back over 7 more spaces
	jcxz	RCB_BackTabDone		;at start, do nothing

RCB_FindPos:

	cmp	al,[di] 		;look back
	jna	RCB_CheckCount		;test the count of look back
	cmp	byte ptr [di],9		;is it a tab character
	jz	RCB_HaveTab		;found a tab
	dec	bl			;back one char if non tab control char

RCB_CheckCount:

	dec	di		  	;go back one more
	loop	RCB_FindPos		;loop till satisfied

RCB_BackTabDone:

	sub	bl,[StartCol]		;subtract starting coloumn

RCB_HaveTab:

	sub	bl,dh		  	;subtract no of characters
	add	cl,bl			;add no of look backs we did
	and	cl,7			;cx has correct number to erase
	cld				;back to normal
	pop	bx			;restore template context
	pop	di			;restore position in local buffer
	jz	RCB_BackUpDone		;nothing to erase

RCB_TabBack:

	call	RCB_BackOnScreen	;back over a character
	loop	RCB_TabBack		;erase correct number of chars
	jmp	short RCB_BackUpDone	;done.

;----------------------------------------------------------------------------;
; This code fragment backs over a character on the screen as well as in the  ;
; local buffer. The second entry point backs a character just on the screen, ;
; not disturbing the buffers.						     ;
;----------------------------------------------------------------------------;

RCB_BackUp:

	dec	dh			;decrement count of characters
	dec	di			;backup buffer pointer

RCB_BackOnScreen:

	mov	al,8			;code for back space
	call	OutChar			;go back one coloumn
	mov	al,' '   	       	;space character
	call	OutChar			;space out character to erase it
	mov	al,8			;backspace again
	jmp	OutChar			;character erased, cursor ok,jmp rets

;----------------------------------------------------------------------------;
; this code fragment is hit when an escape character is actually to be put in;
; the buffer.								     ;
;----------------------------------------------------------------------------;

RCB_TwoEsc:

	mov	al,ED_STARTEDIT		;code to save for escape
	jmp	RCB_SaveChar		;save the character and proceed

;----------------------------------------------------------------------------;
; the code fragment used to copy the rest of the remplate.		     ;
;----------------------------------------------------------------------------;

RCB_CopyLine:

	mov	cl,bl			;total size of template
	sub	cl,bh			;minus position in template= copy count
	jmp	short RCB_CopyEach	;does the copy based on count in CX

;----------------------------------------------------------------------------;
; copies the template till the indicated character.			     ;
;----------------------------------------------------------------------------;

RCB_CopyStr:

	call	RCB_FindTemplateChar   	;find the char,returns distance in CX
	jmp	short RCB_CopyEach	;copy up to it

;----------------------------------------------------------------------------;
; Copies characters from the templates based on count. The first entry point ;
; copies one character, the next on expects a count in CX.		     ;
;----------------------------------------------------------------------------;

RCB_CopyOne:

	mov	cl,1			;need to copy 1 character

RCB_CopyEach:

	mov	InsertMode,0		;all copies turn off insert mode
	cmp	dh,dl			;test for end of buffer
	jz	@f			;at end of buffer, can't do anything
	cmp	bh,bl			;compares distance to template end
	jz	@f			;at end of template, can't do anything
	lods	byte ptr es:[si]	;Get byte from template
	mov	[di],al 		;Save in buffer
	inc	di			;Next char in line
	call	OutAnyChar		;Print char
	inc	bh			;ahead in template
	inc	dh			;ahead in line
	loop	RCB_CopyEach		;untill all characters are copied
@@:
	jmp	RCB_ReadLoop		;continue reading from keyboard

;----------------------------------------------------------------------------;
; skips one character in the template.					     ;
;----------------------------------------------------------------------------;

RCB_SkipOne:

	cmp	bh,bl			;compare distance to end of template
	jz	@f			;at end of template,cannot skip
	inc	bh			;ahead in template
	inc	si			;bump pointer in template
@@:
	jmp	RCB_ReadLoop		;continue in main loop

;----------------------------------------------------------------------------;
; skips to the indicated character in the template.			     ;
;----------------------------------------------------------------------------;

RCB_SkipStr:

	call	RCB_FindTemplateChar 	;find out how far to go
	add	si,cx			;go there bumping pointer in template
	add	bh,cl			;add count of character seen in templ
	jmp	RCB_ReadLoop		;get back tomain loop

;----------------------------------------------------------------------------;
; This routine gets the next character from the keyboard and looks ahead in  ;
; the template for a match, leaving in CX the number of characters toge there;
;									     ;
; If the operation cannot be done, the return address is pooped off the stack;
; and a direct jump is done to get back to the main read loop. So the caller ;
; must not push ANYTHING onto the stack before calling this code.	     ;
;----------------------------------------------------------------------------;

RCB_FindTemplateChar:

	call	GetChar			;Get the char to look for
	cmp	al,ED_STARTEDIT		;did he type a function key?
	jnz	@f			;no, set up for scan
	call	GetChar			;eat next char
	jmp	short RCB_NotFound	;go try again

@@:

	mov	cl,bl			;get number of characters in template
	sub	cl,bh	   		;cx is number of chars to end of templ
	jz	RCB_NotFound		;at end of template
	dec	cx	      		;cannot point past end, limit search
	jz	RCB_NotFound		;if only one char in template,forget it
	push	di			;save poistion in buffer
	mov	di,si	        	;template to es:di
	inc	di			;next character
	repne	scasb	        	;look
	pop	di			;get back pointer in buffer
	jnz     RCB_NotFound		;didn't find the char
	not	cl			;turn how far to go into how far we went
	add	cl,bl			;add size of template
	sub	cl,bh			;sub cur pos, result distance to skip
	ret

RCB_NotFound:
	pop	bp			;chuck return address
	jmp	RCB_ReadLoop		;go back to main loop

;----------------------------------------------------------------------------;
; this code discards the current template and makes line typed till now the  ;
; new template.								     ;
;----------------------------------------------------------------------------;

RCB_ReEdit:
	mov	al,'@'          	;output re-edit character
	call	OutChar			;display the character
	pop	di			;Recover addr of start of template buffer
	push	di			;save it
	call	RCB_CopyNew		;copy current line into template
	pop	si			;get back template start in si
	mov	bl,dh			;size of line is new size template
	jmp	RCB_PutNew		;start over again

;----------------------------------------------------------------------------;
; this code fragment, toggels the insertmode flag.			     ;
;----------------------------------------------------------------------------;

RCB_Insert:

	not	InsertMode		;toggle the flag
	jmp	RCB_ReadLoop		;go back into the main read loop

;----------------------------------------------------------------------------;
; puts a real live ^z in the buffer (embedded)				     ;
;----------------------------------------------------------------------------;

RCB_CtrlZ:

	mov	al,'Z'-'@'		;code for ^z
	jmp	RCB_SaveChar		;save in buffer and proceed

;----------------------------------------------------------------------------;
; 'OutAnyChar  prints out ctrl characters in a printable format, it jmps     ;
; 'OutChar' if the character is not a control character or if it is a tab    ;
;----------------------------------------------------------------------------;

OutAnyChar:

; filter out non control characters and tabl

	cmp	al,9			;Tab is not converted to ^char
	jz	OutChar			;print normal
	cmp	al,' '                  ;Chars above and = to space are normal
	jae	OutChar			;print normal characters
	push	ax			;Save char
	mov	al,'^'          	;Print ^
	call	OutChar			;print the character
	pop	ax			;get back control code
	add	al,'@'          	;Make char printable and print it
	
; all into the normal print code

	errn$	OutChar	
;----------------------------------------------------------------------------;
; this code prints out non-control characters and tabs (which is expanded)   ;
; we will use a 40H/INT 21H call to do the output. If this is being called   ;
; while we are in the middle of a INT 21/0AH call, RCB_FileHandle will be 1  ;
; (stdout). If we are trapping a 3FH call, RCB_FileHandle would be the handle;
; that 3FH used, we have already made sure that the handle has write access. ;
;									     ;
; Also, if the call is from a 3FH call, we will change the mode byte in the  ;
; SFT entry for the file to grant temporary write permision. We will restore ;
; the permision later.							     ;
;----------------------------------------------------------------------------;

cProc	OutChar,<NEAR,PUBLIC,PASCAL>,<ds,dx,ax,bx,cx,es,di>

	localB	OutChar_Byte		;byte to output
	localB	OutChar_Mode		;original SFT mode

cBegin

	mov	OutChar_Byte,al		;save the byte to output
	mov	bx,RCB_FileHandle	;handle to be used for write call
	lea	dx,OutChar_Byte		;ss:dx -> byte to output
	cmp	b3fRCB,0		;trapping a 3FH call ?
	jz	OutChar0AH		;no, trapping a 0AH call

; grant temporary write permison to the SFT

	les	di,lp3fMode		;es:di -> mode byte in SFT
	mov	al,es:[di]		;get the mode
	mov	OutChar_Mode,al		;save it
	and	al,80h			;reser mode/access bits
	or	al,42h			;deny-none/read-write access
	mov	es:[di],al		;save mode

; now write the byte

	smov	ds,ss			;ds:dx -> byte to output
	mov	cx,1			;1 character to write
	mov	ah,40h			;write code
	call	DosCall			;output the character

; finally restore the SFT mode.

	mov	al,OutChar_Mode		;get saved value
	mov	es:[di],al		;restore SFT mode
	jmp	short OutCharRet	;done.

OutChar0Ah:

	smov	ds,ss			;ds:dx -> byte to output
	mov	cx,1			;1 character to write
	mov	ah,40h			;write code
	call	DosCall			;output the character

OutCharRet:

cEnd
;----------------------------------------------------------------------------;
; this routine gets the next character typed in at the keyboard. It does a   ;
; get status call waiting for a character to get ready, and as it waits, it  ;
; tests to see if a context switch is possible and if it is, it would do the ;
; context switching.							     ;
;									     ;
; If the call has come from a 0AH trap, we should do INT 21 GetStatus/GetKey ;
; calls, else if the call has come from a 3FH trap we should use INT 16H to  ;
; do the 'GetStatus'/'ReadKey' calls. A flag would be set if the trap is from;
; a 3FH call.								     ;
;----------------------------------------------------------------------------;

GetChar	proc near

	cmp	b3FRCB,0		;is it a 3FH call ReadConBuffer ?
	jz	GetChar0ACall		;no,
	call	GetInt16KeyFromDos	;use INT 16H calls.
	jmp	short GetCharRet	;return.

GetChar0ACall:

	call	DoInt28			;yield, not if in crit. error handler
	call	SwitchIfPossible	;do a context switch if appropriate
	call	DoDosWait		;wait for key
	jz	GetChar			;wait till key ready
	mov	ah,8			;get the code int 21h call
	call	DosCall			;get the character

; the key is ready, return back	with code in AL

GetCharRet:

	ret

GetChar endp
;----------------------------------------------------------------------------;
; GetInt16KeyFromDos:							     ;
;									     ;
; This is called while we are trapping the 3FH dos call. As noted in the     ;
; header of the file, we will have to do INT 16H status/get key calls.       ;
; When a key code is returned as 00h, we will save the scan code and return  ;
; the scan code on the next invocation of this call.			     ;
;									     ;
; Note: some applications like EXTRA do their own INT 9/INT 16 handle without;
; chaining them on. For this reason we will do a regular INT 16H rather than ;
; trying to call down stream.						     ;
;									     ;
; This code has a special hack in it! This routine is called from the code   ;
; that traps the INT 21H/AH=3Fh call. We do INT 16H calls to get a key rather;
; than INT 21H calls to care of problems with redirection. However, this     ;
; means that we will not be processing CTRL+C and CTRL+BREAK keys correctly. ;
; To take care of this problem, we now do a dummy INT 21H get keyboard status;
; once a key becomes ready.						     ;
;----------------------------------------------------------------------------;
GetInt16KeyFromDos proc near

	cmp	BufferedExtKey,0	;is there a buffered key ?
	jz	GI16KFD_WaitLoop	;no.
	mov	al,BufferedExtKey	;get the saved key
	mov	BufferedExtKey,0	;no more in the buffer
	jmp	short GI16KFD_Ret	;ret

GI16KFD_WaitLoop:

	call	DoInt28			;yield, not if in crit. error handler

; do a INT 16H, set a flag so that our own hook will let it go and also will
; try the 'SwitchIfPossible' call.

	mov	cs:[WOAsInt16],0ffh	;our own INT 16
	mov	ah,01h			;get status call
	int	16h			;do the call
	mov	cs:[WOAsInt16],0	;reset the flag

; test for a key ready.

	jz	GI16KFD_WaitLoop	;no.

; As explained in the header, do an INT 21H get status call to give DOS a 
; chance to handle CTRL+C and CTRL+BREAK keys. 

	mov	ah,0bh			;get status key
	call	DosCall			;ignore results

; do a INT 16H, set a flag so that our own hook will let it go and also will
; try the 'SwitchIfPossible' call.

	mov	cs:[WOAsInt16],0ffh	;our own INT 16
	mov	ah,0			;get the key
	int	16h			;do the call
	mov	cs:[WOAsInt16],0	;reset the flag
	or	al,al			;is it an extended key
	jnz	GI16KFD_Ret		;no.
	mov	BufferedExtKey,ah	;save the scan code of ext key

GI16KFD_Ret:

	ret

GetInt16KeyFromDos  endp
;----------------------------------------------------------------------------;
; GetExtChar:								     ;
;									     ;
; This gets the second character of an extended key stroke. If we are in the ;
; middle of a 3FH trap, the character would already have been saved else     ;
; we must do a AH=08H dos call to get it.				     ;
;----------------------------------------------------------------------------;
GetExtChar proc near

	cmp	b3fRCB,0		;from a #FH trap ?
	jz	@f			;no.
	call	GetInt16KeyFromDos	;will get the buffered key
	ret
@@:
	mov	ah,08h			;get char
	call	DosCall			;get the char
	ret

GetExtChar endp
;----------------------------------------------------------------------------;
; DoDosWait:								     ;
;									     ;
; Does a check keyboard status call to see whether a key is ready or not.    ;
; Zero flag is set if no key is available. This routine does INT 21H call    ;
; rather than INT 16H so that redirection of console will be taken care of.  ;
;----------------------------------------------------------------------------;

DoDosWait proc near

	push	ax			;save
	mov	ah,0bh			;check keyboard status call
	call	DosCall			;call to dos direct
	or	al,al			;set/reset zero flag
	pop	ax			;restore
	ret

DoDosWait endp
;----------------------------------------------------------------------------;

sEnd	StubSeg

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaerr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; defines all recognized error type codes.				     ;
;----------------------------------------------------------------------------;

; define errors first where windows is still active

ER_NO_MEMORY		equ	1	;no windows memory error
ER_NO_LIST_MEMORY       equ	2       ;no memory for window table list
ER_LOW_MEMORY		equ	3	;not enogh memory to run app
ER_COMM_NOLOAD		equ	4	;comm active, cannot load oldapp
ER_NO_XMS_DRV		equ	5	;XMS driver not loaded
ER_LOW_XMS_MEM		equ	6	;insufficient XMS memory


; define the barrier where windows code is there, screen is ok too!

ER_WND_OK_SCR_OK	equ	7	; < 7 proper windows active

ER_WND_SWAP_OUT		equ	8	;windows swap out error
ER_RELOCATE		equ	9	;special relocation error
ER_WND_SWAP_OUT_BAD	equ	99	;swap out err after memory destroyed

; define the second barrier where windows code is there, OEM disabled

ER_WND_OK_SCR_GONE	equ	10	;windows code there,OEM disabled


ER_GRABBER_LOAD		equ	11	;grabber load error
ER_WND_SWAP_IN		equ	12	;windows swap in error
ER_APP_SWAP_OUT		equ	13	;app swap out error
ER_APP_SWAP_IN		equ	14	;app swap in error    
ER_LIST_SWAP		equ	15	;windows table swap failure
ER_EXEC_FAILS		equ	16	;exec call fails

; define error which do not go through the generalized error handler and 
; occur when windows is still around.

ER_WINOLDAP_ACTIVE	equ	17	;winoldap active as stub
ER_BAD_INIT_DIR		equ	18	;bad initial directory.
ER_ANOTHER_SW_ACTIVE	equ	19	;another switcher is active
ER_TOO_MANY_SWITCHERS	equ	20	;too many switchers in the system
ER_APP_NOT_STARTED_YET	equ	21	;the app has not been started yet

; define error when app can't be EXECed because of CreateSession fails

ER_SWAPI_CREATE_FAILS	equ	80	;create session fails

comment ~ */

#define ER_NO_MEMORY	       1
#define ER_NO_LIST_MEMORY      2
#define ER_LOW_MEMORY	       3
#define ER_COMM_NOLOAD         4
#define ER_NO_XMS_DRV	       5
#define ER_LOW_XMS_MEM	       6
#define	ER_WND_SWAP_OUT	       8
#define ER_RELOCATE            9
#define	ER_GRABBER_LOAD	      11	
#define	ER_WND_SWAP_IN	      12
#define	ER_APP_SWAP_OUT	      13	
#define	ER_APP_SWAP_IN	      14	
#define ER_LIST_SWAP	      15
#define ER_EXEC_FAILS	      16
#define ER_WINOLDAP_ACTIVE    17
#define	ER_BAD_INIT_DIR	      18
#define ER_ANOTHER_SW_ACTIVE  19
#define ER_TOO_MANY_SWITCHERS 20
#define ER_APP_NOT_STARTED_YET 21	

#define ER_SWAPI_CREATE_FAILS 80


/* end comment ~ ;*/










			     

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woagrb.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file will hold all fuctions necessary for handling the grabber module ;
; and also code to implement certain aspects of pasting and context saveing  ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)      		     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	woagrab.inc
	include grabber.inc
	include macros.mac
	include	njmp.mac
	include	woaerr.inc
	include woapif.inc
	.list

;----------------------------------------------------------------------------;
; declare any public function or varaiable names here.			     ;
;----------------------------------------------------------------------------;


createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,StubSeg

;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;

	externNP	DosCall			;(WOARLM.ASM)
	externNP	GetMouseStateSize	;(WOAMOUSE.ASM)
	externNP	SaveMouseState		;(WOAMOUSE.ASM)
	externNP	RestoreMouseState	;(WOAMOUSE.ASM)
	externNP	EnableMouse		;(WOAMOUSE.ASM)
	externNP	DisableMouse		;(WOAMOUSE.ASM)
	externFP	Int16ISR		;(WOARLM.ASM)
	externNP	FindVectra		;(WOAHP.ASM)
	externNP	DisableInt15Mouse	;(WOARLM.ASM)
	externNP	EnableInt15Mouse	;(WOARLM.ASM)
	externNP	GetSizeOfInstanceBuffer	;(WOAINSTD.ASM)
	externNP	GetInstanceDataSnapShot	;(WOAINSTD.ASM)

;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;

externW		WoaStubSize		;size of the real mode stub
externW		WoaSegResizeBlock	;segment of block to resize
externW		WoaSizeReservedArea	;reserved area at start of block
externW		GrabberParaSize		;size in para of grabber context
externB		WoaBehavior		;pif behavior flag
externB	        WoaHotKeys		;hot key disabling info
externB		WoaGrabberSwapPath	;grabber data swap path
externB		WoaGrabberName		;grabber load name
externB		WoaSwapDrive		;swap drive to be used
externW		MouseSeg		;segment where mouse context is saved
externW		InstDataSeg		;buffer for instance data management

;----------------------------------------------------------------------------;
; define the grabber related variables.				             ;
;----------------------------------------------------------------------------;

GrabberSeg		dw	?	;segment where grabber is loaded
GrabberScreenBufSeg	dw	?	;segment for saving the screen
GrabberScreenBufSize	dw	?	;size of the above segment
GrabberSize		dw	?	;size of the grabber.(<64k)
lpGrabberEntry		dd	?	;long pointer grabber call address
GrabberInfo		GrabInfo <>	;grabber info structure

;----------------------------------------------------------------------------;
; define some variables necessary for saving and restoring HP vectra state   ;
;----------------------------------------------------------------------------;

globalW HPsize,?			;size needed for saving HP state
globalB fVectra,0			;HP Vectra PC or not
globalW HPWindowsSeg,?			;HP state buffer for windows
globalW HPDosAppSeg,?			;HP state buffer for dos app

;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; LoadGrabberAndInit						  	     ;
;									     ;
; This is the first call related to the grabber that WOA makes and it does   ;
; the following:							     ;
;									     ;
;           .  If the machine is a HP Vectra, we will allocate two buffers   ;
;              right after the real mode stub code for saving the state of   ;
;              windows HP state and the old app HP state. If the PC is not a ;
;	       Vectra, these buffers will not be allocated.		     ;
;           .  Just after the place where the real mode stub is loaded (and  ;
;              the buffers for saving/restoring vectra state, if present, we ;
;              will be saving the mouse state, it saves the segment where    ;
;              the mouse state is to be saved and get the size of the state  ;
;              buffer.							     ;
;	    .  A buffer would be reserved for Instance data management after ;
;	       this.							     ;
;	    .  The grabber will be loaded into the space after the buffer    ;
;	       reserved for the Instance Data.				     ;
;	    .  It then finds out the size of the buffer needed for grabbing  ;
;              the screen and saves the address of the segment just after the;
;	       grabber code, where the buffer will be located.		     ;
;	    .  Invokes the grabber to tell it about the swapdrive and path.  ;
;----------------------------------------------------------------------------;


cProc	LoadGrabberAndInit,<NEAR,PUBLIC,PASCAL>

cBegin

; calculate the segment where the HP state buffers, mouse and grabber will be 
; loaded.

	call	FindVectra		;get the size of HP save area
	mov	ax,WoaSizeReservedArea	;get the size of the resrved area
	add	ax,WoaSegResizeBlock	;take past reserved area
	cmp	HPsize,0		;do we have a HP vectra PC ?
	jz	@f			;no.

; we have a vectra PC, allocate two buffers of AX paragraphs each and save the
; segment addresses.

	mov	HPWindowsSeg,ax		;save HP state for windows here
	add	ax,HPsize		;size of the buffer
	mov	HPDosAppSeg,ax		;segment for storing app HP state
	add	ax,HPsize		;size of the buffer

; add the size of the two buffers to GrabberParaSize

	push	ax			;save
	mov	ax,HPsize		;get the size in paras
	shl	ax,1			;two buffres so double it
	mov	GrabberParaSize,ax	;size of save area context till now
	pop	ax			;restore

@@:
	mov	MouseSeg,ax		;mouse state will be saved here
	push	ax			;save start of mouse save area
	cCall	GetMouseStateSize	;get the size of the buffer needed
	pop	bx			;get back the start segment
	add	GrabberParaSize,ax	;save size of gtabber related context
	add	ax,bx			;Instance data buffer will be here
	mov	InstDataSeg,ax		;for instance data segment

; find out the size of the instance data buffer.

	push	ax			;save start of instance data save area
	cCall   GetSizeOfInstanceBuffer	;size in AX (could be 0)
	pop	bx			;get back start segment

; Note: If AX is 0, the aove routine would have reset InstaDataSeg to 0.

	add	GrabberParaSize,ax	;save size of gtabber related context
	add	ax,bx			;here the grabber will be loaded
	mov	GrabberSeg,ax		;grabber will be loaded here

; create a snap shot of the current instance data state

	save	<ax>			;save
	cCall   GetInstanceDataSnapShot

; if switching is disabled, we need not load the grabber
; at all.

	push	ax			;save
	mov	al,WoaBehavior		;load the behaviour bits
	and	al,fNoGrabber		;mask switch and print screen bits
	cmp	al,fNoGrabber		;if it matches, we do not need grabber
	pop	ax			;restore
	jnz	@f			;grabber is required.

; grabber is not required

	clc				;no error
	jmp	short LoadGrabberAndInitRet;go back

@@:
	
; set up the call vector to start of grabber code

	mov	wptr [lpGrabberEntry+2],ax
	mov	wptr [lpGrabberEntry],0

; load in the grabber.

	cCall	LoadGrabber		;load in the grabber
	jc	LoadGrabberAndInitRet	;return back, cannot load grabber

; get the segment where we will have the screen save buffer

	mov	ax,GrabberSize		;get the size of the code 
	shiftr	ax,4			;get paragraphs
	inc	ax			;align to next paragraph
	add	ax,10h			;add 256 bytes for parameter area
	push	ax			;save the number of paragraphs
	add	ax,GrabberSeg		;ax now has buffer's segment
	mov	GrabberScreenBufSeg,ax	;save it
	pop	ax			;get back the no of paragraphs
	add	GrabberParaSize,ax	;save current size of grabber context

; now invoke the grabber to set the swapdrive and path. 

	mov	di,StubSegOFFSET WoaGrabberSwapPath
	smov	es,ds			;ES:DI points to the swap name
	mov	si,GR_INQUIREGRAB	;main function number
	mov	ax,GR_SETSWAPDRIVE	;subfunction
	mov	bl,WoaSwapDrive		;set up drive C for swap.
	cCall	InvokeGrabber		;invoke the grabber

;----------------------------------------------------------------------------;
; get the size of the buffer needed for saving the context of the screen     ;
; we will need a graphics sized buffer if fGraphics bit is set in the        ;
; WoaBehavior byte.				                             ;
;----------------------------------------------------------------------------;

	mov	ax,2			;assume graphics mode buffer size
	test	WoaBehavior,fGraphics	;marked for graphics screen exchange ?
	jnz	@f			;yes, we need graphics sized buffer
	mov	ax,1			;text sized buffer will suffice
@@:
	mov	si,GR_INQUIRESAVE	;function to get size of buffer
	cCall	InvokeGrabber		;get back size in DX:AX

; the size with the present grabber will never exceed 64k, so just use the
; low word

	mov	GrabberScreenBufSize,ax	;save buffer size

; now calculate the total size in paragraphs being taken up by the grabber
; and the screen save buffer.
		   
	shiftr	ax,4			;get the buffer size in paragraphs
	inc	ax			;update to the next para
	add	GrabberParaSize,ax	;save the total size

	clc				;no error detected

LoadGrabberAndInitRet:

cEnd
;----------------------------------------------------------------------------;
;GrabberSaveScreen:							     ;
;									     ;
; This routine invokes the grabber (which is resident as a part of the stub) ;
; to save the old app screen.		         			     ;
;----------------------------------------------------------------------------;

cProc	GrabberSaveScreen,<NEAR,PUBLIC,PASCAL>

cBegin

; save the mouse state first

	cCall	SaveMouseState		;mouse state variables saved

; now disable the mouse

	cCall	DisableMouse		;mouse disabled

; invoke the save screen function

	mov	es,GrabberScreenBufSeg	;get the segment for the save area
	mov	ax,GrabberScreenBufSize ;the size of save area allocated
	xor	di,di			;offset in buffer starts at 0
	mov	si,GR_SAVESCREEN	;save screen call
	cCall	InvokeGrabber		;call the grabber function
	pushf				;save the carry flag

; now enable and initialize the mouse and return

	cCall	EnableMouse		;reenable the mouse
	popf				;get back save screen status
	jc	SaveScreenFails		;save screen call failed

; Disable INT 15 Mouse if a local INT 15 mouse handler is active.

	call	DisableInt15Mouse	
	clc				;success.
	jmp	short GrabberSaveScreenRet;go back.

SaveScreenFails:

; the save screen call failed, must restore mouse state

	cCall	EnableMouse		;reenable the mouse
	cCall	RestoreMouseState	;restore mouse state
	stc				;save screen has failed.

GrabberSaveScreenRet:

cEnd
;----------------------------------------------------------------------------;
; GrabberRestoreScreen:							     ;
;								             ;
; This routine invokes the grabber (which is a part of the old app context)  ;
; and asks it to restore the old app screen from the saved image.	     ;
;----------------------------------------------------------------------------;

cProc	GrabberRestoreScreen,<NEAR,PUBLIC,PASCAL>

cBegin

; disable the mouse so that it does not interfere with restore screen

	cCall	DisableMouse		;disable the mouse

; call the RestoreScreen function

	mov	es,GrabberScreenBufSeg	;get the segment for the save area
	mov	ax,GrabberScreenBufSize ;size of the buffer area allocated
	xor	di,di			;offset in buffer starts at 0
	mov	si,GR_RESTORESCREEN	;save screen call
	cCall	InvokeGrabber		;call the grabber function

; enable the mouse befor retoring it's state

	cCall	EnableMouse		;reeneable the mouse

; enable the INT 15 mouse if the INT 15 mouse had been disabled.

	call	EnableInt15Mouse

; now restore the mouse state

	cCall	RestoreMouseState	;restore mouse state

cEnd
;----------------------------------------------------------------------------;
; GrabberEnableSave:							     ;
;									     ;
; Calls the EnableSave function in the grabber if it is loaded.		     ;
;----------------------------------------------------------------------------;

cProc	GrabberEnableSave,<NEAR,PUBLIC,PASCAL>

cBegin

; if the grabber is not loaded, we cannot execute this function

	mov	al,WoaBehavior		;load the state of the hotkeys
	and	al,fNoGrabber		;mask switch and print screen bits
	cmp	al,fNoGrabber		;if it matches, we do not need grabber
	jz	GrabberEnableSaveRet	;no grabber loaded
	mov	si,GR_INQUIREGRAB	;the main function code
	mov	ax,GR_ENABLESAVE	;the sub function code
	cCall	InvokeGrabber		;call the grabber function

GrabberEnableSaveRet:

cEnd
;----------------------------------------------------------------------------;
; GrabberDisableSave:							     ;
;									     ;
; Calls the grabber DisableSave function if the grabber is loaded            ;
;----------------------------------------------------------------------------;

cProc	GrabberDisableSave,<NEAR,PUBLIC,PASCAL>

cBegin

; if the grabber is not loaded, we cannot execute this function

	mov	al,WoaBehavior		;load the state of the hotkeys
	and	al,fNoGrabber		;mask switch and print screen bits
	cmp	al,fNoGrabber		;if it matches, we do not need grabber
	jz	GrabberDisableSaveRet	;no grabber loaded
	mov	si,GR_INQUIREGRAB	;main function code
	mov	ax,GR_DISABLESAVE	;sub function code
	cCall	InvokeGrabber		;call the grabber function

GrabberDisableSaveRet:

cEnd
;----------------------------------------------------------------------------;
; GrabberInitScreen:							     ;
;									     ;
; Initailizes and clears the screen by seting it to a known text state.      ;
;----------------------------------------------------------------------------;

cProc	GrabberInitScreen,<NEAR,PUBLIC,PASCAL>

cBegin

; if the grabber is not loaded, we cannot execute this function

	push	ax			;save no of lines to load
	mov	al,WoaBehavior		;load the state of the hotkeys
	and	al,fNoGrabber		;mask switch and print screen bits
	cmp	al,fNoGrabber		;if it matches, we do not need grabber
	pop	ax			;restore number of lines to load
	jz	GrabberInitScreenRet	;no grabber loaded
	mov	si,GR_INITSCREEN	;the function code
	cCall	InvokeGrabber		;invoke the grabber
	clc				;can be no error, grabbers don't do this

GrabberInitScreenRet:

cEnd
;----------------------------------------------------------------------------;
; This routine is responsible for loading the grabber in from the load time  ;
; grabber file.								     ;
;----------------------------------------------------------------------------;


cProc	LoadGrabber,<NEAR,PUBLIC,PASCAL>

cBegin

; open the grabber file

	mov	dx,StubSegOFFSET WoaGrabberName
	mov	ax,3d00h		;need to open a r/o file
	int	21h			;try to open file
	jc	LoadGrabberRet		;load failure
	mov	bx,ax			;have the handle in BX

; get the size of the file by doing an LSEEK of 0 bytes from the end and
; looking at the offset

	xor	cx,cx			;need zero for start offset
	xor	dx,dx			;so cx=dx=0
	mov	ax,4202h		;need to seek from end
	int	21h			;does the seek, DX:AX = size
	mov	GrabberSize,ax		;save low word of size, ignore DX

; now rewind and read the file.

	xor	cx,cx			;set to 0
	xor	dx,dx			;cx:dx = 0
	mov	ax,4200h		;lseek from the start
	int	21h			;rewound.

; now read in the file in one go. Code size will be less than 64k

	push	ds			;save
	xor	dx,dx			;start offset = 0
	mov	cx,GrabberSize		;size of read data
	mov	ds,GrabberSeg		;segment to load data into
	mov	ah,3fh			;read code
	int	21h			;read in the file
	pop	ds			;get back data segment

; close the file
	
	mov	ah,3eh			;close code
	int	21h			;file closed

LoadGrabberRet:

cEnd
;----------------------------------------------------------------------------;
; This routine invokes the grabber in real mode. All resgisters (incl ES)    ;
; set up the way the grabber expects it. Particularly, SI must have the      ;
; offset of the function being called.					     ;
;----------------------------------------------------------------------------;

cProc	InvokeGrabber,<NEAR,PUBLIC,PASCAL>

cBegin

	push	ds			;save
	mov	wptr [lpGrabberEntry],si;set the offset of entry
	mov	ds,GrabberSeg		;have ds same as cs
	assumes	ds,nothing

	call	lpGrabberEntry		;invole the grabber
	pop	ds
	ret

InvokeGrabber	endp
;----------------------------------------------------------------------------;

sEnd  StubSeg

end


	

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woahp.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This module contains all the necessary functions needed for saving and res-;
; -toring the HP vectra state. The routines here were originally developed   ;
; for Real Mode Winoldap and has been adopted after minor modifications.     ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Adapted for 286 protected mode Winoldap			     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	woahpeqs.inc
	include	woahp.inc
	include	macros.mac
	.list

	public	CheckWithApp
	public	NotifyApp

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg

;----------------------------------------------------------------------------;
;  define state specific tables that are of known size.			     ;
;----------------------------------------------------------------------------;

SAVE_TABLE_REC	struc	
SVector	dw	?
SFirst	dw	?			     
SLast	dw	?
SLoc	dw	?
SAVE_TABLE_REC	ends  

DefineTable 	label 	word 
SAVE_TABLE_REC 	<V_LTOUCH, LD_SOURCE, LD_ACCUM_Y+2, LTouch>
SAVE_TABLE_REC 	<V_LPOINTER, LD_SOURCE, LD_ACCUM_Y+2, LPointer>
SAVE_TABLE_REC 	<V_LTABLET, LD_SOURCE, LD_ACCUM_Y+2, LTablet>
SAVE_TABLE_REC	<V_SPCCP, DH_V_PARENT, DH_MAJOR, HPCCP>
SAVE_TABLE_REC	<V_PSOFTKEY, DH_V_PARENT, DH_MAJOR, HPSoftkeys>
	
NUM_DEFINE_TBL_ENTRIES	equ	($-DefineTable)/8

;----------------------------------------------------------------------------;
; declare variables that are defined elsewhere				     ;
;----------------------------------------------------------------------------;

externB		fVectra			;tells us whether m/c is a vectra
externW		HPsize			;size of HP state save area
externW		HPWindowsSeg		;save windows HP state here
externW		HPDosAppSeg		;save app HP state here
externB		Woa6fValue		;INT 6F to be done or not

;----------------------------------------------------------------------------;
; declare all functions which might be called from other files.		     ;
;----------------------------------------------------------------------------;

		public	IsVectra
		public	FindVectra
		public	EnableVectra
		public	DisableVectra
		public	SaveLinkMapping
		public	RestoreLinkMapping
		public  SaveKeyTrans
		public	RestoreKeyTrans

;----------------------------------------------------------------------------;
; define other variables related to the job of saving vectra state.	     ;
;----------------------------------------------------------------------------;


GlobalW	HPVectorTable, 0		;Address of the HP Vector table
CurHPEntry	db	0		;Current HPEntry vector
CurHILState	db	0		;Bit 6= current HIL OFF state

;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
;									     ;
; SysCall	Driver, AXReg						     ;
;									     ;
; Purpose	General purpose HP system calling routine		     ;
;									     ;
; Parameters	Driver  which will be stored in BP			     ;
;		AX value						     ;
;									     ;
; Results	returns AH which is 0 for success			     ;
;				    2 for unsupported			     ;
;									     ;
;----------------------------------------------------------------------------;	

SysCall macro	device, AXReg
	mov	ax, device
	push	ax
	mov	ax, AXReg
	call	HPSysCall
	endm

cProc	HPSysCall,<NEAR>, <ds,bp>
	parmW	Device

cBegin	HPSysCall

	mov	bp, Device
	call	MakeHPIntCall		;make HP system INT call

cEnd	HPSysCall
	 
;----------------------------------------------------------------------------;
;									     ;
; SaveHPSystem( lpSystemState ):Size					     ;
;									     ;
; Purpose	To save the state of the HP EX-BIOS on the Vectra	     ;
;									     ;
; Parameters	lpSystemState - if NULL just return size. 		     ;
;		DS= SS=  Winoldap data segment				     ;
;									     ;
; Results	The size of SystemState in Paras			     ;
;									     ;
; Notes		The following items are saved:				     ;
;			HP Vector table					     ;
;			LTABLET	 data structure				     ;
;			LPOINTER data structure				     ;
;			LTOUCH	 data structure				     ;
;			all physical drivers mapping	       		     ;
;									     ;
;		Since the size of the system state can vary with different   ;
;		version of Vectra, SaveHPSystem should be called first with  ;
;		lpSystemState = NULL to get the size of the system state.    ;
;									     ;
;----------------------------------------------------------------------------;
cProc	SaveHPSystem, <NEAR,PUBLIC>, <DS,ES,SI,DI>

	parmD	HPState
	localW	StateSize  

cBegin	SaveHPSystem	

; set DS - Winoldap data segment, ES - Saved HP data segment, cld

	SysCall V_SYSTEM, <F_INS_BASEHPVT shl 8>
	mov	CS:[HPVectorTable], es
	cld
	
; Find the size of SAVE_STATE if HPState is NULL
; if load is true load them up
;
	les	di, HPState		;Inquire HPstate size if NULL
	mov	ax, es
	or	ax, di
	jz	SaveRet
	
; Save the vector table

	EnterCrit  
	xor	si, si
	mov	DS, CS:[HPVEctorTable]
	les	di, HPState
	lea 	di, ES:[di].VectorTable
 	mov	cx, (V_WINDOWS+6)/2
	cld
	rep	movsw

; Save the well defined data areas
	
	smov	ds,cs			;get stub data segment
	lea	si, DefineTable
	mov	cx, NUM_DEFINE_TBL_ENTRIES  

define_save_loop:

	mov	ax, DS:[si].SLoc
	add	ax, OFF_HPstate
	Save	cx
	cCall	SaveData, <DS:[si].SVector, DS:[si].SFirst, DS:[si].SLast, ax>
	add	si, size SAVE_TABLE_REC
	loop	define_save_loop

; Save the link mapping 

	les	di, HPState
	lea	di, es:[di].Devices
	call	SaveLinkMapping

; Save the keyboard translators

	les	di, HPState
	lea	di, es:[di].Translators
	call	SaveKeyTrans

; Save the speed and key click of the system. Note this will not
; work without EX-BIOS. Tuff Luck.

	les	di, HPState
	mov	bl, 1			;STATE_1
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_GET_STATE>
   	mov	es:[di].Click, bh
	mov	bl, 3			;STATE_3
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_GET_STATE>
   	mov	es:[di].Speed, bh
	
	LeaveCrit

SaveRet:

	mov	AX, size SAVE_STATE     ; AX= Size of HPstate in bytes using

cEnd	SaveHPSystem	
;----------------------------------------------------------------------------;
;									     ;
; RestoreHPSystem( lpSystemState )					     ;
;									     ;
; Purpose	To restore the state of the HP EX-BIOS on the Vectra	     ;
;									     ;
; Parameters	Long pointer lpSystemState				     ;
;		DS = SS = Winoldap data segment				     ;
;									     ;
; Notes		The following items are resotred:			     ;
;			HP Vector table					     ;
;			LTABLET	 data structure				     ;
;			LPOINTER data structure				     ;
;			LTOUCH	 data structure				     ;
;			all physical drivers mapping	       		     ;
;									     ;
;----------------------------------------------------------------------------;
cProc	RestoreHPSystem, <NEAR,PUBLIC>, <DS,ES,SI,DI>

	parmD	HPRState
	localV	CurrentDevices, 14

cBegin	RestoreHPSystem	
		
	EnterCrit

; Restore the speed and key click of the system

	les	di, HPState
	mov	bl, 1			;STATE_1
   	mov	bh, es:[di].Click
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_SET_STATE>
	mov	bl, 3			;STATE_3
   	mov	bh, es:[di].Speed
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_SET_STATE>
	
; Restore the keyboard translators

	les	di, HPRState
	lea	di, es:[di].Translators
	call	RestoreKeyTrans

; Restore the link

	les	di, HPRState
	lea	di, es:[di].Devices
	call	RestoreLinkMapping
					
; Restore the defined data areas

	smov	es,cs
	mov	ds, SEG_HPRState

; ES= Winoldap data - DS= Saved HP area

	lea	si, DefineTable
	mov	cx, NUM_DEFINE_TBL_ENTRIES		    

restore_loop:

	mov	ax, ES:[si].SLoc
	add	ax, OFF_HPRState
	Save	cx
	cCall	RestoreData, <ES:[si].SVector, ES:[si].SFirst, ES:[si].SLast, ax>
	add	si, size SAVE_TABLE_REC
	loop	restore_loop		

; Restore the vector table

	mov	es, CS:[HPVectorTable]	;DS= Saved HP area - ES= HP Vector table
	lds	si, HPRState
	lea 	si, [si].VectorTable
	xor	di, di
 	mov	cx, (V_WINDOWS+6)/2
	cld
	rep	movsw
		 
	LeaveCrit

cEnd	RestoreHPSystem	
;----------------------------------------------------------------------------;
;									     ;
; SaveKeyTrans - Save the state of the keyboard translators.		     ;
;									     ;
;	The state of the keyboard translators are saved in two places:	     ;
;	First, in the headers of V_SCCP and V_PSOFTKEY and in the	     ;
;	8042 chip.							     ;
;									     ;
;									     ;
; Entry									     ;
;	ES:DI	- Pointer to the save area. Must be 6 bytes.		     ;
;	DS, SS  - Winoldap data segment					     ;
;	HP ENTRY must be 6Fh						     ;
;									     ;
; Exit									     ;
;									     ;
; Uses									     ;
;	AX, BX								     ;
;									     ;
;----------------------------------------------------------------------------;

SaveKeyTrans:

	test	[fVectra], 1
	jz	skExit

; Save the cursor pad header

	mov	bx, V_SPCCP		;Cursor cursor pad	
	call	GetParent
	mov	es:[di], ax

; Save the SoftKeys header

	mov	bx, V_PSOFTKEY		
	call	GetParent
	mov	es:[di+2], ax
   
; Save the state of Scandor. If V_SCANDOOR is not present
; these calls will have no effect.

   	mov	bl, 0			;State 0
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_GET_STATE>
   	mov	es:[di+4], bh
   	mov	bl, 2			;State 2
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_GET_STATE>
   	mov	es:[di+5], bh
skExit:
	ret
	
; Save the parent
;    BX    =  Driver vector number
;    ES:DI -> Storage word	


GetParent:

	push	es
	
; get HP vector table

	mov	es, cs:[HPVectorTable]	
	
; get the Device header address

	mov	es, es:[bx+4]		;Get the DS of the driver
	mov	ax, es:[DH_V_PARENT]	;load the parent

; Store the parent

	pop	es
	ret
;----------------------------------------------------------------------------;
;									     ;
; RestoreKeyTrans - Restore the state of the keyboard translators.	     ;
;									     ;
;	The state of the keyboard translators are saved in two places:	     ;
;	First, in the headers of V_SCCP and V_PSOFTKEY and in the	     ;
;	8042 chip.							     ;
;									     ;
;									     ;
; Entry									     ;
;	ES:DI	- Pointer to the save area. Must be 6 bytes.		     ;
;	DS, SS  - Winoldap data segment					     ;
;	HP ENTRY must be 6Fh						     ;
;									     ;
; Exit									     ;
;									     ;
; Uses									     ;
;	AX, BX								     ;
;									     ;
;----------------------------------------------------------------------------;
RestoreKeyTrans:

	test	[fVectra], 1
	jz	rkExit

; Restore the cursor pad header

	mov	bx, V_SPCCP		;Cursor cursor pad	
	mov	ax, es:[di]
	call	SetParent

; Restore the SoftKeys header

	mov	bx, V_PSOFTKEY		
	mov	ax, es:[di+2]
	call	SetParent
   
; Restore the state of Scandor. If V_SCANDOOR is not present
; these calls will have no effect.

   	mov	bl, 0			;State 0
   	mov	bh, es:[di+4] 
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_SET_STATE>
   	mov	bl, 2			;State 2
   	mov	bh, es:[di+5]
   	SysCall	V_SCANDOOR, <F_STATE_IOCTL shl 8 + SF_SET_STATE>
rkExit:
	ret
	
; Set the parent
;    BX    =  Driver vector number
;    ES:DI -> Storage word	

SetParent:
	push	es
	
; get HP vector table

	mov	es, cs:[HPVectorTable]	
	
; get the Device header address

	mov	es, es:[bx+4]		;Get the DS of the driver
	mov	es:[DH_V_PARENT], ax	;set the parent

; Store the parent

	pop	es
	ret
;----------------------------------------------------------------------------;
;									     ;
; SaveLinkMapping							     ;
;									     ;
;	Save the device mapping of the HP-HIL link.			     ;
;									     ;
; Entry									     ;
;	ES:DI	- Pointer to the save area. Must be 28 bytes.		     ;
;	HP ENTRY must be 6Fh						     ;
;									     ;
; Exit									     ;
;									     ;
; Uses									     ;
;	C Convention							     ;
;			       						     ;
;----------------------------------------------------------------------------;
cProc 	SaveLinkMapping, <NEAR>, <ES,DS,SI,DI>

cBegin

	call	IsVectra
	jz	sdExit
	
	mov	si, di
	SysCall V_SINPUT, <F_INQUIRE_ALL shl 8>
	mov	si, di
	add	si, 14	
	SysCall V_SINPUT, <F_IO_CONTROL shl 8 + SF_GET_LINKS>

sdExit:

cEnd
;----------------------------------------------------------------------------;
;									     ;
; RestoreLinkMapping							     ;
;									     ;
;	Restore the device mapping of the HP-HIL link.			     ;
;									     ;
; Entry									     ;
;	ES:DI	- Pointer to the save area. Must be 28 bytes.		     ;
;	HP ENTRY must be 6Fh						     ;
;									     ;
; Exit									     ;
;									     ;
; Uses									     ;
;	C convention							     ;
;									     ;
;----------------------------------------------------------------------------;
cProc	RestoreLinkMapping, <NEAR>, <DS,ES,SI,DI>

	localV	CurrentDevices, 14

cBegin	

	call	IsVectra
	jz	rdExit
	
; Has the link changed ?

	push	es		   	;save map buffer
	smov	es,ss			;will read header data into stack
	lea	si, CurrentDevices
	SysCall V_SINPUT, <F_INQUIRE_ALL shl 8>
	pop	es			;get back buffer with saved links

	smov	ds,ss			;need to compare with data on stack

; DS:SI - current device header data, ES:DI - saved device header data.
; check to see if the device mapping is still intact or not.

	push	di
	mov	cx, 7
	cld
	repe	cmpsw
	pop	di
	je	restore_old
	

; device mappings have been changed (rare), saved link mappings are meaningless
; now. We will restore the default mapping.

	SysCall V_SINPUT, <F_IO_CONTROL shl 8 + SF_DEF_LINKS>
	jmp	short rdExit
	
; device mapping is still the same, restore the link mapping data.

restore_old:

	mov	si, di
	add	si, 14	
        SysCall V_SINPUT, <F_IO_CONTROL shl 8 + SF_SET_LINKS>

rdExit:

cEnd
;----------------------------------------------------------------------------;
;									     ;
; SaveData( Vector, Loc, Start, End ) 					     ;
;									     ;
; Purpose 	Save the data contained in a driver data space		     ;
;									     ;
; Parameters	Vector - HP System vector number			     ;
;		First - starting address				     ;
;		Last - ending address					     ;
;		Loc - save pointer					     ;
;									     ;
; On Entry	es - HP saved Data segment				     ;
;		ds - Winoldap data					     ;
;									     ;
; On Exit	es, ds, si, di preserved				     ;
;									     ;
;----------------------------------------------------------------------------;

cProc	SaveData, <NEAR,PUBLIC>, <es, ds, si, di>

	parmW	Vector
	parmW	First
	parmW	Last
	parmW	Loc

cBegin	SaveData	    

; move the data
	mov	bx, Vector    		;get describe record address
	mov	DS, CS:[HPVectorTable]
	mov	ds, ds:[bx+4]		
	mov	si, First
	mov	di, Loc			;load the destenation addres
	mov	cx, Last
	sub	cx, si	
	cld
	rep 	movsb

cEnd	SaveData
;----------------------------------------------------------------------------;
;									     ;
; RestoreData( Vector, Loc, Start, End ) 				     ;
;									     ;
; Purpose 	Restore the data contained in a driver data space	     ;
;									     ;
; Parameters	SS= Winoldap Data segment				     ;
;		DS= Saved HP data area					     ;
;		Vector - HP System vector number			     ;
;		First - starting address				     ;
;		Last - ending address					     ;
;		Loc - save pointer					     ;
;									     ;
;----------------------------------------------------------------------------;

cProc	RestoreData, <NEAR,PUBLIC>, <ES, SI, DI>

	parmW	Vector
	parmW	First
	parmW	Last
	parmW	Loc

cBegin	RestoreData	    

; find the HP vector table

	mov	es, CS:[HPVectorTable]

; move the data

	mov	bx, Vector    		;get describe record address
	mov	es, es:[bx+4]		;ES= device data segment
	mov	di, First
	mov	si, Loc
	mov	cx, Last
	sub	cx, di	
	cld
	rep 	movsb
	
cEnd	RestoreData
;----------------------------------------------------------------------------;
; IsVectra:							             ;
;									     ;
; Determine if this is a Vectra A, A+, A++ with EX-BIOS resident.	     ;
;									     ;
; Entry:								     ;
;  DS:		Winoldap data						     ;
;									     ;
; Exit:									     ;
;   If it is a Vectra ax != 0 and zero flag cleared			     ;
;									     ;
;----------------------------------------------------------------------------;

IsVectra	Proc	NEAR

;  Check if the PC is a Vectra. If Yes, then call HPSystem to get the
;  current size of the HP state

	push	ES			;Save it
	mov	AX, BIOS_SEG
	mov	ES, AX			;ES: Segment of ID code
	cmp	Word Ptr ES:[ID_OFFSET], 'PH'
	pop	ES			;Restore entry ES
	je	ivCheckBios
	jmp	short ivNo     		;Not a Vectra, so no extra HP processing

;  Check if EX-BIOS is present

ivCheckBios:	

	mov	AX, F16_INQUIRE
	mov	BX, AX			;set BX with out HP
	int	INT_KBD
	cmp	BX, 'HP'		;EX-BIOS present?
	je	ivYes			;No, finish

ivNo:	

	xor	ax, ax
	jmp	short ivRet

ivYes:	

; for a vactra the HP system vector is normaly 6fh, but there might be a
; substitute, so we will get the vector now.

	mov	ax,6F0Dh		;this magic Int 16h returns
	int	16h			;  the HP extended BIOS interrupt
	cmp	ah,2			;  number -- a return of 2 == 6Fh
	jne	@f			;  which is the default
	mov	ah,6Fh
@@:

; AH has the vector number, we will modify a byte in our code to prepare
; the INT xx instruction.

	mov	cs:[HPIntVector],ah	;modify code.

	xor	AX, AX
	inc	ax	

ivRet:	

	ret

IsVectra 	endp
;----------------------------------------------------------------------------;
; FindVectra:								     ;
;									     ;
; Set fVectra flag if we have a Vectra 	A, A+, or A++ with EX-BIOS resident. ;
; Initialize HPsize accordingly.					     ;
;									     ;
; This code is only accessed once when the first context-switchable BAD app  ;
; is executed. 								     ;
;									     ;
; Entry:								     ;
;  DS:		Winoldap data						     ;
;									     ;
; Exit:									     ;
;  fvectra, HPsize							     ;
;----------------------------------------------------------------------------;

FindVectra	Proc	NEAR

	assumes	ds,StubSeg
  
	mov	HPsize,0		;reset size incase not vectra
	call	IsVectra		;is it HP vectra ?
	jz	FindVRet		;No, finish
	mov	fVectra, 1	 	;Yes, flag we have a Vectra

; Under Windows, it is ASSUMED that HPentry is always 6Fh so we can issue
; EX-BIOS calls safely.

	xor	AX, AX
	cCall	SaveHPSystem, <AX, AX>

;  AX:	Size of the HP state in Bytes,convert it into paragraphs and save it

	shiftr	ax,4			;convert to paragraphs
	inc	ax			;round up to the next one
	mov	HPsize,ax		;save size of state in paragraph

FindVRet:

	ret

FindVectra	endp
;----------------------------------------------------------------------------;
; EnableVectra:								     ;
;									     ;
; If we have a Vectra A, A+, or A++ with EX-BIOS, save the current HPEntry   ;
; vector, HPHIL state and set HPentry=6Fh, Turn ON HPHIL.		     ;
;									     ;
; Entry:								     ;
;   DS:		Winoldap DATA						     ;
;									     ;
;									     ;
; Exit:									     ;
;   CurHPentry, CurHILState						     ;
;									     ;
; Regs:									     ;
;   AX, BX								     ;
;----------------------------------------------------------------------------;									     ;

cproc	EnableVectra, <NEAR>

cBegin

	cmp	CS:[fVectra], 1
	jne	EnVret			;No special processing if not a vectra

	push	BP
	push	DS

; Save current HP entry and set it to be 6Fh

	mov	AX, F16_GET_INT_NUMBER
	int	INT_KBD
	mov	CS:[CurHPEntry], HPENTRY ; Assume we have HPentry= 6Fh
	cmp	AH, RS_UNSUPPORTED
	je	EnVectraA		;We have a Vectra A, A+ if unsupported
	mov	CS:[CurHPEntry], AH	;Save it if valid

	mov	BL, HPENTRY		;~~tqn 061287
	mov	AX, F16_SET_INT_NUMBER
	int	INT_KBD

; Save current HPHIL state and set it ON

EnVectraA:

	mov	AH, F_SYSTEM
	mov	AL, SF_REPORT_STATE
	mov	BP, V_HPHIL
	call	MakeHPIntCall		;INT 6f or its substitute

; Bit 14 of BX (Status Word) = 1: HPHIL OFF
;			       0: 	ON

	mov	CS:[CurHILState], BH

; Turn HIL ON

	mov	AH, F_IO_CONTROL
	mov	AL, SF_HIL_ON
	mov	BP, V_HPHIL
	mov	ax,6F0Dh		;this magic Int 16h returns
	int	16h			;  the HP extended BIOS interrupt
	cmp	ah,2			;  number -- a return of 2 == 6Fh
	jne	@f			;  which is the default
	mov	ah,6Fh
@@:
	call	MakeHPIntCall		;INT 6f or its substitute
	pop	DS
	pop	BP

EnVret:	

cEnd	EnableVectra
;----------------------------------------------------------------------------;
; DisableVectra:      							     ;
;									     ;
; Restore the Vectra environment according to CurHPEntry and CurHILState     ;
; Assume that HPENTRY is always 6Fh					     ;
;									     ;
; Entry:								     ;
;   DS:		Winoldap DATA						     ;
;									     ;
; Exit:									     ;
;									     ;
;									     ;
; Regs:									     ;
;   AX, BX								     ;
;----------------------------------------------------------------------------;

cProc	DisableVectra, <NEAR>

cBegin

	cmp	CS:[fVectra], 1
	jne	DisVRet

	push	BP
	push	DS

; Restore the HIL state according to CurHILState

	mov	AH, F_IO_CONTROL
	mov	BP, V_HPHIL
	mov	AL, SF_HIL_ON		;~~tqn 061287 Assume HIL is ON
	test	CS:[CurHILState], B_HIL_STATE
	je	DisVHIL			;0= correct assumption
	mov	AL, SF_HIL_OFF		;~~tqn 061287

DisVHIL:

	call	MakeHPIntCall		;INT 6f or substitute

; Restore the Saved HPEntry

	mov	AX, F16_SET_INT_NUMBER
	mov	BL, CS:[CurHPEntry]
	int	INT_KBD

	pop	DS
	pop	BP

DisVRet:

cEnd	DisableVectra
;----------------------------------------------------------------------------;
; SaveWindowsHPState:							     ;
;									     ;
; This routine saves the state of the HP system when windows was around.     ;
;----------------------------------------------------------------------------;

cProc	SaveWindowsHPState,<NEAR,PUBLIC,PASCAL>

cBegin

	cmp	fVectra,0		;is this a Vectra PC
	jz	SaveWindowsHPStateRet	;nothing to save

; save the state in the pre allocated buffer.

	mov	es,HPWindowsSeg		;segment of save buffer
	xor	ax,ax			;offset is 0
	cCall	SaveHPSystem,<es,ax>	;save the state

; now enable the vectra before handing control to the old app

	cCall	EnableVectra		;see function defined above

SaveWindowsHPStateRet:

cEnd
;----------------------------------------------------------------------------;
; RestoreWindowsHPState:						     ;
;									     ;
; Restores the state of the HP system that was current while windows was act-;
; -ive.									     ;
;----------------------------------------------------------------------------;

cProc	RestoreWindowsHPState,<NEAR,PUBLIC,PASCAL>

cBegin

	cmp	fVectra,0		;is it a HP vectra
	jz	RestoreWindowsHPStateRet;no, nothing to restore

; disable the vectra settings that we had turned on for running the oldapp

	cCall	DisableVectra		;does some state restore

; now restore the state of the HP system from the saved state buffer

	mov	es,HPWindowsSeg		;segment of save buffer
	xor	ax,ax			;offset is 0
	cCall	RestoreHPSystem,<es,ax>	;restore the state

RestoreWindowsHPStateRet:

cEnd
;----------------------------------------------------------------------------;
; SaveDosAppHPState:							     ;
;									     ;
; Saves the state of the HP system before switching out from an Old App.     ;
;----------------------------------------------------------------------------;

cProc	SaveDosAppHPState,<NEAR,PUBLIC,PASCAL>

cBegin
	
	cmp	fVectra,0		;is it a HP Vectra system ?
	jz	SaveDosAppHPStateRet	;no, nothing to save

; save the state of the system

	mov	es,HPDosAppSeg		;segment of save buffer
	xor	ax,ax			;offset is 0
	cCall	SaveHPSystem,<es,ax>	;save the state

SaveDosAppHPStateRet:

cEnd
;----------------------------------------------------------------------------;
; RestoreDosAppHPState:							     ;
;									     ;
; Restores the HP state for an old app to what was current at the time of    ;
; switching the old app out.					   	     ;
;----------------------------------------------------------------------------;
cProc	RestoreDosAppHPState,<NEAR,PUBLIC,PASCAL>

cBegin
	
	cmp	fVectra,0		;is it a HP Vectra system ?
	jz	RestoreDosAppHPStateRet	;no, nothing to restore

; save the state of the system

	mov	es,HPDosAppSeg		;segment of save buffer
	xor	ax,ax			;offset is 0
	cCall	RestoreHPSystem,<es,ax>	;save the state

RestoreDosAppHPStateRet:

cEnd
;----------------------------------------------------------------------------;
; CheckWithApp:								     ;
;								             ;
; Tests to see if the app will allow us to switch out at this point.	     ;
; This routine will set zero if it is OK to switch out from the application. ;
;									     ;
; If INT 6F scheme has bisabled then simply return from this routine with    ;
; ZERO set. (It can be disabled by a switch setting in SYSTEM.INI)           ;
;----------------------------------------------------------------------------;

CheckWithApp	proc	near

	cmp	cs:[Woa6fValue],0	;int 6f to be bypassed ?
	jz	CheckWithAppEnd		;yes, bypass it.

	pushem	ax,si,di,bp,ds		;save the context

	call	CheckNotify		;is windows notification installed?
	jz	CheckWithAppRet		;no, so we can switch out.

; get the approval from the app to switch out.

	mov	bp, V_WINDOWS 		
	mov	ax, F_SYSTEM shl 8 + SF_REPORT_STATE
	call	MakeHPIntCall		;int 6f or its substitute
	or	ax,ax			;can switch out if zero.

CheckWithAppRet:
	
	popem	ax,si,di,bp,ds		;restore the saved registers

CheckWithAppEnd:

	ret

CheckWithApp	endp
;----------------------------------------------------------------------------;
;  CheckNotify:								     ;
;									     ;
;  Checks to see if the INT 6F notification hooks are installed or not.	     ;
;									     ;
;  Outputs:								     ;
;    ZF:	1: Hooks not installed					     ;
;		0: Hooks in						     ;
;----------------------------------------------------------------------------;									     ;

CheckNotify	proc near

	push	es			;save.
	cmp	cs:[fVectra], 1 	;do we have a Vectra ?
	jnz	CheckAsInIBM_PC_or_AT 	;check the IBM way
	mov	es, cs:[HPVectorTable]
	cmp	es:[V_WINDOWS +2], ROM_SEGMENT
	jmp	short CheckNotifyRet	;ZF set if V_WINDOWS CS = ROM_SEGMENT

CheckAsInIBM_PC_or_AT:

	xor	ax,ax			;need to access the IDT at segment 0:
	mov	es,ax			;es has IDT segment
	cmp	es:[4*HPENTRY+2],ROM_AREA;is INT 6F hook in the rom ?
	jb	CheckAsInIBM_PC		;no, but machine may be a IBM_PC
	xor	ax,ax			;vector in ROM for AT.
	jmp 	short CheckNotifyRet 	;app has not hooked INT 6F

CheckAsInIBM_PC:

	cmp word ptr es:[4*HPENTRY+2],0 ;Initial HPENTRY value in an IBM-PC

CheckNotifyRet:

	pop	es			;restore thrashed es
	ret

CheckNotify	endp
;----------------------------------------------------------------------------;
;  NotifyApp:								     ;
;									     ;
;  If the notification hooks are installed by the Oldapp, Notify that app    ;
;  that we have successfully complete a context switch and are back to resume;
;  the app.								     ;
;									     ;
; If INT 6F scheme is marked as disabled, simply return from the routine.    ;
; (it can be disabled by a switch setting in SYSTEM.INI)		     ;
;----------------------------------------------------------------------------;

NotifyApp	proc  near

	cmp	cs:[Woa6fValue],0	;int 6f tobe bypassed ?
	jz	NotifyAppEnd		;yes

	push	ax			;save
	call	CheckNotify		;is the notification hook in?
	jz	NotifyAppRet		;no,will not try to notify

; notification hook is in, notify the app that we are back.

	pushem	bp,ds			;save these registers
	mov	bp, V_WINDOWS		
	mov	ax, F_SYSTEM shl 8 + SF_START
	call	MakeHPIntCall		;int 6f or its substitute

	popem	bp,ds			;restore saved registers

NotifyAppRet:

	pop	ax			;restore

NotifyAppEnd:

	ret

NotifyApp	endp
;----------------------------------------------------------------------------;
; MakeHPIntCall:							     ;
; 									     ;
; This routine makes the HP system INT call. This is just an INT XX instruct-;
; -ion where XX is normally 6fh but may be different on some machines. The   ;
; XX part of the instruction will be modified at run time by the IsVectra    ;
; routine.								     ;
;----------------------------------------------------------------------------;

MakeHPIntCall  proc  near

		db	0cdh		 ;INT opcode
HPIntVector	db	6fh		 ;default is 6fh

		ret

MakeHPIntCall	endp
;----------------------------------------------------------------------------;
sEnd	StubSeg

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woahpeqs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


page	,132

;**************************************************************************
; This file contains equates, data structures and definitions needed to
; access both the Standard BIOS (STD-BIOS) and the Extended BIOS (EX-BIOS)
; of Vectra using MASM 3.0. Depending on what part of the BIOS you are
; accessing you might not need all the equates.  The equates are organized
; as follows:
;
;  o Usefull macros.
;  o 80286 Support Macros and Equates.
;  o EX-BIOS Equates:
;      1) Generic Structures and equates used by all drivers.
;      2) Equates for Vector Addressed.
;      3) Function and SubFunction Equates common to all drivers.
;      4) Function and Subfunction Equates individual to drivers. These
;         are order by vector number.
;  o Industry Standard (STD-BIOS) Interrupt numbers and function equates.
;  o Industry Standard (STD-BIOS) Data Area
;
; The major reason for organizing the equate file in this form is that
; the programmer can extract only those equates that he needs to create
; a tailored equate file.
;**************************************************************************

;**************************************************************************
; Useful macros. 
;**************************************************************************
;  none at this time


;**************************************************************************
; 80286 Support macros and equates.
;**************************************************************************
;**************************************************************************
; The following macro is used to compensate for a bug in the 80286
; hardware interrupt system.  It seems that during a normal
; POPF instruction cycle interrupts are always enabled regardless
; of the state of the interrupt enable flag prior to the pop or after
; the pop. 
;**************************************************************************
POPPF       macro
            jmp   $+3
            iret
            push  cs
            call $-2
            endm

;**************************************************************************
; EX-BIOS support macros and equates.
;**************************************************************************

; Equates for EX-BIOS interrupt number and vector address.  
HPENTRY                 equ     6FH
F_HPENTRY               equ     HPENTRY

BIOS_SEG		EQU	0F000H		; Vectra BIOS ROM Segment
ID_OFFSET		EQU	0F8H		; Vectra ROM ID Offset
;
;**************************************************************************
;                       SYSCALL [vector_address]
;**************************************************************************
syscall                 macro   vector
 ifnb                    <vector>
                        mov     bp,vector
 endif
                        int     HPENTRY
                        endm

ifndef SYS
;
;**************************************************************************
; HP_VECTOR_TABLE Entry
;**************************************************************************
HP_TABLE_ENTRY          struc   ;<1,2,3>
HP_ENTRY_IP             dw      0
HP_ENTRY_CS             dw      0
HP_ENTRY_DS             dw      0
HP_TABLE_ENTRY          ends
;**********************************************************************
; Structure of Data Header for HP's vectors.
;**********************************************************************
HP_SHEADER              STRUC  ;<1,2,3,4,5,6,7,8,9,0>
DH_ATR                  dw  0   ; Attribute
DH_NAME_INDEX           dw  0   ; Name index of driver.
DH_V_DEFAULT            dw  0   ; Driver vector position in HPtable
DH_P_CLASS              dw  0   ; Parent class
DH_C_CLASS              dw  0   ; Child class
DH_V_PARENT             dw  0   ; Vector used when the driver cannot handle
                                ; an F_ISR function call
DH_V_CHILD              dw  0   ; Vector used when the driver cannot handle
                                ; a regular function call
DH_MAJOR                db  0   ; Driver's major address if any.
DH_MINOR                db  0   ; Driver's minor address if any.
HP_SHEADER              ENDS
                        
;**********************************************************************
; DH_ATR bit record
;**********************************************************************
ATR_HP            equ  1000000000000000B ; 1- The Rest of header is valid
ATR_DEVCFG        equ  0100000000000000B ; 1- Present in DEVCONFG
ATR_ISR           equ  0010000000000000B ; 1- Replace My ISR   (Child)
ATR_ENTRY         equ  0001000000000000B ; 1- Replace My ENTRY (Parent)
ATR_RSVD          equ  0000000000000000B ; 0 - Available on allocation from HP
ATR_FREE          equ  0000001000000000B ; 1 - Available Vector
ATR_SRVC          equ  0000010000000000B ; 2 - Service Vector
ATR_LOG           equ  0000011000000000B ; 3 - Logical Device Start DEVCONFG CHA
ATR_IND           equ  0000100000000000B ; 4 - Filter, show driver (options)
ATR_BOT           equ  0000101000000000B ; 5 - End of Chain
ATR_ESC           equ  0000110000000000B ; 6 - Filter, Pass thru , No options
ATR_TYPE7         equ  0000111000000000B ; 7 - Available
ATR_TYPE_MASK     equ  0000111000000000B
ATR_INP           equ  0000000100000000B ;  1 - Chain ISR ( to Parents )
                                         ;  0 - Chain Entry ( Child)
ATR_SUBADD        equ  0000000000000000B
ATR_MAJOR         equ  0000000000100000B
ATR_MINOR         equ  0000000001000000B
ATR_MID           equ  0000000001100000B
ATR_PSHARE        equ  0000000000010000B
ATR_CSHARE        equ  0000000000001000B
ATR_ROM           equ  0000000000000100B
ATR_YIELD         equ  0000000000000010B ;
ATR_0             equ  0000000000000001B

;**********************************************************************
;  DH_Class
;**********************************************************************
CL_KBDFC           equ  1000000000000000B       ; 1 - HP Softkey Transaltor
CL_KBD             equ  0100000000000000B       ; 1 - Keyboard
CL_CCP             equ  0010000000000000B       ; 1 - Cursor Control pad
CL_CON             equ  0001000000000000B       ; 1 - Console Device
CL_BYTE            equ  0000100000000000B       ; 1 - PRN device
CL_COMM            equ  0000010000000000B       ; 1 - COMM device
CL_INTERFACE       equ  0000001000000000B       ; 1 - interface, HPHIL, HPIB
CL_FILT            equ  0000000100000000B       ; 1 - charachter filter
CL_BLK             equ  0000000010000000B       ; 1 - block device
CL_BOOT            equ  0000000001000000B       ; 1 - boot block device
CL_LGID            equ  0000000000100000B       ; 1 - logical physical gid
                                                ; e.g. ccp to gid translator
CL_PGID            equ  0000000000010000B       ; 1 - physical gid
CL_GID             equ  0000000000001000B       ; 1 - any graphics input device
CL_PTS             equ  0000000000000100B       ; 1 - physical touch screen
CL_ASCII           equ  0000000000000010B       ; 1 - ascii input device
CL_EXTEND          equ  0000000000000001B       ; 0 - set of classes above
                                                ; 1 - alternate class set
CL_ALL             equ  1111111111111111B       ; Member of all classes
CL_NULL            equ  0000000000000000B       ; Member No Classes

;***************************************************************************
; Vector Addresses
;***************************************************************************
V_SCOPY                 equ     0000H           ; Copyright Notice
V_DOLITTLE              equ     0006H           ; Nop Routine
V_PNULL                 equ     000CH           ; No Device 
V_SYSTEM                equ     0012H           ; System Intrinsics
V_SINPUT                equ     002AH           ; Input Inquire routines
V_SQWERTY               equ     0036H           ; Qwerty KBD Translator
V_PSOFTKEY              equ     003CH           ; HP f1-f8 Translator
V_PFUNCTION             equ     0042H           ; IBM F1-F10 Translator
V_PNUM_PAD              equ     0048H           ; Numeric Pad Translator
V_SPCCP                 equ     004EH           ; CCP Translator Driver
V_PVIDEO                equ     0054H           ; Video Intrinsics
V_STRACK                equ     005AH           ; Common cursor control funcs.
V_EVENT_TOUCH           equ     0060H           ; Touch Event Intercept
V_EVENT_TABLET          equ     0066H           ; Tablet Event Intercept
V_EVENT_POINTER         equ     006CH           ; Pointer Event Intercept
V_LCCP_CURSOR           equ     008AH           ; CCP to Cursor Always Filter (Default)
V_RAW                   equ     0090H           ; CCP+Softkey RAW Mode Filter
V_LCCP_NUMPAD           equ     0096H           ; CCP to Numeric Pad Filter
V_OFF                   equ     009CH           ; CCP+Softkey Off Filter
V_LCCP_GID              equ     00A2H           ; CCP to GID Filter ( Not Implemented)
V_LFUNCTION             equ     00A8H           ; Softkey (f1-f8) to Function
                                                ;  key (F1-F8) Filter (Default)
V_L8041                 equ     00AEH           ; 8041 Interface
V_PGID_CCP              equ     00B4H           ; Graphic to CCP Filter
V_LTABLET               equ     00BAH           ; Tablet driver
V_LPOINTER              equ     00C0H           ; Pointer driver
V_LTOUCH                equ     00C6H           ; Touch driver
V_LHPMOUSE              equ     00CCH           ; Microsoft/Mouse System's
                                                ;   Compatible Driver
V_LNULL                 equ     0108H           ; No Driver
 
endif	; SYS
 
V_HPHIL                 equ     0114H           ; HPHIL Driver
;
V_WINDOWS  		equ	168H		; HP Windows protocol driver
V_SCANDOOR		equ	016EH		; Scan Door driver	
;
;~~tqn	060887
;
;*********************************************************************
; Extended Keyboard functions (int 16h)
;*********************************************************************

INT_KBD			equ	16H		; Int 16h vetor 
F16_INQUIRE  	        equ	6F00H		; EX-BIOS presence
F16_GET_INT_NUMBER	equ	6F0DH		; Get HPentry vector
F16_SET_INT_NUMBER	equ	6F0EH		; Set HPentry vector
;
;~~
;*********************************************************************
; Common Function Codes for HP Routines.
;*********************************************************************
F_ISR                   equ     00H*2           ; Interrupt service call
F_SYSTEM                equ     01H*2           ; System func. call,
                                                ;   Subfunction required
F_IO_CONTROL            equ     02H*2           ; Device/Driver Dependent
                                                ;   Functions
F_ITF_TO_ENVOY          equ     F_IO_CONTROL    ; Translation function for
                                                ;   SITF_ENVOY service.
F_PUT_BYTE              equ     03H*2           ; Write one byte of data:
                                                ;   Byte is in AL
F_GET_BYTE              equ     04H*2           ; Read a byte of data:
                                                ;   Byte returned in AL
F_PUT_BUFFER            equ     05H*2           ; Write a buffer of data,
                                                ;   ES,DI pointer, CX count
F_GET_BUFFER            equ     06H*2           ; Read a buffer if data,
                                                ;   ES,DI pointer, CX count
F_PUT_WORD              equ     07H*2           ; Write word of data, BX data
F_GET_WORD              equ     08H*2           ; Read word of data, BX data
F_GETTRM_BUFFER         equ    009H*2           ; Reads buffer of data,
                                                ;   ES,DI pointer, CX count
                                                ; BH upper bound, BL lower bound
F_PUT_BLOCK             equ     F_PUT_BUFFER    ;used for disk applications
F_GET_BLOCK             equ     F_GET_BUFFER

;*********************************************************************
; Common Subfunction codes of the F_SYSTEM Function.
;*********************************************************************
SF_INIT                 equ     00H*2   ;Initialize command
SF_START                equ     01H*2   ;Secondary Init--initialize dependent
                                        ; upon other drivers/data structures         
SF_REPORT_STATE         equ     02H*2   ;Reports state of driver
SF_VERSION_DESC         equ     03H*2   ;Report version and option describe
                                        ;  record
SF_DEF_ATTR             equ     04H*2   ;Reports default Configuration
                                        ;   (Baud Rate)
SF_GET_ATTR             equ     05H*2   ;Reports Current Configuration
                                        ;   ES,DI pointer
SF_SET_ATTR             equ     06H*2   ;Sets Next Configuration ES,DI, CX
SF_OPEN                 equ     07H*2   ;Reserve Driver for exclusive access
SF_CLOSE                equ     08H*2   ;Release  "   from    "        "
SF_TIMEOUT              equ     09H*2   ;Notify Driver Timeout Occurred
SF_INTERVAL             equ     0AH*2   ;Notify Driver Interval Occurred
SF_TEST                 equ     0BH*2   ;Test Function

;*********************************************************************
; Common Subfunction Codes for the F_IO_CONTROL function.
;*********************************************************************
SF_LOCK                 equ     00H*2   ; Lock Device for exclusive access
SF_UNLOCK               equ     01H*2   ; Unlock Device for exclusivce access
;
;~~tqn 060887
;
SF_HIL_ON		equ	26H	; Turn ON HIL  (A++)
SF_HIL_OFF		equ	28H	; Turn OFF HIL (A++)
B_HIL_STATE		equ	01000000B ; HIL OFF state from SF_REPORT_STATE
;
;~~
;*********************************************************************
; HP Routines Return Status: Sucessful codes are positive and failure
; are negative.
;*********************************************************************
RS_BREAK         equ    00CH            ; Break -- IFC
RS_DATA_NREADY   equ    00AH            ; RS232 Data Not Ready=>Retry Operation
RS_OVERRUN       equ    008H            ; RS232 Port Data Overrun =>Retry Operation
RS_DONE          equ    006H            ; indicates all done return child
RS_NOT_SERVICED  equ    004H            ; indicates a chained ISR--not handled
RS_UNSUPPORTED   equ    002H            ; indicates function is NOPed/not valid
                                        ; for this driver
RS_SUCCESSFUL    equ    F_ISR           ; indicates executed just fine
RS_SERVICED      equ    rs_SUCCESSFUL   ; indicates chained ISR done
RS_PASSTHRU      equ    rs_SERVICED     ; indicates launch data to parent


ifndef SYS
;
;************************************************************************
RS_FAIL          equ    0FEH            ; To be used with hardware failure
RS_TIMEOUT       equ    0FCH            ; to indicate remote device timeout
RS_BAD_PARAMETER equ    0FAH            ; to indicate a bad parameter
RS_BUSY          equ    0F8H            ; to indicate driver/device is busy
RS_NO_VECTOR     equ    0F6H            ; out of hp_VT vectors
RS_OFFLINE       equ    0F4H            ; device is offline
RS_OUT_OF_PAPER  equ    0F2H            ; out of paper on printer device
RS_PARITY        equ    0F0H            ; parity error in transmission
RS_FRAME         equ    0EEH            ; framing error

;******************************************************************************
; Function Number Equates for the EX-BIOS routines and its Data Structures.
;******************************************************************************

;*********************************************************************
; V_SYSTEM (0012H) function codes.
;*********************************************************************
F_INS_BASEHPVT          equ     0004H
F_INS_XCHGFIX           equ     0006H
F_INS_XCHGRSVD          equ     0008H
F_INS_XCHGFREE          equ     000AH
F_INS_FIXOWNDS          equ     000CH
F_INS_FIXGETDS          equ     000EH
F_INS_FIXGLBDS          equ     0010H
F_INS_FREEOWNDS         equ     0012H
F_INS_FREEGETDS         equ     0014H
F_INS_FREEGLBDS         equ     0016H
F_INS_FIND              equ     0018H
F_INS_FINDALL           equ     001AH
F_INS_NXTLOGBLK         equ     001CH
F_RAM_GET               equ     001EH
F_RAM_RET               equ     0020H
F_CMOS_GET              equ     0022H
F_CMOS_RET              equ     0024H
F_CMOS_HPDFLTS          equ     0026H
F_CMOS_IBMDFLTS         equ     0028H
F_YIELD                 equ     002AH
F_INS_ADR               equ     002CH
F_RESERVE_STRING3       equ     002EH
F_SND_CLICK_ENABLE      equ     0030H
F_SND_CLICK_DISABLE     equ     0032H
F_SND_CLICK             equ     0034H
F_SND_BEEP_ENABLE       equ     0036H
F_SND_BEEP_DISABLE      equ     0038H
F_SND_BEEP              equ     003AH
F_SND_SET_BEEP          equ     003CH
F_SND_TONE              equ     003EH
F_STR_GET_FREE_INDEX    equ     0040H
F_STR_DEL_BUCKET        equ     0042H
F_STR_PUT_BUCKET        equ     0044H
F_STR_GET_STRING        equ     0046H
F_STR_GET_INDEX         equ     0048H

;**********************************************************************
;  String Bucket Header. This structure is usefull if using the
; following V_SYSTEM functions: F_STR_DEL_BUCKET and F_STR_PUT_BUCKET.
;**********************************************************************
STR_HEADER              STRUC
STR_NXT_HDR             dd      (?)
STR_UPPER_BOUND         dw      (?)
STR_LOWER_BOUND         dw      (?)
STR_LIST_PTR            dd      (?)
STR_SEGMENT             dw      (?)
STR_HEADER              ENDS

;**********************************************************************
;  V_SYSTEM Global Data Segment
;**********************************************************************
HP_GLB_HEADER           STRUC
T_HP_HEADER             dw      (?)
T_USED_AND_RESERVED     dw      6 dup (?)
T_HP_LAST_DS            dw      (?)
T_HP_MAX_DS             dw      (?)
T_HP_NXT_VCTR           dw      (?)
T_SND_FLAG              db      (?) ;
T_SND_CLICK_COUNT       db      (?) ;
T_SND_CLICK_DURA        db      (?) ;
T_SND_CLICK_VOLUME      db      (?) ;
T_SND_BEEP_CYCLE        dw      (?) ;
T_SND_BEEP_DURA         dw      (?) ;
T_SND_BEEP_COUNT        db      (?) ;
                        db      (?) ;  1 reserved byte for volume
T_STR_NEXT_INDEX        dw      (?)
T_STR_ROOT              dd      (?)
T_STR_VCT_HDR           db      size STR_HEADER dup (?) ; Area vector's name and
T_STR_MSG_HDR           db      size STR_HEADER dup (?) ; ROM message strings
T_8259_FLAGS            db      (?)
                        db      31 dup (?) ; reserve 2 paragraph
HP_GLB_HEADER           ENDS

;*********************************************************************
; V_SINPUT (2AH) Function and subfunction codes.
;*********************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
F_INQUIRE               equ     0006H
F_INQUIRE_ALL           equ     0008H ; Reports ID's of devices
F_INQUIRE_FIRST         equ     000AH ; Reports (V_HPHIL1) offset
F_REPORT_ENTRY          equ     000CH ; Reports entrypoint of (V_PGID)

;
; Extra subfunctions under F_IO_CONTROL.
;
SF_DEF_LINKS            equ     0000H ; Sets default cofiguration
SF_GET_LINKS            equ     0002H ; Reports current configuration
SF_SET_LINKS            equ     0004H ; Sets Next Configuation
;
SF_MOUSE_DSIZE		equ	0006H ; Return sizes of HPMouse and HPTrack

;**********************************************************************
; V_LGID Fucntion Codes. This is a common driver for: V_LTABLET, 
; V_LPOINTER and V_LTOUCH.
;**********************************************************************
F_SAMPLE                equ     06
; F_IO_CONTROL:
SF_TRACK_ON             equ     4
SF_TRACK_OFF            equ     6
SF_CREATE_EVENT         equ     8
SF_EVENT_ON             equ     0Ah
SF_EVENT_OFF            equ     0Ch
SF_CLIPPING_ON          equ     0Eh
SF_CLIPPING_OFF         equ     10h
;**********************************************************************
; V_LGID LD_DEVICE_STATE
;**********************************************************************
EVENT_ENABLED           equ     10h
TRACK_ENABLED           equ     08h
CLIP_ENABLED            equ     04h
BUTTON_ERROR            equ     02H
ISR_IN_PROGRESS         equ     01H

;*********************************************************************
; V_PGID Data Structures
;*********************************************************************
DESCRIBE        STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
D_SOURCE        db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 (low nibble) is the address of the device
D_HPHIL_ID      db      ?       ; device id byte returned by an HPHIL device
D_DESC_MASK     db      ?       ; describe header from HPHIL device
D_IO_MASK       db      ?       ; I/O descriptor byte from device
D_XDESC_MASK    db      ?       ; extended describe byte from device
D_MAX_AXIS      db      ?       ; maximum number of axis reported
D_CLASS         db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
D_PROMPTS       db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
D_RESERVED      db      ?       ; reserved for future
D_BURST_LEN     db      ?       ; maximum burst length output to a device
                                ; if devices supports more than 255 bytes then
                                ; 255 bytes is the default maximum
D_WR_REG        db      ?       ; number of write registers supported by a device
D_RD_REG        db      ?       ; number of read registers supported by a device
D_TRANSITION    db      ?       ; transitions reported per button
D_STATE         db      ?       ; current state of buttons
D_RESOLUTION    dw      ?       ; counts / cm (m) returned by HPHIL device
D_SIZE_X        dw      ?       ; Maximum count of in units of resolution
D_SIZE_Y        dw      ?       ;
D_ABS_X         dw      ?       ; data reported from device
D_ABS_Y         dw      ?       ; that reports absolute data
D_REL_X         dw      ?       ; data reported from device
D_REL_Y         dw      ?       ; that is relitive
D_ACCUM_X       dw      ?       ; these are used to accumulate scaling
D_ACCUM_Y       dw      ?       ; remainder
DESCRIBE        ENDS

DESCRIBE_SIZE   	equ     size DESCRIBE
D_CCP_STATE             equ     D_STATE + 1
D_SIZE                  equ     D_SIZE_X
D_SAMPLE_ABSOLUTE       equ     D_ABS_X
D_SAMPLE_RELATIVE       equ     D_REL_X
D_REMAINDER_ACCUM       equ     D_ACCUM_X
D_BUFFER                equ     D_SIZE_X        ; offset where buffer begins
D_CLASS_CURRENT 	equ     0F0H
D_CLASS_DEFAULT 	equ     00FH
; The field LD_SOURCE uses the following to access the defined nibbles
D_ADDR_MASK             equ     00FH
D_TYPE_MASK             equ     0F0H
;*********************************************************************
; V_LGID Data Structures
;*********************************************************************
LDESCRIBE       STRUC
                db      size HP_SHEADER dup (?) ; this data is always offset by
LD_SOURCE       db      ?       ; 7-4 (high nibble) contains the GID type
                                ; 3-0 reserved
LD_HPHIL_ID     db      ?       ; device id byte returned by an HPHIL device
LD_DEVICE_STATE dw      ?       ; status bits for logical device
LD_INDEX        db      ?       ; vector index of invoking driver
LD_MAX_AXIS     db      ?       ; maximum number of axis reported
LD_CLASS        db      ?       ; device class
                                ; 7-4 (high nibble) contains current class
                                ; 3-0 (low nibble) contain the default class
LD_PROMPTS      db      ?       ; number of buttons/prompts
                                ; 7-4 (high nibble) is the number of prompts
                                ; 3-0 (low nibble) is the number of buttons
LD_RESERVED     db      ?       ; reserved for future
LD_RES2         db      ?
LD_RES3         db      ?
LD_RES4         db      ?
LD_TRANSITION   db      ?       ; transitions reported per button
LD_STATE        db      ?       ; current state of buttons
LD_RESOLUTION   dw      ?       ; counts / cm (m) returned by HPHIL device
LD_SIZE_X       dw      ?       ; Maximum count of in units of resolution
LD_SIZE_Y       dw      ?       ;
LD_ABS_X        dw      ?       ; data reported from device
LD_ABS_Y        dw      ?       ; that reports absolute data
LD_REL_X        dw      ?       ; data reported from device
LD_REL_Y        dw      ?       ; that is relitive
LD_ACCUM_X      dw      ?       ; these are used to accumulate scaling
LD_ACCUM_Y      dw      ?       ; remainders
LDESCRIBE       ENDS
LDESCRIBE_SIZE 		equ     size LDESCRIBE

LD_SIZE                 equ     LD_SIZE_X
LD_SAMPLE_ABSOLUTE      equ     LD_ABS_X
LD_SAMPLE_RELATIVE      equ     LD_REL_X
LD_REMAINDER_ACCUM      equ     LD_ACCUM_X
LD_BUFFER               equ     LD_RESOLUTION   ; offset where buffer begins
; the following mask are used in the field LD_CLASS
LD_CLASS_CURRENT        equ     0F0H
LD_CLASS_DEFAULT        equ     00FH

;************************************************************************
; V_LHPMOUSE (00CCH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
SF_MOUSE_COM            equ     0000H   ; This function is used during the 
                                        ; reinit call from DOS.  It is used
                                        ; to set up INT 33H.  This is done  
                                        ; because DOS takes INT 33H when it
                                        ; is initialized.
SF_MOUSE_OVERRIDE       equ     0002H   ; This function is used to force the
                                        ; V_LHPMOUSE driver to install INT 33
                                        ; even when the mouse is not present.
                                        ; This allows a programmer to map
                                        ; devices to the V_LHPMOUSE driver if
                                        ; a mouse is not present.

;************************************************************************
; V_STRACK (05AH) Function and subfunction codes.
;************************************************************************
F_TRACK_INIT            equ     0004H   ; used to perform a soft initialization
                                        ; of the tracking driver.
F_TRACK_ON              equ     0006H   ; enables tracking
F_TRACK_OFF             equ     0008H   ; disables tracking
F_DEF_MASKS             equ     000AH   ; define masks for sprite
F_SET_LIMITS_X          equ     000CH   ; define X limit of screen coordinates
F_SET_LIMITS_Y          equ     000EH   ; define Y limits
F_PUT_SPRITE            equ     0010H   ; Used to put the sprite on the screen
F_REMOVE_SPRITE         equ     0012H   ; removes the sprite from the screen

;************************************************************************
; V_HPHIL (0114H) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_IO_CONTROL particular to this driver.
;
SF_CRV_CRV_MAJ_MIN      equ     0004    ; This is used to set a default
                                        ; major and minor addresses
SF_CRV_RECONFIGURE      equ     0006    ; Funtion id used to force the HPHIL
                                        ; link to reconfigure the devices
SF_CRV_WR_PROMPTS       equ     0008    ; Used to write a prompt to a device
SF_CRV_WR_ACK           equ     000A    ; Used to write an acknowledge to a
                                        ; device
SF_CRV_REPEAT           equ     000C    ; Function is used to set a 30 Hz or
                                        ; 60 Hz repeat for keyboards
SF_CRV_DISABLE_REPEAT   equ     000E    ; Used to cancel the repeat rates in 
                                        ; keyboards
SF_CRV_SELF_TEST        equ     0010    ; Used to issue a selftest command
                                        ; to a physical device
SF_CRV_REPORT_STATUS    equ     0012    ; Used to get the status information 
                                        ; that an HPHIL device might wish to
                                        ; report.  For specific information
                                        ; on what is reported, see the specs
                                        ; for the device.
SF_CRV_REPORT_NAME      equ     0014    ; This function is used to return the
                                        ; ascii name that a device has.
SF_ENVOY_REPEAT         equ     0016    ; Used to set the keyboard repeat
                                        ; and delay rates
SF_ENVOY_LED            equ     0018    ; Used to set the keyboard LEDs

;************************************************************************
; V_SCANDOOR (016EH) Function and subfunction codes.
;************************************************************************
; F_ISR, F_SYSTEM and F_IO_CONTROL are functions common to all drivers.
; Subfunction under F_STATE_IOCTL particular to this driver.
;
F_STATE_IOCTL		equ	0008H	; Get and set the state

SF_GET_STATE		equ	0000H	; 
SF_SET_STATE		equ	0002H	; 

;**********************************************************************
; V_HPHIL Data Structure - do not tread lightly in this data structure
;**********************************************************************
HPHIL_DATA              struc
                        db      size HP_SHEADER DUP (?) ; dirver header
CRV_STATUS              dw      ?
CRV_ENVOY_STATUS        db      ?     ; status bits used to support
                                      ; the envoy keyboard
CRV_CURRENT_STATE       db      ?     ; current configuration address
CRV_ADDRESS             db      ?     ; configuration address
CRV_POLL_ADDRESS        db      ?     ; address of device whose poll
CRV_POLL_HEADER         db      ?     ; poll header of data being proc
CRV_MAJOR               db      ?     ; default major address
CRV_MINOR               db      ?     ; default minor address
CRV_EXPECTED_CMD        db      ?     ; command expected to return
CRV_KBD_ADDRESS         db      ?     ; address of the keyboard
CRV_MAX_DEVICES         db      ?     ; status byte of itf keycode tra
CRV_KC_STATE            db      ?     ; state of itf kc translation
CRV_POLL_RECORD         db      32 DUP (?)      ; poll record buffer
RQ_ENV_REPEAT           db      ?     ; envoy special command for repe
RQ_ENV_DELAY            db      ?     ; envoy special command for dela
RQ_ENV_LED              db      ?     ; envoy special command for led'
RQ_RequEST              db      ?
RQ_REGISTER             db      ?
RQ_ADDRESS              db      ?
RQ_DATA                 db      ?
RQ_MAX_BURST            dw      ?
RQ_COUNT                dw      ?
RQ_OFFSET               dw      ?
RQ_SEGMENT              dw      ?
RQ_SPECIAL              db      ?
RQ_TIMEOUT              db      ?
HPHIL_DATA      ends
;
endif	; SYS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woainit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file has most of the initialization code. All the procedures in this  ;
; file are needed only during the initialization phase and are defined in a  ;
; main code segment. WOA will ignore this segment when it does swapping etc  ;
; as all of the code in this segment id discardable in any case.             ;
;                                                                            ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Thu May-03-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)    		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include	njmp.mac
	include woaerr.inc
	include woakeys.inc
	include dosx.inc
	include	grabber.inc
	include woaswch.inc
	.list

	.8086				;must have to run on 8086s too.

;----------------------------------------------------------------------------;
; define the external function calls.					     ;
;----------------------------------------------------------------------------;


	;-------------------------------------------------------;
	; external FAR OLDAPP procedures.                       ;
	;-------------------------------------------------------;


;----------------------------------------------------------------------------;

sBegin	Data

	;-------------------------------------------------;
	; declare all external data seg variables.        ;
	;-------------------------------------------------;

externB		DataSegEnd		;end of _DATA segment
externB		EmsFlag			;EMS present or not.
externB		XmsFlag			;XMS present or not
externB		SwitcherColors		;colors for switcher screen
externB		WoaSwap1Path		;first swap path.
externB		WoaSwap2Path		;second swap path.
externW		Swap1MinK		;min size to be left on 1st path
externW		Swap2MinK		;min size to be left on 2nd path
externB		ErrorType		;WOA error type
externW		hApp			;window handle for this instance
externB		CurrentPathId		;swap path id for current AP.
externB		StartRestartId		;start or restart
externW		HighMemXmsHandle 	;handle of the high mem XMS block
externW 	StubSegSize   		;size of real mode stub segment
externW 	WoaCsSize		;size of protected mode code seg
externW 	WoaDsSize		;size of winoldap data segment
externD		XmsBankSize	    	;size of XMS to be allocated
externW		XmsHeapWalkSel		;scratch selector for walking xms heap
externW 	WoaStubSel		;sel for current loaction of stub code
externW		ArenaWalkSel	   	;temp selector for walkimg arena chain
externW		ArenaRWSel	   	;temp sel for reading/writing arenas
externW 	AppXmsBaseSel		;selector to base of apps XMS block
externB		DosAppSwapFileName	;app swap file name
externW 	DosAppNumber		;app number to be run in this instance
externB		FileTemplate		;for deleting files
externB		WoaSwapFilePrefix   	;'~WOA'
externB	 	DiskSwap1Drive	    	;swap drive index for drive 1
externB	 	DiskSwap2Drive	    	;swap drive index for drive 1
externD		lpXmsControl		;XMS control function address
externW		AppMinMem		;minimum memory required
externW		AppMinXmsK		;minimum XMS memory required
externW		AppMaxXmsK		;maximum xms required
externW		LowMemSel		;pointer to start of block
externB		LowMemBlockType		;type of the low mem block
externW		LowMemArenaSel		;pointer to its arena
externW		LowMemParaSize		;size of available low memory in para
externD		HighMemSize		;size of available high heap
externW		WoaPDBSeg		;WOA's PSP
externW		SegResizeBlock		;block to resize in real mode
externW		SizeReservedArea 	;size of area reserved area at heap st.
externW		UsableLowHeapSel	;sel/seg for reusable part of low heap
externW		SegAfterReservedArea	;segment after the reserved area
externW		StartScreenLines	;startup no of screen lines
externB		SwitcherID		;ID of this switcher (bits 14 & 15)

	;-------------------------------------------------------;
	; define any locally used constants.			;
	;-------------------------------------------------------;


	;-------------------------------------------------------;
	; define any external constants.       			;
	;-------------------------------------------------------;

		externA   IS_WINOLDAP_ACTIVE	;(WOAMGR.ASM)

	;------------------------------------------------------;
	; define public names.				       ;
	;------------------------------------------------------;

		public	GetSegmentLimits

sEnd	Data
;----------------------------------------------------------------------------;
; declare external FAR Winoldap procedures.				     ;
;----------------------------------------------------------------------------;

	externFP ErrorHandler			;(WOAMGR.ASM)
	externFP FarCopyBasicSwap1FileName     	;(WOAMGR.ASM)
	externFP FarCopyBasicSwap2FileName     	;(WOAMGR.ASM)
	externFP FarAppendUniqueNumber		;(WOAMGR.ASM)
	
;----------------------------------------------------------------------------;
; Declare the the code segment and any labels that we want to refernce in it;
;----------------------------------------------------------------------------;

	;-------------------------------------------------;
	; define external data references.		  ;
	;-------------------------------------------------;

sBegin	Code

	externB		CodeSegEnd		;end of _TEXT segment

sEnd 	Code

sBegin	StubSeg	

;----------------------------------------------------------------------------;
; declare external data refernces.					     ;
;----------------------------------------------------------------------------;

externB		WoaGrabberName		;(WOARLM.ASM)
externB		WoaGrabberSwapPath	;(WOARLM.ASM)
externB		WoaPath			;(WOARLM.ASM)
externB		WoaParams		;(WOARLM.ASM)
externB		WoaFcb1			;(WOARLM.ASM)
externB		WoaFcb2			;(WOARLM.ASM)
externB		Woa6fValue		;(WOARLM.ASM)
externB		WoaIrq9Global		;(WOARLM.ASM)
externB		WoaNetAsyncSwitching	;(WOARLM.ASM)
externW		WoaCpuType		;(WOARLM.ASM)
externW		WoaFileEntrySize	;(WOARLM.ASM)
externB		WoaBehavior		;(WOARLM.ASM)
externB		WoaHotKeys		;(WOARLM.ASM)
externW		WoaStartScreenLines	;(WOARLM.ASM)
externB		WoaAltTabDisabled	;(WOARLM.ASM)
externB		WoaShftAltTabDisabled	;(WOARLM.ASM)
externB		WoaAltEscDisabled	;(WOARLM.ASM)
externB		WoaShftAltEscDisabled	;(WOARLM.ASM)
externB		WoaCtrlEscDisabled	;(WOARLM.ASM)
externB		WoaSwitcherID		;(WOARLM.ASM)


sEnd	StubSeg
;----------------------------------------------------------------------------;

sBegin	StubSeg

; InitStartLine MUST be at the very start of the one time initialization code,
; it is the address which will be used to discard the one time initialization
; code after itis done.

	public	InitStartLine

InitStartLine	equ	$	;MAKE ME FIRST!  Everything after this will
				;  be discarded after initialization


externB XmsStartLine			;start of XMS handler in real mode stub
externB	StubSegEnd			;end of _WOARLMSEG segment

	;-------------------------------------------------;
	; define local entry points                       ;
	;-------------------------------------------------;


 	assumes	cs,StubSeg
	assumes	ds,Data
	assumes	es,nothing

;----------------------------------------------------------------------------;
; define temporary strings.						     ;
;----------------------------------------------------------------------------;

szEmsName		db	'EMMXXXX0'	;EMM device name

;----------------------------------------------------------------------------;
; define local constants.						     ;
;----------------------------------------------------------------------------;

CMD_LINE_PARAM_LEN	equ	2		;length of command line param
VALID_CMD_LINE_PARAM	equ	0FE20H		;valid parameter

;----------------------------------------------------------------------------;
; include the HELP text message. This is a separate file for international   ;
; conversions.								     ;
;----------------------------------------------------------------------------;

	include		woahelp.inc

;----------------------------------------------------------------------------;
; ParseCommandLine:							     ;
;									     ;
; DOSSWAP expects a special parameter from the DOSSHELL which tells it that  ;
; it is being run from the SHELL and not from a DOS prompt. This is actually ;
; a space followed by a special character which is kinda difficult to type   ;
; in from the keyboard (At this point it is 0FEH, 08H would probably have    ;
; been the best!). If we do not find this special parameter, we will print   ;
; out a help text and exit.						     ;
;----------------------------------------------------------------------------;
cProc	ParseCommandLine,<FAR,PASCAL,PUBLIC>

cBegin

; command line shoule be at DS:80H.

	mov	si,80h			;default DTA address
	lodsb				;get length of command line 
	cmp	al,CMD_LINE_PARAM_LEN	;is it the length that we expect ?
	jnz	PCL_PrintHelpText	;no, print help text and exit

; check the validity of the parameter.

	lodsw				;get the next two words
	.errnz	CMD_LINE_PARAM_LEN - 2
	cmp	ax,VALID_CMD_LINE_PARAM ;is it the one that we expect ?
	jz	PCL_Ret			;yes, carry is clear too.

PCL_PrintHelpText:

; we don't expect any parameters. Simply print an error message an exit

	push	ds			;save
	push	cs
	pop	ds			;ds points has stub seg
	mov	dx, StubSegOFFSET HelpText
	mov	ah,9
	int	21h			;print help message
	pop	ds			;restore
	stc				;error exit, but no error code

PCL_Ret:

cEnd
;----------------------------------------------------------------------------;
; InitializeWoa:							     ;
;									     ;
; This routine setus up some WOA variables by reafing SYSTEM.INI etc. This   ;
; code is executed only once and the advantage of having it in a separate    ;
; code segment is that we will ignore all the code in this segment after     ;
; the initializations are done.                                              ;
;----------------------------------------------------------------------------;

cProc	InitializeWoa,<FAR,PASCAL,PUBLIC>

	parmW	StartRestart		;start or restart

cBegin
	
;----------------------------------------------------------------------------;
; find out if EMS is present or not, setting flag appropriately.   	     ;
;----------------------------------------------------------------------------;

	mov	ax,3567h		;want to get INT 67 vector
	int	21h			;ES:BX has the vector
	mov	di,10			;want to inspect offset 10
	mov	si,StubSegOFFSET szEmsName ;DS:SI points to exepected name
	mov	cx,8			;need to compare 8 bytes
	cld				;set proper direction flag
	push	ds			;save
	smov	ds,cs			;load code
	repz	cmpsb		    	;compare names
	pop	ds			;restore
	jnz	@f			;names do not match, driver absent
	mov	EmsFlag,0ffh		;EMS driver prsent
@@:
;----------------------------------------------------------------------------;
; Parse the FCBS in the command line for the EXEC call.			     ;
;----------------------------------------------------------------------------;

	cmp	StartRestart,1			;if restart
	jz	@f				;skip this
	mov	si,StubSegOFFSET WoaParams+1	;point to the parameters
	mov	di,StubSegOFFSET Woafcb1 	;fill in the first FCB 
	smov	es,cs				;all in same segment
	mov	ax,2901h	
	int	21h				;PARSE DOS call
	call	find_next_arg			;looks for further args
	jnz	@f				;no second parameter
	mov	di,StubSegOFFSET Woafcb2
	mov	ax,2901h
	int	21h				;parse and fill in fcb2
@@:

; deal with memory requirements.

	cCall	AllocateXms		;allocate all of XMS if HIMEM is loaded

; check for extended memory requirements, if the requirements are not 
; satisfied, invoke the error handler and never return.

	cCall	CheckXmsRequirements	;XMS memory requirement tests

; now get the sizes of various segments etc.

; get the limit fields and save them

	call	GetSegmentLimits	;set segment limits -- sets StubSegSize
	cmp	StartRestart,0		;is it start ?
	jnz	@f			;yes

; now test to see if the applications conventional and extended mode memory 
; requirements can be satisfied or not. If memory requrements cannot be met, 
; the following routine will never return

	call	IsThereEnoughMemory	;check conventional/XMS mem requirements

@@:

	clc				;no error

cEnd
;----------------------------------------------------------------------------;
; IsThereEnoughMemory:							     ;
;									     ;
; This routine checks to see if enough memory can be released to meet the    ;
; apllications conventional.						     ;
;----------------------------------------------------------------------------;

IsThereEnoughMemory proc near

	xor	ax,ax			;initialize size of resident area

; now in the resident area of conventional memory the main code and data
; segments will allways be resident in real mode winoldap (this is not true for
; protected mode winoldap). So initialize the size of the real mode resident 
; area with the size of the main code and data segments.

	mov	ax,WoaCsSize		;size of the main code segment
	add	ax,WoaDsSize		;add in the size of the data segment

;----------------------------------------------------------------------------;
; code independent of real or protected mode.				     ;
;----------------------------------------------------------------------------;

; now check convetional memory requirements.

	mov	bx,AppMinMem		;get minimum req. in KB
	cmp	bx,0			;was minimum limit specified ?
	jz	ThereIsEnoughMemory	;memory requirements will be met

; get the size of the stub segment

	add	ax,StubSegSize		;size of the stub seg

; bx has the minimum memory required in Kbytes, we need to mutiply that by 64
; to get the number of paragraphs.

	shiftr	ax,4			;get number of paragraphs
	inc	ax			;round up
	shiftl	bx,6			;ax has min requirement in paragraphs

; if there is not enough memory to run the application, get out and complain

	neg	ax			;need to subtract from total memory
	add	ax,LowMemParaSize	;size of low heap area
	cmp	bx,ax			;is there enough memory
	jbe	ThereIsEnoughMemory	;yes there is

; we cannot run the appilaction

	mov	ErrorType,ER_LOW_MEMORY	;error type
	jmp	ErrorHandler		;get out

ThereIsEnoughMemory:

	ret

IsThereEnoughMemory  endp
;----------------------------------------------------------------------------;
; GetSegmentLimits:						             ;
;									     ;
; This routine gets the limits of the various winoldap segments. It also     ;
; obtains the sel values for the block allocated to the switcher by Dos and  ;
; also it's size and a sel for it's arena.				     ;
;----------------------------------------------------------------------------;

GetSegmentLimits  proc near

	push	es			;save
	mov	ax,CodeOFFSET CodeSegEnd;end label in _TEXT segment
	add	ax,15			;take into next para	
	and	ax,0fff0h		;paragraph allign
	mov	WoaCsSize,ax		;save it

	mov	ax,DataOFFSET DataSegEnd;end label in _DATA segment
	add	ax,15			;take into next para	
	and	ax,0fff0h		;paragraph allign
	mov	WoaDsSize,ax	

; if the XMS handler is not needed we will discard it.

	mov	bx,StubSegOFFSET InitStartLine	;discardable code line
	mov	ax,wptr XmsBankSize	;if there is an XMS requirement
	or	ax,wptr [XmsBankSize+2] ;  the XMS handler can't be
	jnz	@f
	mov	bx,StubSegOFFSET XmsStartLine	;discard XMS code
@@:
	add	bx,15			;take into next para	
	and	bx,0fff0h		;paragraph allign
	mov	StubSegSize,bx		;usable stub area

	pop	es			;restore es

	mov	ah,62h			;get PSP
	int	21h			;BX has the PSP segment
	mov	WoaPDBSeg,bx		;save it
	mov	LowMemSel,bx		;save it
	dec	bx			;point to the arena
	mov	LowMemArenaSel,bx	;save it
	push	es			;save
	mov	es,bx			;point to the arena
	mov	ax,es:[3]		;get the size of block in paragraphs
	mov	LowMemParaSize,ax	;save it
	mov	al,es:[0]		;get the block type
	mov	LowMemBlockType,al	;save it too
	pop	es			;restore

; save the sel for the block that will be resized.

	mov	ax,LowMemSel		;selector for the block
	mov	SegResizeBlock,ax	;save it.

; get the maximum of the 3 segments.

	mov	ax,_TEXT		;get code segment
	mov	bx,WoaCsSize		;and its size
	cmp	ax,DGROUP		;compare with DS seg
	ja	@f			;no need to swap
	mov	ax,DGROUP		;load ds
	mov	bx,WoaDsSize		;load ds's size
@@:
	cmp	ax,_WOARLMSEG		;comapare with stub
	ja	@f			;no need to swap
	mov	ax,_WOARLMSEG		;load stub seg
	mov	bx,StubSegSize		;and its size
@@:
	shiftr	bx,4			;convert to para
	add	ax,bx			;get to end of segment
	sub	ax,LowMemSel		;subtract the PSP seg
	mov	SizeReservedArea,ax	;size of reserved area
	add	ax,LowMemSel		;segment where stub seg will be loaded
	mov	SegAfterReservedArea,ax	;address of segment after reserved area
	mov	UsableLowHeapSel,ax	;seg for usable area


	ret

GetSegmentLimits endp
;----------------------------------------------------------------------------;
; CheckXmsRequirements:							     ;
;									     ;
; If no XMS memory is required by the application, a flag would be set to    ;
; indicate that.							     ;
;									     ;
; If XMS is required but no XMS driver is loaded we will exit and report the ;
; error.								     ;
;									     ;
; We will then find out details about the XMS block allocated for the high   ;
; heap and find out whether we can meet the oldapps requiremsts.	     ;
;----------------------------------------------------------------------------;

cProc	CheckXmsRequirements,<NEAR,PUBLIC,PASCAL>

cBegin


;----------------------------------------------------------------------------;
; real mode specific code. In real mode we need the address of the XMS contr-;
; -ol fuction, so get the address and save it.				     ;
;									     ;
; (note: this instance may not need any XMS memory, but this instance may    ;
;  later handle some old app which does need XMS and will then be needing    ;
;  the address of the control function).				     ;
;----------------------------------------------------------------------------;

	cmp	AppMinXmsK,0		;is there any requirement ?
	jnz	XmsMemoryDesired	;yes

; as no xms memory is required, set the XMS flag off.

	mov	wptr [XmsBankSize],0	;no XMS memory needed
	mov	wptr [XmsBankSize+2],0  ;reset hiword too
	jmp	short CheckXmsReqRet	;go back.

XmsMemoryDesired:

; test to see if XMS driver is loaded.

	mov	ErrorType,ER_NO_XMS_DRV ;anticipating no XMS driver
	cmp	XmsFlag,0ffh		;driver loaded ?
	njnz	NearErrorHandler	;no xms driver loaded

; XMS driver is loaded, check to see if we can support apps requirements.

	mov	cx,wptr [HighMemSize+2]
	mov	dx,wptr [HighMemSize]	;CX:DX has size of high heap block

; get the number of K bytes this amounts to.

	mov	dl,dh			;divide by 256
	mov	dh,cl			
	mov	cl,ch			
	xor	ch,ch			;we have divided by 256, now by 4
	shr	cx,1			;get lsb into carry
	rcr	dx,1			;get it into dx
	shr	cx,1			;get lsb into carry
	rcr	dx,1			;CX:DX has mem available in K
	or	cx,cx			;if cx > 0 we have enough
	jnz	GrantXmsMemory		;enough is available

	mov	ErrorType,ER_LOW_XMS_MEM;anticipate not enough memory
	cmp	AppMinXmsK,-1		;all of memory needed ?
	jz	AllOfXmsNeeded		;yes
	cmp	dx,AppMinXmsK		;compare with min requirement
	njb	NearErrorHandler	;not enough for minimum requirement

GrantXmsMemory:

; we have made sure that minimum requirement is met, but we must try to grant
; the maximum requirement.

	mov	ax,AppMaxXmsK		;this is what we want to give
	cmp	ax,-1			;do we need all ?
	jz	AllOfXmsNeeded		;yes
	cmp	dx,AppMaxXmsK		;compare with max requirement.
	jbe	AllOfXmsNeeded		;availabe is < desired, grant all
	jmp	short SetXmsRequired	;set up size to be granted

AllOfXmsNeeded:

;----------------------------------------------------------------------------;
; In real mode, DX has the size of the XMS block rounded down to a K.	     ;
;----------------------------------------------------------------------------;

	mov	ax,dx			;all of XMS to be granted

;----------------------------------------------------------------------------;

SetXmsRequired:

	mov	bx,1024			;need to do Kilo to byte conversion
	mul	bx			;DX:AX has apps xms bank size

SaveXmsSize:

	mov	wptr [XmsBankSize+2],dx	;save high word
	mov	wptr [XmsBankSize],ax	;save low word

CheckXmsReqRet:

cEnd
;----------------------------------------------------------------------------;
; AllocateXms:								     ;
;									     ;
; This routine gets the information about the XMS block to use. The XMS block;
; handle is will be saved in the global switch structure by the first inst.  ;
; of the switcher (it would be 0 otherwise) and all other instances would use;
; it to get the size.							     ;
;----------------------------------------------------------------------------;

cProc	AllocateXms,<NEAR,PUBLIC,PASCAL>,<es,di>

cBegin

; check to see if XMS driver is installed or not.

	mov	XmsFlag,0		;assume no xms.
	mov	ax,4300h		;installation check
	int	2fh
	cmp	al,80h			;failure ?
	njne	AllocateXmsRet		;yes, no driver installed.
	mov	XmsFlag,0ffh		;XMS exists

; get the XMS entry point address.

	push	es			;will get thrashed
	mov	ax,4310h		;code to get the address
	int	2fh			;address in es:bx
	mov	wptr [lpXmsControl+2],es;save segment of control function
	mov	wptr [lpXmsControl],bx	;save the offset
	pop	es			;restore

; get a pointer to the global switch structure and find out whether a privious
; instance had allocated the block or not.

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov    	di,ax			;es:di -> info structure
	mov	dx,es:[di].XMS_Handle	;get the stored handle
	or	dx,dx			;if zero then not allocated.
	jz	DoAllocateXMS		;must allocate it.

; the XMS block has already been allocated, save the handle and get the size.

	mov	HighMemXmsHandle,dx	;save the handle
	mov	ax,wptr es:[di][0].XMS_Size
	mov	word ptr [HighMemSize],ax;save low word of size
	mov	ax,wptr es:[di][2].XMS_Size
	mov	word ptr [HighMemSize+2],ax;save high word
	jmp	short AllocateXMSRet	;done.

DoAllocateXMS:

; get the size of the largest available block.

	mov	ah,08h			;query amt. of free memory
	call	lpXmsControl		;AX has largest free block size in K
	cmp	bl,80h			;error ?
	jz	AllocateXmsRet		;no XMS available
	cmp	bl,81h			;error ?
	jz	AllocateXmsRet		;no XMS available

; allocate the block and get it's handle.

	push	ax			;save the size of the largest block.
	mov	dx,ax			;requested size = size of largest block
	mov	ah,09h			;allocate XMS block
	call	lpXmsControl		;AX has largest free block size in K
	or	ax,ax			;failed ?
	pop	ax			;get back size
	jz	AllocateXmsRet		;allocation failed.

; save the handle and the size of the block.

	mov	HighMemXmsHandle,dx	;save the handle
	mov	bx,1024			;need size in KB
	xor	dx,dx			;clear out before mul
	mul	bx			;dx:ax has size in bytes
	mov	word ptr [HighMemSize],ax;save low word of size
	mov	word ptr [HighMemSize+2],dx;save high word

; now save the block information in the global structure.

	mov	wptr es:[di][0].XMS_Size,ax
	mov	wptr es:[di][2].XMS_Size,dx
	mov	dx,HighMemXmsHandle	;get the handle
	mov	es:[di].XMS_Handle,dx	;save it

; finally lock the block.

	mov	ah,0ch			;lock XMS block
	call	lpXmsControl		;AX has largest free block size in K

AllocateXmsRet:

cEnd
;----------------------------------------------------------------------------;
; GetSizeFromArena:							     ;
; 									     ;
; This routine will be assembled only in real mode and it looks into the     ;
; arena associated with a segment whose values in in ax and returns the size ;
; in bytes in AX.							     ;
;----------------------------------------------------------------------------;


GetSizeFromArena  proc  near

	dec	ax			;get to the arena
	mov	es,ax			;have es pointing to arena
	mov	ax,es:[3]		;get the size in paragraphs
	shiftl	ax,4			;get it in bytes
	ret

GetSizeFromArena endp

;----------------------------------------------------------------------------;
; GetSwapFilePathPrefix:						     ;
;									     ;
; This routine gets the path prefix for the swap files to be used. 	     ;
;								             ;
;	. If the [NowWindowsAppf] section in SYSTEM.INI has an entry specifi-;
;         -ed for the key, 'swapdisk=', then that will be the path for temp  ;
;         files,else						             ;
;	. the 'GetTempFileName' function is invoked to get the complete      ;
;	  path name of the temp drive and part of the name upto the unique   ;
;         number is extracted from it.					     ;
;----------------------------------------------------------------------------;

GetSwapFilePathPrefix  proc  near

	cld				;do not take chances with this

; copy the paths. First the first swap path

	mov	si,DataOFFSET WoaSwapFilePrefix
	mov	di,DataOFFSET WoaSwap1Path
	call	AppendDsSiToDsDi

; now the second swap path.

	mov	si,DataOFFSET WoaSwapFilePrefix
	mov	di,DataOFFSET WoaSwap2Path
	call	AppendDsSiToDsDi

; prepare the grabber swap file name from the second swap path

	mov	di,DataOFFSET DosAppSwapFileName;prepare name here
	call	FarCopyBasicSwap2FileName;copy the name until the unique num
	mov	ax,0ffeeh		;irrelevant, grabber will redo this
	call	FarAppendUniqueNumber	;just have a win style file name
	mov	si,DataOFFSET DosAppSwapFileName
	mov	di,StubSegOFFSET WoaGrabberSwapPath
	push	es			;save
	smov	es,ds			;es:si ppints to file name
	call	CopyEsSiToCsDi		;copy over to the stubsegment
	pop	es

	ret

GetSwapFilePathPrefix endp
;----------------------------------------------------------------------------;
; AppendDsSiToDsDi:							     ;
;									     ;
; Appends the strung at DS:SI to the string at ES:DI and makes sure that the ;
; composite string end with a '\'					     ;
;----------------------------------------------------------------------------;

AppendDsSiToDsDi proc near

; first get to the end of the path.

	push	es
	smov	es,ds			;es=ds

@@:
	mov	al,es:[di]		;get the next byte
	inc	di			;next byte
	or	al,al			;NULL ?
	jnz	@b			;no.
	sub	di,2			;go back to last character
	mov     al,es:[di]		;get the last character
	cmp	al,'\'			;path separator ?
	jz	@f			;yes
	mov	al,'\'			;load it, zero in high byte
@@:
	stosb				;append a path separator

; now copy the path prefix.

@@:

	lodsb				;get the next byte
	stosb				;save it
	or	al,al			;NULL copied ?
	jnz	@b			;no.
	pop	es			;restore
	ret

AppendDsSiToDsDi endp
;----------------------------------------------------------------------------;
; GetSwapFileInformation:						     ;
;									     ;
; Gets information for building up swap file names.			     ;
;----------------------------------------------------------------------------;

cProc	GetSwapFileInformation,<NEAR,PUBLIC,PASCAL>,<si,di>

cBegin


; get the path prefix to be used for all swap files.

	call	GetSwapFilePathPrefix	;get the prefix

; obtain the drive letter for the swap drive from the basic swap name. 

	mov	al,WoaSwap1Path		;get the first letter
	and	al,0dfh			;convert to upper case
	mov	DiskSwap1Drive,al	;save

	mov	al,WoaSwap2Path		;get the first letter
	and	al,0dfh			;convert to upper case
	mov	DiskSwap2Drive,al	;save

cEnd
;----------------------------------------------------------------------------;
; find_next_arg:							     ;
;                Takes ES:SI over DOS delimiters and if poitions it to point ;
; to the next valid dos argument, or resturns NZ if end of line is reached   ;
;----------------------------------------------------------------------------;

find_next_arg	proc near

	push	ds			;save
	smov	ds,es			;load it in ds:si

find_next_arg_1:

	lodsb				;get the next byte
	cmp	al,0dh			;end of command line?
	je	no_more_args		;there is no second argument
	call	delim			;is this a DOS delimiter?
	jz	find_next_arg_1		;yes, skip over it
	dec	si			;point to this char
	xor	al,al		        ; set zero flag
	jmp	short find_next_arg_ret
no_more_args:
	dec	si
	or	al,al			;If end then AL is non zero
find_next_arg_ret:
	pop	ds			;restore
	ret

find_next_arg	endp

delim	proc	near
	cmp	al,' '			;space ?
	jz	delim_ret
	cmp	al,'='
	jz	delim_Ret
	cmp	al,','			;comma ?
	jz	delim_ret
	cmp	al,';'			;semicolon ?
	jz	delim_ret
	cmp	al,09H			;tab
	jz	delim_ret
	cmp	al,0AH			; Line Feed
delim_ret:
	ret

Delim	endp
;----------------------------------------------------------------------------;
; GetCompleteFileName:							     ;
;									     ;
; This routine takes a long pointer to a complete or partial file name and   ;
; returns the complete file name in the same buffer. If the file cannot be   ;
; found, AX will be set to -1. Also it assumes that the file name with the   ;
; NULL terminator is not more than 64 characters long.			     ;
;----------------------------------------------------------------------------;

cProc	GetCompleteFileName,<NEAR,PUBLIC,PASCAL>

	parmD	lpName			;input file name

cBegin

	cld				;do not take chances with this
cEnd
;----------------------------------------------------------------------------;
; DeleteTempFiles:							     ;
;									     ;
; This routine goes through a sequence of find first/find next calls and     ;
; deletes all woa and grabber left over temp files if any. The current DTA   ;
; address is saved and this routine uses a DTA on the stack for these calls  ;
;									     ;
;  The grabber files will not be deleted if we have an instance of Windows   ;
;  3.0 winoldap active or if this is not the first instance of the switcher. ;
;  								             ;
; The grabber swap files can only be in the second swap path (the grabbers   ;
; do not support two swap paths and Winoldap lets the grabber know only of   ;
; the second swap path.). There will thus be 3 groups to delete (woa swap    ;
; files in two swap paths and grabber swap file groups in the second path).  ;
;----------------------------------------------------------------------------;

cProc	DeleteTempFiles,<NEAR,PUBLIC,PASCAL>,<es,si,di>

	localD	CurrentDta		;saves current DTA address here
	localV	NewDta,128		;used for find/first and find next.

cBegin
	
; get and save the current DTA address

	mov	ah,2fh			;get DTA address call
	int	21h			;es:bx has the current address
	mov	seg_CurrentDta,es	;save segment
	mov	off_CurrentDta,bx	;save offset

; set the new DTA address to stack.

	lea	dx,NewDta		;will have it here on stack.
	push	ds			;save
	smov	ds,ss			;ds:dx is the new DTA area
	mov	ah,1ah			;set DTA address
	int	21h			;new DTA on stack
	pop	ds			;restore

; now delete the WOA temp files.

	mov	cx,3			;3  chains to delete

DeleteAChain:
	
; get the template of the next chain based on the value of cx:
; CX = 3 implies woa files in second path, CX = 2 implies grabber files in
; second path and CX = 1 implies woa files in first path.

; We should not try to delete grabber files if the SwitcherID is not 1 or if
; Windows 3.0 winoldap is active.

	cmp	cx,2			;trying to delete grabber files ?
	jnz	DTF_OkToDeleteChain	;no.
	cmp	SwitcherID,1		;first instance of switcher ?
	jnz	DTF_SkipThisChain	;no, do not delete grabber files

; check to see if another winoldap is active as a real mode stub.

	mov	ax,IS_WINOLDAP_ACTIVE	;woa traps this in real mode
	int	2fh			;see if woa is in chain
	or	ax,ax			;is woa active as a stub ?
	jz      DTF_SkipThisChain	;yes, donot delete any files

DTF_OkToDeleteChain:

	call	GetTempFileTemplate	;ds:dx has the file name template
	push	cx			;save
	mov	cx,3			;include hidden and read-only files
	mov	ah,4eh			;find first call
	int	21h			;get the first in chain
	jc	DoNextChain		;no such file

DeleteTheFile:

; recreate the complete path-file name from the file name that we just found

	pop	cx			;restore loop index
	push	cx			;save it back
	call	CopyBasicTempPrefix	;get the basic temp prefix
	sub	di,4			;back over '~DOS'
	lea	si,NewDta+1eh		;file name here
	push	ds			;save
	smov	ds,ss			;ds:dx has the file to delete

; now copy the file name over to complete the path file name

@@:

	lodsb				;get the next character of file name
	stosb				;copy it
	or	al,al			;are we done ?
	jnz	@b			;no.

; now delete the file after setting normal attributes.

	pop	ds			;restore ds
	mov	ax,4301h		;set file attributes
	xor	cx,cx			;normal attributes
	int	21h			;normal attributes set
	mov	ah,41h			;delete file code
	int	21h			;one file deleteted
	mov	ah,4fh			;find next file in chain
	int	21h			;did we get another
	jc	DoNextChain		;no.
	jmp	short DeleteTheFile	;delete this and look for more

DoNextChain:

	pop	cx			;get back count

DTF_SkipThisChain:

	loop	DeleteAChain		;delete this chain too.

; now set back the original DTA address and go back.

	push	ds			;save
	mov	dx,off_CurrentDta	;old dta offset
	mov	ds,seg_CurrentDta	;old dta segment
	mov	ah,1ah			;set DTA code
	int	21h			;DTA address restored
	pop	ds			;restore data segment

DeleteTempFilesRet:

cEnd

	;------------------------------------------;
	; get template for temp files based on the ;
	; value of CX.				   ;
	; CX = 3 => woa temp files in swap path2   ;
	; CX = 2 => grb temp files in swap path2   ;
	; CX = 1 => woa temp files in swap path1   ;
	;------------------------------------------;

GetTempFileTemplate proc near

	call	CopyBasicTempPrefix	;get the basic path prefix
	cmp	cx,2			;grabber template ?
	jz	GetGrbTemplate		;get grabbers file template

; now append a nibble for the switcher ID.

	mov	al,SwitcherID		;get the ID
	and	al,0fh			;only a nibble of ID
	add	al,30h			;convert numbers to ascii
	cmp	al,'9'			;did we go above 9 ?
	jbe	GTFT_ALHasAscii		;no, we are ok.
	add	al,7h			;convert to (A-F)

GTFT_ALHasAscii:

	stosb				;save it
	mov	ax,'.*'			;follow it up with '*.*'
	stosw				;save it
	mov	ax,'*'			;ah will have terminating NULL
	stosw				;template created
	mov	dx,DataOFFSET FileTemplate
	ret

GetGrbTemplate:

	sub	di,3			;step back over 'DOS'
	mov	ax,'RG'			;nedd to have 'GRB' instead
	stosw				;'GR' saved
	mov	al,'B'			;last part of 'GRB'
	stosb				;initial part done.
	mov	ax,'.*'			;follow it up with '*.*'
	stosw				;save it
	mov	ax,'*'			;ah will have terminating NULL
	stosw				;template created
	mov	dx,DataOFFSET FileTemplate
	ret

GetTempFileTemplate  endp

	;--------------------------------------------;
	; gets the basic swap path prefix based on   ;
	; the value of cx. CX = 2 or 3 implies use   ;
	; swap path 2, CX = 1 implies use path 1     ;
	;--------------------------------------------;

CopyBasicTempPrefix proc near

	mov	di,DataOFFSET FileTemplate	
	test	cx,2			;2 or 3 
	jnz	@f			;yes.
	call	FarCopyBasicSwap1FileName;get prefix for path 1
	ret
@@:
	call	FarCopyBasicSwap2FileName;get prefix for path 2
	ret

CopyBasicTempPrefix endp
;----------------------------------------------------------------------------;
; GetSwitcherInfo:							     ;
;							 		     ;
; Gets info from the global switch structure.				     ;
;----------------------------------------------------------------------------;

cProc	GetSwitcherInfo,<FAR,PUBLIC,PASCAL>,<es>

	localD	OtherSwitcherAddr	;call in address of the 'other' switcher

cBegin

; get a pointer to the global block.

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure

; scan through the list and if all ProgramID's are zero, then reset the
; Id_Serial field.

	lea	si,[di].Program_List	;es:si points to the first program entry
	mov	cx,MAX_NUM_PROGRAMS	;get the max number of entries
	xor	ax,ax			;will build a count here

LoopAllEntries:

	test	es:[si].Program_Flags,F_FREE
	jnz	ContinueLoop		;this is a free entry
	cmp	es:[si].Program_Id,0	;has this been run before ?
	jnz	OutOfLoop		;yes, break out of loop

ContinueLoop:

	add	si, SIZE Switch_Entry	;es:si -> next program
	inc	ax			;one more fresh entry obtained
	loop	LoopAllEntries		;continue lloking

OutOfLoop:

	cmp	ax,MAX_NUM_PROGRAMS	;all entries fresh ?
	jb	@f			;no.
	mov	es:[di].Id_Serial,0	;reset this.

@@:

; copy the SwitcherId from the global structure.

	mov	al,es:[di].Switcher_Id	;ID allocated to this swicher
	mov	SwitcherID,al		;save it.

; get a pointer to the first program in the list.

	lea	si,[di].Program_List	;start of array
	xor	ah,ah			;clear out high byte
	mov	al,es:[di].First_In_List;get index of first entry
	mov	bl,SIZE Switch_Entry	;size of each entry
	mul	bl			;ax has start offset
	add	si,ax			;es:si -> first program in list.

; copy program related variables.

	mov	ax,es:[si].Conv_Req	;get conventional memory requirements
	mov	AppMinMem,ax		;save minimum memory required
	mov	ax,es:[si].XMS_Req	;amount of xms required
	mov	AppMinXmsK,ax		;save as min xms requirement
	mov	ax,es:[si].XMS_Want	;xms desired
	mov	AppMaxXmsK,ax		;save it

; if AppMaxXmsK is < AppMinXmsK, set it to AppMinXmsK.

	cmp	ax,AppMinXmsK		;ax could be -1 too.
	jae	@f			;all is fine
	mov	ax,AppMinXmsK		;minimum
	mov	AppMaxXmsK,ax		;save it
@@:

; copy global variables and flags from the switch_info structure.
	
	xor	ah,ah			;reset
	mov	al,es:[di].Num_Lines	;start up no of screen lines

; if the screen lines is zero, we must get it from the BIOS area

 	or	al,al			;uninitialized ?
	jnz	@f			;no.
	push	es			;save
	mov	bx,40h			;bios data area
	mov	es,bx			;es points to BIOS data segment
	mov	bx,84h			;location where screen lines saved
	mov	al,es:[bx]		;get the no of screen lines
	inc	ax			;actually it is one more
	pop	es			;restore
@@:
	mov	cs:[WoaStartScreenLines],ax;save it
	mov	StartScreenLines,ax	;save a local copy too.

	mov	al,es:[di].Screen_Back	;back ground screen color
	mov	[SwitcherColors],al	;save it
	mov	al,es:[di].Title_Back	;title back ground color
	mov	[SwitcherColors+1],al	;save it
	mov	al,es:[di].Title_Fore	;title text color
	mov	[SwitcherColors+2],al	;save it
	mov	ax,es:[di].CPU_Type	;get the CPU type
	mov	cs:[WoaCpuType],ax	;save it
	mov	ax,es:[di].SFT_Size	;get the file entry size
	mov	cs:[WoaFileEntrySize],ax;save it

; set the global flags

	mov	al,es:[di].Global_Flags	;get the global flags
	mov	cs:[Woa6fValue],0  	;assume int 6f not to be done
	test	al,GF_INT_6F_TOBE_DONE	;int 6f to be done ?
	jz	@f			;no.
	mov	cs:[Woa6fValue],0ffh		;int 6f to be done.
@@:
	mov	cs:[WoaIrq9Global],0	;assume IRQ 9 to be handled globally
	test	al,GF_IRQ9_GLOBAL	;is IRQ 9 global ?
	jnz	@f			;yes
	mov	cs:[WoaIrq9Global],0ffh	;don't handle IRQ 9
@@:
	mov	cs:[WoaNetAsyncSwitching],0	;assume cannot switch out on async net
	test	al,GF_NET_ASYNC_SWITCH_OK;is it ok to switch out ?
	jz	@f			;no
	mov	cs:[WoaNetAsyncSwitching],0ffh	;ok to switch out
@@:

; copy various behaviour bits and hot key states.

	mov	cs:[WoaBehavior],0 	;initialize
	mov	cs:[WoaHotKeys],0	;initialize
	mov	ax,es:[si].Program_Flags
	and	al,F_NO_SWITCH+F_GRAPHICS+F_NO_PAUSE
	mov	cs:[WoaBehavior],al 	;save it
	and	ax,F_NO_ALT_TAB+F_NO_ALT_ESC+F_NO_CTRL_ESC
	mov	cs:[WoaHotkeys],ah	;save

; also set bytes in the local hot key list for keys that are disabled.

	test	ax,F_NO_ALT_TAB		;ALT+TAB disabled ?
	jz	@f			;no.
	mov	cs:[WoaAltTabDisabled],0ffh
	mov	cs:[WoaShftAltTabDisabled],0ffh
@@:
	test	ax,F_NO_ALT_ESC		;ALT+ESC disabled ?
	jz	@f			;no.
	mov	cs:[WoaAltEscDisabled],0ffh
	mov	cs:[WoaShftAltEscDisabled],0ffh
@@:
	test	ax,F_NO_CTRL_ESC    	;ALT+ESC disabled ?
	jz	@f			;no.
	mov	cs:[WoaCtrlEscDisabled],0ffh
@@:

; copy the swither ID.

	mov	al,SwitcherID		;get the ID
	mov	cs:[WoaSwitcherID],al	;pass it on

; now copy the program name.

	push	di			;save
	push	si			;save program entry pointer
	mov	di,StubSegOFFSET WoaPath;save program name here.
	lea	si,[si].Program_Name	;es:si -> program name
	call	CopyEsSiToCsDi		;copy the name .
	pop	si			;get back start of entry
	pop	di			;restore.

; now copy the parameters

	push	di			;save
	push	si			;save program entry pointer
	lea	si,[di].Parameters	;es:si -> parametsrs
	mov	di,StubSegOFFSET WoaParams;command parameters
	call	CopyEsSiToCsDi		;copy the name .
	pop	si			;get back start of entry
	pop	di			;restore.

; get the program ID and the path ID.

	mov	al,es:[si].Path_Id	;get the path ID
	mov	CurrentPathId,al	;save it
	mov	ax,es:[si].Program_Id	;id for the app
	mov	hApp,ax			;save it.
	mov	StartRestartId,al	;start if 0 else restart
	or	ax,ax			;is it a fresh start ?
	jnz	@f			;no.		     

; build the DosAppNumber.

	mov	ax,es:[di].Id_Serial	;get the serial id
	mov	DosAppNumber,ax		;save it.
	inc	ax			;increment it
	mov	es:[di].Id_Serial,ax	;update it.

; build the hApp id. This is basically the slot in the global structure where
; the program details have been built. Or in otherwords, it is First_In_List.
; we also need to combine the SwitcherID with it.

	mov	ah,SwitcherID		;get the ID
	shiftl	ah,4			;only four 4 bits are significant
	mov	al,es:[di].First_In_List;rest of the task id
	mov	hApp,ax			;app's id
	mov	es:[si].Program_Id,ax	;save it
@@:

; get the grabber file name.

	mov	si,di			;es:si -> SwitchInfo structure
	push	si			;save
	lea	si,es:[si].Grabber_Name	;es:si -> points to the grabber name
	mov	di,StubSegOFFSET WoaGrabberName;will copy grabber name here
	call	CopyEsSiToCsDi		;copy the name .
	pop	si			;es:si -> SwitchInfo

; copy the two swap file paths.

	push	si			;save
	lea	si,es:[si].Swap_Path1	;es:si -> points to the swap path
	mov	di,DataOFFSET WoaSwap1Path;will copy path here
	call	CopyEsSiToDsDi		;copy the name .
	pop	si			;restore pointer to entry

	push	si			;save
	lea	si,es:[si].Swap_Path2	;es:si -> points to the swap path
	mov	di,DataOFFSET WoaSwap2Path;will copy path here
	call	CopyEsSiToDsDi		;copy the name .
	pop	si			;restore pointer to entry

; load the minimum space information for the two swap paths.

	mov	ax,es:[si].Min_Path1	;min space for path 1
	mov	Swap1MinK,ax		;save it
	mov	ax,es:[si].Min_Path2	;min space for path 2
	mov	Swap2MinK,ax		;save it

; get information about swap file.					     

	call	GetSwapFileInformation	      

; If DosAppNumber is 0 and this is not a restart, we must delete all 
; temporary files

	cmp	DosAppNumber,0		;first app ?
	jnz	@f			;no.
	cmp	StartRestartID,0	;if tart
	jnz	@f			;delete files.
	cCall	DeleteTempFiles		;delete all temporary files.
@@:

	clc				;successful completion of routine
	jmp	short GetSwitcherInfoRet

GetSwitcherInfoErr:

	stc				;error, cannot proceed

GetSwitcherInfoRet:

cEnd
;----------------------------------------------------------------------------;
; CopyEsSiToDsDi:								     ;
;									     ;
; Copies a NULL terminated string from es:si to ds:si.			     ;
;----------------------------------------------------------------------------;

CopyEsSiToDsDi proc near

	mov	al,es:[si]		;load a byte
	mov	ds:[di],al		;save it
	inc	si			;bump src ptr
	inc	di			;bump target ptr
	or	al,al			;NULL copied ?
	jnz	CopyEsSiToDsDi		;continue
	ret				;done

CopyEsSiToDsDi endp
;----------------------------------------------------------------------------;
; CopyEsSiToCsDi:								     ;
;									     ;
; Copies a NULL terminated string from es:si to cs:si.			     ;
;----------------------------------------------------------------------------;

CopyEsSiToCsDi proc near

	mov	al,es:[si]		;load a byte
	mov	cs:[di],al		;save it
	inc	si			;bump src ptr
	inc	di			;bump target ptr
	or	al,al			;NULL copied ?
	jnz	CopyEsSiToCsDi		;continue
	ret				;done

CopyEsSiToCsDi endp
;----------------------------------------------------------------------------;
; NearErrorHanlder:							     ;
;									     ;
; From here we jump into the main code segment error handler.		     ;
;----------------------------------------------------------------------------;

NearErrorHandler:

	jmp	ErrorHandler		;hApp jump into _TEXT segment

;----------------------------------------------------------------------------;
sEnd StubSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woakeys.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; defines equates for key codes, shift states and WOA used flags             ;
;----------------------------------------------------------------------------;

; define codes for keys which WOA is interested in.

KEY_DUP		equ	0e0h		;duplicate key predecessorcode
KEY_ALT		equ	038h		;ALT key code
KEY_TAB		equ	0fh		;TAB key code
KEY_ESC		equ	01h		;ESC key code
KEY_PRTSC	equ	54h		;PRINT SCRN key code
KEY_OTHERPRTSC  equ	37h		;alternate PRINT SCRN key code
KEY_BREAK	equ	080h		;'realese a key' code

; define the location of the KeyBoard state flag in BIOS data area

KEYSTATE	equ	417h		;0:417h has the state

; define the key states

ST_RSHIFT	equ	00000001b	;right SHIFT pressed
ST_LSHIFT	equ	00000010b	;left SHIFT pressed
ST_SHIFT	equ	00000011b	;mask for shift state
ST_CTRL		equ	00000100b	;CTRL key pressed
ST_ALT		equ	00001000b	;ALT key pressed

; define the hot key bit codes that WOA uses

WOA_ALT_TAB		equ	00000001b	;ALT+TAB hit
WOA_SHIFT_ALT_TAB	equ	00000010b	;SHIFT+ALT+TAB hit
WOA_ALT_ESC		equ	00000100b	;ALT+ESC hit
WOA_SHIFT_ALT_ESC	equ	00001000b	;SHIFT+ALT+ESC hit
WOA_CTRL_ESC		equ	00010000b	;CTRL+ESC
WOA_ALT_PRTSC		equ	00100000b	;ALT+PRINTSCRN
WOA_SPECIAL_SWITCH	equ	01000000b	;let win decide on next task
WOA_ALT_BREAK		equ	10000000b	;ALT key released
WOA_SWITCH		equ	00111111b	;switch masker
WOA_SWITCH_PREV         equ     00001010b       ;mask for switch to previous
WOA_SWITCH_NEXT		equ	00000101b	;mask for switch to nextcopy
WOA_SWITCH_ESC          equ	00001100b       ;switch on escape
WOA_SWITCH_TAB          equ     00000011b	;switch on tab

; define the EDIT key codes

ED_STARTEDIT	equ	00		;start of 2 char edit sequence
ED_F6		equ	64		;F6
ED_RIGHT_ARROW	equ	77		;-->
ED_F1		equ	59		;F1
ED_DEL		equ	83		;DEL
ED_F2		equ	60		;F2
ED_F4		equ	62		;F4
ED_F3		equ	61		;F3
ED_F5		equ	63		;F5
ED_LEFT_ARROW	equ	75		;<--
ED_INS		equ	82		;INS
ED_F7		equ	65		;F7
ED_CANCELEDIT	equ	27		;ESC


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woahp.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


; SaveState

SAVE_STATE	struc
VectorTable	db	(V_WINDOWS+6) dup (?)
LTouch		db	LDESCRIBE_SIZE dup (?)
LPointer	db	LDESCRIBE_SIZE dup (?)
LTablet		db	LDESCRIBE_SIZE dup (?)
HPSoftkeys	dw	2 dup (?)
HPCCP		dw	2 dup (?)	   
Devices		db	14 dup (?)
DeviceMapping	db	14 dup (?)
Translators	db	6 dup (?)
Click		db	?
Speed		db	?
SAVE_STATE	ends

FALSE 		equ	0
TRUE		equ	-1

NUM_HP_VECTORS	equ	85

; Size in bytes of undefined areas: HPmouse and HPTrack

HPMOUSE_SIZE	equ	0A0H
TRACK_SIZE	equ	280H

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.


EnterCrit   MACRO
        pushf
        cli
ENDM

LeaveCrit   MACRO
        POPFF
ENDM

POPFF   MACRO
        local   a
        jmp     $+3
a       label   near
        iret
        push    cs
        call    a
ENDM				       


HPENTRY 	equ	6FH		; HPSYSTEM interrupt vector
V_WINDOWS	equ	168H		; Windows private vector in the
;					; ..HPSYSTEM vector table
F_SYSTEM	equ	02		; SYSTEM function
SF_START	equ	02		; Start Application subfunction
SF_REPORT_STATE equ	04		; Status inquiry subfunction
;
ROM_SEGMENT	equ	0F000H		; ROM BIOS segment on Vectra
ROM_AREA	equ	0E000H		; ROM BIOS area (0E000h-0FFFFh)


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woakkc.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

ifdef JAPAN	; ### if JAPAN ###

;----------------------------------------------------------------------------;
; This module contains routines realated to saving and restoring of the KKC  ;
; (Kana-Kanji Converter) context.    					     ;
;									     ;
; History:								     ;
;									     ;
;        Mon Feb-18-1991.  	-by-  Norihiko Maruko [norim]		     ;
;        Created for DOS Shell. (Added the History legend) 		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	njmp.mac
	include macros.mac
	.list

	.8086

	public	KkcBufferSeg
	public	KkcBufferSize
	public	KkcDataSize

sBegin	StubSeg

;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

KkcBufferSize		dw	0	; size of a buffer to save/restore
KkcBufferSeg		dw	0	; segment of a buffer to save/restore

	assumes	cs,StubSeg

;----------------------------------------------------------------------------;
; KkcBusyCheck:							             ;
;								             ;
; Busy check to save/restore KKC state                                       ;
;									     ;
; OUT:									     ;
;	CF - 0 Not Busy							     ;
;	     1 Busy							     ;
;----------------------------------------------------------------------------;

cProc	KkcBusyCheck,<FAR,PUBLIC,PASCAL>,<ax,bx,dx,es>

cBegin

	mov	ax,_DATA		;
	mov	es,ax			;
	mov	bx,es:KkcHandleNo	;
	mov	ax,BusyCheck		;
	xor	dx,dx			;
	int	2fh			; busy check
	or	ax,ax			; not support function 4eh
	jnz	@f			; yes
	or	dx,dx			; KKC busy ?
	jnz	CheckError		; yes
@@:
	clc				; not busy
	jmp	short CheckEnd		;
CheckError:
	stc				; busy
CheckEnd:

cEnd
;---------------------------------------------------------------------------
sEnd

sBegin	Data

;----------------------------------------------------------------------------;
; define the KKC state related variables.				     ;
;----------------------------------------------------------------------------;

KkcHandleNo		dw	?	; KKC handle No.
KkcDataSize		dd	0	; data size of KKC

sEnd	Data

sBegin	Code

	assumes	cs,Code
	assumes	ds,Data

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;


		externNP	ReadFile		;(WOAFILE.ASM)
		externNP	WriteFile		;(WOAFILE.ASM)
		externNP	LseekFile		;(WOAFILE.ASM)

;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
; define constants related to various KKC.				     ;
;----------------------------------------------------------------------------;

; Int 2fh function
GetVersionTable		equ	4d03h	; get address of a version table
DisableEnable		equ	4e00h	; disable/enable KKC
BusyCheck		equ	4e01h	; check busy for KKC
GetSize			equ	4e02h	; get size of KKC state
SaveKKC			equ	4e03h	; save KKC state
RestoreKKC		equ	4e04h	; restore KKC state

MaxKkcCount		equ	1	; max KKC count
DefaultHandleNo		equ	1	; default handle no.
KkcBufSize		equ	2048	; buffer's size to save/restore
FileAttribute		equ	0	; file attribute to create
AccessMode		equ	2	; file open mode

;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; EnableKkc:								     ;
;									     ;
; This routine enables the KKC.		  				     ;
;									     ;
;----------------------------------------------------------------------------;

cProc	EnableKkc,<NEAR,PUBLIC,PASCAL>,<ax,bx,dx>

cBegin

	mov	ax,DisableEnable	;
	mov	bx,KkcHandleNo		;
	mov	dl,1			; set enable request
	int	2fh			; set KKC enable
	or	ax,ax			; not support function 4dh ?
	jnz	EnableError		; yes
	clc				;
	jmp	short @f		;
EnableError:
	stc				;
@@:

cEnd
;----------------------------------------------------------------------------;
; DisableKkc:								     ;
;									     ;
; This routine disables the KKC. 					     ;
;----------------------------------------------------------------------------;

cProc	DisableKkc,<NEAR,PUBLIC,PASCAL>,<ax,bx,dx>

cBegin

	mov	ax,DisableEnable	;
	mov	bx,KkcHandleNo		;
	mov	dl,0			; set disable request
	int	2fh			; set KKC disable
	or	ax,ax			; not support function 4dh ?
	jnz	DisableError		; yes
	clc				;
	jmp	short @f		;
DisableError:
	stc				;
@@:

cEnd
;----------------------------------------------------------------------------;
; SaveKkcState:								     ;
; Save the state of the KKC			       			     ;
;----------------------------------------------------------------------------;

cProc	SaveKkcState, <NEAR,PUBLIC,PASCAL>, <ax,bx,cx,dx,di,ds,es>

	parmW	FileHandle
	localD	FileOffset
	localW	DataEmpty
cBegin	     

	xor	ax,ax			;
	mov	bx,2			;
	cCall	LseekFile,<FileHandle,ax,ax,bx> ; seek end of file
	jc	SaveErrorEnd		; seek error
	mov	seg_FileOffset,dx	; save file offset
	mov	off_FileOffset,ax	;

	lea	ax,KkcDataSize		; write total size of KKC data
	mov	cx,4			; need to write 4 bytes
	xor	dx,dx			;
	cCall	WriteFile,<FileHandle,ds,ax,dx,cx>
	jc	SaveErrorEnd		; write error

	mov	ax,_WOARLMSEG		; get StubSeg
	mov	es,ax			;
	mov	ax,es:KkcBufferSeg	; get a segment address to save
	mov	es,ax			;
SaveLoop:
	mov	ax,SaveKkc		; get KKC save function
	mov	bx,KkcHandleNo		; get KKC handle No.
	mov	cx,KkcBufSize		; get size of the saving buffer
	xor	di,di			;
	push	es			; save
	int	2fh			; get KKC state
	pop	es			; restore
	cmp	ax,SaveKkc		; not support this function ?
	jz	SaveErrorEnd		; yes
	mov	DataEmpty,ax		;

	xor	di,di			;
	xor	ax,ax			;
	push	es			; save
	cCall	WriteFile,<FileHandle,es,di,ax,cx>
	pop	es			; restore
	jc	SaveErrorEnd		; write wrror

	cmp	DataEmpty,0		; data empty ?
	jnz	SaveLoop		; no

WriteOffset:
	xor	ax,ax			;
	mov	bx,4			;
	cCall	LseekFile,<FileHandle,ax,bx,ax>
	jc	SaveErrorEnd		; seek error
	lea	ax,FileOffset		; ss:ax points to data to write
	mov	cx,4			; need to write 4 bytes
	xor	dx,dx			;
	cCall	WriteFile,<FileHandle,ss,ax,dx,cx>
	jnc	SaveEnd			; no error

SaveErrorEnd:
	stc				; set error flag

SaveEnd:

cEnd
;----------------------------------------------------------------------------;
; RestoreKkcState:							     ;
;									     ;
; Restores the state of the KKC.					     ;
;----------------------------------------------------------------------------;

cProc	RestoreKkcState, <NEAR,PUBLIC,PASCAL>, <ax,bx,cx,dx,di,ds,es>

	parmW	FileHandle
	localD	FileOffset
	localD	EndPointer
	localD	ReadSize
	localW	RestoreCount
cBegin

	xor	ax,ax			;
	mov	bx,4			;
	cCall	LseekFile,<FileHandle,ax,bx,ax>
	njc	RestoreErrorEnd		; seek error
	lea	ax,FileOffset		; ss:ax points to data to read
	mov	cx,4			; need to read 4 bytes
	xor	dx,dx			;
	cCall	ReadFile,<FileHandle,ss,ax,dx,cx>
	jc	RestoreErrorEnd		; read error

	xor	ax,ax			;
	cCall	LseekFile,<FileHandle,FileOffset,ax>
	jc	RestoreErrorEnd		; seek error

	lea	ax,ReadSize		; read total size of KKC's data
	mov	cx,4			; need to read 4 bytes
	xor	dx,dx			;
	cCall	ReadFile,<FileHandle,ss,ax,dx,cx>
	jc	RestoreErrorEnd		; read error

	mov	ax,_WOARLMSEG		; get StubSeg
	mov	es,ax			;
	mov	ax,es:KkcBufferSeg	; get buffer address to restore
	mov	es,ax			;

RestoreLoop:
	mov	dx,KkcBufSize		;
	cmp	seg_ReadSize,0		; more than 64KB ?
	jnz	@f			; yes
	cmp	off_ReadSize,dx		; reading file size > buffer size ?
	jae	@f			; yes
	mov	dx,off_ReadSize		; get a size to read
@@:
	mov	RestoreCount,dx		; save a counter
	xor	di,di			;
	xor	cx,cx			; get read counter
	push	es			; save
	cCall	ReadFile,<FileHandle,es,di,cx,dx>
	pop	es			; restore
	jc	RestoreErrorEnd		; read error

	mov	ax,cx			; get counter
	mov	ax,RestoreKkc		; get KKC function to restore
	mov	bx,KkcHandleNo		; get KKC handle No.
	xor	di,di			;
	push	es			; save
	int	2fh			; restore KKC state
	pop	es			; restore
	or	ax,ax			; not support this function ?
	jnz	RestoreErrorEnd		; yes

	mov	ax,RestoreCount		;
	sub	off_ReadSize,ax		; renew count to read
	sbb	seg_ReadSize,0		;
	mov	ax,off_ReadSize		;
	or	ax,seg_ReadSize		; finish to restore ?
	jnz	RestoreLoop		; no
	clc				;
	jmp	short RestoreEnd	;

RestoreErrorEnd:
	stc				; set error flag

RestoreEnd:

cEnd
;----------------------------------------------------------------------------;
; GetKkcStateSize:							     ;
;								             ;
; Gets the size of the buffer needed to save the KKC state if there is a     ;
; KKC installed.						             ;
;									     ;
;----------------------------------------------------------------------------;

cProc	GetKkcStateSize,<NEAR,PUBLIC,PASCAL>,<ax,bx,cx,es>


cBegin

	xor	ax,ax			;
	mov	bx,_WOARLMSEG		; get StubSeg address
	mov	es,bx			;
	mov	es:KkcBufferSize,ax	; initialize
	mov	wptr KkcDataSize,ax	; initialize
	mov	wptr KkcDataSize+2,ax	;

	cCall	GetKkcHandleNo		; get KKC handle No.
	jc	GetSizeError		; not installed
	mov	ax,KkcBufSize/16	; set buffer size
	mov	es:KkcBufferSize,ax	; need buffer size

	mov	ax,GetSize		;
	mov	bx,KkcHandleNo		;
	int	2fh			; get total data size of KKC
	or	ax,ax			;
	jnz	GetSizeError		;
	mov	wptr KkcDataSize+2,cx	; set total size
	mov	wptr KkcDataSize,dx	;
	clc
GetSizeError:
	stc				;
GetEnd:
cEnd
;----------------------------------------------------------------------------;
; GetKkcHandleNo:							     ;
;									     ;
; This routine gets the handle number of KKC.				     ;
;----------------------------------------------------------------------------;

cProc	GetKkcHandleNo,<NEAR,PUBLIC,PASCAL>,<ax,bx,cx,dx,ds,es>


cBegin

	mov	ax,GetVersionTable	;
	xor	cx,cx			;
	xor	dx,dx			;
	int	2fh			; get an address of the version table
	or	ax,ax			; no get ?
	jnz	GetHandleError		; yes

	mov	ds,cx			;
	mov	bx,dx			;
	mov	ax,ds:[bx]		; get a counter installing KKC
	or	ax,ax			; KKC installed ?
	jz	GetHandleError		; no
	mov	ax,ds:[bx+2]		; get a version No. of KKC
	or	ax,ax			; not installed ?
	jz	GetHandleError		; yes
	mov	es:KkcHandleNo,DefaultHandleNo
	clc
	jmp	short @f		;
GetHandleError:
	stc				;
@@:
cEnd
;----------------------------------------------------------------------------;
sEnd	Code

endif		; ### end if JAPAN ###

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woamgr.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This is the main code that controls most of the activities in WINOLDAP.    ;
; (Please refer to the documentation file WOA.DOC for a detailed description ;
; of the entire process )                                                    ;
;                                                                            ;
; History:                                                                   ;
;                                                                            ;
;        Fri June-15-1990.      -by-  Amit Chatterjee [amitc]                ;
;        Adapted for the Dos Task Switcher.                                  ;
;                                                                            ;
;        Tue June-20-1989.      -by-  Amit Chatterjee [amitc]                ;
;        Created for Windows. (Added the History legend)                     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include woagrab.inc
	include macros.mac
	include njmp.mac
	include woaerr.inc
	include woakeys.inc
	include woaswch.inc
	.list

	.8086                           ;must have to run on 8086s too.

;----------------------------------------------------------------------------;
; define external function calss.                                            ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external FAR OLDAPP procedures.                       ;
	;-------------------------------------------------------;

	externFP InitializeWoa                  ;(WOAINIT.ASM)
	externFP GetSwitcherInfo                ;(WOAINIT.ASM)
	externFP ParseCommandLine               ;(WOAINIT.ASM)

ifdef	JAPAN
	externFP KkcBusyCheck			;(WOAKKC.ASM)
endif

;----------------------------------------------------------------------------;

sBegin  Data

;----------------------------------------------------------------------------;
; define the global variables defined elsewhere                              ;
;----------------------------------------------------------------------------;

externW SwitcherStackTop                ;top of switchers stack
externB DataSegEnd                      ;end of _DATA segment
externB CodeSegEnd                      ;end of _TEXT segment
externB StubSegEnd                      ;end of _WOARLMSEG segment
externD lpXmsControl                    ;XMS control function address

	;-------------------------------------------------------;
	; define any locally used constants                     ;
	;-------------------------------------------------------;
		public  IS_WINOLDAP_ACTIVE

	INT_COM1                equ     0bh
	INT_COM2                equ     0ch
	MAXPATHLENGTH           equ     80
	IS_WINOLDAP_ACTIVE      equ     4680h

	;-------------------------------------------------------;
	; define any external constants.                        ;
	;-------------------------------------------------------;


;---------------------------------------------------------------------------;
; now define the other global variables that will be needed.                ;
;---------------------------------------------------------------------------;
		
		public DosAppSwapFileName
		public SwapBlock
		public CommArea
		public RS232Area
		public RestoreSwapBlock
		public GetDosAppSwapFileName
		public GetDosAppSwap1FileName
		public GetDosAppSwap2FileName
		public AppendUniqueNumber
		public FarAppendUniqueNumber
		public OldAppManagerEnd
		public OldAppManagerRet
		public ErrorHandler
		public FileTemplate
		public WoaSwap1Path
		public WoaSwap2Path
		public WoaSwapFilePrefix
		public SwitcherColors   

;-----------------------------------------------------------------------------;

globalB SwitcherID,0                    ;ID of this switcher
globalW AppUsesXMS,0                    ;app uses XMS or not.
globalB NodeToSwitchTo,-1               ;node to switch to for dir. hotkeys
globalW StartScreenLines,0              ;start up no of screen lines
globalW hApp,0                          ;app id
globalB StartRestartId,0                ;start or restart
globalW AppMinMem,0                     ;minimum mem
globalW AppMinXmsK,0                    ;minimum xms required
globalW AppMaxXmsK,0                    ;maximum xms required
globalW DosAppNumber,0                  ;serial app number
globalW ArenaWalkSel,?                  ;selector used for walking the arenas
globalW ArenaRWSel,?                    ;selector used to read/write arenas
globalW XmsHeapWalkSel,?                ;walks the XMS heap
globalB LowMemBlockType,?               ;type of the low mem dos block
globalW WoaCsSize,?                     ;woa code segment size
globalW WoaDsSize,?                     ;woa data segment size
globalW StubSegSize,?                   ;size of stub segment
globalW WoaStubParaSize,?               ;size of WOA stub in paras
globalD SwapFileOffset,?                ;start sekk offset in swap file
globalB ErrorType,0                     ;WOA error type
globalB ErrorSubType,0                  ;any subtypes
globalW WinMainSP,?                     ;save entry sp here
globalW CurrentDosSwapSeed,?            ;swap file seed being used now
globalB CurrentPathId,?                 ;oath id for current app
globalW AppDead,0                       ;app dead or alive indicator
globalW WoaStubSel,?                    ;selector where stub is to be found
globalB WinSaveXms,0                    ;tells whether win or app saves XMS
globalB ReturnToShellCode,0             ;code returned to shell
globalW HighMemXmsHandle,?              ;handle of the high heap XMS block
globalD XmsBankSize,?                   ;size of apps XMS bank
globalW LowMemParaSize,0                ;size of available low mem
globalD HighMemSize,0                   ;size of available xms memory
globalW LowMemArenaSel,0                ;sel to arena of available mem
globalW LowMemSel,0                     ;sel to start of available mem
globalW UsableLowHeapSel,0              ;?
globalB XmsFlag,0                       ;XMS present or not.
globalW Swap1MinK,0                     ;min size to be left on 1st swap path
globalW Swap2MinK,0                     ;min size to be left on 2nd swap path
globalB DiskSwap1Drive,?                ;fast swap drive for winoldap
SwitcherColors  label   byte            ;color for the switcher screen
	db      ?                       ;for the desk top back ground
	db      ?                       ;for the title bar
	db      ?                       ;text foreground

; define the registers that we need to communicate with the stub.

globalW RealMode_AX,0                   ;storage for AX
globalW RealMode_BX,0                   ;storage for BX
globalW RealMode_CS,0                   ;storage for CS
globalW RealMode_DS,0                   ;storage for DS
globalW RealMode_ES,0                   ;storage for ES
globalW RealMode_IP,0                   ;storage for IP

	;------------------------------------------------------;
	; define a chain of areas to swap out from low memory  ;
	;                                                      ;
	; SwapBlock defines an array of nodes with 4 fields:   ;
	;      . size of swap area (in words)                  ;
	;      . segment                                       ;        
	;      . offset in segment                             ;
	;      . long pointer to area where the data is to be  ;
	;        saved.                                        ;
	; A size of 0, marks the end of the structure.         ;
	;------------------------------------------------------;


SwapBlock       label word

		dw      (SIZE CommArea) / 2     ;BIOS comm area
		dw      4f0h                    ;at 0:4f0h
		dw      0                       ;seg 0
		dw      DataOffset CommArea     
		dw      SEG CommArea

	
		dw      (8*4)/2                 ;INT2-INT9 vector area size
		dw      2*4                     ;offset in 0:
		dw      0                       ;seg 0
		dw      DataOffset Int2to9      ;save here
		dw      SEG Int2to9

		dw      (SIZE RS232Area) / 2    ;port addresses in BIOS area
		dw      0                       ;offset at 0
		dw      40h                     ;segment at 40:
		dw      DataOffset RS232Area    ;save here
		dw      SEG RS232Area

		dw      0                       ;mark end of swap block
		
; define the known save areas

Int2to9         label   word

		dd      6 dup (?)               ;area for vectors 2-7
IntVect8        dd      ?                       ;area for vector 8
IntVect9        dd      ?                       ;area for vector 9

CommArea        db      50 dup (?)              ;save 0:400h - 0:521h
RS232Area       dw      4 dup (?)               ;4 words at 40:0

;----------------------------------------------------------------------------;
; now define two areas where we will hold the swap file for the windows heap ;
; file and the next dos app that we want to handle.                          ;
;----------------------------------------------------------------------------;

DosAppSwapFileName      db      80  dup (0)     ;leave 80 bytes for name
FileTemplate            db      80  dup (0)     ;for deleting files
WoaSwapFilePrefix       db      '~DOS',0        ;all swap file prefix
WoaSwap1Path            db      68  dup (0)     ;first swap file path
WoaSwap2Path            db      68  dup (0)     ;second swap file path
WinEmsSaveArea          db      256 dup (?)     ;save windows EMS context here

;----------------------------------------------------------------------------;
; define all the variables that can be clubbed together and passed on to the ;
; stub segment in one 'rep movs' instruction.                                ;
;                                                                            ;
; ***************************CAUTION**************************************** ;
; The definition or the order of the variables in the following block should ;
; not be altered unless the changes are duplicated for the corresponding     ;
; variables in 'WOARLM.ASM' (declared below)                                 ;
; ************************************************************************** ;
;----------------------------------------------------------------------------;

StubData label byte

globalB fBreak,?                            ;break status
globalB DiskSwap2Drive,?                    ;slow swap drive for winoldap
globalW WoaPDBSeg,0                         ;segment value for the above pdb
globalB EmsFlag,0                           ;EMS present or not.
globalW Int15UsershApp,0                    ;hApp of INT 15 user
globalW SegResizeBlock,?                    ;block to resize in real mode
globalW SizeReservedArea,?                  ;any reserved area ?, it's para size

StubDataLength equ $ - StubData
;----------------------------------------------------------------------------;
						

sEnd    Data

;----------------------------------------------------------------------------;
; now declare the existence of the realmode stub segment and the variables   ;
; that we want to reference here.                                            ;
;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin  StubSeg

;----------------------------------------------------------------------------;
; The following structure will be loaded from the corresponding variables in ;
; the 'StubData' structure defined in the main 'Data' segment. The variables ;
; in the structure will be transferred by a single 'rep movs' instruction.   ;
;----------------------------------------------------------------------------;

externB WoaStubData                     ;the structure which hold varaibles
externB WoaFcb1                         ;first FCB (defined in WoaStubData)
externB WoaFcb2                         ;second FCB (defined in WoaStubData)
externB WoaParams                       ;(defined in WoaStubData)

;----------------------------------------------------------------------------;
; Declare the rest of the varaibles that are needed by the stub code. These  ;
; will have to be loaded individually as it is not possible to arranges the  ;
; corresponding variables in the main data segment contiguously.             ;
;----------------------------------------------------------------------------;

externW XmsBaseHandle                           ;extended memory block handle
externD AppXmsSize                              ;size of apps XMS area
externD AppXmsBase                              ;base of apps XMS area
externW WoahApp                                 ;handle of the window
externB WoafXmsInstalled                        ;NZ if XMS code installed
externW WoaAppNumber                            ;serial number of the app
externW WoaParamBlock                           ;EXEC parameter block
externB WoaBehavior                             ;the behaviour bits
externB WoaHotkeys                              ;the hot key disable flags
externW WoaStubSize                             ;length of stub

;----------------------------------------------------------------------------;
sEnd    StubSeg

;----------------------------------------------------------------------------;
; we define the switch_cs macro here.                                        ;
;----------------------------------------------------------------------------;

switch_cs macro
	local   _x
	local   _y
_x      proc    far
	lea     ax,_y
	push    ax
	ret
_y:
_x      endp
	endm
;----------------------------------------------------------------------------;

sBegin  Code

	assumes cs,Code
	assumes ds,Data
	assumes es,nothing

;----------------------------------------------------------------------------;
; declare the winoldap external function calls.                              ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; declare public routine names referenced elsewhere     ;
	;-------------------------------------------------------;

	public  CopyBasicSwap1FileName
	public  CopyBasicSwap2FileName
	public  FarCopyBasicSwap1FileName
	public  FarCopyBasicSwap2FileName
	
	;-------------------------------------------------------;
	; external NEAR OLDAPP procedures.                      ;
	;-------------------------------------------------------;

	externNP CreateFile                     ;(WOAFILE.ASM)
	externNP OpnFile                        ;(WOAFILE.ASM)
	externNP CloseFile                      ;(WOAFILE.ASM)
	externNP DeleteFile                     ;(WOAFILE.ASM)
	externNP ReadFile                       ;(WOAFILE.ASM)
	externNP WriteFile                      ;(WOAFILE.ASM)
	externNP LseekFile                      ;(WOAFILE.ASM)
	externNP SetNormalAttributes            ;(WOAFILE.ASM)
	externNP SetHiddenAttributes            ;(WOAFILE.ASM)
	externFP RealModeWoa                    ;(WOARLM.ASM)   
	externNP BackFromContextSwitch          ;(WOARLM.ASM)
	externNP ErrorManager                   ;(WOAERR.ASM)
	externNP SwitchManager                  ;(WOASWCH.ASM)
	externNP GetSelectorBase                ;(WOAPMRM.ASM)
	externNP SetSelectorBaseLim64           ;(WOAPMRM.ASM)
	externNP SaveWinEmsContext              ;(WOAUTILS.ASM)
	externNP SaveAppXmsContext              ;(WOAPMRM.ASM)
	externNP GetRealModeSeg                 ;(WOAPMRM.ASM)
	externNP ShuffleSegments                ;(WOAPMRM.ASM)
	externNP InvokeStubCode                 ;(WOAPMRM.ASM)
	externNP ErrorManager                   ;(WOAERR.ASM)
	externNP GetSegSize                     ;(WOAPMRM.ASM)
	externNP SaveDosMemory                  ;(WOAUTILS.ASM)
	externNP GetBackAppXmsNeeds             ;(WOAUTILS.ASM)
	externNP RestoreWinEmsContext           ;(WOAUTILS.ASM)
	externNP RestoreXmsAndDosAllocatedBlocks;(WOAUTILS.ASM)
	externNP MoveWoaIntoStubArea            ;(WOAPMRM.ASM)
	externNP GetAppXmsBase                  ;(WOAPMRM.ASM)
	externNP RestoreSwappedGroups           ;(WOAPMRM.ASM)
	externNP AppSwapOutErrHandler           ;(WOAUTILS.ASM)
	externNP ResetClassInt15Word            ;(WOAUTILS.ASM)
	externNP SetInt15Word                   ;(WOAUTILS.ASM)
	externNP GetInt15Word                   ;(WOAUTILS.ASM)
	externNP GetNSetCtrlCFlag               ;(WOAUTILS.ASM)
	externNP RestoreCtrlCFlag               ;(WOAUTILS.ASM)
	externNP RecoverWindows                 ;(WOAERR.ASM)
	externNP DeleteFilesAndResources        ;(WOAERR.ASM)
	externNP GetSwapFileInformation         ;(WOAINIT.ASM)
	externNP DeleteApp                      ;(WOASWCH.ASM)
	externNP AppToTheTop                    ;(WOASWCH.ASM)
	externNP UpdateExitCode                 ;(WOASWCH.ASM)
	externNP WhichSwapPathToUse             ;(WOAUTILS.ASM)

ifdef	JAPAN
	externNP GetKkcStateSize		;(WOAKKC.ASM)
	externNP DisableKkc			;(WOAKKC.ASM)
	externNP EnableKkc			;(WOAKKC.ASM)
	externNP SaveKkcState			;(WOAKKC.ASM)
	externNP RestoreKkcState		;(WOAKKC.ASM)
endif

;----------------------------------------------------------------------------;


cProc   OldAppManager,<PUBLIC,FAR,PASCAL>,<si,di,bp>

cBegin

	cld                             ;do not take chances with this

; parse the command line. If DOSSWAP.EXE has been invoked with a command 
; line we should print a help message and exit.

	call    ParseCommandLine        ;is there a command line ?
	njc     OldAppManager4CExit     ;yes, exit 

; switch to a local stack.


; load ds

	mov     ax,DGROUP
	mov     ds,ax                   ;load proper ds
	assumes ds,Data

	cli
	mov     ss,ax
	mov     sp,DataOFFSET SwitcherStackTop;SS:SP -> top of switcher stack
	sti

; get info from the switcher data structure

	cCall   GetSwitcherInfo         
	njc     OldAppManagerEnd        ;error during initialization
		   
	mov     ax,hApp                 ;get the app id
	mov     CurrentDosSwapSeed,ax   ;save it

	cmp     StartRestartId,0        ;start the app
	jz      @f                      ;yes, have to launch it first
	mov     ax,1                    ;restart app context switch
	save    <ax>                    ;save
	cCall   InitializeWoa,<ax>      ;initialize for restart
	njc     OldAppManagerEnd        ;error during initialization

ifdef	JAPAN
	cCall	KkcBusyCheck		; KKC busy ?
	jnc	KkcNotBusy		; no
	mov	ErrorType,ER_APP_SWAP_IN ; set error type 'app swap in error'
	jmp	OldAppManagerEnd	;
KkcNotBusy:
	cCall	GetKkcStateSize		;
endif

	call    ContextSwitch           ;ready to restatrt app
	jmp     short invoke_real_mode_stub
@@:


; call the Initialization routine to set up various variables. This routine
; is in a separate code segment which will be ignored after the initialization
; is done.

	xor     ax,ax                   ;starting an app
	cCall   InitializeWoa,<ax>      ;initialize variables
	njc     OldAppManagerEnd        ;error during initialization

ifdef	JAPAN
	cCall	GetKkcStateSize		;
endif

; get the current int 15 users ID

	cCall   GetInt15Word            ;get the value of the word.
	mov     Int15UsershApp,ax       ;save it.

; at this point we must get the current CTRL+C flag and set it off.

	cCall   GetNSetCtrlCFlag        ;get current one and set it off.

;----------------------------------------------------------------------------;
; save the relevant interrupt vectors and the portions of the BIOS data area ;
; that have been linked into the SwapBlock.                                  ;
;----------------------------------------------------------------------------;

	call    SaveSwapBlock           ;save the areas needed in global heap

	mov     WinSaveXms,0ffh         ;need to save extended memory image

; swap windows out now.

	mov     ax,1                    ;all WOA segments to be relocated
	cCall   SwapWindowsOut,<ax>     ;swap the low heap to disk
	jnc     NoSwapError             ;no error

; delete all files and allocated selectors and terminate this instance.

	call    DeleteFilesAndResources ;free selectors etc.
	xor     ah,ah                   ;error code will be in AX
	mov     al,ER_WND_SWAP_OUT      ;Windows swap out failure
	jmp     short OldAppManagerEnd  ;return back

NoSwapError:

;----------------------------------------------------------------------------;
; And as we want a fresh app to be loaded, we set the AX value to be passed  ;
; to the stub to be 0                                                        ;
;----------------------------------------------------------------------------;

	mov     RealMode_AX,0

invoke_real_mode_stub:

	cCall   InvokeStubCode          ;invokes the stub code
	jnc     NoRealModeError         ;there was no error

; if AH is 0, the error is an exec error, else it is some other error

	or      ah,ah                   ;is it an exec error ?
	jz      ExecError               ;yes, it is

; we had some other error, like grabber load failure etc
	
	mov     ErrorType,ah            ;save the error code
	jmp     ErrorHandler            ;exit from here

ExecError:

	mov     ErrorSubType,al         ;save exec error code
	mov     ErrorType,ER_EXEC_FAILS ;exec failure error code
	jmp     ErrorHandler            ;get out and display error

NoRealModeError:

; the value of BX in the client register frame will tell us if any instance 
; has int 15 hooked and thus locked.

	mov     bx,RealMode_BX
	mov     Int15UsershApp,bx       ;save it

; if AX in the register frame at this point is !0 we have to do a context switch
; to some other application.

	mov     AppDead,0               ;assume app still alive
	cmp     RealMode_AX,0
	jz      @f                      ;old app finished execution

	xor     ax,ax                   ;full fleged context switch
	call    ContextSwitch           ;go to windows & stay till switch back

	jmp     short invoke_real_mode_stub

@@:

; we are back in protected mode and are executing in high heap so we can safely
; load windows back.

	cCall   SwapWindowsIn           ;windows restored to original state

;----------------------------------------------------------------------------;
; windows area has been restored, so restore the swap block and ask kernel to;
; regain whatever trap vectors it needs.                                     ;
;----------------------------------------------------------------------------;

	call    RestoreSwapBlock        ;restore the areas that we had saved

; re-enable kernels dos traps, before this we must return the state of the
; CTRL+C flag. 

	cCall   RestoreCtrlCFlag        ;resturn original state

; if any one is using INT 15 then set the class word.

	mov     ax,Int15UsershApp       ;get the id
	or      ax,ax                   ;no one using it ?
	jz      @f                      ;no one.
	cCall   SetInt15Word,<ax>       ;set the INT 15 id 
@@:

; if the app has been using INT 15, reset the class word

	cCall   ResetClassInt15Word,<hApp>

;----------------------------------------------------------------------------;
; mark this app as deleted in the global structure. It is very important that;
; we do this after we have gone past all areas where we can get an error.    ;
;----------------------------------------------------------------------------;

	mov     ax,CurrentDosSwapSeed   ;load the current dos app number
	cCall   DeleteApp,<ax>          ;delete the app.

; we are going back to the shell, we must maintain the integrity of the Z 
; ordering by making sure that the shell task is at the top of the task
; list. At this point that may not be true. The Z-ordering should be updated
; as if we are doing a directed hot ket switch to the shell.

	xor     ax,ax                   ;want the shell to be on top
	cCall   AppToTheTop,<ax>        ;make shell the top task

OldAppManagerRet:

	xor     ax,ax                   ;normal return path
	mov     ErrorType,al            ;initialize for no error
	mov     ErrorSubType,al         ;no error

OldAppManagerEnd:

; if the XMS block has been allocated, and there is only one app in the list
; (the shell) then unlock and release the block. This should also be done 
; if there are just two apps on the list and we have an error.

	cmp     HighMemXmsHandle,0      ;was it allocated ?
	jz      XmsBlockDone            ;no.
	mov     ax,4a05h                ;opcode
	mov     si,CGET_LIST_LENGTH     ;get the no of programs.
	int     2fh                     ;dx:ax has the long pointer
	or      ax,ax                   ;0 means 1
	jz      XmsBlockRelease         ;realease the xms block.
	cmp     ax,1                    ;just 2 apps left (including the shell)
	ja      XmsBlockDone            ;no, do not bother about XMS block
	cmp     ErrorType,0             ;did we have an error ?
	jz      XmsBlockDone            ;no, so really one old app is still alive

XmsBlockRelease:

; we must unlock and release the block. 

	mov     ah,0dh                  ;unlock xms block
	mov     dx,HighMemXmsHandle     ;handle of the allocated block
	call    lpXmsControl            ;AX has largest free block size in K

	mov     ah,0ah                  ;free xms block code.
	mov     dx,HighMemXmsHandle     ;handle of the allocated block
	call    lpXmsControl            ;AX has largest free block size in K

; update the values in the global list structure.

	pushem  es,di                   ;save
	mov     ax,4a05h                ;opcode
	mov     si,CGET_GLOBAL_SWITCH_DATA
	int     2fh                     ;dx:ax has the long pointer
	mov     es,dx                   ;load it into es
	mov     di,ax                   ;es:di -> info structure
	mov     wptr es:[di].XMS_Handle,0;no valid handle
	mov     wptr es:[di][0].XMS_Size,0
	mov     wptr es:[di][2].XMS_Size,0
	popem   es,di                   ;restore

XmsBlockDone:

; stuff in the exit code.

	cCall   UpdateExitCode,<ErrorType,ErrorSubType>

OldAppManager4CExit:

	mov     ax,4c00h
	int     21h

cEnd

;----------------------------------------------------------------------------;
;                       UTILITY ROUTINES                                     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; ContextSwitch:                                                             ;
;                                                                            ;
;   This routine is responsible for either switching to windows, or to the   ;
;   next or previous oldapp.                                                 ;
;                                                                            ;
;   The gist of the routine is as follows:                                   ;
;                                                                            ;
;          . swaps out part of all of memory which was occupied by windows   ;
;            low heap. This has the outgoing dos apps context                ;                                                       ;
;          . If switch is to an old app, determine which one to run and then ;
;            change the dosappnumber appropriately so that the correct swap  ;
;            file will be handled. If a next/previous dos app is found, then ;
;            jmp to label CS1:, else continue.
;          . swaps in windows low heap, enables kernel interrupt trappings & ;
;            enables the OEM layers. Restores real mode IDT                  ;
;          . sets a global flag indicating that the old app is an iconic     ;
;            state and goes into a loop, geting, translating and dispatching ;
;            windows messages. It stays here till user opens the old app     ;
;            icon which causes the above indicator to be reset.              ;
;          . disables all the OEM layers.                                    ;
;          . disables kernel trapping of the interrupt vectors .             ;
;          . saves real mode IDT                                             ;
;          . swaps windows out                                               ;
;       CS1:                                                                 ;
;          . swaps the old app in                                            ;
;          . calls back to real mode stub, setting up SS & SP to point to    ;
;            initial real mode stack and transfer control to the label named ;
;            'BackFromContextSwitch'                                         ;
;----------------------------------------------------------------------------;

ContextSwitch proc near

	cld                             ;do not take chances with this
	or      ax,ax                   ;first time start ?
	jz      @f                      ;yes
	jmp     short StartAgain        ;no, restart the app
@@:
	mov     ax,RealMode_AX          ;has type of switch

; now call the switch manager to process the type of switch desired. It would
; handle all types of switch requests and if it returns with carry set, we
; would need to switch to an oldapp else to some windows window.

	clc
	cCall   SwitchManager,<ax,CurrentDosSwapSeed>
	smov    es,ds                   ;restore es to be ds
	jnc     @f                      ;must go back to shell.
	cmp     ax,CurrentDosSwapSeed   ;want to restart same app ?
	jz      RestartApp              ;yes, no swapping needed.
	stc                             ;set carry to => restart old app
@@:
	pushf                           ;save state of carry flag.
	push    ax                      ;save app id.
	push    bx                      ;save swap path id

; now swap out the old app.

	cCall   SwapDosAppOut           ;save old app's context
	jnc     @f                      ;app swapped out OK.

; the dos app could not be swapped out, we must return to it. Bring it back to
; the top of the list.

	push    ax                      ;save
	mov     ax,CurrentDosSwapSeed   ;get the ID of the app.
	cCall   AppToTheTop,<ax>        ;move the app to the top of the list.
	pop     ax                      ;restore

; the dos swap out attempt failed, put up a message on the screen saying this
; and restart the app. 

	cCall   AppSwapOutErrHandler    ;display message.
	pop     bx                      ;discard saved swap path id
	pop     ax                      ;disacrd saved app id
	popf                            ;discard saved flag state
	jmp     short RestartApp        ;restart the same app
@@:
	pop     bx                      ;restore swap path id
	pop     ax                      ;restore saved app id
	popf                            ;restore saved flag state
	jnc     BackToWindows           ;go back to shell

; we have to load another oldapp, simply set the dos swap file seed to the
; handle of the window for the oldapp.

	mov     CurrentPathId,bl        ;save swap path ID
	mov     CurrentDosSwapSeed,ax   ;correct dos files seed
	jmp     short ReActivateOldApp  ;reaload another oldapp

BackToWindows:

; control going back to windows

	push    ax                      ;save the window to invoke
	cCall   SwapWindowsIn           ;restore windows low heap

	cCall   RestoreSwapBlock        ;restore last swap block

; re-enable kernels dos traps, before this we must return the state of the
; CTRL+C flag. This had been saved after doing the DisableDos call.

	cCall   RestoreCtrlCFlag        ;resturn original state

ActivateNewTask:

	pop     ax                      ;get back the window handle to activate

; if Int15UsershApp is not zero, we must set it in the class word.
	
	mov     ax,Int15UsershApp       ;get the variable
	or      ax,ax                   ;did the switched out app use it
	jz      @f                      ;no.
	cCall   SetInt15Word,<ax>       ;INT 15 word updated
@@:

	xor     ax,ax                   ;no error
	mov     ErrorSubType,al         ;no error

; if we are going back because of an app swap in error set the error type 
; appropriately. We can also have an error when we try to restart an app
; that has never been started before. In all cases the error code will be
; put in 'ReturnToShellCode'
	
	mov     al,ReturnToShellCode    ;will be zero if no error.
	mov     ErrorType,al            ;initialize for no error
	jmp     OldAppManagerEnd        ;go back.

StartAgain:

	cCall   GetInt15Word            ;get the current INT 15 word value
	mov     Int15UsershApp,ax       ;save it.

; at this point we must get the current CTRL+C flag and set it off.

	cCall   GetNSetCtrlCFlag        ;get current one and set it off.

	cCall   SaveSwapBlock           ;save this swap block

; at this point we are just reloading an already loaded application so while
; swapping windows out, we will assume no XMS is required. If app actually needs
; XMS memory, it will recreate the windows xms swap file. 

	mov     WinSaveXms,0            ;no need to save XMS image now.

; now swap Windows out.

	xor     ax,ax                   ;only main woa segments to be relocated
	cCall   SwapWindowsOut,<ax>     ;windows swapped out
	jnc     ReActivateOldApp        ;swap out successful.
	jmp     OldAppManagerEnd        ;go back, we got an error.

ReActivateOldApp:

; finally get old app context back

	cCall   SwapDosAppIn            ;get back the dos app
	jnc     RestartApp              ;context read in OK
	mov     al,ErrorType            ;get the error type
	mov     ReturnToShellCode,al    ;save it
	jmp     BackToWindows           ;go back to Windows.

RestartApp:

; now reload the register frame, setting AX to 1 this time.

	mov     ax,_WOARLMSEG           ;load the segment for the stub

; set up CS=DS=ES=SS to this value

	mov     RealMode_CS,ax
	mov     RealMode_DS,ax
	mov     RealMode_ES,ax

; set up IP

	mov     ax,StubSegOFFSET BackFromContextSwitch
	mov     RealMode_IP,ax

; set up the value of Int15UsershApp in ax in the client frame.

	mov     ax,Int15UsershApp       
	mov     RealMode_AX,ax

; we are ready to go back to real mode and resume the execution

	ret

ContextSwitch   endp
;----------------------------------------------------------------------------;
; SwapWindowsOut:                                                            ;
;                                                                            ;
; Swaps the low heap out to the disk.                                        ;
;                                                                            ;
; After swapping the low heap out, this routine also relocates winoldap segm-;
; -ents based on a parameter. If the Relocate flag is 1, all the segments are;
; relocated (this is when windows is being swapped out to start the old app  ;
; for the firts time) else only the main code and data segments are relocated;
; (this is when windows is being swapped out to restart the old app).        ;
;----------------------------------------------------------------------------;

cProc   SwapWindowsOut,<NEAR,PASCAL,PUBLIC>,<di,si>

	assumes cs,Code
	assumes ds,Data

	parmW   RelocationFlag          ;type of seg. relocation to be done

	localW  FileHandle              ;save the file handle here
	localD  lpSwapFile              ;name of the swap file

cBegin

	cld                             ;do not take chances with this

; set error type = 'windows swap out error' in case we fail

	mov     ErrorType,ER_WND_SWAP_OUT

; first save the state of the EMS map if EMS is present
		
	call    SaveWinEmsContext       ;save EMS context

	smov    es,ds                   ;make es point to data segment too

; based on the type of relocation of segments desired, do the relocation

	cmp     RelocationFlag,1        ;all segments to be relocated ?
	jz      RelocateAllSegments     ;yes

; reload woa code above into its resident area. Do not bother about the other
; segments.

;       cCall   MoveWoaIntoStubArea     ;relocate main code and data
	jmp     short SegmentRelocationDone

RelocateAllSegments:

;----------------------------------------------------------------------------;
; Windows has been swapped out and it is time now to rellocate the WOA       ;
; segments such that we can release as much space as possible for the oldapp ;
;                                                                            ;
; In protected mode the main code segment and the data segment will be moved ;
; to the begining of the high heap, the stub segment and, if needed, the  XMS;
; segment will be relocated to the start of the lowheap.                     ;
;                                                                            ;
; In Real mode, all winoldap segments will be relocated to the start of the  ;
; low heap after the top PDB area.                                           ;
;----------------------------------------------------------------------------;

	cCall   ShuffleSegments         ;position winoldap segments

SegmentRelocationDone:

	clc                             ;no error

SwapWindowsOutRet:
cEnd
;----------------------------------------------------------------------------;
; SwapWindowsIn:                                                             ;
;                                                                            ;
; Swaps the low heap in, relocates woa from high memory area and then swap in;
; the high heap part                                                         ;
;----------------------------------------------------------------------------;

cProc   SwapWindowsIn,<NEAR,PASCAL,PUBLIC>,<di,si>

	assumes cs,Code
	assumes ds,Data

	localD  lpSwapFile              ;pointer to the name of the swap file

cBegin

	cld                             ;do not take chances with this

; set error type = "windows swap in error" in case we fail

	mov     ErrorType,ER_WND_SWAP_IN

; at first restore the EMS state if EMS is present. We must have the right 
; banks mapped in befor we restore the heap.

	call    RestoreWinEmsContext

; restore the block type and size of the low memory block.

	push    es                      ;save
	mov     es,LowMemArenaSel       ;get the selector for the low mem blk
	mov     al,LowMemBlockType      ;get the saved block type
	mov     es:[0],al               ;restore it
	mov     ax,LowMemParaSize       ;get the size of the low mem block
	mov     es:[3],ax               ;save it.
	pop     es

SwapWindowsInRet:

cEnd
;----------------------------------------------------------------------------;
; SwapDosAppOut:                                                             ;
;                                                                            ;
; This swaps the DOS APP out into the disk in preparation of rolling windows ;
; back.                                                                      ;
;----------------------------------------------------------------------------;

cProc   SwapDosAppOut,<NEAR,PUBLIC,PASCAL>                                      
		
	localW  SwapHandle              ;save the swap file handle here
	localD  FileOffset              ;place to save offset of XMS area start
	localD  lpSwapFile              ;ptr to name of the swap file

cBegin

	cld                             ;do not take chances with this

; find out which swap drive to use and whether we will have space to swap
; out or not.

	call    WhichSwapPathToUse      ;find out which path to use
	njc     SwapDosAppOutRet        ;no space on either.

; get the dos app file name  to swap out

	mov     si,OFFSET DosAppSwapFileName;filled in above
	mov     seg_lpSwapFile,ds       ;save the pointer to the name
	mov     off_lpSwapFile,si

; swap out the allocated dos blocks to the disk

	mov     ax,0ffffh               ;opcode => do swapping
	cCall   SaveDosMemory,<ds,si,ax>
	
	jc      SwapDosAppOutRet        ;cannot proceed with error
	mov     SwapHandle,ax           ;save the handle of the file

; it's time to save the XMS context now, but the current offset of the file
; has to be written into the first 4 bytes of the file so that the XMS context
; could be read in first during swap in.

	xor     ax,ax                   ;need to lseek 0 to get seek offset
	mov     bx,1                    ;need to seek from current position
	cCall   LseekFile,<SwapHandle,ax,ax,bx>
	mov     seg_FileOffset,dx       ;save hiword of current offset
	mov     off_FileOffset,ax       ;save loword of current offset

; now seek back to the start of the file

	xor     ax,ax                   ;for offset/origin
	cCall   LseekFile,<SwapHandle,ax,ax,ax>

; and write the offset of the start of the XMS area

	lea     ax,FileOffset           ;ss:ax points to data to write
	mov     cx,4                    ;need to write 4 bytes
	xor     bx,bx                   ;need for high word of count
	cCall   WriteFile,<SwapHandle,ss,ax,bx,cx>
	jc      SwapDosAppOutRet        ;cannot proceed with error

; finally seek back to the start of the XMS swap out area

	xor     ax,ax                   ;need to seek from the begining
	cCall   LseekFile,<SwapHandle,FileOffset,ax>

; now save the size of the XMS block and the XMS block itself.

	cCall   SaveAppXmsContext,<SwapHandle>;saves apps XMS context
	jc      SwapDosAppOutRet        ;cannot proceed with error

ifdef	JAPAN
	cCall	DisableKkc		; disable KKC
	jc	@f			; no support interface of KKC
	cCall	SaveKkcState,<FileHandle> ; save state of KKC
	jc	SwapDosAppOutRet	; write error
	cCall	EnableKkc		; enable KKC
@@:
endif

; close the dos app file

	cCall   CloseFile,<SwapHandle>  ;the swap file is closed
	jc      SwapDosAppOutRet        ;cannot proceed with error

; mark the file to be read only and hidden

	cCall   SetHiddenAttributes,<lpSwapFile>

SwapDosAppOutRet:
	
cEnd
;----------------------------------------------------------------------------;
; SwapDosAppIn:                                                              ;
;                                                                            ;
; This routine swaps the dos file swap area back to where it was in memory   ;
;----------------------------------------------------------------------------;

cProc   SwapDosAppIn,<NEAR,PUBLIC,PASCAL>                                       

cBegin

	cld                             ;do not take chances with this

; set error type = 'app swap in error' in case we fail

	mov     ErrorType,ER_APP_SWAP_IN

; get the name of the file to swap in
	
	call    GetDosAppSwapFileName   ;DS:SI has the name

; now get back Xms image and the image for the dos app

	cCall   RestoreXmsAndDosAllocatedBlocks,<ds,si>
	jc      SwapDosAppInRet         ;can't read it in

ifdef	JAPAN
	cCall	DisableKkc		; disable KKC
	jc	@f			; no support interface of KKC
	cCall	RestoreKkcState,<ax>
	jc	SwapDosAppInRet
	cCall	EnableKkc		; enable KKC
@@:
endif

; now close the swap file, and delete it.

	cCall   CloseFile,<ax>          ;swap file closed

; get the name of the swap file and delete it

	mov     si,DataOFFSET DosAppSwapFileName
	cCall   DeleteFile,<ds,si>


SwapDosAppInRet:
	
cEnd
;----------------------------------------------------------------------------;
; MoveWoa:                                                                   ;
;               Relocate to low memory                                       ;
;----------------------------------------------------------------------------;

cProc   MoveWoa,<NEAR,PUBLIC,PASCAL>

	parmW   TargetHeapSel           ;area to relocate to
	parmW   NewCsSel                ;selector to use for copied CS
	parmW   NewDsSel                ;selector to use for copied DS

cBegin

	cld                             ;do not take chances with this

	mov     bx,TargetHeapSel        ;get the target selector
	call    GetSelectorBase         ;gets base address

	push    cx
	push    dx                      ;save base of target selector
	mov     bx,NewCsSel             ;load the selector for new CS
	call    SetSelectorBaseLim64    ;sets base and limit to 64k
	mov     NewCsSel,bx             ;save (needed in real mode)
	pop     dx
	pop     cx                      ;get base of copy area
	add     dx,WoaCsSize            ;add size of the code seg
	adc     cx,0
	mov     bx,NewDsSel             ;load the selector for the new data seg
	call    SetSelectorBaseLim64    ;sets base and then limit to 64k
	mov     NewDsSel,bx             ;save it (need in real mode)

; now copy the code segment

	cli                             ;shut off interrupts
	push    ds                      ;save
	mov     cx,WoaCsSize            ;get size in bytes
	mov     es,NewCsSel             ;target segment for copy
	smov    ds,cs                   ;source segment for copy
	xor     si,si
	xor     di,di                   ;offsets start at 0
	rep     movsb                   ;do the move
	pop     ds                      ;get back data segment

; now copy the data segment

	mov     cx,WoaDsSize            ;data segment size
	mov     es,NewDsSel             ;target selector
	xor     si,si
	xor     di,di                   ;start offsets are 0
	rep     movsb                   ;do the move
	sti                             ;enable interrupts

; change attribute of the code segment copy to be code segment

	mov     bx,NewCsSel             ;selector for code segment

; load the ss and ds selectors.

	mov     ax,NewDsSel             ;load the selector for data and stack
	mov     ds,ax
	mov     ss,ax                   ;DS and SS updated

	push    NewCsSel                ;push in the new cs
	switch_cs                       ;does the switch

MoveWoaRet:

; get a new data segment alias for the code segment here

;----------------------------------------------------------------------------;
; NOTE: SINCE KERNEL HAS BEEN SWAPPED OUT WE CANNOT MAKE USE OF THE KERNEL   ;
;       SELECTOR HANDLER ROUTINES, BECAUSE THEY WILL ALTER KERNEL'S STATE.   ;
;----------------------------------------------------------------------------;

cEnd

;----------------------------------------------------------------------------;
; LoadRealModeStub:                                                          ;
;                                                                            ;
; This routine loads all the variables that are needed by the real mode stub.;
;----------------------------------------------------------------------------;

cProc   LoadRealModeStub,<NEAR,PUBLIC,PASCAL>

cBegin

	cld                             ;do not take chances with this

; now copy the real mode WOA segment down into low memory area

	mov     ax,_WOARLMSEG           ;segment for the stub
	mov     es,ax                   ;load it in es
	assumes es,StubSeg
	assumes ds,Data

;----------------------------------------------------------------------------;
; Most of the variables that are needed by the stub segment will be loaded   ;
; by copying 'StubData' structure to the 'WoaStubData' structure. The        ;
; position and definition of individual variables in the two structure must  ;
; be identical.                                                              ;
;----------------------------------------------------------------------------;

	mov     si,DataOFFSET StubData  ;source structure
	mov     di,StubSegOFFSET WoaStubData
	mov     cx,StubDataLength       ;length of xfer
	rep     movsb                   ;move it over (cld done earlier)

;----------------------------------------------------------------------------;
; Now copy other variables (which could not be clubbed into the above        ;
; structure individually.                                                    ;
;----------------------------------------------------------------------------;

; pass the old app number

	mov     ax,DosAppNumber         ;the serial number of the app
	mov     WoaAppNumber,ax         ;pass it on

; pass on the handle of the window

	mov     ax,hApp                 ;handle of this instances window
	mov     WoahApp,ax              ;pass it on

; create the WOA exec parameter block

	xor     ax,ax
	mov     [WoaParamBlock],ax      ;environment seg = 0

; save the value of the stub segment in the client register frame

	mov     ax,es                   ;get the segment value

; also set the CS,DS,ES values in the register frame to this value

	mov     RealMode_CS,ax
	mov     RealMode_DS,ax
	mov     RealMode_ES,ax

	mov     [WoaParamBlock+4],ax    ;segment for parameter block
	mov     [WoaParamBlock+8],ax    ;segment for first FCB
	mov     [WoaParamBlock+12],ax   ;segment for the second FCB

; now load the 3 offsets

	mov     ax,StubSegOFFSET WoaParams
	mov     [WoaParamBlock+2],ax    ;osffet for parameters
	mov     ax,StubSegOFFSET WoaFcb1
	mov     [WoaParamBlock+6],ax    ;offset for first fcb
	mov     ax,StubSegOFFSET WoaFcb2
	mov     [WoaParamBlock+10],ax   ;offset for second fcb

; set up the initial ip in real mode into the resgister frame

	mov     ax,StubSegOFFSET RealModeWoa
	mov     RealMode_IP,ax

; The real mode stub is loaded and is ready to receive control.  Now
; setup data for XMS code if it's installed (it will be installed if
; the XmsBankSize is NZ).

; tell stub if XMS code is installed

	mov     es:[WoafXmsInstalled],0 ;assume not installed
	mov     ax,wptr [XmsBankSize]
	or      ax,wptr [XmsBankSize+2]
	jz      LRMSRet
	inc     es:[WoafXmsInstalled]   ;installed, set flag to NZ

; pass the handle of the high heap xms block

	mov     ax,HighMemXmsHandle     ;get the handle of the xms block
	mov     es:[XmsBaseHandle],ax   ;save it

; get the base of the XMS memory to be allocated to the app

	call    GetAppXmsBase           ;returns base in cx:dx

; pass on this linear address as the base of the apps XMS area

	mov     es:wptr [AppXmsBase+2],cx
	mov     es:wptr [AppXmsBase],dx

; and pass on the size of the apps xms block

	mov     cx,wptr [XmsBankSize+2] ;get size requested by the app
	mov     dx,wptr [XmsBankSize]
	mov     wptr es:[AppXmsSize+2],cx
	mov     wptr es:[AppXmsSize],dx

LRMSRet:

cEnd
;----------------------------------------------------------------------------;
; SaveSwapBlock:                                                             ;
;       Traverses the swap block and transfers areas from the source address ;
;       to the dsetination address. The swap block is an array of nodes with ;
;       the following sturcture:                                             ;
;               WORD   --   size in words of area to swap                    ;
;              DWORD   --   long pointer to source area                      ;
;              DWORD   --   long pointer to destination area                 ;
;                                                                            ;
;        A word count of zero marks the end of the block.                    ;
;----------------------------------------------------------------------------;

SaveSwapBlock   proc    near

	cld                             ;do not take chances with this

	mov     dx,ds                   ;save WOA ds
	mov     bx,DataOFFSET SwapBlock ;DS:BX points to the swap block

save_swap_loop:

	mov     ds,dx                   ;get back WOA data segment
	mov     cx,[bx]                 ;get the word count
	jcxz    save_swap_done          ;the block has been swapped away
	les     di,[bx+6]               ;load the destination in es:di
	lds     si,[bx+2]               ;load source in ds:si
	rep     movsw                   ;save one swap area
	add     bx,10                   ;point to the next entry
	jmp     save_swap_loop          ;move all areas

save_swap_done:

	ret                             
			
SaveSwapBlock   endp
;----------------------------------------------------------------------------;
; RestoreSwapBlock:                                                          ;
;           Restores the swap block. This is very similar to the routine     ;
;           above, except that it reverses the direction of copy.            ;
;----------------------------------------------------------------------------;
RestoreSwapBlock        proc    near

	cld                             ;do not take chances with this

	mov     dx,ds                   ;save WOA ds
	mov     bx,DataOFFSET SwapBlock ;DS:BX points to the swap block

restore_swap_loop:

	mov     ds,dx                   ;get back WOA data segment
	mov     cx,[bx]                 ;get the word count
	jcxz    restore_swap_done       ;the block has been swapped away
	les     di,[bx+2]               ;load the destination in es:di
	lds     si,[bx+6]               ;load source in ds:si
	cli                             ;mask off interrupts
	rep     movsw                   ;save one swap area
	sti                             ;allow interrupts
	add     bx,10                   ;point to the next entry
	jmp     restore_swap_loop               ;move all areas

restore_swap_done:

	ret                             
			
RestoreSwapBlock        endp
;----------------------------------------------------------------------------;
; SwapSwapBlock:                                                             ;
;               This exchanges the contents of the current swap area         ;
;               locations with the saved one.                                ;
;----------------------------------------------------------------------------;
;SwapSwapBlock   proc    near
;
;        cld                             ;do not take chances with this
;
;        mov     dx,ds                   ;save WOA ds
;        mov     bx,DataOFFSET SwapBlock ;DS:BX points to the swap block
;
;swap_swap_loop:
;
;        mov     ds,dx                   ;get back WOA data segment
;        mov     cx,[bx]                 ;get the word count
;        jcxz    swap_swap_done          ;the block has been swapped away
;        les     di,[bx+2]               ;load the destination in es:di
;        lds     si,[bx+6]               ;load source in ds:si
;        cli                             ;mask off interrupts
;swap_a_node:
;        mov     ax,[si]                 ;get a word from source
;        xchg    ax,es:[di]              ;swap it with destination
;        mov     [si],ax                 ;save it in the source
;        add     si,2                    ;next entry in source
;        add     di,2                    ;next entry in destination
;        loop    swap_a_node             ;complete swapping of the node
;        sti                             ;allow interrupts
;        add     bx,10                   ;point to the next entry
;        jmp     swap_swap_loop          ;move all areas
;
;swap_swap_done:
;
;        ret                             
;                        
;SwapSwapBlock   endp
;----------------------------------------------------------------------------;
; these routines create the name for the swap files to be used.              ;
;----------------------------------------------------------------------------;

		;----------------------------------;
		; based on the path ID it calls an ;
		; appropropriate function to create;
		; a swap file name.                ;
		;----------------------------------;
		
GetDosAppSwapFileName proc near

	cmp     CurrentPathId,1         ;first path to use ?
	jnz     @f                      ;no.
	call    GetDosAppSwap1FileName  ;use first path
	jmp     short GetDosAppSwapFileNameRet
@@:
	call    GetDosAppSwap2FileName  ;use second path

GetDosAppSwapFileNameRet:

	ret

GetDosAppSwapFileName endp

		;----------------------------------;
		; Creates Dos App Swap File Name   ;
		; (based on the first swap path)   ;
		;----------------------------------;

GetDosAppSwap1FileName proc near

	mov     di,DataOFFSET DosAppSwapFileName
	call    CopyBasicSwap1FileName  ;copy the invariant part of name
	mov     ax,CurrentDosSwapSeed   ;get the seed for the file
	call    AppendUniqueNumber      ;appens the unique number
	mov     si,DataOFFSET DosAppSwapFileName
	ret

GetDosAppSwap1FileName endp

		;----------------------------------;
		; Creates Dos App Swap File Name   ;
		; (based on the second swap path)  ;
		;----------------------------------;


GetDosAppSwap2FileName proc near

	mov     di,DataOFFSET DosAppSwapFileName
	call    CopyBasicSwap2FileName  ;copy the invariant part of name
	mov     ax,CurrentDosSwapSeed   ;get the seed for the file
	call    AppendUniqueNumber      ;appens the unique number
	mov     si,DataOFFSET DosAppSwapFileName
	ret

GetDosAppSwap2FileName endp

		;----------------------------------;
		;appends the unique number to name ;
		;----------------------------------;

AppendUniqueNumber proc near

	cld                             ;do not take chances with this

	mov     bx,ax                   ;save seed
	mov     al,bh                   ;get high byte of seed
	call    SaveLettersFromByte     ;convert into 2 hex letters and save
	mov     al,bl                   ;get the low byte of the seed
	call    SaveLettersFromByte     ;convert into 2 hex letters and save
	mov     ax,'T.'                 ;next two characters
	stosw                           ;x:\<path>\~DOShhhh.T
	mov     ax,'PM'                 ;final two characters
	stosw                           ;x:\<path>\~DOShhhh.TMP
	xor     al,al                   ;the zero terminator
	stosb                           ;save it too.
	ret

AppendUniqueNumber endp

		;----------------------------------;
		; Far entry point to above routine ;
		;----------------------------------;

FarAppendUniqueNumber proc far

	call    AppendUniqueNumber
	ret

FarAppendUniqueNumber endp

		;----------------------------------;
		; saves two ascii leters fro a byte;
		;----------------------------------;

SaveLettersFromByte proc near

	cld                             ;do not take chances with this

	push    ax                      ;save
	shiftr  al,4                    ;get high nibble
	call    GetLetterFromNibble     ;convert to letter
	stosb                           ;save it
	pop     ax                      ;get back high byte
	and     al,0fh                  ;isolate low nibble
	call    GetLetterFromNibble     ;convert to a letter
	stosb                           ;save it
	ret

SaveLettersFromByte endp

		;----------------------------------;
		;converts a nibble to a hex letter ;
		;----------------------------------;

GetLetterFromNibble proc near

	add     al,30h                  ;add base for 0
	cmp     al,39h                  ;past '9'
	jbe     @f                      ;no, we are ok
	add     al,7                    ;convert to letter
@@:
	ret                             ;AL has ascii letter

GetLetterFromNibble endp

		;---------------------------------;
		;copies the basic swap file name  ;
		;based on the first swap path     ;
		;---------------------------------;

CopyBasicSwap1FileName proc near

	cld                             ;do not take chances with this

	smov    es,ds                   ;es and ds should both be own DSEG
	mov     si,DataOFFSET WoaSwap1Path
@@:
	lodsb                           ;get the next character
	stosb                           ;save it
	or      al,al                   ;was the null copied ?
	jnz     @b                      ;no, continue
	dec     di                      ;back over the null
	ret

CopyBasicSwap1FileName endp

		;---------------------------------;
		;copies the basic swap file name  ;
		;based on the second swap path    ;
		;---------------------------------;

CopyBasicSwap2FileName proc near

	cld                             ;do not take chances with this

	smov    es,ds                   ;es and ds should both be own DSEG
	mov     si,DataOFFSET WoaSwap2Path
@@:
	lodsb                           ;get the next character
	stosb                           ;save it
	or      al,al                   ;was the null copied ?
	jnz     @b                      ;no, continue
	dec     di                      ;back over the null
	ret

CopyBasicSwap2FileName endp

		;-----------------------------------;
		; far entry point to above routines ;
		;-----------------------------------;

FarCopyBasicSwap1FileName proc far

	call    CopyBasicSwap1FileName
	ret

FarCopyBasicSwap1FileName endp

FarCopyBasicSwap2FileName proc far

	call    CopyBasicSwap2FileName
	ret

FarCopyBasicSwap2FileName endp


;----------------------------------------------------------------------------;
; This routine invokes the error manager.                                    ;
;----------------------------------------------------------------------------;

ErrorHandler:
	
	call    ErrorManager            ;this never returns

;----------------------------------------------------------------------------;

sEnd    Code

end OldAppManager

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woainstd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file will hold all fuctions necessary for doing instance data         ;
; management.								     ;
;									     ;
; History:								     ;
;									     ;
;        Mon Sept-17-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created. (Added the History legend)      			     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include	njmp.mac
	include woaswapi.inc
	.list

;----------------------------------------------------------------------------;
; declare any public function or varaiable names here.			     ;
;----------------------------------------------------------------------------;


createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,StubSeg

;----------------------------------------------------------------------------;
; define structures and constants needed for the instance data calls.	     ;
;----------------------------------------------------------------------------;

Instance_Info_Struc STRUC

SIS_Version		db	3,0
SIS_Next_Dev_Ptr	dd	?
SIS_FILLER		db	8 dup (?)
SIS_Instance_Data_Ptr	dd	?

Instance_Info_Struc ENDS

Instance_Item_Struc STRUC

IIS_Ptr			dd	?
IIS_Size		dw	?

Instance_Item_Struc ENDS


;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;

 	externNP	SwitchAPICallIn		;(WOASWAPI.ASM)

;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
; define variables.							     ;
;----------------------------------------------------------------------------;

GlobalW	InstDataSeg,0			;segment for instance data management

InstDataBlockPtr	dd	?	;pointer to instance data block nodes

;----------------------------------------------------------------------------;
; GetSizeOfInstanceBuffer:						     ;
;									     ;
; This routine makes the 'InstanceData' INT 2Fh call and returns the size of ;
; the buffer that will be needed to hold all the instanece data. For each    ;
; block of instance data we will need an additional 6 bytes to store the     ;
; address and size of the block.				             ;
;									     ;
; Entry:								     ;
;	 None.								     ;
; Exit:									     ;
;	 AX - size in paras of buffer needed for instance data management.   ;
;	      (InstDataSeg reset to 0 if AX is retruned as 0).		     ;
; Uses:									     ;
;	 All but ES,DS,BP.						     ;
;----------------------------------------------------------------------------;

cProc	GetSizeOfInstanceBuffer,<NEAR,PUBLIC,PASCAL>,<es,bx,cx,dx,si,di>

cBegin

; set up registers for the int 2fh call.

	mov	ax,SWAPI_GET_INST_DATA	;code for the call
	xor	bx,bx			;need lots of zeros.
	mov	es,bx			;es:bx = 0:0
	mov	cx,cs			;cx:dx = call in address of ours.
	mov	dx,StubSegOFFSET SwitchAPICallIn
	int	2fh			;make the call.

; save the block address.

	mov	wptr [InstDataBlockPtr+2],es
	mov	wptr [InstDataBlockPtr],bx

; walk all the nodes and the instance data subnodes accumulating the node sizes
; remember we need an extra 6 bytes for each data block.

; Also note that the app's IDT will be saved as a part of this block. Set up
; AX to the size needed for the IDT area.

	mov	ax,SIZE Instance_Item_Struc + 256 * 4 

InstanceDataSizeMainLoop:

	mov	cx,es			;is the pointer 0 ?
	or	cx,bx
	jz	InstanceDataSizeObtained;yes, AX has the size.

; load the pointer to the instance data descriptor block.

	pushem	es,bx			;save
	les	bx,es:[bx.SIS_Instance_Data_Ptr]
	mov	cx,es			;is the pointer 0 ?
	or	cx,bx
	jz	NextInstBlockNode	;yes, go to the next block.

InstanceDataSizeSubLoop:

	mov	cx,wptr es:[bx.IIS_Ptr]	;is this the terminator ?
	or	cx,wptr es:[bx.IIS_Ptr.2]
	jz	NextInstBlockNode	;yes.

; accumulate the size.

	add	ax,es:[bx.IIS_Size]	;include the size
	add	ax,SIZE Instance_Item_Struc;for the header

; point ES:BX to the next node in the array.

	add	bx,SIZE Instance_Item_Struc
	jmp	short InstanceDataSizeSubLoop

NextInstBlockNode:

	popem	es,bx			;restore pointer to current node.
	les	bx,es:[bx.SIS_Next_Dev_Ptr]
	jmp	short InstanceDataSizeMainLoop

InstanceDataSizeObtained:

	add	ax,SIZE Instance_Item_Struc;for the terminator
	add	ax,15			;for para alignment
	shiftr	ax,4			;number of paras

GSOIB_Ret:

; AX has the para size of the buffer needed for instance data management.

cEnd
;----------------------------------------------------------------------------;
; GetInstanceDataSnapShot:						     ;
; 									     ;
; This routine prepares the InstanceData buffer by taking a snap shot of the ;
; buffer before starting up the app.					     ;
;									     ;
; The address of the buffer is InstDataSeg:0, and  InstanceDataBlockPtr is   ;
; assumed to still point to the linked list of Instance_Info structures.     ;
;									     ;
; Entry:								     ;
;	 InstDataSeg - valid segment.					     ;
;	 InstanceDataBlockPtr - points to linked list of Instance_Info blocks;
;									     ;
; Exit:									     ;
;	InstDataSeg - will have a snap shot of instance areas. Each instance ;
;		      area is preeceeded by a 4 byte address and a 2 byte    ;
;		      size.						     ;
;									     ;
; USES: all except ES,DS,BP.						     ;
;----------------------------------------------------------------------------;
cProc	GetInstanceDataSnapShot,<NEAR,PUBLIC,PASCAL>,<es>

cBegin
	
	push	ds			;save
	mov	es,InstDataSeg		;get the segment for the save area
	xor	di,di			;es:di points to save area.

; set up the first node for the IDT.

	xor	si,si			;IDT address = 0:0
	mov	wptr es:[di.IIS_Ptr],si	;set address to 0:0
	mov	wptr es:[di.IIS_Ptr.2],si
	mov	es:[di.IIS_Size],256*4	;size of IDT
	add	di,SIZE Instance_Item_Struc

; copy out the IDT.

	push	ds			;save
	assumes	ds,nothing
	mov	ds,si			;ds:si points to IDT start
	mov	cx,256*4/2		;number of words to copy
	cld				;set proper direction
	rep	movsw			;global IDT saved
	pop	ds			;restore
	assumes	ds,StubSeg

; now take snap shots of the other areas.

	lds	si,InstDataBlockPtr	;ds:si points to Instance_Info structure
	assumes	ds,nothing

GIDSS_MainLoop:

	mov	cx,ds			;is the pointer 0 ?
	or	cx,si
	jz	GIDSS_StoreTerminator	;yes we are done.

; load the pointer to the instance data descriptor block.

	pushem	ds,si			;save
	lds	si,[si.SIS_Instance_Data_Ptr]
	mov	cx,ds			;is the pointer 0 ?
	or	cx,si
	jz	GIDSS_NextInstBlockNode	;yes, go to the next block.

GIDSS_SubLoop:

; check for termination sub-node.

	mov	cx,wptr [si.IIS_Ptr]	;is this the terminator ?
	or	cx,wptr [si.IIS_Ptr.2]
	jz	GIDSS_NextInstBlockNode	;yes.

; copy the header part over.

	mov	cx,SIZE Instance_Item_Struc
	push	si			;save
	cld				;clear direction flag
	rep	movsb			;copy the header over
	pop	si			;back to the start

; copy the current block image.

	pushem	ds,si			;save
	mov	cx,[si.IIS_Size]	;size of the block.
	lds	si,[si.IIS_Ptr]		;address of the block.
	cld				;clear direction flag
	rep	movsb			;block is copied.
	popem	ds,si			;restore pointer to sub node

; point DS:SI to the next node in the array.

	add	si,SIZE Instance_Item_Struc
	jmp	short GIDSS_SubLoop

GIDSS_NextInstBlockNode:

	popem	ds,si			;restore pointer to current node.
	lds	si,[si.SIS_Next_Dev_Ptr]
	jmp	short GIDSS_MainLoop

GIDSS_StoreTerminator:

	xor	ax,ax			;for the terminator
	cld				;set proper direction.
	stosw				;first word of terminator
	stosw				;next word of terminator
	stosw				;for the size
	.errnz SIZE Instance_Item_Struc - 6

	pop	ds			;restore
	assumes	ds,StubSeg

GIDS_Ret:

cEnd
;----------------------------------------------------------------------------;
; SwapInstanceDataBlocks:						     ;
;									     ;
; This routine swaps the current contents of the instance data area with     ;
; what is saved in the local buffer.					     ;
;									     ;
; Entry:							             ;
;        InstDataSeg - has a copy of the saved instance area with each block ;
;		       of data being preeceeded by 4 bytes of address and a  ;
;		       word of size.					     ;
; Exit:									     ;
;	 Swaps the current and saved copies of instance data areas.	     ;
;									     ;
; Uses:  all but ES,DS,BP. Interrupts disabled during the Swap.	     	     ;
;----------------------------------------------------------------------------;
cProc	SwapInstanceDataBlocks,<NEAR,PUBLIC,PASCAL>,<es>

cBegin

	cmp	InstDataSeg,0		;any instance data area ?
	jz	SIDB_Ret		;no.

	pushf				;save interrupt flag bit
	cli				;trun off interrupts.
	push	ds			;save
	mov	si,InstDataSeg		;address of saved buffer
	mov	ds,si
	assumes	ds,nothing
	xor	si,si			;DS:SI points to start of saved area

SIDB_NodeWalkLoop:

	les	di,[si.IIS_Ptr]		;pointer to first data area

; test for termination.	For termination all the bytes in the header must be
; 0 since we include the IDT as a part of the swap area.

	mov	cx,es			;is es:bx 0:0 & size = 0?
	or	cx,di
	or	cx,[si.IIS_Size]
	jz	SIDB_SwapDone		;yes, we are done.

; swap the block.

	mov	cx,[si.IIS_Size]	;get the size of the block

; position DS:SI to the start of the current saved area

	add	si,SIZE Instance_Item_Struc

SIDB_SwapLoop:

	mov	al,[si]			;get a byte
	xchg	es:[di],al		;swap the saved copy
	mov	[si],al			;restore the saved copy
	inc	si			;next byte in source
	inc	di			;next byte in destination
	loop	SIDB_SwapLoop		;swap the complete block

; progress to the next block. DS:SI is already pointing to the header of the
; next instance block.

	jmp	short SIDB_NodeWalkLoop	;continue

SIDB_SwapDone:

	pop	ds			;restore
	assumes	ds,StubSeg
	popf				;restore saved interrupt state

SIDB_Ret:

cEnd
;----------------------------------------------------------------------------;

sEnd StubSeg
end


	





	





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woamouse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This module contains routines realated to saving and restoring of the mouse;
; context.      							     ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Wed Dec-20-1989.       -by-  Amit Chatterjee [amitc]		     ;
;        Put in support for Mouse System's Version 5+ Mouse drivers.	     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend) 		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	woahpeqs.inc
	include	njmp.mac
	include macros.mac
	include	woahp.inc
	.list

	.286p

		public	MouseSeg

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,StubSeg


;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;


		externNP	IsVectra		;(WOAHP.ASM)
		externNP	SaveData		;(WOAHP.ASM)
		externNP	RestoreData		;(WOAHP.ASM)
		externNP	SaveLinkMapping		;(WOAHP.ASM)
		externNP	RestoreLinkMapping	;(WOAHP.ASM)

;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;

externB		fVectra			;tells us whether m/c is a vectra

;----------------------------------------------------------------------------;
; define constants related to various mices.				     ;
;----------------------------------------------------------------------------;

HPMOUSE_SIZE	= 0A0H
TRACK_SIZE	= 280H

; Equates for EX-BIOS interrupt number and vector address.
HPENTRY 		equ	6FH
F_HPENTRY		equ	HPENTRY
HP_ID			equ	4850H	;'HP'

V_STRACK		equ	005AH	; Common cursor control funcs.
V_LHPMOUSE		equ	00CCH	; Microsoft/Mouse System's
					;   Compatible Driver
F33_INQUIRE		equ	6F00H	; HP inquire function
F_IO_CONTROL		equ	02H*2	; Device/Driver Dependent
					;   Functions

;----------------------------------------------------------------------------;
; define the mouse state related variables.				     ;
;----------------------------------------------------------------------------;

MouseType		db	0	;type of mouse
					; 1 => Microsoft version 4
MouseSize		dw	?	;size of MsMouse
MouseSeg		dw	?	;segment where mouse state is saved
MouseStateSize		dw	?	;size in para of mouse state
AppMouseX		dw	?	;save switch out x value
AppMouseY		dw	?	;save switch out y value
MouseVector		dd	?	;INT 33 vector
pRestoreMouse		dw	iqRet	     
pSaveMouse		dw	iqRet	     
HPMouseSize		dw	HPMOUSE_SIZE 
TrackSize		dw	TRACK_SIZE   

;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; EnableMouse:								     ;
;									     ;
; This routine enables the mouse driver.  				     ;
;----------------------------------------------------------------------------;

cProc	EnableMouse,<NEAR,PUBLIC,PASCAL>

cBegin

	cmp	MouseType,1		;MS mouse ?
	jnz	@f			;no.
	mov	ax,20h			;enable mouse code
	int	33h
@@:

cEnd
;----------------------------------------------------------------------------;
; DisableMouse:								     ;
;									     ;
; This routine disables the mouse driver. 				     ;
;----------------------------------------------------------------------------;

cProc	DisableMouse,<NEAR,PUBLIC,PASCAL>

cBegin

	cmp	MouseType,1		;MS Mouse
	jnz	@f			;no
	mov	ax,1fh			;disable mouse code
	int	33h
@@:

cEnd
;----------------------------------------------------------------------------;
; GetMouseStateSize:							     ;
;								             ;
; Gets the size of the buffer needed to save the mouse state if there is a   ;
; mouse driver installed.						     ;
;									     ;
;	The mouse driver compatiblity is searched in the following order:    ;
;									     ;
;		New Microsoft Mouse (4.0+)				     ;
;		New PC Mouse (5.0+)					     ;
;		ATT (Logitech)						     ;
;		Rom HP Mouse (A.01.02)					     ;
;		Ram HP Mouse (Patch versions)				     ;
;		Old Microsoft Mouse					     ;
;----------------------------------------------------------------------------;

cProc	GetMouseStateSize,<NEAR,PUBLIC,PASCAL>,<bp,ds,si,di>

	localV	link,32			;for vectra link mapping saving

cBegin

	assumes	cs,StubSeg
	assumes	ds,StubSeg
	assumes	es,nothing


; Is a INT 33 mouse driver there?

	xor	ax,ax			;Look in INT table for a vector
	mov	es,ax			;es has IDT seg
	les	bx, es:[33h*4]	    	;load INT 33 vector
	mov	word ptr cs:[MouseVector], bx 
	mov	word ptr cs:[MouseVector+2], es
	mov	cx,es			;check for null vector
	or	cx,bx		    	;is it NULL ?
	jz	imLExit 		;int 33 vector not stuffed, so no mouse
	cmp	byte ptr es:[bx], 0CFh	;make sure it is not an IRET
	jne	imIsMouse		;there is a mouse
imLExit:
	xor	ax,ax			;no mouse
	mov	MouseStateSize,ax	;save null size
	jmp	imExit			;return back


; There is a mouse driver.

imIsMouse:

; Vectras need there link mapping saved and restored by this function

	push	ss			;temp save area on stack
	pop	es
	lea	di, link		;es:di points to save are
	call	SaveLinkMapping 	;This func has no effect on non vectra

; Is this a Vectra? If so, Is this the wonderfull ROM mouse driver?

imRomHPMouse:

	call	IsVectra		; Is this a Vectra?
	jz	imNewMouse		;No, Can't be a HP Mouse
	mov	bx, word ptr cs:[MouseVector+2]
	cmp	bx, 0F000H		;Does Int 33 point to ROM
	jne	imRamHPMouse		;No, it might be a RAM HP Mouse
	jmp	short imHPDef		;it is a ROM based HP mouse

; Is this patch version of the HP Mouse which is ram based ?
; Notice that I don't make this call with ROM mouse drivers
; because the first ROM mouse driver barfs on this call. Great Code!

imRamHPMouse:

	xor	bx, bx			;Does this ID as an HP mouse?
	mov	AX, F33_INQUIRE 	;do the inquire
	int	33H			
	cmp	BX, 'HP'                ;HP ID Code (new version) ?
	jne	imNewMouse		;check for new mouse

; HPMOUSE:  Inquire LHPMOUSE to get the HPmouse and TRACK sizes

imHPSize:

	mov	AX, F_IO_CONTROL SHL 8 + SF_MOUSE_DSIZE
	mov	bp, V_LHPMOUSE
	int	6fh

; Returns:
;  AH=  RS_UNSUPPORTED - Use defaults
;  AH=  RS_SUCCESSFUL
;       BH= HPMOUSE size in paras
;       BL= TRACK size in paras

	cmp	ah, 0			;valid return ?
	jne	imHPDef 		;No, use default size
	mov	al, bh			;convert size in bytes and save
	mov	cl, 4			
	shl	al, cl
	mov	HPmouseSize, ax		;save size
	xor	bh, bh			;deal with tracksize in same way
	shl	bx, cl
	mov	TrackSize, bx		;save track size in bytes

imHPDef:

	mov	ax, cs:[HPMouseSize]   	;size of the mouse state
	add	ax, cs:[TrackSize]	;add track size
	mov	MouseSize,ax		;total mouse size in bytes

; save the address of the routines to do the save and restore

	mov	pSaveMouse, StubSegOFFSET SaveHPMouse
	mov	pRestoreMouse, StubSegOFFSET RestoreHPMouse
	jmp	imRestore	        ;done with HP mouse

; Now we know that the mouse is not a microsoft mouse.

; Does it support Microsoft's function 21?
;
;	If so, its Microsoft Mouse version 4.0+ compatible.
;	This is prefered method of saving the mouse state.

imNewMouse:

	mov	ax, 21			;check to see if this is supported
	xor	bx, bx			;zero out return value first
	int	33h
	cmp	bx, 0			;if 0 then 21 is not supported
	je	imPCMouse		;must be PC mouse

; we have a version 4.0 int 33 interface mouse. Save the address of the save
; and restore state routines and the mouse size

	mov	MouseType,1		;new mouse
	mov	pSaveMouse, StubSegOFFSET SaveNewMouse
	mov	pRestoreMouse, StubSegOFFSET RestoreNewMouse
	mov	MouseSize,bx		;save size of save area
	jmp	short imRestore		;done with new mouse



; now we need to see whether this is mouse systems mouse or not.

; Does it support Mouse System's function B
;	If so, it's Mouse System version 5.0+ compatible

imPCMouse:
					
	mov	ax, 'B'			;MS Mouse supports this
	xor	bx, bx			;zero out return value before call
	int	33h
	cmp	bx, 0			;if 0 then not MS Mouse
	je	imATTMouse		;could be ATT keyboard mouse

; This is a mouse systems mouse. So save the addresses of the appropriate
; routines for saving and restoring state

	mov	pSaveMouse, StubSegOFFSET SavePCMouse
	mov	pRestoreMouse,StubSegOFFSET RestorePCMouse
	mov	MouseSize,bx		;save the size
	jmp	short imRestore		;done with Mouse Systems mouse

; Now check to see if this is an ATT mouse driver.

imATTMouse:

	les	bx,MouseVector		;get the segment for the mouse vector
	cmp	es:[bx+10h],'OL'        ;see if logitech there
	jne	imOldMouse		;no. Must be old mouse
	mov	ax, '.1'                ;Further check requested by
	cmp	es:[bx+27h], ax 	; Bill Hall
	je	imFoundATT		;yes logitech mouse
	cmp	es:[bx+28h], ax 	;last test
	jne	imOldMouse		;not logitech. Must be old mouse

imFoundATT:

	mov	ax,es:[101h]		;Yes, calculate the save area
	add	ax,103h 		;relative jmp + len of psp + 3 =
	                                ;dist to blowaway code
	mov	MouseSize,ax	;save it

; save the address of the save restore routines

	mov	pSaveMouse,StubSegOFFSET SaveATTMouse
	mov	cs:[pRestoreMouse],StubSegOFFSET RestoreATTMouse
	jmp	short imRestore     		;done with logitech mouse


; Is this an old Microsoft Mouse driver 2.0 or less

imOldMouse:

	mov	MouseSize,0		;initialize
	mov	ax,'M'	  		;test for version 2 mouse driver
	int	33h
	cmp	word ptr es:[di],'oC'   ;Does secret mouse call point at
					;copyright message?
	jne	imExit			;No, no mouse present.

; save address of save/restore routines for old mouse

	mov	pSaveMouse, StubSegOFFSET SaveOldMouse
	mov	pRestoreMouse, StubSegOFFSET RestoreOldMouse
	mov	ax, word ptr MouseVector
	mov	MouseSize, ax
	errn$	imRestore

; Restore Vectra's HP-HIL mapping

imRestore:

	push	ss
	pop	es		       	
	lea	di, link		;es:di points to the saved state	
	call	RestoreLinkMapping 	;This func has no effect on non vectra

imExit:

; return with the size of the state in paragraphs

	mov	ax,MouseSize		;get the size
	shiftr	ax,4			;get it in paragraphs
	inc	ax			;round it up.
	test	fVectra,1		;is it a vectra
	jz	@f			;no
	add	ax,2			;for saving link mapping
@@:


cEnd	GetMouseState
;----------------------------------------------------------------------------;
; SaveMouseState:							     ;
;	     Save the state of the INT 33 driver       			     ;
;----------------------------------------------------------------------------;

cProc	SaveMouseState, <NEAR,PUBLIC,PASCAL>, <ES,DS,SI,DI>				     

cBegin	     

	assumes	cs,StubSeg
	assumes	ds,StubSeg
	assumes	es,nothing

	mov	cx,MouseSeg			  
	jcxz	smsx			;noting to save
	mov	es, cx			;get the mouse save state segment


; If this is a Vectra the link mapping needs to be saved.		     

	test	cs:[fVectra], 1		;is it a Vectra ?				     
	jz	smNotVectra		;no.				     
	xor	di, di			;Save the link mapping		     
	call	SaveLinkMapping 	;This func has no effect on non vectra
	mov	bx, es			;the mouse save area is next	     
	add	bx,2			;add 2 for the link mapping area				     
	mov	es,bx			;mouse state will be saved here							     

smNotVectra:

	mov	cx, cs:[MouseSize] 	;get the size of the mouse
	call	cs:[pSaveMouse]		;save the state

; Put the mouse in the default state with cursor hidden.

; This done so that when we start up another app the it
; will not have the cursor displayed initially.

	xor	ax, ax		       	;initialize mouse
	int	33h

smsx:
cEnd
;----------------------------------------------------------------------------;
; RestoreMouseState:							     ;
;									     ;
; Restores the state of the mouse.					     ;
;----------------------------------------------------------------------------;

cProc	RestoreMouseState, <NEAR,PUBLIC,PASCAL>, <ES,DS,SI,DI>

cBegin

	assumes	cs,StubSeg
	assumes	ds,StubSeg
	assumes	es,nothing


	mov	cx, MouseSeg		;get the segment for the save area
	jcxz	rmx		      	;no save area

; If this is a Vectra the link mapping must be restored. However
; the mouse must restored first because this operation will
; destroy the link mapping.

	test	fVectra,1 		;Is this a Vectra?
	jz	rmCall			;no.
	push	cx			;Save
	add	cx,2			;get to the save area for mouse state

rmCall:

	mov	es,cx			;points to mouse save area
	mov	cx,MouseSize		;get the size in bytes
	push	ds			;save DS for RestoreLinkMapping
	call	pRestoreMouse		;restore the mouse state
	pop	ds

; Restore the link mapping

	test	fVectra,1		;is this a vectra
	jz	rmx		     	;no
	pop	es			;get back start of segment
	xor	di, di			;es:di points to save area
	call	RestoreLinkMapping 	;This func has no effect on non vectra

rmx:

cEnd
;----------------------------------------------------------------------------;
;									     ;
; SaveNewMouse - Save the new mouse state using the function 22 code	     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;									     ;
; Exit									     ;
;	MouseSeg is updated						     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

SaveNewMouse:

	mov	ax, 22			;save code
	jmp	short nmsEntry		;Use the RestoreNewMouse code


;----------------------------------------------------------------------------;
; RestoreNewMouse - Restore the new mouse state using the function 23 code.  ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state restored					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;	     

RestoreNewMouse:	  

	xor	ax, ax
	int	33h			;reset the mouse
	mov	ax, 23			;restore mouse code

nmsEntry:

	xor	dx,dx			;es:dx has the save/restore area
	int	33h			;save/restore mouse state

iqret:
	ret				;done

;----------------------------------------------------------------------------;
; SavePCMouse - Save the PC mouse state using the P function.		     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	MouseSeg is updated						     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

SavePCMouse:

	mov	ax, 'P'
	jmp	short pmsEntry		; Use the RestorePCMouse code

;----------------------------------------------------------------------------;
; RestorePCMouse - Restore the PC Mouse state using the R function.	     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state restored					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

RestorePCMouse:

	mov	ax, 'R'

pmsEntry:

	mov	bx, cx
	xor	dx, dx
	int	33h
	ret

;----------------------------------------------------------------------------;
; SaveATTMouse								     ;
;									     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	MouseSeg is updated						     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

SaveATTMouse:

	mov	ax,2			;hide cursor
	int	33h			
	jmp	SaveOldMouse

;----------------------------------------------------------------------------;
; RestoreATTMouse							     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state restored					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

RestoreATTMouse:

	mov	ax, es
	mov	ds, ax
	mov	es, word ptr cs:[MouseVector+2] ; Dest is mouse driver
	call	MoveMouse	; Blat it in
	xor	cx,cx
	xor	dx,dx
	xor	si,si
	xor	di,di
	mov	ax,16		; show mouse cursor if it was on
	int	33H
	mov	ax,32		;; get mode we left it in
	int	33h
	mov	ax,33		;; set the mode
	int	33h
	call	MoveMouse
	mov	ax,1		;; restore the cursor
	int	33h
	ret

;----------------------------------------------------------------------------;
; SaveHPMouse - Save the HPMouse state by copying its data area.	     ;
;									     ;
;	The HP Mouse has two data areas V_LHPMOUSE and V_STRACK.	     ;
;	See the "HP Vectra Techinical Reference Manual" for details.	     ;
;	A new HP-HIL Mouse Microsoft Mouse driver has been released	     ;
;	by HP which was written by Microsoft. The NewHPMouse code	     ;
;	is used for this driver.					     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state is saved					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

SaveHPMouse:

	EnterCrit
	xor	di, di			; MOUSE must be first
	mov	ax, V_LHPMOUSE
	mov	si, cs:[HPMouseSize]
	cCall	SaveData, <ax, di, si, di> ; Vector, start, end, loc
	add	di, si			; Save TRACK
	mov	ax, V_STRACK
	mov	si, cs:[TrackSize]
	xor	dx,dx
	cCall	SaveData, <ax, dx, si, di>
	LeaveCrit

	push	ax		   	;save
	mov	ax, 2			;hide the cursor
	int	33h
	pop	ax			;restore
	ret

;----------------------------------------------------------------------------;
; RestoreHPMouse							     ;
;									     ;
;	The HP Mouse has two data areas V_LHPMOUSE and V_STRACK.	     ;
;	See the "HP Vectra Techinical Reference Manual" for details.	     ;
;	A new HP-HIL Mouse Microsoft Mouse driver has been released	     ;
;	by HP which was written by Microsoft. The NewHPMouse code	     ;
;	is used for this driver.					     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state is restored				     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

RestoreHPMouse:

	xor	ax, ax
	int	33h
	EnterCrit
	xor	di, di			; MOUSE is always first
	mov	ax, es
	mov	ds, ax
	mov	ax, V_LHPMOUSE
	mov	si, cs:[HPMouseSize]
	cCall	RestoreData, <ax, di, si, di>; Vector, start, end, loc
	add	di, si			; Restore TRACK
	mov	ax, V_STRACK
	mov	si, cs:[TrackSize]
	xor	dx,dx
	cCall	RestoreData, <ax, dx, si, di>
	LeaveCrit
	ret

;----------------------------------------------------------------------------; 
;									     ;
; SaveOldMouse - Save the mouse state by copying the data area		     ;
;									     ;
;	As a freak of nature, old Microsoft mouse drivers stored	     ;
;	there data from CS:0 to CS:Entry. This allows us		     ;
;	to save the data area even though there are now explicit	     ;
;	calls to save it. However, not all the state might be		     ;
;	there.								     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state is saved					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

SaveOldMouse:

	mov	ds,word ptr cs:[MouseVector+2]	; Source is mouse driver seg
	call	MoveMouse		;
	ret

;----------------------------------------------------------------------------;
;									     ;
; RestoreOldMouse - Restore the old mouse data area.			     ;
;									     ;
;	As a freak of nature, old Microsoft mouse drivers stored	     ;
;	there data from CS:0 to CS:Entry. This allows us		     ;
;	to save the data area even though there are now explicit	     ;
;	calls to save it. However, not all the state might be		     ;
;	there.								     ;
;									     ;
; Entry									     ;
;	ES:0 - mouse segment						     ;
;	CX   - Mouse size						     ;
;									     ;
; Exit									     ;
;	The mouse driver state is saved					     ;
;									     ;
; Uses									     ;
;	AX,BX,CX,DX,SI,DI,ES,DS						     ;
;----------------------------------------------------------------------------;

RestoreOldMouse:

	mov	ax, es
	mov	ds, ax
	mov	es, word ptr cs:[MouseVector+2] ; Dest is mouse driver
	call	MoveMouse	; Blat it in
	xor	cx,cx
	xor	dx,dx
	xor	si,si
	xor	di,di
	mov	ax,16		; show mouse cursor if it was on
	int	33H
	errn$	MoveMouse	; RestoreMouse falls into MoveMouse

;----------------------------------------------------------------------------; 
;									     ;
; MoveMouse - Transfer MouseSize bytes of mouse area			     ;
;									     ;
; ENTRY:								     ;
;	DS:0 -> Source of mouse area					     ; 
;	ES:0 -> Dest of mouse area					     ;
;	MouseSize is set						     ;
;									     ;
; EXIT:									     ;
;	Mouse area moved						     ;
;									     ;
; USES:									     ;
;	DI,SI,CX,DS,FLAGS						     ;
;----------------------------------------------------------------------------;

MoveMouse:

	cld
	xor	di,di
	xor	si,si
	mov	cx, cs:[MouseSize]
	shr	cx,1
	EnterCrit			; No Mouse INTs while copying
	rep	movsw
	LeaveCrit
	ret
;----------------------------------------------------------------------------;
sEnd	StubSeg

end
	



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woapif.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */



; flags for pifBehavior.

fNoSwitch	equ	00000001b
fGraphics	equ	00000010b
fDestroy	equ	00000100b

; define a flag which says grabber will not need to be loaded, based on
; above flags.

fNoGrabber	equ	00000001b	;fNoGrab + fNoSwitch


; the hot key disabled flags

fNoAltTab	equ	00000001b
fNoAltEsc	equ	00000010b
fNoCtrlEsc	equ	00000100b
fNoAlt		equ	00000011b
fSwitchDisabled equ	00000111b

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woasegs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; defines the exact segment ordering that we want to have. It is very very   ;
; important that the StubSegment occurs at the end.			     ;
;----------------------------------------------------------------------------;

 createSeg _DATA,Data,word,public,DATA,DGROUP
 defgrp DGROUP,Data
 createSeg _TEXT,Code,word,public,Code
 createSeg _WOARLMSEG,StubSeg,word,public,Code

;----------------------------------------------------------------------------;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woapmrm.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file has code which is differnt for real and protected modes and has  ;
; proper ifdefs.							     ;
;								             ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Fri June-30-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)      		     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include	njmp.mac
	include	woaerr.inc
	include	woaarena.inc
	.list

	.286p

;----------------------------------------------------------------------------;
; define all public names of functions and variables here.		     ;
;----------------------------------------------------------------------------;

	public	GetAppXmsBase
	public	EmergencyExit
	public	SetSelectorBaseLim64
	public	GetSelectorBase

;----------------------------------------------------------------------------;
; declare  the external function calls.     				     ;
;----------------------------------------------------------------------------;



;----------------------------------------------------------------------------;

sBegin	Data

;----------------------------------------------------------------------------;
; define the global variables defined elsewhere			       	     ;
;----------------------------------------------------------------------------;

externW WoaCsSize			;size of protected mode code seg
externW WoaDsSize			;size of winoldap data segment
externW StubSegSize			;size of real mode stub segment
externW	LowMemArenaSel			;selector/seg for low heap arena
externW	ArenaWalkSel			;temp selector for walkimg arena chain
externW	ArenaRWSel			;temp sel for reading/writing arenas
externW WoaStubSel			;selector for stub code segment
externW XmsHeapWalkSel			;used for walking xms heap
externW	LowMemParaSize			;size of low heap in paragraphs
externD	XmsBankSize			;size of XMS to be allocated
externB ErrorType			;save area for error code
externW	SegResizeBlock			;block to resize in real mode
externW	SizeReservedArea		;size of area reserved area at heap st.
externD SwapFileOffset			;lseek offset for swap in/out
externW	UsableLowHeapSel		;sel/seg for reusable part of low heap
externW LowMemSel			;sel for available mem
externB	WinSaveXms			;if ff, XMS to be saved at win swap out
externW	HighMemXmsHandle		;handle of the high heap XMS block
externW AppXmsBaseSel			;selector for apps XMS base.
externW	AppUsesXMS			;app used XMS allocated to it or not
externB NodeToSwitchTo			;node that we want to switch to

; declare the storage for the registers needed to communicate with the stub.

externW	RealMode_AX			;space for AX
externW	RealMode_BX			;space for BX
externW	RealMode_CS			;space for CS
externW	RealMode_DS			;space for DS
externW	RealMode_ES			;space for ES
externW	RealMode_IP			;space for IP

	;-------------------------------------------------------;
	; define any locally used constants			;
	;-------------------------------------------------------;


	;-------------------------------------------------------;
	; define any external contants.				;
	;-------------------------------------------------------;


;---------------------------------------------------------------------------;
; now define the other variables that will be needed.			    ;
;---------------------------------------------------------------------------;

		public	lpXmsControl
		public	SegAfterReservedArea

lpStubEntry		dd	?  	;call gate for stub code
SegAfterReservedArea	dw	?	;segment after the reserved area
SwapHandle		dw	?	;temporary space
lpXmsControl		dd	?	;XMS control function address

;----------------------------------------------------------------------------;

sEnd Data

;----------------------------------------------------------------------------;
; now declare the existence of the realmode stub segment and the variables   ;
; that we want to reference here.					     ;
;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

externB XmsStartLine			;start of XMS handler in real mode stub

sEnd	StubSeg

;----------------------------------------------------------------------------;
sBegin	Code

	assumes	cs,Code
	assumes	ds,Data
	assumes	es,nothing

;----------------------------------------------------------------------------;
; declare the external winoldap functions used here.			     ;
;----------------------------------------------------------------------------;

	externNP ErrorManager		;(WOAERR.ASM)
	externNP MoveWOA		;(WOAMGR.ASM)
	externNP LoadRealModeStub	;(WOAMGR.ASM)
	externNP CreateFile		;(WOAMGR.ASM)
	externNP OpnFile		;(WOAFILE.ASM)
	externNP ReadFile		;(WOAFILE.ASM)
	externNP WriteFile		;(WOAFILE.ASM)
	externNP LseekFile		;(WOAFILE.ASM)
	externNP CloseFile		;(WOAFILE.ASM)
	externNP DeleteFile		;(WOAPMRM.ASM)
	externNP SetNormalAttributes	;(WOAFILE.ASM)
	externNP SetHiddenAttributes	;(WOAFILE.ASM)
	externNP GetSizeInBytes		;(WOAUTILS.ASM)
	externNP RestoreSwappedGroups   ;(WOAUTILS.ASM)
	externNP IsEnoughDiskSpace	;(WOAUTILS.ASM)
	externNP SwapOutNonZeroBlocks	;(WOAUTILS.ASM)


;----------------------------------------------------------------------------;
; SaveFirstDosBlock:						             ;
;									     ;
; This routine is invoked to copy out the first arena header to the swap     ;
; file and to skip over the _DATA and _TEXT segment.			     ;
; If SFDBOpCode is 0 this will not write anything to disk. The size of the   ;
; swap area will be returned in CX:DX and the size of the skipped part in AX.;
;----------------------------------------------------------------------------;

cProc	SaveFirstDosBlock,<NEAR,PASCAL,PUBLIC>,<es>

	parmW	FileHandle		;handle of the swap file
	parmB	SFDBOpCode		;get size only or save

cBegin

	cld				;do not take chances with this
	mov	es,LowMemArenaSel	;get the selector for the arena

; if the OpCide is for get size only, then bypass the File IO

	cmp	SFDBOpCode,0		;get size only ?
	jz	SFDBByPassIO1		;yes

; first swap out the arena.

	xor	ax,ax			;need for hiword of count and for offset
	mov	cx,16			;16 bytes of arena header
	save	<es>			;need to save this
	cCall	WriteFile,<FileHandle,es,ax,ax,cx>
	jc	SaveFirstBlockRet	;will not continue with error

SFDBByPassIO1:

; now calculate the part that will be skipped over - the portion between
; LowMemSel and _WOARLMSEG.

	mov	ax,_WOARLMSEG		;start of stub segment
	sub	ax,LowMemSel		;start of the first block
	xor	cx,cx			;size written out to be in CX:DX
	mov	dx,16			;we just wrote out the arena

SaveFirstBlockRet:

cEnd
;----------------------------------------------------------------------------;
; RestoreFirstDosBlock:							     ;
;									     ;
; This routine restore the arena of the first block from the swap file.      ;
;----------------------------------------------------------------------------;

cProc	RestoreFirstDosBlock,<NEAR,PUBLIC,PASCAL>,<es>

	parmW	FileHandle		;handle of the swap file

cBegin

	cld				;do not take chances with this

; read in the arena header.

	xor	ax,ax			;nedd for hiword of count and for offset
	mov	es,LowMemArenaSel	;get the selector for the arena
	mov	cx,16			;16 bytes of arena header
	save	<es>			;need to save this
	cCall	ReadFile,<FileHandle,es,ax,ax,cx>

cEnd
;----------------------------------------------------------------------------;
; RestoreSwap
;----------------------------------------------------------------------------;
; SaveAppXmsContext:							     ;
;									     ;
; This routine takes a file handle as a parameter and saves the apps XMS     ;
; context from the current location in the file. The context is saved as a   ;
; 4 byte size followed by the actual XMS block if the size is non zero.      ;
;----------------------------------------------------------------------------;

cProc	SaveAppXmsContext,<NEAR,PUBLIC,PASCAL>,<es,si,di>

	parmW	FileHandle		;handle of the dos swap file

cBegin

	cld				;do not take chances with this

; irrespective of whether size is 0 or not, we need to save the size at least

	mov	dx,wptr [XmsBankSize]	;get low word of size
	mov	cx,wptr [XmsBankSize+2]	;get high word of size

; swap out the size and the XMS block to the disk if size is not zero, else
; just write the size into the swap file.

	cCall	RMSwapOutXmsBlock,<FileHandle,cx,dx>

SaveAppXmsContextRet:

cEnd
;----------------------------------------------------------------------------;
; RestoreAppXmsContext: 						     ;
;									     ;
; Restores the apps xms context. This routine takes a file handle as a param-;
; -eter and the 4 bytes at the current position of the file is the size of   ;
; the XMS memory allocated to the app. If the size is non zero, the current  ;
; contents of the XMS area must be saved into the XMS swap file before       ;
; restoring the apps XMS memory.       					     ;
;									     ;
; A very important point to note here is that, at this point the app that we ;
; are trying to restore may not have been loaded by this instance of winoldap;
; So the value of 'XmsBankSize' that we need for restoring is not a property ;
; of the app we are trying to restore. We will reset the value of the        ;
; variable from the value stored in the old apps file.			     ;
;----------------------------------------------------------------------------;

cProc	RestoreAppXmsContext,<NEAR,PUBLIC,PASCAL>,<es,si,di>

	parmW	FileHandle		;handle of the swap file

	localD	TempBuffer		;will read in size of xms block here
	localD	lpSwapFile		;name of the swap file (ptr to it)

cBegin

	cld				;do not take chances with this

; read in the 'AppUsesXMS' field.

	mov	di,DataOFFSET AppUsesXMS;will read in here directly
	xor	ax,ax			;hiword of count is 0
	mov	bx,2			;need to read 2 bytes 
	cCall	ReadFile,<FileHandle,ds,di,ax,bx>
	jc	RestoreAppXmsContextRet	;cannot procedd with error

; read in the 4 byte XMS memory size

	smov	es,ss			;temp buffer is in stack
	lea	di,TempBuffer		;es:di points to buffer
	xor	ax,ax			;hiword of count is 0
	mov	bx,4			;need to read 4 bytes (loword of count)
	cCall	ReadFile,<FileHandle,es,di,ax,bx>
	jc	RestoreAppXmsContextRet	;cannot procedd with error

; test to see if the size of XMS memory is zero or not.

	mov	cx,seg_TempBuffer	;get the high word
	mov	dx,off_TempBuffer	;get the low word

; reset 'XmsBankSize', we will need it to be what is in cx:dx when we finally
; need to save the apps context

	mov	wptr [XmsBankSize+2],cx	;save the high word
	mov	wptr [XmsBankSize],dx	;save the low word

; test to see whether there is at all any context to restore

	mov	ax,cx
	or	ax,dx			;is the memory block size 0 ?
	jz	RestoreAppXmsContextRet	;yes, there is no context to restore.

; test to see if 'AppUsesXMS' is zero, if so then there will be no XMS to 
; swap in.

	cmp	AppUsesXMS,0		;did it use XMS ?
	jz	RestoreAppXmsContextRet	;no, there is no context to restore.

; now swap in the dos xms context from the dos app swap file.

	xor	ax,ax			;opcode = 0 => read from file
	cCall	RMSwapInXmsBlock,<FileHandle,TempBuffer,ax>

RestoreAppXmsContextRet:

cEnd
;----------------------------------------------------------------------------;
; RMSwapOutXmsBlock:							     ;
;									     ;
; Given a file handle and a dword worth of block size, this routine swap the ;
; xms block image preceeded by the size into the file.			     ;
;									     ;
; (This code works in real mode only, where the XMS memory is not directly   ;
;  accessible and has to be moved into conventional memory before swapping   ;
;  out. However it has been ensured that the portion of conventional memory  ;
;  not holding the winoldap stub is free at this point).		     ;
;									     ;
; We will read in chunks of extended memory into conventional memory and for ;
; the chunk read in we will write out the non zero blocks using our general  ;
; swap out routine.							     ;
;----------------------------------------------------------------------------;

cProc	RMSwapOutXmsBlock,<NEAR,PUBLIC,PASCAL>

	parmW	FileHandle		;handle of the file
	parmD	BankSize		;size of the bank

	localD	lpXmsInvoke		;xms entry function address
	localV	RMXOHeader,8		;to write out node header
	localV	XmsMoveStruct,16	;the move parameter block.
	localW	SegForXmsXfer		;seg to be used for move

cBegin

	cld				;do not take chances with this

; save  the 'AppUsesXms' variable. This will govern whether we swap out
; actual XMS or not.

	mov	ax,2			;want to write 2 bytes
	xor	cx,cx			;high word of count is 0
	mov	si,DataOFFSET AppUsesXMS;ds:si points to size
	cCall	WriteFile,<FileHandle,ds,si,cx,ax>
	njc	RMSwapOutXmsBlockRet	;cannot proceed with error

; save the length of the block
	
	mov	ax,4			;want to write 4 bytes
	xor	cx,cx			;high word of count is 0
	lea	si,BankSize		;ss:si points to size
	cCall	WriteFile,<FileHandle,ss,si,cx,ax>
	njc	RMSwapOutXmsBlockRet	;cannot proceed with error

; if the block size is 0, we do not have to write it out

	mov	si,seg_BankSize		;load the high word
	or	si,off_BankSize		;is the size 0 ?
	njz 	RMSwapOutXmsBlockRet	;return

; if 'AppUsesXMS' is 0 we do not have to write XMS out.

	cmp	AppUsesXMS,0		;did it use XMS ?
	njz 	RMSwapOutXmsBlockRet	;return

; the following code can destroy the DOS memory arena chain currently
; within the low heap area.  It's not safe to make DOS calls with the arena
; list in an inconstant state, so we zap the low heap arena to indicate it's
; the end of the list.	This was found when running SHARE.EXE under DOS
; 4.0.	When doing a set file attribute Int 21h shortly after this
; routine executes, SHARE would hang trying to walk the arena list.  Another
; routine will restore the Low heap arena in a little while.

	mov	es,LowMemArenaSel
	mov	bptr es:[0],'Z'

; now calculate the amount of bytes of reusable low heap area. We will use the
; area from the start of the StubSeg on.

	mov	ax,_WOARLMSEG		;start of stub seg (swapped out)
	mov	SegForXmsXfer,ax	;will use for XMS transfer
	sub	ax,LowMemSel		;amount of reserved area (CS + DS)
	neg	ax			;want to subtract it from -
	add	ax,LowMemParaSize	;- the total low heap size
	call	GetSizeInBytes		;AX:BX has the size in bytes
	and	bx,0fff0h		;make it para multiple

; (note that we have just made the size of conventional memory that we can
;  use for the move to be a multiple of para size and the amount of xms that
;  we want to swap out is also a multiple of a para size.)

; now initialize the xms move structure.

	smov	es,ss			;will have structure built in stack
	lea	si,XmsMoveStruct	;the move structure
	mov	cx,HighMemXmsHandle	;the source handle
	mov	es:[si+4],cx		;save the source handle
	xor	cx,cx			;source offset will start at zero.
	mov	es:[si+6],cx		;low word of source offset
	mov	es:[si+8],cx		;high word of source offset
	mov	es:[si+10],cx		;destination handle = 0
	mov	es:[si+12],cx		;destination offset = 0
	mov	cx,SegForXmsXfer	;area to transfer bytes into
	mov	es:[si+14],cx		;destination segment
	mov	cx,wptr [lpXmsControl+2]
	mov	seg_lpXmsInvoke,cx	;save loword of xms call function
	mov	cx,wptr [lpXmsControl]
	mov	off_lpXmsInvoke,cx	;save hiword of xms call function
	mov	cx,seg_BankSize		;get the hiword of the block size
	mov	dx,off_BankSize		;get the loword of the block size

; move in as much of the XMS block as possible and write it out into the
; file.

RMSwapOutXmsLoop:

; compare size left to swap out and size of area that can be used for the move
; and decide what part to swap out.

	cmp	ax,cx			;compare high words
	nja	RMSwapOutLast		;last portion to swap out
	jb	RMSwapOutNext		;next part to swap out
	cmp	bx,dx			;compare the low words
	nja	RMSwapOutLast		;last portion to swap out

RMSwapOutNext:

	mov	es:[si],bx		;save low word of move length
	mov	es:[si+2],ax		;save high word of move length
	pushem	ds,ax,bx		;save these registers
	mov	ah,0bh			;function code for move
	smov	ds,ss			;ds:si points to move structure
	call	lpXmsInvoke		;call the function to do the move
	mov	di,ax			;save the return code
	popem	ds,ax,bx		;restore the registers
	or	di,di			;was it successful ?
	njz	RMSwapOutFail		;no, return back

; now write the block out to the disk, after zero compressing it.

	pushem	ax,bx,cx,dx,si		;save the relevant registers
	mov	dx,es:[si]		;low word of size moved
	mov	cx,es:[si+2]		;cx:dx has amount to write
	mov	ax,es:[si+14]		;segment where block was moved
	mov	si,0ffffh		;want to actually swap out
	cCall	SwapOutNonZeroBlocks,<FileHandle,ax,cx,dx,si>
	popem	ax,bx,cx,dx,si		;restore registers
	jc	RmSwapOutXmsBlockRet	;error in write, return back


; also write out a gap node with all 0s

	pushem	ax,bx,cx,dx,si		;save the relevant registers
	push	es
	smov	es,ss			;need to access header structure
	lea	di,RMXOHeader		;es:di points to the node header area
	push	di			;save the offset
	xor	ax,ax			;want to write 0
	mov	cx,4			;size of header	in words
	rep	stosw			;initialize it
	pop	di			;es:di points to the NodeHeader
	mov	cx,8			;8 bytes of header to write
	xor	dx,dx			;hiword of number of bytes to write
	cCall	WriteFile,<FileHandle,es,di,dx,cx>
	pop	es			;restore
	popem	ax,bx,cx,dx,si		;restore registers
	jc	RmSwapOutXmsBlockRet	;error in write, return back

; update variables for next move

	sub	dx,bx			;update amount left to swap out
	sbb	cx,ax			;cx:dx has amount left to move
	mov	di,cx			;check to see whether we are done
	or	di,dx			;no more left ?
	jz	RmSwapOutDone		;yes, we are done.

; update move structure for next portion.

	add	es:[si+6],bx		;update loword of source offset
	adc	es:[si+8],ax		;update hiword of source offset
	jmp	RMSwapOutXmsLoop	;continue till done.

RMSwapOutLast:

	mov	ax,cx			;get amount left into ax:bx
	mov	bx,dx			;ax:bx has size of last portion
	jmp	RMSwapOutNext		;move and write it out

RMSwapOutDone:

; need to write out a dummy header to mark the end of the memory image area

	smov	es,ss			;need to access header structure
	lea	di,RMXOHeader		;es:di points to the node header area
	push	di			;save the offset
	xor	ax,ax			;need to zero it out
	mov	cx,4			;size of header	in words
	rep	stosw			;initialize it
	pop	di			;es:di points to the NodeHeader
	mov	cx,8			;8 bytes of header to write
	xor	dx,dx			;hiword of number of bytes to write
	cCall	WriteFile,<FileHandle,es,di,dx,cx>
	jmp	short RMSwapOutXmsBlockRet

RMSwapOutFail:

	stc				;swap out failed

RMSwapOutXmsBlockRet:

cEnd
;----------------------------------------------------------------------------;
; RMSwapInXmsBlock:						   	     ;
;									     ;
; Given a file handle and dword worth of XMS context size, it reads back the ;
; image into it's correct place.				             ;
;									     ;
; It will read in swap groups from the file over zeroed out memory and do the;
; moves.								     ;
;									     ;
; There is a third parameter to this routine, 'OpCode', which when 0ffh will ;
; actually ZEROINT the XMS allocation instead of trying to read from the     ;
; file (in this case the FileHandle is ignored).			     ;
;----------------------------------------------------------------------------;

cProc	RMSwapInXmsBlock,<NEAR,PUBLIC,PASCAL>

	parmW	FileHandle		;handle of the file
	parmD	BankSize		;size of the context
	parmB	OpCode			;ZEROINT or not

	localD	lpXmsInvoke2		;xms entry function address
	localV	XmsMoveStruct2,16	;the move parameter block.
	localW	SegForXmsXfer2		;seg to be used for move

cBegin

	cld				;do not take chances with this

; if the block size is 0, we do not have to swap it in

	mov	si,seg_BankSize		;load the high word
	or	si,off_BankSize		;is the size 0 ?
	njz 	RMSwapInXmsBlockRet	;return

; now calculate the amount of bytes of reusable low heap area. We will start
; from the beginig of the StubSeg (not swapped in yet)

	mov	ax,_WOARLMSEG		;beginig of stubseg
	mov	SegForXmsXfer2,ax	;will use for XMS transfer
	sub	ax,LowMemSel		;reserved area (CS+DS)
	neg	ax			;want to subtract it from -
	add	ax,LowMemParaSize	;- the total low heap size
	call	GetSizeInBytes		;AX:BX has the size in bytes
	and	bx,0fff0h		;make it para multiple

; (note that we have just made the size of conventional memory that we can
;  use for the move to be a multiple of para size and the amount of xms that
;  we want to swap out is also a multiple of a para size.)

; now initialize the xms move structure.

	smov	es,ss			;will have structure built in stack
	lea	si,XmsMoveStruct2	;the move structure
	mov	cx,HighMemXmsHandle	;the source handle
	mov	es:[si+10],cx		;save the destination handle
	xor	cx,cx			;source offset will start at zero.
	mov	es:[si+12],cx		;low word of destination offset
	mov	es:[si+14],cx		;high word of destination offset
	mov	es:[si+4],cx		;source handle = 0
	mov	es:[si+6],cx		;source offset = 0
	mov	cx,SegForXmsXfer2	;area to transfer bytes into
	mov	es:[si+8],cx		;source segment
	mov	cx,wptr [lpXmsControl+2]
	mov	seg_lpXmsInvoke2,cx	;save loword of xms call function
	mov	cx,wptr [lpXmsControl]
	mov	off_lpXmsInvoke2,cx	;save hiword of xms call function
	mov	cx,seg_BankSize		;get the hiword of the block size
	mov	dx,off_BankSize		;get the loword of the block size

; move in as much of the XMS swapped out block that can be held in memory
; and move it back to its original area

RMSwapInXmsLoop:

; compare size left to swap in and size of area that can be used for the move
; and decide what part to swap in.

	cmp	ax,cx			;compare high words
	ja	RMSwapInLast		;last portion to swap in
	jb	RMSwapInNext		;next part to swap in
	cmp	bx,dx			;compare the low words
	ja	RMSwapInLast		;last portion to swap out

RMSwapInNext:

	mov	es:[si],bx		;save low word of move length
	mov	es:[si+2],ax		;save high word of move length

; if OpCode is ZEROINIT then memory is already zero-ed out, just move it.

	cmp	OpCode,0ffh		;ZEROINIT required ?
	jz	RMXmsInBlockReadIn	;yes, skip reading from file.

; zero out the block first.

	pushem	ax,bx,cx,dx
	mov	ax,_WOARLMSEG		;begining of stub
	sub	ax,LowMemSel		;size of reserved area in paras
	cCall	ZeroOutMemory,<LowMemSel,LowMemParaSize,ax>
	popem	ax,bx,cx,dx		

; read one swap group. 

	save	<ax,bx,cx,dx,si>	;save
	cCall	RestoreSwappedGroups,<FileHandle>
	jc	RMSwapInXmsBlockRet	;error, cannot proceed

RMXmsInBlockReadIn:

; now move it to its original position

	pushem	ds,ax,bx		;save these registers
	mov	ah,0bh			;function code for move
	smov	ds,ss			;ds:si points to move structure
	call	lpXmsInvoke2		;call the function to do the move
	mov	di,ax			;save the return code
	popem	ds,ax,bx		;restore the registers
	or	di,di			;was it successful ?
	jz	RMSwapInFail		;no, return back

; update variables for next move

	sub	dx,bx			;update amount left to swap out
	sbb	cx,ax			;cx:dx has amount left to move
	mov	di,cx			;check to see whether we are done
	or	di,dx			;no more left ?
	jz	RmSwapInDone		;yes, we are done.

; update move structure for next portion.

	add	es:[si+12],bx		;update loword of destination offset
	adc	es:[si+14],ax		;update hiword of destination offset
	jmp	RMSwapInXmsLoop		;continue till done.

RMSwapInLast:

	mov	ax,cx			;get amount left into ax:bx
	mov	bx,dx			;ax:bx has size of last portion
	jmp	RMSwapInNext		;read it in and move it

RMSwapInDone:

	clc				;no error while moving
	jmp	short RMSwapInXmsBlockRet

RMSwapInFail:

	stc				;swap out failed

RMSwapInXmsBlockRet:

cEnd
;----------------------------------------------------------------------------;
; GetXmsFreeArenaSel:							     ;
;									     ;
; This routine is a NOP in real mode. In protected mode, it prepares the     ;
; selector for the base of the area to be allocated for xms and finds the    ;
; first free windows high heap arena selector with which we can start        ;
; swapping the windows xms image out.					     ;
;----------------------------------------------------------------------------;

cProc	GetXmsFreeArenaSel,<NEAR,PUBLIC,PASCAL>

cBegin


cEnd
;----------------------------------------------------------------------------;
; GetAppXmsBase:							     ;
;						        		     ;
; This routine returns in CX:DX the base of the extended memory to be alloca-;
; -ted to the dos application.						     ;
;----------------------------------------------------------------------------;

GetAppXmsBase  proc  near

; lock the XMS block to get its base and then release the lock. We will not
; be doing any error checking here as we are sure to have a valid handle.

	mov	dx,HighMemXmsHandle	;handle of the extended memory block
	mov	ah,0ch			;function code for lock block
	call	lpXmsControl		;lock it.
	mov	cx,bx			;get loword of base
	xchg	cx,dx			;cx:dx has the base
	pushem	cx,dx			;save the base
	mov	ah,0dh			;function code for unlocking the block
	mov	dx,HighMemXmsHandle	;handle of the xms block
	call	lpXmsControl		;unlock the block
	popem	cx,dx			;get back the base
	ret

GetAppXmsBase	endp

;----------------------------------------------------------------------------;
; GetRealModeSeg:							     ;
;									     ;
; This routine takes a selector as parameter and returns in AX the correspo- ;
; -nding real mode segment.						     ;
;----------------------------------------------------------------------------;

cProc	GetRealModeSeg,<NEAR,PUBLIC,PASCAL>

	parmW	SrcSel			;selector whose address to be extracted

cBegin

	mov	ax,SrcSel		;this itself is the segment

cEnd
;----------------------------------------------------------------------------;
; ShuffleSegments:							     ;
;							                     ;
; Relocates the winoldap segments to where they will be resident when the Dos;
; application resides and transfers parameters to the stub segment.	     ;
;									     ;
; The exact actions, will depend on whether we are executing real or protect-;
; -ed mode winoldap.						             ;
;----------------------------------------------------------------------------;

cProc	ShuffleSegments,<NEAR,PUBLIC,PASCAL>

cBegin

	cld				;do not take chances with this

; now load data into the real mode stub.

	cCall	LoadRealModeStub

; now zero out the memory after the stub.

	cCall	ZeroOutMemory,<LowMemSel,LowMemParaSize,SizeReservedARea>

; if XMS is allocated to the app, ZEROINIT the xms block

	mov	ax,word ptr [XmsBankSize];get the low word
	mov	dx,word ptr [XmsBankSize+2]
	push	ax			;save
	or	ax,dx			;is the size 0 ?
	pop	ax			;dx:ax has bank size
	jz	@f			;no xms allocation
	mov	bx,0ffffh		;ZEROINIT opcode
	cCall	RMSwapInXmsBlock,<bx,dx,ax,bx>
@@:

cEnd
;----------------------------------------------------------------------------;
; MoveWoaIntoStubArea:							     ;
;									     ;
; This routine relocates the main winoldap code and data segment down to the ;
; start of either the low or the high heap area to make room for rolling the ;
; dos app in.								     ;
;									     ;
; In protected mode winoldap, they moved to the start of the high heap area  ;
; where as in real mode winoldap, they are moved to the start of the low heap;
; area.								             ;
;----------------------------------------------------------------------------;

cProc	MoveWoaIntoStubArea,<NEAR,PASCAL,PUBLIC>

cBegin

	cld				;do not take chances with this

;***	cCall	MoveWoa,<LowMemSel,WoaHighCsSel,WoaHighDsSel>

cEnd
;----------------------------------------------------------------------------;
; InvokeStubCode:							     ;
;									     ;
; This routine invokes the real mode stub code and control will come back    ;
; on a context switch or once the old app ends.				     ;
;									     ;
; The invocation code will be different for real and protected modes.	     ;
;----------------------------------------------------------------------------;

cProc	InvokeStubCode,<NEAR,PUBLIC,PASCAL>

cBegin


; prepare the call address from the values of CS,IP in the client register set

	mov	ax,RealMode_CS
	mov	wptr [lpStubEntry+2],ax	;save segment of stubcode
	mov	ax,RealMode_IP
	mov	wptr [lpStubEntry],ax	;save entry offset

; load the other segment registers.

	pushem	ds,bp			;save in new stack
	mov	ax,RealMode_DS
	mov	es,ax			;initialize
	mov	ax,RealMode_AX
	call	lpStubEntry		;invoke the stub code
	popem	ds,bp			;get back saved ds
	mov	RealMode_AX,ax
	mov	RealMode_BX,bx
	mov	AppUsesXMS,cx		;tells us whether app used XMS or not
	mov	NodeToSwitchTo,dl	;for directed hot key switch

	smov	es,ds			;set es to be same as ds

cEnd
;----------------------------------------------------------------------------;
; GetSegSize:								     ;
;									     ;
; This routine gets the size of a segment. Code is different for real and    ;
; protected modes.							     ;
;----------------------------------------------------------------------------;

cProc	GetSegSize,<NEAR,PUBLIC,PASCAL>

	parmW	SegSel			;segment or selector value

cBegin

	push	es			;save it
	mov	ax,SegSel		;get the segment value
	dec	ax			;the associated arena segment
	mov	es,ax			;have it in es
	mov	ax,es:[3]		;get the size in paragraphs
	shiftl	ax,4			;gives the size in bytes
	pop	es			;restore
	xor	dx,dx			;hope segments are never exactly 64k

cEnd
;----------------------------------------------------------------------------;
; ZeroOutMemory:							     ;
;									     ;
; Given a start selector and a DWORD size, this routine clears out that      ;
; amount of memory from the base of the selector.			     ;
;----------------------------------------------------------------------------;

cProc	ZeroOutMemory,<NEAR,PUBLIC,PASCAL>,<es,di,cx>

	parmW	BaseSel			;selector for base
	parmW	MemParaSize		;size of area in paras
	parmW	ResSize			;reserved size at top.
	localD	SelBase			;original base

cBegin.
  	
	mov	bx,BaseSel		;get the base
	add	bx,ResSize		;add in reservbed size in para
	mov	es,bx			;start sel
	mov	ax,MemParaSize		;get the para size
	sub	ax,ResSize		;subtract reserved area size
	call	GetSizeInBytes		;AX:BX has size in bytes
	mov	dx,ax			;DX:BX has the size.
	xor	di,di			;start at 0 offset

zero_loop:

	or	dx,dx			;still > 64K ?
	jz	zero_last		;no.
	mov	cx,8000h		;32K word
	xor	ax,ax
	rep	stosw			;zero out the segment.
	dec	dx			;one more 64k band done.
	mov	cx,es			;get the selector
	add	cx,1000h		;next 64k band
	mov	es,cx			;next segment
	jmp	short zero_loop		;continue.

zero_last:

	mov	cx,bx			;get remaining size
	shr	cx,1			;convert to word
	xor	ax,ax			;zero put
	rep	stosw			;zero the last segment

cEnd
;----------------------------------------------------------------------------;
; GetSelectorBase:							     ;
;									     ;
; Entry:     	BX    --   Selector					     ;
; Return:    CX:DX    --   32 bit base					     ;
; Destroys:     AX							     ;
;----------------------------------------------------------------------------;

GetSelectorBase proc near

	mov	dx,bx			;get the segment value
	mov	cl,4			;need to shift by 4
	shl	dx,cl			;low word of base
	xor	ax,ax			;will prepare hiword here
	mov	al,bh			;get the upper byte of seg address
	shr	al,cl			;ax has high word of base
	mov	cx,ax			;now CX:DX has the base
	ret

GetSelectorBase endp
;----------------------------------------------------------------------------;
; SetSelectorBaseLim64:							     ;
;									     ;
; Entry:     	BX    --   Selector					     ;
;            CX:DX    --   base of the selector				     ;
; Return:    selector set to have specified base and limit of 64k and access ;
;            rights of data.						     ;
; Destroys:     AX							     ;
;----------------------------------------------------------------------------;

SetSelectorBaseLim64  proc near

	pushem	cx,dx			;save
	mov	ax,cx			;have the high base word
	mov	cl,4			;need shift by 4
	shr	dx,cl			;prepare low thre nibbles
	ror	ax,cl			;get low nibble of AX into hi pos.
	or	dh,ah			;dx has the proper segment value
	mov	bx,dx			;return it in bx
	popem	cx,dx			;restore
	ret

SetSelectorBaseLim64 endp
;----------------------------------------------------------------------------;
; EmergencyExit:							     ;
;									     ;
; This routine is called to exit back to dos once windows swap in attempt    ;
; fails. In protected mode windows, we have to use a special INT 2F function ;
; to first switch to the dos extenders PSP and then exit. In real mode, wino-;
; -ld ap executes always on the kernel's PSP so we can directly do the exit. ;
;----------------------------------------------------------------------------;

EmergencyExit	proc  near

	assumes	ds,Data

; if the there is a vailid 'HighMemXmsHandle', unlock and free the xms
; block.

	mov	dx,HighMemXmsHandle	;get the handle
	or	dx,dx			;is it null ?
	jz	@f			;no xms to free

; unlock the xms block and free it.

	mov	ah,0dh			;unlock block code
	call	[lpXmsControl]		;block unlocked
	mov	ah,0ah			;free xms block code
	call	[lpXmsControl]		;all of xms allocated to win released

@@:

; now do the exit

	mov	ax,4c01h		;exit code,exit with error
	int	21h			;exit back to dos

EmergencyExit	endp
;----------------------------------------------------------------------------;
; This routine invokes the error manager.			             ;
;----------------------------------------------------------------------------;

ErrorHandler:
	
	call	ErrorManager		;this never returns

;----------------------------------------------------------------------------;

sEnd Code

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woastk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file just defines the temporary 384 byte stack area that WOA uses     ;
; accross the call to the real mode stack. 				     ;
;									     ;
; The size of 384 bytes is kind of arbitrary. A size of 256 was chosen at    ;
; first. However it was found that at a certain point the stack depth was    ;
; 0c9h (201), to be on the safe side the size has now been increased by      ;
; another 128 bytes.							     ;
;									     ;
; Also this defines a dummy labelled byte in all the segments so that we can ;
; calculate the size of the segments.					     ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Wed May-09-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend) 		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	.list

	.8086				;must have to run on 8086s too.

sBegin	Data

		public	SwitcherStack
		public	SwitcherStackTop
		public	DataSegEnd
		public	CodeSegEnd
		public	StubSegEnd

	;------------------------------------------------;
	; Define the stack area and the top of stack.	 ;
	;------------------------------------------------;

SwitcherStack	db	384 dup (99h)	;stack used accross call to stub

SwitcherStackTop label	byte		;top of stack

		dd	?		;just dummy area

DataSegEnd	label	byte		;end of the segment
		db	99h

sEnd	Data
;----------------------------------------------------------------------------;

sBegin Code

CodeSegEnd	label	byte		;end of code segment
		db	99h

sEnd Code
;----------------------------------------------------------------------------;
createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

StubSegEnd	label	byte		;end of stub seg
		db	99h

sEnd StubSeg
;----------------------------------------------------------------------------;

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woarlm.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

     
;----------------------------------------------------------------------------;
; This file has the functions performaed by the real mode routine.           ;
;                                                                            ;
; History:                                                                   ;
;                                                                            ;
;        Fri June-15-1990.      -by-  Amit Chatterjee [amitc]                ;
;        Adapted for the Dos Task Switcher.                                  ;
;                                                                            ;
;        Tue May-08-1990.       -by-  Amit Chatterjee [amitc]                ;
;        Till now if 'fNoSwitch' was set all the hot keys would be disabled  ;
;        and the hot keys would be chained down the INT 9 interrupt. This    ;
;        was not the right behaviour. The hot keys should only be chained    ;
;        down if the hot key is specifically disabled in the PIF. The INT9   ;
;        ISR has now been modified to take care of this. (Fix for bug #2190) ;
;                                                                            ;
;        Tue June-20-1989.      -by-  Amit Chatterjee [amitc]                ;
;        Created for Windows. (Added the History legend)                     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include woakeys.inc
	include woaerr.inc
	include woapif.inc
	include pdb.inc
	include njmp.mac
	include woaswch.inc
	include woaswapi.inc
	.list

	.286

;----------------------------------------------------------------------------;
; define the equates to access the users registers off the stack.            ;
;----------------------------------------------------------------------------;

USER_FLAGS      equ     wptr [bp+6]     ;the flag word
USER_FLAGLOW    equ     bptr [bp+6]     ;low byte of flags
USER_CS         equ     wptr [bp+4]     ;users return segment
USER_IP         equ     wptr [bp+2]     ;users return address
USER_BP         equ     wptr [bp]       ;bp saved here
USER_DS         equ     wptr [bp-2]     ;ds saved here
USER_DX         equ     wptr [bp-4]     ;dx saved here
USER_ES         equ     wptr [bp-6]     ;es saved here
USER_BX         equ     wptr [bp-8]     ;bx saved here
USER_AX         equ     wptr [bp-10]    ;ax saved here
USER_AL         equ     bptr [bp-10]    ;al saved here
USER_CX         equ     wptr [bp-12]    ;cx saved here
USER_SI         equ     wptr [bp-14]    ;si saved here
USER_DI         equ     wptr [bp-16]    ;di saved here

;----------------------------------------------------------------------------;
; define any public labels or eqautes here.                                  ;
;----------------------------------------------------------------------------;

		public  WoaPath             
		public  WoaParams           
		public  WoaFcb1             
		public  WoaFcb2             
		public  WoaParamBlock       
		public  WoaStubSize         
		public  WoaPSP          
		public  WoaAppNumber
		public  WoaBehavior
		public  WoaHotkeys
		public  WoaEmsFlag
		public  WoafBreak
		public  WoaStartScreenLines
		public  Woa6fValue
		public  WoaIrq9Global
		public  WoaNetAsyncSwitching
		public  AsyncNetPending
		public  WoaInt15UsershApp
		public  WoahApp
		public  WoafXmsInstalled
		public  WoaGrabberName
		public  WoaSegResizeBlock
		public  WoaSizeReservedArea
		public  WoaCpuType
		public  WoaGrabberSwapPath
		public  WoaSwapDrive
		public  WoaFileEntrySize
		public  RealModeWoa
		public  BackFromContextSwitch
		public  SwitchIfPossible
		public  WaitForKeyFromInt16
		public  WaitForKeyFromDosCalls
		public  DosCall
		public  ActualInt21
		public  ActualInt16
		public  ActualInt09
		public  Int16ISR
		public  Int09ISR
		public  TestWoaInt16InChain
		public  ConsoleRawMode
		public  GrabberParaSize
		public  WOAsInt16
		public  ActualXMS
		public  GetXmsHandler
		public  DoInt28
		public  WoaHotKeyState
		public  WoaNodeToSwitchTo
		public  WoaALtTabDisabled
		public  WoaShftALtTabDisabled
		public  WoaALtEscDisabled
		public  WoaShftALtEscDisabled
		public  WoaCtrlEscDisabled
		public  DisableInt15Mouse
		public  EnableInt15Mouse
		public  SwitcherDisabled
		public  WoaSwitcherID
		public  HInt09ChainAddr
		public  WoaSwapAreaParaSize

;----------------------------------------------------------------------------;
; define some local data structures.                                         ;
;----------------------------------------------------------------------------;

ScanCodeStruc   STRUC

SCS_ScanCode            db      ?       ;main scan code
SCS_ShiftState          db      ?       ;the shift state

ScanCodeStruc   ENDS

HotKeyInfoStruc STRUC

HKIS_State              db      ?       ;enabled if 0, else disabled
HKIS_PrefixScanCode     db      ?       ;a prefix for the scan code
HKIS_Type               db      ?       ;type of switch
HKIS_NodeNum            db      ?       ;logical node number

HotKeyInfoStruc ENDS

; at this moment, the code assumes that the size of the 'HotKeyInfoStruc'
; structure is double the size of 'ScanCodeStruc' structure. There are 
; 'errnzs' to assert this.

;----------------------------------------------------------------------------;




;----------------------------------------------------------------------------;
; define two macros for doing near and far returns and one for swapping words;
;----------------------------------------------------------------------------;

near_ret  macro
	local   dummy
dummy   proc    near
	ret     
dummy   endp
	endm

far_ret macro
	local   dummy
dummy   proc    far
	ret
dummy   endp
	endm

swap_a_word     macro

	mov     ax,[si]                 ;;get word from source
	xchg    es:[di],ax              ;;swap it with destination
	mov     [si],ax                 ;;save word in source
	add     si,2                    ;;next word
	add     di,2                    ;;next word
	endm

;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin  StubSeg

	assumes cs,StubSeg
	assumes ds,StubSeg

;----------------------------------------------------------------------------;
; declare external functions here.                                           ;
;----------------------------------------------------------------------------;

	externNP        XenixRead               ;(WOADOS.ASM)
	externNP        ReadConsoleBuffer       ;(WOADOS.ASM)
	externNP        LoadGrabberAndInit      ;(WOAGRB.ASM)
	externNP        GrabberSaveScreen       ;(WOAGRB.ASM)
	externNP        GrabberRestoreScreen    ;(WOAGRB.ASM)
	externNP        GrabberEnableSave       ;(WOAGRB.ASM)
	externNP        GrabberDisableSave      ;(WOAGRB.ASM)
	externNP        GrabberInitScreen       ;(WOAGRB.ASM)
	externNP        SaveWindowsHPState      ;(WOAHP.ASM)
	externNP        RestoreWindowsHPState   ;(WOAHP.ASM)
	externNP        SaveDosAppHPState       ;(WOAHP.ASM)
	externNP        RestoreDosAppHPState    ;(WOAHP.ASM)
	externNP        CheckWithApp            ;(WOAHP.ASM)
	externNP        NotifyApp               ;(WOAHP.ASM)
	externNP        ProcessTsr              ;(WOATSR.ASM)
	externNP        XmsInit                 ;(WOAXMS.ASM)
	externNP        HookOurXMSCode          ;(WOAXMS.ASM)
	externNP        UnHookOurXMSCode        ;(WOAXMS.ASM)
	externNP        SWAPICreateSession      ;(WOASWAPI.ASM)
	externNP        SWAPIResumeSession      ;(WOASWAPI.ASM)
	externNP        SWAPISessionActive      ;(WOASWAPI.ASM)
	externNP        SWAPIDestroySession     ;(WOASWAPI.ASM)
	externNP        OkToSuspend?            ;(WOASWAPI.ASM)
	externNP        SwitchAPICallIn         ;(WOASWAPI.ASM)
	externNP        DoDosWait               ;(WOADOS.ASM)
	externNP        SwapInstanceDataBlocks  ;(WOAINSTD.ASM)
	externNP        InitSwitcherAPI         ;(WOASWAPI.ASM)

ifdef	JAPAN
	externFP	KkcBusyCheck		;(WOAKKC.ASM)
endif

;----------------------------------------------------------------------------;
; declare variables defined in other files.                                  ;
;----------------------------------------------------------------------------;

externB PromptString                            ;(WOAMSG2.INC,WOATSR.ASM)
externB WoaAppUsesXMS                           ;(WOAXMS.ASM)
externW RCB_FileHandle                          ;(WOADOS.ASM)
externD lp3fMode                                ;(WOADOS.ASM)
externB b3fRCB                                  ;(WOADOS.ASM)

ifdef	JAPAN
externW	KkcBufferSize				;(WOAKKC.ASM)
externW	KkcBufferSeg				;(WOAKKC.ASM)
endif

;----------------------------------------------------------------------------;
; define a 256 byte of stack frame for the real mode stack                   ;
;----------------------------------------------------------------------------;

WoaGrabberName          db      80 dup (?)      ;load name of grabber
WoaGrabberSwapPath      db      80 dup (?)      ;grabber swap path
WoaPath                 db      80 dup (?)      ;file to execute
WoaParams               db      130 dup (?)     ;parameters to it
WoaFcb1                 db      32 dup (?)      ;first FCB
WoaFcb2                 db      32 dup (?)      ;second FCB
Woa6fValue              db      ?               ;int 6f to be done or not
WoaIrq9Global           db      ?               ;IRQ 9 to be global or not
WoaNetAsyncSwitching    db      ?               ;Network to be monitored or not
WoaCpuType              dw      ?               ;copy of __WINFLAGS
WoaFileEntrySize        dw      ?               ;size of SFT fcb


;----------------------------------------------------------------------------;
; now define some data variables that will be passed in from protected mode  ;
;                                                                            ;
; ********************************CAUTION**********************************  ;
; THE DEFINITION AND ORDERING OF VARIABLES IN THE FOLLOWING BLOCK MUST BE    ;
; EXACTLY IDENTICAL TO THE DEFINITION AND ORDERING OF VARIABLES IN THE       ;
; CORRESPONDING BLOCK NAMED 'STUBDATA' IN (WOAMGR.ASM)                       ;
; ************************************************************************** ;
;----------------------------------------------------------------------------;

		public  WoaStubData
		public  WoaStubDataLength

WoaStubData     label byte

WoafBreak               db      ?               ;startup state of CTRL+C flag
WoaSwapDrive            db      ?               ;swap drive to use
WoaPSP                  dw      ?               ;WOA PDB seg
WoaEmsFlag              db      ?               ;EMS present or not
WoaInt15UsershApp       dw      ?               ;ID of INT 15 user.
WoaSegResizeBlock       dw      ?               ;block to resize
WoaSizeReservedArea     dw      ?               ;size of reserved area

WoaStubDataLength       equ $ - WoaStubData

;----------------------------------------------------------------------------;
; Define the rest of the variables that are obtained from the main code seg. ;
;----------------------------------------------------------------------------;

WoaStartScreenLines     dw      ?               ;start up no of screen lines
WoahApp                 dw      ?               ;handle of window
WoafXmsInstalled        db      0               ;NZ if XMS code installed
WoaAppNumber            dw      ?               ;serial number of app
WoaParamBlock           dw      7  dup (?)      ;parameters for EXEC
WoaBehavior             db      ?               ;the behaviour bits
WoaHotkeys              db      ?               ;the hot key disable flags
WoaStubSize             dw      ?               ;stub code size
WoaSwitcherID           db      ?               ;ID of the switcher

;----------------------------------------------------------------------------;
; next have any variables needed by real mode code.                          ;
;----------------------------------------------------------------------------;

SwitcherDisabled        dw      0               ;following reasons to disable

  SD_LOCAL_DISABLE      equ     001h            ;local critical sections
  SD_PMODE_WINDOWS      equ     002h            ;pmode windows being run
; SD_SWAPI_DISABLE      equ     004h            ;defined in WOASWAPI.ASM

HardwareIntCount        db      0               ;number of hw ints being serviced
LocalInt15MouseHandler  db      0               ;mouse handler local or not
Int16GetStatusType      db      01h             ;Int 16h get status call to use
WoaSwapAreaParaSize     dw      ?               ;size of swap area
OriginalDosBlockSize    dw      ?               ;size of LOW heap block
OriginalBlockType       db      ?               ;type of the arena
WoaRlmEntrySS           dw      ?               ;stack seg at entry
WoaRlmEntrySP           dw      ?               ;stck pointer at entry
WoaSwitchOutSS          dw      ?               ;value of ss at switch out time
WoaSwitchOutSP          dw      ?               ;value of sp at switch out time
WoaSwitchOutESP         dd      ?               ;value of esp at switch out time
DosAppPSP               dw      ?               ;PSP of the DOS APP.
DosAppDMA               dd      ?               ;DMA address of dos app
MasterPICMask           db      ?               ;value of 21h (master PIC) port
PreExecSLavePICMask     db      ?               ;the preexec value of the mask
GlobalSlavePICMask      db      ?               ;value of slave PIC for windows
AppSlavePICMask         db      ?               ;value of slave PIC for app
AppUsesIRQ9             db      0               ;app uses IRQ 9 or not.
DosAppDisk              db      ?               ;current disk of dos app
DosPreExecDisk          db      ?               ;windows current disk
DosPreExecCD            db      '\'             ;specify the root
			db      79 dup (?)      ;rest of the name
DosAppCD                db      '\'             ;specify the root
			db      79 dup (?)      ;rest of the name
lpInDosFlag             dd      ?               ;long pointer to InDos flag
lpErrModeFlag           dd      ?               ;long pointer to err mode flag
AsyncNetPending         db      0               ;async net request done or not
PendingTime             dw      0               ;num ticks after switch req set
ActualInt1C             dd      ?               ;previous INT 1C ISR
ActualInt09             dd      ?               ;previous INT 09 ISR
ActualInt0A             dd      ?               ;pre-exec INT 0AH
ActualInt21             dd      ?               ;previous INT 21 ISR
ActualInt15             dd      ?               ;previous INT 15 ISR
ActualInt16             dd      ?               ;previous INT 16 ISR
ActualInt24             dd      ?               ;original INT 24 ISR
ActualInt27             dd      ?               ;original INT 27 ISR
ActualInt2A             dd      ?               ;original INT 2A ISR
ActualInt5C             dd      ?               ;original INT 5C ISR
ActualInt71             dd      ?               ;pre-exec INT 71H ISR
OtherActualInt2f        dd      ?               ;original INT 2f ISR
WoaHotkeyState          db      ?               ;state of hot keys
WoaNodeToSwitchTo       db      ?               ;node # to switch to
lpGlobalSwtchStr        dd      ?               ;pointer to global switch str.
LastScanCode            db      0               ;last scan code read
TsrActive               db      0               ;TSR activated or not
TestWoaInt16InChain     db      0               ;are we in INT 16 chain ?


SwitchInProgress        db      0               ;switch in progress or not

  SIP_SWITCHING         equ     01h             ;actually switching

WOAsInt16               db      0               ;INT 16 call from WOA code
PopRet                  dw      ?               ;variable to pop ret address
lpDosData               dd      ?               ;lptr to DOS data block
ConsoleRawMode          db      0               ;console in raw mode or not.
OriginalInt15MemSize    dw      ?               ;original int 15 memory size
OurInt15OffChain        db      ?               ;can we reach INT 15 isr ?
AppEmsSaveArea          db      256 dup (?)     ;EMS save area
WinIoctlData            db      5 dup (?)       ;win IOCTL data for shrd handles
AppIoctlData            db      5 dup (?)       ;app IOCTL data for shrd handles
WinPrinterPorts         dw      3 dup (?)       ;win printer port addresses
AppPrinterPorts         dw      3 dup (?)       ;app printer port addresses 
DevHeaderChain          db      26 dup (0)      ;device header pointers
GrabberParaSize         dw      ?               ;grabber context para size
PrtScInProgress         db      0               ;print screen in progress or not
TempStack               dw      ?               ;save temp stack segment
lpXmsEntry              dd      ?               ;entry to xms initializer
XMsFlag                 db      0               ;XMS installed or not.
ActualXms               dd      ?               ;HIMEM entry point
DosAllocationStrategy   db      ?               ;allocation strategy for app
DosLinkState            db      ?               ;link state
AppsLogicalNodeNum      db      0               ;node number of app
Woa4BSP                 dw      ?               ;saved value of SP of PSP
Woa4BSS                 dw      ?               ;saved value of SS of PSP

;----------------------------------------------------------------------------;
; reserve space for saving some old app state related variables.             ;
;----------------------------------------------------------------------------;

Buf8087                 db      98 dup (?)      ;8087 state saved here
Speaker                 db      0               ;speaker value,init to 0
ControlCFlag            db      ?               ;state of control c flag

;----------------------------------------------------------------------------;
; Miscellaneous flags.                                                       ;
;----------------------------------------------------------------------------;

MiscFlags               dw      0               ;random flags defined below

	TIMER_HOOKED    equ     1h              ;timer has been hooked.

;----------------------------------------------------------------------------;
; define the HOT KEY related structures and definitions.                     ;
;----------------------------------------------------------------------------;


MAX_FIXED_HOT_KEYS      equ     5               ;no of predefined hot keys.

		EVEN
ScanCodeTable   label word

		db      0fh             ;scan code for TAB (ALT-TAB)
		db      00001000b       ;shift state for ALT
		db      01h             ;scan code for ESC (ALT-ESC)
		db      00001000b       ;shift state for ALT
		db      01h             ;scan code for ESC (CTRL-ESC)
		db      00000100b       ;shift state for CTRL
		db      0fh             ;scan code for TAB (SHIFT-ALT-TAB)
		db      00001011b       ;shift state for ALT+SHIFT
		db      01h             ;scan code for ESC (SHIFT-ALT-ESC)
		db      00001011b       ;shift state for ALT+SHIFT

; now have the app specific scan code table

AppsScanCodeTable  db   MAX_NUM_PROGRAMS * SIZE ScanCodeStruc dup (0)

		EVEN

HotKeyInfoTable label byte

 WoaAltTabDisabled      db      0               ;ALT+TAB not disabled
			db      0               ;the extra scan code (none)
			db      WOA_ALT_TAB     ;type of switch.
			db      -1              ;logical node number

  WoaAltEscDisabled     db      0               ;ALT+ESC not disabled
			db      0               ;the extra scan code (none)
			db      WOA_ALT_ESC     ;type of switch.
			db      -1              ;logical node number

  WoaCtrlEscDisabled    db      0               ;ALT+ESC not disabled
			db      0               ;the extra scan code (none)
			db      WOA_CTRL_ESC    ;type of switch.
			db      -1              ;logical node number

  WoaShftALtTabDisabled db      0               ;SHIFT+ALT+TAB not disabled
			db      0               ;the extra scan code (none)
			db      WOA_SHIFT_ALT_TAB;type of switch.
			db      -1              ;logical node number

  WoaShftAltEscDisabled db      0               ;ALT+ESC not disabled
			db      0               ;the extra scan code (none)
			db      WOA_SHIFT_ALT_ESC;type of switch.
			db      -1              ;logical node number

; now have the app specific hot key info table

AppsHotKeyInfoTable  db MAX_NUM_PROGRAMS * SIZE HotKeyInfoStruc dup (0)

;----------------------------------------------------------------------------;
; define a 400 byte of stack frame for the real mode stack which will be     ;
; used while switching out                                                   ;
;----------------------------------------------------------------------------;

			db      400 dup (99h)   ;switch out stack

WoaSwitchOutStackTop    dw      99h             ;the top of temp stack

;----------------------------------------------------------------------------;
; define another 128 byte stack on which we will do the EXEC call to start the
; app. Some INT 21H handler may trap the 4BH call and chain down by calling  ;
; the previous handler. In this case they would have valid data on the stack ;
; that would be needed when the app exits.                                   ;
;----------------------------------------------------------------------------;

			db      128 dup (55h)   ;exec stack

WoaExecStackTop         dw      55h             ;top of exec time stack

;----------------------------------------------------------------------------;

WoaAppsSS               dw      ?               ;app's SS
WoaAppsSP               dw      ?               ;app's SP
WoaAppsESP              dd      ?               ;app's ESP

;----------------------------------------------------------------------------;
; define external constants.                                                 ;
;----------------------------------------------------------------------------;

externA PromptStringLength                      ;(WOAMSG2.INC,WOATSR.ASM)

;----------------------------------------------------------------------------;
; define equates for some hardware ports.                                    ;
;----------------------------------------------------------------------------;

timer0                  equ     40H             ;Timer port 0
SpeakerCtl              equ     61H             ; Speaker port
CoProcPort              equ    0F0H             ; 8087/80287 ports
mskreg                  equ     21H             ; IRQ int mask register
BEEP_ON                 equ     03h             ; beeping...

;----------------------------------------------------------------------------;
; define other needed constants.                                             ;
;----------------------------------------------------------------------------;

TIMEOUT_TICK_COUNT      equ     18*2+1          ;2 seconds timeout value


IS_WINOLDAP_ACTIVE      equ     4680h           ;woa's INT 2f hook
WIN_P_START_UP          equ     1605h           ;PMODE Windows start up
WIN_P_EXIT              equ     1606h           ;PMODE Windows exits
WOA_MIN_FILEHANDLES     equ     2               ;min free handles for WOA

; Define IBM PC port locations for the Intel 8243 Programmable Interval Timer
; chip

PIT_PORTA       =       040h
PIT_PORTB       =       041h
PIT_PORTC       =       042h
PIT_PORTD       =       043h

; Define IBM PC port locations for the Intel 8255 Programmable Peripheral
; Interface chip

PPI_PORTA       =       060h
PPI_PORTB       =       061h
PPI_PORTC       =       062h
PPI_PORTD       =       063h

; Define timimgs and divisors to make sounds via the PIT, PPI chips and the
; PC's speaker circuitry.

BEEP_TIME1      =       02400h
BEEP_TIME2      =       03400h
BEEP_TONE1      =       00533h
BEEP_TONE2      =       00633h


WF_CPU086088    =    0000h
WF_CPU186       =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486ORABV  =    0008h

;----------------------------------------------------------------------------;
; we need to save about 50 bytes from 0:4f0 for comm related stuff. Also,    ;
; Basic uses some of these areas to save some stuff, but then we will not be ;
; able to switch out from basic any way.                                     ;
;----------------------------------------------------------------------------;

CommSaveArea            db      50 dup (?)

;----------------------------------------------------------------------------;
; define the dispatch table for the INT 21 calls that we trap.               ;
;----------------------------------------------------------------------------;

DosTraps        label byte

		db      01h             ;conin with echo
		dw      DosFuncGetKey   ;routine which handles it
		db      07h             ;unfiltered input with echo
		dw      DosFuncGetKey   ;routine which handles it
		db      08h             ;conin without echo
		dw      DosFuncGetKey   ;routine which handles it
		db      0ah             ;buffered-keyboard-input
		dw      DosFunc0A       ;routine which handles that
		db      0ch             ;flush buffer, read keyboard
		dw      DosFunc0C       ;routine which handles it
		db      31h             ;terminate and stay resident
		dw      DosFunc31       ;routine which handles it
		db      3fh             ;read file or device
		dw      DosFunc3f       ;routine which handles it
		db      44h             ;IOCTL function
		dw      DosFunc44       ;routine which handles it
DosDefaultCode  db      ?               ;put AH here on entry to trap default
		dw      DosDefaultFunc  ;pass on to original handler
			
;----------------------------------------------------------------------------;

RealModeWoa proc far

	smov    ds,cs                   ;set up proper data segment

;----------------------------------------------------------------------------;
; save the current values of stack segment and stack pointer so that we can  ;
; return back to protected mode from one of the interrupt handlers in case of;
; a context switch.                                                          ;
;----------------------------------------------------------------------------;

	mov     WoaRlmEntrySS,ss        ;save stack segment
	mov     WoaRlmEntrySP,sp        ;save stack pointer

;----------------------------------------------------------------------------;
; Get the amount of extende memory available via the INT 15 call             ;
;----------------------------------------------------------------------------;

	mov     ah,88h                  ;get extended memory size call ?
	int     15h                     ;ax returns the available size
	mov     OriginalInt15MemSize,ax ;save it.

;----------------------------------------------------------------------------;
; First try to load in grabber and initialize it also reserving and marking  ;
; the loaction of the buffer needed for saving the screen.                   ;
;----------------------------------------------------------------------------;

	cCall   LoadGrabberAndInit      ;load and initialize grabber
	jnc     @f                      ;loading went off smoothly

; the grabber load has failed. Retuen back to real mode with proper error
; code.

	mov     ah,ER_GRABBER_LOAD      ;grabber load failure
	stc                             ;error indication
	ret                             ;go back to protected mode

@@:

; get and save a pointer to the global switch structure.

	mov     ax,4a05h                ;INT 2F code for the shell interface
	mov     si,CGET_GLOBAL_SWITCH_DATA
	int     2fh                     ;dx:ax has the long pointer
	mov     wptr [lpGlobalSwtchStr],ax;save offset
	mov     wptr [lpGlobalSwtchStr+2],dx;save segment

; prepare the table of hotkey information.

	call    PrepareAppHotKeyList

;----------------------------------------------------------------------------;
; We will now shrink the block size to just hold the stubs.                  ;
;                                                                            ;
; Also we must mark this block as the last dos block, so that dos does not   ;
; allocate any memory past the end of the block.                             ;
;----------------------------------------------------------------------------;

	mov     ax,WoaSegResizeBlock    ;segment of block to resize

; first we must save the size.
	
	dec     ax                      ;point to DOS arena segment
	mov     es,ax
	mov     ax,wptr es:[3]          ;get areana size in paras
	mov     OriginalDosBlockSize,ax ;save it

; at this point calculate the size of the swap area for the TestMemoryRegion
; switcher api call. The swapping starts at the current CS and the size in
; paras is:
;
;       OriginalDosBlockSize - (CS - WoaSegResizeBlock)

	mov     bx,cs                   ;get our CS
	sub     ax,bx                   ;based on above formula
	add     ax,WoaSegResizeBlock    ;total para size of swap area from CS:0
	mov     WoaSwapAreaParaSize,ax  ;save it

; also retrive the arena type and mark it as the last one

	mov     al,es:[0]               ;exchange with the current type
	mov     OriginalBlockType,al    ;save the actual arena type

	mov     es,WoaSegResizeBlock    ;want to resize the block
	mov     bx,WoaSizeReservedArea  ;size of any reserved area
	add     bx,GrabberParaSize      ;add in the size of the grabber context

;----------------------------------------------------------------------------;
; add WoaAppNumber to this value, so that the memory locked by the stub will ;
; be progressively more ensuring that none of the oldapps are given the same ;
; PSP by DOS                                                                 ;
;----------------------------------------------------------------------------;

	add     bx,WoaAppNumber         ;extra para, 2nd app onwards

ifdef	JAPAN
	push	cx			;
	mov	cx,KkcBufferSize	;
	or	cx,cx			; not installed KKC ?
	jz	@f			; yes

	mov	ax,WoaSegResizeBlock	;
	add	ax,bx			;
	mov	KkcBufferSeg,ax		; save buffer segment
	add	bx,cx			; add buffer size using to save KKC state
@@:
	pop	cx
endif

;----------------------------------------------------------------------------;

	mov     ax,4a00h                ;resize function
	int     21h                     ;area released for WOA

; initialize our Switcher API handler module.

	cCall   InitSwitcherAPI

; get and save long pointers to the InDos and ErrorMode flags.

	call    GetDosFlags             ;get the flag variables

; now let grabber hook INT 10 if it is loaded

	cCall   GrabberEnableSave       ;grabber hooks int 10

; hook all the vectors that WOA wants to trap

	call    HookIntVectors          ;hooks relevant vectors
	
; now set the mode to a known one and the requested no of lines per screen.

	mov     ax,WoaStartScreenLines  ;start up no of lines

; if the no of lines is not 25,43 or 50 validate it.

	call    PruneNumLines           ;get a valid value
	mov     WoaStartScreenLines,ax  ;save the one num we will use
	cCall   GrabberInitScreen       ;initialize the display

; if HIMEM is installed, then get the address of the XMS entry point. This 
; will be needed to set the correct state of the A20 line.

	call    GetXmsHandler           ;saves the call address

; if XMS handling is to be done, call the XMS initializer

	call    StartXms                ;initialize if needed

; set up ES:BX to point to the parameter block

	mov     bx,StubSegOFFSET WoaParamBlock
	smov    es,ds                   ;ES:BX points to parameter block

; set the environment segment in the parm block from the one in the heap 
; owners pdb.

	push    es                      ;save
	mov     es,WoaPSP               ;get the owners PDB
	mov     ax,es:[2ch]             ;get the environment segment
	pop     es                      ;es:bx  points to param block
	mov     es:[bx],ax              ;save the environment segment

; now we need to save various dos or bios related state befor we start the
; old app so that we can restore these states when we switch back to windows

	call    SaveWinDosBiosStates    ;save various states

; initialize the 'TsrActive' flag, it will be set only if a TSR is activated

	mov     cs:[TsrActive],0        ;is there a tsr to handle ?

; before invoking the Old App, restore the state of the HP system

	push    es                      ;save 
	cCall   SaveWindowsHPState      ;must be restored before going back
	popem   es                      ;restore 

; clear out pending CTRL+Cs, if any.

	mov     ax,0c00h                ;flush keyboard
	int     21h

; reset the CTRL+C flag state now.

	mov     ax,3301h                ;set CTRL+C flag
	mov     dl,WoafBreak            ;get the startup flag
	int     21h                     ;set the start up state

;----------------------------------------------------------------------------;

; do the Create_Session switch API call.

	cCall   SWAPICreateSession
	jz      CreateSessionSucceeded  ;ok to go ahead

; the create session call failed. Exit with an appropriate error code.

	stc                             ;EXEC fails
	mov     ax,ER_SWAPI_CREATE_FAILS;error subcode 
	jmp     short ExecReturns       ;skip over the EXEC call

CreateSessionSucceeded:

; do a resume session call.

	cCall   SWAPIResumeSession

; do a sesssion active call.

	cCall   SWAPISessionActive
;----------------------------------------------------------------------------;

; point DS:DX to the file to execute

	mov     bx,StubSegOFFSET WoaParamBlock
	mov     dx,StubSegOFFSET WoaPath;DS:DX points to file to execute

; switch to a temporary stack before execing.

	cli                             ;mask off interrupts
	smov    ss,cs                   ;stack is in our segment
	mov     sp,StubSegOFFSET WoaExecStackTop
	sti                             ;restore interrupts.
	mov     ax,4b00h                ;exec code
	int     21h                     ;pass control to child.

ExecReturns:

; make sure DS is same as CS at this point

	smov    ds,cs                   ;ds has stub segment

; the stack might have changed, so reload it

	mov     ss,WoaRlmEntrySS        ;get the entry point stack
	mov     sp,WoaRlmEntrySP        ;get the entry point stack pointer

; a terminate and stay resident call might have been made, if so handle it
; (we basically wait in a loop till the user actually exits the TSR)

	pushf                           ;push the flag before comparision
	push    ax                      ;save 4b return code

;----------------------------------------------------------------------------;
; make a DestroySession Switch API call.

	cCall   SWAPIDestroySession
;----------------------------------------------------------------------------;

; restore the state of the A20 line if the application had turned it off (done
; only if HIMEM is installed.

	call    SetCorrectA20State      ;sets A20 back on if HIMEM installed

; turn the CTRL+C flag off, so that if we decide to put up the TSR pop-up &
; decide to stay on for a while longer no one will forcibly abort us.

	mov     ax,3301h                ;set CTRL+C flag
	xor     dl,dl                   ;to off
	int     21h                     ;break flag turned off

	pop     ax                      ;restor return code

	cmp     cs:[TsrActive],0ffh     ;is there a tsr to handle ?
	jnz     NoTsrActive             ;no.
	popf                            ;donot need them now

; a TSR is active, allocate a fresh stack block and move the stack to it

	mov     ah,48h                  ;code to allocate memory block
	mov     bx,64                   ;1K for temporary stack
	int     21h                     ;do the allocation
	mov     cs:[TempStack],ax       ;save segment

; get back exec return code and flag, they must be saved on the new stack

	mov     bx,1000                 ;offset of start stack top
	mov     ss,ax                   ;switch stack
	mov     sp,bx                   ;ss:sp in temporary stack

; now put up the dialog box and wait

	call    ProcessTsr              ;handle the tsr if any
	smov    ds,cs                   ;go back to own segment

; go back to the entry level stack

	mov     ss,WoaRlmEntrySS        ;get the entry point stack
	mov     sp,WoaRlmEntrySP        ;get the entry point stack pointer

; release the stack space.

	mov     ah,49h                  ;release memory code
	mov     es,cs:[TempStack]       ;the allocated segment
	int     21h                     ;block released

; now flags to say there is no exec failure

	clc                             ;no failure
	pushf                           ;save the flag

NoTsrActive:

	push    ax                      ;save exec return code

; if 'destroy pif window' pif setting is not set, display message that we
; are ready to exit and wait for user to type in a key, else this routine
; will be a NOP.

	or      SwitcherDisabled,SD_LOCAL_DISABLE;prevent a switch out.
	call    PressKeyToExit          ;wait if necessary

; now initialize the display back to a know mode incase the old app leaves
; it in a graphics mode.Set back the start up no of lines

	mov     ax,WoaStartScreenLines  ;no of lines per screen
	cCall   GrabberInitScreen       ;initialize the display

; remove our XMS hook.

	cmp     WoafXmsInstalled,0      ;is there any xms handler
	jz      @f                      ;XMS code handler not installed.
	call    UnHookOurXMSCode        ;XMS hook removed
@@:

; we should disable the INT 15 mouse if a local handler is active

	call    DisableInt15Mouse

;----------------------------------------------------------------------------;
; we are back from execing the child, now grow back the original DOS block   ;
; allocated to windows to its original size.                                 ;
;----------------------------------------------------------------------------;

; set back ds to cs
	
	smov    ds,cs                   ;restore stub ds

; restore various dos & bios states that we had saved before the app had 
; started

	call    RestoreWinDosBiosStates ;restore dos and bios states

; if the machine is a vectra, restore the stae of the system for windows

	cCall   RestoreWindowsHPState   ;restores vectra state on a vectra

; restore the saved instance data image which includes IDT

	cCall   SwapInstanceDataBlocks

; let grabber de-install it's INT 10 hooks.

	cCall   GrabberDisableSave      ;grabber releases int 10 hooks

; restore the IRQ enable state in the PIC

	mov     al,MasterPICMask        ;get the value
	out     21h,al                  ;restored

; do the same for the slave PIC. We should restore the slave PIC mask only if
; the app used it else not. Also if the app used it, we should restore the 
; PreExec state.

	mov     al,PreExecSlavePICMask  ;get the value
	call    RestoreSlavePICMask     ;restore the slave pic mask

; go back to heap owner pdb before resizing (same as WOA's PSP)

	mov     bx,WoaPSP
	mov     ax,5000h                ;set PDB call
	int     21h                     ;we are now in DOS extenders PSP

	mov     es,WoaSegResizeBlock    ;this is the DOS block to resize
	mov     bx,OriginalDosBlockSize ;get the original size
	mov     ax,4a00h                ;resize call
	int     21h                     ;dos block resized

; now set back the original arena type.

	mov     ax,es                   ;currently pointing to the block
	dec     ax                      ;the arena segment
	mov     es,ax                   ;point to the arena
	mov     al,OriginalBlockType    ;get the actual arena type
	mov     es:[0],al               ;restore it

; now switch back to WOA PDB

	mov     bx,WoaPSP               ;WOA PDB segment
	mov     ax,5000h                ;set PDB call
	int     21h                     ;back to legal PDB

; we can now go back in protected mode and swap windows in.

	pop     ax                      ;get back exec code
	popf                            ;get back flags
	jc      @f                      ;if error, do not reset ax
	xor     ax,ax                   ;to signify that old app exited
	
@@:
	mov     bx,WoaInt15UsershApp    ;return ID of guy using INT 15
	ret

RealModeWoa     endp

;----------------------------------------------------------------------------;
;                        WOA HOOKED INTERRUPT HANDLERS                       ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; Int1CISR:                                                                  ;
;                                                                            ;
; The Switcher hooks this interrupt to timeout Switch requests that cannot   ;
; be satisfied within a resonable frame of time. The number of timer ints    ;
; that we wait since a SwitchOut Request has been made is governed by a      ;
; constant.                                                                  ;
;                                                                            ;
; Also, if we are in the middle of a switch, we should reset the tickcount   ;
; and activate it again when we are done with the switch.                    ;
;----------------------------------------------------------------------------;

Int1CISR  proc far

	test    cs:[WoaHotkeyState],WOA_SWITCH
	jz      Int1CNoSwReq            ;no switch request has been registered

	inc     cs:[PendingTime]        ;we have seen one more tick

; have we waited long enough.

	cmp     cs:[PendingTime],TIMEOUT_TICK_COUNT
	jae     Int1CAbortSwitch        ;abort the switch.
	jmp     short ChainInt1COn      ;chain it on.

Int1CNoSwReq:

	mov     cs:[PendingTime],0      ;reset
	jmp     short ChainInt1COn      ;chain it on.

Int1CAbortSwitch:

; if we are in the process of switching, do not reset the hotkeystate.

	test    cs:[SwitchInProgress],SIP_SWITCHING
	jnz     ChainInt1COn            ;in the middle of switching

	mov     cs:[WoaHotkeyState],0   ;reset the switch request
	call    OEMBeep                 ;let user know about this

ChainInt1COn:

	jmp     cs:[ActualInt1C]        ;chain it on.

Int1CISR endp
;----------------------------------------------------------------------------;
; Int09ISR:                                                                  ;
;                                                                            ;
; This traps the keyboard hardware interrupt. It detects the types of keys   ;
; and sets flags when it detects the HOT KEYS. It also passes control to the ;
; original Int09 handler once it is done with the checkings.                 ;
;                                                                            ;
; We have a local list of HotKeys and each app in the shell stublet will have;
; it's own hotkeys. Both these lists have to be scanned.                     ;
;----------------------------------------------------------------------------;

Int09ISR  proc  far                     

; because of the hot key search, we might take some time in this routine. 
; we will enable interrupts here.

	sti                             ;enable interrupts      
	push    ds
	push    ax                      ;save callers data seg and ax

; if 'fNoSwitch' flag is set, simply chain on the interrupt.

	test    cs:[WoaBehavior],fNoSwitch;switch prevented ?
	jnz     ChainInt09ISR           ;chain on

; read the key and the scan code.

	xor     ax,ax                   ;need access to 0:
	mov     ds,ax                   ;DS points to seg at 0:

; read in the key code.

	in      al,60h                  ;al has the code for the key pressed

	mov     ah,ds:[KEYSTATE]        ;get the state flag
	and     ah,0fh                  ;mask off the unused bits

	smov    ds,cs                   ;get the code seg
	assumes ds,StubSeg

; we are assuming that we will not have any valid hotkey without SHIFT, CTRL
; or ALT. 

	jz      LeaveInt09ISR           ;can't be a hot key
	test    ah,3                    ;any shift key down ?
	jz      @f                      ;no
	or      ah,3                    ;both shift keys down
@@:


; try to find a match in the hotkey list

	pushem  ax,dx                   ;save
	call    MatchHotKeyList         ;try to match against know hotkeys
	popem   ax,dx                   ;restore scan code and shift state
	jnc     EndInt09ISR             ;a match was found, end the int

; we did not find a match in the hot key list, must chain the INT on.

LeaveInt09ISR:

; save the last key so that keys which need to check for the extended key
; sequences may look at it (like 0eh 37h  is PRTSC but just 37h is NUMPAD '*')

	mov     LastScanCode,al         ;save the last scan code

ChainInt09ISR:

	pop     ax
	pop     ds                      ;restore the registers
	assumes ds,nothing
	jmp     cs:[ActualInt09]        ;jump down the chain

EndInt09ISR:

	mov     LastScanCode,al         ;save the last scan code
	call    SwallowKey              ;eat up the interrupt
	pop     ax
	pop     ds                      ;restore the registers
	iret                            ;and go back

Int09ISR endp
;----------------------------------------------------------------------------;
; MatchLocalHotKeyList:                                                      ;
;                                                                            ;
; This takes a scan code in AL and a shift state in AH and looks for a match ;
; in the local hot key list. If a match is found, AL will return the switch  ;
; type and carry will be reset else carry will be set and AL will return 0.  ;
; This routine will also OR in the switch out flags if a match is found.     ;
;----------------------------------------------------------------------------;

MatchHotKeyList proc near

	assumes ds,StubSeg
	
	pushem  bx,cx,di,es             ;save
	smov    es,ds                   ;load our segment

; see if there is a match in the table of scan codes.

	mov     di,StubSegOFFSET ScanCodeTable
	mov     cx,MAX_NUM_PROGRAMS+MAX_FIXED_HOT_KEYS
	cld                             ;set proper direction flag

MHKL_Loop:

	repne   scasw                   ;look for a match
	jnz     MHKL_NoMatch            ;no match found

; get the index of the matching node.

	push    di                      ;save
	sub     di,2                    ;back over to the matching one
	.errnz  SIZE ScanCodeStruc - 2

	sub     di,StubSegOFFSET ScanCodeTable

; see if a prefix scan code is required and if it matches, if it does, get 
; the other details. Also, make sure that the key has not been disabled.

	shl     di,1                    ;offset into other table
	.errnz  SIZE HotKeyInfoStruc - 4
	add     di,StubSegOFFSET HotKeyInfoTable

; now there are two things to match here. The key must be enabled (that is,
; HKIS_State must be 0) and if the prefix scan code is not 0, it should match
; the LastScanCode.

	xor     bx,bx                   ;BL=enable state, BH needed for other
	mov     dx, wptr [di.HKIS_State];get enable flag and prefix scan code
	cmp     bh,dh                   ;carry set if DH is not 0
	sbb     bh,0                    ;BH=0 if DH = 0, else it is 0FFH
	and     bh,LastScanCode         ;BH = LastScanCode if DH !=0, else 0
	cmp     bx,dx                   ;do they match ?
	jnz     MHKL_Continue           ;no, look for another
	mov     dl,[di.HKIS_NodeNum]    ;logical node number

; if we are trying to hot-key to the current app, we should just pretend that
; the hot key did not match.

	cmp     dl,AppsLogicalNodeNum   ;is it the current app ?
	jz      MHKL_Continue           ;yes, look for another

	pop     bx                      ;balance the stack, don't need saved di

; we have found a hot key, get all the details.

	mov     al,[di.HKIS_Type]       ;type of the switch
	or      WoaHotkeyState,al       ;save the return value
	mov     WoaNodeToSwitchTo,dl    ;save the app's NodeID
	clc                             ;match obtained
	jmp     short MHKL_Ret          ;done.

MHKL_Continue:

	pop     di                      ;points after last match
	jcxz    MHKL_NoMatch            ;no more to search
	jmp     short MHKL_Loop         ;continue looking for more

MHKL_NoMatch:

	stc                             ;no match obtained

MHKL_Ret:

	popem   bx,cx,di,es             ;save
	ret

MatchHotKeyList endp
;----------------------------------------------------------------------------;
; PrepareAppHotKeyList:                                                      ;
;                                                                            ;
; This routine traverses the global switcher structure and fills in the table;
; of Scan codes and hotkey information in the two corresponding tables. This ;
; done once before starting the app and after every switch back to the app.  ;
;----------------------------------------------------------------------------;

PrepareAppHotKeyList proc near

	assumes ds,StubSeg

; first zero out the scan code and hotkey info tables that are specific to
; apps.

	push    es                      ;save
	cld
	smov    es,ds                   ;load our segment into es
	xor     ax,ax                   ;will zero out
	mov     di,StubSegOFFSET AppsScanCodeTable
	mov     cx,MAX_NUM_PROGRAMS * SIZE ScanCodeStruc
	rep     movsb                   ;zero out first table
	mov     di,StubSegOFFSET AppsHotKeyInfoTable
	mov     cx,MAX_NUM_PROGRAMS * SIZE HotKeyInfoStruc
	rep     movsb                   ;zero out first table

; now rebuild the tables.

	les     di,lpGlobalSwtchStr     ;get a pointer to the structure
	xor     bx,bx                   ;start at the top of the table
	mov     cx,MAX_NUM_PROGRAMS     ;number of entries
	mov     dl,SIZE Switch_Entry    ;size of each entry

; walk through the list gathering information about scan codes and hot keys.

	xor     ah,ah                   ;zero out for 'mul' below
	mov     al,es:[di].First_In_list;get the first entry
	mul     dl                      ;ax has the node offset
	lea     si,[di].Program_List    ;es:si points to the first program entry
	add     si,ax                   ;point to the right node.
	xor     dh,dh                   ;logical node number

PAHKL_Loop:

; stuff in the scan codes.

	mov     al,es:[si].HK_Scan_Code_2             ;second scan code
	mov     AppsScanCodeTable[bx.SCS_ScanCode],al ;save scan code.
	mov     al,es:[si].HK_Shift_State             ;get the shift state

; if any shift bit is set, set both.

	test    al,ST_RSHIFT+ST_LSHIFT                ;any shift set ?
	jz      @f                                    ;no.
	or      al,ST_RSHIFT+ST_LSHIFT                ;set both.
@@:
	mov     AppsScanCodeTable[bx.SCS_ShiftState],al ;save shift state


; save the rest of the information about the hotkeys in the other table

	shl     bx,1                                          ;index into the other table
	.errnz SIZE HotKeyInfoStruc - SIZE ScanCodeStruc * 2  ;assert the assumption
	mov     AppsHotKeyInfoTable[bx.HKIS_State],0          ;enabled
	mov     al,es:[si].HK_Scan_Code_1                     ;first scan code
	mov     AppsHotKeyInfoTable[bx.HKIS_PrefixScanCode],al;prefix scan code
	mov     AppsHotKeyInfoTable[bx.HKIS_NodeNum],dh       ;save shift state
	mov     AppsHotKeyInfoTable[bx.HKIS_Type],WOA_ALT_ESC ;type of switch
	shr     bx,1                                          ;restore index

; if the node is for the current app, save the logical node number.

	mov     ax,es:[si.Program_Id]   ;get the program ID
	cmp     ax,WoahApp              ;is it the current node ?
	jnz     PAHKL_Next              ;no.
	mov     AppsLogicalNodeNum,dh   ;save node number

PAHKL_Next:

; move onto the next node

	add     bx,SIZE ScanCodeStruc   ;next index
	xor     ah,ah                   ;zero out
	mov     al,es:[si].Next_In_List ;get the next entry
	cmp     al,es:[di].First_In_List;done ?
	jz      PAHKL_Done              ;yes
	mul     dl                      ;ax has the offset from the start
	lea     si,[di].Program_List    ;es:si points to the first program entry
	add     si,ax                   ;point to the right node.
	inc     dh                      ;one more fresh entry obtained
	loop    PAHKL_Loop              ;continue

PAHKL_Done:

	pop     es                      ;restore
	ret

PrepareAppHotKeyList endp
;----------------------------------------------------------------------------;
; Int15ISR:                                                                  ;
;                                                                            ;
; Hooks the AH=88H INT 15 function and if WoaInt15UsershApp is 0, returns    ;
; OriginalInt15MemSize in AX else returns 0.                                 ;
;                                                                            ;
; This code also watches for the INT 15/C207H call to set a mouse handler on ;
; PS/2 machines. If the callback CS is >= the Switcher's CS a flag is set.   ;
;----------------------------------------------------------------------------;

Int15ISR proc far

	assumes ds,nothing

	cmp     ah,88h                  ;function we want to trap ?
	jnz     CheckOther15Traps       ;no, check for other trap codes
	mov     OurInt15OffChain,0      ;we are still in chain.
	mov     ax,OriginalInt15MemSize ;get the original size
	cmp     WoaInt15UsershApp,0     ;is there an INT 15 user
	jz      @f                      ;no, return original size
	xor     ax,ax                   ;return no memory available
@@:
	iret

CheckOther15Traps:

	cmp     ax,0c207h               ;set mouse call back ?
	jnz     LetGoInt15              ;no, chain it on.
	mov     cs:[LocalInt15MouseHandler],0
	pushem  ax,bx                   ;save
	mov     ax,es                   ;call back segment
	mov     bx,cs                   ;Switcher code segment
	cmp     ax,bx                   ;address in global area ?
	popem   ax,bx                   ;restore
	jb      LetGoInt15              ;yes, address in global area
	mov     cs:[LocalInt15MouseHandler],0ffh

; fall through.

LetGoInt15:

	jmp     cs:[ActualInt15]        ;chain down

Int15ISR endp
;----------------------------------------------------------------------------;
;Int16ISR:                                                                   ;
;                                                                            ;
; Hooks the INT 16 Interrupt vector. It would do the context switch if the   ;
; appropriate hot key is set and we are not inside dos or the critical error ;
; handler.                                                                   ;
;----------------------------------------------------------------------------;

Int16ISR proc far

	assumes ds,nothing

; if we have reached our INT 16 handler we should set a flag byte to 0 so
; that the Pasting code will detect that pasting can occur.

	push    ax                      ;save
	xor     al,al                   ;want to reset the flag
	xchg    cs:[TestWoaInt16InChain],al
	cmp     al,0ffh                 ;was it just to test if on chain or not?
	pop     ax                      ;restore
	jz      ChainInt16              ;yes, bypass action on this call

; do a contextswitch if appropriate.

	call    SwitchIfPossible        ;ContextSwitch if possible

; if this is INT 16 was originated by our own code, pass it on to BIOS

	cmp     cs:[WOAsInt16],0ffh     ;call from own code ?
	jz      ChainInt16              ;yes, chain it on.

	cmp     ah,10h                  ;enhanced read key ?
	jz      Int16BlockRead          ;yes
	cmp     ah,0                    ;is it a 'READ KEY' call
	jnz     ChainInt16              ;no

Int16BlockRead:

; we have a read key call, wait till the key is pressed

	call    WaitForKeyFromInt16     ;wait for key to be pressed

ChainInt16:

	jmp     cs:[ActualInt16]        ;go back to original int 16 code

Int16ISR endp
;----------------------------------------------------------------------------;
; Int21ISR:                                                                  ;
;                                                                            ;
; Hooks the INT 21 vector. The code maintains a list of functions that WOA   ;
; traps and the corresponding handler routine addresses.                     ;
;----------------------------------------------------------------------------;

Int21ISR  proc near
  
; at this point we check to see if it is possible to do a context switch. If
; apprpriate flags are set and this is not a nested INT 21 call or call from
; within a critical error handler, we can do the switch

	call    SwitchIfPossible        ;switch out if possible

	push    bp                      ;save before trashing
	push    ds                      ;save ds
	mov     cs:[DosDefaultCode],ah  ;jam current code in
	mov     bp,StubSegOFFSET DosTraps
	sub     bp,3                    ;each entry of 3 bytes

; search for the address of the function which handles the call

@@:

	add     bp,3                    ;look at next entry
	cmp     ah,cs:[bp]              ;matches code ?
	jnz     @b                      ;continue searching

;  jump off to the function, BP is pushed on stack

	
	push    wptr cs:[bp+1]          ;save jump address
	mov     bp,sp                   ;will access stack with it
	add     bp,4                    ;ss:[bp] has original bp
	;sti                             ;enable interrupts
	near_ret                        ;jump to the handler

Int21ISR endp


	;----------------------------------------------------------;
	; DOS function handler top level routines are defined next ;
	;----------------------------------------------------------;


	;----------------------------------------------------------;
	; This one handles all calls that are not trapped by WOA   ;
	;----------------------------------------------------------;

DosDefaultFunc:

	pop     ds                      ;restore ds
	pop     bp                      ;restore bp
	cli                             ;shut of interrupts
	jmp     cs:[ActualInt21]        ;invoke actual handler

	;----------------------------------------------------------;
	; This one is used to return back to caller                ;
	;----------------------------------------------------------;

DosRet:

	pop     ds                      ;restore ds
	pop     bp                      ;retore bp
	iret                            ;return to user

	;----------------------------------------------------------;
	; This one just calls off to the original dos handler and  ;
	; retuns back. It is used for our internal calls.          ;
	;----------------------------------------------------------;

DosCall proc near

	pushf                           ;part of call-iret protocal
	cli                             ;part of calling protocal
	call    cs:[ActualInt21]        ;call off to dos
	ret                             ;return to caller

DosCall endp

	;----------------------------------------------------------;
	; This one handles all readkey board functions which wait  ;
	; for the key to be hit, like function numbers:            ;
	;       01 -- console input with excho.                    ;
	;       07 -- unfiltered char input with echo              ;
	;       08 -- character input without echo                 ;
	;----------------------------------------------------------;

DosFuncGetKey:

; wait till a character is ready and do a dos call to get the status to 
; take care of redirection.

	sti                             ;enable interrupts
	call    WaitForKeyFromDosCalls  ;wait for a key to be ready
	jmp     DosDefaultFunc          ;execute the function


	;----------------------------------------------------------;
	; This one handles Function 0A (BufferedKeyboardInput)     ;
	;----------------------------------------------------------;

DosFunc0A:

	sti                             ;enable interrupts
	call    SaveRegisters           ;save all resgisters
	mov     es,USER_DS              ;get users DS
	mov     di,USER_DX              ;es:di has users buffer
	mov     cx,[di]                 ;get the buffer length,template length
	smov    ds,cs                   ;load stubseg in ds
	add     dx,2                    ;es:dx points to proper buffer
	push    bp                      ;bp will be thrashed 
	mov     RCB_FileHandle,1        ;handle for STDOUT
	mov     b3fRCB,0                ;not a 3FH call
	call    ReadConsoleBuffer       ;handle the call
	pop     bp                      ;restore bp
	mov     ds,USER_DS              ;get back users ds
	mov     di,USER_DX              ;get back start of buffer
	or      al,al                   ;was the count zero
	jz      @f                      ;yes
	dec     al                      ;return 1 less for CR
@@:
	mov     [di+1],al               ;fill in new template length
	call    RestoreRegisters        ;restore all registers including BP
	iret                            ;get back to caller

	;----------------------------------------------------------;
	; This one handles Function 0C - Flush Buffer and read key ;
	; board, it first flushes the keyboard buffer and then dis-;
	; -patches any of the other calls if there is one.         ;
	;----------------------------------------------------------;

DosFunc0C:

	sti                             ;enable interrupts
	push    ax                      ;save calling code
	xor     al,al                   ;want to just flush the keyboard
	call    DosCall                 ;key board flushed
	pop     ax                      ;get back function
	xchg    ah,al                   ;get the function key in ah
	cmp     ah,0ah                  ;read console buffer call ?
	jz      DosFunc0A               ;yes, dispatch it
	cmp     ah,01h                  ;conin with echo call ?
	jz      DosFuncGetKey           ;yes,dispatch it
	cmp     ah,07h                  ;unfiltered input call ?
	jz      DosFuncGetKey           ;yes,dispatch it
	cmp     ah,08h                  ;con in without echo call ?
	jz      DosFuncGetKey           ;yes, dispatch it

; we don't want to handle the 'al=6' case as it does not wait for any key.

	cmp     ah,06h                  ;direct console i/o ?
	jz      DosDefaultFunc          ;let dos handle it.

; keyborad is flushed and AL does not have a valid function code, so we 
; get back to the user.

	jmp     short DosRet            ;go back, bypassing DOS

	;----------------------------------------------------------;
	; This one handles the terminate and stay resident call.   ;
	; A flag is set to indicate that a TSR has been run.       ;
	;----------------------------------------------------------;

DosFunc31:

	mov     cs:[TsrActive],0ffh     ;a TSR call done
	jmp     DosDefaultFunc          ;let the call go

	;----------------------------------------------------------;
	; This one handles function 3fh - Read From File Or Device.;
	; It would trap the call if the handle specified a console ;
	; device, else will pass it on to the actual handler.      ;
	;----------------------------------------------------------;

DosFunc3f:

	sti                             ;enable interrupts
	call    IsFileConsole?          ;check if the file is CON:
	njnz     DosDefaultFunc          ;no,excute actual ISR
	call    SaveRegisters           ;save all the users registers
	mov     es,USER_DS              ;load users ds
	smov    ds,cs                   ;ds has StubSeg segment
	push    bp                      ;may get thrashed
	mov     RCB_FileHandle,bx       ;save file handle
	mov     b3fRCB,-1               ;3F call
	call    XenixRead               ;trap and execute the call
	pop     bp                      ;restore
	mov     USER_AX,ax              ;save the return value
	call    RestoreRegisters        ;restore all the registers
	iret                            ;go back to user

	;----------------------------------------------------------;
	; This handles DOS function 44 and traps only subfunction, ;
	; 01 and tests to see if the console device is set into raw;
	; mode or not.                                             ;
	;-----------------------------------------------------------;

DosFunc44:

	sti                             ;enable interrupts
	cmp     al,01                   ;subfuntion number 01 ?
	jnz     default44               ;no, we will not trap it
	test    dx,1                    ;is it the standard input
	jz      default44               ;no, we are not interseted

; set the ConsoleRawMode flag to 1, if bit 5 of dl is set, else set it  0
	call    DosCall
	pushf
	jc      iret44     

	mov     cs:ConSoleRawMode,0     ;assume not in raw mode
	test    dl,00100000b            ;set to raw mode ?
	jz      iret44                  ;no, it is in ccoked mode

; set ConsoleRawMode flag on.

	dec     cs:ConsoleRawMode       ;set it to 0ffh
iret44: 
	popf
	pop     ds
	pop     bp
	retf 2
	
default44:
	jmp     DosDefaultFunc          ;let DOS handle the call to0!
;----------------------------------------------------------------------------;
; Int23ISR:                                                                  ;
;                                                                            ;
; If DS is same as CS, then we are in our stub code and we will ask Dos to   ;
; not abort us, else the app will be aborted.                                ;
;----------------------------------------------------------------------------;

Int23ISR  proc far      
  
	sti                             ;enable interrupts
	pushem  ax,bx                   ;save 
	mov     ax,cs                   ;get cs
	mov     bx,ds                   ;get ds
	cmp     ax,bx                   ;in our code
	jnz     @f                      ;no.
	popem   ax,bx                   ;restore
	clc                             ;do not abort
	ret
@@:
	mov     ah,0dh                  ;flush disk buffers call
	int     21h                     ;all buffers flushed
	popem   ax,bx                   ;restore
	stc                             ;set carry on
	ret                             ;leave flags on stack, dos will abort 

Int23ISR endp
;----------------------------------------------------------------------------;
; Int24ISR:                                                                  ;
;                                                                            ;
; This routine traps the critical error handler. If the user code when the   ;
; error happened is not the stub code, the original handler is called to pro-;
; -cess the call, else just the fail error code is passed back.              ;
;----------------------------------------------------------------------------;

Int24ISR   proc far

	pushf                           ;save the flags
	push    bp                      ;save bp, we need to access stack
	mov     bp,sp                   ;get the current stack pointer
	mov     ax,cs                   ;get stub code segment
	cmp     ss:[bp+1eh],ax          ;callers code segment is here
	pop     bp                      ;restore bp
	je      @f                      ;error in stub code
	call    cs:[ActualInt24]        ;call the original handler
	iret                            ;get back

@@:
	popf                            ;get back the flags
	mov     AL, 3                   ;Return FAIL code
	iret                            ;return back

Int24ISR  endp
;----------------------------------------------------------------------------;
; Int27ISR:                                                                  ;
;                                                                            ;
; This routine traps the old termonate and stay resident call. A flag is set ;
; in the code segment and the original int 27 handler is invoked.            ;
;----------------------------------------------------------------------------;

Int27ISR   proc far

	mov     cs:[TsrActive],0ffh     ;a tsr call going thru.
	jmp     cs:[ActualInt27]        ;invoke original handler

Int27ISR  endp
;----------------------------------------------------------------------------;
; Int2AISR:                                                                  ;
;                                                                            ;
; This hooks INT 2AH and looks for asynchronous Network requests. If the     ;
; command code in AH is 1 or 4 we set 'AsyncNetPending' to 0ffh if the       ;
; NCB command code implies a NoWait request. We never try to keep track of   ;
; when the request is completed though.                                      ;
;                                                                            ;
; If the NetRequest is from a CS loaded befor us or is above 0A000H we will  ;
; ignore it.                                                                 ;
;----------------------------------------------------------------------------;

Int2AISR proc far

	call    CheckCallersCS          ;check where the call came from
	jnc     Int2AISRChain           ;not from the app, chain it on.

	cmp     ah,1                    ;1 and 4 for async net requests
	je      IsAsync2ARequest        ;check for 'NoWait'NCB command
	cmp     ah,4                    ;1 and 4 for async net requests
	je      IsAsync2ARequest        ;check for 'NoWait'NCB command
	jmp     short Int2AISRChain     ;chain call on.

IsAsync2ARequest:

	test    bptr es:[bx],80h        ;is it a 'NoWait' request ?
	jz      Int2AISRChain           ;no, chain it on.

Int2aBlockSwitchOut:

; set a flag so that we will not try to switch out from this application.

	mov     cs:[AsyncNetPending],0ffh

Int2AISRChain:

	jmp     cs:[ActualInt2A]        ;pass on to original handler

Int2AISR endp
;----------------------------------------------------------------------------;
; OtherInt2fISR:                                                             ;
;                                                                            ;
; This hooks the INT 2FH vector. It just looks at the IS_WINOLDAP_ACTIVE     ;
; invovcation code and returns AX = 0 for it (it is active) else it chains   ;
; the INT on. Note: if XMS handling is being done, WOA's XMS handler will    ;
; hook INT 2fH ahain (in WOAXMS.ASM)                                         ;
;                                                                            ;
; It also traps the Windows Standard/Enhanced mode start up and exit calls & ;
; sets a flag so that the switcher does not try to switch out while Windows  ;
; in protected mode is active under it.                                      ;
;                                                                            ;
; We also look for the Switcher API INT 2F call to get the address of our    ;
; CallIn routine.                                                            ;
;----------------------------------------------------------------------------;

OtherInt2fISR   proc far

	cmp     ax,IS_WINOLDAP_ACTIVE   ;call of interest ?
	jz      WinoldapActive          ;yes
	cmp     ax,WIN_P_START_UP       ;Windows protected mode start up ?
	jz      WinPStarts              ;yes
	cmp     ax,WIN_P_EXIT           ;Windows protected mode exits ?
	jz      WinPExits               ;yes.

	cmp     ax,SWAPI_DETECT_SWITCHER;Detect_Switcher call ?
	jz      Int2FDetectSwitcher     ;yes.

Chain2fOn:             

; chain the call on.

	jmp     cs:[OtherActualInt2f]   ;chain on

WinoldapActive:

; Winoldap is active, terminate this call with an appropriate code in AX

	xor     ax,ax                   ;say winoldap is active
	iret                            ;terminate chain here

WinPStarts:

; set a flag bit saying that protected mode Windows is around.

	or      cs:[SwitcherDisabled], SD_PMODE_WINDOWS
	jmp     cs:[OtherActualInt2f]   ;chain on

WinPExits:

; reset the flag bit which was set when protected mode Windows started.

	and     cs:[SwitcherDisabled], NOT SD_PMODE_WINDOWS
	jmp     cs:[OtherActualInt2f]   ;chain on

Int2fDetectSwitcher:

	or      bx,bx                   ;must be zero
	jnz     Chain2fOn               ;chain it on
	push    ax                      ;save
	mov     ax,es                   ;es:di must be 0 
	or      ax,di                   ;is it zero ?
	pop     ax                      ;restore
	jnz     Chain2fOn               ;no, chain it on
	smov    es,cs                   ;ES=CS
	mov     di,StubSegOFFSET SwitchAPICallIn
	xor     ax,ax                   ;return code
	mov     bx,sp                   ;get pointer to IRET frame
	and     word ptr ss:[bx+4],NOT 1;reset the carry flag
	xor     bx,bx                   ;set it back to 0
	iret                            ;terminate the call here

OtherInt2fISR   endp
;----------------------------------------------------------------------------;
; Int5CISR:                                                                  ;
;                                                                            ;
; This hooks INT 5CH and looks for asynchronous Network requests. If the     ;
; command code in the NCB has the MSB set, we will set 'AsyncNetPending' to  ;
; 0ffh. We never try to keep track of when the request is completed though.  ;
;                                                                            ;
; If the NetRequest is from a CS loaded befor us or if the caller's CS is    ;
; above 0A000H we will ignore it.                                            ;
;----------------------------------------------------------------------------;

Int5CISR proc far

	call    CheckCallersCS          ;check where the call came from
	jnc     Int5CISRChain           ;not from the app, chain it on.

; test whether it is a 'No Wait' call.

	test    bptr es:[bx],80h        ;'NoWait' request ?
	jz      Int5CISRChain           ;no,chain call on.

Int5cBlockSwitchOut:

; set a flag so that we will not try to switch out from this application.

	mov     cs:[AsyncNetPending],0ffh

Int5CISRChain:

	jmp     cs:[ActualInt5C]        ;chain on.

Int5CISR endp
;----------------------------------------------------------------------------;
; Default hooks for all hardware vectors that the Switcher does not hooks for;
; its own purpose. These hooks increment a byte, call down stream and dec the;
; byte. The byte will tell the switchet how many hardware interrupts are     ;
; being serviced and the Switcher will not switch if the count is non zero.  ;
;----------------------------------------------------------------------------;

		;--------------------------------------;
		; INT 08H   ---- IRQ 0                 ;
		;--------------------------------------;

HInt08ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt08ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt08ISR endp

		;--------------------------------------;
		; INT 09H   ---- IRQ 1                 ;
		;--------------------------------------;

HInt09ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt09ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt09ISR endp

		;--------------------------------------;
		; INT 0AH   ---- IRQ 2                 ;
		;--------------------------------------;

HInt0AISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0AChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0AISR endp
		;--------------------------------------;
		; INT 0BH   ---- IRQ 3                 ;
		;--------------------------------------;

HInt0BISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0BChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0BISR endp
		;--------------------------------------;
		; INT 0CH   ---- IRQ 4                 ;
		;--------------------------------------;

HInt0CISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0CChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0CISR endp
		;--------------------------------------;
		; INT 0DH   ---- IRQ 5                 ;
		;--------------------------------------;

HInt0DISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0DChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0DISR endp
		;--------------------------------------;
		; INT 0EH   ---- IRQ 6                 ;
		;--------------------------------------;

HInt0EISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0EChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0EISR endp
		;--------------------------------------;
		; INT 0FH   ---- IRQ 7                 ;
		;--------------------------------------;

HInt0FISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt0FChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt0FISR endp
		;--------------------------------------;
		; INT 70H   ---- IRQ 8                 ;
		;--------------------------------------;

HInt70ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt70ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt70ISR endp
		;--------------------------------------;
		; INT 71H   ---- IRQ 9                 ;
		;--------------------------------------;

HInt71ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt71ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt71ISR endp
		;--------------------------------------;
		; INT 72H   ---- IRQ 10                ;
		;--------------------------------------;

HInt72ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt72ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt72ISR endp
		;--------------------------------------;
		; INT 73H   ---- IRQ 11                ;
		;--------------------------------------;

HInt73ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt73ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt73ISR endp
		;--------------------------------------;
		; INT 74H   ---- IRQ 12                ;
		;--------------------------------------;

HInt74ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt74ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt74ISR endp
		;--------------------------------------;
		; INT 75H   ---- IRQ 13                ;
		;--------------------------------------;

HInt75ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt75ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt75ISR endp
		;--------------------------------------;
		; INT 76H   ---- IRQ 14                ;
		;--------------------------------------;

HInt76ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt76ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt76ISR endp
		;--------------------------------------;
		; INT 77H   ---- IRQ 15                ;
		;--------------------------------------;

HInt77ISR proc far

	inc     cs:[HardwareIntCount]   ;one more hardware int being serviced
	pushf                           ;call far - iret protocol
	cli                             ;correct way to simulate int
	
; CAUTION: The following 5 bytes are for chaining down the interrupt. The
; chain address will be stuffed in at run time.

	db      9ah                     ;call far opcode

HInt77ChainAddr dd      ?               ;completes the callf instruction

	dec     cs:[HardwareIntCount]   ;interrupt has been serviced
	iret                            ;return

HInt77ISR endp
;----------------------------------------------------------------------------;
;                       UTILITY ROUTINES USED BY ABOVE CODE                  ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; SwitchIfPossible:                                                          ;
;                                                                            ;
; Does a context switch if the apprpriate hot key is set and InDos and       ;
; ErrMode flags are both reset.                                              ;
;----------------------------------------------------------------------------;
SwitchIfPossible proc near

; if a switch request is already in progress, do not try to switch

	push    ax                      ;save
	mov     al,SIP_SWITCHING        ;set this when we switch.
	xchg    al,cs:[SwitchInProgress];for Test And Set
	or      al,al                   ;were we in middle of a switch ?
	pop     ax                      ;restore
	jnz     SwitchIfPossibleRet     ;do no try to switch

; test to see if the hot keys are set.

	test    cs:[WoaHotkeyState],WOA_SWITCH
	jz      SwitchIfPossibleStackOk ;switch not desired

; at this point switch to a temporary stack. Save the current stack pointer

	pushf                           ;save flags
	cli                             ;mask interrupts off
	mov     cs:[WoaAppsSS],ss
	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV ;386 or 486 cpu ?
	jnz     SIP_SaveESP                     ;need to save ESP
	mov     cs:[WoaAppsSP],sp       
	jmp     short SIP_SPSaved               
SIP_SaveESP:
	.386p
	mov     cs:[WoaAppsESP],esp     ;save esp
	.286
SIP_SPSaved:

; load a new stack pointer

	push    cs
	pop     ss                      ;stack's in our segment
	mov     sp,StubSegOFFSET WoaSwitchOutStackTop
	;;do not enable interrupts while old guys interrupts are still in! sti                             ;restore interrupts

; test to see if the switch is possible

	call    OkToSwitch?             ;is it ok to switch
	jc      SwitchIfPossibleRestoreStack;no.

ifdef	JAPAN
	cCall	KkcBusyCheck		; ok KKC
	jnc	@f			; yes
	call	OEMBeep			;
	mov     cs:[WoaHotKeyState],0   ;can't do it and don't try again later
	jmp	SwitchIfPossibleRestoreStack;
@@:
endif

; we are ready to switch, set a flag saying that we are switching

	call    ContextSwitch           ;do the context switch

SwitchIfPossibleRestoreStack:

; now restore the user's stack.

	cli                             ;disable interrupts
	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV ;386 or 486 cpu
	jnz     SIP_Restore386Stack     ;yes
	mov     ss,cs:[WoaAppsSS]       ;get back interruption time ss
	mov     sp,cs:[WoaAppsSP]       ;get back switch out time sp
	jmp     short SIP_SSSPRestored
SIP_Restore386Stack:
	.386p
	mov     ss,cs:[WoaAppsSS]       ;get back interrupt time ss
	mov     esp,cs:[WoaAppsESP]     ;getback interrupt time esp
	.286
SIP_SSSPRestored:
	popf                            ;restore interrupt state

SwitchIfPossibleStackOk:

	mov     cs:[SwitchInProgress],0 ;reset flag bits

SwitchIfPossibleRet:

	ret

SwitchIfPossible endp
;----------------------------------------------------------------------------;
; ContextSwitch:                                                             ;
;                                                                            ;
; Initiates the actual context switching.This routine save all the registers ;
; & switches back to protected mode WOA code, with a special code in AX      ;
; The protected mode code, when it decides that it is time to switch baclk,  ;
; transfers control tot the label named 'BackFromContextSwitch'              ;
;----------------------------------------------------------------------------;

ContextSwitch proc  near

	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV;is it a 386 or 486?
	jnz     Save386Registers        ;yes,need to save 386 pmode regs too.
	pushf                           ;slave interrupt state
	push    ds              
	push    es                      ;saves ES,DS as a part of the context
	pushem  ax,bx,cx,dx,bp,si,di    ;save all other resgisters
	jmp     short CpuRegistersSaved ;all registers saved

Save386Registers:

	.386p
	pushfd                          ;save interrupt state
	pushem  ds,es,gs,fs             ;save 386 segment registers
	pushad                          ;save all 32 bit registers
	.286

CpuRegistersSaved:

	cld                             ;users flag will be on IRET frame.
	smov    ds,cs                   ;make ds = cs to access variables

; set a flag if the app has hooked INT 08. This information is later needed
; by the SaveSoundState and RestoreSoundState routines.

	call    IsTimerHooked           ;see if app hooks timer over us.

; get and save the state of the control C flag and set it off for the switch.

	mov     ax,3300h                ;get state of CTRL C flag
	call    DosCall                 ;flag in dl
	mov     ControlCFlag,dl         ;save it
	mov     ax,3301h                ;set state of CTRL+C flag
	xor     dl,dl                   ;to off
	call    DosCall                 ;turned off.

; see if we can reach our Int 15 Hook.

	mov     OurInt15OffChain,0ffh   ;assume we are not in chain
	mov     ah,88h                  ;get memory size function.
	int     15h                     ;do the call ?
	cmp     ax,OriginalInt15MemSize ;equal to the original size ?
	jz      @f                      ;the above flag tells the story
	mov     OurInt15OffChain,0ffh   ;force it say it uses INT 15
@@:

; process the apps slave pic state. If the app is using IRQ2 or IRQ9, then
; shut off IRQ 9 in the slave PIC.

	call    ProcessAppSlavePICMask  ;save it and mask IRQ 9 if needed

; save relevant OLD APP vector like 9,16,21,24  and restore original value.
; We do this here so that the app does not see the screen being saved through
; it's hooks. Also all instance data images will also be swapped.

; restore the saved instance data image which includes IDT

	cCall   SwapInstanceDataBlocks

	call    SwapMasterPICMask       ;swaps APP's Master 8259 Mask
	sti                             ;enable interrupts

; try to save app screen and bail out if we cant

	cCall   GrabberSaveScreen       ;save the screen
	jnc     OldAppScreenSaved       ;old app screen has been saved

ContextSwitchFails:

; switch out failed, so clear switch flag and return. Also restore the apps
; vectors and other instance data areas. We must also do a RESUME_SESSION
; SWAPI call before restoring the local interrupt vectors.

	cCall   SWAPIResumeSession

; restore the saved instance data image which includes IDT

	cCall   SwapInstanceDataBlocks
	call    SwapMasterPICMask       ;swaps APP's Master 8259 Mask
	sti                             ;leaves int's disabled, but no need to

; restore the slave PIC state.

	mov     al,cs:[AppSlavePICMask] ;get the mask
	call    WriteSlavePICMask       ;restore it.

; local vectors are back, we must do a SESSION_ACTIVE SWAPI call

	cCall   SWAPISessionActive

; now restore the CTRL+C flag state for the application. Till now we had it 
; turned off so that it would not terminate us.

	mov     ax,3301h                ;set control c flag
	mov     dl,ControlCFlag         ;saved state of the flag
	call    DosCall                 ;set flag

	mov     cs:[WoaHotKeyState],0   ;reset switch out request
	jmp     ContextSwitchRet        ;go back

OldAppScreenSaved:

; ask grabber to de-install int 10 hooks.

	cCall   GrabberDisableSave      ;grabber releases INT 10 hooks.

; unhook our XMS hooks.

	cmp     WoafXmsInstalled,0      ;is there any xms handler
	jz      @f                      ;XMS code handler not installed.
	cCall   UnHookOurXmsCode        ;XMS code unhooked
@@:


; now initialize the disaplay to a known state and set it to 25 line mode for
; switcher screen

	mov     ax,25                   ;25 line mode for switcher screen
	cCall   GrabberInitScreen       ;screen initialized

; save dos sate like DMA address, current directory and drive, PSP etc.

	call    SaveDosState

; save other old app related stuff like 8087 state, sound h/w state etc.

	call    SaveOtherTaskVars       ;save some other old app state

; if the machine is a vactra, save the state of the vectra for the old app

	cCall   SaveDosAppHPState       ;must be restored on switch back

; if the machine is a vectra, restore the windows hp state

	cCall   RestoreWindowsHPState   ;restore saved state

; restore the state of the A20 line if the application had turned it off (done
; only if HIMEM is installed.

	call    SetCorrectA20State      ;sets A20 back on if HIMEM installed

; now go back to preexec disk and directory.

	call    ResetDosDirectory       ;set back original drive and dir

; before going back to the Switcher's PSP, we need to save the SS:SP value
; in the DWORD at address 2EH in the PSP and this will be restored at 4CH
; exit time.

	push    es                      ;save
	mov     es,WoaPSP               ;get to the Switcher's PSP
	mov     ax,wptr es:[2eh]        ;get the saved SP value
	mov     Woa4BSP,ax              ;save it
	mov     ax,wptr es:[30h]        ;get the saved SS value
	mov     Woa4bSS,ax              ;save it
	pop     es                      ;restore

; set back WINOLDAP's PSP

	mov     bx,WoaPSP               ;get WINOLDAP's PSP
	mov     ax,5000h                ;set PSP call
	int     21h                     ;WOA's PSP is current

; save value of SS,SP as a part of the oldapp context

	mov     WoaSwitchOutSS,ss
	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV ;386 or 486 cpu ?
	jnz     SaveESP                 ;need to save ESP
	mov     WoaSwitchOutSP,sp       
	jmp     short SPSaved           
SaveESP:
	.386p
	mov     WoaSwitchOutESP,esp     ;save esp
	.286
SPSaved:

; reaload SS,SP to whatever value they were set to at the time the stub was
; called

	mov     ss,WoaRlmEntrySS
	mov     sp,WoaRlmEntrySP

; get the flag byte in AX for context switch.

	xor     ax,ax                   ;set this to zero
	xchg    al,cs:[WoaHotkeyState]  ;load the hot key state and reset
	and     al,WOA_SWITCH           ;have ALT_ESC or ALT_TAB info,mask rest

; if 'OurInt15OffChain' is 0ffh then some instance has locked int 15. This
; will either be 'Int15UsershApp' is that is not zero, or else it will be
; 'WoahApp'.

	xor     bx,bx                   ;assume not locked.
	cmp     OurInt15OffChain,0ffh   ;is that true ?
	jnz     @f                      ;yes.
	mov     bx,WoaInt15UsershApp    ;assume this is not zero
	or      bx,bx                   ;is that true ?
	jnz     @f                      ;yes.
	mov     bx,WoahApp              ;this instance itself has locked it
@@:

; load the 'WoaAppUsesXMS' byte into CL (zero out XMS). If the application
; has no XMS allocated to it this variable would be in discarded code but
; that's OK, the main code seg will only check this byte if the app does
; have XMS allocated.

	xor     ch,ch
	mov     cl,WoaAppUsesXMS        ;whether app actually used XMS or not

; get the node of the app that we want to switch to in DX, if that is -1 we
; will do conventional switching.

	mov     dl,WoaNodeToSwitchTo    ;for directed hot keys

; do a far ret to protectd mode WOA

	clc                             ;mark as no error
	far_ret 

BackFromContextSwitch:

	cld                             ;take no chances with this.

; AX has the value for Int15UsershApp

	mov     bx,cs                   ;get segment value
	mov     ds,bx                   ;have it in ds too

	mov     WoaInt15UsershApp,ax    ;save it

; go back to stack on which we switched

	cli                             ;disable interrupts
	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV ;386 or 486 cpu
	jnz     Restore386Stack         ;yes
	mov     ss,WoaSwitchOutSS       ;get back interruption time ss
	mov     sp,WoaSwitchOutSP       ;get back switch out time sp
	jmp     short SSSPRestored
Restore386Stack:
	.386p
	mov     ss,WoaSwitchOutSS       ;get back interrupt time ss
	mov     esp,WoaSwitchOutESP     ;getback interrupt time esp
	.286
SSSPRestored:
	sti                             ;enable them

; have grabber put back it's INT 10 hooks

	cCall   GrabberEnableSave       ;grabber puts back int 10 hooks

; restore the dos app screen

	cCall   GrabberRestoreScreen    ;get back dos app screen

; restore our XMS Hook.

	cmp     WoafXmsInstalled,0      ;is there any xms handler
	jz      @f                      ;XMS code handler not installed.
	cCall   HookOurXmsCode          ;hook code if needed.
@@:

; we have to resume the oldapp. First restore dos state

	call    RestoreDosState         ;restores app specific dos state

; now restore other task state informations which we had saved

	call    RestoreOtherTaskVars

; if the machine is a vectra then save the current windows hp state

	cCall   SaveWindowsHPState      ;save the current state

; if the machine is a vectra, restore the state of the HP system

	cCall   RestoreDosAppHPState    ;restores HP state on a vectra

; reset the current disk and cd. We might get aborted if an INT 24 happens
; now. In that case switching and pasting will be disabled

	call    RestoreDiskAndCD        ;reset disk and current directory

; prepare the current hotkey information again

	call    PrepareAppHotKeyList

; now flush the buffer, incase any CTRL+C is pending.
	
	mov     ax,0c00h                ;flush keyboard only
	int     21h


;----------------------------------------------------------------------------;
; Make the ResumeSession Switch API call. We must make this call before we 
; restore the local interrupt vector table. This is to make sure that the
; global software gets ready before interrupts start coming in from the 
; local app.

	cCall   SWAPIResumeSession
;----------------------------------------------------------------------------;

; hook back all interrupt vectors -- we leave interrupts disabled since we
; are quickly going back to our Int 21 or 16 handler (wherever we decided
; to switch out from). Also swap back the saved instance data areas

; restore the saved instance data image which includes IDT

	cCall   SwapInstanceDataBlocks
	call    SwapMasterPICMask       ;restore app's master PIC mask

; restore the slave PIC state. We must restore it's state only if it has 
; IRQ 9 owned. Also we must save the current PIC mask as Windows mask

	call    ReadSlavePICMask        ;get the current mask
	mov     GlobalSlavePICMask,al   ;save it.
	mov     al,AppSlavePICMask      ;get the apps slave PIC mask
	call    RestoreSlavePICMask     ;restore mask if needed

; now notify the app that we are back from a context switch.
; NOTE: It is verry essential that we do the following call after restoring
; the saved interrupt vector. This is because the correspeonding check
; notification call that was done in the 'CheckWithApp' routine restores
; some vectors and we save the interrupt vectors after that call.

	call    NotifyApp               ;only if notification hook is in

;----------------------------------------------------------------------------;

; The local interrupt vectors are back, we must make the app know that he can
; resume its task.

	cCall   SWAPISessionActive
;----------------------------------------------------------------------------;
	
; now restore the CTRL+C flag state for the application. Till now we had it 
; turned off so that it would not terminate us.

	mov     ax,3301h                ;set control c flag
	mov     dl,ControlCFlag         ;saved state of the flag
	call    DosCall                 ;set flag
	
ContextSwitchRet:

	test    cs:[WoaCpuType],WF_CPU386 + WF_CPU486ORABV ;386or 486 processor ?
	jnz     Restore386Registers     ;yes, restore 386 pmode all registers

	popem   ax,bx,cx,dx,bp,si,di    ;save all other resgisters
	pop     es                      ;get back es
	pop     ds                      ;get back ds
	popf                            ;restore saved interrupt state
	jmp     short CpuRegistersRestored

Restore386Registers:

	.386p
	popad                           ;restore 32 bit registers
	popem   ds,es,gs,fs             ;restore segment registers
	popfd                           ;restore saved interrupt state
	.286

CpuRegistersRestored:
	
	ret                             ;return back to int handler


ContextSwitch endp
;----------------------------------------------------------------------------;
; SaveDosState:                                                              ;
;                                                                            ;
; This routine save app specific dos states like DMA address, PSP, current   ;
; directory, current drive etc.  It also saves EMS page mapping resgisters   ;
; is EMS is present.                                                         ;
;                                                                            ;
; Also we save the IOCTL Device data for the shared file handles 0 thru 4    ;
;                                                                            ;
; The Allocation strategy is also saved for UMB support.                     ;
;----------------------------------------------------------------------------;

SaveDosState proc near

; get the allocation strategy

	mov     ax,5800h                ;get allocation strategy
	int     21h
	mov     DosAllocationStrategy,al;save it

; get link state

	mov     ax,5802h                ;get link state info
	int     21h
	mov     DosLinkState,al         ;save it

; if UMBs are linked in, unlink them before swapping the app out.

	or      al,al                   ;unlinked ?
	jz      @f                      ;yes
	mov     ax,5803h                ;set links
	xor     bx,bx                   ;unlink.
	int     21h
@@:
	
; get and save the DMA address

	mov     ah,2fh                  ;get DTA address
	int     21h                     ;ES:BX has address
	mov     wptr [DosAppDMA+2],es
	mov     wptr [DosAppDMA],bx     ;save the DMA address

; get and save the DOS APP PSP

	mov     ax,5100h                ;get PSP call code
	int     21h                     ;BX has app psp segment
	mov     DosAppPSP,bx            ;save it

	mov     si,StubSegOFFSET DosAppCD
	inc     si                      ;skip the root symbol
	cCall   GetCurrentDiskAndCD,<si>;get the current disk
	mov     DosAppDisk,al           ;save it

; save the apps IOCTL data and restore pre exec IOCTL data

	mov     di,StubSegOFFSET AppIoctlData
	call    SaveIoctlData           ;save apps Ioctl data
	mov     si,StubSegOFFSET WinIoctlData
	call    RestoreIoctlData        ;restore pre-exec state

; save the printer port addresses of the app and restore windows printer port
; addresses.

	mov     di,StubSegOFFSET AppPrinterPorts
	call    SavePrinterPorts        ;save apps printer port addresses
	mov     si,StubSegOFFSET WinPrinterPorts
	call    RestorePrinterPorts 

; save the apps dev chain ptrs in case it has added some and restore pre exec
; chain

	call    SwapDeviceHeaders       ;swap 2 ptrs at start and 1 at end

; save EMS state if EMS drivers is present

	cmp     WoaEmsFlag,0ffh         ;is EMS driver present
	jnz     @f                      ;no, nothing to save
	push    es                      ;save
	mov     di,StubSegOFFSET AppEmsSaveArea
	smov    es,ds                   ;es:di has save buffer
	mov     ax,4e00h                ;want to get the mapper registers
	int     67h                     ;registers saved
	pop     es                      ;restore
@@:
	ret

SaveDosState    endp
;----------------------------------------------------------------------------;
; GetCurrentDiskAndCD:                                                       ;
;                                                                            ;
; A special routine to get the current Disk which hooks the INT 24 handler   ;
; in case the current drive is not accessible. The INT 24 handler is taken   ;
; away before the return.                                                    ;
;                                                                            ;
; This also gets the current directory.                                      ;
;----------------------------------------------------------------------------;

cProc   GetCurrentDiskAndCD,<NEAR,PASCAL,PUBLIC>,<es,bx>

	parmW   CurCDBuf                ;place to store currnet CD
	localD  OldInt24                ;original INT 24 handler.

cBegin

; first save the current INT 24 handler's address and hook a special INT 24
; handler.

	mov     ax,3524h                ;get original INT 24 vector
	int     21h                     ;es:bx has the vector
	mov     off_OldInt24,bx         ;save it
	mov     seg_OldInt24,es         ;save it
	mov     dx,StubSegOFFSET SpecialInt24ISR
	mov     ax,2524h                ;DS is = CS
	int     21h                     ;set the new vector

; now get the current directory

	mov     ah,47h                  ;get current directory code
	mov     dl,0                    ;for the default drive
	mov     si,CurCDBuf             ;get the buffer for current CD
	int     21h                     ;current directory obtained

; and the current disk

	mov     ah,19h                  ;current disk call
	int     21h                     ;AL has the return
	push    ax                      ;save
	mov     dx,off_OldInt24         ;get the original offset
	push    ds                      ;save
	mov     ds,seg_OldInt24         ;ds:dx points to original ISR
	mov     ax,2524h                ;set vector 24H call
	int     21h                     ;vector restored
	pop     ds                      ;restore own ds
	pop     ax                      ;get back return value

cEnd
;----------------------------------------------------------------------------;
; SetCurrentDiskAndCD:                                                       ;
;                                                                            ;
; A special routine to set the current disk which traps the INT 24 vector to ;
; fail the call if the drive is no more accessible.                          ;
;                                                                            ;
; This also gets the current directory.                                      ;
;----------------------------------------------------------------------------;
cProc   SetCurrentDiskAndCD,<NEAR,PASCAL,PUBLIC>,<es,bx>

	parmW   CurDrive                ;drive to set
	parmW   CurCD                   ;current directory.
	localD  OldInt24                ;original INT 24 handler.

cBegin


; first save the current INT 24 handler's address and hook a special INT 24
; handler.

	mov     ax,3524h                ;get original INT 24 vector
	int     21h                     ;es:bx has the vector
	mov     off_OldInt24,bx         ;save it
	mov     seg_OldInt24,es         ;save it
	mov     dx,StubSegOFFSET SpecialInt24ISR
	mov     ax,2524h                ;DS is = CS
	int     21h                     ;set the new vector

; restore the current disk

	mov     dx,CurDrive             ;get the drive to set
	mov     ah,0eh                  ;set drive code
	int     21h                     ;AL has the return

; now restore the current directory

	mov     ah,3bh                  ;change directory code
	mov     dx,CurCD                ;get the offset to the dir
	int     21h                     ;directory set back

; reset the original critical error handler

	mov     dx,off_OldInt24         ;get the original offset
	push    ds                      ;save
	mov     ds,seg_OldInt24         ;ds:dx points to original ISR
	mov     ax,2524h                ;set vector 24H call
	int     21h                     ;vector restored
	pop     ds                      ;restore own ds

cEnd
;----------------------------------------------------------------------------;
; SpecialInt24ISR:                                                           ;
;                                                                            ;
; This ISR is active only during the above get & set current drive routines  ;
; and fails any 'drive not accessible' error so that the user does not see   ;
; the message that DOS puts up in response to these error.                   ;
;----------------------------------------------------------------------------;

SpecialInt24ISR proc far

	assumes cs,StubSeg
	assumes ds,nothing

; we require DOS 3.1 or greater, so we can always fail the call

	mov     al,3                    ;fail the call
	iret

SpecialInt24ISR endp

;----------------------------------------------------------------------------;
; RestoreDiskAndCD:                                                          ;
;                                                                            ;
; Restores the current Disk and current directory.                           ;
;----------------------------------------------------------------------------;

RestoreDiskAndCD proc near

; restore the current disk

	xor     ah,ah
	mov     al,DosAppDisk
	mov     dx,StubSegOFFSET DosAppCD
	cCall   SetCurrentDiskAndCD,<ax,dx>

	ret

RestoreDiskAndCD endp
;----------------------------------------------------------------------------;
; RestoreDosState:                                                           ;
;                                                                            ;
; This routine restores the saved dos state.  It also restores the state of  ;
; the EMS page mapper registers if an EMS driver is present.                 ;
;----------------------------------------------------------------------------;

RestoreDosState proc near

; first set back the apps psp

	mov     ax,5000h                ;call to set PSP
	mov     bx,DosAppPSP            ;original PSP of the app
	int     21h                     ;PSP set back to one before switch 

; now restore the saved SS:SP value in the Switcher's PSP.

	push    es                      ;save
	mov     es,WoaPSP               ;Switcher's PSP
	mov     ax,Woa4BSP              ;get saved SP value
	mov     wptr es:[2eh],ax        ;restore it in PSP
	mov     ax,Woa4BSS              ;saved SS value
	mov     wptr es:[30h],ax        ;restore it in PSP
	pop     es                      ;restore

; restore the allocation strategy

	mov     ax,5801h                ;reset allocation strategy
	xor     bh,bh
	mov     bl,DosAllocationStrategy;get the saved strategy
	int     21h

; restore Dos link state

	mov     ax,5803h                ;reset link state info
	xor     bh,bh
	mov     bl,DosLinkState         ;get the saved state
	int     21h


; now set back the DMA address to what it was bebore the switch

	push    ds                      ;save ds
	mov     ah,1ah                  ;set DMA code
	mov     dx,wptr [DosAppDMA]
	mov     ds,wptr [DosAppDMA+2]   ;DS:DX has original DMA area
	int     21h                     ;DMA address set back
	pop     ds                      ;restore ds

; restore the apps IOCTL state for the 5 shared handles, after savibg the
; one for windows

	mov     di,StubSegOFFSET WinIoctlData
	call    SaveIoctlData
	mov     si,StubSegOFFSET AppIoctlData
	call    RestoreIoctlData

; restore the printer port addresses for the apps printer ports after saving 
; the current porst addresses for windows

	mov     di,StubSegOFFSET WinPrinterPorts
	call    SavePrinterPorts        ;save for windows
	mov     si,StubSegOFFSET AppPrinterPorts
	call    RestorePrinterPorts     ;restore them

; restore the installable device driver chain (2 ptrs at start and one at end)

	call    SwapDeviceHeaders       ;restore apps links

; restore EMS page mapper resgisters if an EMS driver is present.

	cmp     WoaEmsFlag,0ffh         ;is there an EMS driver
	jnz     @f                      ;no, nothing to restore
	mov     si,StubSegOFFSET AppEmsSaveArea
	mov     ax,4e01h                ;want to set the registers
	int     67h
@@:

	ret

RestoreDosState endp
;----------------------------------------------------------------------------;
; SaveOtherTaskVars:                                                         ;
;                                                                            ;
; This routine saves some important old app state related information which  ;
; donot require large amounts of memory. The information saved are:          ;
;                                                                            ;
;       . CoProcessor state if co processor present                          ;
;       . State of the sound generating hardware.                            ;
;----------------------------------------------------------------------------;

SaveOtherTaskVars  proc  near

; test to see if a math co processor is actually present or not

	int     11h                     ;returns equipment flag in ax
	test    al,00000010b            ;math coprocessor present ?
	jz      @f                      ;not present

; 8087 is present, save its state

	mov     si,StubSegOFFSET Buf8087;buffer where state is to be saved
	fsave   [si]                    ;save the state
@@:

; must save the sound state if necessary.

	call    SaveSoundState          ;saves the relevant sound state

; save 50 bytes of comm area from 0:4f0h

	mov     di,StubSegOFFSET CommSaveArea
	smov    es,cs                   ;es:di has save area
	push    ds                      ;save
	xor     ax,ax                   ;ds has to be loaded with 0
	mov     ds,ax                   ;ds points to segment 0
	mov     cx,50                   ;need to save 50 bytes
	mov     si,4f0h                 ;from 0:4f0
	rep     movsb                   ;bytes saved
	pop     ds                      ;restore
	ret

SaveOtherTaskVars endp
;----------------------------------------------------------------------------;
; RestoreOtherTaskVars:                                                      ;
;                                                                            ;
; This routine restores all the task state realated information that the abo-;
; -ve routine had saved.                                                     ;
;----------------------------------------------------------------------------;

RestoreOtherTaskVars    proc  near

; test to see whether a coprocessor is actually present

	int     11h                     ;returns equipment flag in AX
	test    al,00000010b            ;math coprocessor present ?
	jz      @f                      ;it is not, so do not try frstor

; restore the coprocessor state

	xor     ax,ax                   ;need to output zero to port
	out     CoProcPort,al           ; remove any pending exceptions
	mov     si,StubSegOFFSET Buf8087;buffer where state was saved
	frstor  [si]                    ;restore the coprocessor state
@@:

; restore the app sound state

	call    RestoreSoundState       ;restore sound hardware state

; now restore the state of the 50 byte comm area

	mov     si,StubSegOFFSET CommSaveArea
	push    es                      ;save
	xor     ax,ax                   ;es has to be loaded with 0
	mov     es,ax                   ;es points to segment 0
	mov     cx,50                   ;need to restore 50 bytes
	mov     di,4f0h                 ;to 0:4f0
	rep     movsb                   ;bytes restored
	pop     es                      ;restore
	ret

RestoreOtherTaskVars  endp
;----------------------------------------------------------------------------;
; SaveIoctlData:                                                             ;
;                                                                            ;
; This routine takes in ds:di a pointer to a 5 byte save area and saves the  ;
; current IOCTL data for the first 5 file handles in the block, saving just  ;
; the low byte of the data.                                                  ;
;----------------------------------------------------------------------------;

SaveIoctlData  proc near

; get the low byte of the file handles for the first 5 handles

	mov     cx,5                    ;5 handles to get data about
	push    es                      ;save
	smov    es,ds                   ;es has same segment
	xor     bx,bx                   ;start with handle 0

GetIoctlData:

	mov     ax,4400h                ;IOCTL get device data
	call    DosCall                 ;bypass our own traps
	mov     al,dl                   ;just save low byte
	stosb                           ;save it
	inc     bx                      ;next handle
	loop    GetIoctlData            ;save all 5 handles data
	pop     es                      ;restore
	ret

SaveIoctlData   endp
;----------------------------------------------------------------------------;
; RestoreIoctlData:                                                          ;
;                                                                            ;
; This routine takes in ds:si a pointer to a 5 byte save area and sets the   ;
; current IOCTL data for the first 5 file handles from the block.            ;
;----------------------------------------------------------------------------;

RestoreIoctlData  proc near

; set the low byte of the file handles for the first 5 handles

	mov     cx,5                    ;5 handles to get data about
	xor     bx,bx                   ;start with handle 0

SetIoctlData:

	lodsb                           ;get the data for the next handle
	mov     dl,al                   ;have it in dl
	xor     dh,dh                   ;must be zero for the call
	mov     ax,4401h                ;IOCTL set device data
	call    DosCall                 ;dx has data
	inc     bx                      ;next handle
	loop    SetIoctlData            ;save all 5 handles data
	ret

RestoreIoctlData        endp
;----------------------------------------------------------------------------;
; SavePrinterPorts:                                                          ;
;                                                                            ;
; This routine saves the 3 printer port addresses starting  at 40:8 into the ;
; 3 word buffer pointed to by es:di.                                         ;
;----------------------------------------------------------------------------;

SavePrinterPorts  proc near

	push    ds                      ;save data segment
	smov    es,ds                   ;have own data segment
	mov     ax,40h                  ;bios data segment
	mov     ds,ax                   ;have it in ds
	mov     bx,8                    ;first port
	mov     ax,[bx]                 ;get lpt1: base port address
	stosw                           ;save it     
	mov     ax,[bx+2]               ;get lpt2: base port address
	stosw                           ;save it
	mov     ax,[bx+4]               ;get lpt3: base port address
	stosw                           ;save it
	pop     ds                      ;restor data segment
	ret

SavePrinterPorts  endp
;----------------------------------------------------------------------------;
; RestorePrinterPorts:                                                       ;
;                                                                            ;
; This routine restores the 3 printer port word addresses at 40:8 from the   ;
; 3 word buffer pointed to by ds:si                                          ;
;----------------------------------------------------------------------------;

RestorePrinterPorts  proc near

	push    es                      ;save
	mov     ax,40h                  ;need to restore bios data area data
	mov     es,ax                   ;es points to bios data area
	lodsw                           ;get lpt1: base port address
	mov     es:[8],ax               ;restore it
	lodsw                           ;get lpt2: base port address
	mov     es:[10],ax              ;restore it
	lodsw                           ;get lpt3: base port address
	mov     es:[12],ax              ;restore it
	pop     es                      ;restore
	ret

RestorePrinterPorts  endp
;----------------------------------------------------------------------------;
; SaveDeviceHeaders:                                                         ;
;                                                                            ;
; Say, the device header chain is something like:                            ;
;                                                                            ;
;    A --> B --> C --> ....... --> Z --> -1.                                 ;
;                                                                            ;
; We assume that if the app hooks devices, it will hook in one of the three  ;
; following places:  Between A & B or between B & C or after Z.              ;
;                                                                            ;
; So, we will save the following information (each field a DWORD)            ;
;                                                                            ;
;        Node Address           Current Next Pointer                         ;
;             A                         B                                    ;
;             B                         C                                    ;
;             Z                        -1                                    ;
;                                                                            ;
; We may have only one or two lines if not a lot of devices are chained.     ;
;                                                                            ;
; Note that saving B or C twice is not redundant, because the lft coloumn is ;
; invariant. When we swap the old app or bring it back, we will swap the     ;
; values in the second coloumn (contents of the addresses in the 1st coloumn);
;                                                                            ;
; Irrespective of the no of rows saved above, we will terminate the table by ;
; a word in coloumn 1 being -1. So we need 26 bytes of storage.              ;
;----------------------------------------------------------------------------;

SaveDeviceHeaders  proc near

	push    ds                      ;save

; make es:di point to the save area

	smov    es,ds                   ;same segment
	mov     di,StubSegOFFSET DevHeaderChain

; get the location of the first device header, this is version dependant!

	call    GetDeviceChainHeader    ;ds:si has the header
	mov     cx,2                    ;2 pairs of dwords to save

SaveDevPtrLoop:

; save the address

	mov     ax,si                   ;get the offset
	stosw                           ;save the offset
	mov     ax,ds                   ;get the segment
	stosw                           ;save offset

; get and save the 'next' pointer

	lds     si,[si]                 ;get the next pointer
	mov     ax,si                   ;get the offset
	stosw                           ;save the offset
	mov     ax,ds                   ;get the segment
	stosw                           ;save offset

; if we have saved the last one, get out

	cmp     si,-1                   ;terminator ?
	jz      DevPtrsSaved            ;we are done.
	loop    SaveDevPtrLoop          ;save the next one too.   

; we have saved the first two rows (A,B & B,C) - now save the last one.

@@:
	cmp     wptr [si],-1            ;end of the chain 
	jz      SaveEndOfChain          ;yes.
	lds     si,[si]                 ;get the next in chain
	jmp     short @b                ;get to the end

SaveEndOfChain:

	mov     ax,si                   ;get the offset
	stosw                           ;save the offset
	mov     ax,ds                   ;get the segment
	stosw                           ;save offset
	mov     ax,-1                   ;save the tehrminator
	stosw                           ;save termonator
	stosw                           ;save it as dword

DevPtrsSaved:

	mov     ax,-1                   ;end of table
	stosw                           ;end of table in first coloumn.

	pop     ds                      ;restore
	ret

SaveDeviceHeaders  endp
;----------------------------------------------------------------------------;
; SwapDevPtrs:                                                               ;
;                                                                            ;
; This  routine swaps the contents of the (upto) 3 device header nodes as    ;
; explained in the above routine.                                            ;
;----------------------------------------------------------------------------;

SwapDeviceHeaders  proc near

	push    ds                      ;save
	smov    es,ds                   ;same segment
	mov     di,StubSegOFFSET DevHeaderChain
	cli                             ;shut interrupts off

@@:
	lds     si,es:[di]              ;get the address of next header
	cmp     si,-1                   ;end of table
	jz      @f                      ;yes.
	add     di,4                    ;es:di points to prior contents
	swap_a_word                     ;swap the offset
	swap_a_word                     ;swap the segment
	jmp     short @b                ;keep swapping
@@:
	pop     ds                      ;restore
	sti                             ;set back ints on.
	ret

SwapDeviceHeaders  endp
;----------------------------------------------------------------------------;
; GetDeviceChainHeader:                                                      ;
;                                                                            ;
; Returns the head of the device chain in DS:SI - this is DOS version        ;
; dependant and may have to be changed in future.  Windows 3.0 requires DOS  ;
; 3.1 or greater, and all these DOS versions currently have the device chain ;
; header at offset 22h from the address returned by Int 21/52h.              ;
;----------------------------------------------------------------------------;

GetDeviceChainHeader  proc near

	;!!! What about DOS 5+

	lds     si,lpDosData            ;pointer returned by Int 21h/52h
	add     si,22h                  ;add offset to device chain header
	ret

GetDeviceChainHeader  endp
;----------------------------------------------------------------------------;
; IsTimerHooked:                                                             ;
;                                                                            ;
; This routine sets a flag if the INT 08h vector has been hooked. Based      ;
; on this flag we would decide later whether we have to reprogram the timer  ;
; when we switch out. We will make the desicion based on the hook            ;
; segment alone.                                                             ;
;----------------------------------------------------------------------------;

IsTimerHooked   proc near

	pushem  es,bx                   ;save
	and     [MiscFlags],NOT TIMER_HOOKED;assume it is not hooked
	mov     ax,3508h                ;get INT 08 Vector
	call    DosCall                 ;vector in es:bx
	mov     ax,cs                   ;segment of our hook
	mov     bx,es                   ;get current hook segment
	cmp     ax,bx                   ;still our hook ?
	jz      IsTimerHookedRet        ;yes, timer has not been hooked
	or      [MiscFlags],TIMER_HOOKED;assume it is hooked

IsTimerHookedRet:

	popem   es,bx
	ret

IsTimerHooked   endp
;----------------------------------------------------------------------------;
; SaveSoundState:                                                            ;
;                                                                            ;
; This routine saves the state of the sound generating hardware.             ;
;----------------------------------------------------------------------------;

SaveSoundState  proc near

; if the timer has not been hooked, we should not reprogram the timer

	test    [MiscFlags],TIMER_HOOKED;is it hooked ?
	jz      SSS_TimerOK             ;do not reprogram the timer.

; the timer is hooked, we must reprogram the timer.

	xor     cx,cx                   ;timer to be set to 18.2 tics/sec
	call    SetTimer                ;set the timer

SSS_TimerOK:

	call    SaveRestoreSound        ;common processing
	ret                     

SaveSoundState  endp
;----------------------------------------------------------------------------;
; RestoreSoundState:                                                         ;
;                                                                            ;
; This routine restores the state of the sound generating hardware.          ;
;----------------------------------------------------------------------------;

RestoreSoundState proc near

; if the timer has not been hooked by the app, we should not reprogram the
; timer

	test    [MiscFlags],TIMER_HOOKED;is it hooked ?
	jz      RSS_TimerOK             ;no, just speaker port mask

; just another heuristic check. Was the speaker ON, when we switched out ?

	test    speaker,BEEP_ON         ;was it on
	jz      RSS_TimerOK             ;don't reprogram timer

; We have no clue what tha app had programmed the timer too. We are going 
; to jack it up to the rate that basic expects.

	mov     cx,2048                 ;new timer speed
	call    SetTimer                ;speed up the timer

RSS_TimerOK:

; now restore the sound state

	call    SaveRestoreSound        ;common processing
	ret

RestoreSoundState endp
;----------------------------------------------------------------------------;
; SaveRetoreSound:                                                           ;
;                                                                            ;
; Here we save or restore the speaker control value. We play with only the   ;
; low two bits which are the gate control bits and determine on/off status   ;
; of the speaker. Other bits are not touched.                                ;
;----------------------------------------------------------------------------;

SaveRestoreSound  proc  near

	in      al,SpeakerCtl           ;Get current value
	mov     ah,al                   ;save in ah
	xchg    Speaker,al              ;Swap with saved value
	and     ah,11111100b            ;High six bits from current value
	and     al,00000011b            ;Low two bits from saved value
	or      al,ah                   ;all 8 bits
	out     SpeakerCtl,al           ;restore
	ret

SaveRestoreSound endp
;----------------------------------------------------------------------------;
; SetTimer:                                                                  ;
;                                                                            ;
; This routine modifies the timer rate. CX contains the new timer rate for   ;
; timer 0 port.                                                              ;
;----------------------------------------------------------------------------;

SetTimer  proc near

	in      al,mskreg               ;get the timer port value
	or      al,00000001b            ;disable timer interrupt
	jmp     $+2                     ;i/o delay
	out     mskreg,al               ;timer now disabled
	mov     al,cl                   ;low 8 bits new timer rate
	out     timer0,al               ;Set new rate
	jmp     $+2                     ;i/o delay
	mov     al,ch                   ;high 8 bits new timer rate
	out     timer0,al               ;set new rate
	in      al,mskreg               ;get back enable/disable status
	and     al,1111110b             ;set diable bit off
	jmp     $+2                     ;i/o delay
	out     mskreg,al               ;re-enable timer
	ret

SetTimer  endp
;----------------------------------------------------------------------------;
; WaitForKeyFromInt16                                                        ;
;                                                                            ;
; This routine waits for a key to be hit, also checking to see if a context  ;
; switch can be done. It calls the original Int16 code to get the status.    ;
;                                                                            ;
; NOTE: This routine only expects to be called from an Int 16h interrupt     ;
; handler, and ah is expected to have the Int 16h function code (00 = normal ;
; read character, 10h = enhanced read character).                            ;
;                                                                            ;
;----------------------------------------------------------------------------;

WaitForKeyFromInt16  proc near

; If this is a normal read keyboard call, use normal get status, otherwise
; use extended call.

	mov     cs:[Int16GetStatusType],01h
	or      ah,ah
	jz      @f
	mov     cs:[Int16GetStatusType],11h
@@:
	call    SwitchIfPossible        ;do a context switch if appropriate
	call    IsKeyReady              ;is a key ready
	jz      @b                      ;continue waiting.
	ret

WaitForKeyFromInt16  endp

;----------------------------------------------------------------------------;
; WaitForKeyFromDosCalls:                                                    ;
;                                                                            ;
; This routine waits for a key to be hit, also checking to see if a context  ;
; switch can be done. It calls the a dos function to get the status.         ;
; This routine is called when we are waiting for a key from a DOS get key    ;
; call and does INT 28Hs from the idle loop.                                 ;
;----------------------------------------------------------------------------;

WaitForKeyFromDosCalls proc near

@@:
	call    DoInt28                 ;yield, not if in crit. error handler
	call    SwitchIfPossible        ;do a context switch if appropriate
	call    DoDosWait               ;is a key ready
	jz      @b                      ;continue waiting
	ret

WaitForKeyFromDosCalls endp
;----------------------------------------------------------------------------;
; IsKeyReady:                                                                ;
;                                                                            ;
; This key checks to see if a key is ready by doing INT 16 get status calls. ;
; If pasting is being done it will return with zero reset (meaning key ready);
;                                                                            ;
; NOTE: This routine expects the global variable Int16GetStatusType to be    ;
; setup with the type of Int 16h get keyboard status call to make.           ;
;                                                                            ;
;----------------------------------------------------------------------------'

IsKeyReady proc near

	push    ax                              ;save caller's AX
	mov     ah,cs:[Int16GetStatusType]      ;read status call to use

; get the status from BIOS.

; call int 16 code to get status, set a flag to tell the INT 16 hook that if
; this call does get down to our INT 16 handler, it should chain it to BIOS
; (This gives apps who do their own buffering to work)

	pushf                           ;CALL-IRET protocol
	cli                             ;correct simulation
	call    cs:[ActualInt16]        ;chain down

	pop     ax                      ;restore ax
	ret                             ;Z=1 means not ready, = 0 means ready

IsKeyReady endp
;----------------------------------------------------------------------------;
; HookIntVectors:                                                            ;
;                                                                            ;
; This routine hooks the interrupts that the switcher needs to see.          ;
; NOTE: The original state of these vectors have already been saved as a part;
; of the instance data management.                                           ;
;----------------------------------------------------------------------------;

	assumes ds,StubSeg

HookIntVectors proc near

; hook the 16 hardware vectors with a dummy ISR. This will keep track of
; whether the app has finished it's hardware ISR or not. After seting the
; vectors we will treat the new vectors to be the default for all these
; vectors. 

	.errnz  HInt09ISR - HInt08ISR - 18
	.errnz  HInt0AISR - HInt09ISR - 18
	.errnz  HInt0BISR - HInt0AISR - 18
	.errnz  HInt0CISR - HInt0BISR - 18
	.errnz  HInt0DISR - HInt0CISR - 18
	.errnz  HInt0EISR - HInt0DISR - 18
	.errnz  HInt0FISR - HInt0EISR - 18
	.errnz  HInt70ISR - HInt0FISR - 18
	.errnz  HInt71ISR - HInt70ISR - 18
	.errnz  HInt72ISR - HInt71ISR - 18
	.errnz  HInt73ISR - HInt72ISR - 18
	.errnz  HInt74ISR - HInt73ISR - 18
	.errnz  HInt75ISR - HInt74ISR - 18
	.errnz  HInt76ISR - HInt75ISR - 18
	.errnz  HInt77ISR - HInt76ISR - 18
	.errnz  HInt08ChainAddr - HInt08ISR - 8
	.errnz  HInt09ChainAddr - HInt09ISR - 8
	.errnz  HInt0AChainAddr - HInt0AISR - 8
	.errnz  HInt0BChainAddr - HInt0BISR - 8
	.errnz  HInt0CChainAddr - HInt0CISR - 8
	.errnz  HInt0DChainAddr - HInt0DISR - 8
	.errnz  HInt0EChainAddr - HInt0EISR - 8
	.errnz  HInt0FChainAddr - HInt0FISR - 8
	.errnz  HInt70ChainAddr - HInt70ISR - 8
	.errnz  HInt71ChainAddr - HInt71ISR - 8
	.errnz  HInt72ChainAddr - HInt72ISR - 8
	.errnz  HInt73ChainAddr - HInt73ISR - 8
	.errnz  HInt74ChainAddr - HInt74ISR - 8
	.errnz  HInt75ChainAddr - HInt75ISR - 8
	.errnz  HInt76ChainAddr - HInt76ISR - 8
	.errnz  HInt77ChainAddr - HInt77ISR - 8

	mov     cx,16                   ;16 vectors to be set
	mov     dx,StubSegOFFSET HInt08ISR; first vector -- IRQ 0
	mov     al,08h                  ;start with IRQ 0 vector

SetHWVectorLoop:

	mov     si,dx                   ;get a copy in bx
	mov     ah,35h                  ;get vector code
	int     21h                     ;current vector in es:bx
	mov     wptr [si][10],es
	mov     wptr [si][8],bx         ;save current vector
	mov     ah,25h                  ;set vector code
	int     21h                     ;set new vector
	add     dx,18                   ;next ISR
	inc     al                      ;next vector
	cmp     al,16                   ;past the first range ?
	jb      @f                      ;no.
	mov     al,70h                  ;on to the next range
@@:
	loop    SetHWVectorLoop

; get and save the segment of the current INT 1CH ISR. Also save the vector.
; This hook we need to time out pending switch requests that take too long.
; Note: We hook INT 1CH and not INT 08H bacause programs can program the 
; timer to interrupt faster but INT 1CHs are supposed to be generated at
; 18.2 ticks/sec

	mov     ax,351Ch                ;get vector for int 08
	int     21h                     ;es has the segment for the ISR
	mov     wptr [ActualInt1C+2],es
	mov     wptr [ActualInt1C],bx   ;save current vector

; hook the INT 1CH vector. This, to help timeout switch requests
; that take too long to be satisfied

	mov     dx,StubSegOFFSET Int1CISR
	mov     ax,251Ch                ;set code for vector 1C
	int     21h                     ;set vector for int 1C

; now set vectors 9,16,21,23,24 start with 09 also save some current values. 
; Int 09 will not be hooked if the pif file indicated all the hot keys  
; have been disabled

; decide if int 9 is to be hooked or not

	cmp     cs:[WoaHotkeys],00001111b
	jz      @f                      ;all hot keys disabled

; int 09 must be hooked

	mov     ax,3509h                ;code for get int 09 vctor
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt09+2],es
	mov     wptr [ActualInt09],bx   ;save current vector

	mov     dx,StubSegOFFSET Int09ISR
	mov     ax,2509h                ;set code for vector 09
	int     21h                     ;set vector for int 09
@@:
	mov     cs:[WoaHotkeyState],0   ;reset hot key flag

; set the INT 15 vector, saving the original value

	mov     ax,3515h                ;code for get int 15 vctor
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt15+2],es
	mov     wptr [ActualInt15],bx   ;save current vector

	mov     dx,StubSegOFFSET Int15ISR
	mov     ax,2515h                ;set code for vector 16
	int     21h                     ;set vector for int 16

; set the INT 16 vector, saving the original value

	mov     ax,3516h                ;code for get int 16 vctor
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt16+2],es
	mov     wptr [ActualInt16],bx   ;save current vector

	mov     dx,StubSegOFFSET Int16ISR
	mov     ax,2516h                ;set code for vector 16
	int     21h                     ;set vector for int 16

; set the INT 21 vector, saving its original value

	mov     ax,3521h                ;code for get int 21 vector
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt21+2],es
	mov     wptr [ActualInt21],bx   ;save current vector

	mov     dx,StubSegOFFSET Int21ISR
	mov     ax,2521h                ;set code for vector 21
	int     21h                     ;set vector for int 21

; int 23 must be hooked

	mov     dx,StubSegOFFSET Int23ISR
	mov     ax,2523h                ;set code for vector 23
	int     21h                     ;set vector for int 23

; int 24 must be hooked

	mov     ax,3524h                ;code for get int 24 vctor
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt24+2],es
	mov     wptr [ActualInt24],bx   ;save current vector

	mov     dx,StubSegOFFSET Int24ISR
	mov     ax,2524h                ;set code for vector 24
	int     21h                     ;set vector for int 24

; int 27 must be hooked

	mov     ax,3527h                ;code for get int 27 vector
	int     21h                     ;current vector in es:bx
	mov     wptr [ActualInt27+2],es
	mov     wptr [ActualInt27],bx   ;save current vector

	mov     dx,StubSegOFFSET Int27ISR
	mov     ax,2527h                ;set code for vector 27
	int     21h                     ;set vector for int 27

; int 2f must be hooked. If XMS handling is being done, the handler will 
; hook int 2f again.

	mov     ax,352fh                ;code for get int 2f vector
	int     21h                     ;current vector in es:bx
	mov     wptr [OtherActualInt2f+2],es
	mov     wptr [OtherActualInt2f],bx;save current vector

	mov     dx,StubSegOFFSET OtherInt2fISR
	mov     ax,252fh                ;set code for vector 2f
	int     21h                     ;set vector for int 2f

; now get the vector for INT 0aH and 71h for slave PIC processing at switch
; out time.

	mov     ax,350ah                ;get vector for INT 0Ah
	int     21h                     ;vector in es:bx
	mov     wptr [ActualInt0A+2],es ;save segment
	mov     wptr [ActualInt0A],bx   ;save offset
	mov     ax,3571h                ;get vector for INT 71h
	int     21h                     ;vector in es:bx
	mov     wptr [ActualInt71+2],es ;save segment
	mov     wptr [ActualInt71],bx   ;save offset


; If 'WoaNetAsyncSwitching' is 0, we will need to hook INT 2AH and INT 5CH and
; look for asynchronous network requests.

	cmp     WoaNetAsyncSwitching,0  ;do we need to monitor network ?
	jnz     AllHooksInPlace         ;no.

; int 2A must be hooked

	mov     ax,352Ah                ;code for get int 2A vector
	int     21h                     ;current vector in es:bx

; if the vector is 0:0, do not hook it. Probably this is a redundant test
; and the default vector will never be 0:0 and this is just paranoia code.

	mov     ax,es                   ;check to see if the vector is 0:0
	or      ax,bx                   ;is it 0 ?
	jz      TryToHook5C             ;yes it is, try hooking INT 5CH

; save the current vector and put in our hook.

	mov     wptr [ActualInt2A+2],es
	mov     wptr [ActualInt2A],bx   ;save current vector

	mov     dx,StubSegOFFSET Int2AISR
	mov     ax,252Ah                ;set code for vector 2A
	int     21h                     ;set vector for int 2A

TryToHook5C:

; int 5C must be hooked (only if the default hook is not 0:0)

	mov     ax,355Ch                ;code for get int 5C vector
	int     21h                     ;current vector in es:bx

; it is possible that there is no network software installed on this machine
; and the vector points to 0:0. This happens on some EPSON machines. In this
; case we should not hook the vector.

	mov     ax,es                   ;check to see if it is 0
	or      ax,bx                   ;is it zero ?
	jz      AllHooksInPlace         ;it is, do not put in a hook

; save the current vector and place our hokk over it.

	mov     wptr [ActualInt5C+2],es
	mov     wptr [ActualInt5C],bx   ;save current vector

	mov     dx,StubSegOFFSET Int5CISR
	mov     ax,255Ch                ;set code for vector 5C
	int     21h                     ;set vector for int 5C

AllHooksInPlace:

	ret

HookIntVectors endp
;----------------------------------------------------------------------------;
; SwapMasterPICMask                                                          ;
;                                                                            ;
; This routine swaps the application's Master 8259 Interrupt Mask with       ;
; Window's.                                                                  ;
;                                                                            ;
;----------------------------------------------------------------------------;

SwapMasterPICMask  proc near

	in      al,21h                  ;get the current value
	xchg    al,MasterPICMask        ;swap it
	jmp     short $+2               ;i/o delay
	out     21h,al                  ;restored.

	ret

SwapMasterPICMask  endp

;----------------------------------------------------------------------------;
; OkToSwitch?:                                                               ;
;                                                                            ;
; We will not switch out from within any hardware interrupt handler.         ;
;                                                                            ;
; If the Switcher is disabled because of any reason we will not switch out.  ;
;                                                                            ;
; This routine looks at the InDos flag and the error mode flag and if they   ;
; are both zero, clears carry and gives permission to switch. Else carry is  ;
; set to imply we cannot switch out the old app.                             ;
;                                                                            ;
; If the indos and error flags are not set, this routine tries to get a      ;
; switch out approval from the app (if notification hooks are installed)     ;
;                                                                            ;
; This routine also checks to see if IRQ0 (timer) and IRQ1 (keyboard) are    ;
; unmasked. A 3270 emulation app, PSC actually masks this for a while and    ;
; switching out in this state would be disastrous.                           ;
;                                                                            ;
; The Switch API calls are also made to figure out if it is OK to suspend the;
; app.                                                                       ;
;----------------------------------------------------------------------------;

OkToSwitch?  proc near

; check to see if a we are within any hardware ISR

	cmp     cs:[HardwareIntCount],0 ;inside any hardware ISR
	jnz     OkToSwitchFailNoBeep    ;yes

; check to see if the switcher is disabled.

	cmp     cs:[SwitcherDisabled],0 ;are any bits set ?
	jz      SwitcherNotDisabled     ;no, it's OK to switch.
	jmp     short OkToSwitchFail    ;fail call and beep.

SwitcherNotDisabled:

; check for other conditions that may prevent a switch. 

	call    CheckCriticalRegions    ;sets carry if in some critical region
	jc      OkToSwitchRet           ;switch out not possible

; check to see if we have enough file handles free to complete a context switch

	call    TestForMinFreeHandles   ;are enough file handles available
	jc      OkToSwitchFail          ;not enough free handles to switch out.

; chect to see if it is OK to suspend the app.

	cCall   OkToSuspend?            ;ok to suspend the app ?
	jz      OkToSwitchRet           ;yes.

OkToSwitchFail:

	call    OEMBeep                 ;hoot the hooter.
	mov     cs:[WoaHotKeyState],0   ;can't do it and don't try again later

OkToSwitchFailNoBeep:

	stc                             ;can't do it at this time

OkToSwitchRet:

;----------------------------------------------------------------------------;
; NOTE:                                                                      ;
;       Interrupts are disabled now and will be enabled only after the apps  ;
;       interrupt hooks have been taken out.                                 ;
;----------------------------------------------------------------------------;

	ret

OkToSwitch? endp
;----------------------------------------------------------------------------;
; CheckCriticalRegions:                                                      ;
;                                                                            ;
; Tests for the situations in which it is not possible to switch out.        ;
; These situations are:                                                      ;
;                                                                            ;
;       . IRQ 0 or IRQ 1 are masked.                                         ;
;       . An interrupt is being serviced.                                    ;
;       . Dos 'InDos' flag is set.                                           ;
;       . Critical error handler flag is set.                                ;
;       . The app notifies that it is in a critical region.                  ;
;                                                                            ;
; In all these cases the carry flag would be set before return to imply that ;
; switch  not be serviced.                                                   ;
;                                                                            ;
; In the case where the critical error flag is set, we will also reset the   ;
; the switch request and beep.                                               ;
;----------------------------------------------------------------------------;

CheckCriticalRegions proc near

	pushem  es,bx,ax                ;save registers

; check to see whether IRQ1 and IRQ0 are unmasked. If any of these are 
; masked, we are not going to switch out.

	in      al,21h                  ;get the masks
	and     al,00000011b            ;mask only IRQ0 & 1 bits
	jnz     YesCritical             ;something masked, can't switch now

; do not switch out if any Interrupts are pending

	mov     al,00001011b            ;command byte to read status
	out     20h,al                  ;read status request made
	jmp     $+2                     ;i/o delay
	in      al,20h                  ;get the status
	or      al,al                   ;interrupt pending ?
	jnz     YesCritical             ;yes, can't switch now

; Can't switch if DOS is active

	les     bx,cs:[lpIndosFlag]     ;ES:BX point to indos flag
	cmp     byte ptr es:[bx],0
	jnz     YesCritical

; Can't switch if in a critical error handler, and make user try again later

	les     bx,cs:[lpErrModeFlag]   ;ES:BX points to error flag
	cmp     byte ptr es:[bx],0
	jnz     YesCriticalAbortRequest ;reset the request flag too.

; (Maybe) check with the app itself

	call    CheckWithApp            ;does th app allow switching out ?
	jnz     YesCritical             ;app says no

; Yes, it is okay to switch now!

	clc
	jmp     short CheckCriticalRet  

YesCriticalAbortRequest:

	call    OEMBeep                 ;hoot the hooter.
	mov     cs:[WoaHotKeyState],0   ;can't do it and don't try again later

YesCritical:

	stc                             ;can't do it at this time

CheckCriticalRet:

	popem   es,bx,ax                ;restore saved registers
	ret

CheckCriticalRegions endp
;----------------------------------------------------------------------------;
; IsFileConsole?:                                                            ;
;                                                                            ;
; This routine takes a file handle in BX and traverses the file table to see ;
; if the file name is CON or not. If it is, it sets the 'Z' flag.            ;
;                                                                            ;
; The SFT structure is dos version dependant and that is taken care of here. ;
;                                                                            ;
; The routine must preserve all registers.                                   ;
;----------------------------------------------------------------------------;

IsFileConsole?  proc near

	assumes cs,StubSeg
	assumes ds,nothing
	assumes es,nothing

	cmp     WoaFileEntrySize,0      ;if we don't have a valid SFT entry
	jnz     @f                      ;  size (like when under OS/2), don't
	cmp     bptr WoaFileEntrySize,-1;  grovel for the console, just say
	ret                             ;  it isn't (2nd cmp sets NZ)
@@:
	pushem  ax,si,es,bx             ;save resgister which we thrash                 ;save function
	mov     ax,bx                   ;get handle into ax
	push    ax                      ;Save file handle momentarily
	mov     ah,51H                  ;Get Current PDB code
	call    DosCall                 ;current PDB segment in BX
	mov     es,bx                   ;BX -> ES = Current PDB
	pop     bx                      ;get file handle back

; BX is a entry into the FileIndex table.

	les     si,es:[PDB_JFN_Pointer] ;get pointer to table for 3.00 & above

; ES:SI points to the file index table in the PDB, BX points to an entry in it
; get the entry value, which is the index in the Sytem File Table

	mov     al,es:[bx][si]          ;look up value in PDB_JFN_Table
	cmp     al,80h                  ;special close flag? (windows does this)
	jne     @f                      ;no,continue
	mov     bptr es:[bx][si],0ffh   ;yes,mark closed,& skip rest.

NotConsole:

	or      ax,ax                   ;reset zero flag
	jmp     short IsFileConsoleRet  ;exits with 'NZ', it is not console
@@:
	les     bx,cs:[lpDosData]       ;ES:BX points to Dos's data
	add     bx, 4                   ;ES:BX -> lpFileTable

TraverseSFTlink:

	les     bx,es:[bx+sftLink]      ;get next sft in chain...
	cmp     bx,-1                   ;0ffff in first word marks end of chain
	jz      NotConsole              ;End of chain of tables: return

; test to see if the file index is maintained by this SFT link or node

	sub     al,bptr es:[bx+sftCount];this alloc. has this many files
	jae     TraverseSFTlink         ;not this one, follow the chain

; finally we have located the link which supports this file.

	add     al,bptr es:[bx+sftCount];restore index into this link
	lea     bx,[bx+sftFile]         ;position to start of fcb area
	jz      @f                      ;no adjustment for first fcb in link

LocateCorrectEntry:

	add     bx,WoaFileEntrySize     ;position to next fcb
	dec     al                      ;is this the correct one ?
	jnz     LocateCorrectEntry      ;no, look ahead
@@:

; test for remote files under dos 3 or above

	test    es:[bx+sf_flags],sf_isnet
	jnz     IsFileConsoleRet                ;it is a remote file

; check for the name 'CON '

	cmp     wptr es:[bx+sf_name],"OC"       ;check for 'CON '
	jnz     IsFileConsoleRet                ;not a console device
	cmp     wptr es:[bx+sf_name+2]," N"
	jnz     IsFileConsoleRet                ;not a console driver.

; HACK! We will save a pointer to the SFT entry. In the 'ReadConsoleBuffer'
; routine which traps a 3FH/INT 21H call, we will use the input handle to
; do a write call (40H) to display each character on the output. At that
; time we will change the SFT sf_mode field to ensure that we have write
; access.

	add     bx,sf_mode                      ;es:bx points to sf_mode
	mov     wptr cs:[lp3fMode],bx           ;save offset of address
	mov     wptr cs:[lp3fMode+2],es         ;save segment of address
	xor     al,al                           ;set zero flag, file is CON

IsFileConsoleRet:

	popem   ax,si,es,bx             ;restore saved registers
	ret                     

IsFileConsole? endp
;----------------------------------------------------------------------------;
; GetDosFlags:                                                               ;
;                                                                            ;
; This routine gets and saves long pointers to the InDos flag and the error  ;
; mode flag used by the critical error handler. The location of the InDos    ;
; flag can be obtained by a DOS call, but the location of the ErrorMode flag ;
; is version dependent (but, since Windows 3.0 requires DOS 3.1 or greater,  ;
; the ErrorMode flag is now in the same location):                           ;
;       For Version 3.1 and greater, it is the byte prior to the InDos flag. ;
;----------------------------------------------------------------------------;

GetDosFlags  proc near

; get the address of the InDos flag

	mov     ah,34h                  ;DOS call function
	int     21h                     ;ES:BX points to InDosFlag
	mov     wptr [lpInDosFlag+2],es 
	mov     wptr [lpInDosFlag],bx

	dec     bx                      ;ES:BX now points to ErrorMode flag
	mov     wptr [lpErrModeFlag+2],es
	mov     wptr [lpErrModeFlag],bx

; also get the lptr of the dos data block

	mov     ah,52h                  ;call to get dos data block
	int     21h                     ;es:bx has the dos data block address
	mov     wptr [lpDosData+2],es
	mov     wptr [lpDosData],bx     ;save the address

	ret

GetDosFlags endp
;----------------------------------------------------------------------------;
; This routine save the current dos directory (the pre exec directory).      ;
;----------------------------------------------------------------------------;

SetDosDirectory proc  near

; save the current disk

	mov     ah,19h                  ;get current disk call
	call    DosCall                 ;al has disk id
	mov     DosPreExecDisk,al       ;save it

; now save the current directory

	mov     ah,47h                  ;get current directory code
	mov     dl,0                    ;for the default drive
	mov     si,StubSegOFFSET DosPreExecCD
	inc     si                      ;skip the root symbol
	call    DosCall                 ;current directory obtained

	ret

SetDosDirectory endp
;----------------------------------------------------------------------------;
; SaveWinDosBiosStates:                                                      ;
;                                                                            ;
; This routine saves various dos and bios related state that has to be resto-;
; -red any time we switch back to windows. These states are:                 ;
;                                                                            ;
;       . DOS current directory.                                             ;
;       . IOCTL state for first 5 handles                                    ;
;       . Printer port addresses ( 3 words at 40:8)                          ;
;       . PIC IRQ enable register                                            ;
;                                                                            ;
;----------------------------------------------------------------------------;

SaveWinDosBiosStates  proc near

; get and save the current directory and set the apps directory if needed

	call    SetDosDirectory         ;set up correct directory,saving current

; save the current IOCTL data of the first 5 shared handles

	mov     di,StubSegOFFSET WinIoctlData
	call    SaveIoctlData           ;save the state

; save the printer port information for windows

	mov     di,StubSegOFFSET WinPrinterPorts
	call    SavePrinterPorts        ;save

; save some pointers in installable device driver link

	call    SaveDeviceHeaders       ;old app may add some

; get and set the value of the PIC IRQ enable register.

	in      al,21h                  ;get the register value
	mov     MasterPICMask,al        ;save it

; get and save the slave PIC state as the PreExec state and also as the current
; global SlavePICMask.

	call    ReadSlavePICMask        ;read the mask
	mov     GlobalSlavePICMask,al   ;save it.
	mov     PreExecSlavePICMask,al  ;save it

	ret

SaveWinDosBiosStates  endp
;----------------------------------------------------------------------------;
; RestoreWinDosBiosStates:                                                   ;
;                                                                            ;
; This routine restore some of the dos and bios states for windows before    ;
; switching back to it. The states were saved in the above routine.          ;
;----------------------------------------------------------------------------;

RestoreWinDosBiosStates  proc near

; first reset the directory to what was current prior to exec call

	call    ResetDosDirectory       ;directory restored

; restore the state of the IOCTL data for the first 5 handles

	mov     si,StubSegOFFSET WinIoctlData
	call    RestoreIoctlData        ;IOCTL state restored.

; now restore the printer port addresses in the BIOS data area

	mov     si,StubSegOFFSET WinPrinterPorts
	call    RestorePrinterPorts     ;restore prn port addresses

; restore the device header list.

	call    SwapDeviceHeaders       ;restore the headers

	ret

RestoreWinDosBiosStates  endp
;----------------------------------------------------------------------------;
; The following routine restores the Dos Pre Exec directory after an EXEC    ;
; call is completed.                                                         ;
;----------------------------------------------------------------------------;

ResetDosDirectory proc near

; switch to the preexec drive

	xor     ah,ah                   ;init
	mov     al,DosPreExecDisk       ;initial drive
	mov     dx,StubSegOFFSET DosPreExecCD
	cCall   SetCurrentDiskAndCD,<ax,dx>
	ret

ResetDosDirectory endp
;----------------------------------------------------------------------------;
; ReadSlavePICMask:                                                          ;
;                                                                            ;
; Returns the value of the slave PIC mask in AL. If 'WoaIrq9Global' is       ;
; non zero then no port will be read.                                        ;
;----------------------------------------------------------------------------;

ReadSlavePICMask proc near

	cmp     WoaIrq9Global,0         ;is it disabled ?
	jnz     @f                      ;yes.
	in      al,0a1h                 ;read the slave PIC
@@:
	ret     

ReadSlavePICMask endp
;----------------------------------------------------------------------------;
; WriteSlavePICMask:                                                         ;
;                                                                            ;
; Reprograms the slave PIC mask with the value in AL.                        ;
; If 'WoaIrq9Global' is not zero, no port will be written.                   ;
;----------------------------------------------------------------------------;

WriteSlavePICMask proc near

	cmp     WoaIrq9Global,0         ;is it disabled ?
	jnz     @f                      ;yes.
	sti                             ;let pending ints go through
	out     0a1h,al                 ;write out the mask
@@:
	ret     

WriteSlavePICMask endp
;----------------------------------------------------------------------------;
; ProcessSlavePICMask:                                                       ;
;                                                                            ;
; This routine save the Slave PIC mask state. It then tries to restore the   ;
; Windows PIC state for the slave. However if we find that the App has hooked;
; either INT 0AH (IRQ 2) or INT 71H (IRQ 9) then we will disable the IRQ 9   ;
; bit in the slave.                                                          ;
;----------------------------------------------------------------------------;

ProcessAppSlavePICMask proc near

	push    es

	mov     AppUsesIRQ9,0           ;reset it.
	call    ReadSlavePICMask        ;get the current mask
	mov     AppSlavePICMask,al      ;save it.

	xor     ax,ax
	mov     es,ax
	mov     ax,wptr es:[0Ah*4+2]    ;get INT 0Ah vector segment
	cmp     ax,wptr [ActualInt0A+2] ;is the segment different ?
	jnz     MaskIrq9Off             ;yes, mask IRQ9 off
	mov     ax,wptr es:[0Ah*4]      ;get INT 0Ah vector offset
	cmp     ax,wptr [ActualInt0A]   ;is the offset any different ?
	jnz     MaskIrq9Off             ;yes, mask IRQ9 off

	mov     ax,wptr es:[71h*4+2]    ;get INT 71h vector segment
	cmp     ax,wptr [ActualInt71+2] ;is the segment different ?
	jnz     MaskIrq9Off             ;yes, mask IRQ9 off
	mov     ax,wptr es:[71h*4]      ;get INT 71h vector offset
	cmp     ax,wptr [ActualInt71]   ;is the offset any different ?
	jnz     MaskIrq9Off             ;yes, mask IRQ9 off

; the app has not hooked IRQ 2 or 9, so we will just restore the Windows
; state for the slave PIC.

	mov     al,GlobalSlavePICMask   ;get the mask
	jmp     short OutSlavePicMask   ;reprogram it

MaskIrq9Off:

	mov     al,GlobalSlavePICMask   ;get the mask
	or      al,00000010b            ;disable IRQ 9
	mov     AppUsesIRQ9,0ffh        ;set it.

OutSlavePicMask:

	call    WriteSlavePICMask       ;program the mask

	pop     es
	ret

ProcessAppSlavePICMask endp
;----------------------------------------------------------------------------;
; RestoreSlavePICMask:                                                       ;
;                                                                            ;
; If 'AppUsesIRQ9' is 0ffh, we should restore the apps mask for the slave    ;
; PIC else we should not touch the slave PIC at all.  The mask that is to be ;
; restored is in AL.                                                         ;
;----------------------------------------------------------------------------;

RestoreSlavePICMask proc near

	cmp     AppUsesIRQ9,0ffh        ;is it IRQ 9 owner ?
	jnz     @f                      ;no, do not reprogram IRQ9.
	call    WriteSlavePICMask       ;set the apps mask back.
@@:
	ret

RestoreSlavePICMask endp
;----------------------------------------------------------------------------;
; PressKeyToExit:                                                            ;
;                                                                            ;
; If fDestroy pif setting is set, this routine is set, this routine is a nop ;
; else in text mode it will display the message 'Press Any Key To Exit' on   ;
; the bottom right corner of the screen and wait till user types in a key.In ;
; graphics mode, it will still wait for the key, but will not display any    ;
; message.                                                                   ;
;                                                                            ;
; This routine also flushes the keyboard buffer before doing the read to take;
; away spurious characters from the buffer.                                  ;
;----------------------------------------------------------------------------;

PressKeyToExit  proc    near

	test    WoaBehavior,fDestroy    ;destroy window bit set ?
	jnz     PressKeyToExitRet       ;yes, do not wait

; test for text or graphics mode.

	mov     ah,0fh                  ;get mode call
	int     10h                     ;al has mode
	cmp     al,3                    ;text mode ?
	jbe     DisplayPromptString     ;yes, must prompt user
	cmp     al,7                    ;the other text mode ?
	jz      DisplayPromptString     ;yes,must prompt the user
	jmp     short HitKeyToExit      ;wait for a key stroke

DisplayPromptString:

; display the prompt string on the bottom right corner of the screen. At this
; point AH has the number of coloumns and BH has the active page number.

	pushem  es,bp                   ;save.
	mov     cx,40h                  ;want to access BIOS data area
	mov     es,cx                   ;es points to BIOS data area
	mov     dh,es:[84h]             ;get the last row number

; if the returned values is < 24 use 24. (On some machines like the HP vectra
; BIOS does not maintain the no of lines here so the number will most probably
; be 0.

	cmp     dh,24                   ;25-1?
	jae     @f                      ;40:84h is probably valid, use it.
	mov     dh,24                   ;assume 24 line mode
@@:
	mov     dl,ah                   ;get the last coloumn number
	smov    es,cs                   ;make es point to StubSeg
	mov     cx,PromptStringLength   ;get the length of prompt string
	sub     dl,cl                   ;compute starting coloumn for display
	dec     cx                      ;will not display last space
	mov     bl,70h                  ;will display black text over white
	mov     ax,1301h                ;display string code, move cursor
	mov     bp,StubSegOFFSET PromptString
	int     10h                     ;display the prompt string
	popem   es,bp                   ;restore the registers

HitKeyToExit:

; flush the keyboard buffer.

	mov     ax,0c00h                ;flush keyboard only
	call    DosCall                 ;make a dos call.

; wait for a key stroke, and then exit.

	mov     ah,07h                  ;read character without echo

; at this point do an actual int 21 call so that we will trap it and allow
; an ALT-PRINT-SCREEN to work (if supported).

	int     21h                     ;get the character

PressKeyToExitRet:

	ret

PressKeyToExit  endp
;----------------------------------------------------------------------------;
; This routine resets the keyboard ports and interrupts so that the interrupt;
; is effectively taken care of.                                              ;
;----------------------------------------------------------------------------;

SwallowKey      proc    near

	push    ax                      ;save register
	in      al,61h                  ;read in code
	mov     ah,al                   ;save it
	or      al,80h
	out     61h,al                  
	xchg    ah,al
	out     61h,al
	cli                             
	mov     al,20h                  ;need to output the eoi
	out     20h,al
	sti
	pop     ax                      ;restore
	ret

SwallowKey      endp
;----------------------------------------------------------------------------;
; this function saves all the registers, and here we define equates to access;
; the registers off the stack.                                               ;
;----------------------------------------------------------------------------;

SaveRegisters proc near

; BP is already on stack

	cli                             ;disable interrupts
	pop     cs:[PopRet]             ;save restuen address
	pushem  dx,es,bx,ax,cx,si,di    ;save registers
	and     USER_FLAGLOW,11111110b  ;clears users carry
	push    cs:[PopRet]             ;put back return address
	cld                             ;set proper direction
	sti                             ;enable interrupts
	ret

SaveRegisters  endp
;----------------------------------------------------------------------------;
; This function restores the registers saved by the 'SaveRegisters' call &   ;
; also restores ds and bp which where saved on entry to Int21ISR.            ;
;----------------------------------------------------------------------------;

RestoreRegisters  proc near

	pop     cs:[PopRet]             ;get the return address
	popem   dx,es,bx,ax,cx,si,di    ;restore registers
	pop     ds                      ;restore ds
	pop     bp                      ;restore bp
	push    cs:[PopRet]             ;push back the return address
	ret                             

RestoreRegisters endp
;----------------------------------------------------------------------------;
; StartXms:                                                                  ;
;                                                                            ;
; If an XMS handler has been loaded, it is invoked to set up its tables and  ;
; hook its vectors.                                                          ;
;---------------------------------------------------------------------------;

StartXms proc near

	cmp     WoafXmsInstalled,0      ;is there any xms handler
	jz      StartXmsRet             ;no.

; now invoke it to initialize itself and set up traps

	cCall   XmsInit                 ;invoke it

StartXmsRet:

	ret

StartXms endp
;----------------------------------------------------------------------------;
; PruneNumLines:                                                             ;
;                                                                            ;
; On entry AX has the number of lines that we want to set. Howver if this is ;
; we will parse it such that:                                                ;
;               >= 50 => use 50.                                             ;
;               <  43 => use 25                                              ;
;            else  use 25.                                                   ;
;----------------------------------------------------------------------------;

PruneNumLines proc near

	cmp     ax,50                   ;50 or above
	jae     PruneTo50               ;yes
	cmp     ax,43                   ;less than 43 ?
	jb      PruneTo25               ;yes, use 25
	mov     ax,43                   ;else use 43
	ret

PruneTo50:

	mov     ax,50                   ;50 line mode
	ret

PruneTo25:

	mov     ax,25                   ;25 line mode
	ret

PruneNumLines   endp
;----------------------------------------------------------------------------;
; CheckCallersCS:                                                            ;
;                                                                            ;
; This routine is called right after entering our INT 2AH & INT 5CH hooks &  ;
; it checks the value of the CS on the IRET frame. If the CS is below our CS ;
; or is above 0A000H, it returns with carry clear else carry is set.         ;
;----------------------------------------------------------------------------;

CheckCallersCS proc near

; at this time SS:SP points to <ret addr><iret ip><iret CS>....

	pushem  ax,bp                   ;save

; now SS:SP points to <bp><ax><ret addr><iret ip><iret CS>....

	mov     bp,sp                   ;get the current stack pointer
	mov     bp,[bp][8]              ;get the CS
	mov     ax,cs                   ;get our code seg
	cmp     ax,bp                   ;is callers CS above us ?
	ja      CheckCallersCSRet       ;carry reset, call not from app
	cmp     bp,0a000h               ;is it above 0A000H ?
	jae     CheckCallersCSRet       ;carry reset, call not from app
	stc                             ;call made from the Dos App.

CheckCallersCSRet:

	popem   ax,bp                   ;restore saved registers
	ret

CheckCallersCS endp
;----------------------------------------------------------------------------;
; TestForMinFreeHandles:                                                     ;
;                                                                            ;
; This routine gropes though the SFT nodes and tries to see if atleast       ;
; WOA_MIN_FILEHANDLES number of handles are available. If not carry flag is  ;
; set. These are the number of handles that are needed to ensure that WOA    ;
; will be able to switch out of this app and either get back to Windows or   ;
; start another Dos app.                                                     ;
;----------------------------------------------------------------------------;

TestForMinFreeHandles proc near

	pushem  es,bx,ax,cx,di          ;save
	xor     ax,ax                   ;no of free handles obt. thusfar
	les     bx,cs:[lpDosData]       ;ES:BX points to Dos's data
	les     bx,es:[bx][4]           ;es:bx -> first sft node

WalkSFTNodes:

	mov     cx,es:[bx+sftCount]     ;get the no of links in this node.
	lea     di,[bx+sftFile]         ;es:di points to the first link

WalkSFTLinks:

	cmp     bptr es:[di+sf_ref_count],0 ;is this link free ?
	jnz     @f                      ;no.
	inc     ax                      ;one more free entry obtained.
	cmp     ax,WOA_MIN_FILEHANDLES  ;do we enough ?
	jae     TestForHandlesRet       ;yes, carry clear
@@:
	add     di,cs:[WoaFileEntrySize];onto the next link
	loop    WalkSFTLinks            ;keep searching in this node.

; look at the next node if one exists.

	les     bx,es:[bx+sftLink]      ;get next sft in chain...
	cmp     bx,-1                   ;0ffff in first word marks end of chain
	jnz     WalkSFTNodes            ;search this node.

; not enough file handles are free, we must return with carry set.

	stc                             ;error return

TestForHandlesRet:

	popem   es,bx,ax,cx,di          ;save
	ret

TestForMinFreeHandles endp
;----------------------------------------------------------------------------;
; GetXmsHandler:                                                             ;
;                                                                            ;
; This function sets up the address of the actual XMS handler.               ;
;----------------------------------------------------------------------------;

GetXmsHandler   proc near

; check to see if XMS installed or not.

	mov     XmsFlag,0               ;assume not installed
	mov     ax,4300h                ;installation check.
	int     2fh
	cmp     al,80h                  ;is it installed
	jnz     GetXmsHandlerRet        ;no.
	mov     XmsFlag,0ffh            ;XMS is installed

	pushem  es,bx                   ;save
	mov     ax,4310h                ;get XMS handler address call
	int     2fh                     ;handler address is in ES:BX
	mov     wptr [ActualXms+2],es   ;save segment of original handler
	mov     wptr [ActualXms],bx     ;save offset of actual handler
	popem   es,bx                   ;restore

GetXmsHandlerRet:

	ret

GetXmsHandler   endp
;----------------------------------------------------------------------------;
; SetCorrectA20State:                                                        ;
;                                                                            ;
; If HIMEM is installed, Windows is always going to work with A20 on. The app;
; may however turn it off on its own (Paradox386 does it on some machines).  ;
; To restore the state of the A20 line we will do a 'LocalEnableA20' followed;
; by a 'LocalDisableA20'.                                                    ;
;                                                                            ;
; The assumption here is that as Windows operates with A20 on, the A20 enable;
; count in HIMEM will be 1 atleast and the 'LocalEnableA20' will increment it;
; and thus 'LocalDisableA20' will never set it off. However, if the app did  ;
; actually set A20 off, then 'LocalEnableA20' will set it back on.           ;
;                                                                            ;
; All these must be done only if HIMEM is installed, XmsFlag will have 0ffh  ;
; in this case.                                                              ;
;----------------------------------------------------------------------------;

SetCorrectA20State  proc near

	cmp     XmsFlag,0ffh            ;is HIMEM installed ?
	jnz     SetCorrectA20StateRet   ;no himem.

; do a 'LocalEnableA20' followed by a 'LocalDisableA20'.

	mov     ah,05h                  ;LocalEnableA20
	call    [ActualXms]             ;A20 set on if it was off.
	mov     ah,06h                  ;LocalDisableA20
	call    [ActualXms]             ;cancell prev call, A20 stays on

SetCorrectA20StateRet:

	ret

SetCorrectA20State endp
;----------------------------------------------------------------------------;
; DoInt28:                                                                   ;
;                                                                            ;
; This routine does INT 28H calls and is called from the Dos read keyboard   ;
; trap routines. However we will do the INT 28H only if the critical error   ;
; flag is reset. This is because some TSRs (like LANMAN) may have INT 28H    ;
; hooked and they might do other DOS calls from their hook. This should not  ;
; happen while we are in the critical error handler.                         ;
;----------------------------------------------------------------------------;

DoInt28 proc near

	pushem  es,bx                   ;save
	les     bx,cs:[lpErrModeFlag]   ;ES:BX points to error flag
	cmp     byte ptr es:[bx],0      ;are we in the critical error handler ?
	jnz     @f                      ;yes, don't do INT 28H
	int     28h                     ;ok to do the INT 28h
@@:
	popem   es,bx                   ;restore
	ret

DoInt28 endp
;----------------------------------------------------------------------------;
; DisableInt15Mouse:                                                         ;
;                                                                            ;
; This routine disables the INT 15H mouse if a flag says that the event      ;
; handler is in local memory.                                                ;
;----------------------------------------------------------------------------;
DisableInt15Mouse proc near

	cmp     LocalInt15MouseHandler,0;is there a local handler ?
	jz      DisableInt15MouseRet    ;no.
	pushem  ax,bx                   ;save
	mov     ax,0c200h               ;enable/disable code
	xor     bh,bh                   ;disable
	int     15h                     ;disable the mouse.
	popem   ax,bx                   ;restore

DisableInt15MouseRet:

	ret

DisableInt15Mouse endp
;----------------------------------------------------------------------------;
; EnableInt15Mouse:                                                          ;
;                                                                            ;
; This routine enables the INT 15H mouse if a flag says that the event       ;
; handler is in local memory.                                                ;
;----------------------------------------------------------------------------;
EnableInt15Mouse proc near

	cmp     LocalInt15MouseHandler,0;is there a local handler ?
	jz      EnableInt15MouseRet     ;no.
	pushem  ax,bx                   ;save
	mov     ax,0c200h               ;enable/disable code
	mov     bh,1                    ;enable
	int     15h                     ;disable the mouse.
	popem   ax,bx                   ;restore

EnableInt15MouseRet:

	ret

EnableInt15Mouse endp
;----------------------------------------------------------------------------;
; OEMBeep:                                                                   ;
;                                                                            ;
; This routine taken from the grabber sources hoots the hooter.              ;
;----------------------------------------------------------------------------;

OEMBeep         proc    near

	pushem  ax,cx                   ;save registers to be destroyed
	mov     al,0B6H                 ;select timer 2
	out     PIT_PORTD,al
	mov     ax,BEEP_TONE1           ;divisor for tone 1
	out     PIT_PORTC,al            ;write timer 2 count - lsb
	mov     al,ah
	out     PIT_PORTC,al            ;write timer 2 count - msb
	in      al,PPI_PORTB            ;get current setting of port
	mov     ah,al                   ;save setting
	or      al,00000011b            ;turn speaker on
	out     PPI_PORTB,al
	mov     cx,BEEP_TIME1           ;wait awhile
	loop    $
	mov     cx,BEEP_TONE2           ;divisor for tone 2
	mov     al,cl
	out     PIT_PORTC,al
	mov     al,ch
	out     PIT_PORTC,al
	mov     cx,BEEP_TIME2           ;wait again
	loop    $
	mov     al,ah
	out     PPI_PORTB,al
	popem   ax,cx                   ;restore saved registers
	ret

OEMBeep         endp

;----------------------------------------------------------------------------;
sEnd    StubSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaswapi.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

  
;----------------------------------------------------------------------------;
; This file implements all the switch API functions.			     ;
;									     ;
; History:								     ;
;									     ;
;	 Tue Nov-13-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 'SwitchAPICallIn' returns with carry set for unsupported call-ins.  ;
;									     ;
;        Thu Aug-23-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Switcher. (Added the History legend)    		     ;
;----------------------------------------------------------------------------;


	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include njmp.mac
	include woaswapi.inc
	include woakeys.inc
	.list

	.8086

;----------------------------------------------------------------------------;
; define any public labels or eqautes here.				     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,StubSeg

;----------------------------------------------------------------------------;
; declare public labe and names.					     ;
;----------------------------------------------------------------------------;

			public	SwitchAPICallIn

;----------------------------------------------------------------------------;
; declare variables defined in other files.				     ;
;----------------------------------------------------------------------------;

externW		WoahApp			;App's ID
externB		SwitcherName		;name of the switcher
externW		SwitcherDisabled	;code why switcher is disabled
externB		WoaSwitcherID		;ID of this switcher
externB		WoaHotKeyState		;type of hot key pressed
externW		WoaNodeToSwitchTo	;next node that we want to switch to
externB		WoaNetAsyncSwitching	;Network to be monitored or not
externB		AsyncNetPending		;asynchronous requests seen or not
externW		WoaSwapAreaParaSize	;size of the swap area

;----------------------------------------------------------------------------;
; define data areas that we need in this file.				     ;
;----------------------------------------------------------------------------;

Our_Ver_Struc  	Switcher_Ver_Struc <>	;our version information
Our_NB_API_Info	API_Info_Struc	<>	;our NetBios handler details.

lpCallBackChain		dd	?	;address of the call back SCBI list
CallBackAddrValid 	db	0	;above addr valid or not (not by default)

;----------------------------------------------------------------------------;
; declare external constants.						     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; define local constants.						     ;
;----------------------------------------------------------------------------;

SD_SWAPI_DISABLE  equ	04h		;disabled by another switcher

;----------------------------------------------------------------------------;
; define the call-in jump table.				             ;
;----------------------------------------------------------------------------;

SwitchAPICallInTable label word

	dw	GetVersion		;AX=0
	dw	TestMemoryRegion	;AX=1
	dw	SuspendSwitcher		;AX=2
	dw	ResumeSwitcher		;AX=3
	dw	HookCallOut		;AX=4
	dw	UnHookCallOut		;AX=5
	dw	QueryAPISupport		;AX=6


SWAPI_MAX_CALL_IN equ 6			;highest call number
;----------------------------------------------------------------------------;
; InitSwitcherAPI:							     ;
;									     ;
; This routine should do whatever is needed to initialize our Switcher API   ;
; support. At this momemnt it does the following:			     ;
;									     ;
;	. prepares the GetVersion return information buffer		     ;
;	. prepare a API_Info_Struc buffer for our NetBios handling details   ;
;       . finds out who is the best API handler for NetBios and if there is  ;
;	  one who is better, it sets the 'WoaNetAsyncSwitching' flag so that ;
;	  we will not mess with NetBios calls.				     ;
;									     ;
; Entry:								     ;
;       None.								     ;
; Exit:									     ;
;	None.								     ;
; Uses:									     ;
;	AX,Flags.							     ;
;----------------------------------------------------------------------------;
cProc	InitSwitcherAPI,<NEAR,PUBLIC,PASCAL>,<es,di,bx,si>

	localD	lp_ISAPI_Call		;to build a call address
cBegin

; prepare the invaliant part of the information buffer.

	smov	es,cs			;es:di -> the buffer to fill.
	mov	di,StubSegOFFSET Our_Ver_Struc
	mov	ax,OUR_API_MAJOR	;save major version of our API spec
	mov	es:[di.SVS_API_Major],ax
	mov	ax,OUR_API_MINOR	;save minor version of our API spec
	mov	es:[di.SVS_API_Minor],ax
	mov	ax,OUR_PRODUCT_MAJOR	;save major version of the switcher
	mov	es:[di.SVS_Product_Major],ax
	mov	ax,OUR_PRODUCT_MINOR	;save minor version of the switcher
	mov	es:[di.SVS_Product_Minor],ax
	xor	ah,ah			
	mov	al,WoaSwitcherID	;save the ID
	mov	es:[di.SVS_Switcher_ID],ax
	mov	ax,SwitcherDisabled	;save the state
	and	ax,SD_SWAPI_DISABLE	;isolate the disabled/enabled flag
	shiftr	ax,2			;bring it to LSB
	.errnz	SD_SWAPI_DISABLE - 4
	mov	es:[di.SVS_Flags],ax	
	mov	ax,StubSegOFFSET SwitcherName  ;get the offset of ID
	mov	wptr es:[di.SVS_Name_Ptr],ax   ;save offset 
	mov	ax,cs			       ;get the segment of name
	mov	wptr es:[di.SVS_Name_Ptr.2],ax ;save segment

; check to see if there is another switcher.

	pushem	es,di			;save
	mov	ax,SWAPI_DETECT_SWITCHER;detect switcher code
	xor	di,di			;need lots of zeros
	mov	es,di			;ES:DI = 0
	mov	bx,di			;BX = 0
	int	2fh			;make the call
	mov	ax,es			;is there another switcher ?
	or	ax,di
	jz	ISAPI_NoOther		;no.

; get the address of the previous switcher's version structure.

	mov	seg_lp_ISAPI_Call,es	;save segment of call address
	mov	off_lp_ISAPI_Call,di	;save offset of call address
	mov	ax,SWAPI_GETVERSION	;need to do a get version call
	pushf				;save interrupt flags
	cli				;interrupts disabled for call
	call	lp_ISAPI_Call		;get the address of the structure
	popf				;restore interrupt state
	mov	di,bx			;ES:DI has the address.

ISAPI_NoOther:

	mov	ax,di			;get offset of the structure
	mov	bx,es			;get the segment of the structure
	popem	es,di			;restore pointer to our structure
	mov	wptr es:[di.SVS_Prev_Switcher],ax   ;save offset 
	mov	wptr es:[di.SVS_Prev_Switcher.2],bx ;save segment

; the version structure has been prepared, prepare a buffer having details 
; about the level of our NetBios handler.

	smov	es,cs			;es:di -> the buffer to fill.
	mov	di,StubSegOFFSET Our_NB_API_Info
	mov	ax,SIZE API_Info_Struc  ;save size of the node
	mov	es:[di.AIS_Length],ax	
	mov	ax,API_NETBIOS		;save API code
	mov	es:[di.AIS_API],ax	
	mov	ax,OUR_NB_MAJOR_VER	;save major version of our support
	mov	es:[di.AIS_MAJOR_VER],ax
	mov	ax,OUR_NB_MINOR_VER	;save minor version of our support
	mov	es:[di.AIS_MINOR_VER],ax
	mov	ax,API_SL_MINIMAL	;save support level
	mov	es:[di.AIS_Support_Level],ax

; Now get the information about the best NetBios handler in the system. 
; If 'WoaNetAsyncSwitching' is 0 we will not do any checks at all since 
; we will not be handling NetBios calls then

	cmp	WoaNetAsyncSwitching,0	;No NetBios support ?
	jnz	ISAPI_Ret		;that right.
	mov	ax,SWAPI_QUERY_API_SUPPORT
	mov	bx,API_NETBIOS		;we are interested in NetBios alone
	call	QueryAPISupport		;a call in function supported by us

; compare to see if ours is the best or not. If they are equal we would still
; enforce ours since what is returned could be information about ourselves.

	mov	ax,es			;get the segment
	mov	di,cs			;get our cs
	cmp	ax,di			;is it in our segment ?
	jnz	ISAPI_NoNBSupport	;no, we will turn off NB support
	cmp	bx,StubSegOFFSET Our_NB_API_Info
	jz	ISAPI_Ret		;our's is the best, we will do NetBios

ISAPI_NoNBSupport:

; there is a better NetBios handler in the system than us. We will not handle
; any NetBios calls, that is, we will set WoaNetAsyncSwitching.

	mov	WoaNetAsyncSwitching,-1 ;no NetBios support

ISAPI_Ret:

cEnd
;----------------------------------------------------------------------------;
; BuildCallBackChain:							     ;
;									     ;
; This routine builds the chain of call back nodes.			     ;
;									     ;
; Entry: 								     ;
;	 None.							             ;
; Exit:									     ;
;       ES:BX	-- Call Back Chain.					     ;
;----------------------------------------------------------------------------;
cProc	BuildCallBackChain,<NEAR,PUBLIC,PASCAL>,<ax,cx,dx>

cBegin	

	pushf				;save interrupt state
	mov	ax,SWAPI_BUILD_CHAIN

; load ES:BX to be 0:0

	xor	bx,bx			;es:bx should be 0 at call time
	mov	es,bx

; load the call in finction address in CX:DX

	mov	dx,StubSegOFFSET SwitchAPICallIn
	mov	cx,cs

; make the INT 2FH call to build the chain of call back nodes.

	int	2fh
	popf				;restore interrupt state

cEnd
;----------------------------------------------------------------------------;
; OkToSuspend?:								     ;
;									     ;
; This call checks to see if it is ok to syspend the current app. The        ;
; following actions are done:						     ;
;									     ;
;	(1) A QuerySuspend call is done. If any one fails this call we do    ;
;	    a SessionActive call to all respondents and abort the switch     ;
;	    attempt. Else,						     ;
;	(2) We check to see whether our NetBios handler says it's OK to      ;
;	    switch or not (based on whether asynchronous calls have gone     ;
;	    through or not). If all's fine we move to step 3, else we        ;
;	    check to see if there is a better NetBios handler than us or not.;
;	    If there are none, we do a SessionActive call abd bort the       ;
;	    switch attempt. Else,					     ;
;	(3) We do a SuspendSession call. If this call is failed we abort     ;
;           our switch attempt as mentioned above, else this routine sets the;
;	    zero flag and returns, meaning thereby, it is ok to switch.	     ;
;									     ;
; Entry:								     ;
;	 None.								     ;
; Exit:									     ;
;        ZERO SET    - If the app can be suspended. Also Interrupts are      ;
;		       disabled in this case.				     ;
;      ZERO CLEAR    - If app cannot be suspended.			     ;
;----------------------------------------------------------------------------;
cProc	OkToSuspend?,<NEAR,PUBLIC,PASCAL>,<ax,bx,dx,es>

cBegin

	mov	ax,SWAPI_QUERY_SUSPEND	;code for QuerySuspend
	mov	dx,0ffffh		;call expects a return code
	sti				;interrupts on for this call
	call	MakeSwitchAPICall	;make the Switch API call
	jnz	SuspendFails		;some node failed the call
	cli				;shut off interrupts.

; have we seen any asynchronous NetBios requests go by ?

	cmp	cs:[AsyncNetPending],0	;any asynchronous net requests ?
	jz	OKTS_Step3		;next step.

; get a ptr to the API info structure block of the best handler of the 
; NetBios API.

	mov	ax,SWAPI_QUERY_API_SUPPORT
	mov	bx,API_NETBIOS		;we are interested in NetBios alone
	call	QueryAPISupport		;a call in function supported by us

; compare to see if ours is the best or not. If it is then we will make the
; decisions and since rquests have been oustanding we will fail the call.

	mov	ax,es			;get the segment
	mov	dx,cs			;get our cs
	cmp	ax,dx			;is it in our segment ?
	jnz	OKTS_Step3		;no, goto step 3
	cmp	bx,StubSegOFFSET Our_NB_API_Info
	jz	SuspendFails		;fail the switch.

OKTS_Step3:

; do the actual suspend call now. Interrupts should be disabled for this call

	mov	ax,SWAPI_SUSPEND	;code for QuerySuspend
	mov	dx,0ffffh		;call expects a return code
	cli				;interrupts off for this call
	call	MakeSwitchAPICall	;make the Switch API call
	jz	OkToSuspendRet		;suspend succeeded

SuspendFails:

; we got to make a SessionActive call into all the nodes

	mov	ax,SWAPI_SESSION_ACTIVE	;code for SessionActive
	xor	dx,dx			;call expects no return code
	push	cx			;save cx
	xor	cx,cx			;not the first SessionActive call
	sti				;interrupts on for this call
	call	MakeSwitchAPICall	;make the Switch API call
	pop	cx			;recover cx, ax != 0
	or	ax,ax			;ZERO not set -> failure

OkToSuspendRet:

; invalidate the call back address.

	mov	cs:[CallBackAddrValid],0;the address is invalid

cEnd
;----------------------------------------------------------------------------;
; MakeSwitchAPICall:							     ;
;									     ;
; This routine walks build the Switch API call back structure and calls the  ;
; the entry points in the chain with the function code in AX till all nodes  ;
; have been called or some node returns a non zero value in AX.		     ;
;									     ;
; Entry:								     ;
;	 AX     -    Switch API function code.				     ;
;	 DX	-    0 if return code not significant, -1 if it is.	     ;
;     Flags	-    Interrupts enabled/disabled as appropriate for the call ;
;								             ;
; Exit:									     ;
;    ZeroSet	-    If all the nodes returned success.			     ;
;									     ;
; Note: When this routine is called, DS will not always be our segment.      ;
;----------------------------------------------------------------------------;

cProc	MakeSwitchAPICall,<NEAR,PUBLIC,PASCAL>,<es,di,ax,bx,cx,dx>

	localD	OTS_Call_Ptr		;needed to call through a DWORD

cBegin

	cCall	BuildCallBackChain	;ES:BX points to start of chain

; we should save the address of the call back chain so that all call ins to 
; us from within the call outs do not have to regenerate the chain. This addr
; will however be invalidated at the end of this call.

	mov	wptr cs:[lpCallBackChain],bx ;save address of call back chain.
	mov	wptr cs:[lpCallBackChain+2],es
	mov	cs:[CallBackAddrValid],-1	;the address is valid
	
WalkChainLoop:

	push	ax			;save
	mov	ax,es			;is es:bx 0 ?
	or	ax,bx			;end of chain ?
	pop	ax			;restore
	jz	MakeSwitchAPICallRet	;yes, call was successful

; call down the chain.

	pushem	es,bx,ax,cx		;save in case the call destroys this
	push	dx			;save return code mask
	les	bx,es:[bx.SCBI_Entry_Pt];get the entry point
	mov	seg_OTS_Call_Ptr,es
	mov	off_OTS_Call_Ptr,bx	;save the address we want to call
	mov	bx,cs:[WoahApp]		;ID of app
	smov	es,cs			;es = cs
	mov	di,StubSegOFFSET SwitchAPICallIn
	call	OTS_Call_Ptr		;make the call
	pop	dx			;get back return code mask
	and	ax,dx			;mask the code
	or	ax,ax			;call returned success ?
	popem	es,bx,ax,cx		;restore pointer to current node & code
	jnz	MakeSwitchAPICallRet    ;this call was failed
	les	bx,es:[bx.SCBI_Next]	;load the pointer to the next node.
	jmp	short WalkChainLoop	;continue checking.

MakeSwitchAPICallRet:

cEnd
;----------------------------------------------------------------------------;
; SwitchAPICallIn:							     ;
;									     ;
; This is the Switch API call in function. This routine checks to see whether;
; the entry code is in range and if it is then the appropriate handler is    ;
; called. Carry is set for unsupported call-ins.			     ;
;----------------------------------------------------------------------------;
SwitchAPICallIn	 proc far

	cmp	ax,SWAPI_MAX_CALL_IN	;in range ?
	ja	SwitchAPICallInErr	;no. Return with carry set
	push	bx			;save
	mov	bx,ax			;get the entry code
	shl	bx,1			;for indexing into jump table
	add	bx,StubSegOFFSET SwitchAPICallInTable
	mov	ax,cs:[bx] 		;get the call address
	pop	bx			;restore
	call	ax			;call the routine

SwitchAPICallInRet:

	ret    

SwitchAPICallInErr:

	stc				;unsupported call-in
	ret

SwitchAPICallIn endp
;----------------------------------------------------------------------------;
; GetVersion:   							     ;
;                Entry:							     ;
;			AX = 0						     ;
;		        Interrupts are disabled and may not be enabled.      ;
;			DOS calls may NOT be made.			     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0 for future extensibility.		     ;
;		     ES:BX = address of current switcher ver structures.     ;
;									     ;
;----------------------------------------------------------------------------;
GetVersion proc near

	smov	es,cs			;make es:bx point to Our_Ver_Struc
	mov	bx,StubSegOFFSET Our_ver_Struc
	xor	ax,ax			;also clears carry
	ret

GetVersion endp
;----------------------------------------------------------------------------;
; TestMemoryRegion:							     ;
;                Entry:							     ;
;			AX = 1						     ;
;		     ES:DI = start of buffer				     ;
;		        CX = size of buffer (0=64K)			     ;
;		     Interrupts are disabled and may not be enabled.         ;
;		     DOS calls may NOT be made.				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	If entire buffer is in global memory         ;
;			AX = 1	If partially in global memory		     ;
;			AX = 2	If entire buffer is in local memory	     ;
;									     ;
; Note: The are which is swapped out by the switcher starts at CS:0 and      ;
;       extends for 'WoaSwapAreaParaSize' paragraphs. This is the only area  ;
;       that we are going to treat as local, everything else is local.	     ;
;								             ;
;       There are 5 cases marked below with the appropriate return code.     ;
;			   						     ;
;									     ;
;			  |-------------------|				     ;
;			  | local memory      |				     ;
;  CASE:   1		2 |	    3	      |	4	   5		     ;
;       |------|    |--------|	 |-------| |-------|   |--------|	     ;
;       |------|    |--------|	 |-------| |-------|   |--------|	     ;
;  RETS:   0		1 |----------2--------|	1	   0		     ;
;									     ;
;----------------------------------------------------------------------------;
TestMemoryRegion proc near

	pushem	bx,cx,dx,si,di		;save
	xor	ax,ax
	mov	bx,es	  		;ax:bx has the start segment
	dec	cx			;one less than size

REPT 	4
	shl	bx,1			;shift AX:BX left by 1
	rcl	ax,1
ENDM

	add	bx,di			;add in start offset
	adc	ax,0			;AX:BX has start linear address

; compare AX:BX to CS:0, If AX:BX is less we have case 1 or 2, else 3, 4 or 5

	mov	di,cs			;get CS
	xor	si,si			;SI:DI will have left edge of LocalMem
REPT 	4
	shl	di,1			;shift AX:BX left by 1
	rcl	si,1
ENDM

	call	CompareAXBXtoSIDI	;do the comparision
	jnc	short TMR_Case3or4or5	;beyong left edge of LocalMemory

; we have case 1 or 2.

	add	bx,cx
	adc	ax,0			;AX:BX has the rt edge of the buffer

; compare the right edge of the buffer to the left edge of global memory

	call	CompareAXBXtoSIDI	;do the comparision
	jc	TMR_RetCase1or5		;case 1.
	jmp	short TMR_RetCase2or4	;case 2

TMR_Case3or4or5:

; get the right edge of global memory.

	mov	di,cs			;get CS
	add	di,cs:[WoaSwapAreaParaSize];add in size of the local memory
	xor	si,si			;SI:DI will have left edge of LocalMem
REPT 	4
	shl	di,1			;shift AX:BX left by 1
	rcl	si,1			;SI:DI is one byte beyond right edge
ENDM
	
; figure out if it is case 5 or not. AX:BX is left edge of buffer and SI:DI
; is one byte beyond right edge of local memory.

	call	CompareAXBXtoSIDI	;do the comparision
	jnc	TMR_RetCase1or5		;case 5.

; we have case 3 or 4. Get the right edge of buffer.

	add	bx,cx
	adc	ax,0			;AX:BX has the rt edge of the buffer

; figure out whether it is case 3 or 4.

	call	CompareAXBXtoSIDI	;do the comparision
	jnc	TMR_RetCase2or4		;case 4

TMR_RetCase3:

	mov	ax,2			;buffer is totally local.
	jmp	short TMR_Ret		;done.

TMR_RetCase1or5:

	xor	ax,ax			;totally global
	jmp	short TMR_Ret		;done.

TMR_RetCase2or4:

	mov	ax,1			;partially in local memory

TMR_Ret:

	popem	bx,cx,dx,si,di		;restore
	ret

TestMemoryRegion  endp
;----------------------------------------------------------------------------;
; SuspendSwitcher:							     ;
;									     ;
;                Entry:							     ;
;			AX = 2						     ;
;		     ES:DI = Switcher call in of new task switcher,	     ;
;			     or 0:0 if not supported.			     ;
;		     Interrupts are enabled.				     ;
;		     DOS calls can be made.				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	If the switcher is now suspended.	     ;
;			AX = 1	If the switcher cannot be suspended.         ;
;			AX = 2  Not suspended, others may start.	     ;
;----------------------------------------------------------------------------;
SuspendSwitcher proc near

; set a flag bit to disabled the Switcher.

	or	cs:[SwitcherDisabled], SD_SWAPI_DISABLE				
	xor	ax,ax			;switcher being disabled, clears carry
	ret

SuspendSwitcher endp
;----------------------------------------------------------------------------;
; ResumeSwitcher:							     ;
;									     ;
;                Entry:							     ;
;			AX = 3						     ;
;		     ES:DI = Switcher call in of new task switcher.	     ;
;		     Interrupts are enabled.				     ;
;		     DOS calls can be made.				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	(required for future extensibility)	     ;
;----------------------------------------------------------------------------;
ResumeSwitcher proc near

; reset a flag bit which tells us that the switchet is disabled by another
; task switcher.

	and	cs:[SwitcherDisabled], NOT SD_SWAPI_DISABLE
	xor	ax,ax			;return code, clears carry
	ret

ResumeSwitcher endp
;----------------------------------------------------------------------------;
; HookCallout:								     ;
;									     ;
;                Entry:							     ;
;			AX = 4						     ;
;		     ES:DI = address of routine to add to call out chain.    ;
;		     Interrupts are enabled.				     ;
;		     DOS calls can be made.				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	(required for future extensibility)	     ;
;----------------------------------------------------------------------------;
HookCallOut proc near

	xor	ax,ax			;we generate INT 2f every time, carry clear
	ret

HookCallOut endp
;----------------------------------------------------------------------------;
; UnHookCallout:  							     ;
;									     ;
;                Entry:							     ;
;			AX = 5						     ;
;		     ES:DI = address of routine to delete from call out chain;
;		     Interrupts are enabled.				     ;
;		     DOS calls can be made.				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	(required for future extensibility)	     ;
;----------------------------------------------------------------------------;
UnHookCallOut proc near

	xor	ax,ax			;we generate INT 2f every time, carry clear
	ret

UnHookCallOut endp
;----------------------------------------------------------------------------;
; QueryAPISupport:							     ;
;									     ;
;                Entry:							     ;
;			AX = 6						     ;
;		        BX = API Code.					     ;
;		     Interrupts will not be enabled if the call is being from;
;		     within a call out from the switcher else they will be.  ;
;		     DOS calls will not be made				     ;
;		 Exit:							     ;
;		        carry flag clear				     ;
;			AX = 0	(required for future extensibility)	     ;
;		     ES:BX = address of the API_Info_Struc belonging to the  ;
;			     respondent with the best level of support for   ;
;			     this API.					     ;
;----------------------------------------------------------------------------;
QueryAPISupport proc near

	pushem	cx,si,ds		;save
	mov	cx,bx			;get the API code

; if the call back chain is still valid we whould not try to build the chain
; again.

	les	bx,cs:[lpCallBackChain]	;load it, in case it is vcalid
	cmp	cs:[CallBackAddrValid],0;is the call back address valid ?
	jnz	QAPIS_Walk_Chain	;it is valid

; will the chain again.

	cCall	BuildCallBackChain	;ES:BX points to start of chain

QAPIS_Walk_Chain:

	xor	si,si			;ds:si -> best handler's structure.
	mov	ds,si

QAPIS_WalkChainLoop:

	push	ax			;save
	mov	ax,es			;is es:bx 0 ?
	or	ax,bx			;end of chain ?
	pop	ax			;restore
	jz	QAPIS_DoneWithWalk	;yes, we have the results.

; get to the correct API node.

	pushem	es,bx,ax		;save
	les	bx,es:[bx.SCBI_API_Ptr]	;start of the pointer.
	mov	ax,es			;is it a valid node
	or	ax,bx			;NULL pointer ?
	jz	QAPIS_SameNode		;yes, skip this one.

QAPIS_SubLoop:

	mov	ax,es:[bx.AIS_Length]	;get the length 
	or	ax,ax			;is this the end ?
	jz	QAPIS_SameNode		;have exhausted the list
	cmp	es:[bx.AIS_API],cx	;is it the right API
	jz	QAPIS_FoundAPINode	;yes, got it!
	add	bx,ax			;es:bx -> next API node
	jmp	short QAPIS_SubLoop	;keep looking for node

QAPIS_FoundAPINode:

; check to see if this is a betther handler.

	call	CompareAPILevels	;compare levels
	jnc	QAPIS_SameNode		;current best is still best

; es:bx points to a better node's structure. Save it in DS:SI.

	smov	ds,es			;ds:si = es:bx
	mov	si,bx

QAPIS_SameNode:

	popem	es,bx,ax		;restore

; continue walking down the line.

	les	bx,es:[bx.SCBI_Next]	;load the pointer to the next node.
	jmp	short QAPIS_WalkChainLoop;continue checking.

QAPIS_DoneWithWalk:

; ds:si -> API_Info_Struc of best handler. Compare this with ours and if the
; current one is better or equal retain it.

	smov	es,cs			;es:bx -> to our API info structure
	mov	bx,StubSegOFFSET Our_NB_API_Info
	call	CompareAPILevels	;see if DS:SI still points to best
	jc	QAPIS_Ret		;ES:BX -> best handler's API struc

; DS:SI points to the best, put it in ES:BX

	smov	es,ds			
	mov	bx,si			

QAPIS_Ret:

	popem	cx,si,ds		;save
	ret

QueryAPISupport endp
;----------------------------------------------------------------------------;
; CompareAPILevels:							     ;
;									     ;
; Entry:								     ;
;	ES:BX -> first API Info structure.				     ;
;	DS:SI -> second API Info structure.				     ;
; Exit:									     ;
;	Carry clear if the second structure is still the better handler.     ;
; Uses:									     ;
;	Flags.								     ;
;----------------------------------------------------------------------------;

CompareAPILevels proc near
	
	push	ax			;save
	mov	ax,ds			;is there a valid second guy ?
	or	ax,si
	jz	CAPIL_FirstBest		;first one is the best.

	mov	ax,[si.AIS_Major_Ver]	;major ver of second one
	cmp	ax,es:[bx.AIS_Major_Ver];major ver of first one
	jb	CAPIL_FirstBest		;we have a new node
	ja	CAPIL_Ret		;second is better, carry clear
	mov	ax,[si.AIS_Minor_Ver]	;minor ver of second one.
	cmp	ax,es:[bx.AIS_Minor_Ver];minor ver of first guy.
	jb	CAPIL_FirstBest		;we have a new node
	ja	CAPIL_Ret		;the current one is better
	mov	ax,[si.AIS_Support_Level];level of second guy
	cmp	ax,es:[bx.AIS_Support_Level]
	jae	CAPIL_Ret		;second guy is better

CAPIL_FirstBest:

	stc				;first guy is better

CAPIL_Ret:

	pop	ax			;restore
	ret

CompareAPILevels endp
;----------------------------------------------------------------------------;
; ComapareAXBXtoSIDI:							     ;
;									     ;
; Compare AX:BX (32 bits) to SI:DI (32 bits), the flags return the result of ;
; the comparision as would a CMP AX:BX,SI:DI would do.			     ;
;----------------------------------------------------------------------------;
CompareAXBXtoSIDI  proc near

	cmp	ax,si			;compare high words
	jne	CABTSD_Ret		;either greater or less, flags tell
	cmp	bx,di			;compare low words, flags have result

CABTSD_Ret:

	ret

CompareAXBXtoSIDI  endp
;----------------------------------------------------------------------------;
; SWAPICreateSession:							     ;
;									     ;
; Makes a CREATE_SESSION SWAPI call out.     				     ;
;----------------------------------------------------------------------------;
cProc	SWAPICreateSession,<NEAR,PUBLIC,PASCAL>

cBegin
	mov	ax,SWAPI_CREATE		;create session call
	mov	dx,0ffffh		;call expects a return code
	sti				;interrupts on for this call
	call	MakeSwitchAPICall	;make the Switch API call

; invalidate the call back address.

	mov	cs:[CallBackAddrValid],0;the address is invalid

cEnd
;----------------------------------------------------------------------------;
; SWAPIResumeSession:							     ;
;									     ;
; Makes a RESUME_SESSION SWAPI call out.					     ;
;----------------------------------------------------------------------------;
cProc	SWAPIResumeSession,<NEAR,PUBLIC,PASCAL>

cBegin
	mov	ax,SWAPI_RESUME		;code for ResumeSession
	xor	dx,dx			;call expects no return code
	mov	cx,1			;being run for the first time
	cli				;interrupts off for this call.
	call	MakeSwitchAPICall	;make the Switch API call

; invalidate the call back address.

	mov	cs:[CallBackAddrValid],0;the address is invalid

cEnd
;----------------------------------------------------------------------------;
; SWAPISessionActive:							     ;
;									     ;
; Makes a SESSION_ACTIVE SWAPI call out. 				     ;
;----------------------------------------------------------------------------;
cProc	SWAPISessionActive,<NEAR,PUBLIC,PASCAL>

cBegin
	mov	ax,SWAPI_SESSION_ACTIVE	;code for SessionActive
	xor	dx,dx			;call expects no return code
	mov	cx,1			;being run for the first time
	sti				;interrupts on for this call
	call	MakeSwitchAPICall	;make the Switch API call

; invalidate the call back address.

	mov	cs:[CallBackAddrValid],0;the address is invalid

cEnd
;----------------------------------------------------------------------------;
; SWAPIDestroySession:							     ;
;									     ;
; Makes a DESTROY_SESSION SWAPI call out. 				     ;
;----------------------------------------------------------------------------;
cProc	SWAPIDestroySession,<NEAR,PUBLIC,PASCAL>

cBegin
	mov	ax,SWAPI_DESTROY	;code for DestroySession
	xor	dx,dx			;call expects no return code
	sti				;interrupts on for this call
	call	MakeSwitchAPICall	;make the Switch API call

; invalidate the call back address.

	mov	cs:[CallBackAddrValid],0;the address is invalid


cEnd
;----------------------------------------------------------------------------;
sEnd	StubSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woatsr.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This module contains the routine necessary to put up the tsr pop-up dialog ;
; box in case a TSR call was done and wait in a tight loop waiting for the   ;
; user to press a CTRL+C, in the mean time normal context switching can be   ;
; done (if hot keys are enabled).					     ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Mon July-17-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend) 		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	njmp.mac
	include macros.mac
	.list

	.286p

		public	ProcessTsr

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes	cs,StubSeg
	assumes	ds,StubSeg


;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;


;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
; define any locally used variables or messages.			     ;
;----------------------------------------------------------------------------;

	include	woamsg2.inc		;has the pop-up message box

;----------------------------------------------------------------------------;

ProcessTsr  proc near

; home the cursor and pop up the dialog

	mov	ax,1301h		;write string with attribute
	mov	bx,0007h		;page zero, normal attribute
	mov	cx,TSR_Instruct_Length	;length of string
	mov	dx,0200h		;start at line 2/col 0
	pushem	es,bp			;save
	mov	bp,StubSegOFFSET TSR_Instruct
	smov	es,cs			;es:bp has string
	int	10h			;display the string
	popem	es,bp			;restore registers


; EXTRA has some bad pit falls. It often will fail an INT 10 call depending
; on some internal state. This will cause the pop-up prompt not to be displayed
; if extra is run as 'command /c extra'. To take care of this we will try to
; check that the first character of the string is actually put out. If not
; then we will try to redisplay the string.

	mov	ah,02			;set cursor position

; the message started with a carriage return line feed, so read the chatacter
; on the next line.

	mov	dx,0300h		;the start of the string
	xor	bh,bh			;display page
	int	10h			;set back cursor to start of string
	mov	ah,08h			;read character code
	int	10h			;AL has the character
	cmp	al,bptr TSR_Instruct+2	;does it match ?
	jnz	ProcessTsr		;no.
	mov	dx,1900h		;position cursor on line 25
	mov	ah,02			;set cursor code
	int	10h

; now wait in aloop till a CTRL+C is done

TsrWaitLoop:

; Do the Read Using a INT 21 call, do not do INT 16 blocked-read because
; Attachmate's EXTRA parks on INT 16 and if we de-install at that point, it
; goes back to it's INT 16 code after de-installing hooks!! 

; More over we cannot do a block read INT 21 call either, because EXTRA is
; again going to park on this and will come back to their hook even after
; they have been deinstalled. Howver at this point their INT 21 trap code is
; in a free block and if we switch out from here their code will not be saved
; since it's in a free block and then we will die when we return.

; So we will do a get status call which returns CTRL+C too.


	mov	ah,6			;get key status
	mov	dl,0ffh			;keyboard input
	int	21h			;get a key in AL
	jz	TsrWaitLoop		;wait for a character
	cmp	al,03h			;CTRL+C pressed ?
	jnz	TsrWaitLoop		;no, continue waiting

	ret

ProcessTsr  endp
;----------------------------------------------------------------------------;

sEnd	StubSeg

end
	

	
	


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaswch.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This module has all the routines necessary for implementing the hot key    ;
; switch functions of windoldap. It takes three parameters on entry:	     ;
;									     ;
;      1.   SwitchType	   --- ALT_TAB,SHIFT_ALT_TAB,ALT_ESC etc.            ;
;      2.   CurrentWindow  --- window which was executing till now.          ;
;      3.   WindowState    --- whether to mark the window as dead or not.    ;
;									     ;
; This function module returns 3 information:				     ;
;									     ;
;      1.   NextWindow     --- handle of window to activate next	     ;
;      2.   SwapPathId	   --- swap path ID for the next window		     ;
;      3.   CarryFlag      --- set to indicate, the window belongs to OldApp ;
;									     ;
; The functions that this module has to do are:				     ;
;								             ;
;     . If CTRL_ESC is to be processed, simply return the a NULL handle	     ;
;     . Load the windows title information table from the windows swap file  ;
;	into the area pointed to by the low heap selector.                   ;
;     . Locate the node belonging to the current window in that table and if ;
;       it is to be marked as dead do so.			             ;
;     . Depending on whether we have to go back or forward, locate the next  ;
;       or the previous window node.					     ;
;     . If the switch type is ALT_ESC or SHIFT_ALT_ESC, return with the wind-;
;       -ow handle and set carry flag if the app is an old app.		     ;
;     . If we have to process a TAB type of switch, get into a loop, display-;
;       -ing a switcher screen with the current title and current set of     ;
;       colors and loop back when a TAB is pressed and ALT is still down     ;
;     . return with the handle and type of app in the current node once the  ;
;       ALT key is released.						     ;
;									     ;
; History:								     ;
;									     ;
;	 Tue Nov-113-1990.      -by-  Amit Chatterjee [amitc]		     ;
;	 * UnHookIn09 uses 'Hint09ChainAddr' instead of 'ActualInt09'	     ;
;									     ;
;        Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 * Modified the switcher interface to work with the shell interface. ;
;	 * Modified the code to use the StubSeg's INT 9 hook.		     ;
;									     ;
;        Tue June-20-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created. (Added the History legend)				     ;
;----------------------------------------------------------------------------;



	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	njmp.mac
	include woaerr.inc
	include woakeys.inc
	include woaswch.inc
	include macros.mac
	.list

	.8086

sBegin	Data

;----------------------------------------------------------------------------;
; declare the global variables defined elsewhere	  		     ;
;----------------------------------------------------------------------------;

externB	SwitcherColors			;colors for switcher screen
externW	hApp				;ID of the app
externB NodeToSwitchTo			;for directed hot key switch
externB	ReturnToShellCode		;code returned to the shell

	;-------------------------------------------------------;
	; define any locally used variables here.		;
	;-------------------------------------------------------;

TrackTabNode	dw	?		;cuurent position of TAB task pointer
NumApps		dw	0		;number of apps in the list

	;-------------------------------------------------------;
	; define public names here.				;
	;-------------------------------------------------------;


	;-------------------------------------------------------;
	; define any locally used constants			;
	;-------------------------------------------------------;


	;-------------------------------------------------------;
	; define any external contants.				;
	;-------------------------------------------------------;


;---------------------------------------------------------------------------;
; now define the other global variables that will be needed.		    ;
;---------------------------------------------------------------------------;

sEnd	Data
;----------------------------------------------------------------------------;
; declare code and data in the StubSegment that are referenced here.	     ;
;----------------------------------------------------------------------------;

sBegin	StubSeg

	externFP  Int09ISR		;(WOARLM.ASM)

externD		HInt09ChainAddr		;original INT 09 handler
externB		WoaHotKeyState		;INT 9 hook keeps key state here

sEnd	StubSeg
;----------------------------------------------------------------------------;

sBegin	Code

	assumes	cs,Code
	assumes	ds,Data
	assumes	es,nothing

;---------------------------------------------------------------------------;
; define the external function calls.					    ;
;---------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;

	externNP OpnFile		;(WOAFILE.ASM)
	externNP CloseFile		;(WOAFILE.ASM)
	externNP ReadFile		;(WOAFILE.ASM)
	externNP WriteFile		;(WOAFILE.ASM)
	externNP SetNormalAttributes	;(WOAFILE.ASM)
	externNP SetHiddenAttributes	;(WOAFILE.ASM)

;----------------------------------------------------------------------------;

cProc	SwitchManager,<NERA,PUBLIC,PASCAL>,<es,ds,si,di>

	parmW	SwitchType		;type of switch
	parmW	hWindow			;window which is active

	localB  FreshTitle		;back ground to be drawn or not

cBegin

	mov	TrackTabNode,0		;TAB pointer always starts at top
	mov	FreshTitle,0ffh		;back ground need to be drawn

	cmp	NodeToSwitchTo,-1	;normal switch ?
	jz	ConventionalSwitch	;yes

; we have a directed hot key switch.

	xor	bh,bh
	mov	bl,NodeToSwitchTo	;get the logical node num
	mov	ax,4a05h		;opcode
	mov	si,CTOTOP_ITH_LIST_PE	;get it to the top
	int	2fh			;dx:ax has the long pointer to node
	mov	es,dx
	mov	di,ax			;get pointer in es:di
	jmp	short DisplaySwitchTitle;display the title and be done

ConventionalSwitch:


; test for a valid Z-Order list.

	mov	ax,4a05h		;opcode
	mov	si,CGET_LIST_LENGTH	;get the no of programs.
	int	2fh			;dx:ax has the long pointer
	or	ax,ax			;0 means 1
	jnz	@f			;more than 1 (can't be empty)
	jmp	SwitchManagerExit	;return back, carry is clear
@@:

	mov	NumApps,ax		;save number of apps.
	test	SwitchType,WOA_CTRL_ESC ;is it a control esc type ?
	jz	@f			;no.

; we need to do a control esc type of switch, just return 0 to invoke
; the desktop manager. However before that we should bring the shell to
; the top of the list.

	xor	ax,ax			;internal ID for the shell.
	cCall	AppToTheTop,<ax>	;bring shell to the top
	xor	ax,ax			;return NULL
	clc				;not a old app
	jmp	SwitchManagerExit	;return back
@@:

	cCall	HookInt09		;hook the int 9 vector

DoTheSwitch:

; update the list depending on switch type. Returns pointer of Node to 
; display title from in DX:AX

	cCall	UpdateTaskList,<SwitchType>
	mov	es,dx			
	mov	di,ax			;es:[di] -> top entry
	jmp	short DisplaySwitchTitle

MoveTabTaskToTop:

; if the switch type is ALT_TAB type then we must move the original top node
; into the second position.

	test	SwitchType,WOA_SWITCH_TAB
	jz	SwitchDone		;not TAB type

; move the app pointed by the TAB pointer to the top.

	mov	bx,TrackTabNode		;current position of original top
	or	bx,bx			;currently at top ?
	jz	SwitchDone		;leave it there.
	mov	ax,4a05h		;opcode
	mov	si,CTOTOP_ITH_LIST_PE	;get it to the top
	int	2fh			;dx:ax has the long pointer to node
	mov	es,dx
	mov	di,ax			;get pointer in es:di

SwitchDone:

; we must return with the handle and the application type of the one to 
; switch to. If the program flags say it is the shell, we must go back to 
; shell.

	test	es:[di].Program_Flags,F_SHELL
	jz	@f			;not shell.
	clc				;go back to shell
	jmp	short SwitchManagerRet	;return back to effect switch
@@:
	mov	ax,es:[di].Program_Id	;get program id

; if the program ID is 0 we are trying to restart an app that has never been
; started before. In this case we will return to shell with an error code.

	or	ax,ax			;valid ID ?
	jnz	@f			;yes.
	mov	al,ER_APP_NOT_STARTED_YET
	mov	ReturnToShellCode,al	;save as return code
	clc				;go back to shell
	jmp	short SwitchManagerRet	;return back to effect switch
@@:
	mov	bl,es:[di].Path_Id	;get swap path id	
	stc				;can resume app.
	jmp	short SwitchManagerRet	;return back to effect switch

DisplaySwitchTitle:

; get to the start of the title string and it's length.

	lea	si,[di].Program_Title	;get to the name of the program.
	mov	bx,si			;save it here
	xor	cx,cx			;initialize 

;get to the length of the string.

@@:
	mov	al,es:[si]		;load the next byte
	inc	si			;next byte
	inc	cx			;one more character
	or	al,al			;NULL recahed ?
	jnz	@b			;no.

; cx has the length of the string

	mov	ax,cx			;get the length of the title
	mov	cx,DataOFFSET SwitcherColors

; display the title of the window

	cCall	DisplayTitleBar,<es,bx,ax,cx,FreshTitle>
	mov	FreshTitle,0		;no more back ground drawing

; if this is not a TAB type of switch we are all done and the top node address
; is also in es:di

	test	SwitchType,WOA_SWITCH_TAB
	jz	CompleteTheSwitch	;done with the switch

; now wait till ALT is released, or tab is pressed

	cCall	StallOnSwitch		;wait for event
	jnc	CompleteTheSwitch	;switch finished

; update the switch type and start all over again.

	mov	SwitchType,ax		;reset new switch type
	jmp	DoTheSwitch		;process switch

CompleteTheSwitch:

	cCall	GetTopAppPtr		;get a long pointer to the top app
	mov	es,dx			
	mov	di,ax			;es:[di] -> top entry
	jmp	MoveTabTaskToTop	;process switch

SwitchManagerRet:

	push	ax
	pushf				;save the resturn value
	cCall	UnHookInt09		;unhook the vector
	popf
	pop	ax			;restore return values

SwitchManagerExit:

cEnd
;----------------------------------------------------------------------------;
; UpdateTaskList:							     ;
;									     ;
; Updates the task list based on  the type of the switch. Done by INT 2FH    ;
; calls to the shell stub. For ALT_TAB type of switch the list is not altered;
; at all. This routine returns the address of the next node in DX:AX	     ;
;----------------------------------------------------------------------------;

cProc UpdateTaskList,<NEAR,PUBLIC,PASCAL>,<si,di,cx>

	parmW	SwitchType		;type of the switch

cBegin

; move the next or previous guy to the top of the list.

	test	SwitchType,WOA_SWITCH_TAB
	jnz	UpdateTabType		;TAB type of switch.

	mov	si,CGO_NEXT		;absolute ordering
	test	SwitchType,WOA_SWITCH_NEXT;is it true ?
	jnz	@f

	mov	si,CGO_Z_PREV		;get last into first poition
@@:
	mov	ax,4a05h		;opcode
	int	2fh			;this will do it

; now get a pointer to this node.

	cCall	GetTopAppPtr		;DX:AX points to TOP APP
	jmp	short UpdateTaskListRet

UpdateTabType:

	mov	ax,TrackTabNode		;current pos of TAB task pointer
	mov	bx,1			;assume we TAB forward
	xor	cx,cx			;value after wrap around at NumApps
	test	SwitchType,WOA_SWITCH_NEXT;is it true ?
	jnz	@f

	mov	bx,-1			;we will have to go back
	mov	cx,NumApps			;value after wrap around at 0
@@:
	add	ax,bx			;new position of TAB task pointer
	cmp	ax,NumApps		;wrapped over ?
	jbe	@f			;no.
	mov	ax,cx			;get right value after wrap around
@@:
	mov	TrackTabNode,ax		;poition of new TAB pointer

; get a pointer to this node.

	mov	bx,ax			;get it in BX
	mov	ax,4a05h
	mov	si,CGET_ITH_ENTRY_DATA	;returns pointer in ES:SI
	int	2fh
	mov	dx,es
	mov	ax,si			;have it in DX:AX

UpdateTaskListRet:
	
cEnd
;----------------------------------------------------------------------------;
; GetTopAppPtr:								     ;
;									     ;
; Gets a pointer to the top app in the list and returns it in DX:AX.	     ;
;----------------------------------------------------------------------------;

cProc	GetTopAppPtr,<NEAR,PUBLIC,PASCAL>,<es,di,si>

cBegin

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;get it in es
	mov	di,ax			;es:di -> start of structure

; get a pointer to the first program in the list.

	lea	si,[di].Program_List	;start of array
	xor	ah,ah			;clear out high byte
	mov	al,es:[di].First_In_List;get index of first entry
	mov	bl,SIZE Switch_Entry	;size of each entry
	mul	bl			;ax has start offset
	add	ax,si			;get the offset
	mov	dx,es			;get the segment

cEnd
;----------------------------------------------------------------------------;
; DeleteApp:								     ;
;									     ;
; This takes a Program_ID as the paramete and deletes the app from the list. ;
;----------------------------------------------------------------------------;

cProc	DeleteApp,<NEAR,PUBLIC,PASCAL>,<es,di,si>

	parmW	Id			;ID of app to delete

cBegin

; get the logical node number (ignore DX:AX from following routine)

	cCall	GetSwitcherEntry,<Id>	;bx returns logical node number
	jc	DeleteAppRet		;could not get node

; delete the entry.

	mov	ax,4a05h		;opcode
	mov	si,CDELETE_PROGRAM_FROM_LIST
	int	2fh			;deletes it

DeleteAppRet:

cEnd
;----------------------------------------------------------------------------;
; GetSwitcherEntry:							     ;
;									     ;
; This routine takes an AppID as the parameter and gets to the app that has  ;
; that id. DX:AX returns a pointer to the entry.			     ;
;									     ;
; It returns the logical node number in BX.				     ;
;----------------------------------------------------------------------------;

cProc	GetSwitcherEntry,<NEAR,PUBLIC,PASCAL>,<es,si,di>

	parmW	GSEAppId		;id of app we are looking for

cBegin

; get a pointer to the global block.

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure

; scan through the list in search for the ID. We must walk in the list order.

	xor	ah,ah			;zero out for 'mul' below
	mov	al,es:[di].First_In_list;get the first entry
	mov	bl,SIZE Switch_Entry	;size of each entry
	mul	bl			;ax has the node offset
	lea	si,[di].Program_List	;es:si points to the first program entry
	add	si,ax			;point to the right node.
	mov	cx,MAX_NUM_PROGRAMS	;get the max number of entries
	xor	dx,dx			;logical node number

LoopAllEntries:

	mov	ax,es:[si].Program_Id	;get the ID
	cmp	ax,GSEAppId		;does it match ? 
	jz	GetSwitcherEntryRet	;yes, break out of loop

ContinueLoop:

	xor	ah,ah			;zero out
	mov	al,es:[si].Next_In_List	;get the next entry
	mul	bl			;ax has the offset from the start
	lea	si,[di].Program_List	;es:si points to the first program entry
	add	si,ax			;point to the right node.
	inc	dx			;one more fresh entry obtained
	loop	LoopAllEntries		;continue looking
	stc				;error

GetSwitcherEntryRet:

	mov	bx,dx			;logical node number
	mov	dx,es			;segment of node
	mov	ax,si			;offset of node

cEnd
;----------------------------------------------------------------------------;
; AppToTheTop:								     ;
;									     ;
; This routine moves an app task to the top of the list. To do this it       ;
; must first find out the logical node number of the app and make an INT 2Fh ;
; call to move the logical node to the top. App ID=0 signifies the shell.    ;
;									     ;
; This destroys all registers but for ES,DS and BP.			     ;
;----------------------------------------------------------------------------;

cProc	AppToTheTop,<NEAR,PUBLIC,PASCAL>,<es>

	parmW	ATTT_AppID		;id of the app to move to the top
	
	localW	ATTT_NodeNum		;node number of the app.

cBegin

; get a pointer to the glocal structure.

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure

; walk through the list in node order looking for the app.

	xor	ah,ah			;zero out for 'mul' below
	mov	al,es:[di].First_In_list;get the first entry
	mov	bl,SIZE Switch_Entry	;size of each entry
	mul	bl			;ax has the node offset
	lea	si,[di].Program_List	;es:si points to the first program entry
	add	si,ax			;point to the right node.
	mov	cx,MAX_NUM_PROGRAMS	;get the max number of entries
	mov	ATTT_NodeNum,0		;start with node 0.

ATTT_Loop:

; is this a free node ?

	test	es:[si].Program_Flags,F_FREE
	jnz	ATTT_NextNode		;it is free

; are we checking for the shell ?

	cmp	ATTT_AppID,0		;looking for shell ?
	jz	ATTT_LookForShell	;yes.

; is this the right ID ?

	mov	ax,es:[si].Program_Id	;get the ID of the node
	cmp	ax,ATTT_AppID		;match ?
	jz	ATTT_FoundApp		;we found it
	jmp	short ATTT_NextNode	;move on.

ATTT_LookForShell:

; Is this the shell node ?

	test	es:[si].Program_Flags,F_SHELL
	jnz	ATTT_FoundApp		;yes, we found it.

ATTT_NextNode:

; move on to the next node.

	xor	ah,ah			;zero out
	mov	al,es:[si].Next_In_List	;get the next entry
	mul	bl			;ax has the offset from the start
	lea	si,[di].Program_List	;es:si points to the first program entry
	add	si,ax			;point to the right node.
	inc	ATTT_NodeNum		;one more fresh entry obtained
	loop	ATTT_Loop		;continue looking

; we did not get a match. This should never happen. In any case we will not
; do any further in thie routine.

	jmp	short ATTT_Ret

ATTT_FoundApp:

	mov	bx,ATTT_NodeNum		;get the node number
	or	bx,bx			;is it already at the top ?
	jz	ATTT_Ret		;yes, nothing more to do.

; move the node to the top of the task list.

	mov	ax,4a05h		;opcode
	mov	si,CTOTOP_ITH_LIST_PE	;get it to the top
	int	2fh			;dx:ax has the long pointer to node

ATTT_Ret:

cEnd
;----------------------------------------------------------------------------;
; UpdateExitCode:							     ;
;								             ;
; This routine stuffs in the error code into the global structure. The main  ;
; error code and the subcode are passed in as paramets to this routine.	A    ;
; main code of 0 actually menas no error.				     ;
;----------------------------------------------------------------------------;

cProc	UpdateExitCode,<NEAR,PUBLIC,PASCAL>,<es,di>

	parmB	MainCode		;main error code
	parmB	SubCode			;auxilliary error code

cBegin

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure

; get the error code.

	mov	ah,MainCode	
	mov	al,SubCode
	mov	es:[di].Exit_Code,ax	;stuff it in.

cEnd
;----------------------------------------------------------------------------;
; DisplayTitleBar:							     ;
;									     ;
; This displays a title bar of an application. It takes as parameters, a long;
; pointer to a string to display, and a pointer in the data segment to four  ;
; textmode color attributes, for the desktop background color, title bar     ;
; color, text foreground and background colors and displays the switcher     ;
; screen. It also takes the length of the string.			     ;
;									     ;
; The background of the switcher screen would drawn if 'FreshTitle' is set   ;
; to 0ffh (it needs to be drawn only once).				     ;
;----------------------------------------------------------------------------;

cProc DisplayTitleBar,<NEAR,PUBLIC,PASCAL>,<si,di>

	parmD	lpText			;text for the title
	parmW	Count			;length of the string
	parmW   pColorBlock		;near pointer to color block
	parmB	FreshTitle		;background to be drwan or not

cBegin

	mov	si,pColorBlock		;load near pointer to color block

; Skip background painting if not FresTitle

	cmp	FreshTitle,0		;first time being done ?
	jz	@f			;no.	

; position on line  row 0, coloumn 0

	mov	ah,2			;set cursor position code
	mov	bh,0			;page 0
	xor	dx,dx			;HOME the cursor
	int	10h
	mov	ax,40h			;want to access BIOS data area
	mov	es,ax			;es has bios data segment
	mov	al,24			;24 (25-1) lines on screen.
	mov	bl,es:[4ah]		;get the number of coloumns
	inc	ax			;no of rows is one more
	mul	bl			;ax has the no of coumns
	mov	cx,ax			;move it into cx


; now blank out the screen with the background color

	mov	bh,0			;want to do page 0 only
	mov	bl,[si]			;get the background color attribute
	mov	ax,0920h		;display sapce code
	int	10h			;background displayed

@@:

; position on line  row 1, coloumn 2

	mov	ah,2			;set cursor position code
	mov	bh,0			;page 0
	mov	dx,102h			;row 1 coloumn 2
	int	10h

; we want to center the text in the title bar. Figure out how many chars
; should preceed title

	mov	ax,Count		;get length including NULL
	dec	ax			;just the length
	cmp	ax,76			;is it more than 76 chars ?
	jbe	@f			;no
	mov	ax,76			;can write only 80
@@:
	mov	Count,ax		;number we will write
	mov	cx,76			;length of a row
	sub	cx,ax			;# of spaces on both sides
	push	cx			;save it
	shr	cx,1			;halve it
	adc	cx,0			;if uneven, 1 more on left
	jcxz	@f			;no blank on the left

; display blanks on the left with active caption background color

	push	cx			;save count
	mov	ax,920h			;display space code
	mov	bh,0			;in page 0
	mov	bl,[si+1]		;title bar color
	int	10h			;left of text done
	pop	cx			;get back no of spaces displayed

; now position cursor for text string

	mov	bh,0			;page 0
	mov	dh,1			;row 1
	mov	dl,cl			;start of title
	add	dl,2			;2 blanks at left edge
	mov	ah,2			;set cursor position code
	int	10h			;positioned
@@:

; now display the character string.

	mov	bl,[si+2]		;get text foreground attribute
	or	bl,[si+1]		;or it with back ground of caption bar
	mov	bh,0			;want in page 0
	les	di,lpText		;load pointer to string
	mov	cx,Count		;get number to write
	jcxz	title_displayed		;could be null title

write_character_loop:

	push	cx			;save count
	mov	al,es:[di]		;get the next character
	inc	di			;point to next character
	mov	ah,09h			;display character code
	mov	cx,1			;want to write one character
	int	10h			;character written
	mov	ah,3			;get cursor position code
	int	10h			;dl has coloumn
	inc	dl			;position to next coloumn
	mov	ah,2			;set cursor code
	int	10h			;positioned for next
	pop	cx			;get back count
	loop	write_character_loop	;write out title bar

title_displayed:
		
	pop	cx			;get back number of spaces
	shr	cx,1			;number of spaces to display on left
	jcxz	@f			;none on the right

; display spaces on the right

	mov	ax,920h			;display space code
	mov	bh,0			;in page 0
	mov	bl,[si+1]  		;title bar color
	int	10h			;spaces displayed
@@:

; now make the cursor invisible. The CH=20h/AH=1 call may not work in some 
; cases, so we will set the cursor to the 26th line on the screen and there
; by make it invisible.


	mov	ah,02h			;set cursor position
	xor	bh,bh			;page 0
	mov	dx,1900h		;to the 26th line
	int	10h			;cursor made invisible

cEnd

;----------------------------------------------------------------------------;
; StallOnSwitch:							     ;
;									     ;
; This routine loops for some sort of keyboard action as long as ALT key is  ;
; done. The variable WoaHotKeys is updated by the int 09 ISR. It returns with;
; carry clear if the ALT break is sensed, else if the alt key is still down  ;
; it returns with carry set if WoaHotKeys has a valid switch move.           ;
;									     ;
; NOTE: We get the ALT key state by groping directly into the BIOS data area ;
; rather than doing INT 16H calls. This is because to service the INT 16     ;
; calls DOSX has to swith to realmode and later switch back to pmode. On some;
; 286s like WANG PC250/16 this does not work well, presumably because the    ;
; processor resets mess up the CMOS data.				     ;
;----------------------------------------------------------------------------;

cProc	StallOnSwitch,<NEAR,PUBLIC,PASCAL>,<si,di,es,bx,dx>

cBegin

	mov	ax,40h			;bios data area
	mov	es,ax			
	mov	bx,17h			;es:[bx] has the keyboard state flags
	mov	dx,_WOARLMSEG		;hot keys in stub segment
  	
StallOnSwitchLoop:

; get key board shift status and test if ALT is down or not

	test	bptr es:[bx],ST_ALT	;get the keyboard status
	jz	@f			;it is nomore down

; test to see if a valid switch move has been made or not

	push	es
	mov	es,dx			;load the stubsegment
	assumes	es,StubSeg
	test	WoaHotKeyState,WOA_SWITCH;valid switch move
	pop	es
	assumes	es,nothing
	jz	StallOnSwitchLoop	;no,linger here

; valid move has been made, return with the move

	push	es			;save
	mov	es,dx			;go to stub segment
	assumes	es,StubSeg
	xor	al,al			;must reset it before next call
	xchg	al,WoaHotKeyState	;get the move
	and	al,WOA_SWITCH		;just interested in switch moves
	xor	ah,ah			;AX has move value
	pop	es			;restore
	assumes	es,nothing
	stc				;set carry for new move
	jmp	short StallOnSwitchRet	;go back

@@:
	clc		  		;ALT key has been released

StallOnSwitchRet:


cEnd
;----------------------------------------------------------------------------;
; This routine hooks the int 09 vector and leaves some information in the    ;
; code segment which the ISR needs to handle.				     ;
;----------------------------------------------------------------------------;

cProc	HookInt09,<NEAR<PASCAL>,<di,si>

cBegin
    
	push	es			;save
	mov	ax,_WOARLMSEG		;StubSegment
	mov	es,ax			;load the code seg
	assumes	es,StubSeg

; the original INT 09 address is already in the 'HInt09ChainAddr' variable in the
; StubSeg

; hook the ISR.

	push	ds			;save them
	smov	ds,es			;hook is in StubSeg
	assumes	ds,StubSeg		
	mov	dx,StubSEGOFFSET Int09ISR;ds:dx points to the ISR
	mov	ax,2509h		;want to set vector 9
	int	21h
	mov	WoaHotKeyState,0	;reset hot key state
	pop	ds			;restore 
	assumes	ds,Data

	pop	es			;restore
	assumes	es,nothing
	

cEnd
;----------------------------------------------------------------------------;
; This routine unhooks the Int 09 ISR that we pu in. 			     ;
;----------------------------------------------------------------------------;

cProc	UnHookInt09,<NEAR<PASCAL>

cBegin

	pushem	es,ds			;save
	mov	ax,_WOARLMSEG		;get StubSeg value
	mov	es,ax			;load it in es
	assumes	es,StubSeg
	assumes	ds,nothing

; get and set the orginal vector 

	mov	ds,wptr es:[HInt09ChainAddr+2]
	mov	dx,wptr es:[HInt09ChainAddr];DS:DX has the original vector
	mov	ax,2509h		;want to set vector for int 09
	int	21h
	popem   es,ds			;restore them	
	assumes	es,nothing
	assumes	ds,Data

cEnd
;----------------------------------------------------------------------------;
sEnd Code

end






=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaswch.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


MAX_NUM_PROGRAMS equ 16
MAX_PROGRAM_LENGTH equ 80
MAX_TITLE  equ 30

; DONOT CHANGE THE SIGNIFICANCE OF THE BIT FLAGS WITHOUT MAKING CORRESPONDING
; CHANGES IN THE SWITCHER INCLUDE FILE WOAPIF.INC

F_NO_SWITCH	   equ 0000000000000001b ;program can not be switched away from
F_GRAPHICS	   equ 0000000000000010b ;graphics mode
F_NO_PAUSE         equ 0000000000000100b ;Pause after exit
F_DTS_API_INITED   equ 0000000000001000b ;1=>DTS init has been posted by shell
F_SWAP_NOT_OK	   equ 0000000000010000b ;1=>external tasker incompatble; set by shell
F_UNUSED_3	   equ 0000000000010000b ;
F_UNUSED_4	   equ 0000000000100000b ;
F_SHELL		   equ 0000000001000000b ;program is the shell

F_NO_ALT_TAB	   equ 0000000100000000b ;ALT+TAB to be ignored
F_NO_ALT_ESC	   equ 0000001000000000b ;ALT+ESC to be ignored
F_NO_CTRL_ESC	   equ 0000010000000000b ;CTRL+ESC to be ignored
F_UNUSED_5	   equ 0000100000000000b ;
F_UNUSED_6	   equ 0001000000000000b ;
F_UNUSED_7	   equ 0010000000000000b ;
F_UNUSED_8	   equ 0100000000000000b ;
F_FREE		   equ 1000000000000000b ;free program slot

; equates for global flags

GF_INT_6F_TOBE_DONE	equ	00000001b ;INT 6f to be done
GF_IRQ9_GLOBAL		equ	00000010b ;IRQ 9 to be globally handled
GF_NET_ASYNC_SWITCH_OK	equ	00000100b ;OK to switch out on async net request
GF_UNUSED_1		equ	00001000b ;
GF_UNUSED_2		equ	00010000b ;
GF_UNUSED_3		equ	00100000b ;
GF_UNUSED_4		equ	01000000b ;
GF_UNUSED_5		equ	10000000b ;

Switch_Entry   STRUC
       Program_Name    db MAX_PROGRAM_LENGTH  DUP(?); Program name
       Program_Title   db MAX_TITLE DUP (?)	 ; switcher screen title
       Conv_Req	       dw ?			 ; min conv mem required
       XMS_Req	       dw ?			 ; XMS required
       XMS_Want	       dw ?			 ; XMS desired
       HK_Scan_Code_1  db ?			 ; 1st directed hot key scan code
       HK_Scan_Code_2  db ?			 ; 2nd directed hot key scan code
       HK_Shift_State  db ?			 ; ALT/CTRL/SHIFT states
       Program_Flags   dw ?			 ; Special flags for program
       Next_In_List    db ?			 ; Next program in Z order list
       Program_Id      dw ? 			 ; internal program ID
       Path_Id	       db ?			 ; internal id of swap path
       Shell_Cookie    dw ?			 ; magic cookie for shell		
Switch_Entry   ENDS

Switch_Info    STRUC
       Switcher_Id     db   ?
       CPU_Type	       dw   ?			 ; CPU type flag bits
       SFT_Size	       dw   ?			 ; SFT SIZE
       Parameters      db   130 dup (?) 	 ; parameters to the program
       Grabber_Name    db   80 dup (?) 		 ; grabber path and name
       Swap_Path1      db   68 dup (?) 		 ; first swap drive and path 
       Swap_Path2      db   68 dup (?)		 ; second swap drive & path
       Min_Path1       dw   ?			 ; min k space to be left on drv1
       Min_Path2       dw   ?			 ; min k space to be left on drv2
       XMS_Handle      dw   ?			 ; Handle of locked XMS block
       XMS_Size	       dd   ?			 ; size of block in bytes
       Int_15_Users_Id dw   ?			 ; ID of app using INT 15 memory
       Id_Serial       dw   ?			 ; running app serial number
       Exit_Code       dw   ?			 ; switcher exit code
       Num_Lines       db   ?                    ; start up screen lines
       Global_Flags    db   ?			 ; various global descisions
       Screen_Back     db   ?			 ; back ground screen color
       Title_Fore      db   ?			 ; Title text color
       Title_Back      db   ?			 ; Title back ground color
       Num_Programs    db   ?			 ; number of programs in the list
       First_In_List   db   ?			 ; first program in Z order list
       Program_List    db SIZE Switch_Entry *MAX_NUM_PROGRAMS DUP(?)
Switch_Info    ENDS

CINIT_PROGRAM_LIST	  equ 0
CADD_PROGRAM_TO_LIST	  equ 1
CGO_Z_NEXT		  equ 2
CGO_Z_PREV		  equ 3
CDELETE_PROGRAM_FROM_LIST equ 4
CGO_NEXT		  equ 5
CGET_ITH_PROGRAM_STRING   equ 6
CGET_LIST_LENGTH	  equ 7
CGET_GLOBAL_SWITCH_DATA   equ 8
CGET_ITH_ENTRY_DATA	  equ 9
MAX_HANDLER_CALL	  equ 9
CADD_PARAMS		  equ 10
CGET_EXITCODE		  equ 11
CTOTOP_ITH_LIST_PE 	  equ 12


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaswapi.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */

  
;----------------------------------------------------------------------------;
; This file has the equates for the switch api calls.			     ;
;									     ;
; History:								     ;
;									     ;
;        Thu Aug-23-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Switcher. (Added the History legend)    		     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; define constants for the switch API.					     ;
;----------------------------------------------------------------------------;

SWAPI_BUILD_CHAIN 	equ	4B01h	;INT 2F code for the Switch API
SWAPI_DETECT_SWITCHER	equ	4B02h	;call to detect presence of switcher
SWAPI_ALLOCATE_SW_ID	equ	4B03h	;allocates switcher ID (done by shell)
SWAPI_FREE_SW_ID	equ	4B04h	;frees switcher ID (done by shell)
SWAPI_GET_INST_DATA	equ	4B05h	;gets instance data


		;-----------------------------------------;
		; call out equates.			  ;
		;-----------------------------------------;

SWAPI_INIT_SWITCHER	equ	0	;switcher starts
SWAPI_QUERY_SUSPEND	equ	1	;Query_Suspend
SWAPI_SUSPEND		equ	2	;Suspend session
SWAPI_RESUME		equ	3	;Resume session
SWAPI_SESSION_ACTIVE	equ	4	;resume session now active
SWAPI_CREATE		equ	5	;Create session
SWAPI_Destroy		equ	6	;Destroy session
SWAPI_SWITCHER_EXIT	equ	7	;switcher exits

		;-----------------------------------------;
		; call in equates.			  ;
		;-----------------------------------------;

SWAPI_GETVERSION	equ	0	;GetVersion call in
SWAPI_TESTMEMORYREGION	equ	1	;TestMemoryRegion
SWAPI_SUSPEND_SWITCHER	equ	2	;SuspendSwitcher
SWAPI_RESUME_SWITCHER	equ	3	;ResumeSwitcher
SWAPI_HOOK_CALLOUT	equ	4	;Hook CallOut
SWAPI_UNHOOK_CALLOUT	equ	5	;UnHook CallOut
SWAPI_QUERY_API_SUPPORT	equ	6	;get network API support details


		;----------------------------------------;
		; Switch API call back info structure.   ;
		;----------------------------------------;

Switch_Call_Back_Info STRUC

SCBI_Next	dd	?		;pointer to next structure in list
SCBI_Entry_Pt	dd	?		;CS:IP of entry point procedure
SCBI_Reserved	dd	?		;used by the switcher
SCBI_API_Ptr	dd	?		;pinter to list of API structures

Switch_Call_Back_Info ENDS

		;----------------------------------------;
		; structure for API support details.     ;
		;----------------------------------------;

API_Info_Struc STRUC

AIS_Length	  dw	?		;length of the structure
AIS_API		  dw	?		;the API ID value
AIS_Major_Ver	  dw	?		;major version of API spec
AIS_Minor_Ver	  dw	?		;minor version of the API spec
AIS_Support_Level dw	?		;support level

API_Info_Struc ENDS

		;----------------------------------------;
		; currently defined API ID values.       ;
		;----------------------------------------;

API_NETBIOS	  equ	1		;Netbios
API_8022	  equ	2         	;802.2
API_TCPIP	  equ	3		;TCP/IP
API_LANMAN	  equ	4		;LAN Manager named pipes
API_IPX		  equ	5		;NetWare IPX

		 ;---------------------------------------;
		 ; currently defined support levels      ;
		 ;---------------------------------------;

API_SL_STOPALL	  equ	1		;stop all calls
API_SL_MINIMAL    equ	2		;stop asynchronous calls
API_SL_API	  equ	3		;API level support
API_SL_SW_COMPT	  equ	4		;switcher compatible
API_SL_SEAMLESS	  equ	5		;seamless support

		 ;---------------------------------------;
		 ; structure for return from get version ;
		 ;---------------------------------------;

Switcher_Ver_Struc STRUC

SVS_API_Major	  dw	?		;major version of the specs
SVS_API_Minor	  dw 	?		;minor version of the specs
SVS_Product_Major dw	?		;major version of the task switcher
SVS_Product_Minor dw	?		;minor version of the product
SVS_Switcher_ID	  dw	?		;ID of the switcher
SVS_Flags	  dw	?		;enabled/disabled
SVS_Name_Ptr	  dd	?		;long pointer to ID string
SVS_Prev_Switcher dd	?		;pointer to next switcher

Switcher_Ver_Struc ENDS

		;----------------------------------------;
	        ; constants used by the Switcher         ;
		;----------------------------------------;

OUR_API_MAJOR	  equ	1		;major ver of the specs
OUR_API_MINOR	  equ	0		;minor ver of the specs
OUR_PRODUCT_MAJOR equ   5		;major ver of the switcher
OUR_PRODUCT_MINOR equ   1		;minor ver of the switcher

OUR_NB_MAJOR_VER  equ	2		;major version of NetBios 
OUR_NB_MINOR_VER  equ   0		;minor version of NetBios
	
;----------------------------------------------------------------------------;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woaxms.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file contains all the modules necessary for managing the old app XMS  ;
; requiements.	This code is an optional part of the real mode stub segment, ;
; and will be discarded if not needed.					     ;
;									     ;
; History:								     ;
;									     ;
;	 10-Oct-90 AC		PrevXmm handler allocates all handle numbers ;
;      	 20-Sep-90 AC		Functions that don't succeed are chained on. ;
;	 20-Sep-90 AC		Hooks XMS properly.			     ;
;	 7-Mar-90  jimmat	Now part of real mode stub instead of being  ;
;				a seperate segment.			     ;
;        Mon June-26-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created. (Added the History legend)				     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include	njmp.mac
	include macros.mac
	.list

	.286p

;----------------------------------------------------------------------------;
; define two macros for doing near and far returns.			     ;
;----------------------------------------------------------------------------;

near_ret  macro
	local	dummy
dummy	proc	near
	ret	
dummy	endp
	endm

far_ret	macro
	local	dummy
dummy	proc	far
	ret
dummy	endp
	endm
;----------------------------------------------------------------------------;
createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

	assumes cs,StubSeg

; XmsStartLine MUST be at the very start of the XMS code/data.	This defines
; the address which will be used to discard the XMS code/data if the
; current DOS app does not require XMS support.

	public	XmsStartLine

XmsStartLine	equ	$	;MAKE ME FIRST!  Everything after this will
				;  be discarded if XMS isn't needed.

;----------------------------------------------------------------------------;
; define the external function calls.		          		     ;
;----------------------------------------------------------------------------;

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;

;----------------------------------------------------------------------------;
; declare the variables which are defined elsewhere.			     ;
;----------------------------------------------------------------------------;

externD	ActualXMS			;XMS entry point.
externB	WoafXmsInstalled		;XMS installed or not

;----------------------------------------------------------------------------;
; define the variables that are passed into it at load time.		     ;
;----------------------------------------------------------------------------;

GlobalW	XmsBaseHandle,?			;handle of extended memory block
GlobalD AppXmsBase,?			;base of the apps XMS area
GlobalD AppXmsSize,?			;size of the apps XMS area
GlobalB	WoaAppUsesXMS,0			;whether app allocates XMS or not

;----------------------------------------------------------------------------;
; define variables that are needed for hooking the XMS chain and chaining on ;
;----------------------------------------------------------------------------;

XmmControlBase		dd     -1	;node that is being patched up
XmmControlJmpVal	db	?	;offset of near jump
PrevXmm			dd	?	;for chaining down

;----------------------------------------------------------------------------;
; declare public labels.						     ;
;----------------------------------------------------------------------------;

	public	GetLargestFreeBlock			
	public	AllocateXmsBlock
	public	FreeXmsBlock
	public	MoveXmsBlock
	public	LockXmsBlock
	public	UnlockXmsBlock
	public	GetXmsHandleInfo
	public	RellocateXmsBlock
	public	XmsDispatcher
	public  AllocationTable

;----------------------------------------------------------------------------;
; now define the data structures to be used for manipulating the XMS areas.  ;
;----------------------------------------------------------------------------;

; the main table for managing the handle entries has the following format:


 ;----------|------------------------|------------|---------------------;
 ; Handle   |   32 bit base address  | lock count | size of block in K  ;
 ; (byte)   |       (dword)          |  (byte)    |       (word)        ;
 ;----------|------------------------|------------|---------------------;

; declare a structure for the above table

XmsTableEntry	STRUC

THandle		dw	?		;handle in the table
TBaseLo		dw	?		;loword of base
TBaseHi		dw	?		;high word of base
TLckCount	db	?		;lock count
TSize		dw	?		;size of block

XmsTableEntry	ENDS

; if the handle field is zero, the block is a free block. The Allocation 
; table can have a maximum of 32 + 32 entries and will always be kept sorted
; on the linear address.Allocate one extra entry for the end of table tag,
; which will have a 0ffh in the handle field

AllocationTable	db	(65 * (SIZE XmsTableEntry)) dup (0) ;reserve max size for table

;----------------------------------------------------------------------------;
; define other variables that are needed.				     ;
;----------------------------------------------------------------------------;

ActualInt2f		dd	0  	;original int 2f vector
ExtraMoveOffsetLo	dw	?	;low word of extra offset
ExtraMoveOffsetHi	dw	?	;high word of extra offset
MoveStructure		db 16 dup (?)   ;the move parameter block

MoveTemplate STRUC

Mlength		dd	?		;length of transfer
MSrcHandle	dw	?		;source handle
MSrcOffsetLo	dw	?		;low source offset
MSrcOffsetHi	dw	?		;high source offset
MDstHandle	dw	?		;destination handle
MDstOffsetLo	dw	?		;lo dst offset
MDstOffsetHi	dw	?		;hi dst offset

MoveTemplate ENDS



;----------------------------------------------------------------------------;
; define the dispatch table for the XMS calls that we trap.		     ;
;----------------------------------------------------------------------------;

XmsTraps	label byte

		db	01h		;request high memory area
		dw	XmsFunc01	;routine which handles it
		db	02h		;release high memory area
		dw	XmsFunc02	;routine which handles it
		db	08h		;query free extended memory
		dw	XmsFunc08	;routine which handles it
		db	09h		;allocate extended memory block
		dw	XmsFunc09	;routine which handles it
		db	0ah		;free extended memory block
		dw	XmsFunc0a	;routine which handles it
		db	0bh		;move extended meory block
		dw	XmsFunc0b	;routine which handles it
		db	0ch		;lock extended memory block
		dw	XmsFunc0c	;routine which handles it
		db	0dh		;unlock extended memory block
		dw	XmsFunc0d	;routine which handles it
	     	db	0eh		;get EMB handle information
		dw	XmsFunc0e	;routine which handles it
		db	0fh		;rellocate extended memory block
		dw	XmsFunc0f	;routine which handles it
		db	10h		;request upper memory block
		dw	XmsFunc10	;routine which handles it
		db	11h		;release upper memory block
		dw	XmsFunc11	;routine which handles it
XmsDefaultCode	db	?		;put AH here on entry to trap default
		dw	XmsDefaultFunc	;pass on to original handler

;----------------------------------------------------------------------------;
; XmsInit:								     ;
;									     ;
; This routine is called from the real mode stub, and it initializes the     ;
; allocation table to account for one big free block and hooks in the our    ;
; XMS handler. 
;----------------------------------------------------------------------------;


cProc	XmsInit,<NEAR,PUBLIC,PASCAL>

cBegin	

	smov	ds,cs			;make ds to point to XMS segment
	assumes ds,StubSeg


; the address of current XMS handler is already in 'ActualXms'
; first get the offset from the start of the actual XMS block to the start of
; the apps XMS block

	mov	dx,XmsBaseHandle	;the handle of the actual block
	mov	ah,0ch			;lock handle call
	call	[ActualXms]		;get base in  DX:BX
	pushem	di,cx			;save
	mov	cx,wptr [AppXmsBase]	;get loword of apps base
	mov	di,wptr [AppXmsBase+2]	;get the high word
	sub	cx,bx			;subtract the low word
	sbb	di,dx			;then the high word
	mov	ExtraMoveOffsetLo,cx	;save loword of exttra offset
	mov	ExtraMoveOffsetHi,di	;save hiword of move offset
	popem	di,cx			;restore
	mov	dx,XmsBaseHandle	;get the base handle
	mov	ah,0dh			;unlock call
	call	[ActualXms]		;unlock the block

; we access the table without the structure tags, make sure what we do is
; ok

	.errnz	THandle    - 0
	.errnz	TBaseLo    - 2
	.errnz	TBaseHi    - 4
	.errnz	TLckCount  - 6
	.errnz	TSize	   - 7

; initialize the allocation table to have one big free block.

	push	es			;save
	smov	es,ds			;have own segment
	mov	di,StubSegOFFSET AllocationTable
	xor	ax,ax			;first entry is free.
	stosw				;mark as free
	mov	ax,wptr [AppXmsBase]	;get low word of base
	stosw				;save it
	mov	ax,wptr [AppXmsBase+2]	;get hiword of base
	stosw				;save it
	xor	al,al			;set lock count to 0
	stosb				;save lock count
	mov	dx,wptr [AppXmsSize+2]	;get high word of size
	mov	ax,wptr [AppXmsSize]	;get low word of size
	mov	bx,1024			;need to get size in K
	div	bx			;ax has the quotient
	stosw				;save the size
	mov	ax,0ffffh 		;mark for end of table tag
	stosw	 			;store it in next entries handle field
	pop	es			;restore

; now hook ourselves to the XMS chain.

	call	HookOurXmsCode		;hooks the vectors

; initialization done

XmsInitRet:

cEnd
;----------------------------------------------------------------------------;
; XmsHandler:							             ;
; 									     ;
; This is our own XMS handler dispatcher. It filters out the functions we    ;
; want to trap and passes the rest of them to the actual XMS handler.	     ;
;----------------------------------------------------------------------------;

XmsHandler  proc far

	jmp	short XmsDispatcher	;jump to actual code
	nop				;dummy nops for hookability
	nop				;in case some one hools after us
	nop				;could be bad for them

XmsDispatcher:

	pushf
	push	bp			;save before trashing
	push	ds			;save ds
	smov	ds,cs			;have own segment
	mov	cs:[XmsDefaultCode],ah	;jam current code in
	mov	bp,StubSegOFFSET XmsTraps
	sub	bp,3			;each entry of 3 bytes

; search for the address of the function which handles the call

@@:

	add	bp,3			;look at next entry
	cmp	ah,cs:[bp]		;matches code ?
	jnz	@b			;continue searching

;  jump off to the function, BP is pushed on stack

	
	push	wptr cs:[bp+1]		;save jump address
	mov	bp,sp			;will access stack with it
	add	bp,4			;ss:[bp] has original bp
	near_ret			;jump to the handler

XmsHandler	endp

	;----------------------------------------------------------;
	; XMS function handler top level routines are defined next ;
	;----------------------------------------------------------;


	;----------------------------------------------------------;
	; This one handles all calls that are not trapped by WOA   ;
	;----------------------------------------------------------;

XmsDefaultFunc:

	pop	ds			;restore ds
	pop	bp			;restore bp
	popf
	jmp	cs:[PrevXmm]		;invoke actual handler

	;----------------------------------------------------------;
	; This one is used to return back to caller		   ;
	;----------------------------------------------------------;

XmsRet:

	pop	ds			;restore ds
	pop	bp			;retore bp
	popf
   	far_ret				;go back to caller

	;----------------------------------------------------------;
	; Request High Memory area:			           ;
	;							   ;
	; we return saying HMA is already in use.		   ;
	;----------------------------------------------------------;

XmsFunc01:

	xor	ax,ax			;cannot allocate HMA
	mov	bl,91h			;HMA already in use
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Release High Memory area:			           ;
	;							   ;
	; we return saying HMA was not allocated		   ;
	;----------------------------------------------------------;

XmsFunc02:

	xor	ax,ax			;unsuccessful realease
	mov	bl,93h			;as it was not allocated
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Query Free Extended Block:				   ;
	;							   ;
	; we return size of largest block in Kbytes		   ;
	;----------------------------------------------------------;

XmsFunc08:

	pushem	ax,bx,dx		;save entry parameters
	call	GetLargestFreeBlock	;gets largest free block

; if there is no memory available in our area we should chain on.

	or	dx,dx			;is there ant memory ?
	jnz	Trap08Worked		;yes.

; chain on.

	popem	ax,bx,dx		;restore
	jmp	XmsDefaultFunc		;chain on.

Trap08Worked:

	add	sp,6			;discard saved values.
	jmp	XmsRet

	;----------------------------------------------------------;
	; Allocate Extended Memory Block			   ;
	;							   ;
	; tries to do a local allocation.			   ;
	;----------------------------------------------------------;

XmsFunc09:

	or	dx,dx			;zero length allocations ?
	jz	ChainXmsFunc09		;yes, let prev handler handle it
	pushem	ax,bx,dx		;save entry parameters
	call	AllocateXmsBlock	;do the allocation

; if we fail to allocate memory, we should chain it on.

	or	ax,ax			;did we succeed ?
	jnz	Trap09Worked		;yes.

; chain on.

	popem	ax,bx,dx		;restore entry parameters

ChainXmsFunc09:

	jmp	XmsDefaultFunc		;chain on.

Trap09Worked:

	add	sp,6			;discard saved values
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Free Extended Memory Block				   ;
	;							   ;
	; frees up an allocation				   ;
	;----------------------------------------------------------;


XmsFunc0a:

	pushem	ax,bx			;save
	call	FreeXmsBlock		;free up an allocation
	or	ax,ax			;did it succeed ?
	jnz	Trap0AWorked		;yes.

; if the call failed bacause of an invalid handle, we should chain it on.

	cmp	bl,0a2h			;bad handle ?
	jnz	Trap0AWorked		;no.

; chain the call on as we do not know about the handle.
	
	popem	ax,bx			;restore entry parameters
	jmp	XmsDefaultFunc		;chain on.

Trap0AWorked:

	add	sp,4			;discard saved entry values
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Move Extended Memory Block				   ;
	;							   ;
	; we return saying HMS is already in use.		   ;
	;----------------------------------------------------------;

XmsFunc0b:

	pop	ds			;get back ds
	call	MoveXmsBlock		;move the block
	pop	bp			;restore
	popf
	far_ret

	;----------------------------------------------------------;
	; LockExtendedMemoryBlock:                                 ;
	;							   ;
	; we return the linear address  of the block		   ;
	;----------------------------------------------------------;

XmsFunc0c:

	pushem	ax,bx			;save entry values.
	call	LockXmsBlock		;get the address of the block
	or	ax,ax			;did it succeed ?
	jnz	Trap0CWorked		;yes.

; if the call failed bacause of an invalid handle, we should chain it on.

	cmp	bl,0a2h			;bad handle ?
	jnz	Trap0CWorked		;no.

; chain the call on as we do not know about the handle.
	
	popem	ax,bx			;restore entry parameters
	jmp	XmsDefaultFunc		;chain on.

Trap0CWorked:

	add	sp,4			;discard saved entry values
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Unlock Extended Memory Block:				   ;
	;							   ;
	; If the handle is valid, return success		   ;
	;----------------------------------------------------------;

XmsFunc0d:

	pushem	ax,bx			;save
	call	UnlockXmsBlock		;unlock the block
	or	ax,ax			;did it succeed ?
	jnz	Trap0DWorked		;yes.

; if the call failed bacause of an invalid handle, we should chain it on.

	cmp	bl,0a2h			;bad handle ?
	jnz	Trap0DWorked		;no.

; chain the call on as we do not know about the handle.
	
	popem	ax,bx			;restore entry parameters
	jmp	XmsDefaultFunc		;chain on.

Trap0DWorked:

	add	sp,4			;discard saved entry values
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Get EMB handle information				   ;
	;							   ;
	; get information about the handle			   ;
	;----------------------------------------------------------;

XmsFunc0e:

	push	ax			;save
	call	GetXmsHandleInfo	;get information about handle
	or	ax,ax			;did it succeed ?
	jnz	Trap0EWorked		;yes.

; chain the call on as we do not know about the handle.
	
	pop	ax			;restore entry parameter
	jmp	XmsDefaultFunc		;chain on.

Trap0EWorked:

	add	sp,2			;discard saved entry values
	jmp	XmsRet			;go back to caller

	;----------------------------------------------------------;
	; Rellocate Extended Memory Block			   ;
	;							   ;
	; try to grow or shrink block without moving it		   ;
	;----------------------------------------------------------;

XmsFunc0f:

	pushem	ax,bx			;save entry values
	call	RellocateXmsBlock	;try to do the rellocation
	or	ax,ax			;did it succeed ?
	jnz	Trap0FWorked		;yes.

; if the call failed bacause of an invalid handle, we should chain it on.

	cmp	bl,0a2h			;bad handle ?
	jnz	Trap0FWorked		;no.

; chain the call on as we do not know about the handle.
	
	popem	ax,bx			;restore entry parameters
	jmp	XmsDefaultFunc		;chain on.

Trap0FWorked:

	add	sp,4			;discard saved entry values
	jmp	XmsRet			;get back to caller

	;----------------------------------------------------------;
	; Request Upper Memory Block			           ;
	;							   ;
	; we return saying no UMBs area aveilable		   ;
	;----------------------------------------------------------;

XmsFunc10:

	xor	ax,ax			;fail the call
	mov	bl,0b1h			;no UMBs area available
	jmp	XmsRet


	;----------------------------------------------------------;
	; Release Upper Memory Block			           ;
	;							   ;
	; we return saying segment no is invalid		   ;
	;----------------------------------------------------------;

XmsFunc11:

	xor	ax,ax			;fail the call
	mov	bl,0b1h			;segmet number invalid
	jmp	XmsRet

;----------------------------------------------------------------------------;
; GetLargestFreeBlock:							     ;
;									     ;
; Traverses the allocation table, looking for the largest free block and also;
; accumulation total amount of free space.				     ;
;----------------------------------------------------------------------------;

GetLargestFreeBlock  proc near

	assumes ds,StubSeg

	push	si			;save it
	xor	ax,ax			;initialize largest block count
	xor	dx,dx			;initialize total free count
	mov	si,StubSegOFFSET AllocationTable
	sub	si,SIZE XmsTableEntry	;bias it back for addition below

LookForFreeBlocks:

	add	si,SIZE XmsTableEntry	;look at the next entry
	cmp	[si].THandle,0ffffh	;is this the end of the table
	jz	GetLargestFreeBlockRet	;yes, return back
	cmp	[si].THandle,0		;is it a free block
	jnz	LookForFreeBlocks	;keep looking
	add	dx,[si].TSize		;accumulate net free block
	cmp	ax,[si].TSize		;is this block bigger
	jae	LookForFreeBlocks	;no
	mov	ax,[si].TSize		;largest block obtained till now
	jmp	LookForFreeBlocks	;keep looking

GetLargestFreeBlockRet:

	pop	si			;restore
	ret

GetLargestFreeBlock  endp
;----------------------------------------------------------------------------;
; AllocateXmsBlock:							     ;
;									     ;
; Allocates the first fit XMS block.  It also incs the 'WoaAppUsesXms' field ;
; if the allocation succeedes.						     ;
;----------------------------------------------------------------------------;

AllocateXmsBlock proc near

	pushem	si,di,cx		;save work registers
	call	GetFreeHandle		;get a free handle
	or	bx,bx			;free handle obtained ?
	jz	AllocXmsNoHandle	;no more free handles

; look for the first block that matches size.

	mov	si,StubSegOFFSET AllocationTable
	sub	si,SIZE XmsTableEntry	;bias it for subtraction below

AllocXms1:

	add	si,SIZE XmsTableEntry	;look at the next entry
	cmp	[si].THandle,0ffffh	;have we reached the end ?
	jz	AllocXmsNoFree		;yes, there are no appropriate blocks
	cmp	[si].THandle,0		;is it free ?
	jnz	AllocXms1		;no, keep looking
	cmp	[si].TSize,dx		;appropriate for allocation ?
	jb	AllocXms1		;no.
	call	AllocateBlock		;allocates entry
	mov	dx,bx			;get the handle in DX
	mov	ax,1			;block allocated
	xor	bl,bl			;no errors
	inc	WoaAppUsesXMS		;one more allocation done.
	jmp	short AllocXmsRet	;return back

AllocXmsNoFree:

	call	ReleaseHandle		;mark handle in bx as free
	xor	ax,ax			;could not allocate
	mov	bl,0a0h			;no appropriate frr blocks
	jmp	short AllocXmsRet  	;go back

AllocXmsNoHandle:

	xor	ax,ax			;could not allocate
	mov	bl,0a1h			;as alll handles are in use
	
AllocXmsRet:

	popem	si,di,cx		;restore
	ret				;get back

AllocateXmsBlock endp
;----------------------------------------------------------------------------;
; GetFreeHandle:	  						     ;
;									     ;
; This function calls the previous XMS handler to allocate a zero length     ;
; XMS handle and returns that in BX. If a handle cannot be allocated, we     ;
; return with 0 in BX. If some handler uses 0 as a valid handle which is     ;
; still available for use, we will thereby ignore it.			     ;
;----------------------------------------------------------------------------;

GetFreeHandle	proc near

	assumes ds,StubSeg

	pushem	ax,dx			;save
	mov	ah,09h			;allocate block
	xor	dx,dx			;need a zero length block
	call	[PrevXmm]		;call the previous handler
	mov	bx,dx			;get the handle in BX
	or	ax,ax			;was it successful ?
	jnz	GetFreeHandleRet	;yes.
	xor	bx,bx			;no handle

GetFreeHandleRet:

	popem	ax,dx			;restore
	ret				;go back

GetFreeHandle  endp
;----------------------------------------------------------------------------;
; ReleaseHandle:							     ;
;									     ;
; On entry BX has a handle number and it is freed by calling the previous    ;
; XMS handler.								     ;
;----------------------------------------------------------------------------;

ReleaseHandle	proc near

	assumes ds,StubSeg

	pushem	ax,dx			;save
	mov	ah,0ah			;free xms block
	mov	dx,bx			;get the handle
	call	[PrevXmm]		;free the handle
	popem	ax,dx			;restore
	ret

ReleaseHandle	endp
;----------------------------------------------------------------------------;
; AllocateBlock:							     ;
;									     ;
; On entry si points to a free entry in the allocation table and dx has the  ;
; size of the allocation that we need. This routine does the allocation, if  ;
; the free size is exactly equal to the requested size, the same entry can   ;
; be updated, else the entries below the slot have to be pushed down to make ;
; room for a free entry. Also BX has the handle to allocate.		     ;
;----------------------------------------------------------------------------;

AllocateBlock	proc  near

	assumes ds,StubSeg

	cmp	[si].TSize,dx		;exact fit ?
	jnz	NotExactFit		;no

; we have an exact fit situation, update the entry to mark it with the handle
; and we are done

	mov	[si].THandle,bx		;mark as allocated
	jmp	short AllocateBlockRet	;go back

NotExactFit:

	call	MoveEntriesDown		;make room for a free entry 
	mov	[si].THandle,bx		;mark this one as allocated
	push	di			;save
	mov	di,[si].TBaseHi		;high word of base
	mov	cx,[si].TBaseLo		;get loword of base
	call	UpdateBase		;add DX*1024 to DI:CI
	mov	ax,[si].TSize		;get current size
	mov	[si].TSize,dx		;allocated size
	sub	ax,dx			;size of free block at end
	add	si,SIZE XmsTableEntry	;point to next entry
	mov	wptr [si].THandle,0	;mark as free
	mov	wptr [si].TBaseHi,di	;set hiword of base
	mov	wptr [si].TBaseLo,cx	;lo word of base
	pop	di			;restore
	mov	bptr [si].TLckCount,0	;not locked
	mov	[si].TSize,ax		;size of free area

AllocateBlockRet:

	ret				;end of allocation

AllocateBlock  endp
;----------------------------------------------------------------------------;
; UpdateBase:								     ;
;									     ;
; This adds DX*1024 to DI:CX without destroying other register.		     ;
;----------------------------------------------------------------------------;

UpdateBase  proc  near

	pushem	ax,bx,dx		;save
	mov	ax,dx			;get multiplicand in ax
	xor	dx,dx			;will hold result
	mov	bx,1024			;multiplier
	mul	bx			;dx:ax has result
	add	cx,ax			;add in low wors
	adc	di,dx			;add in hi words with carry
	popem	ax,bx,dx		;restored thrashed registers
	ret

UpdateBase  endp
;----------------------------------------------------------------------------;
; MoveEntriesDown:							     ;
;									     ;
; On entry SI points to an entry in the allocation table. This routine moves ;
; all the allocated entries below the one pointed by si, by one slot.	     ;
;----------------------------------------------------------------------------;

MoveEntriesDown	 proc  near

	assumes ds,StubSeg

	pushem	es,si,di,cx		;save registers

	smov	es,ds			;same segment

; first find out no of entries to move

	mov	di,si			;get the current entry
	mov	cx,1			;initialize count

MoveEntriesDown1:

	add	di,SIZE XmsTableEntry	;point to next entry
	cmp	wptr [di].THandle,0ffffh;is the end ?
	jz	MoveEntriesDown2	;no of entries to move is in cx
	inc	cx			;one more to move
	jmp	short MoveEntriesDown1	;keep counting

MoveEntriesDown2:

	mov	si,di			;last entry in the table
	add	di,SIZE XmsTableEntry	;new place for it
	cld				;set proper direction

MoveEntriesDown3:

	pushem	di,si,cx	       	;save current pointers and count
	mov	cx,SIZE XmsTableEntry	;size of one entry
	cld
	rep	movsb			;move it down
	popem	di,si,cx		;restore counts and pointers
	sub	si,SIZE XmsTableEntry	;source goes back by 1
	sub	di,SIZE XmsTableEntry	;destination goes back by 1
	loop	MoveEntriesDown3	;move required number of entries down

	popem	es,si,di,cx		;restore initial values
	ret

MoveEntriesDown endp
;----------------------------------------------------------------------------;
; FreeXmsBlock:							             ;
; 									     ;
; Tries to free an allocated XMS block, and then compacts the table to merge ;
; any consecutive free blocks together.	It also decs the 'WoaAppUsesXMS'     ;
; field after the deallocation.						     ;
;----------------------------------------------------------------------------;

FreeXmsBlock  proc near

	assumes ds,StubSeg

	pushem	si,di,es		;save work registers

; locate the entry for the block to be freed first

	call	LocateTableEntry	;locates the table entry
	jc	FreeInvalidHandle	;could not locate the entry

; we cannot free the block if it is locked

	cmp	bptr [si].TLckCount,0	;is it locked ?
	jnz	FreeLockedBlock		;yes,cannot free the block

; mark the block as free and compact the table, merging successive free
; blocks.

	push	bx			;save
	xor	bx,bx			;id for free handle.
	xchg	bx,[si].THandle		;get handle, mark entry as free
	call	ReleaseHandle		;reslease the handle
	pop	bx			;restore
	call	CompactTable		;compact the table
	mov	ax,1			;block successfully freed
	xor	bl,bl			;no error code
	dec	WoaAppUsesXMS		;one more block freed.
	jmp	short FreeXmsBlockRet 	;go back

FreeInvalidHandle:

	xor	ax,ax			;could not free the block
	mov	bl,0a2h			;as handle is invalid
	jmp	short FreeXmsBlockRet  	;return back

FreeLockedBlock:
	
	xor	ax,ax			;could not free the block
	mov	bl,0abh			;as block is locked

FreeXmsBlockRet:
	
	popem	si,di,es		;restore work registers
	ret

FreeXmsBlock	endp
;----------------------------------------------------------------------------;
; LocateTableEntry:							     ;
;									     ;
; Given a handle value in DX, this routine returns si pointing to the entry  ;
; in the allocation table, carry will be set if the handle is invalid .	     ;
;----------------------------------------------------------------------------;


LocateTableEntry  proc  near

	mov	si,StubSegOFFSET AllocationTable
	or	dx,dx			;handle valid ?
	jz	LocateInvalidHandle	;no.

LocateEntry1:

	cmp	[si].THandle,0ffffh	;end of table ?
	jz	LocateInvalidHandle	;bad handle provided
	cmp	[si].THandle,dx 	;is this the entry ?
	jz	@f			;yes, all done
	add	si,size XmsTableEntry	;no, keep looking.
	jmp	short LocateEntry1
@@:
	clc				;handle found
	jmp	short LocateTableEntryRet;fo back

LocateInvalidHandle:

	stc				;not a valid handle

LocateTableEntryRet:

	ret

LocateTableEntry  endp
;----------------------------------------------------------------------------;
;CompactTable:							             ;
;									     ;
; Compacts the allocation table, merging consecutive free blocks together.   ;
;----------------------------------------------------------------------------;

CompactTable proc near

	smov	es,ds			;both points to our segment
	mov	si,StubSegOFFSET AllocationTable
	mov	di,si			;get start of table in si
	add	di,SIZE XmsTableEntry	;di points to next one

CompactionLoop:

	cmp	wptr [di].THandle,0ffffh;end of table ?
	jz	CompactTableRet		;yes, compaction done.
	cmp	wptr [si].THandle,0	;is it a free entry ?
	jz	LookForAnotherFree	;is next block free too ?

BumpCompactionPointers:

	mov	si,di			;point tp next one
	add	di,SIZE XmsTableEntry	;and the one after that
	jmp	short CompactionLoop	;keep compacting

LookForAnotherFree:

	cmp	wptr [di].THandle,0	;is the next one free too ?
	jnz	BumpCompactionPointers	;no scope of compaction.

; we have a couple of entries to compact into 1.

	mov	ax,[di].TSize		;get size of second entry
	add	[si].TSize,ax		;compact the two.
	call	MoveEntriesUp		;move subsequent entries up
	jmp	short CompactionLoop	;look for more compactions

CompactTableRet:

	ret

CompactTable  endp
;----------------------------------------------------------------------------;
; MoveEntriesUp:							     ;
;									     ;
; On entry DI points to a table entry, this routine moves the entries after  ;
; that by one slot, obliterating the entry pointed by DI. On exit SI,DI      ;
; should maintain their entry time values.				     ;
;----------------------------------------------------------------------------;

MoveEntriesUp	proc  near

	assumes ds,StubSeg

	pushem	si,di,cx		;must preserve values
	smov	es,ds			;both must have own segment
	mov	si,di			;current entry
	add	si,SIZE XmsTableEntry	;point to next one
	cld				;have proper move direction

MoveEntryLoop:

	mov	cx,SIZE XmsTableEntry	;size of an entry
	cld
	rep	movsb			;move one entry up.
	cmp	wptr [di].THandle,0ffffh;was the last entry moved ?
	jnz	MoveEntryLoop		;cont. ptrs are correct
	
	popem	si,di,cx		;restore values
	ret				;go back, entries moved up

MoveEntriesUp endp
;----------------------------------------------------------------------------;
; MoveXmsBlock:								     ;
;									     ;
; If the src and dst handles in the move structure have valid handle values  ;
; this routine will substitute the handles by the actual XMS block handle    ;
; and add in the offset of the apps XMS base to the offsets specified and    ;
; then will invoke the actual XMS handler to move the block.		     ;
;----------------------------------------------------------------------------;

MoveXmsBlock proc near


	pushem	es,ds,di,si,cx,dx	;save registers
	smov	es,cs			;get own segment

; first copy over the move structure into our segment

	mov	di,StubSegOFFSET MoveStructure
	mov	cx,16			;16 bytes to move
	cld
	rep	movsb			;transfer the block
	smov	ds,es			;have own segment
	assumes ds,StubSeg

	mov	si,StubSegOFFSET MoveStructure

; patch up the structure

	push	ax			;save
	mov	ax,[si].MSrcHandle	;get the source handle
	or	ax,ax			;is it null ?
	jz	PatchDstMove		;no need to modify src
	call	GetBaseOffset		;get offset from start of XMS block
	jc	PatchDstMove		;invalid source handle
	add	ax,ExtraMoveOffsetLo	;add in the low word of pad area
	adc	dx,ExtraMoveOffsetHi	;add in hiword of pad area
	add	[si].MSrcOffsetLo,ax	;add it in
	adc	[si].MSrcOffsetHi,dx	;add it in
	mov	ax,XmsBaseHandle	;get the actual handle
	mov	[si].MSrcHandle,ax	;put in the actual handle

PatchDstMove:

	mov	ax,[si].MDstHandle	;get the destination handle
	or	ax,ax			;is it null ?
	jz	PatchDoMove		;no need to modify dst
	call	GetBaseOffset		;get offset from start of XMS block
	jc	PatchDoMove		;invalid dest handle
	add	ax,ExtraMoveOffsetLo	;add in the low word of pad area
	adc	dx,ExtraMoveOffsetHi	;add in hiword of pad area
	add	[si].MDstOffsetLo,ax	;add it in
	adc	[si].MDstOffsetHi,dx	;add it in
	mov	ax,XmsBaseHandle	;get the actual handle
	mov	[si].MDstHandle,ax	;put in the actual handle

PatchDoMove:
	
	pop	ax			;restore
	call	[PrevXmm]		;get original XMS to do the move
	popem	es,ds,di,si,cx,dx	;restore registers
	ret

MoveXmsBlock	endp
;----------------------------------------------------------------------------;
; LockXmsBlock:								     ;
;									     ;
; Increases the lock count of a specified block.			     ;
;----------------------------------------------------------------------------;

LockXmsBlock  proc near

	assumes ds,StubSeg

	push	si			;save

; locate the entry for the handle first
	
	call	LocateTableEntry	;if found, ds:si points to the entry
	jc	LockInvalidHandle	;not a valid handle

; increment the lock count

	cmp	bptr [si].TLckCount,0ffh;max count already ?
	jz	LockCountOverflow	;has been locked too many times
	inc	[si].TLckCount		;locking the block
	mov	bx,[si].TBaseLo		;get low wprd of base
	mov	dx,[si].TBaseHi		;get hiword of base
	mov	ax,1			;block is locked
	jmp	short LockXmsRet	;get back

LockInvalidHandle:

	xor	ax,ax			;cannot lock
	mov	bl,0a2h			;invalid handle
	jmp	short LockXmsRet	;go back

LockCountOverflow:

	xor	ax,ax			;could not lock the block
	mov	bl,0ach			;count overflow

LockXmsRet:

	pop	si			;restore
	ret

LockXmsBlock	endp
;----------------------------------------------------------------------------;
; UnlockXmsBlock:							     ;
;									     ;
; decreases the lock count of a specified block.			     ;
;----------------------------------------------------------------------------;

UnlockXmsBlock  proc near

	assumes ds,StubSeg

	push	si			;save

; locate the entry for the handle first
	
	call	LocateTableEntry	;if found, ds:si points to the entry
	jc	UnlockInvalidHandle	;not a valid handle

; decrement the Unlock count

	cmp	bptr [si].TLckCount,0	;is it locked ?
	jz	UnlockNotLocked		;not a locked block
	dec	[si].TLckCount		;locking the block
	mov	ax,1			;block is locked
	jmp	short UnlockXmsRet	;get back

UnlockInvalidHandle:

	xor	ax,ax			;cannot lock
	mov	bl,0a2h			;invalid handle
	jmp	short UnlockXmsRet	;go back

UnlockNotLocked:

	xor	ax,ax			;could not lock the block
	mov	bl,0aah			;block was not locked

UnlockXmsRet:

	pop	si			;restore
	ret

UnlockXmsBlock	endp
;----------------------------------------------------------------------------;
; GetXmsHandleInfo:							     ;
;									     ;
; Returns information about the a handle and no of free handles in the system;
;----------------------------------------------------------------------------;

GetXmsHandleInfo  proc near

	assumes ds,StubSeg

	push	si			;save
	call	LocateTableEntry	;try to loacte the entry
	jc	InvalidHandleInfo	;no a valid handle
	call	GetFreeHandleCount	;get no of free handles in system
	mov	bh,[si].TLckCount	;get lock count
	mov	dx,[si].TSize		;get the size
	mov	ax,1			;call was successful
	jmp	short GetXmsHandleInfoRet;go back

InvalidHandleInfo:

	xor	ax,ax			;call didnot succeed

GetXmsHandleInfoRet:
	
	pop	si			;restore
	ret

GetXmsHandleInfo  endp
;----------------------------------------------------------------------------;
; GetFreeHandleCount:							     ;
;								             ;
; Get number of free handles in the system. Since we allocate handle number  ;
; by allocating 0 length blocks from the previous handler, we will let the   ;
; the previous handler handle this call too.				     ;
;									     ;
; We just make the call on our base handle.				     ;
;----------------------------------------------------------------------------;

GetFreeHandleCount  proc  near

	assumes ds,StubSeg

	pushem	si,cx,dx,ax		;save
	mov	dx,XmsBaseHandle	;the handle of the 'big' block
	mov	ah,0eh	  		;get EMB handle info call
	call	[PrevXmm]		;get information, num handles in BL
	popem	si,cx,dx,ax		;restore 
	ret

GetFreeHandleCount  endp
;----------------------------------------------------------------------------;
; RelocateXmsBlock:							     ;
;									     ;
; Tries to grow or shrink the block. 				             ;
;----------------------------------------------------------------------------;

cProc	RellocateXmsBlock,<NEAR,PUBLIC,PASCAL>

	localV	MoveParams,16		;move parameter block, if needed
	localW	Handle1			;the original handle
	localW	Handle2			;the new handle
	localW	CurrentSize		;keeps current block size
	localW	Size1			;new size

cBegin

	assumes ds,StubSeg

	push	si			;save
	call	LocateTableEntry	;try to locate the entry
	njc	RellocateInvalidHandle	;bad handle

; test to see if the block is locked or not

	cmp	[si].TLckCount,0	;is it locked
	njnz	RellocateLockedBlock	;can't rellocate

; get the current size and decide whether to grow or shrink block

	cmp	bx,[si].TSize		;compare sizes
	nje	RellocationDone		;same size
	ja	RellocateGrow		;want to grow the block

; we are trying to shrink the block

	pushem	si,di,ax,bx,cx,es	;save
	call	MoveEntriesDown		;allocate a hole
	mov	ax,[si].TSize		;get current size
	sub	ax,bx			;size of free block created
	mov	[si].TSize,bx		;update size
	mov	di,[si].TBaseHi		;get hiword of current base
	mov	cx,[si].TBaseLo		;get lo word of current base
	mov	dx,bx			;size of the block in K
	call	UpdateBase		;add dx*1024 to di:cx
	add	si,SIZE XmsTableEntry	;point to the free slot entry
	mov	wptr [si].THandle,0	;mark as free
	mov	[si].TBaseLo,cx		;lo word of base
	mov	[si].TBaseHi,di		;hi word of base
	mov	[si].TSize,ax		;size of free block
	mov	bptr [si].TLckCount,0	;not locked
	call	CompactTable		;merge contiguous free blocks
	popem	si,di,ax,bx,cx,es	;restore
	jmp	RellocationDone		;successful

RellocateGrow:

	pushem	si,di,ax,bx,cx,dx,es	;save
	mov	di,si			;get the current entry
	add	di,SIZE XmsTableEntry	;point to next one
	cmp	wptr [di].THandle,0ffffh;end of table ?
	je	HarderRellocation	;need to rellocate the hard way
	cmp	wptr [di].THandle,0	;is it a free block ?
	jne	HarderRellocation	;need to relocate hard way
	mov	ax,[si].TSize		;get current size
	add	ax,[di].TSize		;the size of the free area
	cmp	bx,ax			;compare with size requested
	ja	HarderRellocation	;need to rellocate the hard way
	je	ExactFitRellocation	;free block will totaly be consumed

; we reach here when there is a sufficiently large free block below the the
; requested block and we can grow into this area yet have some left

	mov	[si].TSize,bx		;new size
	sub	ax,bx			;the size of the free area left
	mov	bx,[di].TSize		;original size
	sub	bx,ax			;size taken away
	mov	[di].TSize,ax		;update the size
	mov	si,di			;need pointer to the free block
	mov	di,[si].TBaseHi		;get the high word of base
	mov	cx,[si].TBaseLo		;get the low word of base
	mov	dx,bx			;size in K by which area was shrunk
	call	UpdateBase		;update DI:CX accordingly
	mov	[si].TBaseHi,di		;update hi word of base
	mov	[si].TBaseLo,cx		;update lo word of base
	popem	si,di,ax,bx,cx,dx,es	;restore
	jmp	RellocationDone		;successful

ExactFitRellocation:

; we reach here if there is a free block after the desired block and it will
; totally be taken up

	mov	[si].TSize,bx		;update size
	call	MoveEntriesUp		;obliterate the free block
	popem	si,di,ax,bx,cx,dx,es	;restore
	jmp	short RellocationDone	;successful

HarderRellocation:

; try to allocate a block of the new size, by calling own XMS

	pushem	bx,dx			;save
	mov	Handle1,dx		;save the original handle
	mov	Size1,bx		;save requested size
	mov	ax,[si].TSize		;get the current size
	mov	CurrentSize,ax		;save it
	mov	ah,9			;allocate call
	mov	dx,bx			;amount of memory required
	call	XmsHandler		;try to allocate the block
	or	ax,ax			;was it successful ?
	jz	BiggerRellocFails	;no.
	mov	Handle2,dx		;save the new handle

; the bigger block could be allocated, now we have to move the original block

	push	ds			;save
	smov	ds,ss			;need to access MoveParams
	lea	si,MoveParams		;point to the parameter block
	mov	[si].MDstHandle,dx	;save destination handle
	mov	[si].MDstOffsetLo,0	
	mov	[si].MDstOffsetHi,0	;dst offset is zero
	mov	[si].MSrcOffsetLo,0	
	mov	[si].MSrcOffsetHi,0	;src offset is zero
	mov	ax,CurrentSize		;get the current size
	mov	bx,1024			;it is in K
	mul	bx			;ax:dx has length of move
	mov	[si],ax			;save lo length
	mov	[si][2],dx		;save high length
	mov	dx,Handle1		;get the original handle
	mov	es:[si].MSrcHandle,dx	;save source handle
	mov	ah,0bh			;want to do a move
	call	XmsHandler		;move the block
	pop	ds			;get back own handle
	mov	dx,Handle1		;get the original handle
	mov	ah,0ah			;free block code
	call	XmsHandler		;free the block
	mov	dx,Handle2		;get the new handle
	mov	bx,Handle1		;the original handle
	call	LocateTableEntry	;ds:si points to entry
	mov	[si].THandle,bx		;set the original handle back
	mov	bx,dx			;the work handle
	call	ReleaseHandle		;release the handle
	popem	bx,dx			;restore
	jmp	short RellocationDone	;success

BiggerRellocFails:

	popem	bx,dx			;restore
	xor	ax,ax			;rellocation fails
	mov	bl,0a0h			;no more available memory
	jmp	short RellocateXmsBlockRet;done

RellocationDone:

	mov	ax,1			;operation successful
	xor	bl,bl			;no error
	jmp	short RellocateXmsBlockRet;go back

RellocateInvalidHandle:

	xor	ax,ax			;error
	mov	bl,0a2h			;because of invalid handle
	jmp	short RellocateXmsBlockRet;go back

RellocateLockedBlock:

	xor	ax,ax			;cannot rellocate
	mov	bl,0abh			;as the block is locked

RellocateXmsBlockRet:

	pop	si			;restore

cEnd
;----------------------------------------------------------------------------;
; GetBaseOffset:							     ;
;									     ;
; Given a handle in AX, this routine gets the offset of the start of the     ;
; block from line from which XMS allocation starts. The offset is returned   ;
; in DX:AX and carry is cleared if the handle is valid.			     ;
;----------------------------------------------------------------------------;

GetBaseOffset proc near

	push	si			;save
	mov	dx,ax			;get the handle
	call	LocateTableEntry	;si-> node for the handle
	jc	GetBaseOffsetRet	;handle not valid
	mov	ax,[si].TBaseLo	   	;get low word of base
	mov	dx,[si].TbaseHi		;DX:AX has actual base
	sub	ax,wptr [AppXmsBase]	;get the offset from the start line
	sbb	dx,wptr [AppXmsBase+2]	;DX:AX has relative offset
	clc				;success

GetBaseOffsetRet:		

	pop	si			;restore
	ret

GetBaseOffset endp
;----------------------------------------------------------------------------;
; HookOurXmsCode:							     ;
;									     ;
; This tries to hook our XMS code. If it fails it does nothing.		     ;
;----------------------------------------------------------------------------;
cProc	HookOurXMSCode,<NEAR,PUBLIC,PASCAL>

cBegin

	pushem	es,bx,ax,cx,si,di		;save

	mov	bx,word ptr [ActualXMS]
	mov	es,word ptr [ActualXMS+2]   	;ES:BX = ptr to 1st XMM header

NextXmmHeader:

	mov	word ptr [PrevXmm+2],es		;save seg of prev control adr
	mov	word ptr [XmmControlBase+2],es	;save address for patch
	mov	word ptr [XmmControlBase],bx
	mov	cx,word ptr es:[bx]
	cmp	cl,0EBh				;compare short jmp opcode
	je	ShortJmp
	cmp	cl,0EAh				;compare far jmp opcode
	jne	XmmChainHosed			;bad XMM control chain

FarJmp:

	mov	si,word ptr es:[bx+1]		;SI = offset of jmp
	mov	es,word ptr es:[bx+1+2]		;ES = segment of jmp
	mov	bx,si				;ES:BX points to next node
	jmp	NextXmmHeader			;continue down control chain

ShortJmp:

	cmp	word ptr es:[bx+2],9090h	; check NOPs
	jne	XmmChainHosed			; bad XMM control chain
	cmp	byte ptr es:[bx+4],90h
	jne	XmmChainHosed			; bad XMM control chain
	mov	di,bx				; DI = ptr to XMM header
	xor	ax,ax
	mov	al,ch				; AX = offset of short jmp
	mov	[XmmControlJmpVal],al		; save offset of short jmp
	add	ax,2				; add length of jmp instr
	add	bx,ax				; BX = target of jmp
	mov	word ptr [PrevXmm],bx  		; save previous control addr

; Install ourselves in XMM control chain.

	mov	byte ptr es:[di],0EAh		; far immediate jmp opcode
	mov	word ptr es:[di+1],StubSegOFFSET XmsHandler
	mov	word ptr es:[di+3],cs

	jmp	short Xh_done

XmmChainHosed:

Xh_done:

	popem	es,bx,ax,cx,si,di		;save

HookXMSRet:

cEnd
;----------------------------------------------------------------------------;
; UnHookOurXmsCode:							     ;
;									     ;
; We take out our XMS hook if we had put it in.				     ;
;----------------------------------------------------------------------------;
cProc	UnHookOurXmsCode,<NEAR,PUBLIC,PASCAL>

cBegin

	cmp	word ptr [XmmControlBase],-1
	jne	UnhookXmm
	cmp	word ptr [XmmControlBase+2],-1
	je	UnHookXMSRet		;we didn't hook- don't unhook
UnhookXmm:
	pushem	es,bx			;save
	mov	al,0EBh			;AL = opcode for short jump
	mov	ah,[XmmControlJmpVal]	;AH = displacement for short jump
	les	bx,[XmmControlBase]	;ES:BX = ptr to previous XMM header
	mov	word ptr es:[bx],ax	;restore previous XMM's short jump
	mov	word ptr es:[bx+2],9090h;followed by nop's
	mov	byte ptr es:[bx+4],90h	;third nop
	mov	word ptr [XmmControlBase],-1;we don't have our hook
	mov	word ptr [XmmControlBase+2],-1

	popem	es,bx			;restore

UnHookXMSRet:

cEnd
;----------------------------------------------------------------------------;
sEnd	StubSeg

end
	

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\woautils.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


;----------------------------------------------------------------------------;
; This file has utility programs which are invoked mostly from WOAMGR.ASM    ;
;									     ;
; History:								     ;
;									     ;
;	 Fri June-15-1990.	-by-  Amit Chatterjee [amitc]		     ;
;	 Adapted for the Dos Task Switcher.				     ;
;									     ;
;        Mon June-26-1989.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Windows. (Added the History legend)       		     ;
;----------------------------------------------------------------------------;

	?win = 0

	?DF = 1
	.xlist
	include cmacros.inc
	include woasegs.inc
	include macros.mac
	include	njmp.mac
	include dosx.inc
	include	woapif.inc
	include woaerr.inc
	include	woaarena.inc
	include woaswch.inc
	.list

	.286p

	public	SaveWinEmsContext
	public	RestoreWinEmsContext
	public	GetSizeInBytes
	public	ConvKToBytes

;----------------------------------------------------------------------------;
; define external FAR winoldap procedures.				     ;
;----------------------------------------------------------------------------;

sBegin	Data

;----------------------------------------------------------------------------;
; define the global variables defined elsewhere				     ;
;----------------------------------------------------------------------------;

externW	ArenaWalkSel			;temp selector for walkimg arena chain
externW	ArenaRWSel			;temp sel for reading/writing arenas
externW	XmsHeapWalkSel			;scratch selector for walking xms heap
externW WoaStubSel			;sel for current loaction of stub code
externB	EmsFlag				;EMS present or not.
externB fBreak				;state of CTRL+C flag.
externW	HighMemXmsHandle		;handle of the high heap XMS block
externB	DosAppSwapFileName		;name of the dos app swap file
externB ErrorType			;save area for error code
externW WoaCsSize			;size of protected mode code seg
externW WoaDsSize			;size of winoldap data segment
externW StubSegSize			;size of real mode stub segment
externB DiskSwap1Drive			;swap drive index for fast path
externB DiskSwap2Drive			;swap drive index for slow path
externW	Swap1MinK			;space to be left on 1st drive
externW Swap2MinK			;space to be left on second drive
externW Int15UsershApp			;hApp of INT 15 user
externW hApp				;windows handle for this instance
externD XmsBankSize			;size of apps XMS bank
externW LowMemParaSize			;para size of available memory
externW LowMemArenaSel			;pointer to the available memory arena
externW LowMemSel			;sel for the start of the vail block
externW	SizeReservedArea		;size of area reserved area at heap st.
externW CurrentDosSwapSeed		;swap file seed being used now
externW	AppUsesXMS			;app used it's allocated XMS or not

ifdef	JAPAN
externD KkcDataSize			; Data area size of KKC
endif

	;-------------------------------------------------------;
	; define any locally used constants			;
	;-------------------------------------------------------;


	;-------------------------------------------------------;
	; define any locally used constants			;
	;-------------------------------------------------------;

		ZERO_BLOCK_SIZE equ 128

	;-------------------------------------------------------;
	; define any external contants.				;
	;-------------------------------------------------------;

		externB	  WoaAppSwapErr		;(WOAERR.ASM)
		externA   IS_WINOLDAP_ACTIVE	;(WOAMGR.ASM)

;---------------------------------------------------------------------------;
; now define the other global variables that will be needed.		    ;
;---------------------------------------------------------------------------;
		

;---------------------------------------------------------------------------;
; now define the other variables that will be needed.			    ;
;---------------------------------------------------------------------------;

WinEmsSaveArea		db 256 dup (0)	;save windows EMS context here
globalW AppXmsBaseSel,0			;selector to base of apps XMS block


		;-------------------------------------------;
		; Debug messages used if DEBUGMODE is set.  ;
		;-------------------------------------------;

ifdef	DEBUGMODE

endif	;DEBUGMODE

sEnd Data

;----------------------------------------------------------------------------;
; now declare the existence of the realmode stub segment and the variables   ;
; that we want to reference here.					     ;
;----------------------------------------------------------------------------;

createSeg   _WOARLMSEG,StubSeg,word,public,code
sBegin	StubSeg

sEnd	StubSeg

;----------------------------------------------------------------------------;
; we define the switch_cs macro here.					     ;
;----------------------------------------------------------------------------;

switch_cs macro
	local	_x
	local	_y
_x	proc	far
	lea	ax,_y
	push	ax
	ret
_y:
_x	endp
	endm

;----------------------------------------------------------------------------;

sBegin	Code

	assumes	cs,Code
	assumes	ds,Data
	assumes	es,nothing

	;-------------------------------------------------------;
	; external OLDAPP procedures.			        ;
	;-------------------------------------------------------;

	externNP	DeleteFile		;(WOAFILE.ASM)
	externNP	ErrorManager		;(WOAERR.ASM)
	externNP	CreateFile		;(WOAFILE.ASM)
	externNP	LseekFile		;(WOAFILE.ASM)
	externNP	OpnFile			;(WOAFILE.ASM)
	externNP	ReadFile		;(WOAFILE.ASM)
	externNP	WriteFile		;(WOAFILE.ASM)
	externNP	CloseFile		;(WOAFILE.ASM)
	externNP	DeleteFile		;(WOAFILE.ASM)
	externNP	SetNormalAttributes	;(WOAFILE.ASM)
	externNP	SetHiddenAttributes	;(WOAFILE.ASM)
	externNP	GetSelectorBase		;(WOAPMRM.ASM)
	externNP	SetSelectorBaseLim64	;(WOAPMRM.ASM)
	externNP	GetDosAppSwap1FileName	;(WOAMGR.ASM)
	externNP	GetDosAppSwap2FileName	;(WOAMGR.ASM)
	externNP	SaveFirstDosBlock	;(WOAPMRM.ASM)
	externNP	RestoreFirstDosBlock	;(WOAPMRM.ASM)
	externNP	RestoreAppXmsContext	;(WOAPMRM.ASM)
	externNP	AppendUniqueNumber	;(WOAMGR.ASM)
	externNP	ZeroOutMemory		;(WOAPMRM.ASM)
	externNP	GetSwitcherEntry	;(WOAPMRM.ASM)

;----------------------------------------------------------------------------;
; SaveDosMemory:							     ;
;									     ;
; This routine takes the name of the dos swap file as the input. It writes   ;
; the first DOS block (or a part of it in real mode) to the swap file and    ;
; then traverses memory looking for non zero values and then swaps them      ;
; out in groups.						             ;
;									     ;
; This routine also takes an OpCode, SDMOpCode which if 0 returns just the   ;
; size needed to save the memory and if non zero actually saves the memory.  ;
; If the OpCode is 0, the first parameter is insignificant.		     ;
;----------------------------------------------------------------------------;

cProc	SaveDosMemory,<NEAR,PUBLIC,PASCAL>

	parmD	lpFileName		;name of the swap file
	parmB	SDMOpCode		;save or get size 

	localW	FileHandle		;handle of the swap file
	localV	NodeHeader,8		;DWORDs of base and lock size
	localD	CurrentSize		;size of the node being prepared
	localD	CurrentBase		;base of the node being prepared
	localD	SizeLeft		;amount of memory left
	localD	SDMSize			;size of save area

cBegin

	cld				;do not take chances with this

; Initialize the SDMSize field

	mov	seg_SDMSize,0
	mov	off_SDMSize,4		;4 bytes for XMS link

; create the swap file, at this point the file should not be existing, but
; we do not care to check.  Ifthe OpCode is for get size only, we will not
; try to create any file.

	cmp	SDMOpCode,0		;get size only
	jz	SDMByPassIO1		;yes
	xor	ax,ax			;want to create a normal file
	cCall	CreateFile,<lpFileName,ax>
	jc	SaveDosMemoryRet	;cannot proceed with error.
	mov	FileHandle,ax		;save the handle of the swap file

; we need to leave 4 bytes at the start of the file for storing the offset 
; of the start of the XMS swap out area. This is actually needed only in 
; real mode winoldap where the XMS memory has to be swapped in first.

	xor	ax,ax			;need zeros for hiword of offset/org.

ifdef	JAPAN
	mov	cx,8			;offset for seek
else
	mov	cx,4			;offset for seek
endif

	cCall	LseekFile,<FileHandle,ax,cx,ax>

SDMByPassIO1:

; we will save the first block arena selector separately and then skip over
; the _DATA and _TEXT segments. The following routine will do that, it will
; return the size of the block skipped over (top PDB, _DATA & _TEXT) in AX
; and the size wriiten to file (actuall 16) in CX:DX.

	cCall	SaveFirstDosBlock,<FileHandle,SDMOpCode>;saves the block containing woa stub
	jc	SaveDosMemoryRet	;cannot proceed with error.

; AX has the para size of the first block. CX:DX has the size wriiten out.
; Calculate the amount of memory left to be swapped.

	add	off_SDMSize,dx		;add in size wriitent out
	adc	seg_SDMSize,cx		;update hiword

	sub	ax,LowMemParaSize	;get difference
	neg	ax			;convert to positive
	call	GetSizeInBytes		;AX:BX has the size
	mov	seg_SizeLeft,ax 	;save hiword
	mov	off_SizeLeft,bx 	;save loword

; SetArenaWalkSel to the start of the block from where we want to swap on 
; (_WOARLMSEG) 
	       
	mov	ax,_WOARLMSEG		;want to swap from here
	mov	ArenaWalkSel,ax		;save it

; call the generalized routine to swap out the non zero blocks

	cCall	SwapOutNonZeroBlocks,<FileHandle,ArenaWalkSel,SizeLeft,SDMOpCode>
	jc	SaveDosMemoryRet	;cannot proceed with error.

; update the size and add 8 for the following node too. The above routine 
; would have returned the size written out in DX:AX

	add	ax,8			;for the terminating header
	adc	dx,0			;update hiword
	add	off_SDMSize,ax		;update total size
	adc	seg_SDMSize,dx		;update hiword

	cmp	SDMOpCode,0		;get size only ?
	jz	SaveDosMemoryRet	;yes.

; need to write out a dummy header to mark the end of the memory image area

	smov	es,ss			;need to access header structure
	lea	di,NodeHeader		;es:di points to the node header area
	push	di			;save the offset
	xor	ax,ax			;need to zero it out
	mov	cx,4			;size of header	in words
	rep	stosw			;initialize it
	pop	di			;es:di points to the NodeHeader
	mov	cx,8			;8 bytes of header to write
	xor	dx,dx			;hiword of number of bytes to write
	cCall	WriteFile,<FileHandle,es,di,dx,cx>

SaveDosMemoryRet:

	mov	ax,FileHandle		;need to return the handle of the file

; if the SDMOpCode is zero, return with the size in DX:AX.

	pushf				;save state of carry flag
	cmp	SDMOpCode,0		;get size only ?
	jnz	@f			;no.
	mov	dx,seg_SDMSize		;get hiword of size
	mov	ax,off_SDMSize		;get low eord of size
@@:
	popf				;restore carry flag (success or failure code)

cEnd
;----------------------------------------------------------------------------;
; SwapOutNonZeroBlocks:							     ;
; 									     ;
; This routine takes the following parameters:				     ;
;	 								     ;
;	FileHandle	---	Data will be written into this file	     ;
;	Start sel	---	Swap out area starts here (offset 0)	     ;
;	Size		---	Total size of the area in bytes (dword)	     ;
;       SONZBOpCode	---     If 0 will just get the swap area size.
;									     ;
; It scans the range specified for non zero blocks of zeros and writes out   ;
; swap groups (block preeceded by 8 byte header) to the file. It returns     ;
; with carry set if the writes failed.					     ;
;----------------------------------------------------------------------------;

cProc	SwapOutNonZeroBlocks,<NEAR,PUBLIC,PASCAL>,<es>

	parmW	FHandle			;handle for the file
	parmW	StartSel		;start selector
	parmD	SLeft			;size for the block
	parmB	SONZBOpCode		;get size only or not.

	localV	NHeader,8		;DWORDs of base and lock size
	localD	CSize			;current swap group size
	localD  CBase			;current swap group base
	localW	LoopSize		;size being tested in the loop
	localW	RestartOffset		;restart point
	localD	SONZBSize		;size of the swap area.

cBegin

; initialize the swap area size variable.

	mov	seg_SONZBSize,0
	mov	off_SONZBSize,0

; initialize the base and size for the next swap group

	mov	bx,StartSel		;get the selector
	mov	ArenaWalkSel,bx		;save it
	call	GetSelectorBase		;get the base in cx:dx

	mov	seg_CSize,0		;initialize current size of swap node
	mov	off_CSize,0		;initialize 32 bits
	mov	seg_CBase,cx		;save high word of current base
	mov	off_CBase,dx		;save low word of current base

ScanForZerosLoop:

	mov	es,ArenaWalkSel		;get the selector into es
	mov	ax,seg_SLeft		;are we all done ?
	or	ax,off_SLeft		
	njz	WriteSwapGroup		;write the group and end

; need to scan the segment for zeros.

	mov	cx,8000h		;assume complete segment (in words)
	cmp	seg_SLeft,0		;are we in the last 64k seg ?
	jnz	start_check_for_0	;no.
	mov	cx,off_SLeft		;get the size left to look.
	shr	cx,1			;convert to words

start_check_for_0:

	mov	LoopSize,cx		;save the size in words that we test

; scan for zeros in this segment.

	xor	ax,ax			;looking for zeros.
	xor	di,di			;start at top of segment.

continue_check_for_zero:

	repne	scasw			;look for zero.
	jcxz	go_to_next_seg		;no zeros found.

; the zero stretch should atleast be ZERO_STRETCH_SIZE long.

	inc	cx			;ignore the match.
	sub	di,2			;start of the zeros.
	mov	bx,di			;save

; look ahead ZERO_STRTECH_SIZE  or to the end of segment which ever is smaller

	pushem	ax,bx
	mov	ax,cx			;words left in the segment
	shl	ax,1			;convert to bytes
	mov	bx,ZERO_BLOCK_SIZE	;min zero block size
	jc	enough_in_segment	;complete segment is left
	cmp	ax,bx			;which is smaller ?
	jbe	look_ahead_size_obt	;ax has look ahead size

enough_in_segment:

	mov	ax,bx			;bx is min

look_ahead_size_obt:

	mov	dx,ax			;have it in dx
	popem	ax,bx

; from di onwards we want to have a block of DX size as 0s

	add	di,dx			;look ahead
	jc	scan_block_for_all_0s	;goes into next seg, see if its all 0
	cmp	byte ptr es:[di],0	;is it still 0 ?
	jz	scan_block_for_all_0s	;possibly 0 stretch obtained.
	sub	di,dx			;take it back to start of block

short_zero_block_size:

	add	di,dx			;update past the short block
	shr	dx,1			;convert to words
	sub	cx,dx			;update count left in segment
	jmp	continue_check_for_zero	;keep looking ahead

scan_block_for_all_0s:

	mov	di,bx			;go back to start of block
	pushem	cx,di			;save
	mov	cx,dx			;block size to look for
	shr	cx,1			;convert size to words.
	repe	scasw			;look for non zero.
	or	cx,cx			;all zeros ?
	popem	cx,di			;retrieve cx
	jnz	short_zero_block_size	;no, zero block not of min size
	add	di,dx			;past the zero block
	jc	go_to_next_seg		;forget about these zeros.
	and	di,0fff0h		;take it back to para start.
	mov	RestartOffset,di	;save next start scan point

; we have got a zero block of atleast the minimum size.

	
	mov	di,bx			;get the start of the block.
	add	di,15			;want to align to the next para
	and	di,0fff0h		;para aligned.
	jmp	ZeroBlockFound		;have got a block of zeros.

go_to_next_seg:

; update size left to be scanned.

	mov	cx,LoopSize		;get the size
	shl	cx,1			;get byte size
	sbb	seg_SLeft,0		;update hiword
	sub	off_SLeft,cx		;subtract from low word
	sbb	seg_SLeft,0		;update hiword

; update the sizes left and the current size.

	mov	cx,LoopSize		;get the size that we inspected
	shl	cx,1			;convert to bytes.
	adc	seg_CSize,0		;add cary to hiword
	add	off_CSize,cx		;add loword
	adc	seg_CSize,0		;add cary to hiword

; update to the next segment.

	mov	bx,ArenaWalkSel		;get the current selector
	call	GetSelectorBase		;get the base
	inc	cx			;next segment
	call	SetSelectorBaseLim64	;update to next seg
	mov	ArenaWalkSel,bx		;save
	jmp	ScanForZerosLoop	;continue.

ZeroBlockFound:

; update the sizes for the current swap group and the amount left to look

	add	off_CSize,di		;include till the zeros
	adc	seg_CSize,0		;update high word

	mov	di,RestartOffset	;we have basically scanned this much
	sub	off_SLeft,di		;amount left
	sbb	seg_SLeft,0

WriteSwapGroup:

	mov	bx,ArenaRWSel		;load the temp selector	for read/write
	mov	cx,seg_CBase		;load hiword of base of block
	mov	dx,off_CBase		;load the loword of the base
	call	SetSelectorBaseLim64	;point the selector to the base
	mov	ArenaRWSel,bx		;save the modified selector

; update the size that is being written.

	mov	dx,seg_CSize		;get the hiword
	mov	ax,off_CSize		;offset
	add	ax,8			;for the node header
	adc	dx,0			;update hiword
	add	off_SONZBSize,ax	;update loword of total size
	adc	seg_SONZBSize,dx	;update hiword.

; if the opcode is for get size only, then bypass the write.

	cmp	SONZBOpCode,0		;get size only ?
	jz	SONZBByPassIO1		;yes.
	
; write the header for the node, which consists of a dword of the value of the
; base of the block followed by a dword of the size of the block

	smov	es,ss			;need to access NHeader in stack
	lea	di,NHeader		;es:di points to the node header
	push	di			;save offset
	mov	ax,off_CBase		;get the low word of base
	stosw				;save it
	mov	ax,seg_CBase		;get the high word of base
	stosw				;save it
	mov	ax,off_CSize		;get the low word of size
	stosw				;save it
	mov	ax,seg_CSize		;get the high word of size
	stosw				;save it
	pop	di			;es:di points to the NHeader
	mov	cx,8			;8 bytes of header to write
	xor	dx,dx			;hiword of number of bytes to write
	cCall	WriteFile,<FHandle,es,di,dx,cx>
	njc	SwapNonZeroBlocksRet	;cannot proceed with error.

; now write out the allocated block contents.

	xor	ax,ax			;need for the start offset
	cCall	WriteFile,<FHandle,ArenaRWSel,ax,CSize>
	njc	SwapNonZeroBlocksRet	;cannot proceed with error.

SONZBByPassIO1:

; if we are done, we should write the end header and leave.

	mov	ax,seg_SLeft		;get the size left 
	or	ax,off_SLeft		;is it 0 ?
	njz	SwapNonZeroBlocksRet	;yes, done with the swap

ScanForNonZerosloop:

; if the RestartOffset is 0, we should go to the next segment.

	cmp	RestartOffset,0		;is it 0
	jnz	restart_in_same_seg	;no, we will restart in same seg.

; update to next segment.

	mov	bx,ArenaWalkSel		;get the current selector
	call	GetSelectorBase		;get the base
	inc	cx			;next segment
	call	SetSelectorBaseLim64	;update to next seg
	mov	ArenaWalkSel,bx		;save

restart_in_same_seg:

	mov	es,ArenaWalkSel		;get the selector into es
	mov	ax,seg_SLeft		;are we all done ?
	or	ax,off_SLeft		
	njz	SwapNonZeroBlocksRet	;yes, done with the swap

; get the min of (seg size in words, amount left in this segment , amount
;  left altogether).

	mov	ax,8000h		;seg size in words
	cmp	seg_SLeft,0		;last segment ?
	jnz	@f			;no.
	push	bx
	mov	ax, off_SLeft
	mov	bx, RestartOffset
	neg	bx
	cmp	ax, bx			;
	jbe	ROWontOverShoot		;S_Left is smaller
	or	bx,bx			;maybe bx is zero
	jz	ROWontOverShoot

; we have to ensure that di which will get the value of RestartOffset
; later, does not cros 0ffffh. If ax > bx this could happen.

	mov	ax,bx			;bx is non zero AND less than ax
ROWontOverShoot:
	pop	bx
	shr	ax,1			;convert to words
	jmp	short start_check_for_non_0	
@@:
	cmp	RestartOffset,0		;is it at start of segment ?
	jz	start_check_for_non_0	;yes
	mov	ax,RestartOffset	;get the start
	neg	ax			;amount left in seg
	shr	ax,1			;convert to words

start_check_for_non_0:

	mov	cx,ax			;get scan size in segment in words

; scan for non zeros in this segment.

	xor	ax,ax			;looking for zeros.
	mov	di,RestartOffset	;start from this point
	repe	scasw			;look for zero.
	or	cx,cx			;0?
	jnz	non_zero_found		;no.

; update size left.
	
	push	di			;save
	sub	di,RestartOffset	;amount scanned 
	sub	off_SLeft,di		;subtract
	sbb	seg_SLeft,0		;hiword.
	pop	di

; if both RestartOffset and current DI are 0 we have skipped a complete 
; segment.

	push	di			;save
	or	di,RestartOffset	;skipped one complete segment ?
	pop	di			;restore di
	mov	RestartOffset,0		;next scan from here.	
	jnz	ScanForNonZerosLoop	;no.
	dec	seg_SLeft		;0=>64k
	jmp	ScanForNonZerosLoop	;continue

non_zero_found:

; this segment has some non zero bytes. Start swapping from the previous 
; paragraph though.

	sub	di,2			;go back to start of non zero stretch
	and	di,0fff0h		;go back to start of para

; update the size left.

	mov	bx,di			;get the current offset
	sub	bx,RestartOffset	;place we started from
	sub	off_SLeft,bx		;account for the skipped part.
	sbb	seg_SLeft,0		;update hiword.
	mov	bx,es			;get the current selector
	call	GetSelectorBase		;get the base
	add	dx,di			;update to the start of non 0 block
	adc	cx,0			;update hiword.

; update vars for the next swap group.

	mov	seg_CSize,0		;initialize current size of swap node
	mov	off_CSize,0		;initialize 32 bits
	mov	seg_CBase,cx		;save high word of current base
	mov	off_CBase,dx		;save low word of current base
	call	SetSelectorBaseLim64	;set selector to point to next base
	mov	ArenaWalkSel,bx		;update
	jmp	ScanForZerosLoop	;continue.

SwapNonZeroBlocksRet:

; if the opcode was for get size only, return with the size in DX:AX

	pushf				;save carry flag state
	cmp	SONZBOpCode,0		;get size on;y ?
	jnz	@f			;no.
	mov	dx,seg_SONZBSize	;get hiword of swap size
	mov	ax,off_SONZBSize	;get low word of swap size
@@:
	popf				;restore state of carry flag

cEnd
;----------------------------------------------------------------------------;
; GetBackAppXmsNeeds:							     ;
;									     ;
; This routine looks at the dos app swap file to locate the size of the XMS  ;
; block that the app needs and saves it in 'XmsBankSize'		     ;
;----------------------------------------------------------------------------;

cProc	GetBackAppXmsNeeds,<NEAR,PUBLIC,PASCAL>

	localD	DwordBuffer		;can read in 4 bytes here
	localW	FileHandle		;save file handle here

cBegin

	cld				;do not take chances with this
	mov	ErrorType,ER_APP_SWAP_IN;in case file can't be found
	mov	si,DataOFFSET DosAppSwapFileName
	cCall	SetNormalAttributes,<ds,si>
	mov	ax,2			;open a normal file
	cCall	OpnFile,<ds,si,ax>	;try to open the file
	njc	ErrorHandler		;cannot	swap in
	mov	FileHandle,ax		;save the handle

; now read in the offset to the start of the xms swap area

	lea	ax,DwordBuffer		;read in offset into ss:ax
	xor	cx,cx			;hiword of count of 4 bytes
	mov	bx,4			;need to read in 4 bytes
	cCall	ReadFile,<FileHandle,ss,ax,cx,bx>
	njc	ErrorHandler		;file too small,error

; now seek to the offset that has just been read in

	xor	ax,ax			;need to seek from the start of the file
	cCall	LseekFile,<FileHandle,DwordBuffer,ax>
	njc	ErrorHandler		;file too small,error

; read in the 4 byte XMS memory size

	lea	di,DwordBuffer		;ss:di points to buffer
	xor	ax,ax			;hiword of count is 0
	mov	bx,4			;need to read 4 bytes (loword of count)
	cCall	ReadFile,<FileHandle,ss,di,ax,bx>
	njc	ErrorHandler		;error in reading in

; save the file size in 'XmsBankSize' global variable.

	mov	ax,seg_DwordBuffer	;get the hiword of size
	mov	wptr [XmsBankSize+2],ax	;save it
	mov	ax,off_DwordBuffer	;get the loword of size
	mov	wptr [XmsBankSize],ax	;save it

; return with the handle of the file

	mov	ax,FileHandle		;handle of dos file

cEnd
;----------------------------------------------------------------------------;
; RestoreXmsAndDosAllocatedBlocks:	  				     ;
;									     ;
; This routine takes a long pointer to a swap file name and read in the dos  ;
; memory allocation image that belongs to the old app. The swap file is      ;
; discussed in the header of the routine above.				     ;
;----------------------------------------------------------------------------;

cProc	RestoreXmsAndDosAllocatedBlocks,<NEAR,PUBLIC,PASCAL>

	parmD	lpFileName		;the name of the swap file

	localW	FileHandle		;handle of the swap file
	localD	FileOffset		;place to read in 4 byte offset
	localV	NodeHeader,8		;will read in the node header here

cBegin

	cld				;do not take chances with this

; try to open the swap file. Set normal attributes for the file.

	cCall	SetNormalAttributes,<lpFileName>
	mov	ax,2			;want to open a read only file
	cCall	OpnFile,<lpFileName,ax>	;try to open the file
	jc	RestoreDosAllocatedBlocksRet;cannot proceed with error.
	mov	FileHandle,ax		;save the handle of the swap file

; we first need to restore the XMS context first, so get the offset of the
; start of the XMS area (saved as the first 4 bytes of the file).

	lea	ax,FileOffset		;read in offset into ss:ax
	xor	cx,cx			;hiword of count of 4 bytes
	mov	bx,4			;need to read in 4 bytes
	cCall	ReadFile,<FileHandle,ss,ax,cx,bx>
	jc	RestoreDosAllocatedBlocksRet	

; now seek to the offset that has just been read in

	xor	ax,ax			;need to seek from the start of the file
	cCall	LseekFile,<FileHandle,FileOffset,ax>

; now read in the XMS context. if the app needs XMS memory,we must swap out the 
; block into the XMS file before loading applications XMS blocks

	cCall	RestoreAppXmsContext,<FileHandle>;restore the XMS context
	jc	RestoreDosAllocatedBlocksRet;cannot proceed with error.

; now seek back to the start of the file past the 4 byte offset area for reading
; in the image of the dos app.

	xor	ax,ax			;need zeros for hiword of offset/org.

ifdef	JAPAN
	mov	cx,8			;offset for seek
else
	mov	cx,4			;offset for seek
endif

	cCall	LseekFile,<FileHandle,ax,cx,ax>

; zero out the area where we will read apps context in.	We must zero out 
; from the start of the StubSeg onwards.


	mov	ax,_WOARLMSEG		;start of stub segment
	sub	ax,LowMemSel		;paragraphs at the begining
	cCall	ZeroOutMemory,<LowMemSel,LowMemParaSize,ax>

; now read in the first allocated block. In protected mode the complete block
; had been saved and the size of the block can be obtained after reading in
; the arena. In real mode, the portion of memory right after the arena which
; holds the top pdb and main code and data segments had not been saved and 
; should be skipped during the swap back

  	cCall	RestoreFirstDosBlock,<FileHandle>
	jc	RestoreDosAllocatedBlocksRet;cannot proceed with error.

; now get into a loop reading in header for every node and reading the 
; associated memory image into the right space, till we get a node header
; with a base of zero.

	cCall	RestoreSwappedGroups,<FileHandle>
	mov	ax,FileHandle		;must return with file handle

RestoreDosAllocatedBlocksRet:

cEnd
;----------------------------------------------------------------------------;
; RestoreSwappedGroups:							     ;
;									     ;
; Takes a handle for a swap file as a parameter and reads back swapped out   ;
; groups from the file. The structure of each swap group is a dword of the   ;
; base of the memory where the block is to be read back, a dword of size of  ;
; the block to read in, followed by the image of the block itself. The swap  ;
; groups are terminated by a node header where the base is 0.		     ;
;----------------------------------------------------------------------------;

cProc	RestoreSwappedGroups,<NEAR,PUBLIC,PASCAL>

	parmW	FileHandle		;handle of the swap file

	localV	NodeHeader,8		;will read in the node header here

cBegin

	cld				;do not take chances with this

ReadBlockLoop:

; read in the next node header.

	smov	es,ss			;fill read the header into the stack
	lea	di,NodeHeader		;es:di points to read buffer
	mov	cx,8			;need to read 8 bytes in
	xor	ax,ax			;hiword of count is 0
	pushem	es,di			;save the pointer
	cCall	ReadFile,<FileHandle,es,di,ax,cx>
	popem	es,di			;restore the pointer
	jc	RestoreSwappedGroupsRet ;cannot proceed with error.

; if the base of the block is 0, we are done

	mov	ax,es:[di]		;get the low word of base
	or	ax,es:[di+2]		;the high word of base
	jz	ReadBlockDone		;we have read back  the complate image

; prepare a word selector for reading back the block and read it back.

	mov	cx,es:[di+2]		;get the hiword of the base
	mov	dx,es:[di]		;get the low word of the base
	mov	bx,ArenaRWSel		;load the temp selector
	cCall	SetSelectorBaseLim64	;set up with the proper base
	mov	ArenaRWSel,bx		;save the modified value
	mov	cx,es:[di+6]		;get the high word of count
	mov	dx,es:[di+4]		;get the low word of count
	xor	ax,ax			;need zero for the start offset
	cCall	ReadFile,<FileHandle,ArenaRWSel,ax,cx,dx>
	jc	RestoreSwappedGroupsRet ;cannot proceed with error.

; now read back the other blocks.

	jmp	short ReadBlockLoop	;read in the resto of the blocks

ReadBlockDone:

	clc				;successful read back done

RestoreSwappedGroupsRet:

cEnd
;----------------------------------------------------------------------------;
; GetSizeInBytes:							     ;
;									     ;
; On entry AX has the size of an object in paragraphs, this routine returns  ;
; the size in bytes in AX:BX						     ;
;----------------------------------------------------------------------------;

GetSizeInBytes	proc near

	xor	bh,bh			;hibyte of hiword will be zero
	mov	bl,ah			;need the high nibble
	shiftr	bl,4			;move it to bit positions 16-19
	shiftl	ax,4			;effective mul by 16
	xchg	ax,bx			;ax:bx has the size in bytes
	ret

GetSizeInBytes	endp
;----------------------------------------------------------------------------;
; ConvKToBytes:							  	     ;
;									     ;
; On entry AX has the size of an object in KBytes and this routine returns   ;
; the size in bytes in AX:BX.						     ;
;----------------------------------------------------------------------------;

ConvKToBytes proc near

	push	dx			;save
	xor	dx,dx			;for the mul
	mov	bx,1024			;mult fctor
	mul	bx			;dx:ax has the result
	xchg	ax,dx			;ax:dx has the result
	mov	bx,dx			;ax:bx has the result
	pop	dx			;restore
	ret

ConvKToBytes endp
;----------------------------------------------------------------------------;
; This routine save the state of the EMS page mapping registers if EMS driver;
; is present.							             ;
;----------------------------------------------------------------------------;

SaveWinEmsContext proc near

	cmp	EmsFlag,0ffh		;is the EMS driver present ?
	jnz	@f			;no, nothing to save
	mov	di,DataOFFSET WinEmsSaveArea
	mov	ax,4e00h		;want to get the page mapping resgisters
	smov	es,ds			;ES:DI points to the save area
	int	67h			;page map resgisters obtained
@@:
	ret

SaveWinEmsContext  endp
;----------------------------------------------------------------------------;
; This routine restores the previously saved state of the Ems page mapping   ;
; registers, if the EMS drivers is present.			    	     ;
;----------------------------------------------------------------------------;

RestoreWinEmsContext  proc near

	cmp	EmsFlag,0ffh		;is the EMS driver present ?
	jnz	@f			;no, nothing to restore
	mov	si,DataOFFSET WinEmsSaveArea
	mov	ax,4e01h		;set map resgister code
	int	67h			;the mapper resgisters reprogrammed
@@:
	ret	

RestoreWinEmsContext  endp
;----------------------------------------------------------------------------;
; WhichSwapPathToUse:							     ;
;									     ;
; This routine finds out the amount of space that will be needed for swapping;
; out the dos app's context and decides which swap path it should use.       ;
;									     ;
; It will will up the 'DosAppSwapFileName' buffer appropriately, but will    ;
; return with carry if no space is available in either places. It wil also   ;
; update the global structure for the top entry to reflect what path it is   ;
; using.								     ;
;----------------------------------------------------------------------------;

cProc	WhichSwapPathToUse,<NEAR,PUBLIC,PASCAL>

	localD	WSPSize			;size of swap area

cBegin

; initialize the variable to hold the size of the swap area.

	mov	off_WSPSize,1024	;size of IDT area
	mov	seg_WSPSize,0		;reset high word

; find out the size of the conventional memory context.

	xor	ax,ax			;get size only
	cCall	SaveDosMemory,<ax,ax,ax>;1st two parameters insignificant
	add	off_WSPSize,ax		;add low word of size
	adc	seg_WSPSize,dx		;update high word

; Add in the size of the XMS Context. We will have to consider the complete
; XMS size as we have no way of knowing what the actual size will be, at this
; point.  However if 'AppUsesXMS' is 0, we will not swap the XMS out and thus
; we will not consider it's size

	cmp	AppUsesXMS,0		;did it use XMS ?
	jz	@f			;no.
	mov	ax,wptr [XmsBankSize]	;get low word of size
	mov	dx,wptr [XmsBankSize+2]	;get high word of size
	add	off_WSPSize,ax		;add low word of size
	adc	seg_WSPSize,dx		;update high word
@@:

ifdef	JAPAN
	mov	ax,wptr [KkcDataSize]	; get data size of KKC
	mov	dx,wptr [KkcDataSize+2]	;
	add	off_WSPSize,ax		;add low word of size
	adc	seg_WSPSize,dx		;update high word
endif

; find out if there is enough disk space on the first drive.

	mov	cx,seg_WSPSize		;get low word of size
	mov	dx,off_WSPSize		;cx:dx has swap area size
	mov	ax,Swap1MinK		;min area to be left
	call	ConvKToBytes		;ax:bx has size of space to leave
	add	dx,bx			;add in low word
	adc	cx,ax			;cx:ax = desired space
	cCall	IsEnoughDiskSpace,<DiskSwap1Drive,cx,dx>
	jc	TryDisk2		;not enough on disk 1
	call	GetDosAppSwap1FileName	;fill up file name
	mov	bl,1			;1st path to be used
	jmp	short UpdatePathInfo	;update global block

TryDisk2:

	mov	cx,seg_WSPSize		;get low word of size
	mov	dx,off_WSPSize		;cx:dx has swap area size
	mov	ax,Swap2MinK		;min area to be left
	call	ConvKToBytes		;ax:bx has size of space to leave
	add	dx,bx			;add in low word
	adc	cx,ax			;cx:ax = desired space
	cCall	IsEnoughDiskSpace,<DiskSwap2Drive,cx,dx>
	jc	WhichSwapPathToUseRet	;no space on any drive
	call	GetDosAppSwap2FileName	;fill up file name
	mov	bl,2			;second path to be used

UpdatePathInfo:

	pushem	es,si			;save
	push	bx			;save
	cCall	GetSwitcherEntry,<CurrentDosSwapSeed>
	jc	WhichSwapPathToUseRet	;error, can't find node:can't swapout
	mov	es,dx			;ignore logical node num in bx
	mov	si,ax			;es:si points to the desired entry
	pop	bx			;get back path id
	mov	es:[si].Path_Id,bl	;save path code
	popem	es,si			;restore
	clc				;no error

WhichSwapPathToUseRet:

cEnd
;----------------------------------------------------------------------------;
; IsEnoughDiskSpace:							     ;
;									     ;
; This routine checks to see if the amount of bytes of disk space left is    ;
; enough to swap out the dword of bytes that is passed in as a parameter.    ;
; Carry is set if there is not enough free space else it is set.	     ;
;----------------------------------------------------------------------------;

cProc	IsEnoughDiskSpace,<NEAR,PASCAL,PUBLIC>
	
	parmB	IEDDriveId		;drive ID
	parmD	SpaceNeeded		;amount of space needed

cBegin

; get the amount of disk space left.

	mov	ah,36h			;get free space call
	mov	dl,IEDDriveId		;get the swap drive number
	sub	dl,40h			;A=1,B=2 etc
	int	21h			;get various parameters
	xor	dx,dx			;need for multiplication

; AX*BX*CX is the no of bytes of free space.

	mul	bx			;DX:AX has AX*BX
	or	dx,dx			;is dx already 1 ?
	jnz	IsEnoughDiskSpaceRet	;will be enough space
	mul	cx			;DX:AX has amount of free space

; check to see if this is enough

	cmp	dx,seg_SpaceNeeded	;compare hiwords
	jne	IsEnoughDiskSpaceRet	;carry set or unset for result
	cmp	ax,off_SpaceNeeded	;compare low words

; carry set if not enough space or cleared if enough space

IsEnoughDiskSpaceRet:

cEnd
;----------------------------------------------------------------------------;
; AppSwapOutErrHandler:							     ;
;									     ;
; This routine is called when an application swap out attempt fails. The     ;
; screen had been put into a text mode by a previous grabber call.  This     ;
; routine displays an error msg across the top of the screen and waits	     ;
; for a key to be hit.							     ;
;----------------------------------------------------------------------------;

cProc	AppSwapOutErrHandler,<NEAR,PUBLIC,PASCAL>

cBegin

; if a partial swap file had been created for the application, delete it.

	mov	si,DataOFFSET DosAppSwapFileName;ds:si points to the name
	mov	dx,si			;ds:dx has the pointer now.
	mov	ah,41h			;delete file code
	int	21h			;delete the file

; print the error message. First home the cursor.

	mov	ah,0Fh			;get & set the current mode
	int	10h			;  so that the screen is clear
	xor	ah,ah			;  and the cursor is homed
	int	10h			;  (works for mode 3 & 7)

	mov	dx,DataOFFSET WoaAppSwapErr;the error message
	mov	ah,09h			;display string code
	int	21h			

; now remove the cursor from the screen.

	mov	ah,2			;position cursor
	xor	bh,bh			;page 0
	mov	dx,1900h		;position to 25th line
	int	10h			;cursor removed.

; now wait for a key to be hit.

	mov	ax,0C07h		;flush kbd buffer & do a raw read
	int	21h
		
cEnd
;----------------------------------------------------------------------------;
; ResetClassInt15Word:							     ;
;									     ;
; This takes an  app ID as the parameter and if the INT 15 word in the global;
; structure is the same as the handle then it resets the word.   	     ;
;									     ;
; This routine must also reset the 'Int15UsershApp' variable if the handle   ;
; is the same.							             ;
;----------------------------------------------------------------------------;

cProc	ResetClassInt15Word,<NEAR,PUBLIC,PASCAL>

	parmW	hAppId			;hApp passed in

cBegin

; get the current word.

	cCall	GetInt15Word		;get the current ID
	cmp	ax,hAppId		;does it compare ?
	jnz	@f			;no.
	xor	ax,ax			;need to set it to 0
	mov	Int15UsershApp,ax	;reset the ID
	cCall	SetInt15Word,<ax>	;reset the word
@@:
cEnd
;----------------------------------------------------------------------------;
; GetInt15Word:								     ;
;									     ;
; This routine gets the current value of the INT 15 Users ID saved in the    ;
; global switch structure.						     ;
;----------------------------------------------------------------------------;

cProc	GetInt15Word,<NEAR,PUBLIC,PASCAL>,<es,di>

cBegin

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure
	mov	ax,es:[di].Int_15_Users_Id;get the ID

cEnd
;----------------------------------------------------------------------------;
; SetInt15Word:								     ;
;									     ;
; This routine sets the current value of the INT 15 Users ID saved in the    ;
; global switch structure to the passed in parameter value.  		     ;
;----------------------------------------------------------------------------;

cProc	SetInt15Word,<NEAR,PUBLIC,PASCAL>,<es,di>

	parmW	Value			;value of the word

cBegin

	mov	ax,4a05h		;opcode
	mov	si,CGET_GLOBAL_SWITCH_DATA
	int	2fh			;dx:ax has the long pointer
	mov	es,dx			;load it into es
	mov	di,ax			;es:di -> info structure
	mov	ax,Value		;get the new value
	mov	es:[di].Int_15_Users_Id,ax ;set it

cEnd
;----------------------------------------------------------------------------;
; GetNSetCtrlCFlag:							     ;
;									     ;
; This routine gets the current state of the CTRL+C flag and sets it off     ;
; after saving the state. The state would be restored in the stub segment    ;
; and also before the next EnableDos call.				     ;
;									     ;
; Entry:								     ;
; 	 DS - Winoldap's Data segment.					     ;
;             No other registers relevant.				     ;
;----------------------------------------------------------------------------;

cProc	GetNSetCtrlCFlag,<NEAR,PUBLIC,PASCAL>	

cBegin

; flush the keyboard buffer

	mov	ax,0c00h		;flush buffer code
	int 	21h

; get the current state	of the CtrlC flag.

	mov	ax,3300h		;get CTRL+C flag
	int	21h			;state in DL.
	mov	fBreak,dl		;save it

; now set the state off.

	
	mov	ax,3301h		;set the blag
	xor	dl,dl			;to off
	int	21h			;flag set off

cEnd
;----------------------------------------------------------------------------;
; RestoreCtrlCFlag:							     ;
;									     ;
; Restores the state of the CTRL+C flag that had been saved before.	     ;
;									     ;
; Entry:								     ;
; 	 DS - Winoldap's Data segment.					     ;
;             No other registers relevant.				     ;
;----------------------------------------------------------------------------;

cProc	RestoreCtrlCFlag,<NEAR,PUBLIC,PASCAL>

cBegin

; restore the saved state

	mov	ax,3301h		;set the blag
	mov	dl,fBreak		;get the saved state.
	int	21h			;flag restored

cEnd
;----------------------------------------------------------------------------;
; This routine invokes the error manager.			             ;
;----------------------------------------------------------------------------;

ErrorHandler:
	
	call	ErrorManager		;this never returns

;----------------------------------------------------------------------------;

sEnd Code

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\cds.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/* structure of a CDS */

#define DIRSTRLEN   64+3

struct CDSType
{
        char            text[DIRSTRLEN] ;
        unsigned        flags ;
        long            pDPB ;
        long            ID ;
        unsigned        wUser ;
        unsigned        cbEnd ;
        char            type ;
        long            ifs_hdr ;
        char            fsda[2] ;
} ;

#define CDSNET          0x8000
#define CDSINUSE        0x4000
#define CDSSPLICE       0x2000
#define CDSLOCAL        0x1000

extern char fGetCDS() ;
extern char fPutCDS() ;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\copyrigh.h ===
//M000 - Updated copyright message
char	*copyright1 =  "MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp ";
char	*copyright2 =  "Licensed Material - Property of Microsoft ";
char   *copyright3 =  "All rights reserved ";

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\basemid.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*      SCCSID = @(#)basemid.h	8.26 87/05/21 */

#define MSG_RESPONSE_DATA               0         /* data for valid responses (Y N A R I) */
#define MSG_INVALID_FUNCTION            1         /* Invalid function */
#define MSG_FILE_NOT_FOUND              2         /* File not found */
#define MSG_PATH_NOT_FOUND              3         /* Path not found */
#define MSG_OUT_OF_HANDLES              4         /* Too many open files, no handles left */
#define MSG_ACCESS_DENIED               5         /* Access denied */
#define MSG_INVALID_HANDLE              6         /* Invalid handle */
#define MSG_MEMORY_BLOCKS_BAD           7         /* Memory control blocks destroyed */
#define MSG_NO_MEMORY                   8         /* Insufficient memory */
#define MSG_INVALID_MEM_ADDR            9         /* Invalid memory block address */
#define MSG_INVALID_ENVIRON             10        /* Invalid environment */
#define MSG_INVALID_FORMAT              11        /* Invalid format */
#define MSG_INVALID_ACC_CODE            12        /* Invalid access code */
#define MSG_INVALID_DATA                13        /* Invalid data */
#define MSG_14                          14        /* Reserved */
#define MSG_INVALID_DRIVE               15        /* Invalid drive */
#define MSG_ATT_RD_CURDIR               16        /* Attempt to remove current directory */
#define MSG_NOT_SAME_DEVICE             17        /* Not same device */
#define MSG_NO_MORE_FILES               18        /* No more files */
#define MSG_ATT_WRITE_PROT              19        /* Attempted write on protected disk */
#define MSG_UNKNOWN_UNIT                20        /* Unknown unit */
#define MSG_DRIVE_NOT_READY             21        /* Drive not ready */
#define MSG_UNKNOWN_COMMAND             22        /* Unknown command */
#define MSG_DATA_ERROR                  23        /* Data error (CRC) */
#define MSG_BAD_REQ_STRUCTURE           24        /* Bad request structure length */
#define MSG_SEEK_ERROR                  25        /* Seek error */
#define MSG_UNKNOWN_MEDIA               26        /* Unknown media type */
#define MSG_SECTOR_NOT_FOUND            27        /* Sector not found */
#define MSG_OUT_OF_PAPER                28        /* Printer out of paper */
#define MSG_WRITE_FAULT                 29        /* Write fault */
#define MSG_READ_FAULT                  30        /* Read fault */
#define MSG_GENERAL_FAILURE             31        /* General failure */
#define MSG_SHARING_VIOLATION           32        /* Sharing violation */
#define MSG_SHAR_VIOLAT_FIND            32        /* sharing violation find */
#define MSG_LOCK_VIOLATION              33        /* Lock violation */
#define MSG_INVALID_DISK_CHANGE         34        /* Invalid disk change */
#define MSG_35                          35        /* FCB unavailable */
#define MSG_SHARING_BUFF_OFLOW          36        /* Sharing buffer overflow */
/* msg 37 - 49 reserved */
#define MSG_NET_REQ_NOT_SUPPORT         50        /* net request not supported */
#define MSG_NET_REMOTE_NOT_ONLINE       51        /* remote computer not online */
#define MSG_NET_DUP_FILENAME            52        /* duplicate filename on network */
#define MSG_NET_PATH_NOT_FOUND          53        /* network path not found */
#define MSG_NET_BUSY                    54        /* network is busy */
#define MSG_NET_DEV_NOT_INSTALLED       55        /* device no longer installed */
#define MSG_NET_BIOS_LIMIT_REACHED      56        /* BIOS command limit exceeded */
#define MSG_NET_ADAPT_HRDW_ERROR        57        /* adapter hardware error */
#define MSG_NET_INCORRECT_RESPONSE      58        /* network response incorrect */
#define MSG_NET_UNEXPECT_ERROR          59        /* unexpected network error */
#define MSG_NET_REMOT_ADPT_INCOMP       60        /* remote adapter is incompatible */
#define MSG_NET_PRINT_Q_FULL            61        /* print queue is full */
#define MSG_NET_NO_SPACE_TO_PRINT_FL    62        /* not enough space to print file */
#define MSG_NET_PRINT_FILE_DELETED      63        /* print file was deleted */
#define MSG_NET_NAME_DELETED            64        /* network name was deleted */
#define MSG_NET_ACCESS_DENIED           65        /* network access denied */
#define MSG_NET_DEV_TYPE_INVALID        66        /* network device type invalid */
#define MSG_NET_NAME_NOT_FOUND          67        /* network name cannot be found */
#define MSG_NET_NAME_LIMIT_EXCEED       68        /* net name limit was exceeded */
#define MSG_NET_BIOS_LIMIT_EXCEED       69        /* BIOS session limit exceeded */
#define MSG_NET_TEMP_PAUSED             70        /* net is temporarily paused */
#define MSG_NET_REQUEST_DENIED          71        /* net request was denied */
#define MSG_NET_PRT_DSK_REDIR_PAUSE     72        /* print or disk redirection paused */
/* msg 73 - 79 reserved */
#define MSG_FILE_EXISTS                 80
/* msg 81 reserved */
#define MSG_CANNOT_MAKE                 82
#define MSG_NET_FAIL_INT_TWO_FOUR       83        /* fail on int 24 */
#define MSG_NET_TOO_MANY_REDIRECT       84        /* too many net redirections */
#define MSG_NET_DUP_REDIRECTION         85        /* duplicate redirection */
#define MSG_NET_INVALID_PASSWORD        86        /* invalid password */
#define MSG_NET_INCORR_PARAMETER        87        /* incorrect net parameter */
#define MSG_NET_DATA_FAULT              88        /* net data fault */
#define MSG_NO_PROC_SLOTS               89        /* no process slots */
#define MSG_DISK_CHANGE                 107
#define MSG_DRIVE_LOCKED                108
#define MSG_ERROR_OPEN_FAILED           110       /* error open failed */
#define MSG_DISK_FULL                   112
#define MSG_NO_SEARCH_HANDLES           113
#define MSG_ERR_INV_TAR_HANDLE          114       /* error invalid target handle */
#define MSG_BAD_DRIVER_LEVEL            119       /* bad driver level */
#define MSG_INVALID_NAME                123
#define MSG_NO_VOLUME_LABEL             125
/* */
#define MSG_JOIN_ON_DRIV_IS_TAR         133       /* directory on drive is target of a jo */
#define MSG_JOIN_DRIVE_IS               134       /* drive is joined */
#define MSG_SUB_DRIVE_IS                135       /* drive is substed */
#define MSG_DRIVE_IS_NOT_JOINED         136       /* drive is not joined */
#define MSG_DRIVE_NOT_SUBSTED           137       /* drive is not substituted - subst */
#define MSG_JOIN_CANNOT_JOIN_DRIVE      138       /* cannot join to a joined drive */
#define MSG_SUB_CANNOT_SUBST_DRIVE      139       /* cannot sub to sub drive */
#define MSG_JOIN_CANNOT_SUB_DRIVE       140       /* cannot join to a substed drive */
#define MSG_SUB_CANNOT_JOIN_DRIVE       141       /* cannot sub to a joined drive */
#define MSG_DRIVE_IS_BUSY               142       /* drive is busy - join */
#define MSG_JOIN_SUB_SAME_DRIVE         143       /* cannot join or subst a drive to dir */
#define MSG_DIRECT_IS_NOT_SUBDIR        144       /* directory is not subdirectory of root */
#define MSG_DIRECT_IS_NOT_EMPTY         145       /* directory is not empty  -join */
#define MSG_PATH_USED_SUBST_JOIN        146       /* path used in subst, join - join sub */
/*  147 not used */
#define MSG_PATH_BUSY                   148       /* path is busy - join */
#define MSG_SUB_ON_DRIVE_IS_JOIN        149       /* directory on drive is target of a st */
/* */
#define MSG_VOLUME_TOO_LONG             154
/* */
#define MSG_INVALID_ORDINAL             182       /* invalid ordinal */
#define MSG_INVALID_STARTING_CODESEG    188       /* invalid code seg */
/* */
#define MSG_INVALID_STACKSEG            189       /* invalid stack segment */
#define MSG_INVALID_MODULETYPE          190       /* invalid module type */
#define MSG_INVALID_EXE_SIGNATURE       191       /* Invalid signature */
#define MSG_EXE_MARKED_INVALID          192       /* Invalid exec file */
#define MSG_BAD_EXE_FORMAT              193       /* Bad or old exec file */
#define MSG_ITERATED_DATA_EXCEEDS_64K   194       /* iterated data exceeds 64k */
#define MSG_INVALID_MINALLOCSIZE        195       /* data segment has invalid size */
#define MSG_DYNLINK_FROM_INVALID_RING   196       /* invalid ring */
#define MSG_IOPL_NOT_ENABLED            197       /* IOPL not enabled */
#define MSG_INVALID_SEGDPL              198       /* Invalid privilege level */
#define MSG_AUTODATASEG_EXCEEDS_64K     199       /* Privilege level exceeds 64K */
/*  200 not used */
#define MSG_RELOC_CHAIN_XEEDS_SEGMENT   201       /* Ring must be movable */
#define MSG_INFLOOP_IN_RELOC_CHAIN      202       /* infinite loop */
#define MSG_ENVVAR_NOT_FOUND            203       /* environment variable not found */
#define MSG_SIGNAL_NOT_SENT             205       /* DOS signal not sent */
/* */
#define MSG_MR_CANT_FORMAT              317
#define MSG_MR_NOT_FOUND                318
#define MSG_MR_READ_ERROR               319
#define MSG_MR_IVCOUNT_ERROR            320       /*IvCount out of range */
#define MSG_MR_UN_PERFORM               321
/* */
#define MSG_DIS_ERROR                   355
#define MSG_NO_COUNTRY_SYS              396
#define MSG_OPEN_COUNTRY_SYS            397
#define MSG_COUNTRY_NO_TYPE             401
/* 900 - 999 reserved for IBM Far East */
/* 1000 not used */
#define MSG_BAD_PARM1                   1001      /* invalid parm */
#define MSG_BAD_PARM2                   1002      /* invalid parm with specified input */
#define MSG_BAD_SYNTAX                  1003      /* invalid syntax */
/* 1004 not used */
#define MSG_SWAP_INVALID_DRIVE          1470      /* Invalid drive %1 specified SWAPPATH */
#define MSG_SWAP_INVALID_PATH           1471      /* Invalid path %1 specified in SWAPPATH */
#define MSG_SWAP_CANNOT_CREATE          1472      /* Cannot create swap file %1 */
#define MSG_SWAP_DISABLED               1473      /* Segment swapping is disabled */
#define MSG_SWAP_CANT_INIT              1474      /* Cannot initialize swapper */
#define MSG_SWAP_NOT_READY              1500      /* diskette containing swap file not rdy */
#define MSG_SWAP_WRITE_PROTECT          1501      /* Diskette containing swap file wrpro */
#define MSG_SWAP_IN_ERROR               1502      /* I/O error on swap file */
#define MSG_SWAP_IO_ERROR               1502      /* I/O error on swap file */
#define MSG_SWAP_FILE_FULL              1503      /* Swap file is full */
#define MSG_SWAP_TABLE_FULL             1504      /* Swap control table full */
/* */
#define MSG_SYSINIT_INVAL_CMD           1195      /* Unrecognized command */
#define MSG_SYSINIT_INVAL_PARM          1196      /* Invalid parameter */
#define MSG_SYSINIT_MISSING_PARM        1197      /* Missing parameter */
/* 1198 - 1199 not used */
#define MSG_SYSINIT_DOS_FAIL            1200      /* Cannot create DOS mode */
/* 1201 - 1204 not used */
#define MSG_SYSINIT_DOS_MODIFIED        1205      /* DOS mode memory modified by DD */
#define MSG_SYSINIT_UFILE_NO_MEM        1206      /* Out of memory loading user program or DD */
/* 1207 not used */
#define MSG_SAD_INSERT_DUMP             1395      /* insert dump disk - rasmsg */
/* 1517 not used */
#define MSG_SYSINIT_SFILE_NOT_FND       1518      /* System file not found */
#define MSG_SYSINIT_SFILE_NO_MEM        1519      /* Out of memory loading system program or DD */
/* 1520 not used */
#define MSG_SYSINIT_TOO_MANY_PARMS      1521      /* Too many parms on line */
/* 1522 not used */
#define MSG_SYSINIT_MISSING_SYMB        1523      /* No equal or space */
/* 1708 - 1717 not used */
#define MSG_SYSINIT_UFILE_NOT_FND       1718      /* User file not found */
#define MSG_SYSINIT_UDRVR_INVAL         1719      /* User device driver invalid */
/* 1720 not used */
#define MSG_SYSINIT_BANNER              1721      /* Version banner message */
#define MSG_SYSINIT_CANT_LOAD_MOD       1722      /* Can't load module */
#define MSG_SYSINIT_EPT_MISSING         1723      /* Entry point missing */
#define MSG_SYSINIT_CANT_OPEN_CON       1724      /* Can't open con */
#define MSG_SYSINIT_WRONG_HANDLE        1725      /* wrong handle for standard input file */
#define MSG_SYSINIT_PRESS_ENTER         1726      /* Press enter to continue */
#define MSG_SYSINIT_CANT_GET_CACHE      1727      /* Can't allocate cache memory */
/* 1728 not used */
#define MSG_SYSINIT_VIO_CP              1729      /* VioSetCp failed */
#define MSG_SYSINIT_KBD_CP              1730      /* KbdSetCp failed */
/* 1731 - 1732 not used */
#define MSG_SYSINIT_SCFILE_INVAL        1733      /* System country file is bad */
/* 1734 not used */
#define MSG_SYSINIT_CP_ASSUME           1735      /* Assumed codepage */
/* 1736 not used */
#define MSG_SYSINIT_CP_FATAL            1737      /* Codepage switching disabled */
#define MSG_SYSINIT_NOT_INIT_NMI        1738      /* cannot initial NMI ALSO FOR MODE MGR */
#define MSG_ASYNC_INSTALL               1899      /* Com installed */
#define MSG_ASYNC_COM_DEVICE            1900      /* COM device driver */
/* 1901 - 1914 utilmid2 */
#define MSG_INTERNAL_ERROR              1915      /* Internal error in the Kernel */
#define MSG_USER_ERROR                  1916      /* user error */
/* 1917 - 1918 not used */
#define MSG_SYSINIT_UEXEC_FAIL          1919      /* User program won't execute */
/* 1920 - 1924 not used */
#define MSG_SYSINIT_SEXEC_FAIL          1925      /* System program won't execute */
#define MSG_GEN_PROT_FAULT              1926      /* General protect fault trap d */
#define MSG_CHANGE_INT_VECTOR           1927      /* real mode changed interrupt vector */
#define MSG_NOMEM_FOR_RELOAD            1928      /* no storage to reload code or segment */
#define MSG_STACK_OVERFLOW              1929      /* argument stack low */
#define MSG_TRAP0                       1930      /* divide error */
#define MSG_TRAP1                       1931      /* single step trap */
#define MSG_TRAP2                       1932      /* hardware memory error */
#define MSG_TRAP3                       1933      /* breakpoint instruction */
#define MSG_TRAP4                       1934      /* computation overflow */
#define MSG_TRAP5                       1935      /* index out of range */
#define MSG_TRAP6                       1936      /* incorrect instruction */
#define MSG_TRAP7                       1937      /* cannot process instruction */
#define MSG_TRAP8                       1938      /* double exception error */
#define MSG_TRAP9                       1939      /* math coprocessor */
#define MSG_TRAPA                       1940      /* task state segment */
#define MSG_TRAPB                       1941      /* segment not in memory */
#define MSG_TRAPC                       1942      /* memory beyond the stack segment */
#define MSG_TRAPD                       1943      /* bad segment value */
#define MSG_NMI                         1944      /* nonmaskable interrupt */
#define MSG_NMI_EXC1                    1945      /* error with memory system board */
#define MSG_NM12_EXC2                   1946      /* error memory cards */
#define MSG_NMI2_EXC3                   1947      /* timeout on dma */
#define MSG_NMI2_EXC4                   1948      /* timeout by watchdog timer */
/* 1949 not used */
#define MSG_NPXIEMSG                    1950      /* incorrect operation */
#define MSG_NPXDEMSG                    1951      /* denormalized operand */
#define MSG_NPXZEMSG                    1952      /* zero divide */
#define MSG_NPXOEMSG                    1953      /* overflow */
#define MSG_NPXUEMSG                    1954      /* underflow */
#define MSG_NPXPEMSG                    1955      /* precision */
#define MSG_NPXINSTEMSG                 1956      /* error occurred at address */
#define MSG_SYSINIT_BOOT_ERROR          2025      /* boot error */
#define MSG_SYSINIT_BIO_NOT_FD          2026      /* COMMAND.COM not found */
#define MSG_SYSINIT_INSER_DK            2027      /* Insert diskette */
#define MSG_SYSINIT_DOS_NOT_FD          2028      /* IBMDOS.COM not found */
#define MSG_SYSINIT_DOS_NOT_VAL         2029      /* IBMDOS.COM not valid */
#define MSG_SYSINIT_MORE_MEM            2030      /* need more memory */
/* 2031 - 2056 utilmid3 */
/* 2057 - 2063 not used */
#define MSG_SYSINIT_DOS_NO_MEM          2064      /* Out of memory starting DOS mode */
#define MSG_SYSINIT_SYS_STOPPED         2065      /* System is stopped */
#define MSG_SYSINIT_DOS_STOPPED         2066      /* DOS mode not started */
#define MSG_SYSINIT_SDRVR_INVAL         2067      /* System device driver invalid */
#define MSG_SYSINIT_MSG_LOST            2068      /* Messages lost */
#define MSG_SYSINIT_UCFILE_INVAL        2069      /* User country file is bad */
#define MSG_DEMAND_LOAD_FAILED          2070      /* the demand load has failed */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\doscalls.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*static char *SCCSID = "@(#)doscalls.hwc	10.3 87/05/27";*/
struct DateTime {
	unsigned char hour;
	unsigned char minutes;
	unsigned char seconds;
	unsigned char hundredths;
	unsigned char day;
	unsigned char month;
	unsigned year;
	int timezone;
	unsigned char day_of_week;
	};
struct FileFindBuf {
	unsigned create_date;
	unsigned create_time;
	unsigned access_date;
	unsigned access_time;
	unsigned write_date;
	unsigned write_time;
	unsigned long file_size;
	unsigned long falloc_size;
	unsigned attributes;
	unsigned char string_len;
	char file_name[13];
	};
struct FileStatus {
	unsigned create_date;
	unsigned create_time;
	unsigned access_date;
	unsigned access_time;
	unsigned write_date;
	unsigned write_time;
	unsigned long file_size;
	unsigned long falloc_size;
	unsigned attributes;
	};
struct FSAllocate {
	unsigned long filsys_id;
	unsigned long sec_per_unit;
	unsigned long num_units;
	unsigned long avail_units;
	unsigned bytes_sec;
	};
struct ProcIDsArea {
	unsigned procid_cpid;
	unsigned procid_ctid;
	unsigned procid_ppid;
	};
struct	ResultCodes {
	unsigned TermCode_PID ;
	unsigned ExitCode ;
	};
struct countrycode {
	unsigned country;
	unsigned codepage;
};
extern unsigned far pascal DOSCREATETHREAD (
	void (far *)(void),
	unsigned far *,
	unsigned char far * );
extern unsigned far pascal DOSRESUMETHREAD (
	unsigned );
extern unsigned far pascal DOSSUSPENDTHREAD (
	unsigned );
extern unsigned far pascal DOSCWAIT (
	unsigned,
	unsigned,
	struct ResultCodes far *,
	unsigned far *,
	unsigned );
extern void far pascal DOSENTERCRITSEC (void);
extern unsigned far pascal DOSEXECPGM (
	char far *,
	unsigned,
	unsigned,
	char far *,
	char far *,
	struct ResultCodes far *,
	char far * );
extern void far pascal DOSEXIT (
	unsigned,
	unsigned );
extern void far pascal DOSEXITCRITSEC (void);
extern unsigned far pascal DOSEXITLIST (
	unsigned,
	void (far *)(void) );
extern unsigned far pascal DOSGETPID (
	struct ProcIDsArea far *);
extern unsigned far pascal DOSGETPRTY (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal DOSSETPRTY (
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern void far pascal SET_INT24_VECTOR (
        unsigned );
extern unsigned far pascal DOSKILLPROCESS (
	unsigned,
	unsigned );
extern unsigned far pascal DOSHOLDSIGNAL (
	unsigned );
extern unsigned far pascal DOSFLAGPROCESS (
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSSETSIGHANDLER (
	void (far pascal *)(),
	unsigned long far *,
	unsigned far *,
	unsigned,
	unsigned );
extern unsigned far pascal DOSSENDSIGNAL (
	unsigned,
	unsigned);
extern unsigned far pascal DOSMAKEPIPE (
	unsigned far *,
	unsigned far *,
	unsigned );
extern unsigned far pascal DOSCLOSEQUEUE (
	unsigned ) ;
extern unsigned far pascal DOSCREATEQUEUE (
	unsigned far *,
	unsigned,
	char far * ) ;
extern unsigned far pascal DOSOPENQUEUE (
	unsigned far *,
	unsigned far *,
	char far * ) ;
extern unsigned far pascal DOSPEEKQUEUE (
	unsigned,
	unsigned long far *,
	unsigned far *,
	unsigned long far *,
	unsigned far *,
	unsigned char,
	unsigned char far *,
	unsigned long ) ;
extern unsigned far pascal DOSPURGEQUEUE (
	unsigned ) ;
extern unsigned far pascal DOSQUERYQUEUE (
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSREADQUEUE (
	unsigned,
	unsigned long far *,
	unsigned far *,
	unsigned long far *,
	unsigned,
	unsigned char,
	unsigned char far *,
	unsigned long ) ;
extern unsigned far pascal DOSWRITEQUEUE (
	unsigned,
	unsigned,
	unsigned,
	unsigned char far *,
	unsigned char );
extern unsigned far pascal DOSSEMCLEAR (
	unsigned long );
extern unsigned far pascal DOSSEMREQUEST (
	unsigned long,
	long );
extern unsigned far pascal DOSSEMSET (
	unsigned long );
extern unsigned far pascal DOSSEMSETWAIT (
	unsigned long,
	long );
extern unsigned far pascal DOSSEMWAIT (
	unsigned long,
	long );
extern unsigned far pascal DOSMUXSEMWAIT (
	unsigned far *,
	unsigned far *,
	long );
extern unsigned far pascal DOSCLOSESEM (
	unsigned long );
extern unsigned far pascal DOSCREATESEM (
	unsigned,
	unsigned long far *,
	char far * );
extern unsigned far pascal DOSOPENSEM (
	unsigned long far *,
	char far * );
extern unsigned far pascal DOSGETDATETIME (
	struct DateTime far * );
extern unsigned far pascal DOSSETDATETIME (
	struct DateTime far * );
extern unsigned far pascal DOSSLEEP (
	unsigned long );
extern unsigned far pascal DOSGETTIMERINT (
	unsigned far * );
extern unsigned far pascal DOSTIMERASYNC (
	unsigned long,
	unsigned long,
	unsigned far * );
extern unsigned far pascal DOSTIMERSTART (
	unsigned long,
	unsigned long,
	unsigned far * );
extern unsigned far pascal DOSTIMERSTOP (
	unsigned );
extern unsigned far pascal DOSALLOCSEG (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal DOSALLOCSHRSEG (
	unsigned,
	char far *,
	unsigned far * );
extern unsigned far pascal DOSGETSHRSEG (
	char far *,
	unsigned far * );
extern unsigned far pascal DOSGIVESEG (
	unsigned,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSGETSEG (
	unsigned );
extern unsigned far pascal DOSLOCKSEG (
	unsigned );
extern unsigned far pascal DOSUNLOCKSEG (
	unsigned );
extern unsigned far pascal DOSMEMAVAIL (
	unsigned long far * );
extern unsigned far pascal DOSREALLOCSEG (
	unsigned,
	unsigned );
extern unsigned far pascal DOSFREESEG (
	unsigned );
extern unsigned far pascal DOSALLOCHUGE (
	unsigned,
	unsigned,
	unsigned far *,
	unsigned,
	unsigned );
extern unsigned far pascal DOSGETHUGESHIFT (
	unsigned far *);
extern unsigned far pascal DOSREALLOCHUGE (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSCREATECSALIAS (
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSSUBALLOC (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal DOSSUBFREE (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSSUBSET (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSLOADMODULE (
	char far *,
	unsigned,
	char far *,
	unsigned far * );
extern unsigned far pascal DOSFREEMODULE (
	unsigned );
extern unsigned far pascal DOSGETPROCADDR (
	unsigned,
	char far *,
	unsigned long far * );
extern unsigned far pascal DOSGETMODHANDLE (
	char far *,
	unsigned far *);
extern unsigned far pascal DOSGETMODNAME (
	unsigned,
	unsigned,
	char far * );
extern unsigned far pascal DOSBEEP (
	unsigned,
	unsigned );
extern unsigned far pascal DOSCLIACCESS (void);
extern unsigned far pascal DOSDEVCONFIG (
	unsigned char far *,
	unsigned,
	unsigned );
extern unsigned far pascal DOSDEVIOCTL (
	char far *,
	char far *,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSIOACCESS (
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSPORTACCESS (
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal DOSSGNUM (
	unsigned far *);
extern unsigned far pascal DOSSGSWITCH (
	unsigned );
extern unsigned far pascal DOSSGSWITCHME (
	unsigned );
extern unsigned far pascal DOSMONOPEN (
	char far *,
	unsigned far * );
extern unsigned far pascal DOSMONCLOSE (
	unsigned );
extern unsigned far pascal DOSMONREG (
	unsigned,
	unsigned char far *,
	unsigned char far *,
	unsigned,
	unsigned );
extern unsigned far pascal DOSMONREAD (
	unsigned char far *,
	unsigned char,
	unsigned char far *,
	unsigned far * );
extern unsigned far pascal DOSMONWRITE (
	unsigned char far *,
	unsigned char far *,
	unsigned );
extern unsigned far pascal DOSBUFRESET (
	unsigned );
extern unsigned far pascal DOSCHDIR (
	char far *,
	unsigned long );
extern unsigned far pascal DOSCHGFILEPTR (
	unsigned,
	long,
	unsigned,
	unsigned long far * );
extern unsigned far pascal DOSCLOSE (
	unsigned );
extern unsigned far pascal DOSDELETE (
	char far *,
	unsigned long );
extern unsigned far pascal DOSDUPHANDLE (
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSFINDCLOSE (
	unsigned );
extern unsigned far pascal DOSFINDFIRST (
	char far *,
	unsigned far *,
	unsigned,
	struct FileFindBuf far *,
	unsigned,
	unsigned far *,
	unsigned long );
extern unsigned far pascal DOSFINDNEXT (
	unsigned,
	struct FileFindBuf far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSFILELOCKS (
	unsigned,
	long far *,
	long far * );
extern unsigned far pascal DOSGETINFOSEG (
	unsigned far *,
	unsigned far * );
extern unsigned far pascal DOSMKDIR (
	char far *,
	unsigned long );
extern unsigned far pascal DOSMOVE (
	char far *,
	char far *,
	unsigned long );
extern unsigned far pascal DOSNEWSIZE (
	unsigned,
	unsigned long );
extern unsigned far pascal DOSOPEN (
	char far *,
	unsigned far *,
	unsigned far *,
	unsigned long,
	unsigned,
	unsigned,
	unsigned,
	unsigned long );
extern unsigned far pascal DOSQCURDIR (
	unsigned,
	char far *,
	unsigned far * );
extern unsigned far pascal DOSQCURDISK (
	unsigned far *,
	unsigned long far * );
extern unsigned far pascal DOSQFHANDSTATE (
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSQFILEINFO (
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal DOSQFILEMODE (
	char far *,
	unsigned far *,
	unsigned long );
extern unsigned far pascal DOSQFSINFO (
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal DOSQHANDTYPE (
	unsigned,
	unsigned far *,
	unsigned far * );
extern unsigned far pascal DOSQVERIFY (
	unsigned far * );
extern unsigned far pascal DOSREAD (
	unsigned,
	char far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSREADASYNC (
	unsigned,
	unsigned long far *,
	unsigned far *,
	char far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSRMDIR (
	char far *,
	unsigned long );
extern unsigned far pascal DOSSELECTDISK (
	unsigned );
extern unsigned far pascal DOSSETFHANDSTATE (
	unsigned,
	unsigned);
extern unsigned far pascal DOSSETFSINFO (
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal DOSSETFILEINFO (
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal DOSSETFILEMODE (
	char far *,
	unsigned,
	unsigned long );
extern unsigned far pascal DOSSETMAXFH (
	unsigned );
extern unsigned far pascal DOSSETVERIFY (
	unsigned );
extern unsigned far pascal DOSWRITE (
	unsigned,
	char far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSWRITEASYNC (
	unsigned,
	unsigned long far *,
	unsigned far *,
	char far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSERROR (
	unsigned );
extern unsigned far pascal DOSSETVEC (
	unsigned,
	void (far *)(void),
	void (far * far *)(void) );
extern unsigned far pascal DOSGETMESSAGE (
	char far * far *,
	unsigned,
	char far *,
	unsigned,
	unsigned,
	char far *,
	unsigned far * );
extern unsigned far pascal DOSERRCLASS (
	unsigned,
	unsigned far *,
	unsigned far *,
	unsigned far * );
extern unsigned far pascal DOSINSMESSAGE (
	char far * far *,
	unsigned,
	char far *,
	unsigned,
	char far *,
	unsigned,
	unsigned far * );
extern unsigned far pascal DOSPUTMESSAGE (
	unsigned,
	unsigned,
	char far * );
extern unsigned far pascal DOSSYSTRACE (
	unsigned,
	unsigned,
	unsigned,
	char far * );
extern unsigned far pascal DOSGETENV (
	unsigned far *,
	unsigned far * );
extern unsigned far pascal DOSSCANENV (
     char far *,
     char far * far * );
extern unsigned far pascal DOSSEARCHPATH (
     unsigned,
     char far *,
     char far *,
     char far *,
     unsigned );
extern unsigned far pascal DOSGETVERSION (
	unsigned far * );
extern unsigned far pascal DOSGETMACHINEMODE (
	unsigned char far * );
extern unsigned far pascal DOSGETCTRYINFO (
	unsigned,
	struct countrycode far *,
	char far *,
	unsigned far * );
extern unsigned far pascal DOSGETDBCSEV (
	unsigned,
	struct countrycode far *,
	char far * );
extern unsigned far pascal DOSCASEMAP (
	unsigned,
	struct countrycode far *,
	char far * );
extern unsigned far pascal DOSGETCOLLATE (
	unsigned,
	struct countrycode far *,
	char far *,
	unsigned far *);
extern unsigned far pascal DOSGETCP (
	unsigned,
	unsigned far *,
	unsigned far *);
extern unsigned far pascal DOSSETCP (
	unsigned,
	unsigned);
extern unsigned far pascal DOSPHYSICALDISK (
	unsigned,
	char far *,
	unsigned,
	char far *,
	unsigned);
extern unsigned far pascal DOSSYSTEMSERVICE (
	unsigned,
	char far *,
	char far *);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
	unsigned int ax;
	unsigned int bx;
	unsigned int cx;
	unsigned int dx;
	unsigned int si;
	unsigned int di;
	unsigned int cflag;
	};


/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};


/* segment registers */

struct SREGS {
	unsigned int es;
	unsigned int cs;
	unsigned int ss;
	unsigned int ds;
	};

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
	int exterror;
	char class;
	char action;
	char locus;
	};

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
	char reserved[21];
	char attrib;
	unsigned wr_time;
	unsigned wr_date;
	long size;
	char name[13];
	};

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
	unsigned char day;		/* 1-31 */
	unsigned char month;		/* 1-12 */
	unsigned int year;		/* 1980-2099 */
	unsigned char dayofweek;	/* 0-6, 0=Sunday */
	};

struct dostime_t {
	unsigned char hour;	/* 0-23 */
	unsigned char minute;	/* 0-59 */
	unsigned char second;	/* 0-59 */
	unsigned char hsecond;	/* 0-99 */
	};

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE 	0	/* Ignore the error */
#define _HARDERR_RETRY		1	/* Retry the operation */
#define _HARDERR_ABORT		2	/* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL		3	/* Fail the system call in progress */
					/* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_VOLID	0x08	/* Volume ID file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))


/* external variable declarations */

extern unsigned int _near _cdecl _osversion;


/* function prototypes */

#ifndef _MT
int _cdecl bdos(int, unsigned int, unsigned int);
void _cdecl _chain_intr(void (_cdecl _interrupt _far *)());
void _cdecl _disable(void);
unsigned _cdecl _dos_allocmem(unsigned, unsigned *);
unsigned _cdecl _dos_close(int);
unsigned _cdecl _dos_creat(const char *, unsigned, int *);
unsigned _cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned _cdecl _dos_findfirst(const char *, unsigned, struct find_t *);
unsigned _cdecl _dos_findnext(struct find_t *);
unsigned _cdecl _dos_freemem(unsigned);
void _cdecl _dos_getdate(struct dosdate_t *);
void _cdecl _dos_getdrive(unsigned *);
unsigned _cdecl _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _cdecl _dos_getfileattr(const char *, unsigned *);
unsigned _cdecl _dos_getftime(int, unsigned *, unsigned *);
void _cdecl _dos_gettime(struct dostime_t *);
void (_cdecl _interrupt _far * _cdecl _dos_getvect(unsigned))();
void _cdecl _dos_keep(unsigned, unsigned);
unsigned _cdecl _dos_open(const char *, unsigned, int *);
unsigned _cdecl _dos_read(int, void _far *, unsigned, unsigned *);
unsigned _cdecl _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _cdecl _dos_setdate(struct dosdate_t *);
void _cdecl _dos_setdrive(unsigned, unsigned *);
unsigned _cdecl _dos_setfileattr(const char *, unsigned);
unsigned _cdecl _dos_setftime(int, unsigned, unsigned);
unsigned _cdecl _dos_settime(struct dostime_t *);
void _cdecl _dos_setvect(unsigned, void (_cdecl _interrupt _far *)());
unsigned _cdecl _dos_write(int, const void _far *, unsigned, unsigned *);
int _cdecl dosexterr(struct DOSERROR *);
void _cdecl _enable(void);
void _cdecl _harderr(void (_far *)());
void _cdecl _hardresume(int);
void _cdecl _hardretn(int);
int _cdecl intdos(union REGS *, union REGS *);
int _cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif /* _MT */

void _cdecl segread(struct SREGS *);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\decomp.h ===
/*******************************************************************
*****  Header for Decompression Library (condensed from API.H and RETCODES.H)
********************************************************************/

/*** API.H:  Extern procs for the decompression library. ***/

typedef int (far * PFNWFROMW)(int);

typedef  unsigned char  BYTE;
#define  BOOL  int
#undef TRUE
#define  TRUE  ~0
#undef LONG
typedef  long		LONG;
#define  FALSE  0
#ifndef NULL
#define  NULL   0
#endif
typedef  int            SHORT;
typedef  unsigned int   USHORT;
typedef  unsigned long  ULONG;
typedef  char		CHAR;
typedef  unsigned char	UCHAR;

#define  LCBNIL 	(-1L)
typedef  CHAR *         SZ;

extern BOOL FTerminateDecomp(void);

extern  SHORT   far  WReadHeaderInfo(int fhSrc);
extern  BOOL    far  FFreeHeaderInfo(void);   /* also in SUCOMP.LIB */
extern  LONG    far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead,
                           BYTE far * pfbBuf, LONG lcbBuf, PFNWFROMW pfn,
                           int cProgTicks, PFNWFROMW pfnYield);
extern  LONG    far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbCalculateDecompressedLength(int fhSrc,
                           BOOL fHeaderAlreadyRead);

  /* global variables for file header info before writing or after reading */
extern  SHORT   vwAlgType;
extern  LONG    vlcbSrcLength;
extern  BOOL    vfChecksum;
extern  USHORT  vusChecksum;
extern  USHORT  vcbArgs;
extern  BYTE *  vrgbArgs;
extern  CHAR    vszBaseName[9];
extern  CHAR    vszExtension[4];
extern  SZ      vszText;
extern  USHORT  vcbText;

/*** RETCODES.H:  Return Codes for compression module for Setup Toolkit. ***/

 
  /* error codes - quick check is anything less than rcNoError */
#define  rcNoError                 0     /* no errors */
#define  rcNoHeader              (-1)    /* no header (eg no magic value) */
#define  rcUnknownAlgType        (-2)    /* wAlgType doesn't match knowns */
#define  rcBadHeader             (-3)    /* header too short or bad value */
#define  rcFilenamesTooLong      (-4)    /* filenames bigger than 8.3 */

#define  rcReadError             (-5)    /* reading error with fhSrc */
#define  rcReadSeekError         (-6)    /* seeking error with fhSrc */

#define  rcWriteError            (-7)    /* writing error with fhDest */
#define  rcWriteSeekError        (-8)    /* seeking error with fhDest */
#define  rcDestPatchError        (-9)    /* patching error with fhDest */

#define  rcCompChecksumBad      (-10)    /* compressed checksums mismatch */
#define  rcDecompChecksumBad    (-11)    /* decompressed checksums mismatch */
#define  rcCompLengthBad        (-12)    /* compressed length mismatch */
#define  rcDecompLengthBad      (-13)    /* decompressed length mismatch */

#define  rcGenericCompError     (-14)    /* internal compression error */
#define  rcGenericDecompError   (-15)    /* internal decompression error */

#define  rcSplitSizeTooSmall    (-16)    /* split size too small for header */

#define  rcOutOfMemory          (-17)    /* unable to alloc a buffer */


  /* each code below here has a standard header */
#define  wAlgTypeNil             (-1)    /* no algorithm type (never found) */
#define  wAlgTypeZK1               2     /* Steve Zeck compression algorithm */
#define  wAlgTypeJJJ1              3     /* Jeff J. Johnson algorithm */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char _NEAR _CDECL _ctype[];

/* set bit masks for the possible character types */

#define _UPPER        0x1       /* upper case letter */
#define _LOWER        0x2       /* lower case letter */
#define _DIGIT        0x4       /* digit[0-9] */
#define _SPACE        0x8       /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT       0x10       /* punctuation character */
#define _CONTROL     0x20       /* control character */
#define _BLANK       0x40       /* space char */
#define _HEX         0x80       /* hexadecimal digit */

/* the character classification macro definitions */

#define isalpha(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER) )
#define isupper(c)      ( (_ctype+1)[c] & _UPPER )
#define islower(c)      ( (_ctype+1)[c] & _LOWER )
#define isdigit(c)      ( (_ctype+1)[c] & _DIGIT )
#define isxdigit(c)     ( (_ctype+1)[c] & _HEX )
#define isspace(c)      ( (_ctype+1)[c] & _SPACE )
#define ispunct(c)      ( (_ctype+1)[c] & _PUNCT )
#define isalnum(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(c)      ( (_ctype+1)[c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(c)      ( (_ctype+1)[c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(c)      ( (_ctype+1)[c] & _CONTROL )

#define toupper(c)      ( (islower(c)) ? _toupper(c) : (c) )
#define tolower(c)      ( (isupper(c)) ? _tolower(c) : (c) )

#define _tolower(c)     ( (c)-'A'+'a' )
#define _toupper(c)     ( (c)-'a'+'A' )

#define isascii(c)      ( (unsigned)(c) < 0x80 )
#define toascii(c)      ( (c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(c)      (isalpha(c) || ((c) == '_'))
#define iscsym(c)       (isalnum(c) || ((c) == '_'))

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\comsub.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*static char *SCCSID = "@(#)comsub.h	8.2 87/02/13";*/
/******************** START OF SPECIFICATIONS ************************/
/*								     */
/* SOURCE FILE NAME: COMSUB.H					     */
/*								     */
/* DESCRIPTIVE NAME: COMMON SUBROUTINE INCLUDE FILE		     */
/*								     */
/* FUNCTION:							     */
/*								     */
/*								     */
/* NOTES:							     */
/*								     */
/* ENTRY POINTS:  NONE						     */
/*								     */
/* EXTERNAL REFERENCE:	NONE					     */
/*								     */
/* RELEASE:							     */
/*								     */
/*    VERSION	 DATE		REASON				     */
/*								     */
/*     1.00    03/10/1986    initial version			     */
/*     1.01    03/11/1986    define external pointer to invalid      */
/*			     argument string (CORA's request)        */
/*     1.02    03/18/1986    external declaration of "computmsg"     */
/*			     parm 1 : char far * -> char far **      */
/*     1.03    03/24/1986    delete "comverflnm" related decralation */
/*			     change "int" to "unsigned"              */
/*     1.04    03/25/1986  - add function external declaration of    */
/*			     "comcheckdosver"                        */
/*			   - delete "far" declaration.               */
/*     2.00    04/15/1986    the first intigration version	     */
/*     2.01    05/21/1986  - add "extern rctomid()"                  */
/*     2.02    05/22/1986  - add DBCS common routines		     */
/*     2.03    06/17/1986  - add "com_toupper" and "com_tolower"     */
/*     2.04    06/18/1986  - comment out SCCSID tag		     */
/*     2.05    06/25/1986  - add filehandle enabling switch	     */
/*     2.06    08/07/1986  - add new routine "realopen"              */
/*     2.07    02/13/1987  - add "cm_trace_cmd_flg".                 */
/*********************************************************************/

/*************************************
 *				     *
 *  external function declaration    *
 *				     *
 *************************************/

extern unsigned comgetarg (
	unsigned *,	   /* number of arguments		    */
	char **,	   /* pointer array of original arguments   */
	char **,	   /* pointer of argument unit character    */
			   /* storage				    */
	unsigned,	   /* depth of new argument pointer array   */
	char *, 	   /* broken down argument character buffer */
	unsigned,	   /* size of argument character buffer     */
	char *, 	   /* current defualt drive name	    */
	char *);	   /* switching character		    */
/*
 * print a message and get a response
 */
extern unsigned computmsg (
	char **,	   /* table of variables  to insert	  */
	unsigned,	   /* number of variables to insert	  */
	unsigned,	   /* message id			  */
	char *, 	   /* message file name 		  */
	unsigned,	   /* output device type		  */
	unsigned,	   /* response type			  */
	char *, 	   /* response data area		  */
	unsigned);	   /* size of response data area	  */
/*
 *  verify correct DOS version
 */
extern unsigned comcheckdosver();

/*
 *  return code conversion to message id
 */
extern unsigned rctomid(
	unsigned);	   /* return code to converted to msg id */

/*
 *  open drive in real mode
 */
extern unsigned far pascal REALOPEN(
	char far *,	   /* pointer to drive name */
	unsigned far *,    /* pointer to drive handle */
	unsigned);	   /* open mode */

/*****************************************/
/*					 */
/*	   DBCS common subroutine	 */
/*					 */
/*****************************************/
/*
 *   search the first substring occurrence in a string
 */
extern unsigned char
*com_substr(
   unsigned char *,	      /* source string */
   unsigned char *);	      /* target string */

/*
 *   search the last charater occurrence in a string
 */
extern unsigned char
*com_strrchr(
   unsigned char *,	      /* source string */
   unsigned char );	     /* target string */

/*
 *   compare two strings with regard to case
 */
extern int
com_strcmpi(
  unsigned char *,	      /* source string	       */
  unsigned char *);	      /* string to be compared */

/*
 *   convert a string to uppercase
 */
extern unsigned char
*com_strupr(
   unsigned char *);	      /* string to be converted */

/*
 *   convert a string to lowercase
 */
extern unsigned char
*com_strlwr(
   unsigned char *);	      /* string to be converted */

/*
 *   search the first occurrence of a character in a string
 */
extern char *com_strchr(
   unsigned char *,	      /* a source string */
   unsigned char );	      /* a character to be searched */

/*
 *   convert character to uppercase
 */
extern int com_toupper(
   unsigned char );	      /* character to be converted to uppercase */

/*
 *   convert character to lowercase
 */
extern int com_tolower(
   unsigned char );	      /* character to be converted to lowercase */

/*************************************
 *				     *
 *   external variable declaration   *
 *				     *
 *************************************/
extern unsigned cm_invalid_parm_pointer;  /* points to first detected	 */
					  /* invalid argument string	 */

extern char cm_flhandle_enable_sw;    /* enable filehandle input for	     */
				      /* computmsg routine		     */
				      /*				     */
				      /* if this switch is on (non-zero),    */
				      /* filehandle can be set in devicetype.*/

extern char cm_trace_cmd_flg;	      /* ignore drive validity check.	     */
				      /*   if it set to 1, COMGETARG does    */
				      /*   not check drive validity.	     */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\dpb.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

 struct DPBType {
        char     drive ;        /* physical drive number                   */
        char     unit ;         /* unit within device                      */
        unsigned cbSector ;     /* bytes per sector                        */
        char     mask ;         /* sectors/alloc unit - 1                  */
        char     shift ;        /* bit to shift                            */
        unsigned secFAT ;       /* sector number of first FAT              */
        char     cFAT ;         /* count of FATs                           */
        unsigned cDirEnt ;      /* count of root directory entries         */
        unsigned secData ;      /* first data sector                       */
        unsigned cCluster ;     /* max number of clusters on drive         */
        unsigned csecFAT ;      /* sectors in each FAT                     */
        unsigned secDir ;       /* first sector of root dir                */
        long     pDevice ;      /* pointer to device header                */
        char     media ;        /* last media in drive                     */
        char     fFirst ;       /* TRUE => media check needed              */
        long     nextDPB ;      /* pointer to next dpb                     */
        unsigned clusFree ;     /* cluster number of last alloc            */
        unsigned FreeCnt ;      /* count of free clusters, -1 if unk       */
/*      char     SyncFlg ;      /* sync flags, (see below)                 */
        } ;

/*      Definitions of SyncFlg values from DPB.INC  */

#define DPB_ABUSY  1        /* some process is allocating clusters */
#define DPB_AWANT  2        /* some process waiting to allocate    */
#define DPB_FBUSY  4        /* some process is reading FAT         */
#define DPB_FWANT  8        /* some process waiting to read FAT    */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\internat.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*
	Data structure for international table
 */

struct InterTbl
{
	unsigned dateform ;	/* Date format				   */
	char	currsym[5] ;	/* Currency symbol as ASCIZ string	   */
	char	thousp[2] ;	/* Thousands separator as ASCIZ string	   */
	char	decsp[2] ;	/* Decimal   separator as ASCIZ string	   */
	char	datesp[2] ;	/* Date      separator as ASCIZ string	   */
	char	timesp[2] ;	/* Time      separator as ASCIZ string	   */
	unsigned char bits ;	/* Bit field				   */
	unsigned char numdig ;	/* Number of signifigant decimal digits    */
	unsigned char timeform ;/* Time format				   */
	unsigned long casecall ;/* Case mapping call			   */
	char	datasp[2] ;	/* Data list separator as ASCIZ string	   */
	int	reserv[5] ;	/* RESERVED				   */
} ;


#define DATEFORM_USA	0
#define DATEFORM_EUROPE 1
#define DATEFORM_JAPAN	2

#define BITS_CURRENCY	0x0001
#define BITS_NUMSPC	0x0002

#define TIMEFORM_12	0
#define TIMEFORM_24	1

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\jointype.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */


/*  types.h - basic types
 */

#define NULL 0
#define MAXPATHLEN 80		/* JOIN.C		*/
#define MAXARG 80		/* ERRTST.C		*/
#define CURDISK 0x19		/* ERRTST.C		*/
#define GETVERS 0x30		/* MAIN.C		*/
#define GETVARS 0x52		/* SYSVAR.C		*/
#define IOCTL9 0x4409		/* ERRTST.C		*/
#define SwitChr '/'		/* JOIN.C & SUBST.C 	*/
#define PathChr '\\'		/* SUBST.C		*/
#define	COLON	':'		/* ERRTST.C		*/
#define BACKSLASH '\\'		/* ERRTST.C		*/
#define ASCNULL	'\0'		/* ERRTST.C		*/


#define     IBMSPACE(c) ((c)==','||(c)==';'||(c)=='='||(c)==0x08||(c)==0x0a)
#define     IBMBREAK(c) ((c) == '/' || CMDSPACE((c)))
#define     CMDBREAK(c) IBMBREAK((c))
#define     CMDSPACE(c) (isspace((c)) || IBMSPACE((c)))

#define		SHIFT(c,v)	{c--; v++;}

/*  The following structure is a UNIX file block that retains information
 *  about a file being accessed via the level 1 I/O functions.
 */

struct UFB
{
	char	ufbflg ;		/* flags			   */
	char	ufbtyp ;		/* device type			   */
	int	ufbfh ;			/* file handle			   */
};

#define NUFBS 20			/* number of UFBs defined	   */

/*  UFB.ufbflg definitions	*/

#define UFB_OP 0x80			/* file is open			   */
#define UFB_RA 0x40			/* reading is allowed		   */
#define UFB_WA 0x20			/* writing is allowed		   */
#define UFB_NT 0x10			/* access file with no translation */
#define UFB_AP 8			/* append mode flag		   */

/*  UFB.ufbtyp definitions	*/

#define D_DISK 0
#define D_CON 1
#define D_PRN 2
#define D_AUX 3
#define D_NULL 4

#define TRUE    -1
#define FALSE   0

#define SETFLAG(l,f)    ((l) |= (f))
#define TESTFLAG(v,f)   (((v)&(f))!=0)
#define RSETFLAG(l,f)   ((l) &= ~(f))

#define LOW(w)          ((w)&0xFF)
#define HIGH(w)         LOW((w)>>8)
#define WORD(h,l)       ((LOW((h))<<8)|LOW((l)))

/* buffer description for findfirst and findnext */

struct findType {
    char reserved[21];                  /* reserved for start up */
    char attr;                          /* attribute found */
    unsigned int time;                  /* time of last modify */
    unsigned int date;                  /* date of last modify */
    long length;                        /* file size */
    char name[13];                      /* asciz file name */
};

/* attributes */
#define A_RO    1                       /* read only */
#define A_H     2                       /* hidden */
#define A_S     4                       /* system */
#define A_V     8                       /* volume id */
#define A_D     16                      /* directory */
#define A_A     32                      /* archive */

#define A_MOD   (A_RO+A_H+A_S+A_A)      /* changeable attributes */

#define HASATTR(a,v)    TESTFLAG(a,v)   /* true if a has attribute v */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\msgret.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*  */
/*----------------------------------------------------------------------+
|									|
| This file contains the structures and defines that are needed to use	|
| the parser from a C program.						|
|									|
|									|
| Date: 	6-19-87 						|
|									|
+----------------------------------------------------------------------*/

/* Standard reserved DOS handles					     */

#define stdin		0x00   /*;AN000; Standard Input device handle	     */
#define stdout		0x01   /*;AN000; Standard Output device handle	     */
#define stderr		0x02   /*;AN000; Standard Error Output device handle */
#define stdaux		0x03   /*;AN000; Standard Auxiliary device handle    */
#define stdprn		0x04   /*;AN000; Standard Printer device handle      */

#define utility_msg_class 0xff /*;AN000; Utility message type		     */


/* Sublist Flag Values						       */

/* Alignment Indicator						       */
#define sf_left 	0x00	  /*;AN000; left align		       */
#define sf_right	0x80	  /*;AN000; right align 	       */

/* Field Type							       */
#define sf_char 	0x00	  /*;AN000; character		       */
#define sf_unsbin2d	0x01	  /*;AN000; unsigned binary to decimal */
#define sf_sbin 	0x02	  /*;AN000; signed binary to decimal   */
#define sf_unsbin2h	0x03	  /*;AN000; unsigned binary to hex     */
#define sf_date 	0x04	  /*;AN000; date		       */
#define sf_time12	0x05	  /*;AN000; time 12-hour	       */
#define sf_time24	0x06	  /*;AN000; time 24-hour	       */


/* Data Variable Size						       */

#define sf_ch		0x00	  /*;AN000; single character	       */
#define sf_asciiz	0x10	  /*;AN000; asciiz string	       */
#define sf_word 	0x20	  /*;AN000; word		       */
#define sf_dword	0x30	  /*;AN000; double word 	       */
#define sf_word 	0x20	  /*;AN000; word		       */

#define sf_mdy2 	0x20	  /*;AN000; month,day,year (2 digits)  */
#define sf_mdy4 	0x30	  /*;AN000; month,day,year (4 digits)  */

#define sf_hhmm 	0x00	  /*;AN000; hh:mm		       */
#define sf_hhmmss	0x10	  /*;AN000; hh:mm:ss		       */
#define sf_hhmmsshh	0x20	  /*;AN000; hh:mm:ss:hh 	       */


struct m_sublist		    /*;AN000;				 */
       {			    /*;AN000;				 */
       BYTE   sub_size; 	    /*;AN000;				 */
       BYTE   sub_res;		    /*;AN000;				 */
       WORD   sub_value;	    /*;AN000;				 */
       WORD   sub_value_seg;	    /*;AN000;				 */
       BYTE   sub_id;		    /*;AN000;				 */
       BYTE   sub_flags;	    /*;AN000;				 */
       BYTE   sub_max_width;	    /*;AN000;				 */
       BYTE   sub_min_width;	    /*;AN000;				 */
       BYTE   sub_pad_char;	    /*;AN000;				 */
       };			    /*;AN000;				 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\error.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*static char *SCCSID = "@(#)error.h    7.11 86/09/29";*/
/* XENIX calls all return error codes through AX.  If an error occurred then */
/* the carry bit will be set and the error code is in AX.  If no error occurred */
/* then the carry bit is reset and AX contains returned info. */
/* */
/* Since the set of error codes is being extended as we extend the operating */
/* system, we have provided a means for applications to ask the system for a */
/* recommended course of action when they receive an error. */
/* */
/* The GetExtendedError system call returns a universal error, an error */
/* location and a recommended course of action. The universal error code is */
/* a symptom of the error REGARDLESS of the context in which GetExtendedError */
/* is issued. */
/* */

/* */
/* These are the 2.0 error codes */
/* */
#define NO_ERROR			0
#define ERROR_INVALID_FUNCTION		1
#define ERROR_FILE_NOT_FOUND		2
#define ERROR_PATH_NOT_FOUND		3
#define ERROR_TOO_MANY_OPEN_FILES	4
#define ERROR_ACCESS_DENIED		5
#define ERROR_INVALID_HANDLE		6
#define ERROR_ARENA_TRASHED		7
#define ERROR_NOT_ENOUGH_MEMORY 	8
#define ERROR_INVALID_BLOCK		9
#define ERROR_BAD_ENVIRONMENT		10
#define ERROR_BAD_FORMAT		11
#define ERROR_INVALID_ACCESS		12
#define ERROR_INVALID_DATA		13
/***** reserved 		EQU	14	; ***** */
#define ERROR_INVALID_DRIVE		15
#define ERROR_CURRENT_DIRECTORY 	16
#define ERROR_NOT_SAME_DEVICE		17
#define ERROR_NO_MORE_FILES		18
/* */
/* These are the universal int 24 mappings for the old INT 24 set of errors */
/* */
#define ERROR_WRITE_PROTECT		19
#define ERROR_BAD_UNIT			20
#define ERROR_NOT_READY 		21
#define ERROR_BAD_COMMAND		22
#define ERROR_CRC			23
#define ERROR_BAD_LENGTH		24
#define ERROR_SEEK			25
#define ERROR_NOT_DOS_DISK		26
#define ERROR_SECTOR_NOT_FOUND		27
#define ERROR_OUT_OF_PAPER		28
#define ERROR_WRITE_FAULT		29
#define ERROR_READ_FAULT		30
#define ERROR_GEN_FAILURE		31
/* */
/* These are the new 3.0 error codes reported through INT 24 */
/* */
#define ERROR_SHARING_VIOLATION 	32
#define ERROR_LOCK_VIOLATION		33
#define ERROR_WRONG_DISK		34
#define ERROR_FCB_UNAVAILABLE		35
#define ERROR_SHARING_BUFFER_EXCEEDED	36
/* */
/* New OEM network-related errors are 50-79 */
/* */
#define ERROR_NOT_SUPPORTED		50
/* */
/* End of INT 24 reportable errors */
/* */
#define ERROR_FILE_EXISTS		80
#define ERROR_DUP_FCB			81	  /* ***** */
#define ERROR_CANNOT_MAKE		82
#define ERROR_FAIL_I24			83
/* */
/* New 3.0 network related error codes */
/* */
#define ERROR_OUT_OF_STRUCTURES 	84
#define ERROR_ALREADY_ASSIGNED		85
#define ERROR_INVALID_PASSWORD		86
#define ERROR_INVALID_PARAMETER 	87
#define ERROR_NET_WRITE_FAULT		88
/* */
/* New error codes for 4.0 */
/* */
#define ERROR_NO_PROC_SLOTS		89	  /* no process slots available */
#define ERROR_NOT_FROZEN		90
#define ERR_TSTOVFL			91	  /* timer service table overflow */
#define ERR_TSTDUP			92	  /* timer service table duplicate */
#define ERROR_NO_ITEMS			93	  /* There were no items to operate upon */
#define ERROR_INTERRUPT 		95	  /* interrupted system call */

#define ERROR_TOO_MANY_SEMAPHORES	100
#define ERROR_EXCL_SEM_ALREADY_OWNED	101
#define ERROR_SEM_IS_SET		102
#define ERROR_TOO_MANY_SEM_REQUESTS	103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104

#define ERROR_SEM_OWNER_DIED		105	  /* waitsem found owner died */
#define ERROR_SEM_USER_LIMIT		106	  /* too many procs have this sem */
#define ERROR_DISK_CHANGE		107	  /* insert disk b into drive a */
#define ERROR_DRIVE_LOCKED		108	  /* drive locked by another process */
#define ERROR_BROKEN_PIPE		109	  /* write on pipe with no reader */
/* */
/* New error codes for 5.0 */
/* */
#define ERROR_OPEN_FAILED		110	  /* open/created failed due to */
						  /* explicit fail command */
#define ERROR_BUFFER_OVERFLOW		111	  /* buffer passed to system call */
						  /* is too small to hold return */
						  /* data. */
#define ERROR_DISK_FULL 		112	  /* not enough space on the disk */
						  /* (DOSNEWSIZE/w_NewSize) */
#define ERROR_NO_MORE_SEARCH_HANDLES	113	  /* can't allocate another search */
						  /* structure and handle. */
						  /* (DOSFINDFIRST/w_FindFirst) */
#define ERROR_INVALID_TARGET_HANDLE	114	  /* Target handle in DOSDUPHANDLE */
						  /* is invalid */
#define ERROR_PROTECTION_VIOLATION	115	  /* Bad user virtual address */
#define ERROR_VIOKBD_REQUEST		116
#define ERROR_INVALID_CATEGORY		117	  /* Category for DEVIOCTL in not */
						  /* defined */
#define ERROR_INVALID_VERIFY_SWITCH	118	  /* invalid value passed for */
						  /* verify flag */
#define ERROR_BAD_DRIVER_LEVEL		119	  /* DosDevIOCTL looks for a level */
						  /* four driver.	If the driver */
						  /* is not level four we return */
						  /* this code */
#define ERROR_CALL_NOT_IMPLEMENTED	120	  /* returned from stub api calls. */
						  /* This call will disappear when */
						  /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT		121	  /* Time out happened from the */
						  /* semaphore api functions. */
#define ERROR_INSUFFICIENT_BUFFER	122	  /* Some call require the  */
					  /* application to pass in a buffer */
					  /* filled with data.	This error is */
					  /* returned if the data buffer is too */
					  /* small.  For example: DosSetFileInfo */
					  /* requires 4 bytes of data.	If a */
					  /* two byte buffer is passed in then */
					  /* this error is returned.   */
					  /* error_buffer_overflow is used when */
					  /* the output buffer in not big enough. */
#define ERROR_INVALID_NAME		123	  /* illegal character or malformed */
						  /* file system name */
#define ERROR_INVALID_LEVEL		124	  /* unimplemented level for info */
						  /* retrieval or setting */
#define ERROR_NO_VOLUME_LABEL		125	  /* no volume label found with */
						  /* DosQFSInfo command */
#define ERROR_MOD_NOT_FOUND		126	  /* w_getprocaddr,w_getmodhandle */
#define ERROR_PROC_NOT_FOUND		127	  /* w_getprocaddr */

#define ERROR_WAIT_NO_CHILDREN		128	  /* CWait finds to children */

#define ERROR_CHILD_NOT_COMPLETE	129	  /* CWait children not dead yet */

#define ERROR_DIRECT_ACCESS_HANDLE	130	  /* handle operation is invalid */
						  /* for direct disk access */
						  /* handles */
#define ERROR_NEGATIVE_SEEK		131	  /* application tried to seek	*/
						  /* with negitive offset */
#define ERROR_SEEK_ON_DEVICE		132	  /* application tried to seek */
						  /* on device or pipe */
/* */
/* The following are errors generated by the join and subst workers */
/* */
#define ERROR_IS_JOIN_TARGET		133
#define ERROR_IS_JOINED 		134
#define ERROR_IS_SUBSTED		135
#define ERROR_NOT_JOINED		136
#define ERROR_NOT_SUBSTED		137
#define ERROR_JOIN_TO_JOIN		138
#define ERROR_SUBST_TO_SUBST		139
#define ERROR_JOIN_TO_SUBST		140
#define ERROR_SUBST_TO_JOIN		141
#define ERROR_BUSY_DRIVE		142
#define ERROR_SAME_DRIVE		143
#define ERROR_DIR_NOT_ROOT		144
#define ERROR_DIR_NOT_EMPTY		145
#define ERROR_IS_SUBST_PATH		146
#define ERROR_IS_JOIN_PATH		147
#define ERROR_PATH_BUSY 		148
#define ERROR_IS_SUBST_TARGET		149
#define ERROR_SYSTEM_TRACE		150	/* system trace error */
#define ERROR_INVALID_EVENT_COUNT	151	/* DosMuxSemWait errors */
#define ERROR_TOO_MANY_MUXWAITERS	152
#define ERROR_INVALID_LIST_FORMAT	153
#define ERROR_LABEL_TOO_LONG		154
#define ERROR_TOO_MANY_TCBS		155
#define ERROR_SIGNAL_REFUSED		156
#define ERROR_DISCARDED 		157
#define ERROR_NOT_LOCKED		158
#define ERROR_BAD_THREADID_ADDR 	159
#define ERROR_BAD_ARGUMENTS		160
#define ERROR_BAD_PATHNAME		161
#define ERROR_SIGNAL_PENDING		162
#define ERROR_UNCERTAIN_MEDIA		163
#define ERROR_MAX_THRDS_REACHED 	164

#define ERROR_INVALID_SEGMENT_NUMBER	180
#define ERROR_INVALID_CALLGATE		181
#define ERROR_INVALID_ORDINAL		182
#define ERROR_ALREADY_EXISTS		183
#define ERROR_NO_CHILD_PROCESS		184
#define ERROR_CHILD_ALIVE_NOWAIT	185
#define ERROR_INVALID_FLAG_NUMBER	186
#define ERROR_SEM_NOT_FOUND		187

/*	following error codes have added  to make the loader error
	messages distinct
*/

#define ERROR_EXCEEDED_SYS_STACKLIMIT		188	/* wrw! */
#define ERROR_INVALID_STARTING_CODESEG		189
#define ERROR_INVALID_STACKSEG			190
#define ERROR_INVALID_MODULETYPE		191
#define ERROR_INVALID_EXE_SIGNATURE		192
#define ERROR_EXE_MARKED_INVALID		193
#define ERROR_BAD_EXE_FORMAT			194
#define ERROR_ITERATED_DATA_EXCEEDS_64k 	195
#define ERROR_INVALID_MINALLOCSIZE		196
#define ERROR_DYNLINK_FROM_INVALID_RING 	197
#define ERROR_IOPL_NOT_ENABLED			198
#define ERROR_INVALID_SEGDPL			199
#define ERROR_AUTODATASEG_EXCEEDS_64k		200
#define ERROR_RING2SEGS_MUST_BE_MOVABLE 	201	/* wrw! */
#define ERR_RELOCSRC_CHAIN_OVER_SEGLIM		202	/* wrw! */

#define ERROR_USER_DEFINED_BASE 	0xF000

#define ERROR_I24_WRITE_PROTECT 	0
#define ERROR_I24_BAD_UNIT		1
#define ERROR_I24_NOT_READY		2
#define ERROR_I24_BAD_COMMAND		3
#define ERROR_I24_CRC			4
#define ERROR_I24_BAD_LENGTH		5
#define ERROR_I24_SEEK			6
#define ERROR_I24_NOT_DOS_DISK		7
#define ERROR_I24_SECTOR_NOT_FOUND	8
#define ERROR_I24_OUT_OF_PAPER		9
#define ERROR_I24_WRITE_FAULT		0x0A
#define ERROR_I24_READ_FAULT		0x0B
#define ERROR_I24_GEN_FAILURE		0x0C
#define ERROR_I24_DISK_CHANGE		0x0D
#define ERROR_I24_WRONG_DISK		0x0F
#define ERROR_I24_UNCERTAIN_MEDIA	0x10
#define ERROR_I24_CHAR_CALL_INTERRUPTED 0x11

#define ALLOWED_FAIL			0x0001
#define ALLOWED_ABORT			0x0002
#define ALLOWED_RETRY			0x0004
#define ALLOWED_IGNORE			0x0008

#define I24_OPERATION			0x1
#define I24_AREA			0x6
							  /* 01 if FAT */
							  /* 10 if root DIR */
							  /* 11 if DATA */
#define I24_CLASS			0x80


/* Values for error CLASS */

#define ERRCLASS_OUTRES 		1	  /* Out of Resource */
#define ERRCLASS_TEMPSIT		2	  /* Temporary Situation */
#define ERRCLASS_AUTH			3	  /* Permission problem */
#define ERRCLASS_INTRN			4	  /* Internal System Error */
#define ERRCLASS_HRDFAIL		5	  /* Hardware Failure */
#define ERRCLASS_SYSFAIL		6	  /* System Failure */
#define ERRCLASS_APPERR 		7	  /* Application Error */
#define ERRCLASS_NOTFND 		8	  /* Not Found */
#define ERRCLASS_BADFMT 		9	  /* Bad Format */
#define ERRCLASS_LOCKED 		10	  /* Locked */
#define ERRCLASS_MEDIA			11	  /* Media Failure */
#define ERRCLASS_ALREADY		12	  /* Collision with Existing Item */
#define ERRCLASS_UNK			13	  /* Unknown/other */
#define ERRCLASS_CANT			14
#define ERRCLASS_TIME			15

/* Values for error ACTION */

#define ERRACT_RETRY			1	  /* Retry */
#define ERRACT_DLYRET			2	  /* Delay Retry, retry after pause */
#define ERRACT_USER			3	  /* Ask user to regive info */
#define ERRACT_ABORT			4	  /* abort with clean up */
#define ERRACT_PANIC			5	  /* abort immediately */
#define ERRACT_IGNORE			6	  /* ignore */
#define ERRACT_INTRET			7	  /* Retry after User Intervention */

/* Values for error LOCUS */

#define ERRLOC_UNK			1	  /* No appropriate value */
#define ERRLOC_DISK			2	  /* Random Access Mass Storage */
#define ERRLOC_NET			3	  /* Network */
#define ERRLOC_SERDEV			4	  /* Serial Device */
#define ERRLOC_MEM			5	  /* Memory */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
*******************************************************************************/

#define O_RDONLY    0x0000  /* open for reading only */
#define O_WRONLY    0x0001  /* open for writing only */
#define O_RDWR      0x0002  /* open for reading and writing */
#define O_APPEND    0x0008  /* writes done at eof */

#define O_CREAT     0x0100  /* create and open file */
#define O_TRUNC     0x0200  /* open and truncate */
#define O_EXCL      0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT      0x4000  /* file mode is text (translated) */
#define O_BINARY    0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW   O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT 0x0080      /* child process doesn't inherit file */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
*******************************************************************************/


#define _HEAPEMPTY      -1
#define _HEAPOK         -2
#define _HEAPBADBEGIN   -3
#define _HEAPBADNODE    -4
#define _HEAPEND        -5
#define _HEAPBADPTR     -6
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#if (!defined(NO_EXT_KEYS))

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

#else   /* NO_EXT_KEYS */
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

#ifndef _HEAPINFO_DEFINED

typedef struct _heapinfo {
    int * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;

#define _HEAPINFO_DEFINED
#endif

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif  /* NO_EXT_KEYS */


#if (defined(M_I86SM) || defined(M_I86MM))
#define _heapchk  _nheapchk
#define _heapset  _nheapset
#define _heapwalk _nheapwalk
#endif
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define _heapchk  _fheapchk
#define _heapset  _fheapset
#define _heapwalk _fheapwalk
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* external variable declarations */
extern unsigned int _NEAR _CDECL _amblksiz;

/* function prototypes */

void * _CDECL alloca(size_t);
void * _CDECL calloc(size_t, size_t);
void * _CDECL _expand(void *, size_t);
int _CDECL _fheapchk(void);
int _CDECL _fheapset(unsigned int);
unsigned int _CDECL _freect(size_t);
void _CDECL free(void *);
void * _CDECL malloc(size_t);
size_t _CDECL _memavl(void);
size_t _CDECL _memmax(void);
size_t _CDECL _msize(void *);
int _CDECL _nheapchk(void);
int _CDECL _nheapset(unsigned int);
void * _CDECL realloc(void *, size_t);
void * _CDECL sbrk(int);
size_t _CDECL stackavail(void);


#ifndef NO_EXT_KEYS /* extensions enabled */

void cdecl _ffree(void far *);
void far * cdecl _fmalloc(size_t);
size_t cdecl _fmsize(void far *);
#ifndef _QC
void huge * cdecl halloc(long, size_t);
void cdecl hfree(void huge *);
#endif
void cdecl _nfree(void near *);
void near * cdecl _nmalloc(size_t);
size_t cdecl _nmsize(void near *);
int cdecl _nheapwalk(struct _heapinfo *);
int cdecl _fheapwalk(struct _heapinfo *);

#else
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

int _nheapwalk(struct _heapinfo *);
int _fheapwalk(struct _heapinfo *);

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif /* NO_EXT_KEYS */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* buffered I/O macros */

#define  BUFSIZ  512
#define  _NFILE  20
#define  EOF     (-1)

#ifndef _FILE_DEFINED
#define  FILE    struct _iobuf
#define _FILE_DEFINED
#endif

/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *      + 1 (in case P_tmpdir does not end in "\\")
 *      + 6 (for the temp number string)
 *      + 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define  SYS_OPEN 20
#define  TMP_MAX  32767


/* define NULL pointer value */

#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#endif


/* define file control block */

#ifndef _IOB_DEFINED
extern FILE {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    } _NEAR _CDECL _iob[];
#define _IOB_DEFINED
#endif

#define  fpos_t  long   /* file position variable */

#define  stdin  (&_iob[0])
#define  stdout (&_iob[1])
#define  stderr (&_iob[2])
#define  stdaux (&_iob[3])
#define  stdprn (&_iob[4])

#define  _IOREAD    0x01
#define  _IOWRT     0x02

#define  _IOFBF     0x0
#define  _IOLBF     0x40
#define  _IONBF     0x04

#define  _IOMYBUF   0x08
#define  _IOEOF     0x10
#define  _IOERR     0x20
#define  _IOSTRG    0x40
#define  _IORW      0x80

#define getc(f)         (--(f)->_cnt >= 0 ? 0xff & *(f)->_ptr++ : _filbuf(f))
#define putc(c,f)       (--(f)->_cnt >= 0 ? 0xff & (*(f)->_ptr++ = (char)(c)) \
                        :  _flsbuf((c),(f)))
#define getchar()       getc(stdin)
#define putchar(c)      putc((c),stdout)

#define feof(f)         ((f)->_flag & _IOEOF)
#define ferror(f)       ((f)->_flag & _IOERR)
#define fileno(f)       ((f)->_file)


/* function prototypes */

int _CDECL _filbuf(FILE *);
int _CDECL _flsbuf(int, FILE *);
void _CDECL clearerr(FILE *);
int _CDECL fclose(FILE *);
int _CDECL fcloseall(void);
FILE * _CDECL fdopen(int, char *);
int _CDECL fflush(FILE *);
int _CDECL fgetc(FILE *);
int _CDECL fgetchar(void);
int _CDECL fgetpos(FILE *, fpos_t *);
char * _CDECL fgets(char *, int, FILE *);
int _CDECL flushall(void);
FILE * _CDECL fopen(const char *, const char *);
int _CDECL fprintf(FILE *, const char *, ...);
int _CDECL fputc(int, FILE *);
int _CDECL fputchar(int);
int _CDECL fputs(const char *, FILE *);
size_t _CDECL fread(void *, size_t, size_t, FILE *);
FILE * _CDECL freopen(const char *, const char *, FILE *);
int _CDECL fscanf(FILE *, const char *, ...);
int _CDECL fsetpos(FILE *, const fpos_t *);
int _CDECL fseek(FILE *, long, int);
long _CDECL ftell(FILE *);
size_t _CDECL fwrite(const void *, size_t, size_t, FILE *);
char * _CDECL gets(char *);
int _CDECL getw(FILE *);
void _CDECL perror(const char *);
int _CDECL printf(const char *, ...);
int _CDECL puts(const char *);
int _CDECL putw(int, FILE *);
int _CDECL remove(const char *);
int _CDECL rename(const char *, const char *);
void _CDECL rewind(FILE *);
int _CDECL rmtmp(void);
int _CDECL scanf(const char *, ...);
void _CDECL setbuf(FILE *, char *);
int _CDECL setvbuf(FILE *, char *, int, size_t);
int _CDECL sprintf(char *, const char *, ...);
int _CDECL sscanf(const char *, const char *, ...);
char * _CDECL tempnam(char *, char *);
FILE * _CDECL tmpfile(void);
char * _CDECL tmpnam(char *);
int _CDECL ungetc(int, FILE *);
int _CDECL unlink(const char *);
int _CDECL vfprintf(FILE *, const char *, va_list);
int _CDECL vprintf(const char *, va_list);
int _CDECL vsprintf(char *, const char *, va_list);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\sysvar.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

struct sysVarsType
{
        long    pDPB ;          /* pointer to DPB chain                    */
        long    pSFT ;          /* pointer to System File Table            */
        long    pClock ;        /* pointer to clock device                 */
        long    pCon ;          /* pointer to CON device                   */
        unsigned maxSec ;       /* size of largest physical sector         */
        long    pBuf ;          /* pointer to buffer cache                 */
        long    pCDS ;          /* pointer to Current Dirs                 */
        long    pFCBSFT ;       /* pointer to FCB sftable                  */
        unsigned cKeep ;        /* number of un-recyclable FCBs            */
        char    cDrv ;          /* maximum number of physical drives       */
        char    cCDS ;          /* number of Current Dirs                  */
#ifdef DOS4
        long    pDEVHLP ;       /* ptr DOS DevHlp routine                  */
#endif
        long    pDEV ;          /* pointer to device list                  */
        unsigned attrNUL ;      /* attributes of NUL device                */
        unsigned stratNUL ;     /* strategy entry point of NUL dev         */
        unsigned intNUL ;       /* interrupt entry point of NUL dev        */
        char    namNUL[8] ;     /* name of NUL device                      */
        char    fSplice ;       /* TRUE => splices are in effect           */
        unsigned ibmdos_size ;  /* ;AN000; size in paragraphs              */
        long    ifs_doscall ;   /* ;AN000; IFS serv routine entry          */
        long    ifs ;           /* ;AN000; IFS header chain                */
        unsigned buffers ;      /* ;AN000; BUFFERS= values (m,n)           */
        char    boot_drive ;    /* ;AN000; boot drive A=1 B=2...           */
        char    dwmove ;        /* ;AN000; 1 if 386 machine                */
} ;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\types.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*  types.h - basic types
 */

#define NULL 0
#define MAXPATHLEN 80		/* JOIN.C		*/
#define MAXARG 80		/* ERRTST.C		*/
#define CURDISK 0x19		/* ERRTST.C		*/
#define GETVERS 0x30		/* MAIN.C		*/
#define GETVARS 0x52		/* SYSVAR.C		*/
#define IOCTL9 0x4409		/* ERRTST.C		*/
#define SwitChr '/'		/* JOIN.C & SUBST.C 	*/
#define PathChr '\\'		/* SUBST.C		*/
#define	COLON	':'		/* ERRTST.C		*/
#define BACKSLASH '\\'		/* ERRTST.C		*/
#define ASCNULL	'\0'		/* ERRTST.C		*/


#define     IBMSPACE(c) ((c)==','||(c)==';'||(c)=='='||(c)==0x08||(c)==0x0a)
#define     IBMBREAK(c) ((c) == '/' || CMDSPACE((c)))
#define     CMDBREAK(c) IBMBREAK((c))
#define     CMDSPACE(c) (isspace((c)) || IBMSPACE((c)))

#define		SHIFT(c,v)	{c--; v++;}

/*  The following structure is a UNIX file block that retains information
 *  about a file being accessed via the level 1 I/O functions.
 */

struct UFB
{
	char	ufbflg ;		/* flags			   */
	char	ufbtyp ;		/* device type			   */
	int	ufbfh ;			/* file handle			   */
};

#define NUFBS 20			/* number of UFBs defined	   */

/*  UFB.ufbflg definitions	*/

#define UFB_OP 0x80			/* file is open			   */
#define UFB_RA 0x40			/* reading is allowed		   */
#define UFB_WA 0x20			/* writing is allowed		   */
#define UFB_NT 0x10			/* access file with no translation */
#define UFB_AP 8			/* append mode flag		   */

/*  UFB.ufbtyp definitions	*/

#define D_DISK 0
#define D_CON 1
#define D_PRN 2
#define D_AUX 3
#define D_NULL 4

#define TRUE    -1
#define FALSE   0

#define SETFLAG(l,f)    ((l) |= (f))
#define TESTFLAG(v,f)   (((v)&(f))!=0)
#define RSETFLAG(l,f)   ((l) &= ~(f))

#define LOW(w)          ((w)&0xFF)
#define HIGH(w)         LOW((w)>>8)
#define WORD(h,l)       ((LOW((h))<<8)|LOW((l)))

/* buffer description for findfirst and findnext */

struct findType {
    char reserved[21];                  /* reserved for start up */
    char attr;                          /* attribute found */
    unsigned int time;                  /* time of last modify */
    unsigned int date;                  /* date of last modify */
    long length;                        /* file size */
    char name[13];                      /* asciz file name */
};

/* attributes */
#define A_RO    1                       /* read only */
#define A_H     2                       /* hidden */
#define A_S     4                       /* system */
#define A_V     8                       /* volume id */
#define A_D     16                      /* directory */
#define A_A     32                      /* archive */

#define A_MOD   (A_RO+A_H+A_S+A_A)      /* changeable attributes */

#define HASATTR(a,v)    TESTFLAG(a,v)   /* true if a has attribute v */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\utilmid.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*      SCCSID = @(#)utilmid.h	10.5 87/05/22 */

#define MSG_REC_FILE_NOT_FOUND          2         /* file not found */

#define MSG_DCOMP_INSUFF_MEM            8         /* insufficient storage - diskcomp */
#define MSG_DCOPY_INSUFF_MEM            8         /* insufficient storage - diskcopy */
#define MSG_CHK_MEMORY_UNAVAIL          8         /* memory unavailable - chkdsk */
#define MSG_REST_INSUF_MEM              8         /* insufficient memory */
#define MSG_BACK_INSUF_MEM              8         /* insufficient mem */
#define MSG_REC_UNABLE_ALL_MEM          8         /* unable to allocate memory */
/* 1000 - 1004 basemid */
/* 1005 not used */
#define MSG_SORT_INVAL_PARA             1002      /* sort invalid parameter */
#define MSG_SORT_NOT_ENOUGH_MEMORY      1006      /* sort file size too big */
/* 1008 not used */
#define MSG_SORT_READ_ERROR             30        /* error reading from disk/diskette */
/* 1009 not used */
#define MSG_SORT_RCD_SIZE_EXCEED        1010      /* record size exceeded */
/* 1011 - 1014 unused */
#define MSG_REC_ENT_BEG_REC             1015      /* Press Enter to being recover drive %1 */
#define MSG_REC_ERROR_DRIVE             1016      /* %1 error %2 drive %3 */
#define MSG_REC_INVAL_PARAMETER         1001      /* Invalid parameter */
/* 1018 not used */
#define MSG_REC_INVAL_DRIVE             1019      /* invalid drive */
#define MSG_REC_INVAL_DRIVE_FILE        2         /* invalid drive or filename */
/* 1020 - 1022 */
#define MSG_REC_BYTES_RECOVERED         1023      /* %1 of %2 bytes recovered */
#define MSG_REC_WARN_DIR_FULL           1024      /* warning directory full */
#define MSG_REC_FILES_RECOVERED         1025      /* %1 files recovered */
#define MSG_REC_TOO_MANY_PARAMETERS     1003      /* Too many parameters entered */
/* 1026 - 1031 unused */
#define MSG_REN_INVAL_NUM_PARA          1003      /* Rename invalid number of parameters */
#define MSG_STRIKE_ANY_KEY              1032      /* press any key when ready */
#define MSG_DIR_INVALID_DIR             3         /* Dir invalid directory */
/* 1033 not used */
#define MSG_COM_SEARCH_DIR_BAD          1034      /* specified command search dir bad */
#define MSG_REN_INVAL_PATH_FILENAME     1035      /* rename invalid path or filename */
#define MSG_DATE_INVALID                1036      /* invalid date */
#define MSG_NO_BAT_LABEL                1039      /* batch label not found */
#define MSG_DIR_BAD_COMMAND_OR_FILE     1041      /* bad command or filename */
#define MSG_RMDIR_INVALID_PATH          1042      /* rmdir is bad */
#define MSG_REN_INVALID_PARAMETER       1003      /* rename invalid parameter */
/* 1043 not used */
#define MSG_REN_INVALID_TIME            1044      /* rename invalid time */
#define MSG_BAD_DOS_VER                 1045      /* CMD and DOS incompat */
#define MSG_VER_SPEC_ON_OFF             1001      /* verify and break on or off */
/* 1046 not used */
#define MSG_COMM_VER                    1047      /* command version 5.0 */
#define MSG_C                           1048      /* c acknowledgement */
#define MSG_FILES_COPIED                1049      /* % files copied */
#define MSG_CURRENT_DATE                1050      /* current date is */
#define MSG_CURRENT_TIME                1051      /* current time is */
#define MSG_DOSWRITE_ERROR_TO_DEV       29        /* doswrite error writing to device */
/* 1052 not used */
#define MSG_DIR_OF                      1053      /* directory of %1 */
#define MSG_DIR                         1054      /* dir */
#define MSG_OUT_OF_ENVIRON_SPACE        1056      /* out of environment space */
/* 1058 not used */
#define MSG_EXEC_FAILURE                1059      /* EXEC failure */
#define MSG_FILES_FREE                  1060      /* %1 files %2 bytes free */
#define MSG_FILE_CREATION_ERROR         1061      /* file creation error */
/* 1062 - 1063 not used */
#define MSG_LINES_TOO_LONG              1065      /* lines too long */
#define MSG_CONT_LOST_BEF_COPY          1066      /* content of destination lost before */
#define MSG_INSRT_DISK_BAT              1067      /* insert disk with batch file press key */
#define MSG_ENTER_NEW_DATE              1068      /* Enter new date */
#define MSG_SYNERR_NLN                  1003      /* newline */
/* 1069 not used */
#define MSG_ENTER_NEW_TIME              1070      /* enter new line */
#define MSG_RDR_HNDL_CREATE             1071      /* Handle creation error */
#define MSG_ECHO_OFF                    1074      /* ECHO is off */
#define MSG_ECHO_ON                     1075      /* ECHO is on */
#define MSG_VERIFY_OFF                  1076      /* Verify is off */
#define MSG_VERIFY_ON                   1077      /* Verify is on */
#define MSG_CANNOT_COPIED_ONTO_SELF     1078      /* message cannot be copied onto self */
#define MSG_SYNERR_GENL                 1079      /* syntax error general */
#define MSG_TOP_LEVEL_PROCESS_CAN       1081      /* top level process aborted, cannot con */
#define MSG_PID_IS                      1082      /* pid is %1 */
#define MSG_DUP_FILENAME_OR_NOT_FD      1083      /* duplicate filename or file not found */
#define MSG_ARE_YOU_SURE                1084      /* Are you sure (Y/N)? */
#define MSG_SET_SYNTAX_ERROR            1003      /* syntax error on set command */
/* 1085 not used */
#define MSG_TOKEN_TOO_LONG              1086      /* token too long */
#define MSG_PROG_TOO_BIG_MEM            8         /* program is too big to fit into memory */
/* 1087 not used */
#define MSG_MS_DOS_VERSION              1090      /* cp-dos version %1 %2 */
#define MSG_PIPE_FAILURE                1092      /* pipeline failure %1 */
#define MSG_MS_MORE                     1093      /* more? */
/* 1094 - 1100 unused */
#define MSG_BAD_VERSION                 1210      /* bad dos version - join */
#define MSG_JS_INCOR_SYNT               1003      /* bad join syntax */
/* 1001 not used */
#define MSG_JOIN_CANNOT_CREAT_DIR       82        /* cannot create directory */
/* 1102 not used */
#define MSG_SUBST_CANNOT_ACCPT_DIR      1103      /* cannot accept directory - join */
#define MSG_JOIN_LIST                   1104      /* join is joined */
#define MSG_SUBST_LIST                  1105      /* subst is substituted */
/* 1106 not used */
#define MSG_REAL_MODE_ONLY              1107      /* app run in real mode only */
/* 1108 - 1135 unused */
#define MSG_REP_INCOR_VERSION           1135      /* incorrect dos version replace */
#define MSG_REP_INCOR_PARA              1002      /* incorrect parameters replace */
/* 1136 not used */
#define MSG_REP_SOUR_PATH_REQ           1137      /* source path required replace */
#define MSG_REP_PARA_NOT_COMP           1003      /* parameters not compatible */
/* 1138 not used */
#define MSG_REP_ENTER_ADD_FILE          1139      /* press enter to add file */
#define MSG_REP_ENTER_REPLACE_FILE      1140      /* press enter replace file */
#define MSG_REP_NO_FILES_FOUND          1141      /* no files found replace */
#define MSG_REP_FILE_NOT_COPY_SELF      1078      /* file cannot be copied to self %1 */
/* 1142 - 1144 not used */
#define MSG_REP_NOT_FOUND               2         /* file not found %1 */
#define MSG_REP_PATH_REQ_NOT_FOUND      3         /* path requested not found */
#define MSG_REP_ACCESS_DENIED           1145      /* access to %1 denied */
#define MSG_REP_DRIVE                   15        /* drive rep incorrect */
/* 1146 - 1147 not used */
#define MSG_REP_NO_FILES_ADDED          1148      /* no files added. */
#define MSG_REP_FILES_ADDED             1149      /* files %1 added. */
#define MSG_REP_NO_FILES_REP            1150      /* no files replaced */
#define MSG_REP_FILES_REP               1151      /* files %1 replaced */
#define MSG_REP_ADD                     1152      /* add %1 y/n */
#define MSG_REP_FILES                   1153      /* want to replace %1 */
#define MSG_REP_ADDING_FILES            1154      /* adding %1 files */
#define MSG_REP                         1155      /* replacing %1 files */
/* 1156 - 1160 unused */
#define MSG_COMP_COMPARE_MORE           1161      /* compare more files */
#define MSG_COMP_ENTER_FILE_1ST         1162      /* enter primary filename */
#define MSG_COMP_ENTER_FILE_2ND         1163      /* enter 2nd filename or drive letter */
#define MSG_COMP_COMPARE_OK             1164      /* files compare ok */
#define MSG_COMP_END_COMPARE            1165      /* 10 mismatches ending compare */
#define MSG_COMP_FILE2_BYTE             1166      /* file2 = %0 */
#define MSG_COMP_FILE1_BYTE             1167      /* file 1 = %0 */
#define MSG_COMP_FILE_OFFSET            1168      /* compare error at offset %0 */
#define MSG_COMP_LENGTH_MISMATCH        1169      /* files are different sizes */
#define MSG_COMP_1ST_2ND_FILENAMES      1170      /* %1 and %2 */
#define MSG_COMP_INVALID_PATH           1171      /* invalid path */
#define MSG_COMP_FILE_NOT_FOUND         1490      /* %1 file not found */
#define MSG_COMP_INVALID_DRIVE          15        /* invalid drive */
#define MSG_COMP_INVALID_DOSVER         1210      /* invalid dos version */
/* 1172 - 1179 unused */
#define MSG_MOUSE_PARA_MOD              1180      /* parameters modified */
#define MSG_MOUSE_NOT_LOADED            1181      /* mouse device driver version not load */
#define MSG_MOUSE_LOADED                1183      /* mouse loaded */
#define MSG_XCOPY_ITSELF                1184      /* cannot copy itself */
#define MSG_XCOPY_INTERNAL_ERROR        1185      /* internal error */
#define MSG_XCOPY_NO_OPEN_SOURCE        1186      /* no source open */
#define MSG_XCOPY_NO_OPEN_TARGET        1187      /* no target open */
#define MSG_XCOPY_NO_READ_SOURCE        1186      /* no read source */
/* 1188 not used */
#define MSG_XCOPY_NO_CLOSE_SOURCE       1189      /* close source */
#define MSG_XCOPY_NO_CLOSE_TARGET       1189      /* no close target */
/* 1190  - 1191 not used */
#define MSG_XCOPY_NO_WRITE_TARGET       1187      /* no write target */
#define MSG_XCOPY_NO_ACCESS_SOURCE      1192      /* no access source */
#define MSG_XCOPY_NO_ACCESS_TARGET      1192      /* no access target */
/* 1193 not used */
#define MSG_XCOPY_INVALID_DATE          1036      /* invalid date */
/* 1194 - 1207 basemid */
#define MSG_ENTER_JAPAN_DATE            1208      /* enter the new date yy-mm-dd */
#define MSG_ENTER_DEF_DATE              1209      /* enter the new date dd-mm-yy */
#define MSG_INCORRECT_DOSVER            1210      /* incorrect dos version */
#define MSG_SAD_INV_DOS                 1210      /* invalid dos version - created */
#define MSG_STCP_INV_DOS                1210      /* trace only in >= dos  - trace */
#define MSG_INVALID_DOS_PRINT           1210      /* incorrect dos version */
#define MSG_TREE_INV_DOSVER             1210      /* incorrect DOS version */
#define MSG_INVAL_DOS_VERSION           1210      /* invalid DOS version */
#define MSG_REST_INVAL_VERS             1210      /* invalid dos version not 1.0 */
#define MSG_BACK_INCOR_DOS_VER          1210      /* inval dos ver */
#define MSG_REP_INCOR_DOS_VERSION       1210      /* incorrect dos version replace */
#define MSG_ABORT_RETRY_IGNORE          1211      /* abort, retry, or ignore */
#define MSG_REC_ABORT_RETRY_IGNORE      1211      /* abort, retry, ignore */
#define MSG_PRESS_ANY_KEY               1212      /* press any key when ready */
/* 1213 - 1215 not used */
#define MSG_DCOMP_INV_PARM              1001      /* invalid parameter - diskcomp */
/* 1230 not used */
#define MSG_DCOMP_INV_DRIVE             1231      /* invalid drive - diskcomp */
#define MSG_DCOPY_INV_DRV               1231      /* invalid drive - diskcopy */
#define MSG_DCOMP_INSERT_FIRST          1232      /* insert first disk - diskcomp */
#define MSG_DCOPY_INSERT_SRC            1232      /* insert source disk - diskcopy */
#define MSG_DCOMP_INSERT_SECOND         1233      /* insert second disk - diskcomp */
#define MSG_DCOPY_INSERT_TARG           1233      /* insert target disk - diskcopy */
#define MSG_DCOMP_DISK1_BAD             1234      /* first disk bad - diskcomp */
#define MSG_DCOMP_DISK2_BAD             1235      /* second disk bad - diskcomp */
/* 1236 - 1237 not used */
#define MSG_DCOMP_REPEAT_COMP           1238      /* compare another? - diskcomp */
#define MSG_DCOMP_COMPARING             1239      /* comparing ...  - diskcomp */
#define MSG_DCOMP_DRV_INCOMPAT          1240      /* drive incompatible - diskcomp */
#define MSG_DCOPY_COPYING               1240      /* copying ...  - diskcopy */
#define MSG_DCOMP_COMPARE_ERROR         1242      /* compare error - diskcomp */
/* 1243 not used */
#define MSG_DCOMP_COMPARE_ENDED         1244      /* compare ended - diskcomp */
#define MSG_DCOMP_COMPARE_OK            1245      /* compare ok - diskcomp */
#define MSG_DCOMP_ENTER_SRC             1246      /* source drive letter - diskcomp/copy */
#define MSG_DCOMP_ENTER_TARG            1247      /* target drive letter - diskcomp/copy */
/* 1248 not used */
#define MSG_DCOPY_FORMATTING            1252      /* copying while formatting - diskcopy */
#define MSG_DCOPY_TARG_NOUSE            1255      /* target disk possibly bad - diskcopy */
/* 1256 not used */
#define MSG_DCOPY_COPY_ANOTHER          1259      /* copy another?  - diskcopy */
#define MSG_DCOPY_COPY_TRACKS           1260      /* copy tracks */
/* 1261 - 1262 not used */
#define MSG_DCOPY_READ_ERROR            1264      /* read error - diskcopy */
#define MSG_DCOPY_UNREC_RDERR           1265      /* unrecoverable read error - diskcopy */
#define MSG_DCOPY_COPY_ENDED            1266      /* copy ended - diskcopy */
/* 1267 - 1269 not used */
#define MSG_FMT_INS_NEW_DISK            1270      /* insert new disk - format */
#define MSG_FMT_DISK_WARNING            1271      /* fixed disk warning - format */
#define MSG_FMT_SYS_XFERED              1272      /* system transferred - format */
#define MSG_FMT_ANOTHER                 1273      /* format another - format */
#define MSG_FMT_INV_VOLUME              123       /* invalid volume name - format */
/* 1274 - 1275 not used */
#define MSG_FMT_INV_PARAMETER           1276      /* invalid parameter - format */
#define MSG_FMT_REINSERT_DISK           1277      /* reinsert target disk - format */
#define MSG_FMT_INSERT_DOS              1278      /* reinsert system disk - format */
#define MSG_FMT_FORMAT_FAIL             1279      /* format failure - format */
#define MSG_FMT_DISK_UNSUIT             1280      /* disk unsuitable for system - format */
#define MSG_FMT_INV_MEDIA               1281      /* invalid media - format */
#define MSG_FMT_INSUFF_STORAGE          8         /* insufficient storage - format */
/* 1282 not used */
#define MSG_FMT_DISK_SPACE              1283      /* disk space available - format */
#define MSG_FMT_BYTES_USED              1284      /* bytes used - format */
#define MSG_FMT_BYTES_BAD               1285      /* bytes in bad sectors - format */
#define MSG_FMT_BYTES_AVAIL             1286      /* bytes available - format */
#define MSG_FMT_VOLUME_PROMPT           1288      /* enter volume name - format */
/* 1289 not used */
#define MSG_FMT_NO_SYS_TRANS            1290      /* system cannot transfer */
#define MSG_FMT_DOS_DISK_ERR            1291      /* dos disk error - format */
#define MSG_FMT_NONSYS_DISK             1292      /* non-system disk - format */
/* 1283 not used */
#define MSG_FMT_COMPLETE                1294      /* format complete - format */
#define MSG_FMT_WP_VIOLATION            1295      /* write protect violation - format */
#define MSG_FMT_NO_WRITE_BOOT           1296      /* unable to write boot - format */
#define MSG_FMT_INCOMPAT_DISK           1297      /* incompatible parms for disk - format */
#define MSG_FMT_PARM_INCOMPAT           1298      /* incompatible parameter - format */
#define MSG_FMT_DRV_NOT_READY           1299      /* drive not ready - format */
/* 1300 - 1301 not used */
#define MSG_FMT_HEAD_CYL                1302      /* head/cylinder - format */
#define MSG_FMT_NOT_SUPPORTED           1303      /* format not supported - format */
/* 1304 - 1306 not used */
#define MSG_FMT_FAT_ERROR               1307      /* error writing fat - format */
#define MSG_FMT_DIR_WRTERR              1308      /* error writing directory - format */
#define MSG_FMT_DRIVE_LETTER            1310      /* drive letter must be specified */
#define MSG_FMT_SYS_FILES               1311      /* cannot find system files - format */
/* 1312 not used */
#define MSG_FMT_BAD_PARTITION           1313      /* bad partition table - format */
/* 1314 not used */
#define MSG_FMT_UNSUPP_PARMS            1316      /* parameters not supported - format */
#define MSG_FMT_WHAT_IS_VOLID           1318      /* enter current volume label for dr %1 */
#define MSG_FMT_BAD_VOLID               1319      /* incorrect volume label for drive %1 */
#define MSG_FMT_TBL_ERR                 1320      /* format.tbl missing or an error */
#define MSG_FMT_TRANSFER                1321      /* format transferred */
#define MSG_FMT_DEFAULT_PARM            1322      /* default parameters /n or /t */
#define MSG_CHK_REAL_MODE_MEM_RPT       1327      /* real mode memory report */
#define MSG_CHK_NON_CONT_BLOCKS         1328      /* non-contig blocks */
#define MSG_CHK_SPEC_FILE_CONT          1329      /* specified files are contig */
#define MSG_CHK_INVALID_PARM            1330      /* invalid parameter - chkdsk */
#define MSG_CHK_DISK_OPEN_ERR           1331      /* cannot open disk error - chkdsk */
#define MSG_CHK_DISK_LOCK_ERR           1332      /* cannot lock disk error - chkdsk */
#define MSG_CHK_INVALID_DRIVE           1333      /* invalid drive specification - chkdsk */
#define MSG_CHK_FAT_READ                1336      /* error reading FAT - chkdsk */
#define MSG_CHK_FAT_WRITE               1337      /* error writing FAT - chkdsk */
#define MSG_CHK_DIRECTORY               1338      /* directory - chkdsk */
#define MSG_CHK_NO_SLASHF               1339      /* errors found, no /F - chkdsk */
#define MSG_CHK_INV_CLUSTER             1340      /* invalid cluster - chkdsk */
#define MSG_CHK_INV_CURDIR              1341      /* invalid current dir - chkdsk */
#define MSG_CHK_ALLOC_ERR               1342      /* allocation error - chkdsk */
#define MSG_CHK_CROSSLINK               1343      /* files cross linked - chkdsk */
#define MSG_CHK_1ST_CLUSTER             1344      /* first cluster bad - chkdsk */
#define MSG_CHK_UNREC_DIRERR            1345      /* unrecoverable dir error - chkdsk */
#define MSG_CHK_CONVERT                 1346      /* conver directory? - chkdsk */
#define MSG_CHK_DIR_EMPTY               1347      /* directory empty - chkdsk */
#define MSG_CHK_INV_SUBDIR              1349      /* invalid subdirectory - chkdsk */
#define MSG_CHK_NO_REC_DOT              1350      /* can't recover . entry - chkdsk */
#define MSG_CHK_NO_REC_DOTDOT           1351      /* can't recover .. entry - chkdsk */
#define MSG_CHK_BAD_LINK                1352      /* bad link - chkdsk */
#define MSG_CHK_BAD_ATTRIB              1352      /* bad file attribute - chkdsk */
#define MSG_CHK_BAD_SIZE                1352      /* bad file size - chkdsk */
/* 1353 - 1354 not used */
#define MSG_CHK_NOT_EXIST               1355      /* file does not exist - chkdsk */
#define MSG_CHK_LOST_CLUSTERS           1356      /* lost clusters - chkdsk */
#define MSG_CHK_SPACE_FREED             1358      /* space freed - chkdsk */
#define MSG_CHK_SPACE_POSSIBLE          1359      /* space available - chkdsk */
#define MSG_CHK_NOROOM_ROOT             1360      /* no room in root - chkdsk */
#define MSG_CHK_DISK_TOTAL              1361      /* total space on disk - chkdsk */
#define MSG_CHK_BAD_SECTORS             1362      /* bad sectors - chkdsk */
#define MSG_CHK_HIDDEN_TOTAL            1363      /* hidden file total - chkdsk */
#define MSG_CHK_DIR_TOTAL               1364      /* directory total - chkdsk */
#define MSG_CHK_FILE_TOTAL              1365      /* file total - chkdsk */
#define MSG_CHK_RECOVER_TOTAL           1366      /* recovered total - chkdsk */
#define MSG_CHK_BYTES_POSSIBLE          1367      /* bytes possible - chkdsk */
#define MSG_CHK_BYTES_AVAIL             1368      /* bytes available - chkdsk */
#define MSG_CHK_PROCESS_STOP            1373      /* can't continue - chkdsk */
#define MSG_CHK_FAT_BAD                 1374      /* bad fat - chkdsk */
#define MSG_CHK_VOL_CREATE              1375      /* can't create volume - chkdsk */
#define MSG_CHK_ERR_WRITE_DIR           1376      /* can't write directory - chkdsk */
#define MSG_CHK_ROOT_BAD_DRV            1377      /* root directory bad - chkdsk */
#define MSG_CHK_NON_DOS                 1379      /* probable non-dos disk - chkdsk */
#define MSG_CHK_ERR_READ_DIR            1380      /* can't read dir - chkdsk */
#define MSG_SAD_DUMPING                 1381      /* dump in process */
#define MSG_SAD_INSERT_NEXT             1382      /* current dump diskette filled */
#define MSG_SAD_DISK_ERROR              1383      /* error with diskette, insert another */
#define MSG_SAD_REINSERT                1384      /* insert dump diskette #1 */
#define MSG_SAD_DISK_OVERWRITE          1385      /* disk will be overwritten - created */
#define MSG_SAD_API_ERR                 1386      /* api error - createdd */
#define MSG_SAD_INV_DRIVE               15        /* invalid drive parm - createdd */
#define MSG_SAD_USED_ONCE               1388      /* dump data is already on the diskette */
#define MSG_SAD_HIGH_CAPACITY           1389      /* high capacity diskette */
#define MSG_SAD_PRO_TERM_USER           1390      /* progm is end by user - createdd */
#define MSG_SAD_COMPLETE                1391      /* dump complete remove and reboot */
#define MSG_SAD_NOT_CONTIG              1392      /* not enough contiguous - createdd */
#define MSG_SAD_MEM_RANGE               1393      /* memory address ranges on this disk ar */
/* 1395 basemid */
#define MSG_SAD_INSERT_NEW              1396      /* insert new dump disk - rascrv */
#define MSG_STCP_NOT_EXIST              1397      /* sys trace does not exist - trace */
#define MSG_STCP_INV_ON_OFF             1399      /* invalid or missing on/off - trace */
#define MSG_STCP_EC_RANGE               1400      /* out of range event code - trace */
#define MSG_STCP_EC_INVALID             1401      /* event codes invalid - trace */
/* 1402 - 1405 not used */
#define MSG_DFMT_ENTER                  1406      /* enter to continue - dumpfmtr */
/* 1407 - 1424 not used */
#define MSG_SAD_INS_PROPER              31        /* diskette error, ensure diskette inser */
#define MSG_SAD_WRITE_PROTECT           19        /* diskette error, write protect tab */
#define MSG_SPOOL_WTRUNC_ERROR          1425      /* cannot release filling file - print */
#define MSG_SPOOL_OPEN_ERROR            1426      /* cannot delete filling file - print */
#define MSG_SPOOL_SIG_ERROR             1427      /* cannot delete printing file - print */
#define MSG_SPOOL_MACH_ERROR            1428      /* cannot hold filling file - print */
#define MSG_SPOOL_RUN_PRINT_DATA        1429      /* spool running with print data redir */
#define MSG_SPOOL_RUN_DEVICE            1430      /* spool print run on device */
#define MSG_SPOOL_INV_PARA              1001      /* spooler invalid parameter */
#define MSG_SPOOL_INV_DEVICE            15        /* spool invalid device */
/* 1431 - 1432  not used */
#define MSG_SPOOL_INV_INPAR             1433      /* spool inval input device para */
#define MSG_SPOOL_INV_OUTPAR            1434      /* spool inval output device para */

#define MSG_SPOOL_INV_DIRPARM           1435      /* spool inval subdirectory */
#define MSG_SPOOL_INT_ERROR             8         /* spool internal error */
/* 1436 not used */
#define MSG_SPOOL_DISK_FULL             1437      /* spool disk full */
#define MSG_SPOOL_CURR_CAN_OPER         1438      /* spooler current cancelled by operator */
#define MSG_SPOOL_ALL_CAN_OPER          1439      /* spooler cancelled by operator */
/* 1440 not used */
#define MSG_SPOOL_SHAR_VIOLAT           1441      /* spool share violation */
#define MSG_SPOOL_ALREADY_RUN           1442      /* spool is already running for device */
#define MSG_SPOOL_DISK_IS_FULL          112       /* spool disk is full action different */
/* 1443 - 1455 not used */
#define MSG_SPOOL_DK_FULL               1437      /* spool disk is full action different */
#define MSG_SYS_NO_ROOM                 1456      /* no room for system on disk - sys */
#define MSG_SYS_BAD_TRANS               1457      /* could not transfer files - sys */
#define MSG_SYS_NO_SYSTEM               1458      /* no system on default drive - sys */
#define MSG_SYS_TARGET_DRIVE_IN_USE     21        /* drive in use by another process -sys */
#define MSG_SYS_INTERNAL_ERROR          1459      /* internal error in sys -sys */
/* 1460 not used */
#define MSG_SYS_INV_PARM                1460      /* invalid parameter - sys */
#define MSG_SYS_INV_DRIVE               1461      /* invalid drive - sys */
#define MSG_SYS_TRANSFERRED             1272      /* system transferred - sys */
#define MSG_FDISK_INV_PART_TABLE        1462      /* invalid partition table */
#define MSG_FDISK_ERR_LOADING_OS        1463      /* error loading operating system */
#define MSG_FDISK_ERR_MISSING_OS        1464      /* missing operating system */
#define MSG_VDISK_INV_PARM              1465      /* invalid parameter - vdisk */
#define MSG_VDISK_INSUFF_MEM            1466      /* insufficient memory - vdisk */
#define MSG_VDISK_REPORT                1467      /* vdisk summary - vdisk */
#define MSG_SES_MGR_TERM                1468      /* session manager terminate ignore */
#define MSG_SES_MGR_MENU                1469      /* session manager menu */
/* */
/* 1470-1474 are for swapper and are in basemid.inc */
/* */
#define MSG_TREE_INV_PARM               1001      /* invalid parameter */
/* 1475  - 1477 not used */
#define MSG_TREE_INV_DRIVE              15        /* invalid drive specification */
#define MSG_TREE_INV_PATH               1478      /* invalid path */
#define MSG_TREE_TOP_HEADER             1479      /* DIRECTORY PATH LISTING */
#define MSG_TREE_PATHNAME               1480      /* Path: %1 */
#define MSG_TREE_SUBDIR_HEADER          1481      /* Sub-directories:  %1 */
#define MSG_TREE_FILE_HEADER            1482      /* Files:            %1 */
#define MSG_TREE_NONE_FILE              1483      /* Files:            None */
#define MSG_TREE_NONE_SUBDIR            1484      /* Sub-directories:  None */
#define MSG_TREE_FILENAME               1485      /*                   %1 */
#define MSG_TREE_NO_SUBDIR_EXIST        1486      /* subdirectory does not exist */
#define MSG_HELP_BAD_MID                1487      /* Invalid message id */
#define MSG_HELP_MID_LARGE              1488      /* Message id too large */
#define MSG_HELP_SYNTAX                 1489      /* Syntax error */
#define MSG_FIND_FILE_NOT_FOUND         1490      /* FIND file not found %1 */
#define MSG_SYNTAX_ERR_FIND             1003      /* FIND syntax error */
#define MSG_INVALID_P_NUM               1003      /* invalid number of parameters */
/* 1491 - 1492 not used */
#define MSG_HELP_NO_HELP                1493      /* No help available */
#define MSG_READ_ERROR_FIND             31        /* FIND read error */
/* 1494 - 1496 not used */
#define MSG_INVALID_PARM_FIND           1002      /* FIND invalid parameter */
#define MSG_PATH_NOT_FIND               3         /* path not found */
/* 1497 - 1499 not used */
#define MSG_VDISK_NO_DRIVES             1505      /* no drive letters for vdisk */
/* 1506 - 1508 unused */
#define MSG_INVALID_DR_LABEL            15        /* invalid drive specification %1 */
/* 1509- 1511 unused */
#define MSG_INVALID_LABEL               123       /* inval charact. in volume label */
/* 1512 - 1513 unused */
#define MSG_HAS_NO_LABEL                1514      /* volume in drive x has no label */
#define MSG_GET_NEW_LABEL               1515      /* volume label (11 char) ent for none % */
#define MSG_DR_VOL_LABEL                1516      /* volume in drive X is */
/* 1517 - 1523 in basemid.inc */
#define MSG_PRINT_INV_PARM              1525      /* invalid command line parameter */
#define MSG_PRINT_TOO_MANY              1526      /* too many command line param entered */
/* 1528 not used */
#define MSG_PRINT_INV_DEVICE            1529      /* invalid printer device */
#define MSG_PRINT_WRITE_ERROR           28        /* error occurred on the printer */
/* 1530 not used */
#define MSG_PRINT_NO_SPOOL              1531      /* spooler not running */
#define MSG_PRINT_REAL_MODE             1532      /* spooler runs only in protect mode */
#define MSG_PRINT_FILE_NOT_FOUND        1533      /* file not found */
#define MSG_FDISK_MAIN_INTRO            1534      /* fdisk setup */
#define MSG_FDISK_MAIN_MENU             1535      /* FDISK options */
#define MSG_FDISK_MAIN_NEXTFDISK        1536      /* 5. Select next fixed disk drive */
#define MSG_FDISK_MAIN_PROMPT           1537      /* Enter choice: */
#define MSG_FDISK_CHANGE_CANTACT        1538      /* table partition can't be made active */
#define MSG_FDISK_CHANGE_CURACT         1539      /* current active partition is %1 */
#define MSG_FDISK_CHANGE_DONE           1540      /* partition %1 made active */
#define MSG_FDISK_CHANGE_NOPART         1541      /* No partitions to make active */
#define MSG_FDISK_CHANGE_1PART          1542      /* Partition 1 is already active */
#define MSG_FDISK_CHANGE_PROMPT         1543      /* Enter the number of the partition you */
#define MSG_FDISK_CHANGE_TITLE          1544      /* change active partition */
#define MSG_FDISK_CREATE_DONE           1545      /* DOS partition created */
#define MSG_FDISK_CREATE_NOSPACE        1546      /* No space for a %1 partition */
#define MSG_FDISK_CREATE_NOSPATHE       1547      /* No space for %1 cylinder at cyl%2 */
#define MSG_FDISK_CREATE_NOSPAFDOS      1548      /* No space to create a DOS partition */
#define MSG_FDISK_CREATE_PARTEXISTS     1549      /* fixed disk already has a dos partit */
#define MSG_FDISK_CREATE_SIZEPROMPT     1550      /* Enter partition size... */
#define MSG_FDISK_CREATE_SPACEAT        1551      /* Max avail space is %1 cyl at %2. */
#define MSG_FDISK_CREATE_STARTPROMP     1552      /* enter starting cylinder number... */
#define MSG_FDISK_CREATE_TITLE          1553      /* create DOS partition */
#define MSG_FDISK_CREATE_WHOLEDISK      1554      /* Do you want to use the entire fd y/n */
#define MSG_FDISK_DELETE_DONE           1555      /* DOS partition deleted */
#define MSG_FDISK_DELETE_NOPART         1556      /* No DOS partition to delete */
#define MSG_FDISK_DELETE_PROMPT         1557      /* Warning! Data in the DOS part lost */
#define MSG_FDISK_DELETE_TITLE          1558      /* Delete DOS partition yn */
#define MSG_FDISK_DISPLAY_FDISKSIZE     1559      /* Total disk space is %1 cylinders. */
#define MSG_FDISK_DISPLAY_NOPARTS       1560      /* No partitions defined */
#define MSG_FDISK_DISPLAY_PARTINFO      1561      /* Partition status type start endsize */
#define MSG_FDISK_DISPLAY_TITLE         1562      /* Display partition information */
#define MSG_FDISK_ERR_INVALIDNUMBER     1563      /* %1 is not a choice.  Please enter a c */
#define MSG_FDISK_ERR_INVALIDYN         1564      /* %1 is not a choice.  Please enter yn */
#define MSG_FDISK_ERR_NOFDISKS          1565      /* no fixed disks present */
#define MSG_FDISK_ERR_READ              1566      /* error reading fixed disk */
#define MSG_FDISK_ERR_WRITE             1567      /* error writing fixed disk */
#define MSG_FDISK_CURRENTDISK           1568      /* current fixed disk drive %1 */
#define MSG_FDISK_PRESSESC              1569      /* press esc to return to fdisk options */
#define MSG_FDISK_MUST_RESTART          1570      /* must restart */
#define MSG_FDISK_IN_USE                1571      /* fixed disk in use */
/* 1572 - 1574 unused */
#define MSG_PATCH_INV_NUM_PARMS         1575      /*invalid number of parameters */
#define MSG_PATCH_INV_PARM              1575      /* invalid parameter %1%2 */
/* 1576 not used */
#define MSG_PATCH_NO_CTL                1490      /* cannot open patch control file %1 */
#define MSG_PATCH_NO_EXE_FILE           1490      /* cannot open %1 to patch */
/* 1577 - 1578 not used */
#define MSG_PATCH_PATCHING              1579      /* patching %1 */
#define MSG_PATCH_CONTINUE              1580      /* continue patching %1? Y/N */
#define MSG_PATCH_NO_PATCHES            1581      /* No patches applied */
#define MSG_PATCH_PATCHES_ENTERED       1582      /* Patches entered for %1 */
#define MSG_PATCH_OK_TO_PATCH           1583      /* should these patches be appl to %1? */
#define MSG_PATCH_APPLIED               1584      /* patches applied to %1 */
#define MSG_PATCH_NOT_APPLIED           1585      /* No patches applied to %1 */
#define MSG_PATCH_CURRENT_EOF           1586      /* Current end of file is at %1 */
#define MSG_PATCH_OFFSET_PROMPT         1587      /* enter offset in hex of patch > */
#define MSG_PATCH_PAST_EOF_INT          1588      /* offset is past end of file */
#define MSG_PATCH_CANT_ALLOC            1589      /* Insufficient memory to save pat inf */
#define MSG_PATCH_NO_FILE               1590      /* no file to patch fond in pat con %1 */
#define MSG_PATCH_INV_CMD_COMBO         1591      /* %1 command found without a %2 cmd */
#define MSG_PATCH_INV_OFFSET            1592      /* %1 is not a valid offset for file %2 */
#define MSG_PATCH_INV_BYTES             1593      /* %1 is not a valid %2 byte stg for%3 */
#define MSG_PATCH_TOO_NEAR_EOF          1594      /* offset %1 for %2 too near orpst%3%4 */
#define MSG_PATCH_VERIFY_FAILED         1595      /* verification failed for %1 */
/* 1596 not used */
#define MSG_PATCH_PAST_EOF_AUTO         1597      /* ofst given %1 ofr %2 eof %3 */
#define MSG_PATCH_UNKNOWN_CMD           1598      /* unknown command */
#define MSG_PATCH_CANT_APPEND           1599      /* cannot append */
#define MSG_PATCH_NO_REQUEST            1600      /* no patch request specified */
#define MSG_MODE_INVAL_PARMS            1601      /* invalid number of parameters */
#define MSG_MODE_CPL_SET                1602      /* characters per line has been set */
#define MSG_MODE_LPI_SET                1603      /* lines per inch have been set */
#define MSG_MODE_INF_RET_SET            1604      /* infinite has been set */
#define MSG_MORE                        1605      /* -- More -- */
#define MSG_MODE_INF_RET_RESET          1606      /* infinite retry reset */
#define MSG_MODE_DEVICE_NAME            1607      /* invalid device name */
#define MSG_PRINT_ERROR                 29        /* printer error */
/* 1608 not used */
#define MSG_MODE_ASYNC_SET              1609      /* async protocol set */
/* 1610 not used */
#define MSG_MODE_NO_REDIR               1611      /* mode cannot direct output */
/* 1612 not used */
#define MSG_INVALID_PARITY              1613      /* open parity */
#define MSG_INVALID_DATABITS            1614      /* invalid databits */
#define MSG_INVALID_STOPBITS            1615      /* invalid stopbits */
#define MSG_INVALID_BAUD_RATE           1616      /* invalid baud rate */
#define MSG_INVALID_CHAR_PER_LINE       1617      /* invalid characters per line */
#define MSG_INVALID_LINES_PER_INCH      1618      /* invalid lines per inch */
#define MSG_INVALID_SYNTAX              1601      /* invalid syntax */
/* 1619 - 1621 not used */
#define MSG_MODE_OUT_RANGE              1622      /* mode out of range */
#define MSG_MODE_INV_PARM               1601      /* invalid parameter */
/* 1623 - 1625 unused */
#define MSG_INVAL_PARAMETER             1002      /* invalid parameter attrib */
#define MSG_FILEN_REQUIRED              2         /* filename required attrib */
/* 1626 - 1627 unused */
#define MSG_UNEX_DOS_ERROR              1628      /* unexpected dos error */
/* 1629 - 1633 unused */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\subcalls.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*SCCSID = @(#)subcalls.hwc	10.1 87/05/02*/
struct CursorData {
	unsigned cur_start;
	unsigned cur_end;
	unsigned cur_width;
	unsigned cur_attribute;
	};
struct KbdStatus {
	unsigned length;
	unsigned bit_mask;
	unsigned turn_around_char;
	unsigned interim_char_flags;
	unsigned shift_state;
	};
struct KbdTRANS {
	unsigned char char_code;
	unsigned char scan_code;
	unsigned char status;
	unsigned char nls_shift;
	unsigned shift_state;
	unsigned long time;
	unsigned kbdDDflags;
	unsigned xlt_flags;
	unsigned xlt_shift_state;
	unsigned xlt_rsrv_0;
	};
struct KeyData {
	unsigned char char_code;
	unsigned char scan_code;
	unsigned char status;
	unsigned char nls_shift;
	unsigned shift_state;
	unsigned long time;
	};
struct ModeData {
	unsigned length;
	unsigned char type;
	unsigned char color;
	unsigned col;
	unsigned row;
	unsigned hres;
	unsigned vres;
	};
struct PVBData {
	unsigned pvb_size;
	unsigned long pvb_ptr;
	unsigned pvb_length;
	unsigned pvb_rows;
	unsigned pvb_cols;
	unsigned char pvb_type;
	};
struct PhysBufData {
	unsigned long buf_start;
	unsigned long buf_length;
	unsigned      selectors[2];
	};
struct ConfigData {
	unsigned length ;
	unsigned adapter_type;
	unsigned display_type;
	unsigned long memory_size;
	};
struct VIOFONT {
	unsigned length;
	unsigned req_type;
	unsigned pel_cols;
	unsigned pel_rows;
	unsigned long font_data;
	unsigned font_len;
	};
struct VIOSTATE {
	unsigned length;
	unsigned req_type;
	unsigned double_defined;
	unsigned palette0;
	unsigned palette1;
	unsigned palette2;
	unsigned palette3;
	unsigned palette4;
	unsigned palette5;
	unsigned palette6;
	unsigned palette7;
	unsigned palette8;
	unsigned palette9;
	unsigned palette10;
	unsigned palette11;
	unsigned palette12;
	unsigned palette13;
	unsigned palette14;
	unsigned palette15;
	};
struct EventInfo {
	unsigned Mask;
	unsigned long Time;
	unsigned Row;
	unsigned Col;
	};
struct NoPointer {
	unsigned Row;
	unsigned Col;
	unsigned Height;
	unsigned Width;
	};
struct PtrImage {
	unsigned TotLength;
	unsigned Col;
	unsigned Row;
	unsigned ColOffset;
	unsigned RowOffset;
	};
struct PtrLoc {
	unsigned RowPos;
	unsigned ColPos;
	};
struct QueInfo {
	unsigned Events;
	unsigned QSize;
	};
struct ScaleFact {
	unsigned RowScale;
	unsigned ColScale;
	};
struct StartData {
	unsigned Length;
	unsigned Related;
	unsigned FgBg;
	unsigned TraceOpt;
	char far * PgmTitle;
	char far * PgmName;
	char far * PgmInputs;
	char far * TermQ;
	};
struct StatusData {
	unsigned Length;
	unsigned SelectInd;
	unsigned BindInd;
	};
struct KbdStringInLength
   {
    unsigned int  Length;
    unsigned int  LengthB;
   };
extern unsigned far pascal KBDREGISTER (
	char far *,
	char far *,
	unsigned long);
extern unsigned far pascal KBDDEREGISTER (
	void );
extern unsigned far pascal KBDCHARIN (
	struct KeyData far *,
	unsigned,
	unsigned );
extern unsigned far pascal KBDFLUSHBUFFER (
	unsigned );
extern unsigned far pascal KBDGETSTATUS (
	struct KbdStatus far *,
	unsigned );
extern unsigned far pascal KBDPEEK (
	struct KeyData far *,
	unsigned );
extern unsigned far pascal KBDSETSTATUS (
	struct KbdStatus far *,
	unsigned );
extern unsigned far pascal KBDSTRINGIN (
	char far *,
	struct KbdStringInLength far *,
	unsigned,
	unsigned );
extern unsigned far pascal KBDOPEN (
	unsigned far * );
extern unsigned far pascal KBDCLOSE (
	unsigned );
extern unsigned far pascal KBDGETFOCUS (
	unsigned,
	unsigned );
extern unsigned far pascal KBDFREEFOCUS (
	unsigned );
extern unsigned far pascal KBDGETCP (
	unsigned long,
	unsigned far *,
	unsigned );
extern unsigned far pascal KBDSETCP (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal KBDXLATE (
	struct KbdTRANS far *,
	unsigned );
extern unsigned far pascal KBDSETCUSTXT (
	unsigned far *,
	unsigned );
extern unsigned far pascal KBDSYNCH (
	unsigned );
extern unsigned far pascal VIOREGISTER (
	char far *,
	char far *,
	unsigned long,
	unsigned long );
extern unsigned far pascal VIODEREGISTER (
	void );
extern unsigned far pascal VIOGETBUF (
	unsigned long far *,
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOGETCURPOS (
	unsigned far *,
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOGETCURTYPE (
	struct CursorData far *,
	unsigned );
extern unsigned far pascal VIOGETMODE (
	struct ModeData far *,
	unsigned );
extern unsigned far pascal VIOGETPHYSBUF (
	struct PhysBufData far *,
	unsigned );
extern unsigned far pascal VIOREADCELLSTR (
	char far *,
	unsigned far *,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOREADCHARSTR (
	char far *,
	unsigned far *,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOSCROLLDN (
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal VIOSCROLLUP (
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal VIOSCROLLLF (
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal VIOSCROLLRT (
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal VIOSETCURPOS (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOSETCURTYPE (
	struct CursorData far *,
	unsigned );
extern unsigned far pascal VIOSETMODE (
	struct ModeData far *,
	unsigned );
extern unsigned far pascal VIOSHOWBUF (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTCELLSTR (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTCHARSTR (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTCHARSTRATT (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	char far *,
	unsigned );
extern unsigned far pascal VIOWRTNATTR (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTNCELL (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTNCHAR (
	char far *,
	unsigned,
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOWRTTTY (
	char far *,
	unsigned,
	unsigned );
extern unsigned far pascal VIOSETANSI (
	unsigned,
	unsigned );
extern unsigned far pascal VIOGETANSI (
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOPRTSC (
	unsigned );
extern unsigned far pascal VIOPRTSCTOGGLE (
	unsigned );
extern unsigned far pascal VIOSAVREDRAWWAIT (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOSAVREDRAWUNDO (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOMODEWAIT (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOMODEUNDO (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOSCRLOCK (
	unsigned,
	unsigned char far *,
	unsigned );
extern unsigned far pascal VIOSCRUNLOCK (
	unsigned );
extern unsigned far pascal VIOPOPUP (
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOENDPOPUP (
	unsigned );
extern unsigned far pascal VIOGETCONFIG (
	unsigned,
	struct ConfigData far *,
	unsigned );
extern unsigned far pascal VIOGETFONT (
	struct VIOFONT far *,
	unsigned );
extern unsigned far pascal VIOGETCP (
	unsigned,
	unsigned far *,
	unsigned );
extern unsigned far pascal VIOSETCP (
	unsigned,
	unsigned,
	unsigned );
extern unsigned far pascal VIOSETFONT (
	struct VIOFONT far *,
	unsigned );
extern unsigned far pascal VIOGETSTATE (
	struct VIOSTATE far *,
	unsigned );
extern unsigned far pascal VIOSETSTATE (
	struct VIOSTATE far *,
	unsigned );
extern unsigned far pascal MOUREGISTER (
	char far *,
	char far *,
	unsigned long );
extern unsigned far pascal MOUDEREGISTER (
	void );
extern unsigned far pascal MOUFLUSHQUE (
	unsigned );
extern unsigned far pascal MOUGETHOTKEY (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUSETHOTKEY (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUGETPTRPOS (
	struct PtrLoc far *,
	unsigned );
extern unsigned far pascal MOUSETPTRPOS (
	struct PtrLoc far *,
	unsigned );
extern unsigned far pascal MOUGETPTRSHAPE (
	unsigned char far *,
	struct PtrImage far *,
	unsigned );
extern unsigned far pascal MOUSETPTRSHAPE (
	unsigned char far *,
	struct PtrImage far *,
	unsigned );
extern unsigned far pascal MOUGETDEVSTATUS (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUGETNUMBUTTONS (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUGETNUMMICKEYS (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUREADEVENTQUE (
	struct EventInfo far *,
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUGETNUMQUEEL (
	struct QueInfo far *,
	unsigned );
extern unsigned far pascal MOUGETEVENTMASK (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUSETEVENTMASK (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUGETSCALEFACT (
	struct ScaleFact far *,
	unsigned );
extern unsigned far pascal MOUSETSCALEFACT (
	struct ScaleFact far *,
	unsigned );
extern unsigned far pascal MOUOPEN (
	char far *,
	unsigned far * );
extern unsigned far pascal MOUCLOSE (
	unsigned );
extern unsigned far pascal MOUREMOVEPTR (
	struct NoPointer far *,
	unsigned );
extern unsigned far pascal MOUDRAWPTR (
	unsigned );
extern unsigned far pascal MOUSETDEVSTATUS (
	unsigned far *,
	unsigned );
extern unsigned far pascal MOUINITREAL (
	char far * );
extern unsigned far pascal DOSSTARTSESSION (
	struct StartData far *,
	unsigned far *,
	unsigned far * );
extern unsigned far pascal DOSSETSESSION (
	unsigned,
	struct StatusData far * );
extern unsigned far pascal DOSSELECTSESSION (
	unsigned,
	unsigned long );
extern unsigned far pascal DOSSTOPSESSION (
	unsigned,
	unsigned,
	unsigned long );

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\utilmid2.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*      SCCSID = @(#)utilmid2.h	5.18 87/05/05 */

#define MSG_REST_FILE_FROM              1634      /* restore file from % 1 %2 */
#define MSG_INS_BACKUP_DISK             1635      /* insert backup %1 in drive %2 */
#define MSG_REST_DISK_OUT_SEQ           1636      /* diskette out of seq press key */
#define MSG_REST_FILE_READ              1637      /* Warning file %1 read only */
#define MSG_REST_CHNG_REPL              1638      /* file was changed after backup */
#define MSG_REST_SYS                    1639      /* system files restored */
#define MSG_REST_FILE_BACKUP            1640      /* files were backed up */
#define MSG_REST_FILENAME               1641      /* filename restored */
#define MSG_REST_SOUR_TARG_SAME         1642      /* source and target are same */
#define MSG_REST_NUM_INVAL_PARA         1643      /* invalid number of para restore */
#define MSG_REST_INVAL_SPEC             15        /* invalid drive */
/* 1744 not used */
#define MSG_REST_NO_FILE_FOUND          1645      /* not files found to restore */
#define MSG_REST_INVAL_PARA             1002      /* invalid parameter %1 */
#define MSG_REST_FILE_SHAR              1642      /* sharing conflict */
/* 1646 - 1647 not used */
#define MSG_REST_LAST_FILE_NOT          1648      /* last file not restored */
#define MSG_REST_SOURCE_NO_BACK         1649      /* source does not contain backup files */
#define MSG_REST_FILE_SEQ_ERROR         1651      /* sequence file out of sequence */
#define MSG_REST_FILE_CREAT_ERROR       110       /* file creation error */
/* 1652 - 1654 not used */
#define MSG_REST_TARG_FULL              112       /* Target is full */
#define MSG_REST_CANNOT_REST_FILE       1655      /* cannot restore file */
#define MSG_REST_DISKETTE               1656      /* diskette %1 */
#define MSG_REST_TARG_DISK              1657      /* insert targ disk in drive %1 */
/* 1658 - 1663 unused */
#define MSG_BACK_NUM_INVAL_PARA         1665      /* inval number of parameters */
#define MSG_BACK_ERROR_LOG_FILE         1664      /* error writing log file */
#define MSG_BACK_INVAL_PARA             1001      /* inval parameter */
/* 1666 not used */
#define MSG_BACK_NO_DRIV_SPEC           1667      /* no drive spec */
#define MSG_BACK_NO_TARG_SPEC           1668      /* no target specified */
#define MSG_BACK_INVAL_PATH             3         /* inval path */
/* 1079 - 1670 not used */
#define MSG_BACK_SOUR_TARG_SAME         1671      /* source target same */
#define MSG_BACK_ERR_FORMAT_UTIL        1672      /* error executing format utility */
#define MSG_BACK_INVAL_DATE             1036      /* inval date */
/* 1673 - 1675 not used */
#define MSG_BACK_INVAL_TIME             1044      /* inval time */
#define MSG_BACK_INVAL_DRIV_SPEC        15        /* inval drive spec */
#define MSG_BACK_CANNOT_FIND_FORM       1676      /* cannot find format util */
#define MSG_BACK_ERROR_OPEN_LOGFILE     1677      /* error open logfile */
#define MSG_BACK_CAN_FORM_UNREM_DR      1678      /* cannot form unremovable drive */
#define MSG_BACK_LAST_NOT_INSERT        1679      /* last disk not inserted */
#define MSG_BACK_LOG_TO_FILE            1680      /* log to file %2 */
#define MSG_BACK_FILE_TARG_DRIVE        1681      /* warning file in target drive %2 */
#define MSG_BACK_FILE_BACK_ERASE        1682      /* files in target drive %c */
#define MSG_BACK_FILE_TO_DRIVE          1683      /* backup up files to drive d */
#define MSG_BACK_DISK_NUM               1684      /* diskette number %2 */
#define MSG_BACK_WARN_NO_FIL_FND        1685      /* warning no files were found to backup */
#define MSG_BACK_INSERT_SOURCE          1686      /* insert backup source diskette in dr d */
#define MSG_BACK_INSERT_BACKUP          1687      /* insert backup source disk %2 in dr */
#define MSG_BACK_UNABLE_TO_BKUP         1688      /* not able to backup file */
#define MSG_BACK_LAST_DISK_DRIVE        1689      /* insert last backup diskette in drive */
#define MSG_BACK_TARG_NOT_USE_BKUP      1690      /* target cannot be used for backup */
#define MSG_BACK_LAST_FILE_NO_BKUP      1691      /* last file not backed up */
#define MSG_BACK_DEVICE_D_IS_FULL       1692      /* fixed backup device d is full */
#define MSG_XCOPY_UNAB_CREATE_DIR       1693      /* unable to create directory */
#define MSG_XCOPY_PATH_TOO_LONG         1694      /* path too long */
#define MSG_XCOPY_BLANK_YN              1695      /* blank y/n */
/* 1696 not used */
#define MSG_XCOPY_READ_SOURCE_FILE      1697      /* reading source file */
#define MSG_XCOPY_FILES_COPIED          1698      /* % files copied */
#define MSG_XCOPY_FILE_NOT_FOUND        1699      /* % file not found */
#define MSG_XCOPY_DOES_SPEC_FILENA      1700      /* Does % specify a filename */
#define MSG_XCOPY_CANNOT_COPY_SUB       1701      /* cannot copy using /s to subdirectory */
/* 1702 not used */
#define MSG_XCOPY_INVAL_PARA            1001      /* invalid parameter xcopy */
/* 1703 not used */
#define MSG_XCOPY_INVAL_NUM_PAR         1704      /* invalid number of parameters xcopy */
#define MSG_ANSI_EXT_SCR_KEY_ON         1705      /* ansi extended screen and keyboard on */
#define MSG_ANSI_EXT_SCR_KEY_OFF        1706      /* ansi extended screen and keyboard off */
#define MSG_ANSI_INVAL_PARA             1001      /* ansi invalid parameter */
/* 1707 not used */
/* 1708 - 1736 basemid */
/* 1737 - 1740 unused */
/* 1739 - 1740 unused */
#define MSG_KEYB_TAB_NOT_EXIST          1741      /* translate table does not exist */
#define MSG_KEYB_READ_TAB               1742      /* error reading translate table file */
#define MSG_KEYB_INVAL_CODE             1454      /* Invalid keyboard layout code */
/* 1743 not used */
#define MSG_KEYB_SYS_ERR                1744      /* System error */
#define MSG_KEYB_CODE_PAGE              1745      /* Code page not available */
#define MSG_KEYB_TOO_MANY_PARMS         1454      /* Too many parms */
/* 1746 not used */
#define MSG_KEYB_DEF_LOAD               1747      /* Default ready loaded */
#define MSG_KEYB_DOS_OPEN_ER            1748      /* Dos open error */
/* 1749 not used */
#define MSG_KEYB_INVAL_TYPE             1750      /* Invalid keyboard type */
#define MSG_KEYB_ERR_LOAD_TRANS         1751      /* Invalid loading translate table */
#define MSG_KEYB_LOADED                 1752      /* translate table loaded */
/* 1753-1760 unused */
#define MSG_CHCP_INVALID_PARAMETER      1761      /* invalid parameter */
#define MSG_CHCP_TASK                   1762      /* unable to set process */
/* 1763 - 1765 unused */
#define MSG_CHCP_REPORT                 1766      /* active code page */
#define MSG_CHCP_SYSTEM                 1767      /* Code page not prepared for system */
#define MSG_CHCP_NO_CP                  1768      /* Code page not set for system */
#define MSG_CHCP_DEVICE                 1769      /* Code page not prepared for device */
/* 1770 - 1772 unused */
#define MSG_START_INVALID_PARAMETER     1773      /* Invalid parameter to start command */
/* 1774-1780 unused */
#define MSG_SPOOLER_FONT_SWITCH         1781      /* error attempting to load font */
#define MSG_SPOOLER_INVAL_CODE_PG       1782      /* code page id not valid */
#define MSG_SPOOLER_ERR_OPEN_FONT       1783      /* error attempt to open font file */
#define MSG_SPOOLER_ERR_READ_FONT       1784      /* error reading font file */
#define MSG_SPOOLER_ERR_READ_CTRL       1784      /* error reading font file ctrl */
#define MSG_SPOOLER_READ_DEFIN          1784      /* error reading font file blocks */
/* 1785 - 1786 not used */
#define MSG_SPOOLER_INVAL_PRINT         1787      /* invalid printer type in devinfo */
#define MSG_SPOOLER_INSUF_STOR          1788      /* insuf storage to activate */
#define MSG_SPOOLER_INCOR_FONT          1789      /* devinfo statement font incorrect */
#define MSG_SPOOLER_INTER_ERR           1790      /* font switching internal error */
#define MSG_SPOOLER_TOO_MANY_ROMS       1791      /* too many roms */
#define MSG_SPOOLER_SOME_FONTS_BAD      1792      /* damaged font files */
/* 1793-1799 unused */
#define MSG_CMD_LOCK_VIOLATION          32        /* lock violation */
/* 1800 - 1803 not used */
#define MSG_CMD_NOT_DOS_DISK            26        /* media store not dos disk */
#define MSG_CMD_NO_MEMORY               8         /* No more memory */
#define MSG_CMD_FILE_NOT_FOUND          1804      /* File not found */
#define MSG_CMD_ACCESS_DENIED           5         /* access denied */
/* 1805 - 1808 not used */
#define MSG_CMD_DRIVE_LOCKED            108       /* drive locked */
#define MSG_CMD_SHARING_VIOLATION       32        /* sharing violation */
#define MSG_CMD_SYS_ERR                 1809      /* A system error occurred */
#define MSG_CMD_DIV_0                   1810      /* process terminated */
#define MSG_CMD_SOFT_ERR                1811      /* fatal software error */
#define MSG_CMD_COPROC                  1812      /* process terminated */
#define MSG_CMD_KILLED                  1813      /* process killed */
#define MSG_CMD_TOO_MANY_OPEN           1814      /* too many open files */
/* 1815 - 1824 unused */
#define MSG_PROG_CANT_FIND_FILE         1825      /* cant find file */
#define MSG_PROG_NO_MEM                 1826      /* cannot process command */
#define MSG_PROG_NON_RECOV              1827      /* cannot process request */
#define MSG_PROG_CNT_START              1828      /* cannot start selected program */
/* 1829  not used */
#define MSG_PROG_NO_MOU                 1830      /* cannot set mou key assign */
#define MSG_PROG_UNEXCEPT_FORMAT        1831      /* unacceptable executable format file */
/* 1832 - 1838 unused */
#define MSG_FDISK_WHOLEDISK_2           1839      /* maximum size */
#define MSG_FDISK_CREATE_DOS_MENU       1840      /* create dos menu */
#define MSG_FDISK_CREATE_DOS_EXT        1841      /* create dos extended partition */
#define MSG_FDISK_CREATE_PRIME_HD       1842      /* create primary menu */
#define MSG_FDISK_CREATE_EXT_HD         1843      /* create extended menu */
#define MSG_FDISK_CREATE_LOG_HD         1844      /* create logical drive */
#define MSG_FDISK_EXT_CREATED           1845      /* extended part created */
#define MSG_FDISK_VOL_CREATED           1846      /* volume created */
/* 1847 not used */
#define MSG_FDISK_DEL_MENU              1848      /* delete menu */
#define MSG_FDISK_DEL_LOG_DRV           1849      /* delete logical drive */
#define MSG_FDISK_DEL_PRIM_DOS          1850      /* delete primary dos partition */
#define MSG_FDISK_DEL_EXT_PART          1851      /* delete extended dos partition */
#define MSG_FDISK_DEL_LOG_HD            1852      /* delete logical drive */
#define MSG_FDISK_ALL_LOG_DEL           1853      /* logical drive deleted */
#define MSG_FDISK_EXT_DEL               1854      /* extended partition deleted */
/* 1855 not used */
#define MSG_FDISK_EXT_PART_DEL          1856      /* extended dos partition deleted */
#define MSG_FDISK_DRV_DEL               1857      /* drive deleted */
/* 1858 not used */
#define MSG_FDISK_CUR_PART_NOT_BOOT     1859      /* the partitions marked is boot */
#define MSG_FDISK_WARN_LOG_LOST         1860      /* data in log drive will be lost */
#define MSG_FDISK_WARN_EXT_LOST         1861      /* data in extended part will be lst */
#define MSG_FDISK_SURE_QUERY            1862      /* are you sure? */
#define MSG_FDISK_LOG_SIZE_INP          1863      /* logical drive size */
#define MSG_FDISK_DISP_LOG_INFO_INP     1864      /* extended partition cont log dr */
#define MSG_FDISK_ESC_TO_DOS            1865      /* press esc to return to dos */
#define MSG_FDISK_DEFAULT_INP           1866      /* 1 */
#define MSG_FDISK_MAX_LOG_SPACE         1867      /* total part avail is cylinders */
#define MSG_FDISK_TOT_PART_SIZE         1868      /* Total partition size is cylinder */
/* 1869 not used */
#define MSG_FDISK_CUR_FDISK_LOG         1870      /* current fixed disk drive */
/* 1871 not used */
#define MSG_FDISK_DRV_LETTERS_CHNGD     1872      /* drive letter have changed or del */
#define MSG_FDISK_BOOT_AL_ACT           1873      /* bootable part on drive 1 is act */
#define MSG_FDISK_EXT_FULL              1874      /* avail space is assign to log dr */
#define MSG_FDISK_NO_BOOT_EXIST         1875      /* only non-boot part on dr 1 */
#define MSG_FDISK_ONLY_CURDRV_PART_ACT  1876      /* only part on drive 1 can be act */
#define MSG_FDISK_MAX_LOGDRV_INS        1877      /* maximum number of log dos dr ins */
/* 1878 not used */
#define MSG_FDISK_CANT_DEL_PRIM         1879      /* cannot delete primary dos part */
#define MSG_FDISK_MAX_AVAIL_SPACE       1880      /* max avail space for partit cyl */
#define MSG_FDISK_LOG_INFO_HD           1881      /* drive start end size */
#define MSG_FDISK_LOG_INFO              1882      /* 1 2 3 4 */
#define MSG_FDISK_PART_INFO             1883      /* 1 2 3 4 5 6 7 8 */
#define MSG_FDISK_ERR_EXT_EXIST         1884      /* extended part already exists */
#define MSG_FDISK_ERR_NO_EXT            1885      /* no extended part to delete */
/* 1886 not used */
#define MSG_FDISK_PART_TOO_SMALL        1887      /* file partition too small */
#define MSG_FDISK_ERR_PART_NOT_BOOT     1859      /* partition selected is not bootable */
#define MSG_FDISK_ERR_NO_LOG_DEF        1888      /* no logical drives defined */
#define MSG_FDISK_ERR_LOG_INP_2_BIG     1889      /* requested log drive size exceeds */
#define MSG_FDISK_ERR_PART_INP_2_BIG    1890      /* requested part size exceeds max */
#define MSG_FDISK_ERR_NO_PART_2_DEL     1891      /* no partitions to delete */
#define MSG_FDISK_ERR_NO_PRIM_PART      1892      /* cannot create extend dos prim dk */
#define MSG_FDISK_ERR_LOG_STILL_EXIST   1893      /* cannot delete extend part log dr */
#define MSG_FDISK_ERR_0_PART_SPEC       1894      /* cannot create a zero cylinder pr */
#define MSG_FDISK_ERR_DRV_DEL           1895      /* drive already deleted */
#define MSG_FDISK_INTERNAL_ERROR        1896      /* internal error */
#define MSG_FDISK_ERR_COMMAND_LINE      1897      /* unsupported switch ignored */
#define MSG_START_NONE                  1898      /* screen group not started */
#define MSG_MODE_COM_PORT               1901      /* query status not available */
#define MSG_MODE_P_IGNORE               1902      /* P option ignored */
/* 1903-1914 unused */
/* 1915-1956 in basemid */
/* 1957-1959 unused */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\utilmid3.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*      SCCSID = @(#)utilmid3.h	5.13 87/05/05 */

#define MSG_SPOOL_WTRUNC_ERROR          1425      /* cannot release filling file - print */
#define MSG_SPOOL_OPEN_ERROR            1426      /* cannot delete filling file - print */
#define MSG_SPOOL_SIG_ERROR             1427      /* cannot delete printing file - print */
#define MSG_SPOOL_MACH_ERROR            1428      /* cannot hold filling file - print */
#define MSG_SPOOL_RUN_PRINT_DATA        1429      /* spool running with print data redir */
#define MSG_SPOOL_RUN_DEVICE            1430      /* spool print run on device */
#define MSG_INSTALL_SIMUL_PIPS          1960      /* pips being executed simultaneously */
#define MSG_INSTALL_UNKNOWN_CMD         1961      /* not recognize cmd in pip */
#define MSG_INSTALL_PANEL_ERROR         1962      /* cannot display panel */
#define MSG_INSTALL_FILE_CREATE_ERR     1963      /* cannot create the file */
#define MSG_INSTALL_LABEL_NOT_FOUND     1964      /* cannot find the label */
#define MSG_INSTALL_FILE_NOT_FOUND      1965      /* cannot find file */
#define MSG_INSTALL_FILE_NAME_ERR       1966      /* unacceptable file name */
#define MSG_INSTALL_FILE_OPEN_ERR       1967      /* file open error */
#define MSG_INSTALL_MEM_ALLOC_ERR       1968      /* memory allocation error */
/* 1969 not used */
#define MSG_INSTALL_UNBAL_COMMENTS      1970      /* cannot read part of pip */
#define MSG_INSTALL_SYNTAX_ERR          1971      /* syntax error */
#define MSG_INSTALL_UNSPEC_CHOICE       1972      /* missing choice parameter */
#define MSG_INSTALL_SHELL_ADD_ERR       1973      /* title on program selector */
#define MSG_INSTALL_DUPLICATE_LABEL     1974      /* duplicate label name */
#define MSG_INSTALL_UNSUCCESSFUL        1975      /* not able to install */
#define MSG_INSTALL_HY_HDR              1976      /* history file header */
#define MSG_INSTALL_HY_TITLE            1977      /* history file title */
#define MSG_INSTALL_HY_CRDATE           1978      /* history file date */
#define MSG_INSTALL_HY_UPDATE           1979      /* history file update */
#define MSG_TRC_NOT_ACTIVE              1397      /* trace not active */
/* 1980 not used */
#define MSG_TRC_ABEND                   1981      /* not properly formatted */
/* 1982 - 1984 not used */
#define MSG_INSTALL_BAD_PIP_EXT         1985      /* bad pip extension */
/* 1986 - 1990 unused */
#define MSG_EDLIN_INVALID_DOS_VER       1991      /* Invalid DOS version$ */
#define MSG_EDLIN_Y_IS_FOR_YES          1992      /* Answer for abort and OK questions */
#define MSG_EDLIN_FILENAME_NOT_SPEC     1993      /* Filename must be specified */
#define MSG_EDLIN_INVALID_PARAMETER     1994      /* Invalid parameter */
#define MSG_EDLIN_FILE_READ_ONLY        1061      /* File is read only */
/* 1995 not used */
#define MSG_EDLIN_TOO_MANY_FILES        1996      /* Too many files are open */
#define MSG_EDLIN_READ_ERROR_IN         1997      /* Read error in %S */
#define MSG_EDLIN_CANNOT_EDIT           1998      /* Cannot edit .BAK file -- rename file */
#define MSG_EDLIN_DISK_FULL             1999      /* Disk full edits lost */
#define MSG_EDLIN_INSUFFICIENT_MEM      8         /* Insufficient memory */
/* 2000not used */
#define MSG_EDLIN_ENTRY_ERROR           2001      /* Syntax entry error */
#define MSG_EDLIN_NEW_FILE              2002      /* New file */
#define MSG_EDLIN_NOT_FOUND             2003      /* Cannot find string specified */
#define MSG_EDLIN_OKAY                  2004      /* Okay OK? */
#define MSG_EDLIN_LINE_TOO_LONG         2005      /* The line is too long */
#define MSG_EDLIN_END_INPUT_FILE        2006      /* End of the input file */
#define MSG_EDLIN_ABORT_EDIT            2007      /* Abort edit Y/N ? */
#define MSG_EDLIN_SPECIFY_LINE_NO       2008      /* Must specify destination line number */
#define MSG_EDLIN_NOT_ENOUGH_ROOM       2009      /* Not enough room to merge entire file */
#define MSG_GRAFT_ENG_VER               2010      /* Eng version */
#define MSG_GRAFT_CANFR_VER             2011      /* Canfrench version */
#define MSG_GRAFT_PORT_VER              2012      /* Portugese version */
#define MSG_GRAFT_NORD_VER              2013      /* Nordic version */
#define MSG_GRAFT_ENG_LOAD              2014      /* Eng version loaded */
#define MSG_GRAFT_CANFR_LOAD            2015      /* Canadian French version loaded */
#define MSG_GRAFT_PORT_LOAD             2016      /* Portugese version loaded */
#define MSG_GRAFT_NORD_LOAD             2017      /* Nordic version loaded */
#define MSG_GRAFT_NO_LOAD               2018      /* No Graftable loaded */
#define MSG_GRAFT_ALREAD_LOAD           2019      /* Graftable already loaded */
#define MSG_GRAFT_INCOR_PARM            1001      /* Graftable incorrect parm */
/* 2020 not used */
#define MSG_GRAFT_PARM_SUP              2021      /* Graftable parameter supported */
/* 2022 - 2024 unused */
/* 2025 - 2031 basemid */
/* 2032 - 2034 unused */
#define MSG_FDISK_ESC_TO_CREATE         2035      /* press escape to create logical drive */
/* 2036 - 2039 unused */
#define MSG_DCOPY_WRITE_ERROR           2040      /* Unrecoverable error writing to */
/* 2041 - 2045 */
#define MSG_APPEND_NO_DIR               2046      /* no append dir */
#define MSG_APPEND_ASSIGN_CONFLICT      2047      /* assign conflict */
#define MSG_APPEND_TOPVIEW_CONFLICT     2048      /* topview conflict */
#define MSG_APPEND_ALREADY_INSTALLED    2049      /* append is already installed */
#define MSG_APPEND_INVAL_PATH_PARM      2050      /* invalid path or parameter */
#define MSG_APPEND_INVAL_PATH           2050      /* invalid path */
#define MSG_APPEND_INCOR_APPEND_VER     2052      /* incorrect append version */
/* 2053 - 2055 */
#define MSG_UNEXPEC_ERROR_ENC           2056      /* unexpected error encountered */
/* 2057 - 2070 basemid */
#define MSG_FMT_SKIPPING                2071      /* skipping ADOS files */
#define MSG_FMT_SYS_SKIP                2072      /* files skipped during xfer */
/* 2073 - 2075 unused */
#define MSG_PROG_DOS                    2076      /* to refer to the PCDOS mode box */
#define MSG_PROG_MORE                   2077      /* more data to be scrolled */
/* 2078 - 2080 unused */
#define MSG_INSTALL_SELECT              2081      /* syntax error SELECT/ESELECT block */
/* 2082 - 2085 unused */
#define MSG_LOST_LIBRARY                2086      /* the library is lost */
#define MSG_SETCOM_OPEN_ERROR           2087      /* unable to open a port */
#define MSG_SETCOM_DISABLE              2088      /* port has been disabled */
#define MSG_SETCOM_ENABLE               2089      /* port has been enabled */
#define MSG_BIND_RESERVED               2090      /* unable to load the program */
/* 2091 - 2999 unused */
/* 3000 - 3100 reserved for IBM Far East */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\utlerror.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/*      SCCSID = @(#)utlerror.h	8.7 87/03/09 */
/* */
/* error codes for utilities */
/* */

#define ERROR_INVALID_DOSVER            1000      /* invalid dos version */
#define ERROR_LANGUAGE_NOT_SUPPORTED    1001      /* language not supported */
#define ERROR_INVALID_FILENAME          1002      /* invalid file name */
#define ERROR_MSGFILE_BAD_FORMAT        1010      /* bad message file format */
#define ERROR_MSGFILE_BAD_MID           1011      /* message file has bad mid */
#define ERROR_MSGFILE_OUTERROR          1012      /* error writing output file */
#define ERROR_MSGFILE_INPERROR          1013      /* error reading input file */
#define ERROR_MSGFILE_SYNTAX            1014      /* syntax error */
#define ERROR_MSGFILE_MSG_TOO_BIG       1015      /* message exceeds system limit */
#define ERROR_INSTALL_FAILED            1016      /* install failed */
#define ERROR_INVALID_VOL               1017      /* no volume with /s option */
#define ERROR_INVALID_INPUT_PARM        1018      /* invalid input parameter */
#define ERROR_FILE_SPEC_REQUIRED        1019      /* file specification required */
#define ERROR_SORT_FILE_TOO_BIG         1020      /* file size to big to sort */
#define ERROR_SORT_INVALID_COL          1021      /* invalid column number for sort */
#define ERROR_CHK_BAD_FAT               1022      /* fat bad on specified drive */
#define ERROR_CHK_BAD_ROOT              1023      /* root bad on specified drive */
#define ERROR_INVALID_PARM_NUMBER       1024      /* invalid parameter number */
#define ERROR_PARM_SYNTAX               1025      /* invalid parameter syntax */
#define ERROR_UTIL_TERMINATED           1026      /* program terminated by user */
#define ERROR_REST_NO_BACKUP            1027      /* source does not contain backup file */
#define ERROR_REST_SEQUENCE_ERROR       1028      /* file sequence error */
#define ERROR_REST_FILE_CREATE          1029      /* file creation error */
#define ERROR_FDISK_ERR_WRITE           1030      /* error writing fixed disk */
#define ERROR_FDISK_ERR_READ            1031      /* error reading fixed disk */
#define ERROR_FDISK_ERR_NOFDISKS        1032      /* no fixed disk present */
#define ERROR_PATCH_NO_CTL_FILE         1033      /* cannot open patch control file */
#define ERROR_PATCH_NO_EXE_FILE         1034      /* cannot open file to patch */
#define ERROR_PATCH_CANT_ALLOC          1035      /* insufficient memory to alloc patch */
#define ERROR_PATCH_INV_CMD_COMBO       1036      /* bad command sequence */
#define ERROR_PATCH_INV_OFFSET          1037      /* invalid offset */
#define ERROR_PATCH_INV_BYTES           1038      /* invalid byte string */
#define ERROR_PATCH_TOO_NEAR_EOF        1039      /* too close to end of file */
#define ERROR_PATCH_VERIFY_FAILED       1040      /* verification failed */
#define ERROR_PATCH_INC_VERIFY          1041      /* offset verification failed */
#define ERROR_SPOOL_INVAL_DEVICE        1042      /* invalid device */
#define ERROR_SPOOL_INVAL_IN_DEV_PAR    1043      /* invalid input device parm */
#define ERROR_SPOOL_INVAL_OUT_DEV_PAR   1044      /* invalid output device parm */
#define ERROR_SPOOL_INVAL_SUB           1045      /* invalid subdirectory */
#define ERROR_SPOOL_INTERN_ERROR        1046      /* internal error */
#define ERROR_SPOOL_DISK_FULL           1047      /* spool disk full */
#define ERROR_SPOOL_CANNOT_PT_NXT_FI    1048      /* cannot print next file */
#define ERROR_SPOOL_CANNOT_PTR_NOW_FI   1049      /* cannot print now */
#define ERROR_XCOPY_CANNOT_COPY_SUB     1050      /* cannot copy subdirectory */
#define ERROR_XCOPY_ITSELF              1051      /* cannot copy to itself */
#define ERROR_DISKC_DRIVE_SPEC          1052      /* drive mismatch in diskcomp/copy */
#define ERROR_FORMAT_FAIL               1053      /* format failed */
#define ERROR_FORMAT_INV_MEDIA          1054      /* format had invalid media */
#define ERROR_RAS_STCP                  1055      /* system trace command processor error */
#define ERROR_RAS_CREATEDD              1056      /* error in create dump diskette */
#define ERROR_XCOPY_UNAB_CREATE_DIR     1057      /* unable to create directory */
#define ERROR_XCOPY_PATH_TOO_LONG       1058      /* path to long */
#define ERROR_XCOPY_CANNOT_TO_RES_DEV   1059      /* can't copy to a reserved name */
#define ERROR_XCOPY_CANNOT_COPY_RES     1060      /* can't copy from a reserved name */
#define ERROR_XCOPY_INVAL_DATE          1061      /* invalid date */
#define ERROR_XCOPY_INTERNAL            1062      /* xcopy internal error */
#define ERROR_PRINT_INVALID_PARAMETER   1063      /* invalid parameter */
#define ERROR_PRINT_FILE_NOT_FOUND      1064      /* file not found */
#define ERROR_PRINT_INVALID_DRIVE       1065      /* invalid drive */
#define ERROR_PRINT_INVALID_DOSVER      1066      /* invalid DOS version */
#define ERROR_PRINT_BAD_ENVIRONMENT     1067      /* bad environment */
#define ERROR_PRINT_MSGFILE_BAD_MID     1068      /* bad message ID */
#define ERROR_PRINT_SYS_INTERNAL        1069      /* PRINT internal error */
#define ERROR_SYS_SYS_INTERNAL          1070      /* SYS internal error */
#define ERROR_SYS_MSGFILE_BAD_MID       1071      /* bad message ID */
#define ERROR_SYS_INVALID_DOSVER        1072      /* invalid DOS version */
#define ERROR_SYS_INVALID_DRIVE         1073      /* invalid drive */
#define ERROR_SYS_INVALID_MEDIA         1074      /* invalid media */
#define ERROR_SYS_INVALID_PARM          1076      /* invalid parameter */
#define ERROR_FORMAT_INTERRUPT          1077      /* format interrupted */
#define ERROR_FORMAT_NO_SYSXFER         1078      /* error in system xfer */
#define ERROR_FORMAT_USER_TERM          1079      /* terminated by N resp */
#define ERROR_BACK_NO_FILES             1080      /* no files found for backup */
#define ERROR_BACK_SHARE_ERROR          1081      /* sharing error during backup */
#define ERROR_BACK_FDISKFULL            1082      /* fixed disk is full during backup */
#define ERROR_BACK_INVTARGET            1083      /* invalid backup target disk */
#define ERROR_BACK_INVTIME              1084      /* invalid time parameter */
#define ERROR_BACK_NOSOURCE             1085      /* no source backup files */
#define ERROR_BACK_NOTARGET             1086      /* no target backup files */
#define ERROR_BACK_SRC_TGT_SAME         1087      /* backup source and target same */
#define ERROR_MSGFILE_DBCS              1088      /* error in message file dbcs */
#define ERROR_HELP_MID_LARGE            1089      /* error in message file dbcs */
#define ERROR_HELP_SYNTAX               1090      /* error in message file dbcs */
#define ERROR_HELP_BAD_MID              1091      /* error in message file dbcs */
#define ERROR_HELP_NO_HELP              1092      /* error in message file dbcs */
#define ERROR_SORT_RCD_SIZE_EXCEED      1093      /* sort record size exceeded */
#define ERROR_CM_EOF_REDIRECT           1094      /* eof found on redr input */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1991, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place (ctype.h in the case of toupper/tolower) for other reasons.
*   [ANSI]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* definition of the return type for the onexit() function */

#ifndef _ONEXIT_T_DEFINED
typedef int (_CDECL * _CDECL onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH      144      /* max. length of full pathname */
#define _MAX_DRIVE   3      /* max. length of drive component */
#define _MAX_DIR       130      /* max. length of path component */
#define _MAX_FNAME   9      /* max. length of file name component */
#define _MAX_EXT     5      /* max. length of extension component */

/* external variable declarations */

extern int _NEAR _CDECL errno;              /* XENIX style error number */
extern int _NEAR _CDECL _doserrno;          /* MS-DOS system error value */
extern char * _NEAR _CDECL sys_errlist[];   /* perror error message table */
extern int _NEAR _CDECL sys_nerr;           /* # of entries in sys_errlist table */

extern char ** _NEAR _CDECL environ;        /* pointer to environment table */

extern unsigned int _NEAR _CDECL _psp;      /* Program Segment Prefix */

extern int _NEAR _CDECL _fmode;             /* default file translation mode */

/* DOS major/minor version numbers */

extern unsigned char _NEAR _CDECL _osmajor;
extern unsigned char _NEAR _CDECL _osminor;

#define DOS_MODE    0   /* Real Address Mode */
#define OS2_MODE    1   /* Protected Address Mode */

extern unsigned char _NEAR _CDECL _osmode;


/* function prototypes */

double _CDECL atof(const char *);
double _CDECL strtod(const char *, char * *);
ldiv_t _CDECL ldiv(long, long);

void   _CDECL abort(void);
int    _CDECL abs(int);
int    _CDECL atexit(void (_CDECL *)(void));
int    _CDECL atoi(const char *);
long   _CDECL atol(const char *);
void * _CDECL bsearch(const void *, const void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
void * _CDECL calloc(size_t, size_t);
div_t  _CDECL div(int, int);
char * _CDECL ecvt(double, int, int *, int *);
void   _CDECL exit(int);
void   _CDECL _exit(int);
char * _CDECL fcvt(double, int, int *, int *);
void   _CDECL free(void *);
char * _CDECL gcvt(double, int, char *);
char * _CDECL getenv(const char *);
char * _CDECL itoa(int, char *, int);
long   _CDECL labs(long);
unsigned long _CDECL _lrotl(unsigned long, int);
unsigned long _CDECL _lrotr(unsigned long, int);
char * _CDECL ltoa(long, char *, int);
void   _CDECL _makepath(char *, char *, char *, char *, char *);
void * _CDECL malloc(size_t);
onexit_t _CDECL onexit(onexit_t);
void   _CDECL perror(const char *);
int    _CDECL putenv(char *);
void   _CDECL qsort(void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
unsigned int _CDECL _rotl(unsigned int, int);
unsigned int _CDECL _rotr(unsigned int, int);
int    _CDECL rand(void);
void * _CDECL realloc(void *, size_t);
void   _CDECL _searchenv(char *, char *, char *);
void   _CDECL _splitpath(char *, char *, char *, char *, char *);
void   _CDECL srand(unsigned int);
long   _CDECL strtol(const char *, char * *, int);
unsigned long _CDECL strtoul(const char *, char * *, int);
void   _CDECL swab(char *, char *, int);
int    _CDECL system(const char *);
char * _CDECL ultoa(unsigned long, char *, int);

#ifndef tolower         /* tolower has been undefined - use function */
int _CDECL tolower(int);
#endif  /* tolower */

#ifndef toupper         /* toupper has been undefined - use function */
int    _CDECL toupper(int);
#endif  /* toupper */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\bootform.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;        %OUT BOOTFORM.INC...
;****************************************************************************
;AN000; - Structure of the Extended IBMBOOT record for DOS -. J.K.
;AN001; - D304 Include PHYDRV, CURHD to the header structure	 11/09/87 J.K.
;****************************************************************************
;
;	****** Warning!  You must include bpb.inc BEFORE you include
;		this file or you will get some wrong offsets but
;		the assembler WILL NOT give you any warning message!!!!!
;

BOOT_SIZE		 EQU	 512
EXT_BOOT_SIGNATURE	 EQU	 41		;Extended boot signature
;
EXT_BPB_INFO		STRUC
EBPB_BYTESPERSECTOR	 DW	 ?
EBPB_SECTORSPERCLUSTER	 DB	 ?
EBPB_RESERVEDSECTORS	 DW	 ?
EBPB_NUMBEROFFATS	 DB	 ?
EBPB_ROOTENTRIES	 DW	 ?
EBPB_TOTALSECTORS	 DW	 ?
EBPB_MEDIADESCRIPTOR	 DB	 ?
EBPB_SECTORSPERFAT	 DW	 ?
EBPB_SECTORSPERTRACK	 DW	 ?
EBPB_HEADS		 DW	 ?
EBPB_HIDDENSECTOR	 DD	 ?
EBPB_BIGTOTALSECTORS	 DD	 ?
EXT_BPB_INFO		ENDS
;
;AN001; EXT_PHYDRV, EXT_CURHD included in the header for OS2.
EXT_IBMBOOT_HEADER	STRUC
EXT_BOOT_JUMP		DB	3 DUP (?)
EXT_BOOT_OEM		DB	8 DUP (?)
EXT_BOOT_BPB		DB	size EXT_BPB_INFO dup (?)
EXT_PHYDRV		DB	80h
EXT_CURHD		DB	0
EXT_BOOT_SIG		DB	EXT_BOOT_SIGNATURE
EXT_BOOT_SERIAL 	DD	?
EXT_BOOT_VOL_LABEL	DB	11 DUP (?)
EXT_SYSTEM_ID		DB	8  DUP (?)
EXT_IBMBOOT_HEADER	ENDS
;
BOOT_SIGNATURE	=     word ptr (BOOT_SIZE-2)

;
;J.K. This is the number of sectors (of size 512 bytes) that will cover
;the size of IBMLOAD program.  IBMBOOT program has to at least read this
;many sectors, and these sectors should be the first cluster and consecutive.
;Make sure IBMBOOT program uses the same value as this.
IBMLOADSIZE	equ	3	;Number of sectors IBMBOOT program should read in.


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\version.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/* --------------------------------------------------------------------------
   *	Use the switch below to produce the standard Microsoft version	    *
   *	or the IBM version of the operating system   			    *
   *									    *
   *									    *
   *	Use the switches below to produce the standard Microsoft version    *
   *	or the IBMversion of the operating system			    *
   *									    *
   *	The below chart will indicate how to set the switches to build	    *
   *	the various versions						     *
   *									    *
   *			      IBMVER	      IBMCOPYRIGHT		    *
   *	  --------------------------------------------------------	    *
   *	   IBM Version	 |     TRUE		 TRUE			    *
   *	  --------------------------------------------------------	    *
   *	   MS Version	 |     FALSE		 FALSE			    *
   *	  --------------------------------------------------------	    *
   *	   Clone Version |     TRUE		 FALSE			    *
   -------------------------------------------------------------------------- */

#define IBMVER	     1
#define IBMCOPYRIGHT 0

#ifndef MSVER
#define MSVER	     1-IBMVER	     /* MSVER = NOT IBMVER	    */
#endif
#define IBM	     IBMVER

/*
*****************************************************************************

		<<< Followings are the DBCS relating Definition >>>


	To build DBCS version, Define DBCS by using CL option via
	Dos environment.

	ex.		set CL=-DDBCS



	To build Country depend version, Define JAPAN, KOREA or TAIWAN
	by using CL option via Dos environment.

	ex.		set CL=-DJAPAN
			set CL=-DKOREA
			set CL=-DTAIWAN

*****************************************************************************
*/

#define BUGFIX	   1


/* #define IBMJAPVER	0   */		/* If TRUE define DBCS also */
#define IBMJAPAN   0



/* -------------------- Set DBCS Blank constant ------------------- */

#ifndef DBCS
#define DB_SPACE 0x2020
#define DB_SP_HI 0x20
#define DB_SP_LO 0x20
#else
	#ifdef JAPAN
	#define DB_SPACE 0x8140
	#define DB_SP_HI 0x81
	#define DB_SP_LO 0x40
	#endif

	#ifdef TAIWAN
	#define DB_SPACE 0x8130
	#define DB_SP_HI 0x81
	#define DB_SP_LO 0x30
	#endif

	#ifdef KOREA
	#define DB_SPACE 0xA1A1
	#define DB_SP_HI 0xA1
	#define DB_SP_LO 0xA1
	#endif
#endif

#ifndef altvect 		    /* avoid jerking off vector.inc	*/
#define ALTVECT    0		    /* Switch to build ALTVECT version	*/
#endif


#if BUGFIX
#pragma message( "BUGFIX switch ON" )
#endif

#ifdef DBCS
#pragma message( "DBCS version build switch ON" )

	#ifdef JAPAN
	#pragma message( "JAPAN version build switch ON" )
	#endif

	#ifdef TAIWAN
	#pragma message( "TAIWAN version build switch ON" )
	#endif

	#ifdef KOREA
	#pragma message( "KOREA version build switch ON" )
	#endif
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\h\versionc.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */


#define  EXPECTED_VERSION_MAJOR     6	    /* DOS Major Version 6 */
#define  EXPECTED_VERSION_MINOR     00	    /* DOS Minor Version 00 */

       /********************************************/
       /*Each C program should: 		   */
       /*					   */
       /* if ((EXPECTED_VERSION_MAJOR != _osmajor) */
       /*   | (EXPECTED_VERSION_MINOR != _osminor))*/
       /*  exit(incorrect_dos_version); 	   */
       /*					   */
       /********************************************/


/* DOS location bits, for use with GetVersion call */

#define DOSHMA			    0x10	/* DOS running in HMA */
#define DOSROM			    0x08	/* DOS running in ROM */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\arena.inc ===
BREAK <Memory arena structure>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;	Revision History:
;
;	M001 - added equates for UMB allocation
;	M002 - added equate for LINK/UNLINK state of UMBs
;	M026 - STRAT_MASK should be HF_MASK AND HO_MASK

;**	Arena Header
;

arena	STRUC
arena_signature     DB	?		; 4D for valid item, 5A for last item
arena_owner	    DW	?		; owner of arena item
arena_size	    DW	?		; size in paragraphs of item
arena_reserved	    DB	3 DUP(?)	; reserved
arena_name	    DB	8 DUP(?)	; owner file name
arena	ENDS

;
; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
; and arena_owner_system are all equal to zero and are contained in DI.  Change
; them and change ALLOC.ASM.
;
; I think I have all of these covered via .errnz - JGL


arena_owner_system	EQU 0		; free block indication

arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
arena_signature_end	EQU 5Ah 	; valid signature, last block in arena


FIRST_FIT	EQU	00000000B
BEST_FIT	EQU	00000001B
LAST_FIT	EQU	00000010B

LOW_FIRST	EQU	00000000B	; M001
HIGH_FIRST	EQU	10000000B	; M001
HIGH_ONLY	EQU	01000000B	; M001

LINKSTATE	EQU	00000001B	; M002

HF_MASK		EQU	NOT HIGH_FIRST	; M001
HO_MASK		EQU	NOT HIGH_ONLY	; M001

STRAT_MASK	EQU	HF_MASK AND HO_MASK	; M001;
						; M026: used to mask of bits
						; M026: 6 & 7 of AllocMethod



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\bdsize.inc ===
BIODATASIZ EQU 00910H
BIOCODESIZ EQU 01A70H
DOSDATASIZ EQU 01370H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\buffer.inc ===
BREAK <Disk I/O Buffer Header>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	BUFFER.INC
;
;	Field definition for I/O buffer information

BUFFINFO	STRUC
buf_next	DW	?		; Pointer to next buffer in list
buf_prev	DW	?		; Pointer to prev buffer in list
buf_ID		DB	?		; Drive of buffer (bit 7 = 0)
					; SFT table index (bit 7 = 1)
					; = FFH if buffer free
buf_flags	DB	?		; Bit 7 = 1 if Remote file buffer
					;	= 0 if Local device buffer
					; Bit 6 = 1 if buffer dirty
					; Bit 5 = Reserved
					; Bit 4 = Search bit (bit 7 = 1)
					; Bit 3 = 1 if buffer is DATA
					; Bit 2 = 1 if buffer is DIR
					; Bit 1 = 1 if buffer is FAT
					; Bit 0 = Reserved
buf_sector	DD	?		; Sector number of buffer (bit 7 = 0)
; The next two items are often refed as a word (bit 7 = 0)
buf_wrtcnt	DB	?		; For FAT sectors, # times sector written out
buf_wrtcntinc	DW	?		; "   "     "   , # sectors between each write
buf_DPB 	DD	?		; Pointer to drive parameters
buf_fill	DW	?		; How full buffer is (bit 7 = 1)
buf_reserved	DB	?		; make DWORD boundary for 386
BUFFINFO	ENDS

buf_offset	EQU	DWORD PTR buf_sector
					;For bit 7 = 1, this is the byte
					;offset of the start of the buffer in
					;the file pointed to by buf_ID.  Thus
					;the buffer starts at location
					;buf_offset in the file and contains
					;buf_fill bytes.

BUFINSIZ	EQU	SIZE BUFFINFO
					; Size of structure in bytes

buf_Free	EQU	0FFh		; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	BUFINSIZ

;
; Buffer Hash Entry Structure
;
;BUFFER_HASH_ENTRY	STRUC		; DOS 4.00
;EMS_PAGE_NUM	DW	-1		; logical page number for EMS handle
;BUFFER_BUCKET	DD	 ?		; pointer to buffers
;DIRTY_COUNT	DB	 0		; number of dirty buffers
;BUFFER_RESERVED DB	 0		; reserved
;BUFFER_HASH_ENTRY	ENDS
;
;MaxBuffinBucket EQU	15		; Max number of buffers per bucket
;MaxBucketinPage EQU	 2		; Max number of buckets per 16kb page
;
;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\bugtyp.inc ===
;**	BUGTYP.INC - Debugging types and levels for MSDOS
;

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


TypAccess   EQU     0001h
    LevSFN	EQU	0000h
    LevBUSY	EQU	0001h

TypShare    EQU     0002h
    LevShEntry	EQU	0000h
    LevMFTSrch	EQU	0001h

TypSect     EQU     0004h
    LevEnter	EQU	0000h
    LevLeave	EQU	0001h
    LevReq	EQU	0002h

TypSMB	    EQU     0008h
    LevSMBin	EQU	0000h
    LevSMBout	EQU	0001h
    LevParm	EQU	0002h
    LevASCIZ	EQU	0003h
    LevSDB	EQU	0004h
    LevVarlen	EQU	0005h

TypNCB	    EQU     0010h
    LevNCBin	EQU	0000h
    LevNCBout	EQU	0001h

TypSeg	    EQU     0020h
    LevAll	EQU	0000h

TypSyscall  EQU     0040h
    LevLog	EQU	0000h
    LevArgs	EQU	0001h
    LevErr	EQU	0002h

TypInt24    EQU     0080h
    LevLog	EQU	0000h

TypProlog   EQU     0100h
    LevLog	EQU	0000h

TypInt	    EQU     0200h
    LevLog	equ	0000h

typFCB	    equ     0400h
    LevLog	equ	0000h
    LevCheck	equ	0001h


ifndef BugLev

    DOSCODE	SEGMENT
	EXTRN	BugLev:word
	EXTRN	BugTyp:word
    DOSCODE	ENDS

endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\chkcpu.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

chkcpu	macro

	jmp	begn
	msg	db	13,10,"This copy of MS-DOS will run only on an 8086",13,10
		db	"or 8088 CPU based computer. This computer is not ",13,10
		db 	"based on an 8086 or 8088 CPU. ",13,10
		db	13,10,"Insert a copy of the appropriate MS-DOS system disk ",13,10
		db	"and press any key to re-boot.",13,10,0

begn:
;------GET_CPU_TYPE------------------------------------------------------------May, 88 by M.Williamson
;  Returns: AX = 0 if 8086 or 8088
;              = 1 if 80286
;              = 2 if 80386
;
	pushf
	push	bx			; preserve bx
	xor	bx, bx			; init bx to zero

	xor	ax,ax			; 0000 into AX
	push	ax			; put it on the stack...
	popf				; ...then shove it into the flags
	pushf				; get it back out of the flags...
	pop	ax			; ...and into ax
	and	ax,0F000h		; mask off high four bits
	cmp	ax,0F000h		; was it all 1's?
	je	scpu_8086		; aye; it's an 8086 or 8088

	mov	ax,0F000h		; now try to set the high four bits..
	push	ax
	popf
	pushf
	pop	ax			; ...and see what happens
	and	ax,0F000h		; any high bits set ?
	jz	scpu_286			; nay; it's an 80286

scpu_386:				; bx starts as zero
	inc	bx			; inc twice if 386
scpu_286:				; just inc once if 286
	inc	bx
scpu_8086:				; don't inc at all if 086
	mov	ax, bx			; put CPU type value in ax
	pop	bx			; restore original bx
	popf

	cmp	ax, 0000
	je	cpu_ok
	push	cs
	pop	ds
	mov	si, offset msg
prnt:	lodsb
	or	al, al
	jz	prnt_done
	mov	ah, 14
	mov	bx, 7
	int	10h
	jmp	prnt

prnt_done:
	xor	ah, ah
	int	16h
	
	int	19h
cpu_ok:
	endm

	 


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\const2.asm ===
;	SCCSID = @(#)const2.asm 1.4 85/07/24
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


Break <Initialized data and data used at DOS initialization>

;
; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.
;

	AsmVars <Debug, Redirector, ShareF>

DOSDATA	SEGMENT WORD PUBLIC 'DATA'

;
; Table of routines for assignable devices
;
; MSDOS allows assignment if the following standard devices:
;   stdin  (usually CON input)
;   stdout (usually CON output)
;   auxin  (usually AUX input)
;   auxout (usually AUX output)
;   stdlpt (usually PRN output)
;
; SPECIAL NOTE:
;   Status of a file is a strange idea.  We choose to handle it in this
;   manner:  If we're not at end-of-file, then we always say that we have a
;   character.	Otherwise, we return ^Z as the character and set the ZERO
;   flag.  In this manner we can support program written under the old DOS
;   (they use ^Z as EOF on devices) and programs written under the new DOS
;   (they use the ZERO flag as EOF).

; Default SFTs for boot up

Public CONST001S,CONST001E
CONST001s	label byte
	PUBLIC	sftabl
sftabl	LABEL	DWORD			; [SYSTEM] file table
	DW	-1			; [SYSTEM] link to next table
	DW	-1			; [SYSTEM] link seg to next table
	DW	sf_default_number	; [SYSTEM] Number of entries in table
	DB	sf_default_number DUP ( (SIZE sf_entry) DUP (0)); [SYSTEM]

; the next two variables relate to the position of the logical stdout/stdin
; cursor.  They are only meaningful when stdin/stdout are assigned to the
; console.
	I_am	CARPOS,BYTE		; [SYSTEM] cursor position in stdin
	I_am	STARTPOS,BYTE		; [SYSTEM] position of cursor at beginning of buffered input call
	I_am	INBUF,128		; [SYSTEM] general device input buffer
	I_am	CONBUF,131		; [SYSTEM] The rest of INBUF and console buffer

	I_am	PFLAG,BYTE		; [SYSTEM] printer echoing flag
	I_am	VERFLG,BYTE		; [SYSTEM] Initialize with verify off
	I_am	CharCo,BYTE,<00000011B> ; [SYSTEM] Allows statchks every 4 chars...
	I_am	chSwitch,BYTE,<'/'>	; UNUSED - obsolete datum, can be reused
	I_am	AllocMethod,BYTE	; [SYSTEM] how to alloc first(best)last
	I_am	fShare,BYTE,<0> 	; [SYSTEM] TRUE => sharing installed
	I_am	DIFFNAM,BYTE,<1>	; [SYSTEM] Indicates when MYNAME has
					;	     changed
	I_am	MYNAME,16,<32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32>
					; [SYSTEM] My network name


;
; The following table is a list of addresses that the sharer patches to be
; PUSH AX to enable the critical sections
;
PUBLIC	CritPatch
CritPatch LABEL WORD
IRP sect,<critDisk,critDevice>
IF (NOT REDIRECTOR) AND (NOT SHAREF)
;
;SR; Change code patch address to a variable in data segment
;
        dw OFFSET DOSDATA: redir_patch
        dw OFFSET DOSDATA: redir_patch

;hkn	Short_Addr  E&sect
;hkn	Short_Addr  L&sect

ELSE
	DW	0
	DW	0
ENDIF
ENDM
	DW	0

;
; WARNING!!!  PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
; Also, IBM server 1.0 requires this also.
;
	EVEN			; Force swap area to start on word boundry
PUBLIC	SWAP_START
SWAP_START	LABEL BYTE
	I_am	ErrorMode,BYTE		; Flag for INT 24 processing
	I_am	INDOS,BYTE,<0>		; DOS status for interrupt processing
	I_am	WPErr,BYTE,<-1> 	; Write protect error flag
	I_am	EXTERR_LOCUS,BYTE	; Extended Error Locus
	I_am	EXTERR,WORD,<0> 	; Extended Error code

;WARNING Following two bytes Accessed as word in $GetExtendedError
	I_am	EXTERR_ACTION,BYTE	; Extended Error Action
	I_am	EXTERR_CLASS,BYTE	; Extended Error Class
; end warning

	I_am	EXTERRPT,DWORD		; Extended Error pointer
	I_am	DMAADD,DWORD,<80h,?>	; User's disk transfer address (disp/seg)
	I_am	CurrentPDB,WORD 	; Current process identifier
	I_am	ConC_spsave,WORD	; saved SP before ^C
	I_am	exit_code,WORD		; exit code of last proc.
	I_am	CURDRV,BYTE		; Default drive (init A)
	I_am	CNTCFLAG,BYTE,<0>	; ^C check in dispatch disabled
					; F.C. 2/17/86
	I_am	CPSWFLAG,BYTE,<0>	; Code Page Switching Flag  DOS 4.00
	I_am	CPSWSAVE,BYTE,<0>	; copy of above in case of ABORT
	EVEN
 PUBLIC Swap_Always
 Swap_Always	LABEL	BYTE
	I_am	USER_IN_AX,WORD 	; User INPUT AX value (used for
					;   extended error type stuff.	NOTE:
					;   does not have Correct value on
					;   1-12, OEM, Get/Set CurrentPDB,
					;   GetExtendedError system calls
	I_am	PROC_ID,WORD,<0>	; PID for sharing (0 = local)
	I_am	USER_ID,WORD,<0>	; Machine for sharing (0 = local)
	I_am	FirstArena,WORD 	; first free block found
	I_am	BestArena,WORD		; best free block found
	I_am	LastArena,WORD		; last free block found
	I_am	EndMem,WORD		; End of memory used in DOSINIT
	I_am	LASTENT,WORD		; Last entry for directory search

	I_am	FAILERR,BYTE,<0>	; NZ if user did FAIL on I 24
	I_am	ALLOWED,BYTE,<0>	; Allowed I 24 answers (see allowed_)
	I_am	NoSetDir,BYTE		; true -> do not set directory
	I_am	DidCTRLC,BYTE		; true -> we did a ^C exit
	I_am	SpaceFlag,BYTE		; true -> embedded spaces are allowed in FCB
; Warning!  The following items are accessed as a WORD in TIME.ASM
	EVEN
	I_am	DAY,BYTE,<0>		; Day of month
	I_am	MONTH,BYTE,<0>		; Month of year
	I_am	YEAR,WORD,<0>		; Year (with century)
	I_am	DAYCNT,WORD,<-1>	; Day count from beginning of year
	I_am	WEEKDAY,BYTE,<0>	; Day of week
; end warning
	I_am	CONSWAP,BYTE		; TRUE => console was swapped during device read
	I_am	IDLEINT,BYTE,<1>	; TRUE => idle int is allowed
	I_am	fAborting,BYTE,<0>	; TRUE => abort in progress

; Combination of all device call parameters
	PUBLIC	DEVCALL 		;
DEVCALL SRHEAD	<>			; basic header for disk packet
	PUBLIC	CALLUNIT
CALLUNIT    LABEL   BYTE		; unit number for disk
CALLFLSH    LABEL   WORD		;
	I_am	CALLMED,BYTE		; media byte
CALLBR	    LABEL   DWORD		;
	PUBLIC	CALLXAD 		;
CALLXAD     LABEL   DWORD		;
	I_am	CALLRBYT,BYTE		;
	PUBLIC	CALLVIDM		;
CALLVIDM    LABEL   DWORD		;
	DB	3 DUP(?)		;
	PUBLIC CallBPB			;
CALLBPB     LABEL   DWORD		;
	I_am	CALLSCNT,WORD		;
	PUBLIC	CALLSSEC
CALLSSEC    LABEL    WORD		;
	    DW	    ?			;
	I_am	CALLVIDRW,DWORD 	;
					;
	I_am	CALLNEWSC,DWORD 	; starting sector for >32mb
	I_am	CALLDEVAD,DWORD 	; stash for device entry point
					;
; Same as above for I/O calls		;
					;
	PUBLIC	IOCall			;
IOCALL	SRHEAD	<>			;
IOFLSH	LABEL	WORD			;
	PUBLIC	IORCHR			;
IORCHR	LABEL	BYTE			;
	I_am	IOMED,BYTE		;
	I_am	IOXAD,DWORD		;
	I_am	IOSCNT,WORD		;
	I_am	IOSSEC,WORD		;
; Call struct for DSKSTATCHK		;
	I_am	DSKSTCALL,2,<DRDNDHL,0> ;
	I_am	DSKSTCOM,1,<DEVRDND>	;
	I_am	DSKSTST,WORD		;
	DB	8 DUP (0)		;
	I_am	DSKCHRET,BYTE		;

;hkn; short_addr has been changed to provide offset in DOSCODE.
;hkn; deviobuf is in DATA seg (DOSDATA)
;hkn        short_addr  DEVIOBUF            ;
	
	DW	offset DOSDATA:DEVIOBUF

	DW	?			; DOS segment set at Init
	I_AM	DSKSTCNT,WORD,<1>	;
	DW	0			;

	I_am	CreatePDB,BYTE		; flag for creating a process
	PUBLIC	Lock_Buffer		;
Lock_Buffer LABEL    DWORD		;MS. DOS Lock Buffer for Ext Lock
	    DD	    ?			;MS. position
	    DD	    ?			;MS. length
CONST001e	label byte


;hkn; the foll. was moved from dosmes.asm.

	EVEN				; needed to maintain offsets

    PUBLIC  UserNum, OEMNum
    Public DMES001S,DMES001E
DMES001S Label byte
USERNUM DW	?			; 24 bit user number
	DB	?
IF	IBM
	IF	IBMCOPYRIGHT
	OEMNUM	DB	0			; 8 bit OEM number
	ELSE
	OEMNUM	DB	0FFH			; 8 bit OEM number
	ENDIF
ELSE
OEMNUM	DB	0FFH
ENDIF


DMES001E label byte


DOSDATA	ENDS



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\bpb.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure.  It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB.  DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it.
;



A_BPB			STRUC
BPB_BYTESPERSECTOR	DW	?
BPB_SECTORSPERCLUSTER	DB	?
BPB_RESERVEDSECTORS	DW	?
BPB_NUMBEROFFATS	DB	?
BPB_ROOTENTRIES 	DW	?
BPB_TOTALSECTORS	DW	?
BPB_MEDIADESCRIPTOR	DB	?
BPB_SECTORSPERFAT	DW	?
BPB_SECTORSPERTRACK	DW	?
BPB_HEADS		DW	?
BPB_HIDDENSECTORS	DW	?
			DW	?
BPB_BIGTOTALSECTORS	DW	?
			DW	?
			DB	6 DUP(?)	; NOTE:  many times these
;						; 	 6 bytes are omitted
;						;	 when BPB manipulations
;						;	 are performed!
A_BPB			ENDS
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\copyrigh.inc ===
;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
;M031 - changed copyright to 1991
;9/16 - changed verison to 6.0 and copyright to 1992
;9/21 - Added international translations, language passed through COUNTRY macro
;B49,50 - changed version to 6 and copyright to 1993

ifdef USA
       DB      "MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
       DB      "Licensed Material - Property of Microsoft "
       DB      "All rights reserved "
endif

ifdef DUT
	DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
	DB	"Licensed Material - Property of Microsoft "
        DB      "All rights reserved "
endif

ifdef FRN 
	DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp"
    	DB  	"Licensed Material - Proprit de Microsoft."
    	DB  	"Tous droits rservs."
endif

ifdef GER 
	DB	"MS-DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp"
	DB  	"Lizensiertes Material - Eigentum von Microsoft  "
        DB  	"Alle Rechte vorbehalten "
endif

ifdef ITN
	DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
	DB	"Licensed Material - Property of Microsoft "
        DB      "All rights reserved "
endif

ifdef POR 
	DB	"MS DOS Versao 6 (C)Copyright 1981-1993 Microsoft Corp"
	DB  	"Material licensiado - Propriedade da Microsoft  "
	DB  	"Todos os direitos reservados "
endif

ifdef SPA 
	DB	"Versin 6 MS DOS (C)Copyright 1981-1993 Microsoft Corp"
	DB  	"Material Bajo Licencia - Propiedad de Microsoft "
        DB  	"Derechos reservados "
endif

ifdef SWE
	DB	"MS-DOS version 6 (C)Copyright 1981-1993 Microsoft Corp "
	DB	"Licensierat material - tillhr Microsoft "
	DB	"Med ensamrtt "
endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\cpmfcb.inc ===
;       SCCSID = @(#)cpmfcb.asm 1.1 85/04/10
;       SCCSID = @(#)cpmfcb.asm 1.1 85/04/10
;BREAK <File Control Block definition>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; Field definition for FCBs
; The FCB has the following structure:
;
;       +---------------------------+
;       |   Drive indicator(byte)   |
;       +---------------------------+
;       |    Filename (8 chars)     |
;       +---------------------------+
;       |    Extension (3 chars)    |
;       +---------------------------+
;       |   Current Extent(word)    |
;       +---------------------------+
;       |    Record size (word)     |
;       +---------------------------+
;       |    File Size (2 words)    |
;       +---------------------------+
;       |       Date of write       |
;       +---------------------------+
;       |       Time of write       |
;       +---------------------------+
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;       +---------------------------+
;       |   8 bytes reserved        |
;       +---------------------------+
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;       |    next record number     |
;       +---------------------------+
;       |   random record number    |
;       +---------------------------+
;

sys_fcb     STRUC
fcb_drive   DB      ?
fcb_name    DB      8 DUP (?)
fcb_ext     DB      3 DUP (?)
fcb_EXTENT  DW      ?
fcb_RECSIZ  DW      ?                   ; Size of record (user settable)
fcb_FILSIZ  DW      ?                   ; Size of file in bytes; used with the
                                        ; following word
fcb_DRVBP   DW      ?                   ; BP for SEARCH FIRST and SEARCH NEXT
fcb_FDATE   DW      ?                   ; Date of last writing
fcb_FTIME   DW      ?                   ; Time of last writing
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
fcb_reserved DB      8 DUP (?)           ; RESERVED
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
fcb_NR      DB      ?                   ; Next record
fcb_RR      DB      4 DUP (?)           ; Random record
sys_fcb     ENDS

FILDIRENT       = fcb_FILSIZ            ; Used only by SEARCH FIRST and SEARCH
                                        ; NEXT

fcb_sfn         EQU     BYTE PTR fcb_reserved

; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
; all must point to the same byte.  Otherwise, the FCBRegen will fail.
; NOTE about this byte (fcb_nsl_drive)
;   The high two bits of this byte are used as follows to indicate the FCB type
;       00 means a local file or device with sharing loaded
;       10 means a remote (network) file
;       01 means a local file with no sharing loaded
;       11 means a local device with no sharing loaded

;
; Network FCB
;
fcb_net_drive   EQU     BYTE PTR fcb_reserved+1
fcb_net_handle  EQU     WORD PTR fcb_reserved+2
fcb_netID       EQU     DWORD PTR fcb_reserved+4

;
; No sharing local file FCB
;
;SR; The definitions of some of the fields have been changed for the new
;FCB implementation. Some extra information from the SFT has been stored 
;into the FCB reserved fields to facilitate regeneration everytime.
;
;fcb_sfn : Bit 7 -- saved read-only attribute bit from SFT
;	   Bit 6 -- saved archive attribute bit from SFT
;	   Bits 5 - 0 -- High order bits of sector number ( 21 - 16 ).
; A sector no. is 22-bits at most so that we can handle upto 2Gb media
;All other fields remain unchanged.

fcb_nsl_drive   EQU     BYTE PTR fcb_reserved+1
fcb_nsl_bits    EQU     BYTE PTR fcb_reserved+2
fcb_nsl_firclus EQU     WORD PTR fcb_reserved+3
fcb_nsl_dirsec  EQU     WORD PTR fcb_reserved+5	;SR; low word of sector no.
fcb_nsl_dirpos  EQU     BYTE PTR fcb_reserved+7

;
; No sharing local device FCB
;
fcb_nsld_drive  EQU     BYTE PTR fcb_reserved+1
fcb_nsld_drvptr EQU     DWORD PTR fcb_reserved+2

;
; Sharing local FCB
;
fcb_l_drive     EQU     BYTE PTR fcb_reserved+1
fcb_l_firclus   EQU     WORD PTR fcb_reserved+2
fcb_l_mfs       EQU     WORD PTR fcb_reserved+4
fcb_l_attr      EQU     BYTE PTR fcb_reserved+6

;
; Bogusness:  the four cases are:
;
;   local file      00
;   local device    40
;   local sharing   C0
;   network         80
;
; Since sharing and network collide, we cannot use a test instruction for
; deciding whether a network or a share check in involved
;
FCBDEVICE   EQU 040h
FCBNETWORK  EQU 080h
FCBSHARE    EQU 0C0h

; FCBSPECIAL must be able to mask off both net and share
FCBSPECIAL  EQU 080h
FCBMASK     EQU 0C0h

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\cputype.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; Note: this must be a macro, and not a subroutine in the BIOS since
; 	it is called from both CODE and SYSINITSEG.
;
;------GET_CPU_TYPE------------------------------------------------------------May, 88 by M.Williamson
;  Returns: AX = 0 if 8086 or 8088
;              = 1 if 80286
;              = 2 if 80386
;
Get_CPU_Type	macro
	pushf
	push	bx			; preserve bx
	xor	bx, bx			; init bx to zero

	xor	ax,ax			; 0000 into AX
	push	ax			; put it on the stack...
	popf				; ...then shove it into the flags
	pushf				; get it back out of the flags...
	pop	ax			; ...and into ax
	and	ax,0F000h		; mask off high four bits
	cmp	ax,0F000h		; was it all 1's?
	je	cpu_8086		; aye; it's an 8086 or 8088

	mov	ax,0F000h		; now try to set the high four bits..
	push	ax
	popf
	pushf
	pop	ax			; ...and see what happens
	and	ax,0F000h		; any high bits set ?
	jz	cpu_286			; nay; it's an 80286

cpu_386:				; bx starts as zero
	inc	bx			; inc twice if 386
cpu_286:				; just inc once if 286
	inc	bx
cpu_8086:				; don't inc at all if 086
	mov	ax, bx			; put CPU type value in ax
	pop	bx			; restore original bx
	popf
	endm

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\curdir.inc ===
BREAK <Current directory list structure>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	CDS - Current Directory Structure
;
; CDS items are used bu the internal routines to store cluster numbers and
; network identifiers for each logical name.  The ID field is used dually,
; both as net ID and for a cluster number for local devices.  In the case
; of local devices, the cluster number will be -1 if there is a potential
; of the disk being changed or if the path must be recracked.
;
;	Some pathnames have special preambles, such as
;
;		\\machane\sharename\...
;	For these pathnames we can't allow ".." processing to back us
;	up into the special front part of the name.  The CURDIR_END field
;	holds the address of the seperator character which marks
;	the split between the special preamble and the regular
;	path list; ".." processing isn't allowed to back us up past
;	(i.e., before) CURDIR_END
;	For the root, it points at the leading /.  For net
;	assignments it points at the end (nul) of the initial assignment:
;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
;	  ^		 ^		     ^


DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

CURDIR_LIST	STRUC
CURDIR_TEXT	DB	DIRSTRLEN DUP (?)   ; text of assignment and curdir
CURDIR_FLAGS	DW	?		; various flags
CURDIR_DEVPTR	DD	?		; local pointer to DPB or net device
CURDIR_ID	DW	2 dup (?)	; cluster of current dir (net ID)
CURDIR_USER_WORD DW	?
CURDIR_END	DW	?		; index to ".." backup limit - see above
CURDIR_TYPE	DB	?		; IFS drive (2=ifs, 4=netuse)
CURDIR_IFS_HDR	DD	?		; Ptr to File System Header
CURDIR_FSDA	DB	2 DUP (?)	; File System Dependent Data Area
CURDIR_LIST	ENDS

curdirLen	EQU	Size CURDIR_list	; Needed for screwed up
						; ASM87 which doesn't allow
						; Size directive as a macro
						; argument
CURDIR_netID	EQU	DWORD PTR CURDIR_ID


;**	Flag values for CURDIR_FLAGS

CURDIR_isnet	EQU	1000000000000000B
CURDIR_isifs	EQU	1000000000000000B
CURDIR_inuse	EQU	0100000000000000B
CURDIR_splice	EQU	0010000000000000B
CURDIR_local	EQU	0001000000000000B

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\doscntry.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;Equates for COUNTRY INFORMATION.
SetCountryInfo		EQU	1	;country info
SetUcase		EQU	2	;uppercase table
SetLcase		EQU	3	;lowercase table (Reserved)
SetUcaseFile		EQU	4	;uppercase file spec table
SetFileList		EQU	5	;valid file character list
SetCollate		EQU	6	;collating sequence
SetDBCS 		EQU	7	;double byte character set
SetALL			EQU	-1	;all the entries


;DOS country and code page information table structure.
;Internally, DOS gives a pointer to this table.
;IBMBIO, MODE and NLSFUNC modules communicate with DOS through
;this structure.
DOS_country_cdpg_info struc
ccInfo_reserved 	db	8 dup (?) ;reserved for internal use
ccPath_CountrySys	db	64 dup (0);path and filename for country info
ccSysCodePage		dw	0	;system code page id
ccNumber_of_entries	dw	6	; 6 entries
ccSetUcase		db	SetUcase
ccUcase_ptr		dd	?	;pointer to Ucase table

ccSetUcaseFile		db	SetUcaseFile
ccFileUcase_ptr 	dd	?	;pointer to File Ucase table

ccSetFileList		db	SetFileList
ccFileChar_ptr		dd	?	;pointer to File char list table

ccSetCollate		db	SetCollate
ccCollate_ptr		dd	?	;pointer to collate table

ccSetDBCS		db	SetDBCS
ccDBCS_ptr		dd	?	;pointer to DBCS  table

ccSetCountryInfo	db	SetCountryInfo
ccCountryInfoLen	dw	?	;length of country info
ccDosCountry		dw	?	;active country code id
ccDosCodePage		dw	?	;active code page id
ccDFormat		dw	?	;date format
ccCurSymbol		db	"    ",0;5 byte of (currency symbol+0)
cc1000Sep		db	" ",0   ;2 byte of (1000 sep. + 0)
ccDecSep		db	" ",0   ;2 byte of (Decimal sep. + 0)
ccDateSep		db	" ",0   ;2 byte of (date sep. + 0)
ccTimeSep		db	" ",0   ;2 byte of (time sep. + 0)
ccCFormat		db	?	;currency format flags
ccCSigDigits		db	?	;# of digits in currency
ccTFormat		db	?	;time format
ccMono_Ptr		dd	?	;monocase routine entry point
ccListSep		db	" ",0   ;data list separator
ccReserved_area 	dw	5 dup(?);reserved

DOS_country_cdpg_info ends

;Ucase table
CC_UCASE_TAB	struc
ccUcase_leng	       dw	128
ccUcase_data	       db	128 dup (?)
CC_UCASE_TAB	ends

;File Ucase table
CC_FILE_UCASE_TAB	struc
ccFileucase_leng	dw	128
ccFileucase_data	db	128 dup (?)
CC_FILE_UCASE_TAB	ends

;File char list
CC_FILE_CHAR_TAB	struc
ccFilechar_leng 	dw	?
ccFilechar_data 	db	46 dup (?)
CC_FILE_CHAR_TAB	ends

;collate table
CC_COLLATE_TAB	struc
ccCollate_leng		dw	256
ccCollate_data		db	256 dup (?)
CC_COLLATE_TAB	ends

;DBCS table -  for DOS 4.00
CC_DBCS_TAB	struc
ccDBCS_leng	       dw      6
ccDBCS_data	       db      6 dup (?)
CC_DBCS_TAB	ends

;						2/12/KK
; Define subfunctions of ECS_call ( 63H )	2/12/KK
;						2/12/KK
GetLeadBTBL	EQU	0	;		2/12/KK
SetInterimMode	EQU	1	;		2/12/KK
GetInterimMode	EQU	2	;		2/12/KK
				;		2/12/KK
NonInterimMode	EQU	0	;		2/12/KK
InterimMode	EQU	1	;		2/12/KK

OLD_COUNTRY_SIZE    equ     (size DOS_country_cdpg_info - ccDFormat - 10)
NEW_COUNTRY_SIZE    equ     (size DOS_country_cdpg_info - ccDosCountry)

;CAPITALIZATION equates
CAP_ONE_CHAR	    equ      20H
CAP_STRING	    equ      21H
CAP_ASCIIZ	    equ      22H
CHECK_YES_NO	    equ      23H
UPPER_TABLE	    equ      80H

;NLS_YES	     equ      59H
;NLS_yes2	     equ      79H
;NLS_NO 	     equ      4EH
;NLS_no2	     equ      6EH

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dirent.inc ===
;**	Break <Directory entry>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	NOTE:  These offsets are also used in the DTA for
;	extended FCB SearchFirst/Next.  DIR_NAME lines up
;	with the FCB filename field, and the rest of the
;	DIR_ENTRY fields follow.  -DavidOls

;**	DIRENT.INC - FAT Directory Entry Definition
;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

DIR_ENTRY   STRUC
DIR_NAME    db	    11 DUP (?)	; file name
DIR_ATTR    db	    ?		; attribute bits
DIR_CODEPG  dw	    ?		; code page DOS 4.00
DIR_EXTCLUSTER dw	?		; extended attribute starting cluster
DIR_ATTR2   db	    ?		; reserved
DIR_PAD     db	    5  DUP (?)	; reserved for expansion
DIR_TIME    dw	    ?		; time of last write
DIR_DATE    dw	    ?		; date of last write
DIR_FIRST   dw	    ?		; first allocation unit of file
DIR_SIZE_L  dw	    ?		; low 16 bits of file size
DIR_SIZE_H  dw	    ?		; high 16 bits of file size

;	    Caution:  An extended FCB SearchFirst/Next on a network
;	    drive under Novell Netware 286 or 386 returns the time/date
;	    in the SIZE fields for subdirectory files.  Ordinarily,
;	    this field is zero for subdirectory files.

DIR_ENTRY   ENDS

ATTR_READ_ONLY	equ	 1h
ATTR_HIDDEN	equ	 2h
ATTR_SYSTEM	equ	 4h
ATTR_VOLUME_ID	equ	 8h
ATTR_DIRECTORY	equ	10h
ATTR_ARCHIVE	equ	20h
ATTR_DEVICE	equ	40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

ATTR_ALL	equ	attr_hidden+attr_system+attr_directory
				; OR of hard attributes for FINDENTRY

ATTR_IGNORE	equ	attr_read_only+attr_archive+attr_device
				; ignore this(ese) attribute(s) during
				; search first/next

ATTR_CHANGEABLE equ	attr_read_only+attr_hidden+attr_system+attr_archive
				; changeable via CHMOD


DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\devsym.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DevSym.inc - Device Symbols
;
; 	Revision History: 
;
;	M018 - defined bit 11 of DOS34_FLAG. See M041 in dos.tag for 
;	       explanation.
;


;	THE DEVICE TABLE LIST HAS THE FORM:

SYSDEV	       STRUC
SDEVNEXT       DD    ?		    ;POINTER TO NEXT DEVICE HEADER
SDEVATT        DW    ?		    ;ATTRIBUTES OF THE DEVICE
SDEVSTRAT      DW    ?		    ;STRATEGY ENTRY POINT
SDEVINT        DW    ?		    ;INTERRUPT ENTRY POINT
SDEVNAME       DB    '        '	    ;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
SYSDEV	       ENDS

;
; ATTRIBUTE BIT MASKS
;
; CHARACTER DEVICES:
;
; BIT 15 -> MUST BE 1
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versions of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> UNUSED
;      5 -> UNUSED
;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
;      3 -> 1 IF DEVICE IS CLOCK DEVICE
;      2 -> 1 IF DEVICE IS NULL DEVICE
;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
;      0 -> 1 IF DEVICE IS CONSOLE INPUT
;
; BLOCK DEVICES:
;
; BIT 15 -> MUST BE 0
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
;	    THE SAME PLACE.
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versionso of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
;      5 -> UNUSED
;      4 -> UNUSED
;      3 -> UNUSED
;      2 -> UNUSED
;      1 -> UNUSED
;      0 -> UNUSED
;

DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
CHARDEV        EQU   8000H
DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
				    ;  COMP MEDIA.
OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
				    ;  NOT.  CURRENTLY BLOCK ONLY.
DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
				    ;  ENTRY POINTS, 0 IF NOT

EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
				    ;  THIS BIT IS RESERVED FOR FUTURE USE
				    ;  TO EXTEND THE DEVICE HEADER BEYOND
				    ;  ITS CURRENT FORM.

; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
;    MACHINES (FORMAT,CHKDSK,RECOVER,..).

; M017 IOQUERY	       EQU   0100H	    ;Bit 8 - Supports generic IOCtl query
IOQUERY	       EQU   080H	    ;Bit 7 - Supports generic IOCtl query M017


DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
				    ;DEVICE SUPPORTS SET/GET MAP OF
				    ;LOGICAL DRIVES, AND SUPPORTS
				    ;GENERIC IOCTL CALLS.
				    ;FOR CHARACTER DEVICES, THIS
				    ;DEVICE SUPPORTS GENERIC IOCTL.
				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
EXTDRVR        EQU   0002H	    ;BIT 1 - BLOCK DEVICE EXTNDED DRIVER



;STATIC REQUEST HEADER
SRHEAD	       STRUC
REQLEN	       DB    ?		    ;LENGTH IN BYTES OF REQUEST BLOCK
REQUNIT        DB    ?		    ;DEVICE UNIT NUMBER
REQFUNC        DB    ?		    ;TYPE OF REQUEST
REQSTAT        DW    ?		    ;STATUS WORD
	       DB    8 DUP(?)	    ;RESERVED FOR QUEUE LINKS
SRHEAD	       ENDS

;STATUS WORD MASKS
STERR	       EQU   8000H	    ;BIT 15 - ERROR
STBUI	       EQU   0200H	    ;BIT 9 - BUISY
STDON	       EQU   0100H	    ;BIT 8 - DONE
STECODE        EQU   00FFH	    ;ERROR CODE
;						  2/12/KK
; Interim  character identifier 		  2/12/KK
Ddkey		EQU	0000010000000000B	; 2/12/KK

;FUNCTION CODES
DINITHL        EQU   26 	    ;SIZE OF INIT HEADER
DMEDHL	       EQU   15 	    ;SIZE OF MEDIA CHECK HEADER
DBPBHL	       EQU   22 	    ;SIZE OF GET BPB HEADER
DRDWRHL        EQU   22 	    ;SIZE OF RD/WR HEADER
DRDNDHL        EQU   14 	    ;SIZE OF NON DESTRUCTIVE READ HEADER
DSTATHL        EQU   13 	    ;SIZE OF STATUS HEADER
DFLSHL	       EQU   15 	    ;SIZE OF FLUSH HEADER

DEVINIT        EQU   0		    ;INITIALIZATION
DEVMDCH        EQU   1		    ;MEDIA CHECK
DEVBPB	       EQU   2		    ;GET BPB
DEVRDIOCTL     EQU   3		    ;IOCTL READ
DEVRD	       EQU   4		    ;READ
DEVRDND        EQU   5		    ;NON DESTRUCTIVE READ NO WAIT (CHARACTER DEVS)
DEVIST	       EQU   6		    ;INPUT STATUS
DEVIFL	       EQU   7		    ;INPUT FLUSH
DEVWRT	       EQU   8		    ;WRITE
DEVWRTV        EQU   9		    ;WRITE WITH VERIFY
DEVOST	       EQU   10 	    ;OUTPUT STATUS
DEVOFL	       EQU   11 	    ;OUTPUT FLUSH
DEVWRIOCTL     EQU   12 	    ;IOCTL WRITE
DEVOPN	       EQU   13 	    ;DEVICE OPEN
DEVCLS	       EQU   14 	    ;DEVICE CLOSE
DOPCLHL        EQU   13 	    ;SIZE OF OPEN/CLOSE HEADER
DEVRMD	       EQU   15 	    ;REMOVABLE MEDIA
REMHL	       EQU   13 	    ;SIZE OF REMOVABLE MEDIA HEADER
GENIOCTL       EQU   19

; THE NEXT THREE ARE USED IN DOS 4.0
;		     20
;		     21
;		     22

DEVGETOWN      EQU   23 	    ;GET DEVICE OWNER
DEVSETOWN      EQU   24 	    ;SET DEVICE OWNER
IOCTL_QUERY    EQU   25		    ;Query generic ioctl support

OWNHL	       EQU   13 	    ;SIZE OF DEVICE OWNER HEADER

DEVOUT	       EQU   16 	    ; OUTPUT UNTIL BUSY.

DEVOUTL        EQU   DEVWRT	    ; LENGTH OF OUTPUT UNTIL BUSY

; ADDED FOR DOS 5.00
;


; GENERIC IOCTL REQUEST STRUCTURE
;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
;
IOCTL_REQ      STRUC
	       DB    (SIZE SRHEAD) DUP(?)
				    ; GENERIC IOCTL ADDITION.
MAJORFUNCTION  DB    ?		    ;FUNCTION CODE
MINORFUNCTION  DB    ?		    ;FUNCTION CATEGORY
REG_SI	       DW    ?
REG_DI	       DW    ?
GENERICIOCTL_PACKET DD ?	    ; POINTER TO DATA BUFFER
IOCTL_REQ      ENDS

;	DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
GEN_IOCTL_WRT_TRK   EQU   40H
GEN_IOCTL_RD_TRK    EQU   60H
GEN_IOCTL_FN_TST    EQU   20H	    ; USED TO DIFF. BET READS AND WRTS

;; 32-bit absolute read/write input list structure

ABS_32RW	 STRUC
SECTOR_RBA	 DD	 ?	    ; relative block address
ABS_RW_COUNT	 DW	 ?	    ; number of sectors to be transferred
BUFFER_ADDR	 DD	 ?	    ; data addrress
ABS_32RW	 ENDS

;; media ID info

MEDIA_ID_INFO	 STRUC
MEDIA_level	 DW	 0	    ; info level
MEDIA_Serial	 DD	 0	    ; serial #
MEDIA_Label	 DB	 11 dup (' ') ;volume label
MEDIA_System	 DB	 8  dup (' ') ;system type
MEDIA_ID_INFO	 ENDS

;; equates for DOS34_FLAG
;
; BUGBUG: why are bits 0,1,3 and 4 not defined.
;

FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
					    ;M018: that knows how to handle 
					    ;M018: open for exec

NO_FROM_DISK_RESET    EQU   NOT FROM_DISK_RESET	;not from disk reset
NO_Force_I24_Fail     EQU   NOT Force_I24_Fail	;not form IFS CALL BACK
NO_Disable_EOF_I24    EQU   NOT Disable_EOF_I24

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dseg.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;---Revised 8-17-84 FOR KBX	(ADDED ADDITIONAL KEYBOARD FLAG - KB_FLAG_3)
;----------------------------------------
;	 0286 INTERRUPT LOCATIONS (READ):
;----------------------------------------
ABS0	SEGMENT AT 0
STG_LOC0		LABEL	BYTE
	ORG 2*4
NMI_PTR 		LABEL	WORD
	ORG 5*4
INT5_PTR		LABEL	WORD
	ORG 8*4
INT_ADDR		LABEL	WORD
INT_PTR 		LABEL	DWORD
	ORG 10H*4
VIDEO_INT		LABEL	WORD
	ORG 13H*4			; NEW FDISK
ORG_VECTOR		LABEL	DWORD
	ORG 18H*4
BASIC_PTR		LABEL	WORD
	ORG 19H*4
BOOT_VEC		LABEL	DWORD
BOOT_VECTOR		LABEL	DWORD
	ORG 1DH*4
PARM_PTR		LABEL	DWORD	; POINTER TO VIDEO PARMS
	ORG 1EH*4
DISK_POINTER		LABEL	DWORD
	ORG 01FH*4
EXT_PTR 		LABEL	DWORD
	ORG 40H*4			; DISKETTE POINTER
DISK_VECTOR		LABEL	DWORD
       ORG 41H*4
HF_TBL_VEC		LABEL	DWORD
	ORG 46H*4
HF1_TBL_VEC		LABEL	DWORD
	ORG 70H*4
SLAVE_INT_PTR		LABEL	DWORD
RTC_INT_VEC		LABEL	DWORD	; REAL TIME CLOCK INT
	ORG 76H*4			; FIXED DISK INTERRUPT VECTOR
HDISK_INT		LABEL	DWORD
	ORG	400H
DATA_AREA		 LABEL BYTE	;ABSOLUTE LOCATION OF DATA SEGMENT
DATA_WORD		 LABEL WORD
	ORG	0500H
MFG_TEST_RTN		 LABEL	FAR
	ORG	7C00H
BOOT_LOCN		 LABEL	FAR
ABS0	ENDS
PAGE
;------------------------------------------------
; STACK -- USED DURING INITIALIZATION ONLY	:
;------------------------------------------------
STACK	SEGMENT AT 30H
	DW	128 DUP(?)
TOS	LABEL	WORD
STACK	ENDS
;----------------------------------------
;	ROM BIOS DATA AREAS		:
;----------------------------------------
DATA	SEGMENT AT 40H
;DATA_BASE	 LABEL	 BYTE
RS232_BASE	DW	4 DUP(?)	; ADDRESSES OF RS232 ADAPTERS
PRINTER_BASE	DW	4 DUP(?)	; ADDRESSES OF PRINTERS
EQUIP_FLAG	DW	1 DUP(?)	; INSTALLED HARDWARE
MFG_TST 	DB	1 DUP(?)	; INITIALIZATION FLAG
MEMORY_SIZE	DW	1 DUP(?)	; MEMORY SIZE IN K BYTES
MFG_ERR_FLAG	DB	1 DUP(?)	; SCRATCHPAD FOR MANUFACTURING
		DB	1 DUP(?)	; ERROR CODES
PAGE
;----------------------------------------
;	KEYBOARD DATA AREAS		:
;----------------------------------------
KB_FLAG 	DB	1 DUP(?)
KB_FLAG_1	DB	1 DUP(?)	; SECOND BYTE OF KEYBOARD STATUS
ALT_INPUT	DB	1 DUP(?)	; STORAGE FOR ALTERNATE KEYPAD ENTRY
BUFFER_HEAD	DW	1 DUP(?)	; POINTER TO HEAD OF KEYBOARD BUFFER
BUFFER_TAIL	DW	1 DUP(?)	; POINTER TO TAIL OF KEYBOARD BUFFER
KB_BUFFER	DW	16 DUP(?)	; ROOM FOR 15 ENTRIES
KB_BUFFER_END	LABEL	WORD

;------ HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY

;----------------------------------------
;	DISKETTE DATA AREAS		:
;----------------------------------------
SEEK_STATUS	DB	1 DUP(?)	; DRIVE RECALIBRATION STATUS
					; BIT 3-0 = DRIVE 3-0 NEEDS RECAL
					; BEFORE NEXT SEEK IF BIT IS = 0
MOTOR_STATUS	DB	1 DUP(?)	; MOTOR STATUS
					; BIT 3-0 = DRIVE 3-0 IS CURRENTLY
					;   RUNNING
					; BIT 7 = CURRENT OPERATION IS A WRITE,
					;   REQUIRES DELAY
MOTOR_COUNT	DB	1 DUP(?)	; TIME OUT COUNTER FOR DRIVE TURN OFF
DISKETTE_STATUS DB	1 DUP(?)	; RETURN CODE STATUS BYTE
CMD_BLOCK	LABEL	BYTE
HD_ERROR	LABEL	BYTE
NEC_STATUS	DB	7 DUP(?)	; STATUS BYTES FROM NEC
PAGE
;----------------------------------------
;	VIDEO DISPLAY DATA AREA 	:
;----------------------------------------
CRT_MODE	DB	1 DUP(?)	; CURRENT CRT MODE
CRT_COLS	DW	1 DUP(?)	; NUMBER OF COLUMNS ON SCREEN
CRT_LEN 	DW	1 DUP(?)	; LENGTH OF REGEN IN BYTES
CRT_START	DW	1 DUP(?)	; STARTING ADDRESS IN REGEN BUFFER
CURSOR_POSN	DW	8 DUP(?)	; CURSOR FOR EACH OF UP TO 8 PAGES
CURSOR_MODE	DW	1 DUP(?)	; CURRENT CURSOR MODE SETTING
ACTIVE_PAGE	DB	1 DUP(?)	; CURRENT PAGE BEING DISPLAYED
ADDR_6845	DW	1 DUP(?)	; BASE ADDRESS FOR ACTIVE DISPLAY CARD
CRT_MODE_SET	DB	1 DUP(?)	; CURRENT SETTING OF THE 3X8 REGISTER
CRT_PALLETTE	DB	1 DUP(?)	; CURRENT PALLETTE SETTING COLOR CARD
PAGE
;----------------------------------------
;	POST DATA AREA			:
;----------------------------------------
IO_ROM_INIT	DW	1 DUP(?)	; PNTR TO OPTIONAL I/O ROM INIT ROUTINE
IO_ROM_SEG	DW	1 DUP(?)	; POINTER TO IO ROM SEGMENT
INTR_FLAG	DB	1 DUP(?)	; FLAG TO INDICATE AN INTERRUPT HAPPEND
;----------------------------------------
;	TIMER DATA AREA 		:
;----------------------------------------
TIMER_LOW	DW	1 DUP(?)	; LOW WORD OF TIMER COUNT
TIMER_HIGH	DW	1 DUP(?)	; HIGH WORD OF TIMER COUNT
TIMER_OFL	DB	1 DUP(?)	; TIMER HAS ROLLED OVER SINCE LAST READ
;----------------------------------------
;	SYSTEM DATA AREA		:
;----------------------------------------
BIOS_BREAK	DB	1 DUP(?)	; BIT 7=1 IF BREAK KEY HAS BEEN HIT
RESET_FLAG	DW	1 DUP(?)	; WORD=1234H IF KEYBOARD RESET UNDERWAY
PAGE
;----------------------------------------
;	HARD FILE DATA AREAS		:
;----------------------------------------
DISK_STATUS1	DB	1 DUP(?)
HF_NUM		DB	1 DUP(?)
CONTROL_BYTE	DB	1 DUP(?)
PORT_OFF	DB	1 DUP(?)
;------------------------------------------------------
;	PRINTER AND RS232 TIME-OUT VARIABLES	      :
;------------------------------------------------------
PRINT_TIM_OUT	DB	4 DUP(?)
RS232_TIM_OUT	DB	4 DUP(?)
;----------------------------------------
;	ADDITIONAL KEYBOARD DATA AREA	:
;----------------------------------------
BUFFER_START	DW	1 DUP(?)
BUFFER_END	DW	1 DUP(?)
;---------------------------------------
;	ADDITIONAL FLOPPY DATA	       ;
;---------------------------------------
	ORG	8BH
LASTRATE	DB	1 DUP(?)	; LAST DATA RATE SELECTED
PAGE
;---------------------------------------
;	ADDITIONAL HARD FILE DATA      :
;---------------------------------------
	ORG	8CH
HF_STATUS	DB	1 DUP(?)	; STATUS REGISTER
HF_ERROR	DB	1 DUP(?)	; ERROR REGISTER
HF_INT_FLAG	DB	1 DUP(?)	; HARD FILE INTERRUPT FLAG
HF_CNTRL	DB	1 DUP(?)	; COMBO HARD FILE/FLOPPY CARD BIT 0=1
;----------------------------------------
;	ADDITIONAL DISKETTE AREA       :
;----------------------------------------
	ORG	90H
DSK_STATE	LABEL	BYTE
		DB	1 DUP(?)	; DRIVE 0 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 1 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 0 OPERATION START STATE
		DB	1 DUP(?)	; DRIVE 1 OPERATION START STATE
DSK_TRK 	DB	1 DUP(?)	; DRIVE 0 PRESENT CYLINDER
		DB	1 DUP(?)	; DRIVE 1 PRESENT CYLINDER
		DB	1 DUP(?)	; RESERVED
;----------------------------------------				AEV
;	ADDITIONAL KEYBOARD FLAG FOR KBX:				AEV
;----------------------------------------				AEV
	ORG	96H			;				AEV
KB_FLAG_3	DB	1 DUP(?)	;				AEV
;----------------------------------------
;	ADDITIONAL KEYBOARD LED FLAG	:
;----------------------------------------
	ORG	97H
KB_FLAG_2	DB	1 DUP(?)
PAGE
;----------------------------------------
;	REAL TIME CLOCK DATA AREA	:
;----------------------------------------
	ORG	98H
USER_FLAG	DW	1 DUP(?)	; OFFSET ADDR OF USERS WAIT FLAG
USER_FLAG_SEG	DW	1 DUP(?)	; SEG ADDR OF USER WAIT FLAG
RTC_LOW 	DW	1 DUP(?)	; LOW WORD OF USER WAIT FLAG
RTC_HIGH	DW	1 DUP(?)	; HIGH WORD OF USER WAIT FLAG
RTC_WAIT_FLAG	DB	1 DUP(?)	; WAIT ACTIVE FLAG
DATA	ENDS
;----------------------------------------
;	EXTRA DATA AREA 		:
;----------------------------------------
XXDATA	SEGMENT AT 50H
STATUS_BYTE	DB	1 DUP(?)
XXDATA	ENDS
;----------------------------------------
;	VIDEO DISPLAY BUFFER		:
;----------------------------------------
VIDEO_RAM	SEGMENT AT 0B800H
REGEN	LABEL	BYTE
REGENW	LABEL	WORD
	DB	16384 DUP(?)
VIDEO_RAM	ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dosmac.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Macro definitions for MSDOS.
;
;       Revision history:
;        	M019 DB 10/26/90 - Added Cmp32 macro.

TRUE    EQU 0FFFFh
FALSE   EQU 0

SUBTTL BREAK a listing into pages and give new subtitles
PAGE
BREAK   MACRO   subtitle
	SUBTTL  subtitle
	PAGE
ENDM
.xcref  break

BREAK   <ASMVAR - handle assembly variables once and for all>

AsmVars Macro   varlist
IRP     var,<varlist>
AsmVar  var
ENDM
ENDM

AsmVar  Macro   var
IFNDEF  var
var = FALSE
ENDIF
ENDM

BREAK <I_NEED: declare a variable external, if necessary, and allocate a size>

;
; declare a variable external and allocate a size
;
AsmVar  InstalledData
I_NEED  MACRO   sym,len
IF NOT InstalledData
	DOSDATA    SEGMENT WORD PUBLIC 'DATA'
    IFIDN   <len>,<WORD>
	EXTRN   &sym:WORD
    ELSE
	IFIDN   <len>,<DWORD>
	EXTRN   &sym:DWORD
	ELSE
	EXTRN   &sym:BYTE
	ENDIF
    ENDIF
	DOSDATA    ENDS
ENDIF
ENDM
	.xcref I_need


; call a procedure that may be external.  The call will be short.

invoke  MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	CALL    name
ENDM
.xcref  invoke

PAGE
;
; jump to a label that may be external.  The jump will be near.
;
transfer    MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	JUMP    name
ENDM
.xcref  transfer

;
; get a short address in a word
;
short_addr  MACRO   name
    IFDIF   <name>,<?>
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DW  OFFSET DOSCODE:name
    ELSE
	DW  ?
    ENDIF
ENDM
.xcref  short_addr

;
; get a long address in a dword
;
long_addr   MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DD  name
ENDM
.xcref  long_addr

;
; declare a PROC near or far but PUBLIC nonetheless
;
.xcref ?frame
.xcref ?aframe
.xcref ?stackdepth
.xcref ?initstack
?frame        =   0                     ; initial
?aframe       =   0                     ; initial
?stackdepth   =   0                     ; initial stack size
?initstack    =   0                     ; initial stack size

procedure   MACRO   name,distance
	?frame =    0
	?aframe =   2                   ;; remember the pushed BP
	PUBLIC  name
name    PROC    distance
	ASSUME	DS:nothing,ES:nothing
	?initstack    = ?stackdepth     ;; beginning of procedure
ENDM
.xcref  procedure


; end a procedure and check that stack depth is preserved

EndProc MACRO   name, chk
	IFDIF   <chk>,<NoCheck>       ;; check the stack size
	IF2
	IF ?initstack NE ?stackdepth    ;; is it different?
	%OUT    ***** Possible stack size error in name *****
	ENDIF
	ENDIF
	ENDIF
name    ENDP
ENDM
.xcref  endproc
PAGE
;
; define a data item to be public and of an appropriate size/type
;

I_AM    MACRO   name,size,init
;; declare the object public
	PUBLIC  name
;; declare the type of the object
    IFIDN <size>,<WORD>
name    LABEL WORD
	I_AM_SIZE   =   1
	I_AM_LEN    =   2
    ELSE
	IFIDN <size>,<DWORD>
name    LABEL DWORD
	I_AM_SIZE   =   2
	I_AM_LEN    =   2
	ELSE
	    IFIDN <size>,<BYTE>
name    LABEL BYTE
	I_AM_SIZE   =   1
	I_AM_LEN    =   1
	    ELSE
name    LABEL BYTE
	I_AM_SIZE   =   size
	I_AM_LEN    =   1
	    ENDIF
	ENDIF
    ENDIF
;; if no initialize then allocate blank storage
    IFB <init>
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
    ELSE
IF NOT InstalledData
	IRP itm,<init>
	    IF I_AM_LEN EQ 1
		DB  itm
	    ELSE
		DW  itm
	    ENDIF
	    I_AM_SIZE = I_AM_SIZE - 1
	ENDM
	IF I_AM_SIZE NE 0
	    %out    ***** initialization of name not complete *****
	ENDIF
ELSE
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
ENDIF
    ENDIF
ENDM
.xcref  I_AM
.xcref  I_AM_SIZE
.xcref  I_AM_LEN
I_AM_SIZE   = 0
I_AM_LEN    = 0

PAGE

;
; define an entry in a procedure
;
entry macro name
	PUBLIC  name
name:
endm
.xcref  entry

BREAK <ERROR - store an error code then jump to a label>

error macro code
.xcref
	MOV AL,code
	transfer    SYS_RET_ERR
.cref
ENDM
.xcref  error

BREAK <JUMP - real jump that links up shortwise>
;
; given a label <lbl> either 2 byte jump to another label <lbl>_J
; if it is near enough or 3 byte jump to <lbl>
;

jump    macro lbl
    local a
.xcref

    ifndef lbl&_J                       ;; is this the first invocation
a:      JMP lbl
    ELSE
	IF (lbl&_J GE $) OR ($-lbl&_J GT 126)
a:      JMP lbl                         ;; is the jump too far away?
	ELSE
a:      JMP lbl&_J                      ;; do the short one...
	ENDIF
    ENDIF
    lbl&_j = a
.cref
endm
.xcref  jump

BREAK <RETURN - return from a function>

return  macro x
    local a
.xcref
a:
	RET
ret_l = a
.cref
endm
.xcref  return

BREAK <CONDRET - conditional return>

condret macro   cc,ncc
    local   a
.xcref
.xcref a
.cref
    ifdef   ret_l                       ;; if ret_l is defined
	if (($ - ret_l) le 126) and ($ gt ret_l)
					;;     if ret_l is near enough then
	    a:  j&cc    ret_l           ;;         a: j<CC> to ret_l
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    ifdef   ret_&cc                     ;; if ret_<CC> defined
	if (($ - ret_&cc) le 126) and ($ gt ret_&cc)
					;;     if ret_<CC> is near enough
	    a:  j&cc    ret_&cc         ;;         a: j<CC> to ret_<CC>
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    j&ncc   a                           ;; j<NCC> a:
    return                              ;; return
    a:                                  ;; a:
    ret_&cc = ret_l                     ;; define ret_<CC> to be ret_l
endm
.xcref  condret

BREAK <RETZ - return if zero, links up shortwise if necessary>

retz    macro
    condret z,nz
endm
.xcref  retz

BREAK <RETNZ - return if not zero, links up shortwise if necessary>

retnz   macro
    condret nz,z
endm
.xcref  retnz

BREAK <RETC - return if carry set, links up shortwise if necessary>

retc    macro
    condret c,nc
endm
.xcref  retc

BREAK <RETNC - return if not carry, links up shortwise if necessary>

retnc   macro
    condret nc,c
endm
.xcref  retnc

BREAK <CONTEXT - set the DOS context to a particular register>

context macro   r
	PUSH    SS
	POP     r
	ASSUME  r:DOSDATA
endm
.xcref  context

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH    reg
ENDM
ENDM
.xcref  SaveReg

Save	MACRO	arglist		;; push those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth + 1
	PUSH	arg
ENDM
ENDM
.xcref	Save

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP     reg
ENDM
ENDM
.xcref  RestoreReg

Restore MACRO	 arglist		;; pop those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth - 1
	POP	arg
ENDM
ENDM
.xcref	Restore

BREAK <Critical section macros>

EnterCrit MACRO section
	Invoke  E&section
ENDM

LeaveCrit MACRO section
	Invoke  L&section
ENDM

Break   <message - display a message>

AsmVars <ShareF,Cargs,Redirector>

if debug
fmt     MACRO   typ,lev,fmts,args
local   a,b,c
	PUSHF
IFNB <typ>
	TEST    BugTyp,typ
	JZ      c
	CMP     BugLev,lev
	JB      c
ENDIF
	PUSH    AX
	PUSH    BP
	MOV     BP,SP
If (not sharef) and (not redirector)
DOSDATA segment
a       db      fmts,0
DOSDATA	 ends
	MOV	AX,OFFSET DOSDATA:a
else
	jmp     short b
a       db      fmts,0
if sharef
b:      mov     ax,offset share:a
else
b:      mov     ax,offset netwrk:a
endif
endif
	PUSH    AX
cargs = 2
IRP item,<args>
IFIDN   <AX>,<item>
	push	[bp+2]
     ;	MOV	AX,[BP+2]
ELSE
     ;	MOV	AX,item
	push	item
ENDIF
   ;	PUSH	AX
cargs = cargs + 2
ENDM
	invoke  PFMT
	ADD     SP,Cargs
	POP     BP
	POP     AX
c:
	POPF
ENDM
else
fmt macro
endm
endif

Break   <DOSAssume - validate assumes>

AsmVar  Debug,$temp

;**	DOSAssume - Check that a register addresses DOSSEG
;
;	DOSAssume  reglist, message


IF debug
DOSAssume   Macro   reglist,message
local a,b
    $temp   =	0
    IRP r,<reglist>
	IFIDN <r>,<DS>
	    $temp = $temp OR 2
	ELSE
	    IFIDN <r>,<ES>
		$temp = $temp OR 4
	    ELSE
		IFIDN <r>,<SS>
		    $temp = $temp OR 1
		ELSE
		    %out ***** Invalid register reg in DOSAssume *****
		ENDIF
	    ENDIF
	ENDIF
    ENDM
	Invoke  SegCheck
	jmp	short a
	db	$temp
	db	message,0
a:

    IRP r,<reglist>
	ASSUME	r:DOSDATA
    ENDM
ENDM

ELSE

DOSAssume   Macro   reglist,message
IRP r,<reglist>
    ASSUME  r:DOSDATA
ENDM
ENDM
ENDIF

BREAK   <ASSERT - make assertions about registers>

IF DEBUG
Assert  MACRO   kind, objs, message
	LOCAL   a,b
    IFIDN   <kind>,<Z>
	CMP     objs,0
	JZ      a
	fmt <>,<>,<message>
a:
    ELSE
	IFIDN   <kind>,<NZ>
	CMP     objs,0
	JNZ     a
	fmt <>,<>,<message>
a:
	ELSE
    PUSH    AX
	    IRP obj,<objs>
	PUSH    obj
	    ENDM
	    IF SHAREF
    MOV     AX,OFFSET b
	    ELSE
    MOV     AX,OFFSET DOSDATA:b
	    ENDIF
    PUSH    AX
	    IFIDN   <kind>,<ISBUF>
	Invoke  BUFCheck
	    ENDIF
	    IFIDN   <kind>,<ISSFT>
	Invoke  SFTCheck
	    ENDIF
	    IFIDN   <kind>,<ISDPB>
	Invoke  DPBCheck
	    ENDIF
    POP     AX
	    IF SHAREF
    JMP SHORT a
b   DB  Message,0
a:
	    ELSE
DOSDATA	 segment
b   db  Message,0
DOSDATA	 ends
	    ENDIF
	ENDIF
    ENDIF
ENDM
ELSE
Assert  Macro
ENDM
ENDIF

Break   <CallInstall - hook to installable pieces>

CallInstall MACRO   name,mpx,fn,save,restore
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV     AX,(mpx SHL 8) + fn
	INT     2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke  name
ENDIF
ENDM

Break   <Stack frame manipulators>

localvar    macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    ?frame =  ?frame + 1
	    a = ?frame
	    name EQU  BYTE PTR [BP-a]
	else
	    ifidn   <length>,<WORD>
		?frame =  ?frame + 2
		a = ?frame
		name EQU  WORD PTR [BP-a]
	    else
		ifidn   <length>,<DWORD>
		    ?frame =  ?frame + 4
		    a = ?frame
		    name EQU  DWORD PTR [BP-a]
		    name&l EQU  WORD PTR [BP-a]
		    name&h EQU  WORD PTR [BP-a+2]
		else
		    ?frame =  ?frame + length
		    a = ?frame
		    name EQU  BYTE PTR [BP-a]
		endif
	    endif
	endif
endm

enter   macro
	push    bp
	mov     bp,sp
	sub     sp,?frame
endm

leave   macro
	mov     sp,bp
	pop     bp
endm

Argvar  macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    a = ?aframe
	    ?aframe =  ?aframe + 1
	    name EQU  BYTE PTR [BP+a]
	else
	    ifidn   <length>,<WORD>
		a = ?aframe
		?aframe =  ?aframe + 2
		name EQU  WORD PTR [BP+a]
	    else
		ifidn   <length>,<DWORD>
		    a = ?aframe
		    ?aframe =  ?aframe + 4
		    name EQU  DWORD PTR [BP+a]
		    name&l EQU  WORD PTR [BP+a]
		    name&h EQU  WORD PTR [BP+a+2]
		else
		    a = ?aframe
		    ?aframe =  ?aframe + length
		    name EQU  BYTE PTR [BP+a]
		endif
	    endif
	endif
endm


save_world 	macro

	push	es
	invoke	save_user_world

endm

restore_world	macro

	invoke	restore_user_world
	pop	es

endm

;
; This macro gets the DOS data segment value and puts it in the specified
; segment register.  This can only be used in the DOSCODE segment.
;

getdseg	macro 	r

ifdef ROMDOS
	mov	r, cs:[BioDataSeg]
	assume	r:bdata
	mov	r, r:[DosDataSg]
else
	mov	r, cs:[DosDseg]
endif
	assume	r:dosdata
endm

;
; This macro does the necessary extrns to allow use of the getdseg macro.
;
allow_getdseg macro

ifdef ROMDOS
	extrn	BioDataSeg:word
	bdata	segment at 70H
	extrn	DosDataSg:word
	bdata	ends
else
	extrn	DosDseg:word
endif

endm



BREAK <LJcc - Long Conditional Jumps>

LJE macro l
 LJ JE JNE l
endm

LJNE macro l
 LJ jne JE l
endm

LJZ macro l
 LJE l
endm

LJNZ macro l
 LJNE l
endm

LJC macro l
 LJ jc JNC l
endm

LJNC macro l
 LJ jnc JC l
endm

LJA macro l
 LJ ja JNA l
endm

LJNA macro l
 LJ jna JA l
endm

LJB macro l
 LJ jb JNB l
endm

LJNB macro l
 LJ jnb JB l
endm

LJS macro l
 LJ js JNS l
endm

LJNS macro l
 LJ jns JS l
endm

LJAE macro l
 LJ jae JNAE l
endm

LJBE macro l
 LJ jbe JNBE l
endm

LJL macro l
 LJ jl JNL l
endm

LJG macro l
 LJ jg JNG l
endm

LJLE macro l
 LJ jle JNLE l
endm

DLJE macro l
 DLJ JE JNE l
endm

DLJNE macro l
 DLJ jne JE l
endm

DLJZ macro l
 DLJE l
endm

DLJNZ macro l
 DLJNE l
endm

DLJC macro l
 DLJ jc JNC l
endm

DLJNC macro l
 DLJ jnc JC l
endm

DLJA macro l
 DLJ ja JNA l
endm

DLJNA macro l
 DLJ jna JA l
endm

DLJB macro l
 DLJ jb JNB l
endm

DLJNB macro l
 DLJ jnb JB l
endm

DLJS macro l
 DLJ js JNS l
endm

DLJNS macro l
 DLJ jns JS l
endm

DLJAE macro l
 DLJ jae JNAE l
endm

DLJBE macro l
 DLJ jbe JNBE l
endm

DLJG macro l
 DLJ jg JNG l
endm

DLJL macro l
 DLJ jl JNL l
endm

DLJLE macro l
 DLJ jle JNLE l
endm


;*	LJ - generate long conditional jump
;
;	if target preceeds us and is in range just use a short jump
;	else use a long jump
;
;	LJ <direct jmp>,<skip jmp>,<label>

LJ MACRO dirop,idirop,l
 local a
 IF ((.TYPE l) XOR 20h) AND 0A0h
  idirop a			       ;; not defined or is external
  jmp l
a:
 ELSE				       ;; is local definied
  IF (($-l) LT 124) AND ($ GT l)
   dirop l			      ;; is before and within range
  ELSE
   idirop a			      ;; is out of range or forward (pass 2)
   jmp l
a:
  ENDIF
 ENDIF
ENDM


;*	DLJ - generate debug long conditional jump
;
;	If DEBUG is defined then we generate a long jump, else a short
;	one.
;
;	DLJ <direct jmp>,<skip jmp>,<label>

DLJ MACRO dirop,idirop,l
 local a
 IF DEBUG
  idirop a
  jmp l
a:
 ELSE
  dirop l
 ENDIF
ENDM

.xcref	LJE, LJNE, LJZ, LJNZ, LJC, LJNC, LJA, LJNA
.xcref	LJB, LJNB, LJS, LJNS, LJAE, LJBE, LJG, LJL, LJLE
.xcref	DLJE, DLJNE, DLJZ, DLJNZ, DLJC, DLJNC, DLJA, DLJNA
.xcref	DLJB, DLJNB, DLJS, DLJNS, DLJAE, DLJBE, DLJG, DLJL, DLJLE
.xcref	LJ,DLJ



;**	SHORT offset macro
;
;	expands to SHORT if non debug, to nul if debug.
;
;	this allows us to code
;
;		jmp	SHRT foobar
;
;	and get a long form if debugging is turned on (because the extra
;	debug code puts the target out of range)

if DEBUG
  SHRT	EQU	<>
else
  SHRT	EQU	SHORT
endif


;**	FALLTHRU - Verifies Fallthrough Validity

FALLTHRU MACRO	labl
;	BUGBUG - restore align when we make code segment word aligned
;	align	2		; don't have errnz fail due to alignment
    IF2 			; of following label
	.errnz	labl-$
    ENDIF
	ENDM


;**	INTTEST - Generate an INT 3 for testing

INTTEST MACRO
if DEBUG
	int	3
endif
	ENDM


;**	DPUBLIC - Make a public symbol for debugging

DPUBLIC MACRO	arg
if DEBUG
	public	arg
endif
	ENDM

;*	Debug Traps
;
;	These are removed as the code is exercised

TRAP	macro			; Like INTTEST but is normally left in during
	int	3		; debugging; indicates "should not occur"
	ENDM

TRAPC	macro
	local	l
	jnc	short l
	int	3
l:
	ENDM

TRAPNC	macro
	local	l
	jc	short l
	int	3
l:
	ENDM

TRAPA	macro
	local	l
	jna	short l
	int	3
l:
	ENDM

TRAPNA	macro
	local	l
	ja	short l
	int	3
l:
	ENDM

TRAPZ	macro
	local	l
	jnz	short l
	int	3
l:
	ENDM

TRAPNZ	macro
	local	l
	jz	short l
	int	3
l:
	ENDM



	BREAK	<Structure Field Macros>


;**	Follows - Verify that a field follows another
;
;	FOLLOWS field1, field2 [, size]
;
;	This macro generates an error if "field1" doesn't immeidately
;	follow "field2".  If "size" is specified then an error is generated
;	if Field1 is not of the proper size.

FOLLOWS macro	field1, field2, fldsiz
	.errnz	field1 - size field2 - field2
IFNB	<fldsiz>
	.errnz	size field1 - fldsiz
ENDIF
	ENDM



;**	LAST - Verify that a field is the last field in a structure
;
;	LAST	fieldname, structname
;
;	Generates an error if fieldname is not last in structname.

LAST	macro	fldnam, strunam
	.errnz	size strunam - fldnam - size fldnam
	endm



;**	TESTB - Use Byte form for Word TESTS, when possible
;
;	TESTB is used in place of 16-bit TEST instructions.  It substitutes
;	a smaller 8-bit test when possible.

TESTB	macro	targ,mask,thirdarg
	local	mask2,delta

ifnb <thirdarg>
	.err	mask must be enclosed in brackets
endif

ifidn <targ>,<[bx]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[si]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[di]>		; don't process these operands specially
	test	targ,mask
	exitm
endif
ifidn <targ>,<[BX]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[SI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[DI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<SI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<DI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<BP>
	test	targ,mask
	exitm
endif
delta	=	0
mask2	=	mask

    if	mask2 AND 0ff00h
;	have a mask bit in the high half
	if mask2 AND 0ffh
	    test targ,mask
	    exitm
	endif
	mask2 = mask2 SHR 8
	delta = 1
    endif

ifidn <targ>,<AX>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<BX>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<CX>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<DX>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif
ifidn <targ>,<ax>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<bx>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<cx>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<dx>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif

	test	byte ptr targ+delta,mask2
	endm


;
; Some old versions of the 80286 have a bug in the chip.  The popf
; instruction will enable interrupts.  Therefore in a section of code with
; interrupts disabled and you need a popf instruction use the 'popff'
; macro instead.
;

POPFF	macro
	jmp	$+3
	iret
	push	cs
	call	$-2
	endm

Break   <Cmp32 - 32-bit compare>
;----------------------------------------------------------------------------
;
; Macro Name : Cmp32
;
; Inputs:
;       msw1 -- 1st operand, most  significant word; MUST BE REGISTER.
;       lsw1 -- 1st operand, least significant word; MUST BE REGISTER.
;       msw2 -- 2nd operand, most  significant word.
;       lsw2 -- 2nd operand, least significant word.
; Function:
;       Compare 2 32-bit operands.  Implemented as a macro.
; Outputs:
;       CF = 1 if 1st operand <  2nd operand
;          = 0 if 1st operand >= 2nd operand
;	ZF = 1 if 1st operand == 2nd operand
;          = 0 if 1st operand <> 2nd operand
;-----------------------------------------------------------------------------
;M019: Created.

Cmp32   MACRO   msw1,lsw1,msw2,lsw2
        LOCAL   cmp32x

        cmp     msw1,msw2
        jne     cmp32x
        cmp     lsw1,lsw2
cmp32x:
        ENDM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dosseg.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	segment ordering for MSDOS
;
;

;hkn; START		SEGMENT BYTE PUBLIC 'START'
;hkn; START		ENDS
;hkn; 
;hkn; CONSTANTS	SEGMENT WORD PUBLIC 'CONST'
;hkn; CONSTANTS	ENDS
;hkn; 
;hkn; DATA		SEGMENT WORD PUBLIC 'DATA'
;hkn; DATA		ENDS
;hkn; 
;hkn; TABLE		SEGMENT BYTE PUBLIC 'TABLE'
;hkn; TABLE		ENDS
;hkn; 
;hkn; CODE		SEGMENT BYTE PUBLIC 'CODE'
;hkn; CODE		ENDS
;hkn; 
;hkn; LAST		SEGMENT PARA PUBLIC 'LAST'
;hkn; LAST		ENDS
;hkn; 
;hkn; DOSGROUP    GROUP   START,CONSTANTS,DATA,TABLE,CODE,LAST

; If this is the disk based DOS, then there are just two (real) segments,
; DOSCODE and DOSDATA.  All the initialization and startup code in in the
; DOSCODE segment.  For ROMDOS, the initialization code cannot be in the
; same segment as the resident code, so a new segment, DOSINIT is included
; between the two.
;


DOSCODE		SEGMENT	BYTE PUBLIC 'CODE'
DOSCODE		ENDS

DUM	SEGMENT	PARA PUBLIC 'DUM'
DUM	ENDS

ifndef IS_SHARE	; M038 Removes segment definition in SHARE.EXE
ifdef ROMDOS

DOSINITSEG	SEGMENT WORD PUBLIC 'DOSINITSEG'
DOSINITSEG	ENDS

DUM2	SEGMENT	PARA PUBLIC 'DUM2'
DUM2	ENDS

endif ; ROMDOS
endif		; M038

DOSDATA		SEGMENT	WORD PUBLIC 'DATA'
DOSDATA		ENDS

DOSDATALAST	SEGMENT	WORD PUBLIC 'DATA'
DOSDATALAST	ENDS

DOSGRP		GROUP DOSDATA,DOSDATALAST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\cmacros.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright 1984, 1988 Microsoft Corporation
$
if1
outif MACRO name,defval,onmsg,offmsg
    ifndef name
	ifb <defval>
	    name=0
	else
	    name=defval
	endif
    endif
    if name
	name=1
	ifnb <onmsg>
	    %out ! onmsg
	endif
    else
	ifnb <offmsg>
	    %out ! offmsg
	endif
    endif
endm

error MACRO msg
bug
%out E r r o r ----- msg
ENDM
%out cMacros Version 1.04
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?WIN,0,<Windows Support>
outif ?PLM,0,<PLM calling convention>
endif
 .XCREF
 .XCREF ?N,?AX,?AH,?AL,?BX,?BH
 .XCREF ?BL,?CX,?CH,?CL,?DX,?DH
 .XCREF ?DL,?SI,?DI,?ES,?DS,?BP
 .XCREF ?SP,?SS,?CS
 .XCREF ?RSL,?CPD,?argl,?argc,?BA
 .XCREF ?ACB,???,?PO
 .XCREF ?PAS,?PC
 .XCREF Uconcat,mPush,mPop
 .XCREF ?RI,?pp,?pp1,?al1
 .XCREF ?aD,?AP,?Atal,?pd,?dd,?dd1,?ex1,?cas
 .XCREF ?pg,?pg1,?aloc,?cs1,?cs2
 .XCREF ?lb1,?lblpu
 .XCREF ?DF,?PLM,?WIN,?IA,?PU,?ADJ
 .CREF
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?lblpu = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
uconcat macro n1,n2,o1,o2,p1,p2
n1&n2 o1&o2 p1&p2
endm
mpush macro rV
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if rV AND ?&&x
push x
endif
endm
endm
mpop macro rV
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if rV AND ?&&x
pop x
endif
endm
endm
SAVE macro rL
?RSL = 0
?RI ?RSL,<rL>
endm
smashes macro n,rL
 .xcref
 .xcref ?SM&n
 .cref
?SM&n = 0
?RI ?SM&n,<rL>
endm
?RI macro n,rL
irp x,<rL>
ifdef ?&&x
n = n or ?&&x
endif
endm
endm
parmB macro nl
?pp <&nL>,<byte>,2,1
endm
parmW macro nl
?pp <&nL>,<word>,2,2
endm
parmD macro nl
ife ?PLM
irp x,<nL>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<nL>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro nl
?pp <&nL>,<QWORD>,8,8
endm
parmT macro nl
?pp <&nL>,<TBYTE>,10,10
endm
if sizeC
parmCP macro nl
parmD <nl>
endm
else
parmCP macro nl
parmW <nl>
endm
endif
if sizeD
parmDP macro nl
parmD <nl>
endm
else
parmDP macro nl
parmW <nl>
endm
endif
?pp macro nL,t,l,s
if ?CPD
 .xcref
ife ?PLM
irp x,<nL>
?pp1 x,<t>,%?PO,%?adj,%(?PO+?adj)
?PO = ?PO + l
 .xcref ?T&&x
?T&&x = s
endm
else
irp x,<nL>
?PO = ?PO + l
?pp1 x,<t>,%?PO,%?adj,%(?PO+?adj)
 .xcref ?T&&x
?T&&x = s
endm
endif
 .cref
else
%out Parm(s) "&nl" declared outside proc def.
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
localB macro nL
?aLoc <&nL>,<BYTE ptr>,1,1,0
endm
localW macro nL
?aLoc <&nL>,<WORD PTR>,2,2,1
endm
localD macro nL
irp x,<nL>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro nL
?aLoc <&nL>,<QWORD PTR>,8,8,1
endm
localT macro nL
?aLoc <&nL>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro nL
localD <nL>
endm
else
localCP macro nL
localW <nL>
endm
endif
if sizeD
localDP macro nL
localD <nL>
endm
else
localDP macro nL
localW <nL>
endm
endif
localV macro n,a
?aLoc <&n>,,%(&a),0,1
endm
?aLoc macro nL,t,l,s,a
if ?CPD
 .xcref
??? = ??? + l
if a
??? = ((??? + 1) AND 0FFFEH)
endif
irp x,<nL>
?aL1 x,<t>,%???
 .xcref ?T&&x
?T&&x = s
endm
 .cref
else
%out Locals "&nl" declared outside procedure def.
endif
endm
?aL1 macro n,t,o
if ?IA
n equ t [bp-?IA-o]
else
n equ t [bp-o]
endif
endm
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
externB macro nL
?ex1 <&nL>,1,<BYTE>
endm
externW macro nL
?ex1 <&nL>,2,<WORD>
endm
externD macro nL
?ex1 <&nL>,4,<DWORD>
endm
externQ macro nL
?ex1 <&nL>,8,<QWORD>
endm
externT macro nL
?ex1 <&nL>,10,<TBYTE>
endm
externNP macro nL
?ex1 <&nL>,2,<NEAR>
endm
externFP macro nL
?ex1 <&nL>,4,<FAR>
endm
if sizeC
externP macro nL
?ex1 <&nL>,4,<FAR>
endm
else
externP macro nL
?ex1 <&nL>,2,<NEAR>
endm
endif
if sizeC
externCP macro nL
?ex1 <&nL>,4,<DWORD>
endm
else
externCP macro nL
?ex1 <&nL>,2,<WORD>
endm
endif
if sizeD
externDP macro nL
?ex1 <&nL>,4,<DWORD>
endm
else
externDP macro nL
?ex1 <&nL>,2,<WORD>
endm
endif
?ex1 macro nL,s,d
irp x,<nL>
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
labelB macro nL
?lb1 <&nL>,1,<BYTE>
endm
labelW macro nL
?lb1 <&nL>,2,<WORD>
endm
labelD macro nL
?lb1 <&nL>,4,<DWORD>
endm
labelQ macro nL
?lb1 <&nL>,8,<QWORD>
endm
labelT macro nL
?lb1 <&nL>,10,<TBYTE>
endm
labelNP macro nL
?lb1 <&nL>,2,<NEAR>
endm
labelFP macro nL
?lb1 <&nL>,4,<FAR>
endm
if sizeC
labelP macro nL
?lb1 <&nL>,4,<FAR>
endm
else
labelP macro nL
?lb1 <&nL>,2,<NEAR>
endm
endif
if sizeC
labelCP macro nL
?lb1 <&nL>,4,<DWORD>
endm
else
labelCP macro nL
?lb1 <&nL>,2,<WORD>
endm
endif
if sizeD
labelDP macro nL
?lb1 <&nL>,4,<DWORD>
endm
else
labelDP macro nL
?lb1 <&nL>,2,<WORD>
endm
endif
?lb1 macro nL,s,d
?lblpu = 0
irp x,<nL>
ifidn <x>,<PUBLIC>
?lblpu = 1
else
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
defB macro nL
?aD <&nL>,1
endm
defW macro nL
?aD <&nL>,2
endm
defD macro nL
?aD <&nL>,4
endm
defQ macro nL
?aD <&nL>,8
endm
defT macro nL
?aD <&nL>,10
endm
if sizeC
defCP macro nL
defD <nL>
endm
else
defCP macro nL
defW <nL>
endm
endif
if sizeD
defDP macro nL
defD <nL>
endm
else
defDP macro nL
defW <nL>
endm
endif
?aD macro nL,s
irp x,<nL>
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
endm
endm
regPtr macro n,S,O
 .xcref
 .xcref ?T&n,?SR&n,?OR&n
 .cref
?T&n = 0FFFFH
?SR&n = 0
?RI ?SR&n,<&S>
?OR&n = 0
?RI ?OR&n,<&O>
endm
arg macro aL
irp x,<aL>
?argc = ?argc + 1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
 .xcref
 .xcref ?ALI&i
 .cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl = ?argl + 2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl = ?argl + 2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl = ?argl + 6
exitm
endif
ife ?T&n-0FFFFH
mpush %(?SR&n),1
mpush %(?OR&n),1
?argl = ?argl + 2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ife ?PLM
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
ifdef ?SM&n
?RSL = ?RSL AND ?SM&n
endif
mpush %?RSL
?argl = 0
?ACB = ?argc
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB = ?ACB - 1
endm
ife ?PLM
ifb <sleaze>
call _&n
else
call n
endif
else
call n
endif
if ?argl
add sp,?argl
endif
mpop %?RSL
?RSL = 0
?argc = 0
?argl = 0
endm
else
ccall macro n,a
ifnb <a>
Arg <a>
endif
ifdef ?SM&n
?RSL = ?RSL AND ?SM&n
endif
mpush %?RSL
?argl = 0
?ACB = 1
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB = ?ACB + 1
endm
ife ?PLM
call _&n
else
call n
endif
mpop %?RSL
?RSL = 0
?argc = 0
?argl = 0
endm
endif
cProc macro n,cl,s
?pd n,<cl>,<s>,4
endm
?pd macro n,c,a,i
if ?CPD
?UTPE
endif
?CPD = 1
??? = 0
?argc = 0
?BA = 0
?PO = 0
?PU = 0
?IA = 0
?adj = i
?PAS = 0
ifnb <a>
?RI ?PAS,<a>
endif
?PC = sizeC
irp x,<c>
ifidn <x>,<FAR>
?PC = 1
endif
ifidn <x>,<NEAR>
?PC = 0
endif
ifidn <x>,<PUBLIC>
?PU = 1
endif
endm
if ?PC
if ?WIN
?IA = 2
endif
?adj = ?adj + 2
endif
ife ?PLM
ife ?PC
n label near
else
n label far
endif
?pg <_&n>,%?PU,%?PC,%?PAS
else
?pg <n>,%?PU,%?PC,%?PAS
endif
endm
?pg macro n,p,c,a
    .xcref
    cBegin &macro g
	.xcref
	?pg1 <n>,c,a,%?PO
	?CPD = 0
	?argc = 0
	?BA = 1
	??? = (???+1) AND 0FFFEH
	if p
	    PUBLIC n
	endif
	ife c
	    n proc NEAR
	else
	    n proc FAR
	endif
	ifidn <g>,<nogen>
	    if ???+?PO+a
		%out <cBegin - possible invalid use of nogen>
	    endif
	else
	    if ?IA
		mov ax,ds
		nop
		inc bp
		push bp
		mov bp,sp
		push ds
		mov ds,ax
	    else
		push bp
		mov bp,sp
	    endif
	    if ???
		sub sp,???
	    endif
	    mPush a,1
	endif
	.cref
	purge cBegin
    &endm
    ?UTPE &macro
	%out Unterminated Procedure Definition: "&n"
    &endm
endm

?pg1 macro n,c,a,o
    .xcref
    cEnd &macro g
	.xcref
	?BA = 0
	ifidn <g>,<nogen>
	    if o+a
		%out <cEnd - possible invalid use of nogen>
	    endif
	else
	    mPop a,1
	    if ?IA
		sub bp,2
		mov sp,bp
		pop ds
		pop bp
		dec bp
	    else
		mov sp,bp
		pop bp
	    endif
	    ife ?PLM
		ret
	    else
		ret o
	    endif
	endif
	n endp
	.cref
	purge cEnd
    &endm
    .cref
endm

assumes macro s,g
local assumed
assumed = 0
ifidn <code>,<g>
?cas <s>
assumed = 1
endif
ifidn <CODE>,<g>
?cas <s>
assumed = 1
endif
ifidn <data>,<g>
assume s&:dgroup
assumed = 1
endif
ifidn <DATA>,<g>
assume s&:dgroup
assumed = 1
endif
ife assumed
assume s&:&g
endif
endm
if sizeC
?cas macro s
assume s&:_TEXT
endm
else
?cas macro s
assume s&:IGROUP
endm
endif
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
ifidn <grp>,<IGROUP>
ife sizeC
addSeg IGROUP,n
endif
else
addSeg grp,n
endif
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <n>,<ln>
endm
if1
ASMpass=1
else
ASMpass=2
endif
addSeg macro grp,seg
ifndef def_&grp
def_&grp= 0
endif
if def_&grp ne ASMpass
add_&grp &macro s
in_&grp <seg>,s
&endm
in_&grp &macro sl,s
ifb <s>
grp group sl
else
add_&grp &macro ns
in_&grp <sl,s>,ns
&endm
endif
&endm
def_&grp=ASMpass
else
add_&grp seg
endif
endm
defGrp macro nam
addSeg nam
endm
?cs1 macro n,ln
begin&ln &macro
?cs2 <n>
n segment
&endm
endm

?cs2 macro n
    sEnd &macro
	n ends
    &endm
endm

sBegin macro ln
    begin&ln
endm

ife ?DF
    createSeg _TEXT,code,byte,public,CODE,IGROUP
    createSeg _DATA,data,word,public,DATA,DGROUP
    if ?WIN
	ife sizeC
	    createSeg _INITTEXT,initcode,byte,public,CODE,IGROUP
	    createSeg _INITDATA,initdata,word,public,DATA,DGROUP
	endif
    endif
    ife sizeC
	defGrp IGROUP
    endif
    defGrp DGROUP
    if sizeC
	codeOFFSET equ OFFSET _TEXT:
    else
	codeOFFSET equ OFFSET IGROUP:
    endif
    dataOFFSET equ OFFSET DGROUP:
endif

errnz macro x
    if2
	if x
	    errnz1 <x>,%(x)
	endif
    endif
endm

errnz1 macro x1,x2
    = *ERRNZ* x1 = x2
endm

errn$ macro l,x
    errnz <OFFSET $ - OFFSET l x>
endm

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\ds_vers.h ===
/*
	This .h file is used by DBLSPACE.EXE to determine the
	internal revision number it should require from
	DBLSPACE.BIN.  It should be updated simultaneously
	with ds_vers.inc.
*/
#define DS_INTERNAL_REVISION 6

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dpl.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)dpl.asm	1.1 85/04/10
;	SCCSID = @(#)dpl.asm	1.1 85/04/10
DPL	STRUC
DPL_AX	DW	?	; AX register
DPL_BX	DW	?	; BX register
DPL_CX	DW	?	; CX register
DPL_DX	DW	?	; DX register
DPL_SI	DW	?	; SI register
DPL_DI	DW	?	; DI register
DPL_DS	DW	?	; DS register
DPL_ES	DW	?	; ES register
DPL_reserved DW ?	; Reserved
DPL_UID DW	?	; User (Machine) ID (0 = local macine)
DPL_PID DW	?	; Process ID (0 = local user PID)
DPL	ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dossym.inc ===
;	PAGE 80,132
	.xall
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; Revision History:
;	
;	M003	- added A20OFF_FLAG for MS PASCAL 3.2 compatibility support
;		  for DOS5.X running in HMA. 
;
;	M004	- added bit definition SETSSSP for DOS_FLAG for supporting
;		  exe files without stack segment. 
;		  This is no longer needed as we modify SP only. Removing 
;		  this equate. 9/26/90
;
;       M009	- addded comments relating to mace mkeyrate ver 1.0 support 
;		  with DOS in HMA.
;
;	M025	- Added SWITCHES=/W for suppressing mandatory loading
;		  of WINA20.386
;
;	M027	- Support for copy protected apps. Defined bit 2 of DOS_FLAG
;	

TRUE	    EQU 0FFFFh
FALSE	    EQU 0

Installed   = TRUE
IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

include dbcs.sw
include dosmac.INC
include VERSIONA.INC
include VERSION.INC


BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

BREAK <Read This and Weep>

include buffer.INC

BREAK <User stack inside of system call and SysVars>
; Location of user registers relative user stack pointer

user_environ	STRUC
user_AX     DW	    ?			; 00 hex offsets to
user_BX     DW	    ?			; 02	 facilitate debugging
user_CX     DW	    ?			; 04
user_DX     DW	    ?			; 06
user_SI     DW	    ?			; 08
user_DI     DW	    ?			; 0A
user_BP     DW	    ?			; 0C
user_DS     DW	    ?			; 0E
user_ES     DW	    ?			; 10
user_IP     DW	    ?			; 12
user_CS     DW	    ?			; 14
user_F	    DW	    ?			; 16
user_environ	ENDS


	BREAK <Disk map>

;	MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

include dirent.INC

BREAK <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).




;**	Character Type Flags
;
;	These flags are used in a lookup table indexed by the character code.
;	They're used to quickly classify characters when parsing paths.
;	I think that these are only used to parse FCBs - jgl

FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
FDELIM	equ 2		; is a delimiter
FSPCHK	equ 4		; set if character is not a space or equivalent
FFCB	equ 8		; is valid in an FCB


	include error.INC

;** Bit definitions for DOS_FLAG
;
; Bit 0 - this is set when a $open call is made from $exec. This is used in
;	  $open to indicate to the redirector that this open is being made
;	  by an exec call.
;
; Bit 2
;
; M003, M027:
;
; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
; the HMA. By default DOS will turn A20 OFF before Xferring control to the
; user program in the case of an Exec call. The next call to DOS will turn
; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
; In order to support this we will set Bit 2 of this flag in the DOS exec
; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
; M009, M027:
;
; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
; program converted to a com file. Therefore if DOS is loaded high and if 
; this program is loaded below 64K it will blurt out "packed file is corrupt".
; This program does an int 21 ah=49h before executing the buggy execpacked
; code. This int21 call turns a20 on and hence the problem. In $dealloc
; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
;
;

EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
SUPPRESS_WINA20	EQU	00000010b	; M025
EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\ds_vers.inc ===
;
;	This .inc file is used by both IO.SYS and DBLSPACE.BIN, to
;	set the internal revision number expected and given.  There
;	is a corresponding ds_vers.h file which should be updated
;	simultaneously, which is used by DBLSPACE.EXE

DS_INTERNAL_REVISION	equ	6

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\dpb.inc ===
BREAK <DPB structure>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DPB - Drive Parameter Block
;
;	BUGBUG - this isn't authorative - it's my probably incomplete and
;	possibly inaccurate deductions from code study... - jgl
;
;	The DPB is DOS's main structure for describing block devices.
;	It contains info about the "Drive" intermingled with info about
;	the FAT file system which is presumably on the drive.  I don't know
;	how those fields are used if it's not the FAT file system - BUGBUG
;
;	The DPBs are statically allocated and chained off of DPBHead.
;	Users scan this chain looking for a match on DPB_DRIVE.
;	The DPBs are built at init time from info in the SYSDEV structure.


DPB	STRUC

DPB_DRIVE	    DB	?	; Logical drive # assoc with DPB (A=0,B=1,...)
DPB_UNIT	    DB	?	; Driver unit number of DPB
DPB_SECTOR_SIZE     DW	?	; Size of physical sector in bytes
DPB_CLUSTER_MASK    DB	?	; Sectors/cluster - 1
DPB_CLUSTER_SHIFT   DB	?	; Log2 of sectors/cluster
DPB_FIRST_FAT	    DW	?	; Starting record of FATs
DPB_FAT_COUNT	    DB	?	; Number of FATs for this drive
DPB_ROOT_ENTRIES    DW	?	; Number of directory entries
DPB_FIRST_SECTOR    DW	?	; First sector of first cluster
DPB_MAX_CLUSTER     DW	?	; Number of clusters on drive + 1
DPB_FAT_SIZE	    DW	?	; Number of records occupied by FAT
DPB_DIR_SECTOR	    DW	?	; Starting record of directory
DPB_DRIVER_ADDR     DD	?	; Pointer to driver
DPB_MEDIA	    DB	?	; Media byte
DPB_FIRST_ACCESS    DB	?	; This is initialized to -1 to force a media
				;   check the first time this DPB is used
DPB_NEXT_DPB	    DD	?	; Pointer to next Drive parameter block
DPB_NEXT_FREE	    DW	?	; Cluster # of last allocated cluster
DPB_FREE_CNT	    DW	?	; Count of free clusters, -1 if unknown

DPB	ENDS

DPBSIZ	EQU	SIZE DPB	; Size of the structure in bytes

DSKSIZ	=	DPB_max_CLUSTER ; Size of disk (temp used during init only)

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\ea.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;Get/Set Extended Attrbute Equates

;The following equates are for EA types

EAISUNDEF	      equ  00H	     ; undefined
EAISLOGICAL	      equ  01H	     ; logical (0 or 1), 1 byte
EAISBINARY	      equ  02H	     ; binary integer 1, 2, or 4 bytes
EAISASCII	      equ  03H	     ; ASCII , 0 to 128 bytes
EAISDATE	      equ  04H	     ; DOS file date format, 2 bytes
EAISTIME	      equ  05H	     ; DOS file time format, 2 bytes

;The following equates are for EA flags

EASYSTEM	      equ  8000H     ; system defined, bultin
EAREADONLY	      equ  4000H     ; read-only , cannot be changed
EAHIDDEN	      equ  2000H     ; hidden from ATTRIB
EACREATEONLY	      equ  1000H     ; settable only at create time

;The following equates are for EA failure reason code (set by DOS)

EARCSUCCESS	      equ  00H	     ; success
EARCNOTFOUND	      equ  01H	     ; name not found
EARCNOSPACE	      equ  02H	     ; no space to hold name or value
EARCNOTNOW	      equ  03H	     ; name can't be set on this function
EARCNOTEVER	      equ  04H	     ; name can't be set
EARCUNDEF	      equ  05H	     ; name known to IFS but not supported
EARCDEFBAD	      equ  06H	     ; EA definition bad (type,length, etc)
EARCACCESS	      equ  07H	     ; EA access denied
EARCBADVAL	      equ  08H	     ; bad value
EARCDEVERROR	      equ  09H	     ; device error
EARCUNKNOWN	      equ  0FFFFH    ; unknown cause


;The following equates are for EA file type

EAEXISTING	     equ  00H	    ; existing file
EARTL		     equ  02H	    ; right to left
EAEXECUTABLE	     equ  03H	    ; executable program
EAINSTALLABLE	     equ  04H	    ; installable executable program
EAOVERLAY	     equ  05H	    ; program overlay
EADEV_DRIVER	     equ  06H	    ; device driver
EAIFS_DRIVER	     equ  07H	    ; ifs deriver




By_Create	      equ  0000010B	     ; set by Extended Open (create)
BY_XA		      equ  0000100B	     ; set by Get/Set XA by Handle

;Extended Attribute Structure

EA	    STRUC			      ; extended attribute list
EA_TYPE     DB	      ? 		      ; type
EA_FLAGS    DW	      ? 		      ; flags
EA_RC	    DB	      ? 		      ; reason code
EA_NAMELEN  DB	      ? 		      ; name length
EA_VALLEN   DW	      ? 		      ; value length
EA_NAME     DB	      ? 		      ; name
EA	    ENDS


;Query Extended Attribute list

QEA	     STRUC			       ; extended attribute list
QEA_TYPE     DB        ?		       ; type
QEA_FLAGS    DW        ?		       ; flags
QEA_NAMELEN  DB        ?		       ; name length
QEA_NAME     DB        ?		       ; name
QEA	     ENDS


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\error.inc ===
BREAK	<DOS error codes>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX.	If an error occurred then
;    the carry bit will be set and the error code is in AX.	If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.	The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
error_file_not_found		EQU	2
error_path_not_found		EQU	3
error_too_many_open_files	EQU	4
error_access_denied		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
error_not_enough_memory 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
error_bad_format		EQU	11
error_invalid_access		EQU	12
error_invalid_data		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35
error_sharing_buffer_exceeded	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00 			;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00 			;AN000;
error_handle_Disk_Full		EQU	39    ; DOS 4.00 			;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00				;AN000;




	BREAK <Interrupt 24 error codes>

;**	Int24 Error Codes

error_I24_write_protect 	EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0DH is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh


;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
;
;	NOTE: ABORT is ALWAYS allowed

Allowed_FAIL			EQU	00001000B
Allowed_RETRY			EQU	00010000B
Allowed_IGNORE			EQU	00100000B

I24_operation			EQU	00000001B	;Z if READ,NZ if Write
I24_area			EQU	00000110B	; 00 if DOS
							; 01 if FAT
							; 10 if root DIR
							; 11 if DATA
I24_class			EQU	10000000B	;Z if DISK, NZ if FAT or char


	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

;**	The GetExtendedError call takes an error code and returns CLASS,
;	ACTION and LOCUS codes to help programs determine the proper action
;	to take for error codes that they don't explicitly understand.


;	Values for error CLASS

errCLASS_OutRes 	EQU	1	; Out of Resource
errCLASS_TempSit	EQU	2	; Temporary Situation
errCLASS_Auth		EQU	3	; Permission problem
errCLASS_Intrn		EQU	4	; Internal System Error
errCLASS_HrdFail	EQU	5	; Hardware Failure
errCLASS_SysFail	EQU	6	; System Failure
errCLASS_Apperr 	EQU	7	; Application Error
errCLASS_NotFnd 	EQU	8	; Not Found
errCLASS_BadFmt 	EQU	9	; Bad Format
errCLASS_Locked 	EQU	10	; Locked
errCLASS_Media		EQU	11	; Media Failure
errCLASS_Already	EQU	12	; Collision with Existing Item
errCLASS_Unk		EQU	13	; Unknown/other

;	Values for error ACTION

errACT_Retry		EQU	1	; Retry
errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
errACT_User		EQU	3	; Ask user to regive info
errACT_Abort		EQU	4	; abort with clean up
errACT_Panic		EQU	5	; abort immediately
errACT_Ignore		EQU	6	; ignore
errACT_IntRet		EQU	7	; Retry after User Intervention

;	Values for error LOCUS

errLOC_Unk		EQU	1	; No appropriate value
errLOC_Disk		EQU	2	; Random Access Mass Storage
errLOC_Net		EQU	3	; Network
errLOC_SerDev		EQU	4	; Serial Device
errLOC_Mem		EQU	5	; Memory

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\fastxxxx.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; Fastxxx equates
FastOpen_ID	   equ	   1
FastSeek_ID	   equ	   2
Fast_yes	   equ	   10000000B	 ; fastxxx flag

;Structure definitions
;
Fasttable_Entry  struc			 ; Fastxxx  Entry pointer in DOS
Fast_Entry_Num	    dw	    2		 ; number of entries
FastOpen_Seek	    dd	    ?		 ; fastopen & fastseek entry address
Fasttable_Entry  ends
;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\find.inc ===
Break	<find first/next buffer>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Findfirst/FindNext Record
;
;	Client programs see this structure.  Some if it is defined,
;	clients probably use undefined parts too.


FIND_BUF    STRUC

FIND_BUF_DRIVE	    DB	?		; drive of search
FIND_BUF_NAME	    DB	11 DUP (?)	; formatted name
FIND_BUF_SATTR	    DB	?		; attribute of search
FIND_BUF_LASTENT    DW	?		; LastEnt
FIND_BUF_DIRSTART   DW	?		; DirStart
FIND_BUF_NETID	    DB	4 DUP (?)	; Reserved for NET
FIND_BUF_ATTR	    DB	?		; attribute found
FIND_BUF_TIME	    DW	?		; time
FIND_BUF_DATE	    DW	?		; date
FIND_BUF_SIZE_L     DW	?		; low(size)
FIND_BUF_SIZE_H     DW	?		; high(size)
FIND_BUF_PNAME	    DB	13 DUP (?)	; packed name

FIND_BUF    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\exe.inc ===
BREAK <EXEC and EXE file structures>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;----------------------------------------------------------------------------
;
; M00x : 4b04 implementation
;
;----------------------------------------------------------------------------
;

;**	EXE.INC - Definitions for the EXEC command and EXE files
;
; The following get used as arguments to the EXEC system call.	They indicate
; whether or not the program is executed or whether or not a program header
; gets created.

EXEC_FUNC_NO_EXECUTE	EQU 1		; no execute bit
EXEC_FUNC_OVERLAY	EQU 2		; overlay bit

EXEC0		STRUC
EXEC0_ENVIRON	dw	?		; seg addr of environment
EXEC0_COM_LINE	dd	?		; pointer to asciz command line
EXEC0_5C_FCB	dd	?		; default fcb at 5C
EXEC0_6C_FCB	dd	?		; default fcb at 6C
EXEC0		ENDS

EXEC1		STRUC
EXEC1_ENVIRON	dw	?		; seg addr of environment
EXEC1_COM_LINE	dd	?		; pointer to asciz command line
EXEC1_5C_FCB	dd	?		; default fcb at 5C
EXEC1_6C_FCB	dd	?		; default fcb at 6C
EXEC1_SP	dw	?		; stack pointer of program
EXEC1_SS	dw	?		; stack seg register of program
EXEC1_IP	dw	?		; entry point IP
EXEC1_CS	dw	?		; entry point CS
EXEC1		ENDS

EXEC3		STRUC
EXEC3_LOAD_ADDR DW	?		; seg address of load point
EXEC3_RELOC_FAC DW	?		; relocation factor
EXEC3		ENDS


;**	Exit codes (in upper byte) for terminating programs

EXIT_TERMINATE		EQU	0
EXIT_ABORT		EQU	0
EXIT_CTRL_C		EQU	1
EXIT_HARD_ERROR 	EQU	2
EXIT_KEEP_PROCESS	EQU	3



;**	EXE File Header Description
;

EXE_FILE	STRUC

EXE_SIGNATURE	dw  ?			; must contain 4D5A  (yay zibo!)
EXE_LEN_MOD_512 dw  ?			; low 9 bits of length
EXE_PAGES	dw  ?			; number of 512b pages in file
EXE_RLE_COUNT	dw  ?			; count of reloc entries
EXE_PAR_DIR	dw  ?			; number of paragraphs before image
EXE_MIN_BSS	dw  ?			; minimum number of para of BSS
EXE_MAX_BSS	dw  ?			; max number of para of BSS
EXE_SS		dw  ?			; stack of image
EXE_SP		dw  ?			; SP of image
EXE_CHKSUM	dw  ?			; checksum  of file (ignored)
EXE_IP		dw  ?			; IP of entry
EXE_CS		dw  ?			; CS of entry
EXE_RLE_TABLE	dw  ?			; byte offset of reloc table
EXE_IOV 	dw  ?			; overlay number (0 for root)
EXE_SYM_TAB	dd  ?			; offset of symbol table in file

EXE_FILE	ENDS

EXE_VALID_SIGNATURE	EQU 5A4Dh
EXE_VALID_OLD_SIGNATURE EQU 4D5Ah


;**	EXE file symbol info definitions

SYMBOL_ENTRY	STRUC
SYM_VALUE	dd  ?
SYM_TYPE	dw  ?
SYM_LEN 	db  ?
SYM_NAME	db  255 dup (?)
SYMBOL_ENTRY	ENDS


;
; M00x - BEGIN
;
;**	Data structure passed for ExecReady call

ERStruc		STRUC
 ER_Reserved	dw	?		; reserved, should be zero
 ER_Flags	dw	?
 ER_ProgName	dd	?		; ptr to ASCIIZ str of prog name
 ER_PSP		dw	?		; PSP of the program
 ER_StartAddr	dd	?		; Start CS:IP of the program
 ER_ProgSize	dd	?		; Program size including PSP
ERStruc		ENDS

;** bit fields in ER_Flags

ER_EXE		equ	0001h
ER_OVERLAY	equ	0002h

;
; M00x - END
;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\filemode.inc ===
BREAK	<FILEMODE.INC - Misc. File API Values>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FILEMODE.INC - Misc. File API Values
;
;	These values are all visable to the client program as part of
;	an API.


;**	Standard I/O file handles
;

STDIN	equ	0
STDOUT	equ	1
STDERR	equ	2
STDAUX	equ	3
STDPRN	equ	4



;**	File Modes

ACCESS_MASK	    equ 0Fh
OPEN_FOR_READ	    equ 00h
OPEN_FOR_WRITE	    equ 01h
OPEN_FOR_BOTH	    equ 02h
EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
				; made from exec

SHARING_MASK	    equ 0F0h
SHARING_COMPAT	    equ 000h
SHARING_DENY_BOTH   equ 010h
SHARING_DENY_WRITE  equ 020h
SHARING_DENY_READ   equ 030h
SHARING_DENY_NONE   equ 040h
SHARING_NET_FCB     equ 070h
SHARING_NO_INHERIT  equ 080h



;**	Extended Open Definitions
;

RESERVED_BITS_MASK	equ 0FE00h	; reserved bits for extended open flags
EXISTS_MASK		equ 0Fh 	; "file exists" action field
NOT_EXISTS_MASK 	equ 0F0h


;*	SF_MODE values

AUTO_COMMIT_WRITE	equ 4000h
INT_24_ERROR		equ 2000h


;*	Flags in EXTOPEN_ON

EXT_OPEN_ON		equ 01h
EXT_FILE_NOT_EXISTS	equ 04h
EXT_OPEN_I24_OFF	equ 02h


;*	Flags in EXTOPEN_FLAG

ACTION_OPENED		equ 01h
ACTION_CREATED_OPENED	equ 02h
ACTION_REPLACED_OPENED	equ 03h
EXT_EXISTS_OPEN 	equ 01h
EXT_EXISTS_FAIL 	equ 00h
EXT_NEXISTS_CREATE	equ 10h


;**	Extended Open Structure
;

EXT_OPEN_PARM	   struc
EXT_SET_LIST	    dd ?
EXT_NUM_OF_PARM     dw ?
EXT_OPEN_PARM	   ends


;*	Unused. should be deleted


;   NO_CODE_PAGE_CHECK	equ 0100h
;   IO_MODE_ID		equ 00000010b

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\fastopen.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; EXPORT DATE: 9/11
;Equates for FASTOPEN.

;FASTOPEN NAME CACHING Subfunctions
FONC_Look_up	equ	1
FONC_insert	equ	2
FONC_delete	equ	3
FONC_update	equ	4
FONC_purge	equ	5		;reserved for the future use.
FONC_Rename	equ	6		;AN001

;FASTOPEN EXTENT  CACHING Subfunctions
FSK_Open       equ     11					       ;AN000;
FSK_Close      equ     12					       ;AN000;
FSK_Delete     equ     13					       ;AN000;
FSK_Lookup     equ     14					       ;AN000;
FSK_Insert     equ     15					       ;AN000;
FSK_Trunc      equ     16					       ;AN000;

HeaderSize     equ    8        ; size of file header (8 bytes)	       ;AN000;
ExtendSize     equ    8        ; size of extend (8 bytes)	       ;AN000;
Num_Of_Pages   equ    1        ; number of pages		       ;AN000;
Num_Of_Segs    equ    2        ; number of frame segments	       ;AN000;
Stayresident  equ    04ch     ; terminate and stay resident function code


;Equates used in DOS.
FastOpen_Set	       equ     00000001B
FastOpen_Reset	       equ     11111110B
Lookup_Success	       equ     00000010B
Lookup_Reset	       equ     11111101B
Special_Fill_Set       equ     00000100B
Special_Fill_Reset     equ     11111011B
No_Lookup	       equ     00001000B
Set_For_Search	       equ     00010000B	     ;DCR 167


;============= FastOpen Data Structures =====================

Fastopen_Entry	STRUC			;Fastopen Entry pointer in DOS
Fastopen_Entry_size	dw	4	;size of the following
Fastopen_Name_Caching	dd	?
;Fastopen_FatChain_Caching dd	  ?	;reserved for future use
Fastopen_Entry	ENDS
;


CMPCT_DIR_INFO	STRUC			;compact version of Dir Info.
CDI_file_name	db	11 dup (' ')
CDI_file_attr	db	?
CDI_codepage	dw	?
CDI_extcluster	dw	?
CDI_attr2	db	?
CDI_time	dw	?
CDI_date	dw	?
CDI_cluster	dw	?
CDI_filesize	dd	?
CMPCT_DIR_INFO	ENDS
;

ORIG_DIR_INFO	STRUC
ODI_head	db	17 dup (?)
ODI_skip	db	5  dup (0)	;reserved for DOS. FASTOPEN does not
ODI_tail	db	10 dup (?)	;  use ODI_skip part.
ORIG_DIR_INFO	ENDS
;

ODI_head_leng	equ	17
ODI_skip_leng	equ	5
ODI_tail_leng	equ	10
;

FASTOPEN_EXTENDED_INFO	STRUC
FEI_dirpos	db	0
FEI_dirsec	dd	0
FEI_clusnum	dw	0
FEI_lastent	dw	0		; for search first
FEI_dirstart	dw	0		; for search first
FASTOPEN_EXTENDED_INFO	ENDS
;

NAME_RECORD	STRUC
nLRU_ptr	dw	-1
nMRU_ptr	dw	-1		;reverse of nLRU_ptr
nChild_ptr	dw	-1
nSibling_ptr	dw	-1
nBackward_ptr	dw	-1		;points to preceding node
nCmpct_Dir_Info db	size Cmpct_Dir_Info dup (' ')
nExtended_Info	db	size Fastopen_Extended_Info dup (?)
NAME_RECORD	ENDS
;

DRIVE_CACHE_HEADER	STRUC		;drive cache header
DCH_LRU_ROOT	 dw	 0		;Header of the LRU chain of this drive
DCH_MRU_ROOT	 dw	 0		;offset to the last entry of LRU chain
DCH_Child_ptr	 dw	 -1		;the first child in Name cache seg.
DCH_Sibling_ptr  dw	 -1		;points to the next drive cache header
DCH_Drive_letter db	'C'             ;drive letter
DCH_Num_Entries  dw	 0		;Number of entries in the Name cache.
DCH_Name_Buff	 dw	 0		;pointer to name cahe buffer
DRIVE_CACHE_HEADER	ENDS
;





;======== FAST SEEK FUNCTION  DATA  STRUCTURES =======================

DRIVE_HEADER	STRUC		   ; Drive header structure		;AN000;
Drive_Number	     dw     0	   ; drive number			;AN000;
Extent_Count	     dw     0	   ; reserved for debugging
MRU_Hdr_Ptr	     dw     0	   ; pointer to OPEN Queue
Free_ptr	     dw     0	   ; pointer to FREE buffer		;AN000;
Close_Ptr	     dw     0	   ; pointer to CLOSE Queue	     ;AN000;
Buff_Size	     dw     0	   ; cache buffer size including header ;AN000;
Free_Size	     dw     0	   ; size of Free area in bytes
Next_Drv_Hdr_Ptr     dw     0	   ; pointer to next drive header
DRIVE_HEADER   ENDS



FILE_HEADER	STRUC		   ; File header structure		;AN000;
FH_Phys_Clus_Num     dw     0	   ; starting physcial clustnum of file ;AN000;
FH_Refer_Count	     dw     0	   ; reference count			;AN000;
FH_Next_Extn_Ptr     dw     0	   ; pointer to first extent of the file;AN000;
FH_Next_Hdr_Ptr      dw     0	   ; pointer to next file header	;AN000;
FH_MRU_Extn_Ptr      dw     0	   ; pointer to  MRU extent
		     dw     0
		     dw     0
		     dw     0
FILE_HEADER	ENDS							;AN000;



EXTENT_HEADER	STRUC		   ; extend header structure		;AN000;
EH_Logic_Clus_Num    dw     0	   ; starting logical clus num of extent;AN000;
EH_Phys_Clus_Num     dw     0	   ; starting physical clus numof  extnt;AN000;
EH_Count	     dw     0	   ; range of logical clusnum in the extnt
EH_Next_Extn_Ptr     dw     0	   ; pointer to next extent		;AN000;
EH_Prev_Extn_Ptr     dw     0	   ; pointer to previous extent  ;AN000;
EH_Next_LRU_Ptr      dw     0	   ; pointer to next LRU extent
EH_Prev_LRU_Ptr      dw     0	   ; pointer tp previous LRU extent
		     dw     0
EXTENT_HEADER	ENDS




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\highexit.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Module:   HIGHEXIT.INC - Code executed after LoadHigh or DeviceHigh
;
;   Date:     May 14, 1992
;
;******************************************************************************
;
;   Modification log:
;
;     DATE    WHO      DESCRIPTION
;   --------  -------  --------------------------------------------------------
;   05/14/92  t-richj  Original
;   06/21/92  t-richj  Final revisions before check-in
;
;******************************************************************************
;
;
; Public:
;
;       PROCEDURES
;		FreeUMBs
;		HeadUMB
;               UnHideUMBs
;
; Internal:
;
;       PROCEDURES
;		freeMCB
;               he_unlink
;		isHideMCB
;               linkumb
;
; Definitions:
;
;       DOS_STRATEGY_SET -      AX value when calling int 21h, to set the DOS
;                               memory-allocation strategy.
;       DOS_UMBLINK_SET -       AX value when calling int 21h, to set the UMB
;                               link-state.
;       DOS_GET_LISTS -         AH value when calling int 21h, to get the DOS
;                               "list of lists".
;       UMB_HeadIdx -           After returning from int 21h, func 52h...
;                               ES:[Umb_HeadIdx] will contain the address of
;                               the first UMB delimiter, usually 0x9FFF... if
;                               it's 0xFFFF, then it hasn't been set yet.
;
; *****************************************************************************

DOS_STRATEGY_GET  equ   5800h	; Int 21h, Func 58h, Svc 0 = get alloc strategy
DOS_STRATEGY_SET  equ   5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
DOS_UMBLINK_GET   equ   5802h	; Int 21h, Func 58h, Svc 2 = get link state
DOS_UMBLINK_SET   equ   5803h	; Int 21h, Func 58h, Svc 3 = set link state
DOS_GET_LISTS     equ     52h	; Int 21h, Func 52h = get list of lists

UMB_HeadIdx       equ     8Ch	; Offset from ES (after func52h) to get UMBHead

;
; If HV_LoadHigh has been defined, this is going into stub.asm under
; cmd\command... and stub doesn't include dosmac.inc.  So, rather than
; include dosmac to get BREAK, its definition is just copied here.
;

ifdef HV_LoadHigh

BREAK   MACRO   subtitle	; Arena.inc, below, needs this macro... but
	SUBTTL  subtitle	; if we include dosmac to get it, we've gotta
	PAGE			; include more crap, and so on, and so on, and
ENDM				; so on, and so on, and so on, and so on...

include arena.inc	; For DeviceHigh, highload and highexit are in the
			; same module, so they both have arena.inc; in LoadHigh
endif			; they don't.

; -----------------------------------------------------------------------------
;*** UnHideUMBs - Marks HIDDEN elements as FREE
; -----------------------------------------------------------------------------
; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
;               very little to do, as no elelments will be marked as HIDDEN.
; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
; ERROR:  None
; USES:   fInHigh (from highvar.inc), carry flag
; -----------------------------------------------------------------------------

	public  UnHideUMBs

UnHideUMBs	proc	near
	push	ax		; Save ax for what we're about to do

; -----------------------------------------------------------------------------
; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
;    length of time.  Those six constitute a check of whether or not we should
;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
;    will destroy the current link-state and memory-allocation strategy after
;    every command execution.
; -----------------------------------------------------------------------------

	getdata	al, fInHigh	; Get InHigh from data segment
	or	al, al
	jnz	uhu10		; If didn't call loadhigh/devicehigh earlier,

	pop	ax		; then there's nothing to do here... so
	stc			; restore everything and return.  Just like
	ret			; that.


uhu10:	call	linkumb		; Make sure UMBs are linked in.
	call	FreeUMBs

	putdata	fInHigh, 0	; We're leaving, so update fInHigh.

	call	he_unlink	; Unlink UMBs

	pop	ax
	clc
	ret
UnHideUMBs	endp

; -----------------------------------------------------------------------------
;*** he_unlink - unlinks UMBs if fm_umb is set to 0
; -----------------------------------------------------------------------------
; ENTRY:    fm_umb == 1 : leave linked, else unlink
; EXIT:     None
; ERROR:    None
; USES:     AX, BX
; -----------------------------------------------------------------------------

he_unlink	proc	near
	xor	bh, bh
	getdata	bl, fm_umb		; Restore original link-state
	mov	ax, DOS_UMBLINK_SET
	int	21h

ifdef HV_LoadHigh
	xor	bh, bh
	getdata	bl, fm_strat		; Restore original mem-alloc strategy

	mov	ax, DOS_STRATEGY_SET
	int	21h
endif
	ret
he_unlink	endp

; -----------------------------------------------------------------------------
;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     None; HIDDEN memory elements returned to FREE
; ERROR:    None (ignore CF)
; USES:     Flags
; -----------------------------------------------------------------------------

	public	FreeUMBs

FreeUMBs	proc	near
	pushreg	<ax, es>

	call	HeadUmb		; Returns with carry if err, else ES == MCB
	jc	fusX

	mov	es, ax		; Prepare for the loop; ES = current MCB addr.

fus10:	call	isHideMCB	; Returns with ZF set if owner is 0
	jnz	fus20
	call	freeMCB

fus20:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	fusX		; That means this was the last MCB--that's it.

	mov	ax, es
	add	ax, es:[arena_size]
	inc	ax
	mov	es, ax		; Go on forward.
	jmp short fus10

fusX:	popreg	<es, ax>
	ret
FreeUMBs	endp

; -----------------------------------------------------------------------------
;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is hidden, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isHideMCB	proc	near
	push	ax

	cmp	es:[arena_owner], SystemPSPOwner	; If the owner's SYSTEM
	jnz	ihm_x					; then check for HIDDEN

	mov	ax, word ptr es:[arena_name]
	cmp	ax, 'IH'
	jnz	ihm_x
	mov	ax, word ptr es:[arena_name+2]
	cmp	ax, 'DD'
	jnz	ihm_x
	mov	ax, word ptr es:[arena_name+4]
	cmp	ax, 'NE'
	jnz	ihm_x
	mov	ax, word ptr es:[arena_name+6]
	cmp	ax, '  '

ihm_x:	pop	ax
	ret
isHideMCB	endp

; -----------------------------------------------------------------------------
;*** freeMCB - marks as free the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB free'd
; ERROR:    None
; USES:     AX
; -----------------------------------------------------------------------------

freeMCB	proc	near
	mov	es:[arena_owner], 0
	mov	ax, '  '
	mov	word ptr es:[arena_name+0], ax
	mov	word ptr es:[arena_name+2], ax
	mov	word ptr es:[arena_name+4], ax
	mov	word ptr es:[arena_name+6], ax
	ret
freeMCB	endp

; -----------------------------------------------------------------------------
;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
; -----------------------------------------------------------------------------
; ENTRY:  Nothing
; EXIT:   AX contains 0x9FFF for most systems
; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	public	HeadUmb

HeadUmb	proc	near
	pushreg	<si, ds, es>

	mov	ah, DOS_GET_LISTS	; Call int 21h, function 52h...
	int	21h

	mov	ax, es:[UMB_HeadIdx]	; And read what's in ES:008C
	cmp	ax, 0FFFFh
	jz	xhu_e			; If it's 0xFFFF, it's an error...

	clc				; Else, it isn't.
	jmp short xhu_x

xhu_e:	stc

xhu_x:	popreg	<es, ds, si>
	ret
HeadUmb	endp

; -----------------------------------------------------------------------------
;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
; ERROR:    None
; USES:     AX, BX, fm_umb
; -----------------------------------------------------------------------------

linkumb	proc	near
	mov	ax, DOS_UMBLINK_GET
	int	21h			; Current link-state is now in al

	or	al, al			; BUGBUG: proper check?
	jnz	lumbX			; Jumps if UMBs already linked in

	mov	ax, DOS_UMBLINK_SET
	mov	bx, 1
	int	21h

lumbX:
	ret
linkumb	endp
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\highload.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Module:   HIGHLOAD.INC - Code used to prepare for LoadHigh or DeviceHigh
;
;   Date:     May 14, 1992
;
;******************************************************************************
;
;   Modification log:
;
;     DATE    WHO      DESCRIPTION
;   --------  -------  ----------------------------------------------
;   05/14/92  t-richj  Original
;   06/21/92  t-richj  Final revisions before check-in
;
;******************************************************************************
;
; This file contains routines needed to parse and implement user-given
; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4".  InitVar()
; and Parsevar() are used to parse this data and place it in encoded form into
; the variables in highvar.inc, for use by the rest of the routines.
;
; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
;    DEVICEHIGH SIZE=hhhhhh module opts
; Or, DeviceHigh and LoadHigh accept any of the following:
;    DH/LH module opts
;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
; The initial UMB,SIZE pair designates the module's load address; the remainder
; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
; available during the load.
;
; When an actual load is ready to be performed, a call to HideUMBs() will
; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
; upper-memory block which was not specified by the user... in addition, if
; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
; elements in that umb SAVE the lower-half of the newly-shrunken one are also
; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
; free any UMBs so allocated.
;
; When a device driver loads, there is the additional problem of allocating its
; initial load site; this should be restricted to the first UMB specified on
; the command-line.  The function FreezeUM temporarily allocates all remaining
; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
; UMB.  Then the initial allocation may be made, and a call to UnFreeze will
; return any so-allocated memory elements to FREE, for the true load.  Note
; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
;
;******************************************************************************
;
;   Public:
;
;___PROCEDURES_________________________________________________________________
;
;   AddrToUmb   - converts a segment address in AX to its appropriate UMB #
;   BigFree     - makes ES:0 point to the largest free MCB in UMB given as AL
;   FixMem      - scans the UM chain and concatenates adjacent free MCBs
;   FreezeUM    - Marks FROZEN all UM elements now FREE, save those in load UMB
;   GetLoadSize - Returns the load UMB minimum size (0 if not specified)
;   GetLoadUMB  - Returns the load UMB number in AL (-1 if not specified)
;   GetSize     - Returns the UMB in AL's minimum size (0 if not specified)
;   GetXNum     - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
;   HideUMBs    - links UMBs and hides upper-memory as appropriate
;   InitVar     - initializes all the variables used in ParseVar and HideUMBs
;   NextMCB     - moves an MCB pointer forward to the next MCB
;   ParseVar    - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
;   PrTable     - produces a printout of the variables in highvar.inc
;   StoLoadSize - Overrides the load UMB minimum size with what's in AX
;   StoLoadUMB  - Overrides the load UMB number with what's in AL
;   UmbHead     - returns in AX the address of the first UMB block (0x9FFF)
;   UnFreeze    - Marks FROZEN elements as FREE
;
;___VARIABLES__________________________________________________________________
;
;   gnradix     - After a call to GetXNum, is 16 or 10, depending on the # read
;
;   Internal:
;___PROCEDURES_________________________________________________________________
;
;   convUMB     - checks after GetXNum to convert an address to a UMB number
;   findUMB     - makes ES:0 point to the first MCB in UMB given as AL
;   fm_link     - links UMBs not already linked in
;   fm_unlink   - unlinks UMBs if fm_umb is set to 0
;   frezMCB     - marks as 8+FROZEN the MCB at ES:0
;   hideMCB     - marks as HIDDEN the MCB at ES:0
;   hideUMB     - marks as HIDDEN all FREE elements in UMB passed as AL
;   hideUMB?    - hides as appropriate the UMB in CL
;   hl_unlink   - unlinks UMBs if fm_umb is set to 0; restores strategy too
;   incArgc     - increments fm_argc, for use with LH command-line parsing
;   isEOL       - returns with ZF set iff AL contains CR or LF, or 0
;   isFreeMCB   - returns with ZF set if current MCB (ES:0) is FREE
;   isFrozMCB   - returns with ZF set if current MCB (ES:0) is FROZEN
;   isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
;   isSysMCB    - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
;   isTiny      - returns with ZF set if user didn't specify /S
;   isWhite     - returns with ZF set iff AL contains whitespace (or "=")
;   loadLow     - returns AL==0 if UMB0 == 0, else AL==1
;   mul32       - multiplies the number in DX:AX by gnradix
;   parseL      - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
;   setUMBs     - links umbs and sets allocation strategy for a load
;   shrinkMCB   - breaks an MCB into two pieces, the lowest one's size==AX
;   stowSiz     - marks a given UMB as having a given minimum size
;   stowUMB     - marks a given UMB as used, if it hasn't been so marked before
;   toDigit     - converts a character-digit to its binary counterpart
;   toPara      - divides DX:AX by 16; result in AX only
;   toUpper     - accepts one argument (probly a register), and upper-cases it.
;   unHideMCB   - marks as FREE the MCB at ES:0
;   unMarkUMB   - marks a given UMB as unused, even if previously marked used
;
;******************************************************************************

SWTCH	equ	'/'		; Switch character

DOS_CHECK_STRATEGY  equ	5800h	; Int 21h, Func 58h, Svc 0 = check alloc strat
DOS_SET_STRATEGY    equ	5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
DOS_CHECK_UMBLINK   equ	5802h	; Int 21h, Func 58h, Svc 2 = check link state
DOS_SET_UMBLINK     equ	5803h	; Int 21h, Func 58h, Svc 3 = set link state
DOS_GET_DOS_LISTS   equ	  52h	; Int 21h, Func 52h = return list of lists
DOS_UMB_HEAD        equ	  8Ch	; Offset from ES (after func52h) to get UMBHead

CR	equ	0Dh		; Carriage Return
LF	equ	0Ah		; Line Feed
TAB	equ	09h		; Tab character (^I)

; -----------------------------------------------------------------------------
; This file needs arena.inc, but it should already have been included.  Because
; of MASM's strange method of two-pass definitions, we can't just include it
; inside of an ifndef, or it won't make it to stage two.  Odd odd odd.
; -----------------------------------------------------------------------------

; -----------------------------------------------------------------------------
;*** toUpper - accepts one argument (probly a register), and upper-cases it.
;    BUGBUG: t-richj 6/3/92 - This method, though used elsewhere (for example,
;            used in sysinit2.asm to upper-case config.sys), relies on ASCII
;            conventions.  Might be bad.
; -----------------------------------------------------------------------------

toUpper	macro	arg
	and	arg, 0DFh
	endm

; -----------------------------------------------------------------------------
;*** NextMCB - moves an MCB pointer forward to the next MCB
; -----------------------------------------------------------------------------
; ENTRY:       First arg - seg pointer (ES?); second, a scratch register (AX?)
; EXIT:        Seg pointer moved forward, scratch register = distance moved
; ERROR EXIT:  None
; USES:        Flags, arguments
; -----------------------------------------------------------------------------

NextMCB	macro	seg, reg
	mov	reg, seg
	add	reg, seg:[arena_size]
	inc	reg			; Inc 1 paragraph for the header
	mov	seg, reg
	endm

; -----------------------------------------------------------------------------
;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
; -----------------------------------------------------------------------------
; ENTRY:       None
; EXIT:        Variables listed in highvar.inc are initialized
; ERROR EXIT:  None
; USES:        Flags, variables in highvar.inc
; -----------------------------------------------------------------------------
; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
; are largely ignored, but it is initialized nonetheless.
; -----------------------------------------------------------------------------

	public	InitVar

InitVar	proc	near
	pushreg	<ax, cx, di, es>
	dataseg	es			;Point ES into appropriate data segment

	xor	ax, ax
	mov	fUmbTiny, al		;Shrink UMBs? (made 1 if /S given)
	mov	fInHigh,  al		;Set to 1 when DH/LH has been called
	mov	SegLoad,  ax		;Load Address (seg), used for DH only
	mov	UmbLoad, UNSPECIFIED	;Later is the # of the 1st spec'd UMB
	mov	fm_argc,  al		;Start with zero args having been read

	cld

	mov	cx, MAXUMB		;For each entry
	mov	di, offset ES:UmbUsed	;on the UmbUsed array,
	rep	stosb			;	Store 0

	mov	cx, MAXUMB		;Okay... for each entry
	mov	di, offset ES:UmbSize	;on the UmbSize array,
	rep	stosw			;	Store 0

	normseg	es		; Return ES

	popreg	<es, di, cx, ax>
 	ret

InitVar	endp

; -----------------------------------------------------------------------------
;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
; -----------------------------------------------------------------------------
; ENTRY   : None
; EXIT    : None
; ERROR   : None
; USES    : Flags, fm_umb, fm_strat
; -----------------------------------------------------------------------------

	public	FixMem

FixMem	proc	near

	pushreg	<ax, bx, cx, dx, es>

	call	fm_link		; Link in UMBs

	call	UmbHead		; Get first upper-memory MCB address (0x9FFF)
	jc	fmX		; (if couldn't get it, leave now).

	mov	es, ax		; It returns in AX, so move it to ES.

;
; - Walk MCB Chain ------------------------------------------------------------
;

	xor	dx, dx		; We're keeping the address of the last MCB
	mov 	cx, dx		; in CX... and the last owner
	inc	dx		; in dx as we go through the loop:

; ------------------------------------------
; FM10--DX  = last MCB's owner's PSP address
;       CX  = last MCB's address (segment)
; ------------------------------------------

fm10:	mov	al, es:[arena_signature]	; if 'Z', don't repeat loop
	mov	bx, es:[arena_owner]		; if not zero, do nothing
	or	bx, dx				; dx was owner of previous MCB
	jnz	fm30				; If not both zero, don't cat.

	; - Coalesce memory blocks at ES:00 and CX:00 -------------------------

fm20:	mov	bx, es:[arena_size]		; Grab this block's Size,
	mov	es, cx				; Go back to prev MCB's address
	mov	es:[arena_signature], al	; & move the SECOND sig here

	add	bx, es:[arena_size]		; Size += first MCB's size
	add	bx, 1h				; And add one for the header
	mov	es:[arena_size], bx		; Write the size

	; ---------------------------------------------------------------------

fm30:	mov	cx, es			; Put this address on the stack
	mov	dx, es:[arena_owner]	; And remember its owner

	NextMCB	es, bx			; Move to the next MCB

	cmp	al, arena_signature_end
	jnz	fm10			; If signature != 'Z', there are more.

fmX:	call	fm_unlink		; Unlink UMBs

	popreg	<es, dx, cx, bx, ax>
	ret

FixMem	endp

; -----------------------------------------------------------------------------
;*** fm_link - links UMBs not already linked in
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
; ERROR:    None
; USES:     AX, BX, fm_umb
; -----------------------------------------------------------------------------

fm_link	proc	near
	mov	ax, DOS_CHECK_UMBLINK
	int	21h			; Current link-state is now in al

	putdata	fm_umb, al		; So store it in fm_umb for later

	mov	ax, DOS_SET_UMBLINK
	mov	bx, 1
	int	21h

	ret
fm_link	endp

; -----------------------------------------------------------------------------
;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
; -----------------------------------------------------------------------------
; ENTRY:    fm_umb == 1 : leave linked, else unlink
; EXIT:     None
; ERROR:    None
; USES:     AX, BX
; -----------------------------------------------------------------------------

fm_unlink	proc	near
	xor	bx, bx
	getdata	bl, fm_umb		; fm_umb already has the old link-state
	mov	ax, DOS_SET_UMBLINK
	int	21h			; so just use that, and call int 21h
	ret
fm_unlink	endp

; -----------------------------------------------------------------------------
;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
; laid out in highvar.inc
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
; EXIT:     ES:SI points to first character in child program name
; ERROR:    ES:SI points to character which caused error, carry set, AX == code
; USES:     ES:SI, AX, flags, variables in highvar.inc
; -----------------------------------------------------------------------------
; Error codes (in AX if carry set on return):
;
PV_InvArg	equ	1	; Invalid argument passed
PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
PV_InvSwt	equ	3	; Unrecognized switch passed
;
; This routine exects ES:SI to point to a string much like the following:
;    "/S/L:1,200;2 module options"
; Optionally, the string can begin with whitespace; neither /S nor /L is
; required, though that's what this routine is supposed to parse.
;
optS		equ	'S'	; /S
optL		equ	'L'	; /L:...
;
; -----------------------------------------------------------------------------
; LoadHigh has a list of arguments, returned by cparse, which is used to create
; a command-line for spawning a child process.  For a typical LH command, say,
;     lh /l:1,1000;2 print/d:lpt2
; the arguments would look like (one per line):
;     lh
;     /l
;     1
;     1000
;     2
;     print
;     /d
;     :lpt2
; In short, if "print" were, say, "43", there'd be no way to determine which
; arg was the filename.  So, inside this routine, we keep a running counter
; of the number of arguments LH will need to skip in order to get to the
; program name.  The "lh" is implicit--it'll always have to skip that.  So if
; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
; for:
;    Each /L
;    Each /S (there should be only one)
;    Each UMB number (they follow ":" or ";")
;    Each UMB size   (they follow ",")
; So, in the above example, fm_argc would be 4-- and LH would skip right to
; "print".  Note that InitVar initializes fm_argc to zero.
; -----------------------------------------------------------------------------

	public	ParseVar

ParseVar	proc	near
	pushreg	<di, ds, es>

	push	es		; Make DS:SI point to it, as well as ES:SI
	pop	ds		; (regardless if we're in devhigh or loadhigh)
	cld

; ------------------------------------------------
; PV10--ES:SI = any whitespace on the command-line
; ------------------------------------------------

pv10:	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
	call	isWhite
	jz	pv10		;       ES:SI==" /L..."--keep eating.
	cmp	al, SWTCH
	jz	pv20		;       ES:SI=="/L..."--go process a switch

	dec	si		; Backup--it's now "odule options", and we need
	clc			; that "m" we just read (or whatever it is).
	jmp short pvX		; Then return with carry clear == we're done.

pv20:	lodsb			; Just read 'S' or 'L', hopefully
	toUpper	al		; So we make it upper-case, and...
	cmp	al, optS	; just read 'S'?
	jnz	pv30

	call	incArgc		; If it's /S, it's another arg for LH to skip.

	putdata	fUmbTiny, 1	; /S, so ES:SI=="  /L..." or " module opts", or
	jmp short pv10		; possibly even "/L...".

pv30:	cmp	al, optL	; If it's not 'L' either, then 'tis a bad
	jnz	pvE1		; switch!

	call	incArgc		; If it's /L, it's another arg for LH to skip.

	call	parseL
	jnc	pv10		; If no carry, go back and look for more

	dec	si		; Else, back up and exit.
	jmp short pvErr		; AX has already been set by parseL

pvE1:	mov	ax, PV_InvSwt	; Unrecognized switch passed
pvErr:	dec	si
	dec	si
	stc
pvX:	popreg	<es, ds, di>
	ret
ParseVar	endp

; -----------------------------------------------------------------------------
;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to colon
; EXIT:     ES:SI points to first character not parsed
; ERROR:    Carry set; rewind three characters and return (see ParseVar)
; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
; -----------------------------------------------------------------------------
; If the string here is terminated with anything other than whitespace or a
; switchchar (perhaps it's /S or another /L:... ), then we return with carry
; set, indicating that they've screwed up the syntax.  The 3-character rewind
; makes sure the app /L: is reported as being the culprit.
; -----------------------------------------------------------------------------

parseL	proc	near

	lodsb
	cmp	al, ':'		; Make sure they did /L:
	jnz	plE1		; If they didn't, return with carry set.

; ------------------------------------------
; PL10--ES:SI = a UMB number, after /L: or ;
; ------------------------------------------

pl10:	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
	jc	plE2		; And error if it's a bad number.
	call	convUMB		; Convert any address to a UMB number

	mov	cl, al		; Remember the UMB number
	call	stowUMB		; Mark this UMB # as used;
	jc	plE2		; If it was already marked, it'll error

	call	incArgc		; Each UMB number is another arg for LH to skip

	lodsb
	cmp	al, ';'		; Did "umb;" ?
	jz	pl10		; Yep: go back and get another UMB.

	call	isWhite		; Did "umb " ?
	jz	plX		; Yep: return (it'll go back to whitespace)

	call	isEOL		; Did "umb" ?
	jz	plSwX		; If so, backup and exit like everything's ok

	cmp	al, SWTCH	; Did "umb/" ? (as in, "/L:1,100;2/S")
	jz	plSwX		; If so, back up ES:SI one character and return

	cmp	al, ','		; Did "umb," ?
	jnz	plE1		; Just what the heck DID they do? Return error.

; --- Read a size -------------------------------------------------------------

	call	GetXNum		; Stop on "size;" or "size " or anything else
	jc	plE1		; And error if it's a bad size.

	call	toPara		; Convert from bytes to paragraphs

	call	stowSiz		; CL still has the UMB number for this routine

	call	incArgc		; Each UMB size is another arg for LH to skip

	lodsb
	cmp	al, ';'		; They did "umb,size;", so get another UMB.
	jz	pl10		;

	call	isWhite		; Did it end with whitespace?
	jz	plX		; If so, we're done here--go back.

	call	isEOL		; Did they do "umb,size" and end??? (stupid)
	jz	plSwX		; If so, backup and exit like everything's ok

	cmp	al, SWTCH	; Did they do "umb,size/" ?
	jz	plSwX		; If so, again, we're done here.

plE1:	mov	ax, PV_InvArg	; If not, we don't know WHAT they did...
	dec	si
	stc
	ret

plE2:	mov	ax, PV_BadUMB	; In this case, they've specified a UMB twice
	stc
	ret

plSwX:	dec	si		; If we hit a '/' character, back up one char
				; so the whitespace checker will see it too.

plX:	clc			; Then just return with carry clear, so
	ret			; ParseVar will go about its business.
parseL	endp

; -----------------------------------------------------------------------------
;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     None
; ERROR:    None
; USES:     fm_argc, flags
; -----------------------------------------------------------------------------

incArgc	proc	near
	push	ax

	getdata	al, fm_argc	; Obtain previous value of fm_argc,
	inc	al		; Increment it,
	putdata	fm_argc, al	; And store it right back.

	pop	ax
	ret
incArgc	endp

; -----------------------------------------------------------------------------
;*** isEOL - returns with ZF set iff AL contains CR or LF, or 0
; -----------------------------------------------------------------------------
; ENTRY:    AL contains character to test
; EXIT:     ZF set iff AL contains CR or LF, or 0
; ERROR:    None
; USES:     ZF
; -----------------------------------------------------------------------------

isEOL	proc	near
	cmp	al, 0		; Null-terminator
	jz	ieX
	cmp	al, CR		; Carriage Return
	jz	ieX
	cmp	al, LF		; LineFeed
ieX:	ret
isEOL	endp

; -----------------------------------------------------------------------------
;*** isWhite - returns with ZF set iff AL contains whitespace (or "=")
; -----------------------------------------------------------------------------
; ENTRY:    AL contains character to test
; EXIT:     ZF set iff AL contains space, tab, or equals
; ERROR:    None
; USES:     ZF
; -----------------------------------------------------------------------------

isWhite	proc	near
	cmp	al, ' '		; Space
	jz	iwX
	cmp	al, '='		; Equals (treat as whitespace)
	jz	iwX
	cmp	al, TAB		; Tab
iwX:	ret
isWhite	endp

; -----------------------------------------------------------------------------
;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
; -----------------------------------------------------------------------------
; ENTRY:    AL contains UMB number
; EXIT:     None
; ERROR:    None
; USES:     Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

unMarkUMB	proc	near
	pushreg	<ax, bx, di, es>
	dataseg	es

	xor	ah, ah
	mov	bx, ax
	mov	es:UmbUsed[bx], 0
	cmp	UmbLoad, al
	jnz	umu10

	mov	UmbLoad, 0	; If unmarked the load UMB, load into convent.

umu10:	popreg	<es, di, bx, ax>
	normseg	es
	ret
unMarkUMB	endp

; -----------------------------------------------------------------------------
;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
; listed in the /L:... chain.  If it's the first one specified, it sets UmbLoad
; to that UMB #... and in any case, it marks the UMB as specified.
; -----------------------------------------------------------------------------
; ENTRY:    AL contains UMB number, as specified by the user
; EXIT:     None
; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
; USES:     AX, Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

stowUMB	proc	near
	cmp	al, MAXUMB
	jb	su10
	stc
	ret			; Ooops-- UMB>=MAXUMB

su10:	pushreg	<bx, di, si, ds, es>

	dataseg	es		; Point ES into appropriate data segment
	dataseg	ds		; Point DS into appropriate data segment

	cmp	UmbLoad, UNSPECIFIED	; If this, we haven't been here before
	jne	su20
	mov	UmbLoad, al	; So remember this UMB as the load UMB slot.

su20:	or	al, al		; If they gave UMB 0, there's really nothing
	jz	su30		; that we should do here.

	mov	bl, al
	xor	bh, bh
	mov	ax, 1		; Now, AX = 1, and BX = UMB Number

	xchg	ES:UmbUsed[bx], al

	or	al, al		; If it was already 1, then al==1... and that
	jz	su30		; means an error.

	stc			; OOOPS!  This one's been used before.  :(

su30:	popreg	<es, ds, si, di, bx>
	normseg	ds
	normseg	es
	ret
stowumb	endp

; -----------------------------------------------------------------------------
;*** stowSiz - marks a given UMB as having a given minimum size
; -----------------------------------------------------------------------------
; ENTRY:    CL contains UMB number, AX contains size
; EXIT:     None
; ERROR:    None
; USES:     AX, DX, Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

stowSiz	proc	near
	pushreg	<bx, di, es>
	dataseg	es			; Point ES into appropriate data seg

	mov	bl, cl			; Now bl==UMB number, AX==size
	mov	bh, 0			;     bx==UMB number, AX==size
	shl	bl, 1			;     bx==offset into array, AX=size
	mov	es:UmbSize[bx], ax	; Store the size

	popreg	<es, di, bx>
	normseg	es			; Return ES to where it was
	ret
stowSiz	endp

; -----------------------------------------------------------------------------
;*** toDigit - converts a character-digit to its binary counterpart
;            -- verifies that CL contains a valid character-digit; if so, it
; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).  A-F
; are considered valid iff gnradix is 16.
; -----------------------------------------------------------------------------
; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
; USES:     CL, Flags
; -----------------------------------------------------------------------------
; If the string is preceeded with "0x", the value is read as hexadecimal; else,
; as decimal.  After a read, you may check the radix by examining gnradix--it
; will be 10 or 16.
; -----------------------------------------------------------------------------

public	gnradix
gnradix	dw	?		; Must be a word--16x16 multiplication

toDigit	proc	near
	cmp	gnradix, 16
	jnz	td20		; Don't check hex digits if radix isn't 16

	cmp	cl, 'a'
	jb	td10
	cmp	cl, 'f'
	ja	tdE		; Nothing valid above 'z' at all...
	sub	cl, 'a'-10	; Make 'a'==10 and return.
;	clc			; <- CLC is implicit from last SUB
	ret

td10:	cmp	cl, 'A'
	jb	td20		; Below 'A'?  Not a letter...
	cmp	cl, 'F'
	ja	tdE		; Above 'F'?  Not a digit.
	sub	cl, 'A'-10	; Make 'A'==10 and return.
;	clc			; <- CLC is implicit from last SUB
	ret

td20:	cmp	cl, '0'		; If less than zero,
	jb	tdE		; Done.
	cmp	cl, '9'		; Or, if greater than nine,
	ja	tdE		; Done.
	sub	cl, '0'		; Okay--make '0'==0 and return.
;	clc			; <- CLC is implicit from last SUB
	ret

tdE:	stc
	ret
todigit	endp

; -----------------------------------------------------------------------------
;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to an ascii string to scan
; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
; USES:     ES:SI, DX, AX, Flags, gnradix
; -----------------------------------------------------------------------------
; If the string is preceeded with "0x", the value is read as hexadecimal; else,
; as decimal.  After a read, you may check the radix by examining gnradix--it
; will be 10 or 16.
; -----------------------------------------------------------------------------

	public	GetXNum

GetXNum	proc	near
	pushreg	<bx, cx, ds>

	cld
	xor	ax, ax
	xor	bx, bx
	xor	cx, cx
	xor	dx, dx			; Start with 0 (makes sense)

	mov	gnradix, 10		; And default to a radix of 10 (dec)

	mov	cl, byte ptr es:[si]	; Now AX=0, BX=0, CH=0/CL=char, DX=0
	call	toDigit
	jc	gxnE			; If it's not a digit, leave now.

	or	cl, cl
	jnz	gxn20			; Doesn't have '0x'
	mov	cl, byte ptr es:[si+1]
	cmp	cl, 'x'			; Either 'x'...
	jz	gxn10
	cmp	cl, 'X'			; ...or 'X' means it's hexadecimal
	jnz	gxn20

gxn10:	mov	gnradix, 16
	inc	si			; Since we read "0x", march over it.
	inc	si

; ------------------------------------------------------
; GXN20--ES:SI = a digit in a number; if not, we're done
;        DX:AX = current total
;        BX    = 0
;        CH    = 0
; ------------------------------------------------------

gxn20:	mov	cl, byte ptr es:[si]	; Now DX:AX=current total, CH=0/CL=char
	inc	si

	call	toDigit		; Accepts only valid digits, A-F -> 10-16
	jc	gxnQ		; <- Ah... wasn't a digit.  Stop.

	call	mul32		; Multiply DX:AX by gnradix
	jc	gxnX		; (if it's too big, error out)

	add	ax, cx		; Add the digit
	adc	dx, bx		; (BX is 0!)--Adds 1 iff last add wrapped
	jc	gxnX		; If _that_ wrapped, it's too big.
	jmp short gxn20

gxnE:	stc			; In this case, we need to set the carry
	jmp short gxnX		; and leave--there were no digits given.

gxnQ:	dec	si		; Don't read in the offensive character.
	clc			; And clear carry, so they know it's okay.

gxnX:	popreg	<ds, cx, bx>
	ret
GetXNum	endp

; -----------------------------------------------------------------------------
;*** mul32 - multiplies the number in DX:AX by gnradix
; -----------------------------------------------------------------------------
; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
; ERROR:   Carry set if number was too large
; USES:    Flags, AX, DX
; -----------------------------------------------------------------------------

mul32	proc	near
	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
	mov	ax, dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
	mul	gnradix		; DX=?,      AX=new:hi, TOS=old:lo, BX=0
	jc	m32E		; Too big?

	mov	dx, ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig,   BX=0

	xchg	dx, bx		; DX=0,      AX=old:lo, TOS=orig,   BX=new:hi
	mul	gnradix		; DX=carry,  AX=new:lo, TOS=orig,   BX=new:hi
	xchg	dx, bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
	add	dx, bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
	xor	bx, bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=0
	ret

m32E:	pop	ax
	ret
mul32	endp

; -----------------------------------------------------------------------------
;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
; -----------------------------------------------------------------------------
; ENTRY:   DX:AX = the number to be divided
; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
; ERROR:   None
; USES:    Flags, AX, DX
; -----------------------------------------------------------------------------
; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
;       can't ensure a 386 host machine.  Sorry.
; -----------------------------------------------------------------------------

toPara	proc	near
	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll

	mov	cl, 4		;
	shr	ax, cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
	xchg	ax, dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
	mov	cl, 12
	shl	ax, cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
	or	ax, dx		;    AX=hhhh LLLL llll llll

	pop	cx
	ret
toPara	endp

ifdef DEBUG_PRTABLE
; -----------------------------------------------------------------------------
;*** PrTable - produces a printout of the variables in highvar.inc
;            -- The data are reported in this format:
;
;	ShrinkUMBs? (01/00)	LoadAddr (DH only)	UMB0 (load UMB number)
;	00	conv_used?	conv_size (ignored)
;	01	umb1_used?	umb1_size (00==not specified)
;	02	umb2_used?	umb2_size
;		...
;	0F	umb15_used?	umb15_size
;
; -----------------------------------------------------------------------------
; ENTRY/EXIT : Nothing
; USES:        Flags, AX
; -----------------------------------------------------------------------------
; This routine is for debugging only, and should not be included in the final
; versions of loadhigh and devicehigh (if it's called, you'll know).  To use
; it, you'll need to add "include wordout.inc" if it's not available already.
; -----------------------------------------------------------------------------

	public	PrTable

PrTable	proc	near
	pushreg	<cx, si, ds>
	dataseg	ds			; Point DS into appropriate data seg

	mov	al, fUmbTiny
	call	byteout
	printtab
	mov	ax, SegLoad
	call	wordout
	printtab
	mov	al, UmbLoad
	call	byteout
	printtab
	mov	al, fInHigh
	call	byteout
	printcr
	printcr

	xor	cx,  cx			; For each entry

; ----------------------------
; PT10--CL = index into arrays
; ----------------------------

pt10:	mov	al, cl
	call	byteout
	printtab

	mov	si, offset DS:UmbUsed	; on the UmbUsed array,
	mov	ax, cx
	add	ax, si
	mov	si, ax
	lodsb				; Get used element
	call	byteout
	printtab

	mov	si, offset DS:UmbSize	; on the UmbSize array,
	mov	ax, cx
	shl	ax,  1			; ax *= 2 (two bytes per element)
	add	ax, si
	mov	si, ax
	lodsw				; Get size element
	call	wordout
	printcr

	inc	cx
	cmp	cx, MAXUMB
	jb	pt10

	popreg	<ds, si, cx>
	normseg	ds			; Return DS
	ret
PrTable endp

endif	; DEBUG_PRTABLE

; -----------------------------------------------------------------------------
;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
; -----------------------------------------------------------------------------
; ENTRY:  Nothing
; EXIT:   AX contains 0x9FFF for most systems
; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
; USES:   Flags, AX
; -----------------------------------------------------------------------------
; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
; to be precise, before a UMB provider is around.  In this event, the pointer
; is always set to 0xFFFF; it changes once a provider is around.  On most
; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
; -----------------------------------------------------------------------------

	public	UmbHead

UmbHead	proc	near
	pushreg	<si, ds, es>

	mov	ah, DOS_GET_DOS_LISTS	; Call int 21h, function 52h...
	int	21h

	mov	ax, es:[DOS_UMB_HEAD]	; And read what's in ES:[008C]
	cmp	ax, 0FFFFh
	jz	uhE			; If it's 0xFFFF, it's an error...

	clc				; Else, it isn't (CLC done by prev cmp)
	jmp short uhX

uhE:	stc
uhX:	popreg	<es, ds, si>
	ret
UmbHead	endp

; -----------------------------------------------------------------------------
;*** isSysMCB - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
; -----------------------------------------------------------------------------
; ENTRY:  ES:0 should point to a valid MCB
; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
; USES:   Flags
; -----------------------------------------------------------------------------

isSysMCB	proc	near
	push	ax

	mov	ax, es:[arena_owner]	; Check the owner...
	cmp	ax, SystemPSPOwner	; 8 (for US OR Japan) is valid
	jz	ism10
	cmp	ax, JapanPSPOwner	; 9 (for Japan) is valid
	jz	ism10
	jmp short ismX			; Anything else isn't.

ism10:	mov	ax, word ptr es:[arena_name]	; Check the name...
	cmp	ax, 'CS'

ismX:	pop	ax
	ret
isSysMCB	endp

; -----------------------------------------------------------------------------
;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
; -----------------------------------------------------------------------------
; ENTRY:  AX contains a segment address
; EXIT:   AX will contain the UMB number which contains the address (0==conv)
; ERROR:  If the address is above UM Range, AX will return as FFFF.
; USES:   Flags, AX
; -----------------------------------------------------------------------------
; An address in the following areas is treated as:
;    0      <-> umbhead (0x9FFF)          = Conventional memory
;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
;      ...
;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
; -----------------------------------------------------------------------------

AddrToUmb	proc	near
	pushreg	<cx, dx, es>

	mov	dx, ax		; DX = address to search for

	call	UmbHead		; AX = first segment
	jc	atuE		; If it couldn't get it, error out.

	mov	es, ax		; ES = first UMB segment
	xor	cx, cx		; Pretend we're on UMB 0 for now... (cx = UMB#)

; ----------------------------------------
; ATU10--ES - Current MCB address
;        DX - Address given for conversion
;        CX - Current UMB #
; ----------------------------------------

atu10:	mov	ax, es
        cmp	ax, dx		; Present segment >= given segment?
	jae	atuX		; Yep--done.

	call	isSysMCB	; Returns with ZF set if this is a system MCB
	jnz	atu20

	inc	cx		; If it _was_ a system MCB, we're in a new UMB.

atu20:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	atu30		; 'Z' means this was the last MCB... that's it.

	NextMCB	es, ax

	jmp short atu10

; -----------------------------------------------------------------------------
; if we get to atu30, they specified a number that was past the last MCB.
; make sure it's not _inside_ that MCB before we return an error condition.
; -----------------------------------------------------------------------------

atu30:	mov	ax, es
	add	ax, es:[arena_size]
	cmp	ax, dx		; Present >= given?
	jae	atuX		; Yep! It _was_ inside.

atuE:	xor	cx, cx		; Else, fall through with UMB # == -1
	dec	cx		; (that makes it return 0xFFFF and sets CF)

atuX:	mov	ax, cx		; Return the UMB number in AX
	popreg	<es, dx, cx>
	ret
AddrToUmb	endp

; -----------------------------------------------------------------------------
;*** convUMB - checks after GetXNum to convert an address to a UMB number
;            -- if GetXNum read a hex number, we interperete that as a segment
; address rather than a UMB number... and use that address to look up a UMB.
; This routine checks for that condition and calls AddrToUmb if necessary.
; -----------------------------------------------------------------------------
; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
; EXIT:   AX will contain a UMB number
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

convUMB	proc	near
	cmp	gnradix, 16
	jnz	cu10		; If it didn't read in hex, it's not an address
	call	AddrToUmb	; Else, convert the address to a UMB number
	cmp	ax, 0FFFFh
	jnz	cu10
	inc	ax		; If too high, ignore it (make it conventional)
cu10:	ret
convUMB	endp

; -----------------------------------------------------------------------------
;*** setUMBs - links umbs and sets allocation strategy for a load
;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
; of the usual HIGH_FIRST.  See the code.
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   None
; ERROR:  None
; USES:   Flags, fm_umb, fm_strat
; -----------------------------------------------------------------------------

setUMBs	proc	near
	pushreg	<ax, bx>

	call	fm_link

ifdef HV_LoadHigh
	mov	ax, DOS_CHECK_STRATEGY
	int	21h

	putdata	fm_strat, al	; Store the current strategy for later restore

	and	ax, 007Fh	; 0000.0000.0111.1111 == All that other stuff
	push	ax		; Watch this carefully...

	call	loadLow		; returns al==0 if load low, al==1 if loadhigh
	ror	al, 1		; Shift that to al==0 or al==0x80

	pop	bx		; ...pushed as AX above
	or	bl, al		; Now we have 0000.0000.?111.1111 in BX;

	mov	ax, DOS_SET_STRATEGY ; with ? ==1 if load highfirst.  Perfect!

	int	21h
endif

	popreg	<bx, ax>
	ret
setUMBs	endp

; -----------------------------------------------------------------------------
;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
;         Carry set if UMB0 not specified (_NOT_ an error)
; ERROR:  None
; USES:   Flags, fm_strat, fm_umb
; -----------------------------------------------------------------------------
; We want to set the memory strategy to LOW_FIRST if the user specified a
; load UMB, and it is 0.  That 0 can be either from the user having _specified_
; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
; such that the load UMB is too small, and shouldn't be used.
; -----------------------------------------------------------------------------


loadLow	proc	near
	push	ds
	dataseg	ds		; Point DS into appropriate data segment

	mov	al, UmbLoad
	cmp	al, UNSPECIFIED
	jnz	ll10

	mov	al, 1		; Return with AL==1 && STC if no UMBs specified
	stc
	jmp short llX

ll10:	or	al, al		; AL=the load UMB: Is it == 0?
	jz	llX		; Yep... CF==0 (from OR) && AL=0, so just exit

	mov	al, 1
	clc

llX:	pop	ds		; Return DS to where it was
	normseg	ds		;
	ret
loadLow	endp

; -----------------------------------------------------------------------------
;*** HideUMBs - links UMBs and hides upper-memory as appropriate
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   None
; ERROR:  None
; USES:   Flags, fm_strat, fm_umb
; -----------------------------------------------------------------------------

	public	HideUMBs

HideUMBs	proc
	pushreg	<ax, cx, ds, es>

	call	UmbTest		; See if we REALLY linked in anything...
	jc	husX		; ...if not, there's nothing for us to do.

	call	FixMem		; Concatenate adjacent free MCBs in upper mem
	call	setUMBs		; Link UMBs and set memory-allocation strategy

	putdata	fInHigh, 1	; Remember that we're now running high

	call	GetLoadUMB	; See if they gave us a list to leave free
	cmp	al, UNSPECIFIED	; If they didn't,
	jz	husX		; then we shouldn't do this loop:

	xor	cx, cx

; -----------------------------------------------
; HUS10-CX - UMB number (after inc, 1==first UMB)
; -----------------------------------------------

hus10:	inc	cx		; For each UMB:
	cmp	cx, MaxUMB
	jae	hus20

	mov	al, cl		; (stopping as soon as we're outside of the
	push	es
	call	findumb		; valid range of UMBs)
	pop	es		; push/pop: trash what findumb finds.  :-)
	jc	hus20

	call	hideUMB?	; hide what we need to hide.

	jmp short hus10

hus20:	call	GetLoadUMB	; Now check if they offered /L:0
	or	al, al		; --Is the load UMB 0? (-1==unspecified)
	jnz	husX		; If not, we're done.

	call	hl_unlink	; If so, however, fix UMBs and strategy.

husX:	popreg	<es, ds, cx, ax>
	ret
HideUMBs	endp

; -----------------------------------------------------------------------------
;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AL == load UMB
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	public	GetLoadUMB

GetLoadUMB	proc	near
	getdata	al, UmbLoad
	ret
GetLoadUMB	endp

; -----------------------------------------------------------------------------
;*** GetLoadSize - Returns the load UMB minimum size (0 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AX == load UMB minimum size
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	public	GetLoadSize

GetLoadSize	proc	near
	pushreg	<bx, si, ds>
	dataseg	ds

	mov	al, UmbLoad

	xor	ah, ah			;    ax==UMB
	mov	bx, offset DS:UmbSize	;                     bx==array
	shl	al, 1	                ;    ax==offset
	add	ax, bx			;    ax==element index
	mov	si, ax			; ds:si==element index

	lodsw				;    ax==size

	popreg	<ds, si, bx>
	normseg	ds
	ret
GetLoadSize	endp

; -----------------------------------------------------------------------------
;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  AL == a UMB number
; EXIT:   AX == UMB minimum size, as specified by the user
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

GetSize	proc	near
	pushreg	<bx, si, ds>
	dataseg	ds

	xor	ah, ah			;    ax==UMB
	mov	bx, offset DS:UmbSize	;                     bx==array
	shl	al, 1	                ;    ax==offset
	add	ax, bx			;    ax==element index
	mov	si, ax			; ds:si==element index

	lodsw				;    ax==size

	popreg	<ds, si, bx>
	normseg	ds
	ret
GetSize	endp

; -----------------------------------------------------------------------------
;*** StoLoadUMB - Overrides the load UMB number with what's in AL
; -----------------------------------------------------------------------------
; ENTRY:   AL == new load UMB
; EXIT:    None
; ERROR:   None
; USES:    Flags, AX
; -----------------------------------------------------------------------------
; CAUTION: Should only be used if /L:... was used.  Logically, that is the only
;          time you would ever need this, so that's okay.
; -----------------------------------------------------------------------------

	public	StoLoadUMB

StoLoadUMB	proc	near
	putdata	UmbLoad, al
	ret
StoLoadUMB	endp

; -----------------------------------------------------------------------------
;*** StoLoadSize - Overrides the load UMB minimum size with what's in AX
; -----------------------------------------------------------------------------
; ENTRY:  AL == new load size
; EXIT:   None
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	public	StoLoadSize

StoLoadSize	proc
	push	dx

	getdata	dl, UmbLoad		; Put UMB# in DL and size in AX
	cmp	dl, UNSPECIFIED
	jz	sls10

	call	stowsiz			; We've got a function to do just this

sls10:	pop	dx
	ret
StoLoadSize	endp

; -----------------------------------------------------------------------------
;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
; -----------------------------------------------------------------------------
; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
; EXIT:     None; free elements in UMB marked as hidden
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

hideUMB	proc	near
	pushreg	<ax, es>

	call	findUMB		; Returns with carry if err, else ES == MCB
	jc	huX

; ------------------------------------------------
; HU10--ES - MCB inside UMB; if it's a system MCB,
;            we're not in the same UMB, so exit.
; ------------------------------------------------

hu10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jz	huX		; If it is, we've finished the UMB.
	call	isFreeMCB	; Returns with ZF set if owner is 0
	jnz	hu20

	call	hideMCB

hu20:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	huX		; 'Z' means this was the last MCB... that's it.

	NextMCB	es, ax		; Go on forward.

	jmp short hu10

huX:	popreg	<es, ax>
	ret
hideUMB	endp

; -----------------------------------------------------------------------------
;*** isTiny - returns with ZF set if user didn't specify /S
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     ZF set if user DIDN'T specify /S
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isTiny	proc	near
	push	ax
	getdata	al, fUmbTiny
	or	al, al
	pop	ax
	ret
isTiny	endp

; -----------------------------------------------------------------------------
;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is free, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isFreeMCB	proc	near
	or	ES:[arena_owner], 0
	ret
isFreeMCB	endp

; -----------------------------------------------------------------------------
;*** hideMCB - marks as HIDDEN the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB marked as HIDDEN
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

hideMCB	proc	near
	mov	es:[arena_owner], SystemPSPOwner
	mov	word ptr es:[arena_name+0], 'IH'
	mov	word ptr es:[arena_name+2], 'DD'
	mov	word ptr es:[arena_name+4], 'NE'
	mov	word ptr es:[arena_name+6], '  '
	ret
hideMCB	endp

; -----------------------------------------------------------------------------
;*** unHideMCB - marks as FREE the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB marked as FREE
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

unHideMCB	proc	near
	push	ax
	mov	es:[arena_owner], FreePSPOwner
	mov	ax, '  '
	mov	word ptr es:[arena_name+0], ax
	mov	word ptr es:[arena_name+2], ax
	mov	word ptr es:[arena_name+4], ax
	mov	word ptr es:[arena_name+6], ax
	pop	ax
	ret
unHideMCB	endp

; -----------------------------------------------------------------------------
;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
; ERROR:    Carry set if couldn't reach UMB (too high)
; USES:     Flags, ES
; -----------------------------------------------------------------------------

findUMB	proc	near
	pushreg	<ax, cx, dx>

	xor	ah, ah		; Zap ah, so al==ax

	mov	dx, ax		; Store the to-be-found UMB number in DX

	call	UmbHead		; Returns first UMB segment in AX
	mov	es, ax
	xor	cx, cx		; Pretend we're on UMB 0 for now...

; ---------------------------------------------
; FU10--CX - This UMB number; 0 == conventional
;       DX - The UMB number they're looking for
;       ES - The current MCB address
; ---------------------------------------------

fu10:	cmp	cx, dx		; If CX==DX, we've found the UMB we're
	jz	fuX		; searching for--so exit.

	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jnz	fu20

	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.

fu20:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	fuE		; 'Z' means this was the last MCB... that's it.

	NextMCB	es, ax		; Go on forward.

	jmp short fu10

fuE:	stc
fuX:	popreg	<dx, cx, ax>	; The address is already in ES.
	ret
findUMB	endp

; -----------------------------------------------------------------------------
;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
; ERROR:    Carry set if couldn't reach UMB (0 or too high)
; USES:     Flags, ES
; -----------------------------------------------------------------------------

	public	BigFree

BigFree	proc	near
	pushreg	<bx, cx>

	call	findUMB			; Returns with CF if err, else ES==MCB
	jc	bfX			; (would be "jc bfE"; it just does stc)

	xor	bx, bx			; Segment address of largest free MCB
	xor	cx, cx			; Size of largest free MCB

; ---------------------------------------------
; BF10--ES - Current MCB address
;       BX - Address of largest free MCB so far
;       CX - Size of largest free MCB so far
; ---------------------------------------------

bf10:	call	isSysMCB		; If we've left the MCB, we're done.
	jz	bf30

	call	isFreeMCB		; Returns with ZF set if owner is 0
	jnz	bf20

	cmp	cx, es:[arena_size]	; Compare sizes...
	jg	bf20			; Unless we're bigger,

	mov	bx, es			; Store this new element's address,
	mov	cx, es:[arena_size]	; and its size.

bf20:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	bf30			; 'Z' means this was the last MCB.

	NextMCB	es, ax			; Go on forward.

	jmp short bf10

bf30:	mov	es, bx			; Return the address
	mov	ax, cx			; Return the size
	or	bx, bx
	jnz	bfX			; (if size==0, there's nothing free)

bfE:	stc
bfX:	popreg	<cx, bx>

	ret
BigFree	endp

; -----------------------------------------------------------------------------
;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isSpecified	proc	near
	push	ax

	xor	bh, bh
	mov	bl, al
	getdata	al, DS:UmbUsed[bx]
	or	al, al			; Sets ZF if al==0 (ie, if unspecified)

	pop	ax
	ret
isSpecified	endp

; -----------------------------------------------------------------------------
;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
; -----------------------------------------------------------------------------
; ENTRY:    AX == new size, ES:0 == current MCB
; EXIT:     None; MCB broken if carry clear
; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
; USES:     Flags
; -----------------------------------------------------------------------------
; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
; the specified new size, the split is useless; if it's onnly 0x10 bytes, that
; 0x10 will be used to make a header that mentions a 0-byte free space, and
; that just sucks up 0x10 bytes for nothing.  So we make 0x20 bytes the
; minimum for performing a split.
; -----------------------------------------------------------------------------

MIN_SPLIT_SIZE	equ	20h

shrinkMCB	proc	near
	pushreg	<bx, cx, es>

	mov	bx, ax			; Move things around... and
	mov	ax, es			; save this one for later.

	mov	cx, es:[arena_size]
	sub	cx, MIN_SPLIT_SIZE
	cmp	bx, cx			; {New size} vs {Current Size-20h}
	ja	smE			; if wanted_size > cur-20h, abort.

	mov	dl, es:[arena_signature]
	mov	cx, es:[arena_size]

	mov	word ptr es:[arena_size], bx
	mov	byte ptr es:[arena_signature], 'M'

	add	ax, bx
	inc	ax
	mov	es, ax			; Move to new arena area

	mov	ax, cx
	sub	ax, bx
	dec	ax			; And prepare the new size

	mov	byte ptr es:[arena_signature], dl
	mov	word ptr es:[arena_owner], 0
	mov	word ptr es:[arena_size], ax
	mov	ax, '  '
	mov	word ptr es:[arena_name+0], ax
	mov	word ptr es:[arena_name+2], ax
	mov	word ptr es:[arena_name+4], ax
	mov	word ptr es:[arena_name+6], ax

	clc
	jmp short smX

smE:	stc

smX:	popreg	<es, cx, bx>
	ret
shrinkMCB	endp

; -----------------------------------------------------------------------------
;*** hideUMB? - hides as appropriate the UMB in CL
; -----------------------------------------------------------------------------
; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
; EXIT:     None; UMB is hidden as necessary
; ERROR:    None
; USES:     Flags, AX, CX
; -----------------------------------------------------------------------------
; PRIMARY LOGIC:
;
; If the UMB is specified in the DH/LH statement, then:
;    If the largest free segment is too small (check specified size), then:
;       Pretend it wasn't ever specified, and fall out of this IF.
;    Else, if largest free segment is LARGER than specified size, then:
;       If /S was given on the command-line, then:
;          Break that element into two pieces
;          Set a flag that we're shrinking
;       Endif
;    Endif
; Endif
; If the UMB is NOT specified (or was removed by the above):
;    Hide all free elements in the UMB
;    If the flag that we're shrinking was set, then:
;       UN-hide the lower portion of the shrunken UMB
;    ENDIF
; ENDIF
; -----------------------------------------------------------------------------

hideUMB?	proc
	pushreg	<bx, dx, es>

	mov	al, cl
	call	isSpecified	; Returns ZF set if al's umb was NOT specified
	jz	hu?20

	mov	al, cl		; Retrieve the size of the largest
	call	BigFree		; free element in AX; put its address in ES
	jc	hu?20		; Oops.  Errors mean skip this part.

	push	ax		; TOS==size of BigFree in UMB (popped as BX)
	mov	al, cl		; Retrieve the user's specified
	call	GetSize		; minimum size for this umb (into AX)
	pop	bx		; Now BX==BigFree, AX==Specified Size

	or	ax, ax		; If they didn't specify one,
	jz	hu?20		; Skip over all this.

	cmp	ax, bx		; Ah... if (specified > max free)
	jbe	hu?10

	mov	al, cl		;    Then mark that UMB as unused.  Nya nya.
	call	unMarkUMB
	jmp short hu?20

hu?10:	call	isTiny		; Returns ZF clear if user specified /S
	jz	hu?20

	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
	jc	hu?20		; Ah... if didn't shrink after all, skip this:

	mov	dx, es
	jmp short hu?30		; Skip the spec check.. we wanna hide this one.

hu?20:	mov	ax, cx
	call	isSpecified	; If they specified this UMB, we're done...
	jnz	hu?X		; so leave.

	xor	dx, dx

hu?30:	mov	al, cl

	call	hideUMB		; Hides everything in UMB #al

	or	dx, dx		; Did we shrink a UMB?  If not, DX==0,
	jz	hu?X		; So we should leave.

	mov	es, dx		; Ah, but if it isn't, DX==the MCB's address;
	call	unHideMCB	; Un-hides the lower portion of that MCB.

hu?X:	popreg	<es, dx, bx>
	ret
hideUMB?	endp

; -----------------------------------------------------------------------------
;*** UnFreeze - Marks FROZEN elements as FREE
; -----------------------------------------------------------------------------
; Entry:  None
; Exit:   None; all 8+FROZEN elements are marked as FREE, from any UMB.
; Error:  None
; Uses:   Flags
; -----------------------------------------------------------------------------

	public  UnFreeze

UnFreeze	proc	near
	pushreg	<ax, es>

	call	UmbHead		; Returns with carry if err, else ES == MCB
	jc	ufX

	mov	es, ax

; ------------------------------
; UF10--ES - Current MCB address
; ------------------------------

uf10:	call	isFrozMCB	; Returns with ZF set if MCB is FROZEN
	jnz	uf20
	call	unHideMCB

uf20:	mov	al, es:[arena_signature]

	cmp	al, arena_signature_end
	jz	ufX		; 'Z' means this was the last MCB... that's it.

	NextMCB	es, ax		; Go on forward.
	jmp short uf10

ufX:	popreg	<es, ax>
	ret
UnFreeze	endp

; -----------------------------------------------------------------------------
;*** isFrozMCB - returns with ZF set if current MCB (ES:0) is FROZEN
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is frozen, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isFrozMCB	proc	near
	push	ax

	mov	ax, es:[arena_owner]	; Check the owner...
	cmp	ax, SystemPSPOwner	; 8 (for US OR Japan) is valid
	jnz	ifmX

	mov	ax, word ptr es:[arena_name]
	cmp	ax, 'RF'
	jnz	ifmX
	mov	ax, word ptr es:[arena_name+2]
	cmp	ax, 'ZO'
	jnz	ifmX
	mov	ax, word ptr es:[arena_name+4]
	cmp	ax, 'NE'
	jnz	ifmX
	mov	ax, word ptr es:[arena_name+6]
	cmp	ax, '  '

ifmX:	pop	ax
	ret
isFrozMCB	endp

; -----------------------------------------------------------------------------
;*** frezMCB - marks as 8+FROZEN the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB frozen
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

frezMCB	proc	near
	mov	es:[arena_owner], SystemPSPOwner
	mov	word ptr es:[arena_name+0], 'RF'
	mov	word ptr es:[arena_name+2], 'ZO'
	mov	word ptr es:[arena_name+4], 'NE'
	mov	word ptr es:[arena_name+6], '  '
	ret
frezMCB	endp

; -----------------------------------------------------------------------------
;*** FreezeUM - Marks FROZEN all UM elements now FREE, save those in load UMB
; -----------------------------------------------------------------------------
; Entry:  None
; Exit:   None; all free elements not in load UMB marked as 8+FROZEN
; Error:  None
; Uses:   Flags
; -----------------------------------------------------------------------------

FreezeUM	proc	near
	pushreg	<ax, cx, dx, es>

	call	GetLoadUMB
	xor	ah, ah		; Zap ah, so al==ax
	mov	dx, ax		; Store the load UMB in DX, so we can skip it

	call	UmbHead		; Returns first UMB segment in AX
	mov	es, ax
	xor	cx, cx		; Pretend we're on UMB 0 for now...

; -----------------------------------------
; FUM10--ES - Current MCB address
;        CX - Current UMB number
;        DX - UMB number to skip (load UMB)
; -----------------------------------------

fum10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jnz	fum20

	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.

fum20:	cmp	cx, dx		; If this is the load UMB, we don't want to
	jz	fum30		; freeze anything... so skip that section.

	call	isFreeMCB	; Oh.  If it's not free, we can't freeze it
	jnz	fum30		; either.

	call	frezMCB

fum30:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	fumX		; 'Z' means this was the last MCB... that's it.

	NextMCB	es, ax		; Go on forward.
	jmp short fum10

fumX:	popreg	<es, dx, cx, ax>
	ret
FreezeUM	endp

; -----------------------------------------------------------------------------
;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     Carry is clear if UMBs are available, or set if they are not
; ERROR:    None
; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
; -----------------------------------------------------------------------------

	public	UmbTest

UmbTest	proc	near
	pushreg	<ax, bx, ds, es>

	call	fm_link			; Link in UMBs (if not already linked)
	call	WalkMem			; Check to see if they're really linked
	pushf				; And remember what we found out
	call	fm_unlink		; Unlink UMBs (if WE have linked 'em)
	popf				; And restore what we found out.

	popreg	<es, ds, bx, ax>
	ret
UmbTest	endp

; -----------------------------------------------------------------------------
;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

WalkMem	proc	near
	pushreg	<ax, bx, es>

	mov	ah, DOS_GET_DOS_LISTS	; Call int 21h, function 52h...
	int	21h

	mov	ax, es:[bx -2]
	mov	es, ax

; ------------------------------
; UM10: ES = Current MCB pointer
; ------------------------------

um10:	mov	al, es:[arena_signature]
	cmp	al, arena_signature_end
	jz	um20			; If signature == 'Z', hay no more.

	NextMCB	es, bx			; Move to the next MCB
	jmp short um10			; And restart the loop.

um20:	mov	ax, es
	cmp	ax, 9FFFh		; This sets CF iff ax < 9FFF.

	popreg	<es, bx, ax>
	ret
WalkMem	endp

; -----------------------------------------------------------------------------
;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
; -----------------------------------------------------------------------------
; ENTRY:    fm_umb == 1 : leave linked, else unlink
; EXIT:     None
; ERROR:    None
; USES:     AX, BX
; -----------------------------------------------------------------------------

hl_unlink	proc	near
	xor	bh, bh
	getdata	bl, fm_umb		; Restore original link-state
	mov	ax, DOS_SET_UMBLINK
	int	21h

ifdef HV_LoadHigh
	xor	bh, bh
	getdata	bl, fm_strat		; Restore original mem-alloc strategy

	mov	ax, DOS_SET_STRATEGY
	int	21h
endif
	ret
hl_unlink	endp
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\int2a.inc ===
BREAK	<Int 2A Definitions>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Int 2A functions
;
;	Int 2A is an interface to the network code; it's also overloaded
;		as a critical section handler since critical sections
;		were originally created to support the net.


;**	This table was created by examining the source and may not be
;	complete or completely accurate - JGL
;
;	M010	MD	8/31/90 - Added definition for AH = 5

;	(ah) = 0	installation check
;			   (returns ah !=0 if installed)
;	(ah) = 1	cooked net bios call
;	(ah) = 3	query drive shared
;			   (ds:si) = "n:" asciz string
;	(ah) = 4	net bios
;	       (al) = 0	   cooked net bios call
;	       (al) = 1	   raw net bios call
;	       (al) = 2	   ???
;
;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
;			NCBs available/outstanding. DX returns the number of
;			sessions. Supposedly, this is documented in an old
;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
;			Manager 2.0 Enhanced responds to it. But it should
;			not be used, as it is a hack, only to get Lotus
;			Notes running.
;
;	(ah) = 80h	enter critical section
;	(ah) = 81h	leave critical section
;	(ah) = 82h	free all critical sections (Leave-all)
;	(ah) = 84h	entering idle loop (don't understand how this works)


	Break <Critical sections>


;**	Critical section definitions
;
;	Although DOS is not designed to be reentrant there are some hacks
;	which various programs use to make it so, in a limited fashion.
;	Both WIN386 and some servers block copy a section of the DOS data
;	area so that DOS can be reentered on behalf of another thread/program.
;	DOS's global data structures, such as the memory arena, are not
;	in this area, so critical section indicators are used to protect
;	those areas.  DOS flags a critical section by issuing an INT_IBM
;	(int 2Ah) at each critical section entry and exit.  Some clients
;	(such as WIN386) just don't "context switch" the DOS when one
;	of these is in effect, others, such as the IBM server, go ahead
;	and reenter the DOS and if they get an int 2A to reenter the same
;	critical section they then switch away from that second thread and
;	let the first one finish and exit the section.
;
;	These below are subject to leave-all sections

critDisk    EQU     1			; Disk I/O critical section
critShare   EQU     1			; Sharer I/O critical section
critMem     EQU     1			; memory maintenance critical section
critSFT     EQU     1			; sft table allocation
critDevice  EQU     2			; Device I/O critical section
critNet     EQU     5			; network critical section
critIFS     EQU     6			; ifsfunc critical section

;	These below are not subject to leave-all sections

critASSIGN  EQU     8			; Assign has munged a system call

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\magicdrv.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1992
;	All Rights Reserved.
;

; MagicDrv Int 2Fh Equates

multMagicdrv	equ	4a11h	; Int2f multiplex number

MD_VERSION	equ	0	; Get driver version #
MD_DRIVE_MAP	equ	1	; Get drive mapping info function


; PLAIN_BPB - This is a simple BPB as DOS defines it. Refer to DOS technical
;	      manual for more details

PLAIN_BPB	struc
jmpBOOT 	db	3 dup (?)	;jump to bootstrap routine
achOEMName	db	8 dup (?)	;OEM Name
cbPerSec	dw	?		;count of bytes per sector
csecPerClu	db	?		;count of sectors per cluster
csecReserved	dw	?		;reserved sectors
cFATs		db	?		;count of FATs
cRootDirEntries dw	?		;count of root dir entries
csecTotalWORD	dw	?		;count of total sectors
bMedia		db	?		;media descriptor byte
csecFAT 	dw	?		;count of sectors in FAT
csecPerTrack	dw	?		;count of sectors per track
cHeads		dw	?		;count of disk heads
csecHidden	dd	?		;count of hidden sectors
csecTotalDWORD	dd	?		;count of total sectors
					;  (if csecTotalWORD = 0)
PLAIN_BPB	ends



; MD_BPB - This is the structure that is stored at teh begining of the
;	   MagicDrv Compressed Volume File (CVF).  Early versions of
;	   MagicDrv used different names for the MD_BPB fields;  these
;	   names are documented after this structure.

MD_BPB		struc

dos_bpb 	db  (SIZE PLAIN_BPB) dup (?)	;starts with a normal DOS BPB

secMDFATStart	dw	?	;logical sector of MD FAT start
nLog2cbPerSec	db	?	;Power 2 of sector size
csecMDReserved	dw	?	;sector count reserved for internal tables
secRootDirStart dw	?	;logical sector of root directory start
secHeapStart	dw	?	;logical sector of sector heap start
cluFirstData	dw	?	;first internal 'cluster' which contains data
cpageBitFAT	db	?	;count of pages for bit_fat table
		dw	?	;reserved
nLog2csecPerClu db	?	;Power 2 of csecPerClu (sectors per cluster)
		dw	?	;reserved

cbCVFMin	dd	?	;minimum CVF size in bytes
		dd	?	;reserved
f12BitFAT	db	?	;NZ if 12 bit FAT, Z if 16 bit FAT
cmbCVFMax	dw	?	;maximum CVF size, in megabytes

MD_BPB		ends


; Following is a mapping of the new MD_BPB field names to the old
; "our_bpb" names.
;
;  secMDFATStart	sqztor_cluster_o
;  nLog2cbPerSec	sector_pow2
;  csecMDReserved	log_internal
;  secRootDirStart	first_root
;  secHeapStart 	first_data
;  cluFirstData 	first_cluster
;  cpageBitFAT		b_fat_parts
;  nLog2csecPerClu	sectors_p_unit_pow2
;			pass_off
;  cbCVFMin		min_file
;			max_file
;  f12BitFAT		xfat_12bit
;  cmbCVFMax		max_cap
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\highvar.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Module:   HIGHVAR.INC - Data common to LOADHIGH and DEVICEHIGH, res seg
;
;   Date:     May 14, 1992
;
;******************************************************************************
;
;   Modification log:
;
;     DATE    WHO      DESCRIPTION
;   --------  -------  --------------------------------------------------------
;   05/14/92  t-richj  Original
;   06/21/92  t-richj  Final revisions before check-in
;
;******************************************************************************
;
; There are two primary definitions which need to be made, selectively, before
; this include file should be used.  These are:
;    HV_Extern - If this has been defined, variables for this module will be
;                declared as external.  Otherwise, variables will be declared
;                public, as well as defined, here.  LoadHigh declares HV_Extern
;                in stub.asm and loadhi.asm, and does not declare it in
;                rdata.asm... DeviceHigh does not declare HV_Extern anywhere
;                (as only one module, sysconf.asm, includes this file).
;    HV_LoadHigh - This should be defined when this module is going into
;                  command.com, for LoadHigh.  All of loadhi.asm, stub.asm and
;                  rdata.asm define this, while io.sys' sysconf.asm does not.
;
;******************************************************************************

;
; To keep track of which UMBs were specified on the DH/LH command lines, and
; to keep track of the minimum sizes given for each, there're two arrays kept
; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
; big.  16 should be around 14 too many for most users, so there's no expected
; space problem (it's just such a nice round number, eh?).
;

MAXUMB	equ	16

;
; Memory elements owned by the system are marked as PSP address 8 in both the
; USA and Japan; Japanese systems also use 9 under more bizzarre conditions.
;

FreePSPOwner	equ	0	; Free MCBs all have an owner PSP address of 0
SystemPSPOwner	equ	8
JapanPSPOwner	equ	9

; -----------------------------------------------------------------------------
;*** ih_local - declares data+public if HV_Extern not defined, else as extrn
;             -- One module for each executable using highvar.inc should _not_
; define HV_Extern before including it; that way, variables are local to one
; module only, and external to the rest.
; -----------------------------------------------------------------------------
; These macros make stuff external or public+declared depending on whether
; or not HV_Extern has been defined for this module.  For example:
;
;    randomdata	flag, byte, db, 1
;
; will evaluate to
;
;    extrn	randomdata :byte
;
; for any modules where HV_Extern has been defined, and to
;
;    public	randomdata
;    randomdata	db 1
;
; for any modules (there should be only one) which haven't declared HV_Extern.
; -----------------------------------------------------------------------------

ifdef	HV_Extern
	ih_local  macro  data, type, real, val
		extrn	data :type
	endm
else
	ih_local  macro  data, type, real, val, val2, val3
		public	data
		data	real	val	val2	val3
	endm
endif

;
; Now, using these macros, we declare or define the following pieces of data
; for LoadHigh and DeviceHigh:
;
;	fInHigh - Is set to 1 during HideUMBs(), and back to zero in
;	          UnHideUMBs().
;	fUmbTiny - Is set to 1 iff the user has specified /S on the command-
;	           line.
;	SegLoad - Segment address for first UMB specified; set automatically.
;	UmbLoad - The load UMB number; for example, this is 3 if the user has
;	          given a command-line like "/L:3,500;4"
;	UmbUsed - An array of characters, each of which is 1 iff the UMB
;	          matching its index number was specified on the command-line;
;	          for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
;	          will be set to 1.  All others will be set to 0.
;	UmbSize - An array of words, each of which is interpereted as a size
;	          specified by the user for a UMB (in the above example, all
;	          elements would be zero save UmbSize[3], which would be 500.
;	fm_umb - Set to the old UMB link-state (0x80 or 0x00)
;	fm_strat - Set to the old memory-allocation strategy (0$00000???)
;	fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
;	           for details).
;

	ih_local fInHigh,  byte, db, 0
	ih_local fUmbTiny, byte, db, ?
	ih_local SegLoad,  word, dw, ?
	ih_local UmbLoad,  byte, db, ?
	ih_local UmbUsed,  byte, db, MAXUMB dup (?)
	ih_local UmbSize,  word, dw, MAXUMB dup (?)

	ih_local fm_umb,   byte, db, ?
	ih_local fm_strat, byte, db, ?
	ih_local fm_argc,  byte, db, ?

;
; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
; UmbLoad is set to the UMB number given.
;

UNSPECIFIED	equ	-1

; -----------------------------------------------------------------------------
;*** dataseg - moves a segment ptr (es/ds/etc) to the data segment for HighVar
;            -- LoadHigh keeps HighVar variables in the resident data segment.
; -----------------------------------------------------------------------------
; ENTRY:       Segment ("dataseg ds" etc)
; EXIT:        Given segment points to appropriate data segment for LH or DH
; ERROR EXIT:  None
; USES:        AX, given segment
; ASSUMES:     For LoadHigh, ds:ResSeg points to DATARES
; -----------------------------------------------------------------------------

; -----------------------------------------------------------------------------
;*** normseg - returns a given segment (es/ds/etc) to its default segment
; -----------------------------------------------------------------------------
; ENTRY:       Segment ("normseg es", etc)
; EXIT:        Given segment points to appropriate data segment for LH or DH
; ERROR EXIT:  None
; USES:        AX, given segment
; -----------------------------------------------------------------------------

ifdef HV_LoadHigh	; If this is defined, we're in command.com

ifdef HV_Stub		; If this is defined, we're in command.com's stub.asm
	dataseg	macro	sg
		assume	sg:DATARES
		endm
	normseg	macro	sg
		assume	sg:nothing
		endm
else  ; HV_Stub
	dataseg	macro	sg
		mov	sg, ds:ResSeg	; Assume ds:ResSeg points to DATARES
		assume	sg:DATARES
		endm
	normseg	macro	sg
		assume	sg:TRANGROUP
		endm
endif ; HV_Stub

else  ; HV_LoadHigh
	dataseg	macro	sg
		push	cs		; sysinitseg is same as code segment
		pop	sg
		assume	sg:sysinitseg;
		endm
	normseg	macro	sg
		assume	sg:nothing;
		endm
endif  ; HV_LoadHigh

; -----------------------------------------------------------------------------
;*** getdata - retrieves a piece of data from the appropriate data segment.
; -----------------------------------------------------------------------------
; ENTRY:      reg - Register in which to place variable's value
;             off - Variable-name to query              ("getdata al, fInHigh")
; EXIT:       Given register contains value of specified variable.
; ERROR EXIT: None
; USES:       Given register
; ASSUMES:    For LoadHigh, ds:ResSeg points to DATARES
; -----------------------------------------------------------------------------

getdata	macro	reg, off
	push	ds
	dataseg	ds
	mov	reg, off
	pop	ds
	normseg	ds
	endm

; -----------------------------------------------------------------------------
;*** putdata - changes a piece of data in the appropriate data segment.
; -----------------------------------------------------------------------------
; ENTRY:      Variable-name, new value, and segment ("putdata fInHigh, 1, es").
;             I cannot think of a reason why the segment would not be "es",
;             but I've left it open anyway.
; ENTRY:      off - Name of variable to change          ("putdata fInHigh, 1")
;             arg - New value for variable (constant, register, memory, etc)
; EXIT:       Given variable contains value passed by arg (immediate or reg).
; ERROR EXIT: None
; USES:       Given variable
; ASSUMES:    For LoadHigh, ds:ResSeg points to DATARES
; -----------------------------------------------------------------------------

putdata	macro	off, arg
	push	es
	dataseg	es
	mov	off, arg
	pop	es
	normseg	es
	endm

; -----------------------------------------------------------------------------
;*** pushreg - repetitively pushes a variable # of arguments onto the stack
; -----------------------------------------------------------------------------
; ENTRY:      Parameters consist of any number of arguments, pushed left-to-
;             right.
; EXIT:       None; parameters are pushed.
; ERROR EXIT: None
; USES:       Stack
; -----------------------------------------------------------------------------
; CAUTION:    You must reverse "popreg" arguments; they both work left-to-right
;       For example:
;		pushreg	<ax, bx, cx, di, es>
;		...
;		popreg	<es, di, cx, bx, ax>
; -----------------------------------------------------------------------------

pushreg	macro	reglist
	irp	reg, <reglist>
		push	reg
		endm
	endm

; -----------------------------------------------------------------------------
;*** popreg - repetitively pops a variable # of arguments from the stack
; -----------------------------------------------------------------------------
; ENTRY:      Parameters consist of any number of arguments, popped left-to-
;             right.
; EXIT:       None; parameters are popped.
; ERROR EXIT: None
; USES:       Stack
; -----------------------------------------------------------------------------
; CAUTION:    You must reverse "popreg" arguments; they both work left-to-right
;       For example:
;		pushreg	<ax, bx, cx, di, es>
;		...
;		popreg	<es, di, cx, bx, ax>
; -----------------------------------------------------------------------------

popreg	macro	reglist
	irp	reg, <reglist>
		pop	reg
		endm
	endm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\lmstub.asm ===
;===========================================================================
;
; 	TITLE Low Memory Stub for DOS when DOS runs in HMA
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	Revision History:
;
;	M003 - MS PASCAL 3.2 support. Please see under tag M003 in dossym.inc
;	       7/30/90
;
;	M006 - print A20 Hardware error using int 10.
;
;	M020 - Fix for Rational Bug - see exepatch.asm for details
;
;	M011 - check for wrap rather than do an XMS query 
;	       A20 after int 23,24 and 28
;
;	M012 - Rearranged stuff to make Share build with msdata
;
;	M023 - Added variable UmbSave1 for preserving umb_head arena across 
;	       win /3 session for win ver < 3.1
;
;       M032 - Correct length of Exec data block in Win 2.x instance table.
;
;	M034 - add a new variable i20to28count to be used by MSDOS.SYS
;		(msinit.asm). IF POWER is built into BIOS, then this var
;		should be 8 (which means, DOS will not patch INT 28 to an
;		IRET); otherwise, this should be 9.
;
;	M00x - Added a variable for storing the ROM Exclude list ptr
;
;============================================================================


DOSDATA    SEGMENT WORD PUBLIC 'DATA'
	   assume cs:DOSDATA


;----------------------------------------------------------------------------
;
;	P U B L I C S
;
;----------------------------------------------------------------------------

	PUBLIC	DOSINTTABLE

	public	ldivov
	public	lquit
	public	lcommand
	public	labsdrd
	public	labsdwrt
	public	lStay_resident
	public	lint2f
	public	lcall_entry
	public	lirett


	public	i0patch
	public	i20patch
	public	i21patch
	public	i25patch
	public	i26patch
	public	i27patch
	public	i2fpatch
	public	cpmpatch



;----------------------------------------------------------------------------
;
; 	D A T A
;
;----------------------------------------------------------------------------

	EVEN
DOSINTTABLE	LABEL	DWORD
	
	DW	OFFSET DOSCODE:DIVOV 		, 0
	DW	OFFSET DOSCODE:QUIT 		, 0
	DW	OFFSET DOSCODE:COMMAND		, 0
	DW	OFFSET DOSCODE:ABSDRD		, 0
	DW	OFFSET DOSCODE:ABSDWRT		, 0
	DW	OFFSET DOSCODE:Stay_resident	, 0
	DW	OFFSET DOSCODE:INT2F		, 0
	DW	OFFSET DOSCODE:CALL_ENTRY	, 0
	DW	OFFSET DOSCODE:IRETT		, 0

	SS_Save	DW	?		; save user's stack segment
	SP_Save	DW	?		; save user's stack offset



;-------------------------------------------------------------------------
;
; LOW MEM STUB:
;
; The low mem stub contains the entry points into DOS for all interrupts 
; handled by DOS. This stub is installed if the user specifies that the 
; DOS load in HIMEM. Each entry point does this.
;
;
; 	1. if jmp to 8 has been patched out
;	   2. if A20 OFF
;	      3. Enable A20
;	   4. else 
;	      5. just go to dos entry
;	   6. endif
;	7. else
;	   8. just go to dos entry
;	9. endif
;
;
;--------------------------------------------------------------------------
	assume	cs:dosdata

;--------------------------------------------------------------------------
;
; DIVIDE BY 0 handler
;
;--------------------------------------------------------------------------

ldivov:
	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i0patch:
	jmp	short divov_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

divov_cont:
	jmp	dword ptr DOSINTTABLE	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 20 Handler
;
; Here we do not have to set up the stack to return here as the abort call
; will return to the address after the int 21 ah=4b call. This would be the
; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
; will be restored then.
;
;-------------------------------------------------------------------------

lquit:
	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i20patch:
	jmp	short quit_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
quit_cont:
	jmp	dword ptr DOSINTTABLE+4	; jump to DOS

;--------------------------------------------------------------------------
;
; INT 21 Handler
;
;--------------------------------------------------------------------------

lcommand:

	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i21patch:
	jmp	short command_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

command_cont:
	jmp	dword ptr DOSINTTABLE+8	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 25 
;
;----------------------------------------------------------------------------

labsdrd:
	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i25patch:
	jmp	short absdrd_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

absdrd_cont:
	jmp	dword ptr DOSINTTABLE+12; jmp to DOS

;-------------------------------------------------------------------------
;
; INT 26
;
;-----------------------------------------------------------------------

labsdwrt:

	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i26patch:
	jmp	short absdwrt_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

absdwrt_cont:
	jmp	dword ptr DOSINTTABLE+16; jmp to DOS

;------------------------------------------------------------------------
;
; INT 27
;
;-----------------------------------------------------------------------

lStay_resident:

	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i27patch:
	jmp	short sr_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

sr_cont:
	jmp	dword ptr DOSINTTABLE+20; jmp to DOS

;-----------------------------------------------------------------------------
;
; INT 2f
;
;-------------------------------------------------------------------------

lint2f:

	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i2fpatch:
	jmp	short int2f_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

int2f_cont:
	jmp	dword ptr DOSINTTABLE+24; jmp to DOS

;-----------------------------------------------------------------------------
;
; CPM entry
;
;------------------------------------------------------------------------

lcall_entry:

	;
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
cpmpatch:
	jmp	short callentry_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

callentry_cont:
	jmp	dword ptr DOSINTTABLE+28; jmp to DOS


;--------------------------------------------------------------------------

lirett:	iret

;---------------------------------------------------------------------------
;
; LowIntXX:
;
; Interrupts from DOS that pass control to a user program must be done from
; low memory, as the user program may change the state of the A20 line or
; they may require that the A20 line be OFF. The following piece of code is
; far call'd from the following places in DOS:
;
;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
;	2. msctrlc.asm where dos issues an int 24h (critical error)
;	3. msctrlc.asm where dos issues an int 28h (idle int)
;
; The int 23 and int 24 handlers may decide to do a far return instead of an
; IRET ane leave the flags on the stack. Therefore we save the return address
; before doing the ints and then do a far junp back into DOS.
;
;---------------------------------------------------------------------------


public	DosRetAddr23, DosRetAddr24
public	LowInt23, LowInt24, LowInt28

DosRetAddr23	DD	?
DosRetAddr24	DD	?
DosRetAddr28	DD	?

	; 
	; Execute int 23h from low memory
	;

LowInt23:
					; save the return address that is on
					; the stack
	pop	word ptr cs:[DosRetAddr23]
	pop	word ptr cs:[DosRetAddr23+2]

	int	23h			; ctrl C
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF 

	jmp	dword ptr DosRetAddr23	; jump back to DOS



	; 
	; Execute int 24h from low memory
	;

LowInt24:
					; save the return address that is on
					; the stack
	pop	word ptr cs:[DosRetAddr24]
	pop	word ptr cs:[DosRetAddr24+2]

	int	24h			; crit error
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	jmp	dword ptr DosRetAddr24	; jump back to DOS


	; 
	; Execute int 23h from low memory
	;

LowInt28:

	int	28h			; idle int
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	retf

;-------------------------------------------------------------------------
;
; int 21 ah=4b (exec) call will jump to the following label before xferring
; control to the exec'd program. We turn of A20 inorder to allow programs
; that have been packed by the faulty exepack utility to unpack correctly.
; This is so because exepac'd programs rely on address wrap.
;
;------------------------------------------------------------------------- 

public	disa20_xfer
disa20_xfer:
	call	XMMDisableA20		; disable A20

	;
	; Look at msproc.asm at label exec_go for understanding the following:
	;

	; DS:SI points to entry point
	; AX:DI points to initial stack
	; DX has PDB pointer
	; BX has initial AX value


	cli
	mov	BYTE PTR InDos,0	; SS Override

	ASSUME	SS:NOTHING

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
	sti
	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX
	retf



;-------------------------------------------------------------------------
;
; M003:
;
; If an int 21 ah=25 call is made immediately after an exec call, DOS will
; come here, turn A20 OFF restore user stack and registers before returning 
; to user. This is done in dos\msdisp.asm. This has been done to support 
; programs complied with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for 
; more info.	
;
; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that 
; SS is also DOS stack. It is important that we do the XMS call on DOS's 
; stack to avoid additional stack overhead for the user.
;
; -------------------------------------------------------------------------
public	disa20_iret
disa20_iret:

	assume	ds:DOSDATA

	call	XMMDisableA20
	dec	InDos
	mov	SS,User_SS		; restore user stack
	mov	SP,User_SP
	mov	BP,SP
	mov	BYTE PTR [BP.User_AX],AL
	mov	AX,Nsp
	mov	User_SP,AX
	mov	AX,Nss
	mov	User_SS,AX

	pop	AX			; restore user regs
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
	pop	ES
	iret

	assume	ds:NOTHING

;*****************************************************************************
;***	XMMDisableA20 - switch 20th address line			      
;									      
;	This routine is used to disable the 20th address line in 	      
;	the system using XMM calls.					      
;									      
;	ENTRY	none		;ds = _DATA				      
;	EXIT	A20 line disabled					      
;	USES	NOTHING					      
;									      
;*****************************************************************************


XMMDisableA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_LOCAL_DISABLE_A20
	call	cs:[XMMcontrol]
	pop	ax
	pop	bx
	ret

XMMDisableA20	endp


; The entry point in the BIOS XMS driver is defined here.
public	XMMcontrol
	XMMcontrol	DD	?


;---------------------------------------------------------------------------
;
;***	EnsureA20ON - Ensures that A20 is ON
;									      
;	This routine is used to query the A20 state in		 	      
;	the system using XMM calls.					      
;									      
;	ENTRY: none		
;
;	EXIT : A20 will be ON
;		
;									      
; 	USES : NONE								      
;									      
;---------------------------------------------------------------------------


LowMemory   label   dword		; Set equal to 0000:0080
	dw	00080h
	dw	00000h

HighMemory  label   dword
	dw	00090h			; Set equal to FFFF:0090
	dw	0FFFFh

EnsureA20ON	proc	near

	pushf
	push    ds
	push	es
	push	cx
	push	si
	push	di

	lds	si,cs:LowMemory     	; Compare the 4 words at 0000:0080
	les	di,cs:HighMemory    	; with the 4 at FFFF:0090
	mov	cx,4
	cld
	repe    cmpsw

	jz	EA20_OFF

EA20_RET:

	pop	di
	pop	si
	pop	cx
	pop	es
	pop	ds
	popf
	ret

EA20_OFF:

	;
	; We are going to do the XMS call on the DOS's AuxStack. NOTE: ints
	; are disabled at this point.
	;

	push	bx
	push	ax

	mov	ax, ss			; save user's stack pointer
	mov	cs:[SS_Save],ax
	mov	cs:[SP_Save],sp
	mov	ax, cs
	mov	ss, ax
	mov	sp, OFFSET DOSDATA:AuxStack
					; ss:sp -> DOSDATA:AuxStack
	
	mov	ah, XMM_LOCAL_ENABLE_A20
	call	cs:[XMMcontrol]
	or	ax, ax
	jz	XMMerror		; AX = 0 fatal error


	mov	ax, cs:[SS_Save]	; restore user stack
	mov	ss, ax
	mov	sp, cs:[SP_Save]

	pop	ax
	pop	bx

	jmp	short EA20_RET


EnsureA20ON	endp


XMMerror:				; M006 - Start

	mov	ah, 0fh			; get video mode
	int	10h
	cmp	al, 7			; Q: are we an MDA
	je	XMMcont			; Y: do not change mode
	xor	ah, ah			; set video mode
	mov	al, 02h			; 80 X 25 text
	int	10h
XMMcont:
	mov	ah, 05h			; set display page
	xor	al, al			; page 0
	int	10h
	
	mov	si, offset XMMERRMSG
	push	cs
	pop	ds
	cld				; clear direction flag

XMMprnt:
	lodsb
	cmp	al, '$'			; indicates end of XMMERRMSG
	jz	XMMStall		; function 0eh	
	mov	ah, 14
	mov	bx, 7
	int	10h
	jmp	short XMMprnt
	
XMMStall:
	sti				; allow the user to warm boot
	jmp	XMMStall		; M006 - End



;
;This has been put in for WIN386 2.XX support. The format of the instance 
;table was different for this. Segments will be patched in at init time.
;
public  OldInstanceJunk
OldInstanceJunk	dw	70h	;segment of BIOS
		dw	0	;indicate stacks in SYSINIT area
		dw	6	;5 instance items

		dw	0,offset dosdata:contpos, 2
		dw	0,offset dosdata:bcon, 4
		dw	0,offset dosdata:carpos,106h
		dw	0,offset dosdata:charco, 1
		dw	0,offset dosdata:exec_init_sp, 34               ;M032
		dw	070h,offset BData:altah, 1	 ; altah byte in bios




; M021-
;
; DosHasHMA - This flag is set by seg_reinit when the DOS actually
; 	takes control of the HMA.  When running, this word is a reliable
;	indicator that the DOS is actually using HMA.  You can't just use
;	CS, because ROMDOS uses HMA with CS < F000.

public	DosHasHMA
	DosHasHMA		db	0

public	fixexepatch, RationalPatchPtr
	fixexepatch		dw	?		; M012
	RationalPatchPtr 	dw	?		; M012

; End M021


;
; M020 Begin
;
		public	RatBugCode
RatBugCode	proc	far
		push	cx
		mov	cx, word ptr ds:[10h]
		loop	$
		pop	cx
		ret
RatBugCode	endp
;
; M020 End
;

	
public	UmbSave1			; M023
UmbSave1	db	0bh dup (?)	; M023

public	Mark3
	Mark3	label byte

IF2
	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF

;############################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
;
; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
; data variable that is to be added to DOSDATA must go in between Mark3
; COUNTRY_CDPG if it can. 
;
; MARK3 SHOULD NOT BE > 122AH 
;
; As of 9/6/90, this area is FULL!
;
;############################################################################
 
	ORG	0122ah

; The following table is used for DOS 3.3
;DOS country and code page information is defined here for DOS 3.3.
;The initial value for ccDosCountry is 1 (USA).
;The initial value for ccDosCodepage is 850.
;
;
		   PUBLIC  UCASE_TAB,FILE_UCASE_TAB,DBCS_TAB
		   PUBLIC  FILE_CHAR_TAB,COLLATE_TAB

PUBLIC	COUNTRY_CDPG

;
; country and code page infomation
;
COUNTRY_CDPG  label  byte

	 db   0,0,0,0,0,0,0,0	      ; reserved words
	 db   '\COUNTRY.SYS',0        ; path name of country.sys
	 db   51 dup (?)
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
	 dw   932		      ; system code page id (JAPAN)
  endif
  ifdef	  TAIWAN
	 dw   938		      ; system code page id (TAIWAN)
  endif
  ifdef   KOREA
         dw   934                     ; system code page id (KOREA IBM)
  endif
else
	 dw   437		      ; system code page id
endif
; ------------------------------------------------<MSKK01>----------------------
	 dw   6 		      ; number of entries
	 db   SetUcase		      ; Ucase type
	 dw   OFFSET DOSDATA:UCASE_TAB    ;pointer to upper case table
	 dw   0 			   ; segment of poiter
	 db   SetUcaseFile	      ; Ucase file char type
	 dw   OFFSET DOSDATA:FILE_UCASE_TAB	;pointer to file upper case table
	 dw   0 			   ; segment of poiter
	 db   SetFileList	      ; valid file chars type
	 dw   OFFSET DOSDATA:FILE_CHAR_TAB   ;pointer to valid file char tab
	 dw   0 			   ; segment of poiter
	 db   SetCollate	      ; collate type
	 dw   OFFSET DOSDATA:COLLATE_TAB  ;pointer to collate table
	 dw   0 			   ; segment of poiter
	 db   SetDBCS		      ;AN000; DBCS Ev			  2/12/KK
	 dw   OFFSET DOSDATA:DBCS_TAB ;AN000;;pointer to DBCS Ev table   2/12/KK
	 dw   0 		       ;AN000; segment of poiter	 2/12/KK
	 db   SetCountryInfo	      ; country info type
	 dw   NEW_COUNTRY_SIZE	      ; extended country info size
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
	 dw   81 		      ; <MSKK01> JAPAN country id
	 dw   932		      ; <MSKK01> JAPAN system code page id
	 dw   2 		      ; <MSKK01> date format (YMD)
	 db   '\',0,0,0,0             ; <MSKK01> currency symbol (YEN)
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   0 		      ; <MSKK01> # of disgit in currency
	 db   1 		      ; <MSKK01> time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
  ifdef	  TAIWAN
	 dw   88		      ; TAIWAN country id
	 dw   938		      ; TAIWAN system code page id
	 dw   0 		      ; date format (MDY)
	 db   'N','T','$',0,0	      ; currency symbol
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   2 		      ; # of disgit in currency
	 db   1 		      ; time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
  ifdef   KOREA
         dw   82                      ; <MSCH> KOREA country id
         dw   934                     ; <MSCH> KOREA system code page id
         dw   2                       ; <MSCH> date format (YMD)
         db   '\',0,0,0,0             ; <MSCH> currency symbol (WON)
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
         db   0                       ; <MSCH> # of disgit in currency
         db   1                       ; <MSCH> time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
else
	 dw   1 		      ; USA country id
	 dw   437		      ; USA system code page id
	 dw   0 		      ; date format
	 db   '$',0,0,0,0             ; currency symbol
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0		      ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   2 		      ; # of disgit in currency
	 db   0 		      ; time format
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
endif
; ------------------------------------------------<MSKK01>----------------------

; M034 BEGIN
IFDEF	ROMDOS

        public	i20To28Count		; M034


IFDEF	POWER			; if POWER Driver is part of BIOS
i20To28Count	dw	8	; then dont' patch I28 to an IRET
ELSE
i20To28Count	dw	9	; else patch I28 to an IRET
ENDIF

ENDIF
; M034 END

; M035 BEGIN

IFDEF	ROMEXEC
	public	RomExclRegPtr
RomExclRegPtr	dd	0
ENDIF ; ROMEXEC

; M035 END

include	msdos.cl2			; XMMERRMSG

DOSDATA	ends


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -	       Add Patriot/Sebring determination code for HOT Replug
;;			so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030		Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;			  versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H	;; typewriter style caps lock
					;;
JR_HOT_KEY_1_2	equ	4000h		;; M030 Merged back for kdfcf.asm
JR_KB		equ	8000h		;; M030 Merged back for kdfcf.asm
					;; Some useful scan codes:
F1_SCAN     EQU   59			;; F1
F2_SCAN     EQU   60			;; F2
					;;
					;;	SYSTEM_FLAG / Hardware equates:
					;;   INT 16h and remote support
EXT_16		EQU	8000H		;; extended INT 16h support is there
EXT_122 	EQU	4000H		;; extended INT 16h for 122 is there
;		EQU	2000H		;;  unused
PC_NET		EQU	1000H		;; flag PC Net is installed
					;;   System type/hardware support flags
PC_81		EQU	0800H		;; flag for Original PC
PC_XT		EQU	0400H		;; code for PC, PC/XT, PORTABLE
PC_LAP		EQU	0200H		;; code for Convertiable (p-12)
PC_PAL		EQU	0080H		;; code for Model 30 (PALACE)
PC_AT		EQU	0040H		;; code for PC-AT  with 8042
PC_386		EQU	0020H		;; code for PS/2's with 8042 (WRANGLER)
PS_8042 	EQU	0010H		;; 8042 is a Patriot/Sebring type array;AN007;jwg
					;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE	EQU	0008h	; M030	;; Server password mode is active
;				; M030	;;  This bit becomes off from on when
;				; M030	;;  correct password is entered JP9010
					;;
					;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0			;;  hot key is active => US
LANG_MODE   EQU   0FFH			;;  hot key is inactive
					;;
					;; -----------------------------------
SHARED_DATA_STR     STRUC		;; SHARED DATA AREA
					;;
OLD_INT_9	    DD	  0		;; saved int 9 vector
OLD_INT_2F	    DD	  0		;; saved int 2F vector
		    dd    0		;; reserved
KEYB_TYPE	    DW	  0		;; type of keyboard
SYSTEM_FLAG	    DW	  0		;; system configuration flags
TABLE_OK	    DB	  0		;; flag to INT 9 that table is built
		    db    5 dup (0)	;; reserved
					;;
					;; Table copy begins here:
ACTIVE_LANGUAGE     DB	  'US'          ;; language code
INVOKED_CP_TABLE    DW	  437		;; ptr to table for invoked code page
INVOKED_KBD_ID	    DW	  0		;; WGR invoked keyboard id.	       ;AN000
ACTIVE_XLAT_PTR     DW	  -1		;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR	    DW	  -1		;; ptr to first Specific Translate Sect
RESIDENT_END	    DW	  0ffffh	;; offset of last byte in resident mem
LOGIC_PTR	    DW	  -1		;; ptr to State Logic
COMMON_XLAT_PTR     DW	  -1		;; ptr to Common Translate Section
SPECIAL_FEATURES    DW	  ?		;; special Features
TABLE_OVERFLOW	    DB	  0		;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB	  ?		;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB	  ?		;;  to turn hot key on and off
		    DB	  4 DUP(0)	;; reserved
TABLE_AREA	    DB	  ?		;; tables loaded here:
					;;  State Logic
					;;  Common Translate Section
					;;  Specific Translate Sections for
					;;   each code page
SHARED_DATA_STR     ENDS		;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_LOGIC_STR STRUC			;;
					;;
SL_LOGIC_LEN	DW   ?			;; length of state logic
SL_SPECIAL_FEATURES   DW   ?		;;
SL_LOGIC_CMDS	DB   0			;; state logic commands begin here
					;;
STATE_LOGIC_STR ENDS			;;
					;;
					;;
NUM_BIOS_FLAGS	    EQU   4		;;
NUM_NLS_FLAGS	    EQU   2		;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS	    EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
					;;
					;;
EITHER_SHIFT	    EQU   80H		;; EXT_KB_FLAG : our own shift state
EITHER_CTL	    EQU   40H		;;  flags
EITHER_ALT	    EQU   20H		;;
SCAN_MATCH	    EQU   08H		;; set if scan code found in XLATT
					;; or SET_FLAG searches
					;;
					;;
KB_FLAG_ID	    EQU   0		;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID	    EQU   1		;;  commands
KB_FLAG_2_ID	    EQU   2		;;
KB_FLAG_3_ID	    EQU   3		;;
EXT_KB_FLAG_ID	    EQU   4		;;
NLS_FLAG_1_ID	    EQU   5		;;
NLS_FLAG_2_ID	    EQU   6		;;
					;;
COMMAND_BITS	    EQU   0F0H		;; Mask to isolate command code
SUB_CMD_BITS	    EQU   0FH		;; mask to isolate sub command code
NOT_TEST	    EQU   08H		;; NOT bit in IFF, ANDF
COMMAND_SHIFT	    EQU   4		;; shift amount for command code
FLAG_ID_BITS	    EQU   07H		;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS	    EQU   0CH		;; number of commands
					;;
IFF_COMMAND	    EQU   00H		;;
ANDF_COMMAND	    EQU   10H		;;
ELSEF_COMMAND	    EQU   20H		;;
ENDIFF_COMMAND	    EQU   30H		;;
XLATT_COMMAND	    EQU   40H		;;
OPTION_COMMAND	    EQU   50H		;;
SET_FLAG_COMMAND    EQU   60H		;;
PUT_ERROR_COMMAND   EQU   70H		;;
IFKBD_COMMAND	    EQU   80H		;;
GOTO_COMMAND	    EQU   90H		;;
BEEP_COMMAND	    EQU   0A0H		;;
RESET_NLS_COMMAND   EQU   0B0H		;;
CHECK_CORE_COMMAND  EQU   0C0H		;;
					;;
					;;
EXIT_INT_9_FLAG 	EQU  01H	;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG	EQU  02H	;;  values are in the right nibble
					;;   of the GOTO command.
					;;
					;; PROCESSING OPTIONS:
EXIT_IF_FOUND	    EQU   80H		;; exit INT 9 if a translation
					;;  match is found
					;;
ANY_KB		     EQU   0FFFFH	;;
XT_KB		     EQU   4000H	;;
AT_KB		     EQU   2000H	;;
G_KB		     EQU   1000H	;;
P_KB		     EQU   0800H	;;
P12_KB		     EQU   0400H	;;
DBCS_OLD_A_KB	     EQU   0080H ; M030	;; JP9009
DBCS_OLD_P_KB	     EQU   0040H ; M030	;; JP9009
DBCS_OLD_G_KB	     EQU   0020H ; M030	;; JP9009
DBCS_OLD_KB	     EQU   00C0H ; M030	;; JP9009
DBCS_KB		     EQU   0020H ; M030	;; JP9009
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;	 XLAT_SECT_STR		  ; header info for the section
;;	    STATE_STR		  ; header for state #1
;;	      XLAT_STR		  ;   first translate tab for state #1
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      XLAT_STR		  ;   second translate tab
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	    STATE_STR		  ; header for state #2
;;	      XLAT_STR
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	   ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
XLAT_SECT_STR	    STRUC		;;
					;;
XS_NEXT_SECT_PTR       DW    ?		;; Pointer to next Specific Translate
					;;  Section
XS_CP_ID	       DW    ?		;; code page id
XS_FIRST_STATE	       DB    ?		;;
					;;
XLAT_SECT_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_STR	    STRUC		;;
					;;
XS_STATE_LEN	 DW    ?		;; length of state section
XS_STATE_ID	 DB    ?		;; State ID
XS_KBD_TYPE	 DW    ?		;; Keyboard Type
XS_ERROR_CHAR	 DW    ?		;; Buffer entry for error character
XS_FIRST_TAB	 DB    ?		;;
					;;
STATE_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;	       Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;	       Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Translate options:
ASCII_ONLY	    EQU   80H		;; Only ASCII codes listed - use
					;;  incoming scan for buffer entry
TYPE_2_TAB	    EQU   40H		;; search xlat table for matching scan
ZERO_SCAN	    EQU   20H		;; set the scan half of the buffer
					;;  entry to 0
					;;
NULL_ASCII_CODE     EQU   -1		;;
					;;
DEFAULT_TAB_2_ENT_SZ   EQU   3		;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2		;;
					;;
					;;
XLAT_STR	    STRUC		;;
					;;
XLAT_TAB_SIZE	    DW	  ?		;; Size in bytes of this table -
					;;  includes this field, options etc.
XLAT_OPTIONS	    DB	  ?		;; xlat options
					;; XLAT TABLE IS HERE
XLAT_STR	    ENDS		;;
					;;
XLAT_TYPE_1_STR     STRUC		;; use scan code as index into table
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO	    DB	  ?		;; Scan code
XLAT_SCAN_HI	    DB	  ?		;;  range
XLAT_1_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_1_STR     ENDS		;;
					;;
XLAT_TYPE_2_STR     STRUC		;; search table for scan
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM	    DB	  ?		;; number of scans
XLAT_SCAN	    DB	  ?		;; Scan code
XLAT_2_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_2_STR     ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
SF_ENT_SZ     EQU   3			;; size of entry
					;;
SET_FLAG_STR	    STRUC		;;
					;;
SF_NUM		    DB	  0		;; Number of entries
SF_SCAN_CODE	    DB	  0		;; scan code
SF_FLAG_ID	    DB	  0		;; flag id
SF_FLAG_MASK	    DB	  0		;; flag mask
					;;
SET_FLAG_STR	    ENDS		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\intnat.inc ===
;	SCCSID = @(#)intnat.asm	1.1 85/04/10
BREAK <International data structure format>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; Current structure of the data returned by the international call
;
internat_block STRUC
Date_tim_format DW	?		; 0-USA, 1-EUR, 2-JAP
Currency_sym	DB	?		; Currency Symbol 5 bytes
		DB	?
		DB	?
		DB	?
		DB	?
Thous_sep	DB	?		; Thousands separator 2 bytes
		DB	?
Decimal_sep	DB	?		; Decimal separator 2 bytes
		DB	?
Date_sep	DB	?		; Date separator 2 bytes
		DB	?
Time_sep	DB	?		; Decimal separator 2 bytes
		DB	?
Bit_field	DB	?		; Bit values
					;   Bit 0 = 0 if currency symbol first
					;	  = 1 if currency symbol last
					;   Bit 1 = 0 if No space after currency symbol
					;	  = 1 if space after currency symbol
Currency_cents	DB	?		; Number of places after currency dec point
Time_24 	DB	?		; 1 if 24 hour time, 0 if 12 hour time
Map_call	DW	?		; Address of case mapping call (DWORD)
		DW	?		; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
					;  in pieces.
Data_sep	DB	?		; Data list separator character
		DB	?
internat_block ENDS

;
; Max size of the block returned by the INTERNATIONAL call
;
internat_block_max	EQU	32

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\ioctl.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;  %OUT IOCTL.INC...
; THESE ARE ALL THE IMPORTANT STRUCTURES AND EQUATES FOR IOCTL
;==============================================================================
;REVISION HISTORY:
;AN000 - New for DOS Version 4.00 - J.K.
;AC000 - Changed for DOS Version 4.00 - J.K.
;AN00x - PTM number for DOS Version 4.00 - J.K.
;==============================================================================
;AN001; D241 Provide support of Multi-track Format/Verify	   9/23/87 J.K.
;AN002; P1535 Unformatted hard file problem			  10/15/87 J.K.
;AN003; D490 IOCTL subfunction 63h,43h,64h,44h conflicts with OS2  2/26/88 J.K.
;==============================================================================

;*** J.K.
;General Guide -
;Category Code:
; 0... .... DOS Defined
; 1... .... User defined
; .xxx xxxx Code

;Function Code:
; 0... .... Return error if unsupported
; 1... .... Ignore if unsupported
; .0.. .... Intercepted by DOS
; .1.. .... Passed to driver
; ..0. .... Sends data/commands to device
; ..1. .... Quries data/info from device
; ...x .... Subfunction
;
; Note that "Sends/queries" data bit is intended only to regularize the
; function set.  It plays no critical role; some functions may contain both
; command and query elements. The convention is that such commands are
; defined as "sends data".

;*****************************;*
; BLOCK DRIVERS 	      ;*
;*****************************;*

; IOCTL SUB-FUNCTIONS
IOCTL_GET_DEVICE_INFO	EQU	0
IOCTL_SET_DEVICE_INFO	EQU	1
IOCTL_READ_HANDLE	EQU	2
IOCTL_WRITE_HANDLE	EQU	3
IOCTL_READ_DRIVE	EQU	4
IOCTL_WRITE_DRIVE	EQU	5
IOCTL_GET_INPUT_STATUS	EQU	6
IOCTL_GET_OUTPUT_STATUS EQU	7
IOCTL_CHANGEABLE?	EQU	8
IOCTL_DeviceLocOrRem?	EQU	9
IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
IOCTL_SHARING_RETRY	EQU	0Bh   ;11
GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
GENERIC_IOCTL		EQU	0Dh   ;13
IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
IOCTL_QUERY_HANDLE	EQU	10h   ;16
IOCTL_QUERY_BLOCK	EQU	11h   ;17


; GENERIC IOCTL CATEGORY CODES
IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
IOC_TC			EQU	2	; TERMINAL CONTROL
IOC_SC			EQU	3	; SCREEN CONTROL
IOC_KC			EQU	4	; KEYBOARD CONTROL
IOC_PC			EQU	5	; PRINTER CONTROL
IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO			EQU	8

; RAWIO SUB-FUNCTIONS
GET_DEVICE_PARAMETERS	EQU	60H
SET_DEVICE_PARAMETERS	EQU	40H
READ_TRACK		EQU	61H
WRITE_TRACK		EQU	41H
VERIFY_TRACK		EQU	62H
FORMAT_TRACK		EQU	42H
GET_MEDIA_ID		EQU	66h		;AN000;AN003;changed from 63h
SET_MEDIA_ID		EQU	46h		;AN000;AN003;changed from 43h
GET_ACCESS_FLAG 	EQU	67h		;AN002;AN003;Unpublished function.Changed from 64h
SET_ACCESS_FLAG 	EQU	47h		;AN002;AN003;Unpublished function.Changed from 44h
SENSE_MEDIA_TYPE	EQU	68H		;Added for 5.00


; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
BUILD_DEVICE_BPB	EQU	000000001B

; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
INSTALL_FAKE_BPB	EQU	000000001B
ONLY_SET_TRACKLAYOUT	EQU	000000010B
TRACKLAYOUT_IS_GOOD	EQU	000000100B

; SPECIAL FUNCTION FOR FORMAT TRACK
STATUS_FOR_FORMAT		EQU	000000001B
DO_FAST_FORMAT			equ	000000010B	;AN001;
; CODES RETURNED FROM FORMAT STATUS CALL
FORMAT_NO_ROM_SUPPORT		EQU	000000001B
FORMAT_COMB_NOT_SUPPORTED	EQU	000000010B

; DEVICETYPE VALUES
MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
DEV_5INCH		EQU	0
DEV_5INCH96TPI		EQU	1
DEV_3INCH720KB		EQU	2
DEV_8INCHSS		EQU	3
DEV_8INCHDS		EQU	4
DEV_HARDDISK		EQU	5
DEV_OTHER		EQU	7
DEV_3INCH1440KB		EQU	7
DEV_3INCH2880KB		EQU	9

MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
					; CURRENTLY SUPPORT.

A_SECTORTABLE	    STRUC
ST_SECTORNUMBER 	DW	?
ST_SECTORSIZE		DW	?
A_SECTORTABLE	    ENDS

A_DEVICEPARAMETERS  STRUC
DP_SPECIALFUNCTIONS	DB	?
DP_DEVICETYPE		DB	?
DP_DEVICEATTRIBUTES	DW	?
DP_CYLINDERS		DW	?
DP_MEDIATYPE		DB	?
DP_BPB			DB	SIZE A_BPB DUP (?)
DP_TRACKTABLEENTRIES	DW	?
DP_SECTORTABLE		DB MAX_SECTORS_IN_TRACK * SIZE A_SECTORTABLE DUP (?)
A_DEVICEPARAMETERS  ENDS

A_TRACKREADWRITEPACKET STRUC
TRWP_SPECIALFUNCTIONS	DB	?
TRWP_HEAD		DW	?
TRWP_CYLINDER		DW	?
TRWP_FIRSTSECTOR	DW	?
TRWP_SECTORSTOREADWRITE DW	?
TRWP_TRANSFERADDRESS	DD	?
A_TRACKREADWRITEPACKET ENDS

;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
A_FORMATPACKET	    STRUC
FP_SPECIALFUNCTIONS	DB	?
FP_HEAD 		DW	?
FP_CYLINDER		DW	?
FP_TRACKCOUNT		DW	1
A_FORMATPACKET	    ENDS

A_VERIFYPACKET	    STRUC
VP_SPECIALFUNCTIONS	DB	?
VP_HEAD 		DW	?
VP_CYLINDER		DW	?
A_VERIFYPACKET	    ENDS

A_MEDIA_ID_INFO     STRUC
MI_LEVEL		DW	0		;J.K. 87 Info. level
MI_SERIAL		DD	?		;J.K. 87 Serial #
MI_LABEL		DB     11 DUP (' ')     ;J.K. 87 volume label
MI_SYSTEM		DB	8 DUP (' ')     ;J.K. 87 File system type
A_MEDIA_ID_INFO     ENDS

A_DISKACCESS_CONTROL	STRUC			;AN002; Unpublished function. Only for Hard file.
DAC_SPECIALFUNCTIONS	DB	0		;AN002; Always 0
DAC_ACCESS_FLAG 	DB	0		;AN002; Non Zero - allow disk I/O to unformatted hard file
A_DISKACCESS_CONTROL	ENDS			;AN002; 0 - Disallow disk I/O to unformatted hard file


A_MEDIA_SENSE	STRUC			; Media sense structure added 5.00
MS_ISDEFAULT		DB	?	; If 1 type returned is drv default
MS_DEVICETYPE		DB	?	; Drive type 
MS_RESERVED1		DB	?	; RESERVED
MS_RESERVED2		DB	?	; RESERVED 
A_MEDIA_SENSE	ENDS

;********************************;*
; CHARACTER DEVICES (PRINTERS)	 ;*
;********************************;*

;RAWIO SUB-FUNCTIONS
GET_RETRY_COUNT 	EQU	65H
SET_RETRY_COUNT 	EQU	45H

A_RETRYCOUNT	    STRUC
RC_COUNT		DW	?
A_RETRYCOUNT	    ENDS

;********************************;*		;J.K. 4/29/86
; CHARACTER DEVICES (SCREEN)	 ;*
;********************************;*		;J.K. 4/29/86
;
;SC_MODE_INFO	 struc
;SC_INFO_LENGTH 	 DW	 9
;SC_MODE		 DB	 0
;SC_COLORS		 DW	 0
;SC_WIDTH		 DW	 0
;SC_LENGTH		 DW	 0
;SC_MODE_INFO	 ends
;
;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.

;SUBFUNCTIONS FOR CON$GENIOCTL
;GET_SC_MODE		 EQU	 60h
;SET_SC_MODE		 EQU	 40h
;The following subfunctions are reserved for installable CODE PAGE switch
;console devices. - J.K. 4/29/86
;Get_active_codepage	 equ	 6Ah
;Invoke_active_codepage  equ	 4Ah
;Start_designate_codepage equ	 4Ch
;End_designate_codepage  equ	 4Dh
;Get_list_of_designated_codepage equ 6Bh
;J.K. 4/29/86 *** End of Con$genioctl equates & structures


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\lock.inc ===
;**	LOCK.INC - Definitions for Record Locking
;

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	LOCK functions
;

LOCK_ALL	    equ    0
UNLOCK_ALL	    equ    1
LOCK_MUL_RANGE	    equ    2
UNLOCK_MUL_RANGE    equ    3
LOCK_READ	    equ    4
WRITE_UNLOCK	    equ    5
LOCK_ADD	    equ    6



;**	Structure for Lock buffer

LockBuf    STRUC

   Lock_position DD    ?	    ; file position for LOCK
   Lock_length	 DD    ?	    ; number of bytes to LOCK

LockBuf    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mi.inc ===
;	SCCSID = @(#)mi.asm	1.1 85/04/10
BREAK <Machine instruction, flag definitions and character types>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

mi_INT		EQU	0CDh
mi_Long_JMP	EQU	0EAh
mi_Long_CALL	EQU	09Ah
mi_Long_RET	EQU	0CBh
mi_Near_RET	EQU	0C3h

;			xxxxoditszxaxpxc
f_Overflow	EQU	0000100000000000B
f_Direction	EQU	0000010000000000B
f_Interrupt	EQU	0000001000000000B
f_Trace 	EQU	0000000100000000B
f_Sign		EQU	0000000010000000B
f_Zero		EQU	0000000001000000B
f_Aux		EQU	0000000000010000B
f_Parity	EQU	0000000000000100B
f_Carry 	EQU	0000000000000001B

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msdata2.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)ibmdata.asm	1.1 85/04/10
;
; DATA Segment for DOS
;

.xlist
.xcref
include dosseg.inc
include dossym.inc
include version.inc
include mssw.asm
INCLUDE SF.INC
INCLUDE CURDIR.INC
INCLUDE DPB.INC
INCLUDE ARENA.INC
INCLUDE VECTOR.INC
INCLUDE DEVSYM.INC
INCLUDE PDB.INC
INCLUDE FIND.INC
INCLUDE MI.INC
.cref
.list

TITLE   IBMDATA - DATA segment for DOS
NAME    IBMDATA

installed = TRUE

include msdata.asm
include msinit.asm
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mft.inc ===
BREAK   <MFT Definitions>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**     MSDOS MFT definitions
;
;   The Master File Table (MFT) associates the cannonicalized pathnames, lock
;   records and SFTs for all files open on this machine.
;
;   The MFT implementation employs a single memory buffer which is used from
;   both ends.  This gives the effect (at least until they run into each
;   other) of two independent buffers.
;
;       MFT buffer
;       ==========
;   The MFT buffer contains MFT name records and free space.  It uses a
;   classic heap architecture:  freed name records are marked free and
;   conglomerated with any adjacent free space.  When one is to create a name
;   entry the free list is searched first-fit.  The list of name and free
;   records is always terminated by a single END record.
;
;       LOCK buffer
;       ===========
;   The lock buffer contains fixed format records containing record locking
;   information.  Since they are fixed format the space is handled as a series
;   of chains:  one for each MFT name record and one for the free list.  No
;   garbage collection is necessary.
;
;       Space allocation
;       ================
;   The MFT is managed as a heap.  Empty blocks are allocated on a first-fit
;   basis.  If there is no single large enough empty block the list is garbage
;   collected.
;
;       MFT name records:
;
;              8     16     8     16     32     16        n
;           |------|-----|-----|------|------|------|---------~~~~~~---------|
;           | FLAG | LEN | SUM | LPTR | SPTR | SERL |     <.asciz string>    |
;           --------------------------------------------------~~~~~~----------
;
;                       FLAG = record type flag
;                       LEN =  total byte length of record.
;                       SUM =  sum of bytes in asciz string.  Used to speed
;                              searches
;                       LPTR=  pointer to first record in lock chain segment
;                              is MFT segment
;                       SPTR= pointer to first sft in sft chain
;                       SERL= serial number
;                       <string> = name string, zero-byte terminated.  There
;                              may be garbage bytes following the 00 byte;
;                              these are counted in the LEN field.
;
;
;       MFT free records
;
;              8      16
;           |------|-----|----~~~~~~~~~~~~~~~~~~~~~~~~~~~---------|
;           | FLAG | LEN |         free                           |
;           ------------------~~~~~~~~~~~~~~~~~~~~~~~~~~~----------
;
;                       FLAG = record type flag
;                       LEN  = total byte length of record.
;
;
;       MFT END records
;
;                  8
;               |------|
;               | FLAG |
;               --------
;
;                       FLAG = record type flag

;**     MFT definitions
;*
;*      NOTE:  the flag and length fields are identical for all record types
;*              (except the END type has no length) This must remain so as
;*              some code depends upon it.
;*
;*      NOTE:  Many routines check for "n-1" of the N flag values and if no
;*              match is found assume the flag value must be the remaining
;*              possibility.  If you add or remove flag values you must check
;*              all references to mft_flag.

MFT_entry       STRUC

mft_flag        DB      ?               ; flag/len field
mft_len         DW      ?
mft_sum         DB      ?               ; string sum word
mft_lptr        DW      ?               ; LCK pointer
mft_sptr        DD      ?               ; sft pointer
mft_serl        DW      ?               ; serial number
mft_name        DB      ?               ; offset to start of name

MFT_entry       ENDS

MFLG_NAM        EQU     1               ; min value for name record
MFLG_FRE        EQU     0               ; free record
MFLG_END        EQU     -1              ; end record

;*      Record Lock Record (RLR):
;
;                  16       32       32       32
;               |-------|--------|--------|--------|
;               | NEXT  |  FBA   |  LBA   |  SPTR  |
;               |       | lo hi  | lo hi  |        |
;               ------------|--------|--------------
;
;                       CHAIN  = pointer to next RLR.  0 if end
;                       FBA    = offset of 1st  byte of locked region
;                       LBA    = offset of last byte of locked region
;                       SPTR   = pointer to SFT lock was issued on

RLR_entry       STRUC

rlr_next        DW      ?               ; chain to next RLR, 0 if end
rlr_fba         DW      ?               ; first byte addr (offset) of reigion
                DW      ?
rlr_lba         DW      ?               ; last byte addr of region
                DW      ?
rlr_sptr        DD      ?               ; SFT pointer
rlr_pid         dw      ?               ; process id of issuer
rlr_type        dw      ?               ; lock type
RLR_entry       ENDS

rlr_lall        equ     00h            ; lock all ops
rlr_lwr         equ     01h            ; lock write ops

;
;   A pictorial diagram for the linkages is as follows:
;
;          +---sptr------+
;          V             |
;        +---+<----------|---sptr------+------------+
;        |SFT+----+      |             |            |
;        +-+-+    |    +-+-+        +--+-+       +--+-+
;          V      +--->|MFT+-lptr->-|LOCK+-next->|LOCK+->0
;        +---+    |    +---+        +----+       +----+
;        |SFT+----+      ^
;        +-+-+           |
;          |             |
;          +-------------+
;
;

;**
;
;   Interesting behavior should be noted:
;
;       The sharer must maintain information on files in three forms:
;
;       local/remote handles.  These are normal handles and behave in no
;           strange manner.  They are identified by SF_mode not having the
;           sfIsFCB flag nor by having the sf_mode = 70.  No problems with
;           locking.  No problems with open.  No problems with close.
;           CloseByName will iterate closes until the mft disappears.
;           CloseUser will iterate closes until no SFT for the particular user
;           appears.  CloseProcess will iterate closes until no SFT for the
;           particular user/process appears.
;
;       local FCBs.  There are no corresponding SFT's for these as the SFTs
;           are cached but will be valid for the particular file.  There is
;           one SFT for each open on a file by a specific process.  These are
;           identified the sfIsFCB flag in the sf_mode field.  When multiple
;           opens occur, we merely find the sf pertinent to the file and
;           process.  Close decrements the ref count.  CloseByName, CloseUser,
;           CloseProcess will iterate closes until no more SFTs exist.
;
;       handles with mode 70.  These represent FCB's open across the network.
;           As such, identical sfts may have been collapsed by the $open code.
;           This results in a reuse of the same SFT.  The $Open code must
;           correctly set the ref-count for the sft to reflect the number of
;           collapses that have occurred.  These are identified by a 70 in the
;           SF_mode field.  There can be no locking on these SFTs.  Open must
;           scan the list of SFTs for the file and increment its ref count
;           appropriately.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msbdata.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; MSBDATA.INC
;
; This file defines some locations in the BIOS data segment that are
; accessed by code outside the BIOS, e.g. by the DOS and by the ROMDOS
; loader.
;
	include	oemconf.inc


	ifndef	In_Bios		; if we're actually running in the BIOS,
;				;  then our segment is already open and
;				;  we'll actually generate code

Bdata	segment at 70h
	assume	cs:Bdata
	org	3		; fixed location in Bios_Data segment
int_2f	=	0		; define dummy so msbdata will assemble

	endif

	public	dosdatasg
DosDataSg dw	0		; Let DOS find it's data segment through here
				; Note: this value is set by the ROMDOS loader
				; to tell where the DOS data and init code
				; has been loaded into RAM


;	dos's int 2f handler will exit via a jump through here.  This is
;	  how the BIOS hooks int2f
	
	public	bios_i2f	; M012
bios_i2f proc	far
;	jmp	int_2f		; assembler won't generate forward
;				;  reference to a far label
	db	0eah
	dd	int_2f		; generate manual far jump
bios_i2f endp

ifdef	ROMEXEC
	public	romstartaddr
romstartaddr	dw	ROMEXEC_SEG ; The start address for the romfind routines
				    ; is obtained from here (70:A)
else
	public	romstartaddr
romstartaddr	dw	0	; The start address for the romfind routines
				; This is to maintain binary compatibilty
				;  with DISK based DOS 5.0
endif


; This is a byte used for special key handling in the resident
; console device driver.  It must be here so that it can be included
; in the WIN386 instance table (in INC\LMSTUB.ASM).

	public	altah

altah		db	0	;special key handling


ifdef	ROMDOS
; ROMDOS support:
;   The following values in the BIOS data segment are set by the ROMDOS
;   loader at boot time before the BIOS starts running.

	public	BIOS_Res
BIOS_Res	dw	?	; segment addr of BIOS resident code (in ROM)

	public	DOS_Res
DOS_Res		dw	?	; segment addr of DOS resident code (in ROM)

	public	BootFlags
BootFlags	dw	?	; boot options from CMOS or multiboot menu


endif
; 
; End of ROMDOS support

	ifndef	In_Bios
Bdata	ends
	endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msghan.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

	       IF1			;AN000;
                     ;%OUT INCLUDING MSGHAN.INC...;AN000;
	       ENDIF			;AN000;
;THIS IS A COMMONLY INCLUDED FILE, USED BY (AT LEAST) THE FOLLOWING COMPONENTS:
;TREE, GRAFTABL, DISKCOMP, DISKCOPY, COMP - WRITTEN OR Revised BY E.K.

;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;AN000;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;AN000;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;AN000;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;AN000;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;AN000;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;AN000;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC	  STRUC 	   ;AN000;
MSG_NUM 	  DW	0	   ;AN000;MESSAGE NUMBER (TO AX)
MSG_HANDLE	  DW	STDOUT	   ;AN000;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	  DW	0	   ;AN000;POINTER TO SUBLIST (TO SI)
MSG_COUNT	  DW	0	   ;AN000;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	  DW	CLASS_A SHL 8 ;AN000;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	  ENDS		   ;AN000;

;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;AN000;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;AN000;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;AN000;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;AN000;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;AN000;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;AN000;MINIMUM WIDTH OF STRING FIELD
PAD_BLK        EQU   " "           ;AN000;CHAR FOR PAD FIELD
FILL_OFF       EQU   0		   ;AN000;TO BE REPLACED WITH ACTUAL OFFSET
FILL_SEG       EQU   0		   ;AN000;TO BE REPLACED WITH ACTUAL SEG ID

;THIS SUBLIST CONTROL BLOCK, POINTED TO BY SI WHEN SYSDISPMSG IS CALLED
;FURTHER DESCRIBES THE MESSAGE AND THE VARIABLE FIELDS THE MSG MAY CONTAIN.
;THERE IS ONE OF THESE CONTROL BLOCKS PER VARIABLE FIELD.  ADDITIONAL
;VARIABLE FIELDS ARE DEFINED IN ADDITIONAL "SUBLIST" CONTROL BLOCKS,
;CONSECUTIVE AND CONTIGUOUS WITH THIS ONE.  THE NUMBER OF THESE CONTROL
;BLOCKS IS THE SUBSTITUTION COUNT, PASSED IN CS TO SYSDISPMSG, AS DEFINED
;IN THE ABOVE "MSC_DESC" CONTROL BLOCK.

SUBLIST 	  STRUC 	;AN000;
SUB_SIZE	  DB	11	;AN000;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	  DB	0	;AN000;RESERVED
				;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	  DW	0	;AN000;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	  DW	0	;AN000;SEG ID OF PTR
				;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				; IF THIS IS A .COM FILE)
SUB_ID		  DB	0	;AN000;N OF %N
SUB_FLAGS	  DB	0	;AN000;DATA TYPE FLAGS
SUB_MAX_WIDTH	  DB	MAX_0	;AN000;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	  DB	0	;AN000;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	  DB	PAD_BLK ;AN000;CHARACTER FOR PAD FIELD
				; CAN BE " ", "0" OR ",".
				; "," CAUSES INSERTION OF THE ACTIVE
				; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
SUBLIST 	  ENDS		;AN000;

;		  BITS DEFINED FOR SUB_FLAGS ABOVE
;			FORMAT = A0SSTTTT
;				 ++ + +--- FIELD TYPE
;				 || +--- DATA VARIABLE SIZE
;				 |+--- RESERVED, MUST BE ZERO
;				 +--- ALIGNMENT INDICATOR
SF_BITS     RECORD F_ALIGN:1,F_RES:1=0,F_SIZE:2,F_TYPE:4;AN000;

;		F_ALIGN FIELD, ALIGNMENT INDICATOR
SF_LEFT 	  EQU	0	   ;AN000;LEFT ALIGN
SF_RIGHT	  EQU	1	   ;AN000;RIGHT ALIGN

;		F_RES FIELD, RESERVED, SHOULD BE ZERO

;		F_TYPE FIELD, FIELD TYPE
SF_CHAR 	  EQU	0000B	   ;AN000;TYPE IS CHARACTER
;		F_SIZE FIELD,
SF_CH		  EQU	00B	   ;AN000;SINGLE CHARACTER
SF_ASCIIZ	  EQU	01B	   ;AN000;ASCIIZ STRING

;		F_TYPE FIELD, FIELD TYPE
SF_UN_BD	  EQU	0001B	   ;AN000;UNSIGNED BINARY TO DECIMAL CHARACTER
;		F_SIZE FIELD,
SF_BYTE 	  EQU	01B	   ;AN000;DATA IS BYTE SIZED
SF_WORD 	  EQU	10B	   ;AN000;DATA IS WORD SIZED
SF_DWORD	  EQU	11B	   ;AN000;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_SIN_BD	  EQU	0010B	   ;AN000;SIGNED BINARY TO DECIMAL CHARACTER
;		F_SIZE FIELD,
;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_UN_BH	  EQU	0011B	   ;AN000;UNSIGNED BINARY TO HEXADECIMAL CHARACTER
;		F_SIZE FIELD,
;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_DATE 	  EQU	0100B	   ;AN000;DATE TO CHARACTER,
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=YEAR
				   ;SUB_VALUE LOW=MMDD
;		F_SIZE FIELD,
SF_MD		  EQU	01B	   ;AN000;MONTH AND DAY ONLY
SF_MDY2 	  EQU	10B	   ;AN000;MONTH,DAY AND YEAR (2 DIGITS)
SF_MDY4 	  EQU	11B	   ;AN000;MONTH,DAY AND YEAR (4 DIGITS)

;		F_TYPE FIELD, FIELD TYPE
SF_TIME_12	  EQU	0101B	   ;AN000;TIME TO CHARACTER, 12 HOUR FORMAT
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=HHMM
				   ;SUB_VALUE LOW=SSHH
;		F_SIZE FIELD,
SF_HHMM 	  EQU	00B	   ;AN000;HH:MM (ACTIVE TIME FORMAT)
SF_HHMMSS	  EQU	01B	   ;AN000;HH:MM:SS (ACTIVE TIME FORMAT)
SF_HHMMSSHH	  EQU	10B	   ;AN000;HH:MM:SS:HH

;		F_TYPE FIELD, FIELD TYPE
SF_TIME_24	  EQU	0110B	   ;AN000;TIME TO CHARACTER, 24 HOUR FORMAT
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=HHMM
				   ;SUB_VALUE LOW=SSHH
;		F_SIZE FIELD,
;SF_HHMM	  EQU	00B	   ;HH:MM (ACTIVE TIME FORMAT)
;SF_HHMMSS	  EQU	01B	   ;HH:MM:SS (ACTIVE TIME FORMAT)
;SF_HHMMSSHH	  EQU	10B	   ;HH:MM:SS:HH

;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES

	       PUBLIC MSGNUM_EXTERR;AN000;
MSGNUM_EXTERR  MSG_DESC <,STDERR,,,CLASS_1 SHL 8> ;AN000;ALL EXTENDED DOS ERRORS
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES

	       PUBLIC MSGNUM_PARSE ;AN000;SO PARSE DRIVER CAN FIND IT
MSGNUM_PARSE   MSG_DESC <,STDERR,,,CLASS_2 SHL 8> ;AN000;ALL PARSING ERRORS
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT

	       PUBLIC MSGNUM_VER   ;AN000;
MSGNUM_VER     MSG_DESC <1,STDERR> ;AN000;"Incorrect DOS Version"
;end of MSGHAN.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msgdcl.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; This Macro was removed from sysmsg.inc. We had to remove this
; macro and put it into it's own include file in order to clear up
; some assembly errors. MS MASM will not allow a public declaration
; during the second pass of the assembler. IBM MASM will allow this.
;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_DECLARE	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
$M_DECLARE    macro	numcls	       ;
   $M_DCOUNT = 0		       ;
   REPT  numcls 		       ;
     $M_DCOUNT =  $M_DCOUNT + 1        ;
     $M_DECLARE2  %$M_DCOUNT	       ;
   ENDM 			       ;

  IF COMR
    IFNDEF $M_RT2			;  If Resident table is not in this assembly,
	EXTRN	$M_RT2:BYTE		;     Must be external
    ELSE
	PUBLIC	$M_RT2
    ENDIF				;
  ELSE
    IFNDEF $M_RT			;  If Resident table is not in this assembly,
	EXTRN	$M_RT:BYTE		;     Must be external
    ELSE
	PUBLIC	$M_RT
    ENDIF				;
  ENDIF

  $M_CHECK $M_GET_MSG_ADDRESS	      ;  If this subroutine is not in this assembly,
  $M_CHECK $M_MSGSERV_1 	      ;  If this subroutine is not in this assembly,
  $M_CHECK $M_MSGSERV_2 	      ;  If this subroutine is not in this assembly,

ENDM				       ;
				       ;
$M_DECLARE2   macro   innum	       ;
  IF NOT COMR			       ; IF Not resident COMMAND.COM
    IF NOT COMT 			 ; IF Not transient COMMAND.COM
      IFNDEF  $M_CLS_&innum		 ; IF class is not in this assembly,
	IF	FARmsg			 ;
	  EXTRN   $M_CLS_&innum:FAR	 ;    Must be external
	ELSE				 ;
	  EXTRN   $M_CLS_&innum:NEAR	 ;    Must be external
	ENDIF				 ;
      ELSE				 ; ELSE
	PUBLIC	$M_CLS_&innum		 ;    Label PUBLIC
      ENDIF				 ;
    ELSE				 ; ELSE
      IFDIF  <$M_CLS_&innum>,<$M_CLS_1>  ; IF NOT $M_CLS_1 or
	IFDIF <$M_CLS_&innum>,<$M_CLS_2> ;   IF NOT $M_CLS_2 then
	  IFNDEF  $M_CLS_&innum 	 ;     IF class is not in this assembly,
	    IF	    FARmsg		 ;
	      EXTRN   $M_CLS_&innum:FAR  ;	 Must be external
	    ELSE			 ;
	      EXTRN   $M_CLS_&innum:NEAR ;	 Must be external
	    ENDIF			 ;
	  ELSE				 ;     ELSE
	    PUBLIC  $M_CLS_&innum	 ;	 Label PUBLIC
	  ENDIF 			 ;
	ENDIF				 ;
      ENDIF				 ;
    ENDIF				 ;
  ELSE					 ; ELSE
    IFDIF  <$M_CLS_&innum>,<$M_CLS_1>	 ; IF NOT $M_CLS_1 or
      IFDIF <$M_CLS_&innum>,<$M_CLS_2>	 ;   IF NOT $M_CLS_2 then
	IFNDEF	$M_CLS_&innum		 ;     IF class is not in this assembly,
	  IF	  FARmsg		 ;
	    EXTRN   $M_CLS_&innum:FAR	 ;	 Must be external
	  ELSE				 ;
	    EXTRN   $M_CLS_&innum:NEAR	 ;	 Must be external
	  ENDIF 			 ;
	ELSE				 ;     ELSE
	  PUBLIC  $M_CLS_&innum 	 ;	 Label PUBLIC
	ENDIF				 ;
      ENDIF				 ;
    ENDIF				 ;
  ENDIF 			       ;
ENDM				       ;
				       ;
$M_CHECK      macro   parm	       ;
  IFNDEF  parm			       ; IF class is not in this assembly,
    IF	    FARmsg		       ;
      EXTRN   parm:FAR		       ;    Must be external
    ELSE			       ;
      EXTRN   parm:NEAR 	       ;    Must be external
    ENDIF			       ;
  ELSE
    IF COMR
    ELSE
      PUBLIC parm
    ENDIF
  ENDIF 			       ;
ENDM				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
IF1				       ;
  $M_DECLARE %$M_NUM_CLS	       ;  Declare any class not in this assembly
ENDIF				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msbds.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


; values for various flags in bds_flags.

fnon_removable	    equ     01h 	;for non-removable media
fchangeline	    equ     02h 	;if changeline supported on drive
return_fake_bpb     equ     04h 	; when set, don't do a build bpb
					; just return the fake one
good_tracklayout    equ     08h 	; the track layout has no funny sectors
fi_am_mult	    equ     10h 	;if more than one logical for this physical
fi_own_physical     equ     20h 	;signify logical owner of this physical
fchanged	    equ     40h 	;indicates media changed
set_dasd_true	    equ     80h 	; set dasd before next format
fchanged_by_format  equ    100h 	;media changed by format
unformatted_media   equ    200h 	;an001; fixed disk only

;
; various form factors to describe media
;
ff48tpi 	    equ     0
ff96tpi 	    equ     1
ffsmall 	    equ     2
ffhardfile	    equ     5
ffother 	    equ     7
ff288		    equ     9		; 2.88 MB drive

bds_struc	struc
bds_link	dd		0ffffh	; link to next bds
bds_drivenum	db		80	; int 13 drive number
bds_drivelet	db		3	; dos drive number

;	We want to embed a BPB declaration here, but we can't initialize
;	it properly if we do, so we duplicate the byte/word/dword architecture
;	of the BPB declaration.

;BDS_BPB	db	size BPBSTRUC dup (?)	; actual BPB
BDS_BPB		dw	512		; BPB_BYTESPERSECTOR
		db	1		; BPB_SECTORSPERCLUSTER
		dw	1		; BPB_RESERVEDSECTORS
		db	2		; BPB_NUMBEROFFATS
		dw	16		; BPB_ROOTENTRIES
		dw	0		; BPB_TOTALSECTORS
		db	0f8h		; BPB_MEDIADESCRIPTOR
		dw	1		; BPB_SECTORSPERFAT
		dw	0		; BPB_SECTORSPERTRACK
		dw	0		; BPB_HEADS
		dd	0		; BPB_HIDDENSECTORS
		dd	0		; BPB_BIGTOTALSECTORS

bds_fatsiz	db		0	; flags...
bds_opcnt	dw		0	; open ref. count
bds_formfactor	db		3	; form factor index
bds_flags	dw		0020h	; various flags
bds_ccyln	dw		40	; max number of cylinders

BDS_RBPB	db size A_BPB dup (0)	; recommended BPB

bds_track	db		-1	; last track accessed on drive
bds_tim_lo	dw		1	; time of last access. keep
bds_tim_hi	dw		0	; these contiguous.
bds_volid	db "NO NAME    ",0	; volume id of medium
bds_vol_serial	dd	0	  ;current volume serial number from boot record
bds_filesys_id	db	"FAT12   ",0 ; current file system id from boot record
bds_struc	ends

;	The assembler will generate bad data for "size bds_volid", so we'll
;	  define an equate here.

VOLID_SIZ	equ	12

bdsm_ismini	equ	bds_tim_lo	; overlapping bds_tim_lo
bdsm_hidden_trks equ	bds_tim_hi	; overlapping bds_tim_hi

max_mini_dsk_num = 23	      ; max # of mini disk ibmbio can support


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mstable.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)ibmtable.asm	1.1 85/04/10
;
; Table Segment for DOS
;

.xlist
.xcref
include version.inc
include mssw.asm
.cref
.list

TITLE	IBMTABLE - Table segment for DOS
NAME	IBMTABLE

include ms_table.asm
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mshalo.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
;   there is a header that describes a block of rom program.  This header
;   contains information needed to initialize a module and to provide PCDOS
;   with a set of reserved names for execution.
;
;   This header has the following format:
;
;   rom_header	STRUC
;	Signature1  DB	55h
;	Signature2  DB	AAh
;	rom_length  DB	?		; number of 512 byte pieces
;	init_jmp    DB	3 dup (?)
;	name_list   name_struc <>
;   rom_header	ENDS
;
;   name_struc	STRUC
;	name_len    DB	?
;	name_text   DB	? DUP (?)
;	name_jmp    DB	3 DUP (?)
;   name_struc	ENDS
;
;   The name list is a list of names that are reserved by a particular section
;   of a module.  This list of names is terminated by a null name (length
;   is zero).
;
;   Consider now, the PCDOS action when a user enters a command:
;
;	COMMAND.COM has control.
;	o   If location FFFFEh has FDh then
;	o	Start scanning at C0000h, every 800h for a byte 55h followed
;		    by AAh, stop scan if we get above or = F0000H
;	o	When we've found one, compare the name entered by the user
;		    with the one found in the rom.  If we have a match, then
;		    set up the environment for execution and do a long jump
;		    to the near jump after the found name.
;	o	If no more names in the list, then continue scanning the module
;		    for more 55h followed by AAh.
;	o   We get to this point only if there is no matching name in the
;		rom.  We now look on disk for the command.
;
;   This gives us the flexibility to execute any rom cartridge without having
;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
;   want to be invisible to the DOS should not have any names in their lists
;   (i.e. they have a single null name).
;
;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
;   Clearly this version will be available on disk.  How does a user actually
;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
;   EXEC loader will execute the ROM before it even looks at the disk!	Only
;   solution:
;
;   o	Keep things consistent and force the user to have his software named
;	differently from the ROM names (BASIC1, BASIC2, etc).

rom_header  STRUC
    Signature1	DB  ?
    Signature2	DB  ?
    rom_length	DB  ?
    init_jmp	DB  3 dup (?)
    name_list	DB  ?
rom_header  ENDS

name_struc  STRUC
    name_len	DB  ?
    name_text	DB  1 DUP (?)
    name_jmp	DB  3 DUP (?)
name_struc  ENDS

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;
; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
;
ROM_SCAN:
	PUSH	ES
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX
	PUSH	BX
;
; check for PC Jr signature in rom
;
	MOV	AX,0F000h
	MOV	ES,AX
	CMP	BYTE PTR ES:[0FFFEh],0FDh
	JZ	SCAN_IT
NO_ROM:
	CLC
ROM_RET:
	POP	BX
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	POP	ES
	RET
SCAN_IT:
;
; start scanning at C000
;
	MOV	AX,0C000h
SCAN_ONE:
	MOV	ES,AX
	XOR	DI,DI
SCAN_MODULE:
;
; check for a valid header
;
	CMP	WORD PTR ES:[DI],0AA55h
	JZ	SCAN_LIST
	ADD	AX,080h
SCAN_END:
	CMP	AX,0F000h
	JB	SCAN_ONE
	JMP	NO_ROM
;
; trundle down list of names
;
SCAN_LIST:
	MOV	BL,ES:[DI].rom_length	; number of 512-byte jobbers
	XOR	BH,BH			; nothing in the high byte
	SHL	BX,1
	SHL	BX,1			; number of paragraphs
	ADD	BX,7Fh
	AND	BX,0FF80h		; round to 2k

	MOV	DI,name_list
SCAN_NAME:
	MOV	CL,ES:[DI]		; length of name
	INC	DI			; point to name
	XOR	CH,CH
	OR	CX,CX			; zero length name
	JNZ	SCAN_TEST		; nope... compare
	ADD	AX,BX			; yep, skip to next block
	JMP	SCAN_END
;
; compare a single name
;
SCAN_TEST:
	MOV	SI,DX
	INC	SI
	REPE	CMPSB			; compare name
	JZ	SCAN_FOUND		; success!
SCAN_NEXT:
	ADD	DI,CX			; failure, next name piece
	ADD	DI,3
	JMP	SCAN_NAME
;
; found a name. save entry location
;
SCAN_FOUND:
	CMP	BYTE PTR DS:[SI],'?'
	JZ	SCAN_SAVE
	CMP	BYTE PTR DS:[SI],' '
	JNZ	SCAN_NEXT
SCAN_SAVE:
	MOV	[rom_cs],ES
	MOV	[ROM_ip],DI
	STC
	JMP	ROM_RET

;
; execute a rom-placed body of code. allocate largest block
;
ROM_EXEC:
	MOV	BX,0FFFFh
	MOV	AH,ALLOC
	INT	int_command
	MOV	AH,ALLOC
	INT	int_command
	PUSH	BX
	PUSH	AX
;
; set terminate addresses
;
	MOV	AX,(set_interrupt_vector SHL 8) + int_terminate
	PUSH	DS
	MOV	DS,[RESSEG]
	ASSUME	DS:RESGROUP
	MOV	DX,OFFSET RESGROUP:EXEC_WAIT
	INT	int_command
	MOV	DX,DS
	MOV	ES,DX
	ASSUME	ES:RESGROUP
	POP	DS
	ASSUME	DS:NOTHING
;
; and create program header and dup all jfn's
;
	POP	DX
	MOV	AH,DUP_PDB
	INT	int_command
;
; set up dma address
;
	MOV	DS,DX
	MOV	DX,080h
	MOV	AH,SET_DMA
	INT	int_command
;
; copy in environment info
;
	MOV	AX,[ENVIRSEG]
	MOV	DS:[PDB_environ],AX
;
; set up correct size of block
;
	POP	BX			; BX has size, DS has segment
	MOV	DX,DS
	ADD	DX,BX
	MOV	DS:[PDB_block_len],DX
;
; change ownership of block
;
	MOV	DX,DS
	DEC	DX
	MOV	DS,DX
	INC	DX
	MOV	DS:[arena_owner],DX
	MOV	DS,DX
;
; set up correct stack
;
	CMP	BX,1000h
	JB	GOT_STACK
	XOR	BX,BX
GOT_STACK:
	MOV	CL,4
	SHL	BX,CL
	MOV	DX,DS
	MOV	SS,DX
	MOV	SP,BX
	XOR	AX,AX
	PUSH	AX
;
; set up initial registers and go to the guy
;
	NOT	AX
	PUSH	[ROM_CS]
	PUSH	[ROM_IP]
	MOV	ES,DX
ASSUME ES:NOTHING
FOOBAR	PROC	FAR
	RET
FOOBAR	ENDP

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\ms_data.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;       SCCSID = @(#)msdata.asm 1.8 85/09/12

;
;----------------------------------------------------------------------------
;
; M008 : Renamed callback_ss & callback_sp to AbsRdWr_SS & AbsRdWr_SP
;	 To be used in Absolute Read/Write DISK routines
; M019 DB 10/26/90 - Disk write optimization: removed HIGH_SECTOR_TEMP.
;
;----------------------------------------------------------------------------
;
        AsmVars <Debug, Redirector, ShareF>
 
;
;smr;--- These extrns should be in DOSCODE segment
;
DOSCODE		SEGMENT	BYTE PUBLIC 'CODE'
;hkn;		extrn	ucase_tab:byte
;hkn;		extrn	file_ucase_tab:byte
;hkn;		extrn	file_char_tab:byte
;hkn;		extrn	collate_tab:byte
;hkn;		extrn	dbcs_tab:byte
;hkn;		extrn	map_case:byte

		extrn	DIVOV:near
		extrn	QUIT:near
		extrn	COMMAND:near
		extrn	ABSDRD:near
		extrn	ABSDWRT:near
		extrn	Stay_resident:near
		extrn	INT2F:near
		extrn	CALL_ENTRY:near
		extrn	IRETT:near

DOSCODE		ENDS
;
Break <Uninitialized data overlayed by initialization code>
 
DOSDATA    SEGMENT WORD PUBLIC 'DATA'
; Init code overlaps with data area below
 
;        ORG     0
PUBLIC MSDAT001S,MSDAT001E
MSDAT001S       label byte
 
        I_am    TIMEBUF,6               ; Time read from clock device
        I_am    DEVIOBUF,2              ; Buffer for I/O under file assignment
;
; The following areas are used as temp buffer in EXEC system call
;
        I_am    OPENBUF,128             ; buffer for name operations
        I_am    RenBuf,128              ; buffer for rename destination
; Buffer for search calls
        I_am    SEARCHBUF,53            ; internal search buffer
        I_am    DummyCDS,curdirLen
;
; End of contiguous buffer
;
 
;
; Temporary directory entry for use by many routines.  Device directory
; entries (bogus) are built here.
;
        PUBLIC  DevFCB
DEVFCB  LABEL   BYTE                    ; Uses NAME1, NAME2, combined
; WARNING..  do not alter position of NAME1 relative to DEVFCB
; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
; as well as it is the only guy who uses NAME2 and DESTSTART.
        I_am    NAME1,12                ; File name buffer
        I_am    NAME2,13                ;
        I_am    DESTSTART,WORD          ;
        DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
;
; End Temporary directory entry.
;
        I_am    ATTRIB,BYTE             ; storage for file attributes
        I_am    EXTFCB,BYTE             ; TRUE => extended FCB in use
        I_am    SATTRIB,BYTE            ; Storage for search attributes
        I_AM    open_access,BYTE        ; access of open system call
        I_am    FoundDel,BYTE           ; true => file was deleted
        I_am    Found_dev,BYTE          ; true => search found a device
        I_am    fSplice,BYTE            ; true => do a splice in transpath
        I_am    fSharing,BYTE           ; TRUE => no redirection
        I_am    SECCLUSPOS,BYTE         ; Position of first sector within cluster
        I_am    TRANS,BYTE              ;
        I_am    READOP,BYTE             ;
        I_am    THISDRV,BYTE            ;
        I_am    CLUSFAC,BYTE            ;
        I_am    CLUSSPLIT,BYTE          ;
        I_am    INSMODE,BYTE            ; true => insert mode in buffered read
        I_am    cMeta,BYTE              ; count of meta'ed components found
        I_am    VOLID,BYTE              ;
        I_am    exit_type,BYTE          ; type of exit...
 
        EVEN
 
; WARNING - the following two items are accessed as a word
        I_am    CREATING,BYTE           ; true => creating a file
	I_am	DELALL,BYTE		; = 0 iff BUGBUG
					; = DIRFREE iff BUGBUG
        I_am    EXITHOLD,DWORD          ; Temp location for proc terminate
        I_am    user_SP,WORD            ; User SP for system call
        I_am    user_SS,WORD            ; User SS for system call
        I_am    CONTSTK,WORD            ;
        I_am    THISDPB,DWORD           ;
        I_am    CLUSSAVE,WORD           ;
        I_am    CLUSSEC,DWORD           ;>32mb                                  AC0000
        I_am    PREREAD,WORD            ; 0 means preread; 1 means optional
        I_am    FATBYT,WORD             ; Used by ALLOCATE
        I_am    FATBYTE,WORD            ; Used by $SLEAZEFUNC
        I_am    DEVPT,DWORD             ;
        I_am    THISSFT,DWORD           ; Address of user SFT
        I_am    THISCDS,DWORD           ; Address of current CDS
        I_am    THISFCB,DWORD           ; Address of user FCB
        I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
        I_am    JFN,WORD                ; JobFileNumber found for accessfile
        I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
        I_am    WFP_START,WORD          ;
        I_am    REN_WFP,WORD            ;
        I_am    CURR_DIR_END,WORD       ;
        I_am    NEXTADD,WORD            ;
        I_am    LASTPOS,WORD            ;
        I_am    CLUSNUM,WORD            ;
        I_am    DIRSEC,DWORD            ;>32mb                                  AC0000
        I_am    DIRSTART,WORD           ;
        I_am    SECPOS,DWORD       ;>32mb Position of first sector accessed
        I_am    VALSEC,DWORD       ;>32mb Number of valid (previously written)
                                        ; sectors
        I_am    BYTSECPOS,WORD          ; Position of first byte within sector
        I_am    BYTPOS,4                ; Byte position in file of access
        I_am    BYTCNT1,WORD            ; No. of bytes in first sector
        I_am    BYTCNT2,WORD            ; No. of bytes in last sector
        I_am    SECCNT,WORD             ; No. of whole sectors
        I_am    ENTFREE,WORD            ;
        I_am    ENTLAST,WORD            ;
        I_am    NXTCLUSNUM,WORD         ;
        I_am    GROWCNT,DWORD           ;
        I_am    CURBUF,DWORD            ;
        I_am    CONSft,DWORD            ; SFT of console swapped guy.
        I_am    SaveBX,WORD             ;
        I_am    SaveDS,WORD             ;
        I_am    restore_tmp,WORD        ; return address for restore world
        I_am    NSS,WORD
        I_am    NSP,WORD
        I_am    EXTOPEN_FLAG,WORD,<0>   ;FT. extended open input flag           ;AN000;
        I_am    EXTOPEN_ON,BYTE,<0>     ;FT. extended open conditional flag     ;AN000;
        I_am    EXTOPEN_IO_MODE,WORD,<0>;FT. extende open io mode               ;AN000;
        I_am    SAVE_DI,WORD            ;FT. extende open saved DI              ;AN000;
        I_am    SAVE_ES,WORD            ;FT. extende open saved ES              ;AN000;
        I_am    SAVE_DX,WORD            ;FT. extende open saved DX              ;AN000;
        I_am    SAVE_CX,WORD            ;FT. extende open saved CX              ;AN000;
        I_am    SAVE_BX,WORD            ;FT. extende open saved BX              ;AN000;
        I_am    SAVE_SI,WORD            ;FT. extende open saved SI              ;AN000;
        I_am    SAVE_DS,WORD            ;FT. extende open saved DS              ;AN000;

;	HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
;	we used to just pass 16 bits in a register.  Now High_SECTOR holds
;	the high 16, the low 16 are still in the register.

        I_am    HIGH_SECTOR,WORD,<0>    ;>32mb higher sector #                  ;AN000;

        ;I_am    UU_HIGH_SECTOR_TEMP,WORD,<0> ;M019: Unused
        I_am    OffsetMagicPatch,WORD,<offset MagicPatch> ;scottq 8/6/92
                                                          ;see dos\mpatch.asm

        I_am    DISK_FULL,BYTE          ;>32mb indicating disk full when 1      ;AN000;
        I_am    TEMP_VAR,WORD           ; temporary variable for everyone       ;AN000;
        I_am    TEMP_VAR2,WORD          ; temporary variable 2 for everyone     ;AN000;
        I_am    DrvErr,BYTE             ; used to save drive error              ;AN000;
        I_am    DOS34_FLAG,WORD,<0>     ; common flag for DOS 3.4               ;AN000;
        I_am    NO_FILTER_PATH,DWORD    ; pointer to orignal path               ;AN000;
        I_am    NO_FILTER_DPATH,DWORD   ; pointer to orignal path of destination;AN000;
; M008
        I_am   AbsRdWr_SS,WORD         ; INT 25/26 user stack segment
        I_am   AbsRdWr_SP,WORD         ; INT 25/26 user stack offset
        I_am   UU_Callback_flag,BYTE,<0>  ; Unused
; M008
 
 
; make those pushes fast!!!
EVEN
StackSize   =   180h                    ; gross but effective
;;;StackSize   =   300h                    ; This is a "trial" change IBM hasn't
;;;                                        ; made up their minds about
 
;
; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
;
 
        PUBLIC  RENAMEDMA,AuxStack,DskStack,IOStack
RENAMEDMA   LABEL   BYTE                ; See DOS_RENAME
 
        DB      StackSize DUP (?)       ;
AuxStack    LABEL   BYTE
 
        DB      StackSize DUP (?)       ;
DskStack    LABEL   BYTE
 
        DB      StackSize DUP (?)       ;
IOStack LABEL   BYTE
 
 
; patch space for Boca folks.
; Say What????!!! This does NOT go into the swappable area!
; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
;       This allows the REDIRector to work on either IBM or MS-DOS.
 
PUBLIC  IBMPATCH
IBMPATCH    label byte
        I_am    PRINTER_FLAG,BYTE,<0>   ; [SYSTEM] status of PRINT utility
        I_am    VOLCHNG_FLAG,BYTE,<0>   ; [SYSTEM] true if volume label created
        I_am    VIRTUAL_OPEN,BYTE,<0>   ; [SYSTEM] non-zero if we opened a virtual file
 
; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
      I_am     FSeek_drive,BYTE         ;AN000; fastseek drive #
      I_am     FSeek_firclus,WORD       ;AN000; fastseek first cluster #
      I_am     FSeek_logclus,WORD       ;AN000; fastseek logical cluster #
      I_am     FSeek_logsave,WORD       ;AN000; fastseek returned log clus #
;      I_am     UU_ACT_PAGE,WORD,<-1>       ;;;;;;; ;BL ; active EMS page                       ;AN000;
      I_am     TEMP_DOSLOC,WORD,<-1>    ;stores the temporary location of dos
					;at SYSINIT time.
 
 
SWAP_END    LABEL   BYTE
PUBLIC  SWAP_END
 
; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
;   BE USED. If the size of the swap data area is ODD, it will be rounded up
;   to include this byte.
        DB      ?
 
;hkn;            DB      (512+80+32-(SWAP_END-ibmpatch)) DUP (?)


DOSDATA    ENDS



DOSDATALAST SEGMENT
	
MSDAT001e       label byte
 
DOSDATALAST ENDS


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\msgserv.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; * * * * * * * * * * * * START OF SPECIFICATIONS * * * * * * * * * * * * * * *
;
; MODULE NAME: MSGSERV.SAL
;
; DESCRIPTIVE NAME: Message Services SALUT file
;
; FUNCTION: This module incorporates all the messages services and
;	    is called upon at build time to INCLUDE the code requested
;	    by a utility. Code is requested using the macro MSG_SERVICES.
;
; ENTRY POINT: Since this a collection of subroutines, entry point is at
;	    requested procedure.
;
; INPUT: Since this a collection of subroutines, input is dependent on function
;	    requested.
;
; EXIT-NORMAL: In all cases, CARRY FLAG = 0
;
; EXIT-ERROR: In all cases, CARRY FLAG = 1
;
; INTERNAL REFERENCES: (list of included subroutines)
;
;	- SYSLOADMSG
;	- SYSDISPMSG
;	- SYSGETMSG
;
;
; EXTERNAL REFERENCES: None
;
; NOTES: At build time, some modules must be included. These are only included
;	 once using assembler switches. Other logic is included at the request
;	 of the utility.
;
;	 COMR and COMT are assembler switches to conditionally assemble code
;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
;	 storage and multiple EQUates.
;
; REVISION HISTORY: Created MAY 1987
;
;     Label: DOS - - Message Retriever
;	     (c) Copyright 1988 Microsoft
;
;
; * * * * * * * * * * * * END OF SPECIFICATIONS * * * * * * * * * * * * * * * *
; Page 

;
;	Revision History
;	================
;
;	M007	SR	08/24/90	Fixed bug #1818 -- changed
;				$M_DISPLAY_H_STRING to properly
;				handle Ctrl-Z being passed
;
;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
;				these routines are no longer assembled.
;
;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
;				CR-LF string also gets reinitialized
;				on every cycle.
;
;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
;				& $_MSG_NUM also in SYSLOADMSG.
;



;   $SALUT	     $M  (2,5,22,62)			     ;;AN000;; Set SALUT formatting

IF  $M_STRUC						     ;;AN000;; IF we haven't included the structures yet THEN
    $M_STRUC	     =	FALSE				     ;;AN000;;	 Let the assembler know that we have
							     ;;AN000;;	   and include them

    PAGE
    SUBTTL	     DOS - Message Retriever - MSGSTR.INC Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_SUBLIST_STRUC
;;
;; Replacable parameters are described by a sublist structure
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_SUBLIST_STRUC STRUC					     ;;AN000;;
							     ;;
    $M_S_SIZE	     DB        11			     ;;AN000;; SUBLIST size  (PTR to next SUBLIST)
    $M_S_RESV	     DB        0			     ;;AN000;; RESERVED
    $M_S_VALUE	     DD        ?			     ;;AN000;; Time, Date or PTR to data item
    $M_S_ID	     DB        ?			     ;;AN000;; n of %n
    $M_S_FLAG	     DB        ?			     ;;AN000;; Data-type flags
    $M_S_MAXW	     DB        ?			     ;;AN000;; Maximum field width
    $M_S_MINW	     DB        ?			     ;;AN000;; Minimum field width
    $M_S_PAD	     DB        ?			     ;;AN000;; Character for Pad field
							     ;;
$M_SUBLIST_STRUC ENDS					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_CLASS_ID
;;
;; Each class will be defined by this structure.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CLASS_ID STRUC					     ;;AN000;;
							     ;;
    $M_CLS_ID	     DB        -1			     ;;AN000;; Class identifer
    $M_COMMAND_VER   DW        EXPECTED_VERSION 	     ;;AN003;; COMMAND.COM version check
    $M_NUM_CLS_MSG   DB        0			     ;;AN000;; Total number of message in class
							     ;;
$M_CLASS_ID ENDS					     ;;
							     ;;AN000;;
    $M_CLASS_ID_SZ   EQU       SIZE $M_CLASS_ID 	     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_ID_STRUC
;;
;; Each message will be defined by this structure.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_ID STRUC						     ;;AN000;;
							     ;;
    $M_NUM	     DW        -1			     ;;AN000;; Message Number
    $M_TXT_PTR	     DW        ?			     ;;AN000;; Pointer to message text
							     ;;
$M_ID ENDS						     ;;AN000;;
							     ;;AN000;; Status Flag Values:
    $M_ID_SZ	     EQU       SIZE $M_ID		     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_RES_ADDRS
;;
;; Resident data area definition of variables
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_RES_ADDRS STRUC					     ;;AN000;;
							     ;;
    $M_EXT_ERR_ADDRS DD        0			     ;;AN000;; Allow pointers to THREE Extended error locations
    $M_EXT_FILE      DD        0			     ;;AN001;;
    $M_EXT_COMMAND   DD        0			     ;;AN000;;
    $M_EXT_TERM      DD        -1			     ;;AN000;;
    $M_PARSE_COMMAND DD        0			     ;;AN000;;
    $M_PARSE_ADDRS   DD        0			     ;;AN000;; Allow pointers to TWO Parse error locations
    $M_PARSE_TERM    DD        -1			     ;;AN000;;
    $M_CRIT_ADDRS    DD        0			     ;;AN000;; Allow pointers to TWO Critical error locations
    $M_CRIT_COMMAND  DD        0			     ;;AN000;;
    $M_CRIT_TERM     DD        -1			     ;;AN000;;
    $M_DISK_PROC_ADDR DD       -1			     ;;AN004;; Address of READ_DISK_PROC
    $M_CLASS_ADDRS   DD        $M_NUM_CLS DUP(0)	     ;;AN000;; Allow pointers to specified classes
    $M_CLS_TERM      DD        -1			     ;;AN000;;
    $M_DBCS_VEC      DD        0			     ;;AN000;; Save DBCS vector
    $M_HANDLE	     DW        ?			     ;;AN000;;
    $M_SIZE	     DB        0			     ;;AN000;;
    $M_CRLF	     DB        0DH,0AH			     ;;AN004;; CR LF message
    $M_CLASS	     DB        ?			     ;;AN004;; Saved class
    $M_RETURN_ADDR   DW        ?			     ;;AN000;;
    $M_MSG_NUM	     DW        $M_NULL			     ;;AN000;;
    $M_DIVISOR	     DW        10			     ;;AN000;; Default = 10 (must be a WORD for division)
    $M_TEMP_BUF      DB        $M_TEMP_BUF_SZ DUP("$")	     ;;AN000;; Temporary buffer
    $M_BUF_TERM      DB        "$"			     ;;AN000;;

$M_RES_ADDRS ENDS					     ;;AN000;;
							     ;;
$M_RES_ADDRS_SZ EQU  SIZE $M_RES_ADDRS			     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_COUNTRY_INFO
;;
;; Important fields of the Get Country Information call
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_COUNTRY_INFO STRUC					     ;;AN000;; Expected Country infomation
							     ;;
    $M_HEADER	     DB       $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1 DUP(?) ;;AN000;; Go past first part of struc
    $M_DATE_FORMAT   DW       ? 			     ;;AN000;; <------- Date Format
    $M_CURR_SEPARA   DB       5 DUP(?)			     ;;AN000;;
    $M_THOU_SEPARA   DB       ?,0			     ;;AN000;; <------- Thou Separator
    $M_DECI_SEPARA   DB       ?,0			     ;;AN000;; <------- Decimal Separator
    $M_DATE_SEPARA   DB       ?,0			     ;;AN000;; <------- Date Separator
    $M_TIME_SEPARA   DB       ?,0			     ;;AN000;; <------- Time Separator
    $M_CURR_FORMAT   DB       ? 			     ;;AN000;;
    $M_SIG_DIGS_CU   DB       ? 			     ;;AN000;;
    $M_TIME_FORMAT   DB       ? 			     ;;AN000;; <------- Time Format
							     ;;
$M_COUNTRY_INFO ENDS					     ;;AN000;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
ELSE							     ;;AN000;;	ELSE if we have already included the STRUCTURES
; 
;   $SALUT  $M	(2,5,13,62)				     ;;AN000;;	Set SALUT formatting for code section

    IF	    MSGDATA					     ;;AN000;;	IF this is a request to include the data area
      MSGDATA =  FALSE					     ;;AN000;;	  Let the assembler know not to include it again
							     ;;AN000;;	  and include it
      PAGE
      SUBTTL  DOS - Message Retriever - MSGRES.TAB Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	DATA NAME: $M_RES_TABLE
;;
;;	REFERENCE LABEL: $M_RT
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF    COMR						     ;;AN000;; Since COMMAND.COM includes this twice
      $M_RT   EQU	       $M_RT2			     ;;AN000;;	we must redefine the label so no
      $M_RT2  LABEL  BYTE				     ;;AN000;;	 assembly errors occur
      $M_ALTLABEL = TRUE				     ;;AN000;; Flag that label was changed
ELSE							     ;;AN000;;
      $M_RT   LABEL   BYTE				     ;;AN000;;
ENDIF							     ;;AN000;;
      $M_RES_ADDRS <>					     ;;AN000;; Resident addresses
							     ;;
      include COPYRIGH.INC				     ;;AN001;; Include Copyright 1988 Microsoft
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ENDIF						     ;;AN000;; END of include of Data table

; 
    IF	    NOT  $M_MSGDATA_ONLY			     ;;AN000;; IF this was a request for only the data table THEN
							     ;; 	don't include any more code
							     ;;AN000;; Figure out what other code to  include
      IF      DISK_PROC 				     ;;AN003;;	 Is the request to include the READ_DISK code
	IF	COMR					     ;;AN003;;	 (Only Resident COMMAND.COM should ask for it)
	  $M_RT   EQU		   $M_RT2		     ;;AN003;;
	ENDIF
	DISK_PROC = FALSE				     ;;AN003;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - DISK_PROC Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: DISK_PROC
;;
;;	FUNCTION: Used in COMMAND.COM if we need to access the Parse or Extended
;;		  errors from disk\diskette
;;	INPUTS: AX has the message number
;;		DX has the message class
;;		AND ... the COMMAND.COM Variable RESGROUP:COMSPEC is
;;		assumed to be set!!
;;
;;	OUTPUTS: ES:DI points to message length (BYTE) followed by text
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
	PUBLIC	READ_DISK_PROC				     ;;
							     ;;
READ_DISK_PROC PROC FAR 				     ;;AN003;;

	PUSH	AX					     ;;AN003;; Save everything
	PUSH	BX					     ;;AN003;;
	PUSH	DX					     ;;AN003;;
	PUSH	SI					     ;;AN003;;
	PUSH	BP					     ;;AN003;;
	PUSH	DS					     ;;AN003;;
	PUSH	DI					     ;;AN003;;
	MOV	BP,AX					     ;;AN003;; Save message number
	MOV	AX,DOS_EXTENDED_OPEN			     ;;AN003;; Set INT 21 function
	LEA	SI,RESGROUP:COMSPEC			     ;;AN003;; Get addressibilty to COMMAND.COM
	PUSH	CS					     ;;AN003;;
	POP	DS					     ;;AN003;;
	MOV	DI,-1					     ;;AN003;; No extended attribute list
	MOV	BX,NO_CRIT_OPEN 			     ;;AN003;; Don't generate critical error
	MOV	DX,NOT_EX_FAIL_EX_OPEN			     ;;AN003;; Open Flag
	INT	21H					     ;;AN003;; Open the file
	POP	DI					     ;;AN003;; Retreive LSEEK pointer
							     ;;AN003;; Error ?
;	$IF	NC,LONG 				     ;;AN003;;	No,
	JNC $MXL1
	JMP $MIF1
$MXL1:
	  PUSH	  DI					     ;;AN003;; Save LSEEK pointer
	  MOV	  BX,AX 				     ;;AN003;;	 Set handle in BX
	  MOV	  AX,DOS_LSEEK_FILE			     ;;AN003;;	 LSEEK to the errors
	  XOR	  CX,CX 				     ;;AN003;;	   Value has been set by COMMAND.COM
	  MOV	  DX,DI 				     ;;AN003;;
	  INT	  21H					     ;;AN003;;	 LSEEK the file
	  POP	  DX					     ;;AN003;; Retreive LSEEK pointer
							     ;;AN003;;	 Error ?
;	  $IF	  NC					     ;;AN003;;	  No,
	  JC $MIF2
	    INC     CX					     ;;AN003;;	   Set flag to first pass
;	    $DO 					     ;;AN003;;
$MDO3:
	      PUSH    DX				     ;;AN003;;	   Save LSEEK pointer
	      PUSH    CX				     ;;AN003;;	   Save first pass flag
	      PUSH    AX				     ;;AN003;;	   Save number of messages (if set yet)
	      XOR     SI,SI				     ;;AN003;;	   Reset buffer index
	      MOV     AH,DOS_READ_BYTE			     ;;AN003;;	   Read
	      MOV     CX,$M_TEMP_BUF_SZ 		     ;;AN003;;	     the first part of the header
	      LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN003;;	       into the temp buffer
	      INT     21H				     ;;AN003;;	   Read it
	      MOV     DI,DX				     ;;AN003;;
	      POP     AX				     ;;AN003;;
	      POP     CX				     ;;AN003;;
	      OR      CX,CX				     ;;AN003;;
;	      $IF     NZ				     ;;AN003;;
	      JZ $MIF4
		XOR	CX,CX				     ;;AN003;;	   Set flag to second pass
		XOR	AH,AH				     ;;AN003;;	   Get number of messages in class
		MOV	AL,DS:[DI].$M_NUM_CLS_MSG	     ;;AN003;;
		MOV	SI,$M_CLASS_ID_SZ		     ;;AN003;;	   Initialize index
		CMP	DS:[DI].$M_COMMAND_VER,EXPECTED_VERSION ;;AN003;;  Is this the right version of COMMAND.COM?
;	      $ENDIF					     ;;AN003;;
$MIF4:
	      POP     DX				     ;;AN003;;
;	      $IF     Z 				     ;;AN003;;	   Yes,
	      JNZ $MIF6
;		$SEARCH 				     ;;AN003;;
$MDO7:
		  CMP	  BP,WORD PTR $M_RT.$M_TEMP_BUF[SI]  ;;AN003;;	     Is this the message I'm looking for?
;		$EXITIF Z				     ;;AN003;;	     Yes, (ZF=1)
		JNZ $MIF7
		  CLC					     ;;AN003;;	      Reset carry, exit search
;		$ORELSE 				     ;;AN003;;	     No,  (ZF=0)
		JMP SHORT $MSR7
$MIF7:
		  ADD	  SI,$M_ID_SZ			     ;;AN003;;	      Increment index
		  ADD	  DX,$M_ID_SZ			     ;;AN003;;	      Add offset of first header
		  DEC	  AX				     ;;AN003;;	      Decrement # of messages left
;		$LEAVE	Z				     ;;AN003;;	      Have we exhausted all messages?
		JZ $MEN7
		  CMP	  SI,$M_TEMP_BUF_SZ-1		     ;;AN003;;	       No, Have we exhausted the buffer?
;		$ENDLOOP A				     ;;AN003;;		No, Check next message (ZF=1)
		JNA $MDO7
$MEN7:
		  STC					     ;;AN003;;	       Yes, (ZF=0) set error (ZF=0)
;		$ENDSRCH				     ;;AN003;;
$MSR7:
;	      $ELSE					     ;;AN003;;	   No,
	      JMP SHORT $MEN6
$MIF6:
		XOR	CX,CX				     ;;AN003;;	     Set Zero flag to exit READ Loop
		STC					     ;;AN003;;	     Set Carry
;	      $ENDIF					     ;;AN003;;
$MEN6:
;	    $ENDDO  Z					     ;;AN003;;	       Get next buffer full if needed
	    JNZ $MDO3
							     ;;AN003;; Error ?
;	    $IF     NC					     ;;AN003;;	No,
	    JC $MIF16
	      MOV     AX,DOS_LSEEK_FILE 		     ;;AN003;;	 Prepare to LSEEK to the specific message
	      XOR     CX,CX				     ;;AN003;;	 Value has been set by COMMAND.COM
	      ADD     DX,$M_CLASS_ID_SZ 		     ;;AN003;;	 Add offset of first header
	      ADD     DX,WORD PTR $M_RT.$M_TEMP_BUF[SI]+2    ;;AN003;;	 Add offset from msg structure
	      INT     21H				     ;;AN003;;	 LSEEK the file
	      MOV     AH,DOS_READ_BYTE			     ;;AN003;;	   Read
	      MOV     CX,$M_TEMP_BUF_SZ 		     ;;AN003;;	     the message
	      LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN003;;	       into the temp buffer
	      INT     21H				     ;;AN003;;	   Read it
	      MOV     DI,DX				     ;;AN003;;	       into the temp buffer
	      PUSH    DS				     ;;AN003;;	       into the temp buffer
	      POP     ES				     ;;AN003;;	       into the temp buffer
;	    $ENDIF					     ;;AN003;;
$MIF16:
;	  $ENDIF					     ;;AN003;;
$MIF2:
	  PUSHF 					     ;;AN003;;	   Close file handle
	  MOV	  AH,DOS_CLOSE_FILE			     ;;AN003;;	   Close file handle
	  INT	  21H					     ;;AN003;;
	  $M_POPF					     ;;AN003;;
;	$ENDIF						     ;;AN003;; Yes there was an error,
$MIF1:
	POP	DS					     ;;AN003;;
	POP	BP					     ;;AN003;;
	POP	SI					     ;;AN003;;
	POP	DX					     ;;AN003;;
	POP	BX					     ;;AN003;;
	POP	AX					     ;;AN003;;
							     ;;AN003;;	     abort everything
	RET						     ;;AN003;;

READ_DISK_PROC ENDP					     ;;AN003;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ENDIF						     ;;AN003;; END of include for DISK_PROC
;

SETSTDIO = FALSE					; M013
      IF      SETSTDIO					     ;;AN000;;	 Is the request to include the code for SETSTDIO
	SETSTDIO = FALSE				     ;;AN000;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - SETSTDIO Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: SETSTDIO
;;
;;	FUNCTION:
;;	INPUTS:
;;
;;	OUPUTS:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;AN001;
	SETSTDINON PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDINON PROC NEAR				     ;AN001;
ENDIF							     ;AN001;
	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDIN				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	OR	DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;
							     ;AN001;
	SETSTDINON ENDP 				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDINOFF PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDINOFF PROC NEAR				     ;AN001;
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDIN				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	AND	DH,NOT $M_CRIT_ERR_MASK 		     ;AN001; Turn off bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDINOFF ENDP				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDOUTON PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDOUTON PROC NEAR				     ;AN001;
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDOUT				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	OR	DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDOUTON ENDP				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDOUTOFF PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDOUTOFF PROC NEAR
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDOUT				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	AND	DH,NOT $M_CRIT_ERR_MASK 		     ;AN001; Turn off bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDOUTOFF ENDP				     ;AN001;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ENDIF						     ;;AN000;; END of include for SETSTDIO
; 
      IF      LOADmsg					     ;;AN000;;	 Is the request to include the code for SYSLOADMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF
	LOADmsg = FALSE 				     ;;AN000;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - LOADMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: SYSLOADMSG
;;
;;	FUNCTION:
;;	INPUTS:
;;
;;	OUPUTS:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSLOADMSG PROC FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSLOADMSG PROC NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
	PUSH	AX					     ;;AN000;
	PUSH	BX					     ;;AN000;
	PUSH	DX					     ;;AN000;
	PUSH	ES					     ;;AN000;
	PUSH	DI					     ;;AN000;
	XOR	CX,CX					     ;;AN000;  Reset to zero
	MOV	ES,CX					     ;;AN000;
	XOR	DI,DI					     ;;AN000;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_EXTENDED			     ;;AN000;; Where are the Extended errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_EXT_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_COMMAND,DI	     ;;AN000;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_PARSE			     ;;AN000;; Where are the Parse errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_PARSE_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_PARSE_COMMAND,DI	     ;;AN000;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_CRITICAL			     ;;AN000;; Where are the Critical errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_CRIT_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_CRIT_COMMAND,DI	     ;;AN000;;

	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN001;; 2FH Interface
	MOV	DL,DOS_GET_FILE 			     ;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
	INT	2FH					     ;;AN001;; Private interface
	MOV	WORD PTR $M_RT.$M_EXT_FILE+2,ES 	     ;;AN001;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_FILE,DI		     ;;AN001;;

IF	COMR						     ;;  ** Special case for RESIDENT COMMAND.COM
	IF2
	  IFNDEF  READ_DISK_INFO			     ;;AN003;;
	    Extrn   READ_DISK_PROC:Far			     ;;AN003;;
	  ENDIF 					     ;;AN003;;
	ENDIF						     ;;AN003;;
ELSE							     ;;
	IF	FARmsg					     ;;AN000;;
	  CALL	  FAR PTR $M_MSGSERV_1			     ;;AN000;; Get addressibilty to MSGSERV CLASS 1 (EXTENDED Errors)
	ELSE						     ;;AN000;;
	  CALL	  $M_MSGSERV_1				     ;;AN000;; Get addressibilty to MSGSERV CLASS 1 (EXTENDED Errors)
	ENDIF						     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_EXT_ERR_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_ERR_ADDRS,DI	     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_CRIT_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_CRIT_ADDRS,DI 	     ;;AN000;;
							     ;;
	IF	FARmsg					     ;;AN000;;
	  CALL	  FAR PTR $M_MSGSERV_2			     ;;AN000;; Get addressibilty to MSGSERV CLASS 2 (PARSE Errors)
	ELSE						     ;;AN000;;
	  CALL	  $M_MSGSERV_2				     ;;AN000;; Get addressibilty to MSGSERV CLASS 2 (PARSE Errors)
	ENDIF						     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_PARSE_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_PARSE_ADDRS,DI	     ;;AN000;;
ENDIF							     ;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN001;; 2FH Interface
	MOV	DL,DOS_GET_ADDR 			     ;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
	INT	2FH					     ;;AN001;; Private interface
	MOV	WORD PTR $M_RT.$M_DISK_PROC_ADDR+2,ES	     ;;AN001;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_DISK_PROC_ADDR,DI	     ;;AN001;;

;M016; M020
; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
;be safe.  Initialize $M_MSG_NUM and $M_DIVISOR also.
;
	mov	word ptr $M_RT.$M_CRLF,0a0dh		; Reinit CR-LF ;M016
	mov	byte ptr $M_RT.$M_BUF_TERM,'$'		; Reinit buffer end;M016
	mov	word ptr $M_RT.$M_MSG_NUM,$M_NULL	; M020
	mov	word ptr $M_RT.$M_DIVISOR,$M_BASE10	; M020

	$M_BUILD_PTRS %$M_NUM_CLS			     ;;AN000;; Build all utility classes
							     ;;AN000;;
	CALL	$M_GET_DBCS_VEC 			     ;;AN000;; Save the DBCS vector

IF	NOT	NOCHECKSTDIN				     ;;AN000;; IF EOF check is not to be suppressed
	CALL	$M_CHECKSTDIN				     ;;AN000;;	 Set EOF CHECK
ENDIF							     ;;AN000;;
							     ;;AN000;;
IF	NOT	NOCHECKSTDOUT				     ;;AN000;; IF Disk Full check is not to be suppressed
	CALL	$M_CHECKSTDOUT				     ;;AN000;;	 Set Disk Full CHECK
ENDIF							     ;;AN000;;
							     ;;AN000;;
IF	NOVERCHECKmsg					     ;;AN000;; IF version check is to be supressed
	CLC						     ;;AN000;;	 Make sure carry is clear
ELSE							     ;;AN000;; ELSE
	PUSH	CX					     ;;AN000;;
	CALL	$M_VERSION_CHECK			     ;;AN000;;	 Check Version
ENDIF							     ;;AN000;;
							     ;;        Error ?
;	$IF	NC					     ;;AN000;; No.
	JC $MIF20
IF	  NOT	  NOVERCHECKmsg 			     ;;AN000;;	IF version check was not supressed
	  POP	  CX					     ;;AN000;;	Reset stack
ENDIF							     ;;AN000;;
	  POP	  DI					     ;;AN000;;	Restore REGS
	  POP	  ES					     ;;AN000;;
	  POP	  DX					     ;;AN000;;
	  POP	  BX					     ;;AN000;;
	  POP	  AX					     ;;AN000;;
;	$ELSE						     ;;AN000;; Yes,
	JMP SHORT $MEN20
$MIF20:
IF	  NOVERCHECKmsg 				     ;;AN000;;	IF version check is to be supressed
	  ADD	  SP,10 				     ;;AN000;;
	  STC						     ;;AN000;;	Reset carry flag
ELSE							     ;;AN000;;	IF version check is to be supressed
	  ADD	  SP,12 				     ;;AN000;;
	  STC						     ;;AN000;;	Reset carry flag
ENDIF							     ;;AN000;;	IF version check is to be supressed
;	$ENDIF						     ;;AN000;;
$MEN20:
	RET						     ;;AN000;;
							     ;;
	SYSLOADMSG ENDP 				     ;;AN000;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PAGE
	SUBTTL	DOS - Message Retriever - $M_VERSION_CHECK Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_GET_DBCS_VEC
;;
;;  Function:	Get the DBCS vector and save it for later use
;;
;;  Inputs:	None
;;
;;  Outputs:	None
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_GET_DBCS_VEC PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	AX					     ;;AN000;; Save character to check
	PUSH	SI					     ;;AN000;;
	PUSH	DS					     ;;AN000;;
	MOV	AX,DOS_GET_DBCS_INFO			     ;;AN000;; DOS function to get DBSC environment
	INT	21H					     ;;AN000;; Get environment pointer
	PUSH	DS					     ;;AN000;; Get environment pointer
	POP	ES					     ;;AN000;; Get environment pointer
	POP	DS					     ;;AN000;; Get environment pointer
;	$IF	NC					     ;;AN000;;
	JC $MIF23
	  MOV	  WORD PTR $M_RT.$M_DBCS_VEC,SI 	     ;;AN000;; Save DBCS Vector
	  MOV	  WORD PTR $M_RT.$M_DBCS_VEC+2,ES	     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MIF23:
	POP	SI					     ;;AN000;;
	POP	AX					     ;;AN000;; Retrieve character to check
	RET						     ;;AN000;; Return
							     ;;
$M_GET_DBCS_VEC ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IF	NOCHECKSTDIN				     ;AN001; Are we suppose to include the code for Checking EOF ?
	ELSE						     ;AN001; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_CHECKSTDIN Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_CHECKSTDIN
;;
;;  Function:
;;
;;  Inputs:	None
;;
;;  Outputs:
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHECKSTDIN PROC NEAR 				     ;AN001;

	  MOV	  AX,DOS_IOCTL_GET_INFO 		     ;AN001; Get info using IOCTL
	  MOV	  BX,STDIN				     ;AN001;
	  XOR	  DX,DX 				     ;AN001;
	  INT	  21H					     ;AN001;

	  AND	  DH,1                                       ;clear top 7 bits
	  OR	  DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	  MOV	  AX,DOS_IOCTL_SET_INFO 		     ;AN001; Set info using IOCTL
	  INT	  21H					     ;AN001;

	  RET						     ;AN001;

$M_CHECKSTDIN ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;AN001; END of include for EOF Check
	IF	NOCHECKSTDOUT				     ;AN001; Are we suppose to include the code for Checking Disk Full?
	ELSE						     ;AN001; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_CHECKSTDOUT Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_CHECKSTDOUT
;;
;;  Function:
;;
;;  Inputs:	None
;;
;;  Outputs:
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHECKSTDOUT PROC NEAR				     ;AN001;

	  MOV	  AX,DOS_IOCTL_GET_INFO 		     ;AN001; Get info using IOCTL
	  MOV	  BX,STDOUT				     ;AN001;
	  XOR	  DX,DX 				     ;AN001;
	  INT	  21H					     ;AN001;

	  OR	  DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	  MOV	  AX,DOS_IOCTL_SET_INFO 		     ;AN001; Set info using IOCTL
	  INT	  21H					     ;AN001;

	  RET						     ;AN001;

$M_CHECKSTDOUT ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;AN001;  END of include for Disk Full Check
	IF	NOVERCHECKmsg				     ;;AN000;; Are we suppose to include the code for DOS version check?
	ELSE						     ;;AN000;; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_VERSION_CHECK Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_VERSION_CHECK
;;
;;  Function:	Determine if DOS version is within allowable limits
;;
;;  Inputs:	None
;;
;;  Outputs:	CARRY_FLAG = 1 if Incorrect DOS version
;;		Registers set for SYSDISPMSG
;;		CARRY_FLAG = 0 if Correct DOS version
;;
;;  Regs Changed: AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_VERSION_CHECK PROC NEAR				     ;;AN000;;
							     ;;
	  MOV	  AH,DOS_GET_VERSION			     ;;AN000;; Check that version matches VERSIONA.INC
	  INT	  21H					     ;;AN000;;
							     ;;
	  CMP	  AX,EXPECTED_VERSION			     ;;AN000;; IF DOS_MAJOR is correct
;	  $IF	  E					     ;;AN000;;
	  JNE $MIF25
	    CLC 					     ;;AN000;;	 Clear the carry flag
;	  $ELSE 					     ;;AN000;; ELSE
	  JMP SHORT $MEN25
$MIF25:
IF	    NOT     COMR				     ;;  ** Special case for RESIDENT COMMAND.COM
	    CMP     AX,LOWEST_4CH_VERSION		     ;;AN000;; Does this version support AH = 4CH
;	    $IF     B					     ;;AN000;; No,
	    JNB $MIF27
	      MOV     BX,NO_HANDLE			     ;;AN000;;	 No handle (version doesn't support)
;	    $ELSE					     ;;AN000;; Yes,
	    JMP SHORT $MEN27
$MIF27:
	      MOV     BX,STDERR 			     ;;AN000;;	 Standard Error
;	    $ENDIF					     ;;AN000;;
$MEN27:
ELSE
	    MOV     BX,NO_HANDLE			     ;;AN000;;	 No handle
ENDIF
	    MOV     AX,1				     ;;AN000;; Set message # 1
	    MOV     CX,NO_REPLACE			     ;;AN000;; No replacable parms
	    MOV     DL,NO_INPUT 			     ;;AN000;; No input
	    MOV     DH,UTILITY_MSG_CLASS		     ;;AN000;; Utility class message
	    STC 					     ;;AN000;; Set Carry Flag
;	  $ENDIF					     ;;AN000;;
$MEN25:
							     ;;
	  RET						     ;;AN000;; Return
							     ;;
$M_VERSION_CHECK ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include for DOS version check
      ENDIF						     ;;AN000;; END of include for SYSLOADMSG
; 
      IF      GETmsg					     ;;AN000;; Is the request to include the code for SYSGETMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF						     ;;AN000;;
	GETmsg	=      FALSE				     ;;AN000;; Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - GETMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSGETMSG
;;
;;  Function:	The GET service returns the segment, offset and size of the
;;		message text to the caller based on a message number.
;;		The GET function will not display the message thus assumes
;;		caller will handle replaceable parameters.
;;
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Call $M_GET_MSG_ADDRESS
;;		IF MSG_NUM exists THEN
;;		   Set DS:SI = MSG_TXT_PTR + 1
;;		   CARRY_FLAG = 0
;;		ELSE
;;		   CARRY_FLAG = 1
;;		ENDIF
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSGETMSG PROC	FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSGETMSG PROC	NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
;; Save registers needed later

	PUSH	AX					     ;;AN000;; Save changed regs
	PUSH	ES					     ;;AN000;;
	PUSH	DI					     ;;AN000;;
	PUSH	BP					     ;;AN000;;
							     ;;
IF	FARmsg						     ;;AN000;;
	CALL	FAR PTR $M_GET_MSG_ADDRESS		     ;;AN000;; Scan thru classes to find message
ELSE							     ;;AN000;;
	CALL	$M_GET_MSG_ADDRESS			     ;;AN000;; Scan thru classes to find message
ENDIF							     ;;AN000;; Return message in ES:DI
;	$IF	NC					     ;;AN000;; Message found?
	JC $MIF31
	  CMP	  DH,UTILITY_MSG_CLASS
	  CLC						     ;;AN000;;
;	  $IF	  NE
	  JE $MIF32
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	   Return message in DS:SI
;	  $ELSE
	  JMP SHORT $MEN32
$MIF32:
IF	    FARmsg					     ;;AN000;;	 Yes,
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	   Return message in DS:SI
ELSE							     ;;AN000;;
	    PUSH    CS					     ;;AN000;;	   Return message in DS:SI
	    POP     DS					     ;;AN000;;
ENDIF							     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN32:
	  MOV	  SI,DI 				     ;;AN000;;	   Return message in DS:SI
;	$ENDIF						     ;;AN000;;
$MIF31:
							     ;;
	POP	BP					     ;;AN000;; Restore changed regs
	POP	DI					     ;;AN000;;
	POP	ES					     ;;AN000;;
	POP	AX					     ;;AN000;;
							     ;;
	RET						     ;;AN000;;	  Return
							     ;;
	SYSGETMSG ENDP					     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IF	$M_SUBS 				     ;;AN000;; Include the common subroutines if they haven't yet
	  $M_SUBS = FALSE				     ;;AN000;; No, then include and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_MSG_ADDRESS
;;
;;	FUNCTION:  To scan thru classes to return pointer to the message header
;;	INPUTS:    Access to $M_RES_ADDRESSES
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to the specified message
;;	REGS CHANGED: ES,DI,CX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	  FARmsg					     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC FAR			     ;;AN000;;
ELSE							     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC NEAR			     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
	  PUSH	  SI					     ;;AN000;;
	  PUSH	  BX					     ;;AN000;;
	  XOR	  SI,SI 				     ;;AN000;; Use SI as an index
	  XOR	  CX,CX 				     ;;AN000;; Use CX as an size
;	  $DO						     ;;AN000;;
$MDO36:
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;; Were utility messages requested?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF37
	      IF      FARmsg				     ;;AN000;;
		LES	DI,DWORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;  Get address of class
		MOV	BX,ES				     ;;AN000;
	      ELSE					     ;;AN000;;
		MOV	DI,WORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;	 Get address of class
		MOV	BX,DI				     ;;AN000;
	      ENDIF					     ;;AN000;;
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN37
$MIF37:
	      TEST    DH,PARSE_ERR_CLASS		     ;;AN000;;	 Were parse errors requested?
;	      $IF     NE				     ;;AN000;;	 Yes,
	      JE $MIF39
		LES	DI,DWORD PTR $M_RT.$M_PARSE_COMMAND[SI] ;;AN000;;   Get address of class
		MOV	BX,ES				     ;;AN000;
;	      $ELSE					     ;;AN000;;	 No, extended errors were specified
	      JMP SHORT $MEN39
$MIF39:
		CMP	AX,$M_CRIT_LO			     ;;AN000;;	   Is this a critical error?
;		$IF	AE,AND				     ;;AN000;;
		JNAE $MIF41
		CMP	AX,$M_CRIT_HI			     ;;AN000;;
;		$IF	BE				     ;;AN000;;	    Yes,
		JNBE $MIF41
		  LES	  DI,DWORD PTR $M_RT.$M_CRIT_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ELSE					     ;;AN000;;
		JMP SHORT $MEN41
$MIF41:
		  LES	  DI,DWORD PTR $M_RT.$M_EXT_ERR_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ENDIF					     ;;AN000;;
$MEN41:
;	      $ENDIF					     ;;AN000;;
$MEN39:
;	    $ENDIF					     ;;AN000;;
$MEN37:
							     ;;
	    CMP     BX,$M_TERMINATING_FLAG		     ;;AN000;; Are we finished all classes?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF46
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;;	  Was it a UTILITY class?
;	      $IF     E 				     ;;AN000;;	  Yes,
	      JNE $MIF47
		STC					     ;;AN000;;	    Set the carry flag
;	      $ELSE					     ;;AN000;;	  No,
	      JMP SHORT $MEN47
$MIF47:
		MOV	$M_RT.$M_MSG_NUM,AX		     ;;AN000;;	    Save message number
		MOV	AX,$M_SPECIAL_MSG_NUM		     ;;AN000;;	    Set special message number
		MOV	BP,$M_ONE_REPLACE		     ;;AN000;;	    Set one replace in message
		XOR	SI,SI				     ;;AN000;;	    Reset the SI index to start again
		CLC					     ;;AN000;;
;	      $ENDIF					     ;;AN000;; No,
$MEN47:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN46
$MIF46:
	      CMP     BX,$M_CLASS_NOT_EXIST		     ;;AN000;;	 Does this class exist?
;	      $IF     NE				     ;;AN001;;	 Yes,
	      JE $MIF51
		CALL	$M_FIND_SPECIFIED_MSG		     ;;AN000;;	   Try to find the message
;	      $ENDIF					     ;;AN000;;
$MIF51:
	      ADD     SI,$M_ADDR_SZ_FAR 		     ;;AN000;;	     Get next class
	      CLC					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN46:
;	  $LEAVE  C					     ;;AN000;;
	  JC $MEN36
	    OR	    CX,CX				     ;;AN000;;	   Was the message found?
;	  $ENDDO  NZ,LONG				     ;;AN000;;
	  JNZ $MXL2
	  JMP $MDO36
$MXL2:
$MEN36:

	  PUSHF 					     ;;AN006;; Save the flag state
	  CMP	  DH,EXT_ERR_CLASS			     ;;AN006;; Was an extended error requested?
;	  $IF	  E					     ;;AN006;; Yes,
	  JNE $MIF56
	    PUSH    DX					     ;;AN006;;	Save all needed registers
	    PUSH    BP					     ;;AN006;;
	    PUSH    CX					     ;;AN006;;
	    PUSH    ES					     ;;AN006;;
	    PUSH    DI					     ;;AN006;;
	    PUSH    AX					     ;;AN006;;

	    MOV     AX,IFSFUNC_INSTALL_CHECK		     ;;AN006;;	Check if IFSFUNC is installed
	    INT     2FH 				     ;;AN006;;
	    CMP     AL,IFSFUNC_INSTALLED		     ;;AN006;;	Is it installed?
	    POP     AX					     ;;AN006;;	Restore msg number
;	    $IF     E					     ;;AN006;;	 Yes,
	    JNE $MIF57
	      MOV     BX,AX				     ;;AN006;;	  BX is the extended error number
	      MOV     AX,IFS_GET_ERR_TEXT		     ;;AN006;;	  AX is the muliplex number
	      INT     2FH				     ;;AN006;;	  Call IFSFUNC
;	    $ELSE					     ;;AN006;;	 No,
	    JMP SHORT $MEN57
$MIF57:
	      STC					     ;;AN006;;	  Carry conditon
;	    $ENDIF					     ;;AN006;;
$MEN57:

;	    $IF     C					     ;;AN006;;	Was there an update?
	    JNC $MIF60
	      POP     DI				     ;;AN006;;	No,
	      POP     ES				     ;;AN006;;	 Restore old pointer
	      POP     CX				     ;;AN006;;
;	    $ELSE					     ;;AN006;;	Yes
	    JMP SHORT $MEN60
$MIF60:
	      ADD     SP,6				     ;;AN006;;	 Throw away old pointer
	      CALL    $M_SET_LEN_IN_CX			     ;;AN006;;	 Get the length of the ASCIIZ string
;	    $ENDIF					     ;;AN006;;
$MEN60:
	    POP     BP					     ;;AN006;;	Restore other Regs
	    POP     DX					     ;;AN006;;
;	  $ENDIF					     ;;AN006;;
$MIF56:
	  $M_POPF					     ;;AN006;; Restore the flag state

	  POP	  BX					     ;;AN000;;
	  POP	  SI					     ;;AN000;;
	  RET						     ;;AN000;; Return ES:DI pointing to the message
							     ;;
$M_GET_MSG_ADDRESS ENDP 				     ;;
							     ;;
$M_SET_LEN_IN_CX PROC NEAR				     ;;
							     ;;
	  PUSH	  DI					     ;;AN006;; Save position
	  PUSH	  AX					     ;;AN006;;
	  MOV	  CX,-1 				     ;;AN006;; Set CX for decrements
	  XOR	  AL,AL 				     ;;AN006;; Prepare compare register
	  REPNE   SCASB 				     ;;AN006;; Scan for zero
	  NOT	  CX					     ;;AN006;; Change decrement into number
	  DEC	  CX					     ;;AN006;; Don't include the zero
	  POP	  AX					     ;;AN006;;
	  POP	  DI					     ;;AN006;; Restore position
	  RET						     ;;AN006;;
							     ;;
$M_SET_LEN_IN_CX ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FIND_SPECIFIED_MSG
;;
;;	FUNCTION:  To scan thru message headers until message is found
;;	INPUTS:    ES:DI points to beginning of msg headers
;;		   CX contains the number of messages in class
;;		   DH contains the message class
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to header of specified message
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FIND_SPECIFIED_MSG PROC NEAR 			     ;;AN000;;
							     ;;
	  CMP	  BX,1					     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  E,AND 				     ;;AN004;;	Yes,
	  JNE $MIF64
	  CMP	  WORD PTR $M_RT.$M_DISK_PROC_ADDR,-1	     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  NE					     ;;AN004;;	Yes,
	  JE $MIF64
	    CMP     AX,$M_SPECIAL_MSG_NUM		     ;;AN004;; Are we displaying a default Ext Err?
;	    $IF     E					     ;;AN004;;	. . . and . . .
	    JNE $MIF65
	      PUSH    AX				     ;;AN004;;	 Reset the special message number
	      MOV     AX,$M_RT.$M_MSG_NUM		     ;;AN004;;	 Get the old message number
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
	      POP     AX				     ;;AN004;;	 Reset the special message number
;	    $ELSE					     ;;AN004;;	 Get the old message number
	    JMP SHORT $MEN65
$MIF65:
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
;	    $ENDIF					     ;;AN004;;	 Get the old message number
$MEN65:
;	  $ELSE 					     ;;AN004;;
	  JMP SHORT $MEN64
$MIF64:
	    XOR     CX,CX				     ;;AN002;;	 CX = 0 will allow us to
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	    $IF     NE					     ;;AN001;;
	    JE $MIF69
	      MOV     CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
;	    $ELSE					     ;;AN001;;
	    JMP SHORT $MEN69
$MIF69:
IF	      FARmsg					     ;;AN001;;
	      CMP     BYTE PTR ES:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ELSE
	      CMP     BYTE PTR CS:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ENDIF
;	      $IF     E 				     ;;AN002;;	pointer (hopefully)
	      JNE $MIF71
IF		FARmsg					     ;;AN001;;
		MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
ELSE
		MOV	CL,BYTE PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
ENDIF
;	      $ENDIF					     ;;AN002;;	  go on to the next class
$MIF71:
;	    $ENDIF					     ;;AN001;;
$MEN69:
	    ADD     DI,$M_CLASS_ID_SZ			     ;;AN000;;	   Point past the class header
	    STC 					     ;;AN004;;	 Flag that we haven't found anything yet
;	  $ENDIF					     ;;AN004;;
$MEN64:

;	  $IF	  C					     ;;AN004;; Have we found anything yet?
	  JNC $MIF75
	    CLC 					     ;;AN004;; No, reset carry
;	    $SEARCH					     ;;AN000;;
$MDO76:
	      OR      CX,CX				     ;;AN000;;	  Do we have any to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN76
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	      $IF     NE				     ;;AN001;;
	      JE $MIF78
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN001;; Is this the message requested?
;	      $ELSE					     ;;AN001;;
	      JMP SHORT $MEN78
$MIF78:
IF		FARmsg					     ;;AN001;;
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ELSE
		CMP	AX,WORD PTR CS:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ENDIF
;	      $ENDIF
$MEN78:
;	    $EXITIF E					     ;;AN000;;
	    JNE $MIF76
;	    $ORELSE					     ;;AN000;
	    JMP SHORT $MSR76
$MIF76:
	      DEC     CX				     ;;AN000;;	  No, well do we have more to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN76
	      ADD     DI,$M_ID_SZ			     ;;AN000;;	     Yes, skip past msg header
;	    $ENDLOOP					     ;;AN000;;
	    JMP SHORT $MDO76
$MEN76:
	      STC					     ;;AN000;;
;	    $ENDSRCH					     ;;AN000;;	     Check next message
$MSR76:
;	    $IF     NC					     ;;AN000;;	 Did we find the message?
	    JC $MIF86
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;	 Yes, is it a utility message?
	      CLC					     ;;AN001;;
;	      $IF     E 				     ;;AN001;;
	      JNE $MIF87
IF		FARmsg					     ;;AN001;;
ELSE							     ;;AN000;;
		PUSH	CS				     ;;AN000;;
		POP	ES				     ;;AN000;;	 Return ES:DI pointing to the message
ENDIF
;	      $ENDIF					     ;;AN001;;
$MIF87:
	      ADD     DI,WORD PTR ES:[DI].$M_TXT_PTR	     ;;AN000;; Prepare ES:DI pointing to the message
;	    $ENDIF					     ;;AN004;;
$MIF86:
;	  $ENDIF					     ;;AN004;;
$MIF75:
							     ;; 	  Yes, great we can return with CX > 0

;	  $IF	  NC					     ;;AN000;;	 Did we find the message?
	  JC $MIF91
	    XOR     CH,CH				     ;;AN000;;
	    MOV     CL,BYTE PTR ES:[DI] 		     ;;AN000;;	 Move size into CX
	    INC     DI					     ;;AN000;;	 Increment past length
;	  $ENDIF					     ;;AN004;;
$MIF91:

	  MOV	  $M_RT.$M_SIZE,$M_NULL 		     ;;AN004;; Reset variable
	  RET						     ;;AN000;; Return
							     ;;
$M_FIND_SPECIFIED_MSG ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of common subroutines
      ENDIF						     ;;AN000;; END of include of SYSGETMSG
; 
      IF      DISPLAYmsg				     ;;AN000;; Is the request to include the code for SYSGETMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF						     ;;AN000;;
	DISPLAYmsg =  FALSE				     ;;AN000;; Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - DISPMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSDISPMSG
;;
;;  Function:	The DISPLAY service will output a defined message to a handle
;;		requested by the caller. It also provides function to display
;;		messages when handles are not applicable (ie. DOS function calls
;;		00h to 0Ah) Replaceable parameters are allowed and are
;;		defined previous to entry.
;;
;;		It is assumes that a PRELOAD function has already determined
;;		the addressibilty internally to the message retriever services.
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Save registers needed later
;;		Get address of the message requested
;;		IF Message number exists THEN
;;		  IF replacable parameters were specified THEN
;;		     Display message with replacable parms
;;		  ELSE
;;		     Display string without replacable parms
;;		  ENDIF
;;		  IF character input was requested THEN
;;		     Wait for character input
;;		  ENDIF
;;		  Clear CARRY FLAG
;;		ELSE
;;		   Set CARRY FLAG
;;		ENDIF
;;		Return
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSDISPMSG PROC FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSDISPMSG PROC NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
;; Save registers and values needed later

	PUSH	AX					     ;;AN000;; Save changed REGs
	PUSH	BX					     ;;AN000;;
	PUSH	CX					     ;;AN000;;
	PUSH	BP					     ;;AN000;;
	PUSH	DI					     ;;AN000;; Save pointer to input buffer (offset)
	PUSH	ES					     ;;AN000;; Save pointer to input buffer (segment)
	PUSH	DX					     ;;AN000;; Save Input/Class request

	MOV	BP,CX					     ;;AN000;; Use BP to hold replace count
	MOV	WORD PTR $M_RT.$M_HANDLE,BX		     ;;AN000;; Save handle
	MOV	BYTE PTR $M_RT.$M_CLASS,DH		     ;;AN004;; Save class

;; Get address of the message requested

IF	FARmsg						     ;;AN000;;
	CALL	FAR PTR $M_GET_MSG_ADDRESS		     ;;AN000;; Scan thru classes to find message
ELSE							     ;;AN000;;
	CALL	$M_GET_MSG_ADDRESS			     ;;AN000;; Scan thru classes to find message
ENDIF							     ;;AN000;;
	OR	CX,CX					     ;;AN000;; Was message found?
;	$IF	NZ					     ;;AN000;;	 YES, Message address in ES:DI
	JZ $MIF93

;; Test if replacable parameters were specified

	  OR	  BP,BP 				     ;;AN000;;	 Were replacable parameters requested
;	  $IF	  Z					     ;;AN000;;
	  JNZ $MIF94

;; Display string without replacable parms

	    CALL    $M_DISPLAY_STRING			     ;;AN000;; No, great . . . Display message
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN94
$MIF94:
IF	    $M_REPLACE					     ;;AN000;;

;; Display message with replacable parms

	    CALL    $M_DISPLAY_MESSAGE			     ;;AN000;;	 Display the message with substitutions
ENDIF							     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN94:
;	  $IF	  NC
	  JC $MIF97

	    POP     DX					     ;;AN000;; Get Input/Class request

	    CALL    $M_ADD_CRLF 			     ;;AN004;; Check if we need to add the CR LF chars.

	    POP     ES					     ;;AN000;; Get location of input buffer (if specified)
	    POP     DI					     ;;AN000;;

;; Test if character input was requested

IF	    INPUTmsg					     ;;AN000;;
	    OR	    DL,DL				     ;;AN000;; Was Wait-For-Input requested?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF98
	      CALL    $M_WAIT_FOR_INPUT 		     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF98:
ENDIF							     ;;AN000;;
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN97
$MIF97:
	    ADD     SP,6				     ;;AN000;;
	    STC 					     ;;AN000;; Reset carry flag
;	  $ENDIF					     ;;AN000;;
$MEN97:
;	$ELSE						     ;;AN000;; No,
	JMP SHORT $MEN93
$MIF93:
	  POP	  ES					     ;;AN000;;	 Get pointer to input buffer (segment)
	  POP	  DI					     ;;AN000;;	 Get base pointer to first sublist (offset)
	  POP	  DX					     ;;AN000;;	 Get base pointer to first sublist (segment)
	  STC						     ;;AN000;;	 Set carry flag
;	$ENDIF						     ;;AN000;;
$MEN93:
							     ;;
;	$IF	NC					     ;;AN000;; Was there an error?
	JC $MIF104
	  POP	  BP					     ;;AN000;; No,
	  POP	  CX					     ;;AN000;;
	  POP	  BX					     ;;AN000;;
IF	  INPUTmsg					     ;;AN000;;
	  ADD	  SP,2					     ;;AN000;;
ELSE							     ;AN000;
	  POP	  AX					     ;;AN000;;
ENDIF							     ;;AN000;;
;	$ELSE						     ;;AN000;;	Yes,
	JMP SHORT $MEN104
$MIF104:
	  ADD	  SP,8					     ;;AN000;;	   Eliminate from stack
	  STC						     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MEN104:
							     ;;
	RET						     ;;AN000;; Return
							     ;;
	SYSDISPMSG ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;;
;;	PROC NAME: $M_DISPLAY_STRING
;;
;;	FUNCTION:  Will display or write string
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the length of string to write (if applicable)
;;	OUTPUTS:   None
;;	REGS Revised: None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_STRING PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	AX					     ;;AN000;;
	PUSH	BX					     ;;AN000;;
	PUSH	DX					     ;;AN000;;
							     ;;
	MOV	BX,$M_RT.$M_HANDLE			     ;;AN000;; Retrieve handle
							     ;;
IF	COMR						     ;;  ** Special case for RESIDENT COMMAND.COM
	CALL	$M_DISPLAY_$_STRING			     ;;AN000;; No, display $ terminated string
ELSE
	CMP	BX,$M_NO_HANDLE 			     ;;AN000;; Was there a handle specified?
;	$IF	E					     ;;AN000;;
	JNE $MIF107
	  CALL	  $M_DISPLAY_$_STRING			     ;;AN000;; No, display $ terminated string
;	$ELSE						     ;;AN000;;
	JMP SHORT $MEN107
$MIF107:
	  CALL	  $M_DISPLAY_H_STRING			     ;;AN000;; Yes, display string to handle
;	$ENDIF						     ;;AN000;;
$MEN107:
							     ;AN001;
;	$IF	C					     ;;AN000;;	Was there an error?
	JNC $MIF110
	  MOV	  AH,DOS_GET_EXT_ERROR			     ;;AN000;;	Yes,
	  MOV	  BX,DOS_GET_EXT_ERROR_BX		     ;;AN000;;	  Get extended error
	  INT	  21H					     ;;AN000;;
	  XOR	  AH,AH 				     ;;AN000;;	  Clear AH
	  ADD	  SP,6					     ;;AN000;;	  Clean up stack
	  STC						     ;;AN000;;	  Flag that there was an error
;	$ELSE						     ;;AN000;;	No,
	JMP SHORT $MEN110
$MIF110:
	  CMP	  BX,$M_NO_HANDLE			     ;;AN000;; Was there a handle specified?
;	  $IF	  NE					     ;;AN000;;
	  JE $MIF112
	    CMP     AX,CX				     ;AN001;	 Was it ALL written?
;	    $IF     NE					     ;AN001;	 No,
	    JE $MIF113
	      CALL    $M_GET_EXT_ERR_39 		     ;AN001;	   Set Extended error
	      ADD     SP,6				     ;AN001;	   Clean up stack
	      STC					     ;AN001;	   Flag that there was an error
;	    $ENDIF					     ;AN001;
$MIF113:
;	  $ENDIF					     ;AN001;
$MIF112:
;	$ENDIF						     ;;AN000;;
$MEN110:
ENDIF
;	$IF	NC					     ;;AN000;;	Was there ANY error?
	JC $MIF117
	  POP	  DX					     ;;AN000;;	Restore regs
	  POP	  BX					     ;;AN000;;
	  POP	  AX					     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MIF117:
	RET						     ;;AN000;; Return
							     ;;
$M_DISPLAY_STRING ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_$_STRING
;;
;;	FUNCTION:  Will display a $ terminated string
;;	INPUTS:    ES:DI points to beginning of message text (not the length)
;;	OUPUTS:    None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_$_STRING PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	DS					     ;;AN000;;
	PUSH	ES					     ;;AN000;;
	POP	DS					     ;;AN000;; Set DS to segment of message text
IF	NOT	COMR
	CMP	CX,$M_SINGLE_CHAR			     ;;AN000;; Is this a single character?
;	$IF	E					     ;;AN000;; Yes,
	JNE $MIF119
	  MOV	  AH,DOS_DISP_CHAR			     ;;AN000;;	 DOS Function to display CHARACTER
	  MOV	  DL,BYTE PTR ES:[DI]			     ;;AN000;;	 Get the character
	  INT	  21H					     ;;AN000;;	 Write character
	  POP	  DS					     ;;AN000;; Set DS to segment of message text
	  MOV	  AL,DL 				     ;;AN000;;	 Get the character in AL
	  CALL	  $M_IS_IT_DBCS 			     ;;AN000;;	 Is this the first byte of a DB character
	  PUSH	  DS					     ;;AN000;;
	  PUSH	  ES					     ;;AN000;;
	  POP	  DS					     ;;AN000;; Set DS to segment of message text
;	  $IF	  C					     ;;AN000;;	 Yes,
	  JNC $MIF120
	    MOV     DL,BYTE PTR ES:[DI]+1		     ;;AN000;; Get the next character
	    INT     21H 				     ;;AN000;;	 Write character
	    CLC 					     ;;AN000;;	 Clear the DBCS indicator
;	  $ENDIF					     ;;AN000;;
$MIF120:
;	$ELSE						     ;;AN000;; No,
	JMP SHORT $MEN119
$MIF119:
ENDIF
	  MOV	  AH,DOS_DISP_CHAR			     ;;AN000;;	 DOS Function to display CHARACTER
;	  $DO						     ;;AN002;; No,
$MDO123:
	    OR	    CX,CX				     ;;AN002;;	 Are there any left to display?
;	  $LEAVE  Z					     ;;AN002;;	 Yes,
	  JZ $MEN123
	    MOV     DL,BYTE PTR ES:[DI] 		     ;;AN002;;	   Get the character
	    INT     21H 				     ;;AN002;;	   Display the character
	    INC     DI					     ;;AN002;;	   Set pointer to next character
	    DEC     CX					     ;;AN002;;	   Count this character
;	  $ENDDO  Z					     ;;AN002;; No,
	  JNZ $MDO123
$MEN123:
IF	  NOT	  COMR
;	$ENDIF						     ;;AN000;;
$MEN119:
ENDIF
	CLC						     ;;AN000;;	 Char functions used don't return carry as error
	POP	DS					     ;;AN000;;
	RET						     ;;AN000;;
							     ;;
$M_DISPLAY_$_STRING ENDP				     ;;AN000;;
							     ;;
IF	NOT	COMR


;
;Scan_ctrlZ : This routine looks through the string to be printed and 
;truncates it at the Ctrl-Z if any present.
;
;	ENTRY:	ds:dx = String to be displayed
;		cx = number of chars to be displayed
;
;	EXIT:	cx = number of chars to be displayed
;

Scan_CtrlZ	proc	near

	push	di
	push	ax
	push	es
	push	bx

	mov	di,dx
	push	ds
	pop	es   			;es:di points at string

	mov	bx,cx			;save current count

	mov	al,1ah	
	cld
	repne	scasb			;find first Ctrl-Z
	jnz	noCtrlZ		;no CtrlZ found in string

	sub	bx,cx
	dec	bx			;bx = new count to display
					
noCtrlZ:
	mov	cx,bx			;cx = actual display count

	pop	bx
	pop	es
	pop	ax
	pop	di

	ret

Scan_CtrlZ	endp



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_H_STRING
;;
;;	FUNCTION:  Will display a string to a specified handle
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the number of bytes to write
;;		   BX contains the handle to write to
;;	OUPUTS:    None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_H_STRING PROC NEAR				     ;;AN000;;
							     ;;
	XOR	AX,AX					     ;;AN002;; Set number of bytes written to 0
	OR	CX,CX					     ;;AN002;; For performance, don't write if not necessary
;	$IF	NZ					     ;;AN002;; Any chars to write?
	JZ $MIF127
	  PUSH	  DS					     ;;AN000;; Yes,
	  PUSH	  ES					     ;;AN000;;
	  POP	  DS					     ;;AN000;;	 Set DS to segment of message text
	  MOV	  AH,DOS_WRITE_HANDLE			     ;;AN000;;	 DOS function to write to a handle
	  MOV	  DX,DI 				     ;;AN000;;	 Pointer to data to write
	  CMP	  CX,$M_SINGLE_CHAR			     ;;AN000;;	 Is this a single character?
;	  $IF	  E					     ;;AN000;;	 Yes,
	  JNE $MIF128
	    INT     21H 				     ;;AN000;;	   Write character
	    POP     DS					     ;;AN000;;	     Set DS to segment of message text
	    PUSH    AX					     ;;AN000;;
	    MOV     AL,BYTE PTR ES:[DI] 		     ;;AN000;;	     Get the character
	    CALL    $M_IS_IT_DBCS			     ;;AN000;;	     Is this the first byte of a DB character
	    POP     AX					     ;;AN000;;	     Set DS to segment of message text
	    PUSH    DS					     ;;AN000;;
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	     Set DS to segment of message text
;	    $IF     C					     ;;AN000;;	     Yes,
	    JNC $MIF129
	      CLC					     ;;AN000;;	      Clear the DBCS indicator
	      MOV     AH,DOS_WRITE_HANDLE		     ;;AN000;;	      DOS function to write to a handle
	      INC     DX				     ;;AN000;;	      Point to next character
	      INT     21H				     ;;AN000;;	      Write character
;	    $ENDIF					     ;;AN000;;
$MIF129:
;SR;
; If the single char happened to be a Ctrl-Z, the dos write would return
;0 chars written making the caller think there was an error writing. To 
;avoid this, we check if the single char was a Ctrl-Z and if so, return that
;the char was written, thus fooling the caller.
;
	pushf				;save flags
	cmp	byte ptr es:[di],1ah		;is char a Ctrl-Z?
	jnz	@f		;no, continue

	mov	ax,cx			;yes, fake as if it was written
@@:
	$M_Popf				;restore flags

;	  $ELSE 					     ;;AN000;;	 No,
	  JMP SHORT $MEN128
$MIF128:
;SR;
; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
;
	push	bp			; M007
	push	cx
	call	scan_ctrlZ		;cx = count without Ctrl-Z
	mov	bp,cx			;store no ^Z count in bp ;M007
	pop	cx			;get old count back ;M007
	
	    INT     21H 				     ;;AN000;;	   Write String at DS:SI to handle
	jnc	chk_count		;no error, adjust return count

	jmp	short m_cnt_ok		;error, return with carry set;M007
;M007
;	If we are writing to con and there is a Ctrl-Z in the string, the
;return count will be much less and if this returns to the caller we can get
;spurious error messages. We check here if the count returned is same as
;original count or same as the count if we stop at Ctrl-Z. In the second
;case, we fake it as if all bytes have been written. If the return count
;does not match either count, then we had some other disk error (such as
;insufficient disk space) and we pass it through
;
chk_count:
	cmp	cx,ax			;have all bytes been written?;M007
	je	m_cnt_ok		;there was an error writing ;M007
	cmp	bp,ax			;count = Ctrl-Z count? ;M007
	clc				;no error either way ;M007
	jne	m_cnt_ok		;no, pass it through ;M007
	mov	ax,cx			;return old count ;M007
m_cnt_ok:				; M007
	pop	bp			; M007

;	  $ENDIF					     ;;AN000;;
$MEN128:
	  POP	  DS					     ;;AN000;;
;	$ENDIF						     ;;AN002;;
$MIF127:
							     ;;
	RET						     ;;AN000;;
							     ;;
$M_DISPLAY_H_STRING ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_EXT_ERR_39
;;
;;	FUNCTION:  Will set registers for extended error #39
;;	INPUTS:    None
;;	OUPUTS:    AX,BX,CX set
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_GET_EXT_ERR_39 PROC NEAR				     ;AN001;
							     ;;
	MOV	AX,EXT_ERR_39				     ;AN001; Set AX=39
	MOV	BX,(ERROR_CLASS_39 SHR 8) + ACTION_39	     ;AN001; Set BH=1 BL=4
	MOV	CH,LOCUS_39				     ;AN001; Set CH=1
							     ;AN001;
	RET						     ;AN001;
							     ;;
$M_GET_EXT_ERR_39 ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIF
;;
;;	PROC NAME: $M_ADD_CRLF
;;
;;	FUNCTION:  Will decide whether to display a CRLF
;;	INPUTS:    DX contains the Input/Class requested
;;	OUTPUTS:   None
;;	REGS Revised: CX,ES,DI
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_ADD_CRLF PROC NEAR					     ;;AN004;;
							     ;;
	CMP	DH,UTILITY_MSG_CLASS			     ;;AN004;; Is it a utility message?
;	$IF	NE					     ;;AN004;; No,
	JE $MIF134
	  TEST	  DH,$M_NO_CRLF_MASK			     ;;AN004;;	 Are we to supress the CR LF?
;	  $IF	  Z					     ;;AN004;;	 No,
	  JNZ $MIF135
	    PUSH    DS					     ;;AN004;;
	    POP     ES					     ;;AN004;;	  Set ES to data segment
	    LEA     DI,$M_RT.$M_CRLF			     ;;AN004;;	  Point at CRLF message
	    MOV     CX,$M_CRLF_SIZE			     ;;AN004;;	  Set the message size
	    CALL    $M_DISPLAY_STRING			     ;;AN004;;	  Display the CRLF
;	  $ENDIF					     ;;AN004;;
$MIF135:
;	$ENDIF						     ;;AN004;;
$MIF134:
	RET						     ;;AN004;; Return
							     ;;
$M_ADD_CRLF ENDP					     ;;AN004;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_IS_IT_DBCS
;;
;;	FUNCTION:  Will decide whether character is Single or Double Byte
;;	INPUTS:    AL contains the byte to be checked
;;	OUPUTS:    Carry flag = 0 if byte is NOT in DBCS range
;;		   Carry flag = 1 if byte IS in DBCS range
;;	REGS USED: All restored
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_IS_IT_DBCS PROC NEAR 				     ;;AN000;;
							     ;;
	PUSH	ES					     ;;AN000;; Save Extra segment register
	PUSH	DI					     ;;AN000;; Save SI register
							     ;;
	LES	DI,$M_RT.$M_DBCS_VEC			     ;;AN000;;
	OR	DI,DI					     ;;AN000;; Was the DBCS vector set?
;	$IF	NZ					     ;;AN000;;
	JZ $MIF138
;	  $DO						     ;;AN000;;
$MDO139:
	    CMP     WORD PTR ES:[DI],$M_DBCS_TERM	     ;;AN000;; Is this the terminating flag?
	    CLC 					     ;;AN000;;
;	  $LEAVE  E					     ;;AN000;;
	  JE $MEN139
							     ;;        No,
	    CMP     AL,BYTE PTR ES:[DI] 		     ;;AN000;;	  Does the character fall in the DBCS range?
;	    $IF     AE,AND				     ;;AN000;;
	    JNAE $MIF141
	    CMP     AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	  Does the character fall in the DBCS range?
;	    $IF     BE					     ;;AN000;;
	    JNBE $MIF141
	      STC					     ;;AN000;;	  Yes,
;	    $ENDIF					     ;;AN000;;	     Set carry flag
$MIF141:
	    INC     DI					     ;;AN000;;	  No,
	    INC     DI					     ;;AN000;;	     Go to next vector
;	  $ENDDO					     ;;AN000;;
	  JMP SHORT $MDO139
$MEN139:
;	$ENDIF						     ;;AN000;;
$MIF138:

	POP	DI					     ;;AN000;;
	POP	ES					     ;;AN000;; Restore SI register
	RET						     ;;AN000;; Return
							     ;;
$M_IS_IT_DBCS ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CONVERT2ASC
;;
;;	FUNCTION: Convert a binary number to a ASCII string
;;	INPUTS: DX:AX contains the number to be converted
;;		$M_RT_DIVISOR contains the divisor
;;	OUPUTS: CX contains the number of characters
;;		Top of stack  --> Last character
;;				     . . .
;;		Bot of stack  --> First character
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CONVERT2ASC PROC NEAR				     ;;AN000;;
							     ;;
	POP	[$M_RT.$M_RETURN_ADDR]			     ;;AN000;; Save Return Address
	XOR	BX,BX					     ;;AN000;; Use BP as a swapping register
							     ;;
	XCHG	BX,AX					     ;;AN000;; Initialize - Low Word in BP
	XCHG	AX,DX					     ;;AN000;;		  - High Word in AX
;	$DO						     ;;AN000;; DO UNTIL Low Word becomes zero
$MDO145:
	  DIV	  $M_RT.$M_DIVISOR			     ;;AN000;; Divide High Word by divisor
	  XCHG	  BX,AX 				     ;;AN000;; Setup to divide Low Word using remainder
							     ;; 	and save reduced High Word in BP
	  DIV	  $M_RT.$M_DIVISOR			     ;;AN000;; Divide Low Word by divisor
	  CMP	  DX,9					     ;;AN000;;	Make a digit of the remainder
;	  $IF	  A					     ;;AN000;;	IF 10 to 15,
	  JNA $MIF146
	    ADD     DL,55				     ;;AN000;;	   Make A to F ASCII
;	  $ELSE 					     ;;AN000;;	IF 0 to 9,
	  JMP SHORT $MEN146
$MIF146:
	    ADD     DL,'0'				     ;;AN000;;	   Make 0 to 9 ASCII
;	  $ENDIF					     ;;AN000;;
$MEN146:
	  PUSH	  DX					     ;;AN000;; Save the digit on the stack
	  INC	  CX					     ;;AN000;; Count that digit
	  OR	  AX,AX 				     ;;AN000;; Are we done?
;	$LEAVE	Z,AND					     ;;AN000;;
	JNZ $MLL149
	  OR	  BX,BX 				     ;;AN000;; AX and BX must be ZERO!!
;	$LEAVE	Z					     ;;AN000;; No,
	JZ $MEN145
$MLL149:
IF	  NOT	  COMR
	  CMP	  CX,$M_FIRST_THOU			     ;;AN000;; Are we at the first thousands mark
;	  $IF	  E					     ;;AN000;; Yes,
	  JNE $MIF150
	    CMP     $M_SL.$M_S_PAD,$M_COMMA		     ;;AN000;; Is the pad character a comma?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF151
	      PUSH    WORD PTR $M_RT.$M_THOU_SEPARA	     ;;AN000;; Insert a thousand separator
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF151:
;	  $ELSE 					     ;;AN000;; No,
	  JMP SHORT $MEN150
$MIF150:
	    CMP     CX,$M_SECOND_THOU			     ;;AN000;;	 Are we at the first thousands mark
;	    $IF     E					     ;;AN000;;	      Yes,
	    JNE $MIF154
	      CMP     $M_SL.$M_S_PAD,$M_COMMA		     ;;AN000;; Is the pad character a comma?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF155
		PUSH	WORD PTR $M_RT.$M_THOU_SEPARA	     ;;AN000;; Insert a thousand separator
		INC	CX				     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF155:
;	    $ELSE					     ;;AN000;;	      No,
	    JMP SHORT $MEN154
$MIF154:
	      CMP     CX,$M_THIRD_THOU			     ;;AN000;;	 Are we at the first thousands mark
;	      $IF     E 				     ;;AN000;;		Yes,
	      JNE $MIF158
		CMP	$M_SL.$M_S_PAD,$M_COMMA 	     ;;AN000;; Is the pad character a comma?
;		$IF	E				     ;;AN000;; Yes,
		JNE $MIF159
		  PUSH	  WORD PTR $M_RT.$M_THOU_SEPARA      ;;AN000;; Insert a thousand separator
		  INC	  CX				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF159:
;	      $ENDIF					     ;;AN000;;
$MIF158:
;	    $ENDIF					     ;;AN000;;
$MEN154:
;	  $ENDIF					     ;;AN000;;
$MEN150:
ENDIF
	  XCHG	  AX,BX 				     ;;AN000;;	 Setup to divide the reduced High Word
							     ;;AN000;;	   and Revised Low Word
	  XOR	  DX,DX 				     ;;AN000;;	 Reset remainder
;	$ENDDO						     ;;AN000;;	 NEXT
	JMP SHORT $MDO145
$MEN145:
							     ;;AN000;; Yes,
	XOR	DX,DX					     ;;AN000;;	 Reset remainder
	XOR	AX,AX					     ;;AN000;;	 Reset remainder
	PUSH	[$M_RT.$M_RETURN_ADDR]			     ;;AN000;;	 Restore Return Address
	RET						     ;;AN000;;	 Return
							     ;;
$M_CONVERT2ASC ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_MESSAGE
;;
;;	FUNCTION:  Will display or write entire message (with replacable parameters)
;;	INPUTS:    ES:DI points to beginning of message
;;		   DS:SI points to first sublist structure in chain
;;		   BX contains the handle to write to (if applicable)
;;		   CX contains the length of string to write (before substitutions)
;;		   BP contains the count of replacables
;;
;;	OUTPUTS:
;;	REGS USED: All
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_MESSAGE PROC NEAR				     ;;AN000;;
							     ;;
;	$DO						     ;;AN000;; Note: DS:SI -> message
$MDO165:
	  XOR	  DX,DX 				     ;;AN000;; Set size = 0
	  OR	  CX,CX 				     ;;AN000;; Are we finished the message yet?
;	  $IF	  NZ					     ;;AN000;; No,
	  JZ $MIF166
	    MOV     AH,"%"				     ;;AN000;;	 Prepare to scan for %
	    MOV     AL,0				     ;;AN004;;
							     ;;
;	    $DO 					     ;;AN000;;	 Scan through string until %
$MDO167:
	      CMP     BYTE PTR ES:[DI],AH		     ;;AN000;;	 Is this character NOT a %
;	    $LEAVE  E,AND				     ;;AN000;;	 No,
	    JNE $MLL168
	      CMP     BYTE PTR ES:[DI+1],AH		     ;;AN000;;	   Is the next character also a %
;	    $LEAVE  NE,AND				     ;;AN000;;	   No,
	    JE $MLL168
	      CMP     AL,AH				     ;;AN000;;	     Was the character before a %
;	    $LEAVE  NE					     ;;AN000;;	     No, GREAT found it
	    JNE $MEN167
$MLL168:
	      MOV     AL,BYTE PTR ES:[DI]		     ;;AN004;;	 Yes, (to any of the above)
	      CALL    $M_IS_IT_DBCS			     ;;AN004;;	   Is this character the first part of a DBCS?
;	      $IF     C 				     ;;AN004;;	   Yes,
	      JNC $MIF169
		INC	DI				     ;;AN004;;	     Increment past second part
;	      $ENDIF					     ;;AN004;;
$MIF169:
	      INC     DI				     ;;AN000;;	     Next character in string
	      INC     DX				     ;;AN000;;	     Size = Size + 1
	      DEC     CX				     ;;AN000;;	     Decrement total size
;	    $ENDDO  Z					     ;;AN000;;	 Exit scan if we're at the end of the line
	    JNZ $MDO167
$MEN167:
;	  $ENDIF					     ;;AN000;;
$MIF166:
							     ;;
	  PUSH	  SI					     ;;AN000;; Save beginning of sublists
	  XCHG	  CX,DX 				     ;;AN000;; Get size of message to display (tot sz in DX)
	  OR	  BP,BP 				     ;;AN000;; Do we have any replacables to do?
;	  $IF	  NZ					     ;;AN000;; Yes,
	  JZ $MIF173
	    DEC     BP					     ;;AN000;;	 Decrement number of replacables

;; Search through sublists to find applicable one

	    CMP     $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	    $IF     E					     ;;AN000;; No,
	    JNE $MIF174
;	      $SEARCH					     ;;AN000;;
$MDO175:
		MOV	AL,$M_SL.$M_S_ID		     ;;AN000;;	 Get ID byte
		ADD	AL,30H				     ;;AN000;;	 Convert to ASCII
		CMP	AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	 Is this the right sublist?
;	      $EXITIF E 				     ;;AN000;;
	      JNE $MIF175
;	      $ORELSE					     ;;AN000;;	 No,
	      JMP SHORT $MSR175
$MIF175:
		CMP	AL,$M_SPECIAL_CASE		     ;;AN000;;	   Does this sublist have ID = 0
;	      $LEAVE  E,AND				     ;;AN000;;	   Yes,
	      JNE $MLL178
		OR	DX,DX				     ;;AN000;;	   Are we at the end of the message?
;	      $LEAVE  Z 				     ;;AN000;;	   No,
	      JZ $MEN175
$MLL178:
		ADD	SI,WORD PTR $M_SL.$M_S_SIZE	     ;;AN000;;	     Next SUBLIST
;	      $ENDLOOP					     ;;AN000;;	   Yes,
	      JMP SHORT $MDO175
$MEN175:
		CMP	$M_RT.$M_CLASS,UTILITY_MSG_CLASS     ;;AN004;;	     Is it a utility message?
;		$IF	E				     ;;AN004;;	     Yes,
		JNE $MIF180
		  INC	  DX				     ;;AN000;;	       Remember to display CR,LF
		  INC	  DX				     ;;AN000;;		 at the end of the message
		  DEC	  CX				     ;;AN000;;	       Adjust message length
		  DEC	  CX				     ;;AN000;;
		  DEC	  DI				     ;;AN000;;	       Adjust ending address of message
		  DEC	  DI				     ;;AN000;;
;		$ELSE					     ;;AN004;;	     No,
		JMP SHORT $MEN180
$MIF180:
		  MOV	  DX,-1 			     ;;AN004;;	       Set special case
;		$ENDIF					     ;;AN004;;
$MEN180:
;	      $ENDSRCH					     ;;AN000;;
$MSR175:
;	    $ENDIF					     ;;AN000;;
$MIF174:
;	  $ENDIF					     ;;AN000;;
$MIF173:

;; Prepare and display this part of message

	  PUSH	  DI					     ;;AN000;; Save pointer to replace number
	  SUB	  DI,CX 				     ;;AN000;; Determine beginning of string
	  CALL	  $M_DISPLAY_STRING			     ;;AN000;; Display string until % (or end)
	  POP	  DI					     ;;AN000;; Get back pointer to replace number
	  POP	  CX					     ;;AN000;; Clean up stack in case error
;	$LEAVE	C,LONG					     ;;AN000;; Fail if carry was set
	JNC $MXL3
	JMP $MEN165
$MXL3:
	  PUSH	  CX					     ;;AN000;;

;; Save and reset pointer registers

	  MOV	  CX,DX 				     ;;AN000;; Get the size of the rest of the message
	  CMP	  $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H	     ;;AN000;; Is this the %0 case?
;	  $IF	  NE					     ;;AN000;; No,
	  JE $MIF187
	    OR	    CX,CX				     ;;AN000;;	Are we finished the whole message?
;	    $IF     NZ					     ;;AN000;;	No,
	    JZ $MIF188
	      DEC     CX				     ;;AN000;;	  Decrement total size (%)
	      DEC     CX				     ;;AN000;;	  Decrement total size (#)
	      INC     DI				     ;;AN000;;	  Go past %
	      INC     DI				     ;;AN000;;	  Go past replace number
;	    $ELSE					     ;;AN000;;	Yes, (Note this will not leave because INC)
	    JMP SHORT $MEN188
$MIF188:
	      POP     SI				     ;;AN000;;	  Get back pointer to beginning of SUBLISTs
;	    $ENDIF					     ;;AN000;; Yes, Note this will not leave because INC
$MEN188:
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN187
$MIF187:
	    OR	    CX,CX				     ;;AN000;;	Are we finished the whole message?
;	    $IF     Z					     ;;AN004;;	 No,
	    JNZ $MIF192
	      POP     SI				     ;;AN000;;	 Get back pointer to beginning of SUBLISTs
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN192
$MIF192:
	      CMP     CX,-1				     ;;AN004;;	 Are we at the end of the message?
;	      $IF     Z 				     ;;AN004;;	 No,
	      JNZ $MIF194
		XOR	CX,CX				     ;;AN004;;
;	      $ENDIF					     ;;AN000;;
$MIF194:
	      OR      DI,DI				     ;;AN004;;	Turn ZF off
;	    $ENDIF					     ;;AN000;;
$MEN192:
;	  $ENDIF					     ;;AN000;; Note this will not leave because INC
$MEN187:
;	$LEAVE	Z					     ;;AN000;;
	JZ $MEN165
	  PUSH	  BP					     ;;AN000;;	 Save the replace count
	  PUSH	  DI					     ;;AN000;;	 Save location to complete message
	  PUSH	  ES					     ;;AN000;;
	  PUSH	  CX					     ;;AN000;;	 Save size of the rest of the message
	  XOR	  CX,CX 				     ;;AN000;;	 Reset CX used for character count

;; Determine what action is required on parameter

	  CMP	  $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	  $IF	  E					     ;;AN000;;
	  JNE $MIF199

IF	    CHARmsg					     ;;AN000;; Was Char specified?
	    TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF200

;; Character type requested
							     ;;AN000;;
	      LES     DI,DWORD PTR $M_SL.$M_S_VALUE	     ;;AN000;; Load pointer to replacing parameter
	      CALL    $M_CHAR_REPLACE			     ;;AN000;;
;	    $ELSE					     ;;AN000;;	 Get the rest of the message to display
	    JMP SHORT $MEN200
$MIF200:
ENDIF							     ;;AN000;;
IF	      NUMmsg					     ;;AN000;; Was Nnmeric type specified?
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,OR				     ;;AN000;;
	      JZ $MLL202
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,OR				     ;;AN000;;
	      JZ $MLL202
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF202
$MLL202:

;; Numeric type requested

		LES	DI,DWORD PTR $M_SL.$M_S_VALUE	     ;;AN000;; Load pointer to replacing parameter
		CALL	$M_BIN2ASC_REPLACE		     ;;AN000;;
;	      $ELSE					     ;;AN000;; Get the rest of the message to display
	      JMP SHORT $MEN202
$MIF202:
ENDIF							     ;;AN000;;
IF		DATEmsg 				     ;;AN000;; Was date specified?
		TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Date_Type AND $M_TYPE_MASK ;;AN000;;
;		$IF	E				     ;;AN000;;
		JNE $MIF204

;; Date type requested

		  CALL	  $M_DATE_REPLACE		     ;;AN000;;
;		$ELSE					     ;;AN000;; Get the rest of the message to display
		JMP SHORT $MEN204
$MIF204:
ENDIF							     ;;AN000;;
IF		  TIMEmsg				     ;;AN000;;	Was time (12 hour format) specified?

;; Time type requested (Default if we have not matched until here)

		  CALL	  $M_TIME_REPLACE		     ;;AN000;;
ENDIF							     ;;AN000;;

IF		  DATEmsg				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MEN204:
ENDIF							     ;;AN000;;
IF		NUMmsg					     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MEN202:
ENDIF							     ;;AN000;;
IF	      CHARmsg					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN200:
ENDIF							     ;;AN000;;

IF	    $M_REPLACE					     ;;AN000;;
;; With the replace information of the Stack, display the replaceable field

	    CALL    $M_DISPLAY_REPLACE			     ;;AN000;; Display the replace
ENDIF							     ;;AN000;;
;; None of the above - Extended/Parse replace
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN199
$MIF199:
IF	    NOT     COMR
	    CALL    $M_EXT_PAR_REPLACE			     ;;AN000;;
ENDIF
;	  $ENDIF					     ;;AN000;;
$MEN199:

;; We must go back and complete the message after the replacable parameter if there is any left

;	  $IF	  NC					     ;;AN000;; IF there was an error displaying then EXIT
	  JC $MIF211
	    POP     CX					     ;;AN000;; Get size of the rest of the message
	    POP     ES					     ;;AN000;; Get address of the rest of the message
	    POP     DI					     ;;AN000;;
	    POP     BP					     ;;AN000;; Get replacment count
	    POP     SI					     ;;AN000;; ELSE get address of first sublist structure
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN211
$MIF211:
	    ADD     SP,10				     ;;AN000;; Clean up stack if error
	    STC 					     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN211:
	  CMP	  $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	$ENDDO	NE,OR					     ;;AN000;;
	JNE $MLL214
;	$ENDDO	C,LONG					     ;;AN000;; Go back and display the rest of the message
	JC $MXL4
	JMP $MDO165
$MXL4:
$MLL214:
$MEN165:
							     ;;        IF there was an error displaying then EXIT
	MOV	$M_RT.$M_MSG_NUM,0			     ;;AN000;; Reset message number to null
	RET						     ;;AN000;; Return
							     ;;
$M_DISPLAY_MESSAGE ENDP 				     ;;AN000;;
IF	NOT	COMR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_EXT_PAR_REPLACE
;;
;;	FUNCTION:
;;	INPUTS:
;;	OUPUTS:
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_EXT_PAR_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	XOR	DX,DX					     ;;AN000;; Prepare for get binary value (HIGH)
	MOV	AX,$M_RT.$M_MSG_NUM			     ;;AN000;; Prepare for get binary value (LOW)
	MOV	$M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
							     ;;
	CALL	$M_CONVERT2ASC				     ;;AN000;;
							     ;;
;	$DO						     ;;AN000;;
$MDO215:
	  POP	  AX					     ;;AN000;;	 Get character in register
	  MOV	  BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL	     ;;AN000;;	Move char into the buffer
	  INC	  BX					     ;;AN000;;	 Increase buffer count
	  CMP	  BX,$M_TEMP_BUF_SZ			     ;;AN000;;	 Is buffer full?
;	  $IF	  E					     ;;AN000;;	 Yes,
	  JNE $MIF216
	    CALL    $M_FLUSH_BUF			     ;;AN000;;	   Flush the buffer
;	  $ENDIF					     ;;AN000;;
$MIF216:
	  DEC	  CL					     ;;AN000;;	 Have we completed replace?
;	$ENDDO	Z					     ;;AN000;;
	JNZ $MDO215
							     ;;
	MOV	AX,$M_CR_LF				     ;;AN000;;	Move char into the buffer
	MOV	WORD PTR $M_RT.$M_TEMP_BUF[BX],AX	     ;;AN000;;	Move char into the buffer
	INC	BX					     ;;AN000;;	 Increase buffer count
	INC	BX					     ;;AN000;;	 Increase buffer count
	CALL	$M_FLUSH_BUF				     ;;AN000;;	   Flush the buffer
	RET						     ;;AN000::
							     ;;
$M_EXT_PAR_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIF
	IF	$M_SUBS 				     ;;AN000;; Include the common subroutines if they haven't yet
	  $M_SUBS = FALSE				     ;;AN000;; No, then include and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_MSG_ADDRESS
;;
;;	FUNCTION:  To scan thru classes to return pointer to the message header
;;	INPUTS:    Access to $M_RES_ADDRESSES
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN DS:SI points to the specified message
;;	REGS CHANGED: ES,DI,CX,DS,SI
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	  FARmsg					     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC FAR			     ;;AN000;;
ELSE							     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC NEAR			     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
	  PUSH	  SI					     ;;AN000;;
	  PUSH	  BX					     ;;AN000;;
	  XOR	  SI,SI 				     ;;AN000;; Use SI as an index
	  XOR	  CX,CX 				     ;;AN000;; Use CX as an size
;	  $DO						     ;;AN000;;
$MDO219:
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;; Were utility messages requested?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF220
	      IF      FARmsg				     ;;AN000;;
		LES	DI,DWORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;  Get address of class
		MOV	BX,ES				     ;;AN000;
	      ELSE					     ;;AN000;;
		MOV	DI,WORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;	 Get address of class
		MOV	BX,DI				     ;;AN000;
	      ENDIF					     ;;AN000;;
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN220
$MIF220:
	      TEST    DH,PARSE_ERR_CLASS		     ;;AN000;;	 Were parse errors requested?
;	      $IF     NE				     ;;AN000;;	 Yes,
	      JE $MIF222
		LES	DI,DWORD PTR $M_RT.$M_PARSE_COMMAND[SI] ;;AN000;;   Get address of class
		MOV	BX,ES				     ;;AN000;
;	      $ELSE					     ;;AN000;;	 No, extended errors were specified
	      JMP SHORT $MEN222
$MIF222:
		CMP	AX,$M_CRIT_LO			     ;;AN000;;	   Is this a critical error?
;		$IF	AE,AND				     ;;AN000;;
		JNAE $MIF224
		CMP	AX,$M_CRIT_HI			     ;;AN000;;
;		$IF	BE				     ;;AN000;;	    Yes,
		JNBE $MIF224
		  LES	  DI,DWORD PTR $M_RT.$M_CRIT_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ELSE					     ;;AN000;;
		JMP SHORT $MEN224
$MIF224:
		  LES	  DI,DWORD PTR $M_RT.$M_EXT_ERR_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ENDIF					     ;;AN000;;
$MEN224:
;	      $ENDIF					     ;;AN000;;
$MEN222:
;	    $ENDIF					     ;;AN000;;
$MEN220:
							     ;;
	    CMP     BX,$M_TERMINATING_FLAG		     ;;AN000;; Are we finished all classes?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF229
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;;	  Was it a UTILITY class?
;	      $IF     E 				     ;;AN000;;	  Yes,
	      JNE $MIF230
		STC					     ;;AN000;;	    Set the carry flag
;	      $ELSE					     ;;AN000;;	  No,
	      JMP SHORT $MEN230
$MIF230:
		MOV	$M_RT.$M_MSG_NUM,AX		     ;;AN000;;	    Save message number
		MOV	AX,$M_SPECIAL_MSG_NUM		     ;;AN000;;	    Set special message number
		MOV	BP,$M_ONE_REPLACE		     ;;AN000;;	    Set one replace in message
		XOR	SI,SI				     ;;AN000;;	    Reset the SI index to start again
		CLC					     ;;AN000;;
;	      $ENDIF					     ;;AN000;; No,
$MEN230:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN229
$MIF229:
	      CMP     BX,$M_CLASS_NOT_EXIST		     ;;AN000;;	 Does this class exist?
;	      $IF     NE				     ;;AN001;;	 Yes,
	      JE $MIF234
		CALL	$M_FIND_SPECIFIED_MSG		     ;;AN000;;	   Try to find the message
;	      $ENDIF					     ;;AN000;;
$MIF234:
	      ADD     SI,$M_ADDR_SZ_FAR 		     ;;AN000;;	     Get next class
	      CLC					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN229:
;	  $LEAVE  C					     ;;AN000;;
	  JC $MEN219
	    OR	    CX,CX				     ;;AN000;;	   Was the message found?
;	  $ENDDO  NZ,LONG				     ;;AN000;;
	  JNZ $MXL5
	  JMP $MDO219
$MXL5:
$MEN219:

	  PUSHF 					     ;;AN006;; Save the flag state
	  CMP	  DH,EXT_ERR_CLASS			     ;;AN006;; Was an extended error requested?
;	  $IF	  E					     ;;AN006;; Yes,
	  JNE $MIF239
	    PUSH    DX					     ;;AN006;;	Save all needed registers
	    PUSH    BP					     ;;AN006;;
	    PUSH    CX					     ;;AN006;;
	    PUSH    ES					     ;;AN006;;
	    PUSH    DI					     ;;AN006;;
	    PUSH    AX					     ;;AN006;;

	    MOV     AX,IFSFUNC_INSTALL_CHECK		     ;;AN006;;	Check if IFSFUNC is installed
	    INT     2FH 				     ;;AN006;;
	    CMP     AL,IFSFUNC_INSTALLED		     ;;AN006;;	Is it installed?
	    POP     AX					     ;;AN006;;	Restore msg number
;	    $IF     E					     ;;AN006;;	 Yes,
	    JNE $MIF240
	      MOV     BX,AX				     ;;AN006;;	  BX is the extended error number
	      MOV     AX,IFS_GET_ERR_TEXT		     ;;AN006;;	  AX is the muliplex number
	      INT     2FH				     ;;AN006;;	  Call IFSFUNC
;	    $ELSE					     ;;AN006;;	 No,
	    JMP SHORT $MEN240
$MIF240:
	      STC					     ;;AN006;;	  Carry conditon
;	    $ENDIF					     ;;AN006;;
$MEN240:

;	    $IF     C					     ;;AN006;;	Was there an update?
	    JNC $MIF243
	      POP     DI				     ;;AN006;;	No,
	      POP     ES				     ;;AN006;;	 Restore old pointer
	      POP     CX				     ;;AN006;;
;	    $ELSE					     ;;AN006;;	Yes
	    JMP SHORT $MEN243
$MIF243:
	      ADD     SP,6				     ;;AN006;;	 Throw away old pointer
	      CALL    $M_SET_LEN_IN_CX			     ;;AN006;;	 Get the length of the ASCIIZ string
;	    $ENDIF					     ;;AN006;;
$MEN243:
	    POP     BP					     ;;AN006;;	Restore other Regs
	    POP     DX					     ;;AN006;;
;	  $ENDIF					     ;;AN006;;
$MIF239:
	  $M_POPF					     ;;AN006;; Restore the flag state

	  POP	  BX					     ;;AN000;;
	  POP	  SI					     ;;AN000;;
	  RET						     ;;AN000;; Return ES:DI pointing to the message
							     ;;
$M_GET_MSG_ADDRESS ENDP 				     ;;
							     ;;
$M_SET_LEN_IN_CX PROC NEAR				     ;;
							     ;;
	  PUSH	  DI					     ;;AN006;; Save position
	  PUSH	  AX					     ;;AN006;;
	  MOV	  CX,-1 				     ;;AN006;; Set CX for decrements
	  XOR	  AL,AL 				     ;;AN006;; Prepare compare register
	  REPNE   SCASB 				     ;;AN006;; Scan for zero
	  NOT	  CX					     ;;AN006;; Change decrement into number
	  DEC	  CX					     ;;AN006;; Don't include the zero
	  POP	  AX					     ;;AN006;;
	  POP	  DI					     ;;AN006;; Restore position
	  RET						     ;;AN006;;
							     ;;
$M_SET_LEN_IN_CX ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FIND_SPECIFIED_MSG
;;
;;	FUNCTION:  To scan thru message headers until message is found
;;	INPUTS:    ES:DI points to beginning of msg headers
;;		   CX contains the number of messages in class
;;		   DH contains the message class
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to header of specified message
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FIND_SPECIFIED_MSG PROC NEAR 			     ;;AN000;;
							     ;;
	  CMP	  BX,1					     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  E,AND 				     ;;AN004;;	Yes,
	  JNE $MIF247
	  CMP	  WORD PTR $M_RT.$M_DISK_PROC_ADDR,-1	     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  NE					     ;;AN004;;	Yes,
	  JE $MIF247
	    CMP     AX,$M_SPECIAL_MSG_NUM		     ;;AN004;; Are we displaying a default Ext Err?
;	    $IF     E					     ;;AN004;;	. . . and . . .
	    JNE $MIF248
	      PUSH    AX				     ;;AN004;;	 Reset the special message number
	      MOV     AX,$M_RT.$M_MSG_NUM		     ;;AN004;;	 Get the old message number
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
	      POP     AX				     ;;AN004;;	 Reset the special message number
;	    $ELSE					     ;;AN004;;	 Get the old message number
	    JMP SHORT $MEN248
$MIF248:
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
;	    $ENDIF					     ;;AN004;;	 Get the old message number
$MEN248:
;	  $ELSE 					     ;;AN004;;
	  JMP SHORT $MEN247
$MIF247:
	    XOR     CX,CX				     ;;AN002;;	 CX = 0 will allow us to
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	    $IF     NE					     ;;AN001;;
	    JE $MIF252
	      MOV     CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
;	    $ELSE					     ;;AN001;;
	    JMP SHORT $MEN252
$MIF252:
IF	      FARmsg					     ;;AN001;;
	      CMP     BYTE PTR ES:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ELSE
	      CMP     BYTE PTR CS:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ENDIF
;	      $IF     E 				     ;;AN002;;	pointer (hopefully)
	      JNE $MIF254
IF		FARmsg					     ;;AN001;;
		MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
ELSE
		MOV	CL,BYTE PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
ENDIF
;	      $ENDIF					     ;;AN002;;	  go on to the next class
$MIF254:
;	    $ENDIF					     ;;AN001;;
$MEN252:
	    ADD     DI,$M_CLASS_ID_SZ			     ;;AN000;;	   Point past the class header
	    STC 					     ;;AN004;;	 Flag that we haven't found anything yet
;	  $ENDIF					     ;;AN004;;
$MEN247:

;	  $IF	  C					     ;;AN004;; Have we found anything yet?
	  JNC $MIF258
	    CLC 					     ;;AN004;; No, reset carry
;	    $SEARCH					     ;;AN000;;
$MDO259:
	      OR      CX,CX				     ;;AN000;;	  Do we have any to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN259
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	      $IF     NE				     ;;AN001;;
	      JE $MIF261
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN001;; Is this the message requested?
;	      $ELSE					     ;;AN001;;
	      JMP SHORT $MEN261
$MIF261:
IF		FARmsg					     ;;AN001;;
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ELSE
		CMP	AX,WORD PTR CS:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ENDIF
;	      $ENDIF
$MEN261:
;	    $EXITIF E					     ;;AN000;;
	    JNE $MIF259
;	    $ORELSE					     ;;AN000;
	    JMP SHORT $MSR259
$MIF259:
	      DEC     CX				     ;;AN000;;	  No, well do we have more to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN259
	      ADD     DI,$M_ID_SZ			     ;;AN000;;	     Yes, skip past msg header
;	    $ENDLOOP					     ;;AN000;;
	    JMP SHORT $MDO259
$MEN259:
	      STC					     ;;AN000;;
;	    $ENDSRCH					     ;;AN000;;	     Check next message
$MSR259:
;	    $IF     NC					     ;;AN000;;	 Did we find the message?
	    JC $MIF269
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;	 Yes, is it a utility message?
	      CLC					     ;;AN001;;
;	      $IF     E 				     ;;AN001;;
	      JNE $MIF270
IF		FARmsg					     ;;AN001;;
ELSE							     ;;AN000;;
		PUSH	CS				     ;;AN000;;
		POP	ES				     ;;AN000;;	 Return ES:DI pointing to the message
ENDIF
;	      $ENDIF					     ;;AN001;;
$MIF270:
	      ADD     DI,WORD PTR ES:[DI].$M_TXT_PTR	     ;;AN000;; Prepare ES:DI pointing to the message
;	    $ENDIF					     ;;AN004;;
$MIF269:
;	  $ENDIF					     ;;AN004;;
$MIF258:
							     ;; 	  Yes, great we can return with CX > 0

;	  $IF	  NC					     ;;AN000;;	 Did we find the message?
	  JC $MIF274
	    XOR     CH,CH				     ;;AN000;;
	    MOV     CL,BYTE PTR ES:[DI] 		     ;;AN000;;	 Move size into CX
	    INC     DI					     ;;AN000;;	 Increment past length
;	  $ENDIF					     ;;AN004;;
$MIF274:

	  MOV	  $M_RT.$M_SIZE,$M_NULL 		     ;;AN004;; Reset variable
	  RET						     ;;AN000;; Return
							     ;;
$M_FIND_SPECIFIED_MSG ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of common subroutines
; 
	IF	$M_REPLACE				     ;;AN000;; Is the request to include the code for replaceable parms
	  $M_REPLACE = FALSE				     ;;AN000;;	   Tell the assembler we did
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
$M_DISPLAY_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	  XOR	  BX,BX 				     ;;AN000;; Use BX for buffer count
IF	  NOT	  COMR
	  CMP	  $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H	     ;;AN000;; Is this the special case (convert to ASCII)
;	  $IF	  E					     ;;AN000;; Yes,
	  JNE $MIF276
	    MOV     WORD PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP ;;AN000;; Move in a " -"
	    INC     BX					     ;;AN000;;	   Increment count
	    INC     BX					     ;;AN000;;	   Increment count
	    MOV     BYTE PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE  ;;AN000;;	   Move in a " "
	    INC     BX					     ;;AN000;;	   Increment count
	    CALL    $M_FLUSH_BUF			     ;;AN000;;	   Write out " - " to prepare for special case
;	  $ENDIF					     ;;AN000;;	   If it fails we will catch it later
$MIF276:
ENDIF

	  POP	  BP					     ;;AN000;; Remember the return address
	  XOR	  BX,BX 				     ;;AN000;; Use BX for buffer count
	  XOR	  DX,DX 				     ;;AN000;; Use DX for count of parms taken off the stack

	  MOV	  $M_RT.$M_SIZE,CL			     ;;AN000;; Save size to later clear stack
	  MOV	  AL,BYTE PTR $M_SL.$M_S_MINW		     ;;AN000;; Get the minimum width
							     ;;
	  CMP	  AL,CL 				     ;;AN000;; Do we need pad chars added?
;	  $IF	  A					     ;;AN000;; Yes,
	  JNA $MIF278
	    SUB     AL,CL				     ;;AN000;;	 Calculate how many pad chars are needed.
	    MOV     DH,AL				     ;;AN000;;	 Save the number of pad characters
	    TEST    BYTE PTR $M_SL.$M_S_FLAG,Right_Align     ;;AN000;;	 Was replaceable parm to be right aligned?
;	    $IF     NZ					     ;;AN000;;	 Yes,
	    JZ $MIF279
;	      $DO					     ;;AN000;;	   Begin filling buffer with pad chars
$MDO280:
		MOV	AL,BYTE PTR $M_SL.$M_S_PAD	     ;;AN000;;
		MOV	BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL    ;;AN000;;	   Move in a pad char
		INC	BX				     ;;AN000;;
		CMP	BX,$M_TEMP_BUF_SZ		     ;;AN000;;	   Is buffer full?
;		$IF	E				     ;;AN000;;	   Yes,
		JNE $MIF281
		  CALL	  $M_FLUSH_BUF			     ;;AN000;;	     Flush the buffer
;		$ENDIF					     ;;AN000;;
$MIF281:
		DEC	DH				     ;;AN000;;	   Have we filled with enough pad chars?
;	      $ENDDO  Z 				     ;;AN000;;	   No, next pad character
	      JNZ $MDO280
;	    $ENDIF					     ;;AN000;;
$MIF279:
;	  $ENDIF					     ;;AN000;;	   Yes,
$MIF278:
							     ;;
	  CMP	  BYTE PTR $M_SL.$M_S_MAXW,$M_UNLIM_W	     ;;AN000;; Is maximum width unlimited?
;	  $IF	  NE					     ;;AN000;;
	  JE $MIF286
	    CMP     BYTE PTR $M_SL.$M_S_MAXW,CL 	     ;;AN000;; Will we exceed maximum width?
;	    $IF     B					     ;;AN000;; Yes,
	    JNB $MIF287
	      SUB     CL,BYTE PTR $M_SL.$M_S_MAXW	     ;;AN000;;	 Calculate how many extra chars
	      MOV     DL,CL				     ;;AN000;;	 Remember how many chars to pop off
	      MOV     CL,BYTE PTR $M_SL.$M_S_MAXW	     ;;AN000;;	 Set new string length
;	    $ENDIF					     ;;AN000;;
$MIF287:
;	  $ENDIF					     ;;AN000;;
$MIF286:
	  OR	  CX,CX 				     ;;AN000;;
;	  $IF	  NZ					     ;;AN000;;
	  JZ $MIF290
;	    $DO 					     ;;AN000;; Begin filling buffer with string
$MDO291:
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,AND				     ;;AN000;;
	      JNZ $MIF292
	      TEST    $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK ;  Is this replace a ASCIIZ string?
;	      $IF     NZ				     ;;AN000;; Yes,
	      JZ $MIF292
		MOV	AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get first character from string
		INC	DI				     ;;AN000;;	 Next character in string
;	      $ELSE					     ;;AN000;; No,
	      JMP SHORT $MEN292
$MIF292:
		POP	AX				     ;;AN000;;	 Get character in register
;	      $ENDIF					     ;;AN000;;
$MEN292:
	      MOV     BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL      ;;AN000;;	Move char into the buffer
	      INC     BX				     ;;AN000;;	 Increase buffer count
	      CMP     BX,$M_TEMP_BUF_SZ 		     ;;AN000;;	 Is buffer full?
;	      $IF     E 				     ;;AN000;;	 Yes,
	      JNE $MIF295
		CALL	$M_FLUSH_BUF			     ;;AN000;;	   Flush the buffer
;	      $ENDIF					     ;;AN000;;
$MIF295:
	      DEC     CL				     ;;AN000;;	 Have we completed replace?
;	    $ENDDO  Z					     ;;AN000;;	   Test again
	    JNZ $MDO291
;	  $ENDIF					     ;;AN000;;
$MIF290:
							     ;;
	  TEST	  BYTE PTR $M_SL.$M_S_FLAG,Right_Align	     ;;AN000;;	 Was replaceable parm to be left aligned?
;	  $IF	  Z					     ;;AN000;; Yes,
	  JNZ $MIF299
	    OR	    DH,DH				     ;;AN000;;	 Do we need pad chars added?
;	    $IF     NZ					     ;;AN000;;	 Yes,
	    JZ $MIF300
;	      $DO					     ;;AN000;;	   Begin filling buffer with pad chars
$MDO301:
		MOV	AL,BYTE PTR $M_SL.$M_S_PAD	     ;;AN000;;
		MOV	BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL    ;;AN000;;	   Move in a pad char
		INC	BX				     ;;AN000;;
		CMP	BX,$M_TEMP_BUF_SZ		     ;;AN000;;	   Is buffer full?
;		$IF	E				     ;;AN000;;	   Yes,
		JNE $MIF302
		  CALL	  $M_FLUSH_BUF			     ;;AN000;;	     Flush the buffer
;		$ENDIF					     ;;AN000;;
$MIF302:
		DEC	DH				     ;;AN000;;	   Have we filled with enough pad chars?
;	      $ENDDO  Z 				     ;;AN000;;	     Test again
	      JNZ $MDO301
;	    $ENDIF					     ;;AN000;;
$MIF300:
;	  $ENDIF					     ;;AN000;;
$MIF299:
							     ;;
	  TEST	  BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	  $IF	  Z,AND 				     ;;AN000;;
	  JNZ $MIF307
	  TEST	  $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK ;;AN000;;	Is this replace a ASCIIZ string?
;	  $IF	  NZ					     ;;AN000;; Yes,
	  JZ $MIF307
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN307
$MIF307:
	    OR	    DL,DL				     ;;AN000;;
;	    $IF     NE					     ;;AN000;;
	    JE $MIF309
;	      $DO					     ;;AN000;;
$MDO310:
		POP	[$M_RT.$M_RETURN_ADDR]		     ;;AN000;;	 Clean Up stack using spare variable
		DEC	DL				     ;;AN000;;	 Are we done?
;	      $ENDDO  Z 				     ;;AN000;;
	      JNZ $MDO310
;	    $ENDIF					     ;;AN000;;
$MIF309:
;	  $ENDIF					     ;;AN000;;
$MEN307:
	  CALL	  $M_FLUSH_BUF				     ;;AN000;;	     Flush the buffer for the final time
	  PUSH	  BP					     ;;AN000;; Restore the return address
							     ;;
	  RET						     ;;AN000;;
							     ;;
$M_DISPLAY_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FLUSH_BUFFER
;;
;;	FUNCTION: Display the contents of the temporary buffer
;;	INPUTS: DI contains the number of bytes to display
;;	OUTPUTS: BX reset to zero
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FLUSH_BUF PROC NEAR					     ;;AN000;;
							     ;;
	  PUSH	  CX					     ;;AN000;; Save changed regs
	  PUSH	  ES					     ;;AN000;;
	  PUSH	  DI					     ;;AN000;;
	  PUSH	  DS					     ;;AN000;; Set ES pointing to buffer
	  POP	  ES					     ;;AN000;;
							     ;;
	  MOV	  CX,BX 				     ;;AN000;; Set number of bytes to display
	  XOR	  BX,BX 				     ;;AN000;; Reset buffer counter
	  LEA	  DI,$M_RT.$M_TEMP_BUF			     ;;AN000;; Reset buffer location pointer
	  CALL	  $M_DISPLAY_STRING			     ;;AN000;; Display the buffer
							     ;;
;	  $IF	  NC					     ;;AN000;; Error?
	  JC $MIF314
	    POP     DI					     ;;AN000;; No, Restore changed regs
	    POP     ES					     ;;AN000;;
	    POP     CX					     ;;AN000;;
;	  $ELSE 					     ;;AN000;; Yes,
	  JMP SHORT $MEN314
$MIF314:
	    ADD     SP,6				     ;;AN000;;	Fix stack
	    STC 					     ;;AN000;;
;	  $ENDIF					     ;;AN000;; Error?
$MEN314:
							     ;;
	  RET						     ;;AN000;; Return
							     ;;
$M_FLUSH_BUF ENDP					     ;;AN000;;
							     ;;
							     ;;
	  IF	  CHARmsg				     ;;AN000;; Is the request to include the code for CHAR replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = TRUE 			     ;;AN000;;	 replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CHAR_REPLACE
;;
;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;
;;	OTHER REGS Revised: AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHAR_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    TEST    $M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK ;;AN000;; Was Character specified?
;	    $IF     Z					     ;;AN000;; Yes,
	    JNZ $MIF317
	      MOV     AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get the character
	      PUSH    AX				     ;;AN000;;	 Put it on the stack
	      INC     CX				     ;;AN000;;	 Increase the count
	      CALL    $M_IS_IT_DBCS			     ;;AN000;;	 Is this the first byte of a DB character
;	      $IF     C 				     ;;AN000;;	 Yes,
	      JNC $MIF318
		MOV	AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	   Get the next character
		PUSH	AX				     ;;AN000;;	   Put it on the stack
		CLC					     ;;AN000;;	   Clear the carry
;	      $ENDIF					     ;;AN000;;
$MIF318:
;	    $ELSE					     ;;AN000;; No, it was an ASCIIZ string
	    JMP SHORT $MEN317
$MIF317:
;	      $DO					     ;;AN000;;
$MDO321:
		MOV	AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get the character
		OR	AL,AL				     ;;AN000;;	 Is it the NULL?
;	      $LEAVE  Z 				     ;;AN000;;	 No,
	      JZ $MEN321
		INC	DI				     ;;AN000;;	   Next character
		INC	CX				     ;;AN000;;	   Increment the count
;	      $ENDDO					     ;;AN000;;	 Yes,
	      JMP SHORT $MDO321
$MEN321:
	      SUB     DI,CX				     ;;AN000;;	 Set SI at the beginning of the string
;	    $ENDIF					     ;;AN000;;
$MEN317:
							     ;;AN000;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_CHAR_REPLACE ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of CHAR replace code
; 
	  IF	  NUMmsg				     ;;AN000;; Is the request to include the code for NUM replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	 replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_BIN2ASC_REPLACE
;;
;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: BX,DX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_BIN2ASC_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
							     ;;
	    XOR     DX,DX				     ;;AN000;; Prepare for get binary value (HIGH)
	    XOR     AX,AX				     ;;AN000;; Prepare for get binary value (LOW)
	    MOV     $M_RT.$M_DIVISOR,$M_BASE16		     ;;AN000;; Set default divisor
	    XOR     BX,BX				     ;;AN000;; Use BP as the NEG flag (if applicable)
IF	    NOT     COMR
	    TEST    $M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK ;;AN000;; Was BYTE specified?
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF325
	      MOV     AL, BYTE PTR ES:[DI]		     ;;AN000;; Setup byte in AL
	      TEST    $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF326
		TEST	AL,10000000b			     ;;AN000;; Is this number negative?
;		$IF	NZ				     ;;AN000;;	 Yes,
		JZ $MIF327
		  INC	  BX				     ;;AN000;;	   Remember that it was negative
		  AND	  AL,01111111b			     ;;AN000;;	   Make it positive
;		$ENDIF					     ;;AN000;;
$MIF327:
		MOV	$M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF326:
	      TEST    $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF330
		MOV	$M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF330:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN325
$MIF325:
ENDIF
	      TEST    $M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK ;;AN000;; Was WORD specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF333
		MOV	AX, WORD PTR ES:[DI]		     ;;AN000;; Setup byte in AL
		TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;; AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF334
		  TEST	  AH,10000000b			     ;;AN000;; Is this number negative?
;		  $IF	  NZ				     ;;AN000;;	 Yes,
		  JZ $MIF335
		    INC     BX				     ;;AN000;;	   Remember that it was negative
		    AND     AH,01111111b		     ;;AN000;;	   Make it positive
;		  $ENDIF				     ;;AN000;;
$MIF335:
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF334:
		TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF338
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF338:
;	      $ELSE					     ;;AN000;;
	      JMP SHORT $MEN333
$MIF333:
IF		NOT	COMR
		MOV	AX, WORD PTR ES:[DI]		     ;;AN000;; Setup Double word in DX:AX
		MOV	DX, WORD PTR ES:[DI]+2		     ;;AN000;;
		TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF341
		  TEST	  DH,10000000b			     ;;AN000;; Is this number negative?
;		  $IF	  NZ				     ;;AN000;;	 Yes,
		  JZ $MIF342
		    INC     BX				     ;;AN000;;	   Remember that it was negative
		    AND     DH,01111111b		     ;;AN000;;	   Make it positive
;		  $ENDIF				     ;;AN000;;
$MIF342:
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF341:
		TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF345
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF345:
ENDIF
;	      $ENDIF					     ;;AN000;;
$MEN333:
;	    $ENDIF					     ;;AN000;;
$MEN325:
							     ;;
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert to ASCII string
IF	    NOT     COMR
	    OR	    BX,BX				     ;;AN000;;
;	    $IF     NZ					     ;;AN000;; Was number negative?
	    JZ $MIF349
	      XOR     DX,DX				     ;;AN000;; Yes,
	      MOV     DL,$M_NEG_SIGN			     ;;AN000;;	 Put "-" on the stack with the number
	      PUSH    DX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;; No,
$MIF349:
ENDIF
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_BIN2ASC_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of NUM replace code
; 
	  IF	  DATEmsg				     ;;AN000;; Is the request to include the code for DATE replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	  replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DATE_REPLACE
;;
;;	FUNCTION: Convert a date to a decimal ASCII string using current
;;		  country format and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: DX, AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DATE_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    MOV     $M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
	    CALL    $M_GET_DATE 			     ;;AN000;; Set date format/separator in $M_RT
							     ;;AN000;; All O.K.?
	    XOR     DX,DX				     ;;AN000;; Reset DX value
	    XOR     AX,AX				     ;;AN000;; Reset AX value
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,0	     ;;AN000;; USA Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF351
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;; Increment count
	      XOR     AX,AX				     ;;AN000;; Reset AX value
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;; Increment count
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF351:
							     ;;
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,1	     ;;AN000;; EUROPE Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF353
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      XOR     AX,AX				     ;;AN000;; Reset AX
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF353:
							     ;;
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,2	     ;;AN000;; JAPAN Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF355
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF355:
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_DATE_REPLACE ENDP					     ;;AN000;;
							     ;;
$M_GET_DATE PROC    NEAR				     ;;AN000;;
	    MOV     AH,DOS_GET_COUNTRY			     ;;AN000;; Call DOS for country dependant info
	    MOV     AL,0				     ;;AN000;; Get current country info
	    LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN000;; Set up addressibility to buffer
	    INT     21H 				     ;;AN000;;
;	    $IF     C					     ;;AN000;; No,
	    JNC $MIF357
	      MOV     WORD PTR $M_RT.$M_DATE_FORMAT,$M_DEF_DATE_FORM ;;AN000;;	 Set default date format    (BH)
	      MOV     BYTE PTR $M_RT.$M_DATE_SEPARA,$M_DEF_DATE_SEP ;;AN000;;	Set default date separator (BL)
;	    $ENDIF					     ;;AN000;;
$MIF357:
	    RET 					     ;;AN000;;
$M_GET_DATE ENDP					     ;;AN000;;
							     ;;
$M_YEAR     PROC    NEAR				     ;;AN000;;
	    MOV     AX,WORD PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Year
	    TEST    $M_SL.$M_S_FLAG,Date_MDY_4 AND $M_DATE_MASK ;;AN000;; Was Month/Day/Year (2 Digits) specified?
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF359
	      CMP     AX,$M_MAX_2_YEAR			     ;;AN000;;	Get Year
;	      $IF     A 				     ;;AN000;;
	      JNA $MIF360
		MOV	AX,$M_MAX_2_YEAR		     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF360:
;	    $ENDIF					     ;;AN000;;
$MIF359:
	    RET 					     ;;AN000;;
$M_YEAR     ENDP					     ;;AN000;;
							     ;;
$M_CONVERTDATE PROC NEAR				     ;;AN000;;
	    POP     WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    MOV     $M_RT.$M_SIZE,CL			     ;;AN000;; Save the size before conversion
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to an ASCII string
	    DEC     CX					     ;;AN000;; Test if size only grew by 1
	    CMP     CL,$M_RT.$M_SIZE			     ;;AN000;; Did size only grow by one
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF363
	      MOV     AX,$M_TIMEDATE_PAD		     ;;AN000;;	 Get a pad character (0)
	      PUSH    AX				     ;;AN000;;	 Save it
	      INC     CX				     ;;AN000;;	 Count it
;	    $ENDIF					     ;;AN000;;
$MIF363:
	    INC     CX					     ;;AN000;; Restore CX
	    PUSH    WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    RET 					     ;;AN000;;
$M_CONVERTDATE ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of DATE replace code
; 
	  IF	  TIMEmsg				     ;;AN000;; Is the request to include the code for TIME replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	  replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_TIME_REPLACE
;;
;;	FUNCTION: Convert a time to a decimal ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	REGS USED: BP,CX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_TIME_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    MOV     $M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
	    CALL    $M_GET_TIME 			     ;;AN000;; All O.K.?
	    TEST    $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK ;;AN000;; Is this a request for current country info?
;	    $IF     NZ					     ;;AN000;; Yes,
	    JZ $MIF365
	      CMP     BYTE PTR $M_RT.$M_TIME_FORMAT,0	     ;;AN000;; Is the current country format 12 Hour?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF366
		MOV	AL,BYTE PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Hours
		CMP	AL,12				     ;;AN000;;	Is hour 12 or less?
;		$IF	L,OR				     ;;AN000;;	 or
		JL $MLL367
		CMP	AL,23				     ;;AN000;;	  Is hour 24 or greater?
;		$IF	G				     ;;AN000;;	Yes,
		JNG $MIF367
$MLL367:
		  MOV	  AL,$M_AM			     ;;AN000;;
		  PUSH	  AX				     ;;AN000;;	  Push an "a" to represent AM.
		  INC	  CX				     ;;AN000;;
;		$ELSE					     ;;AN000;;	No,
		JMP SHORT $MEN367
$MIF367:
		  MOV	  AL,$M_PM			     ;;AN000;;
		  PUSH	  AX				     ;;AN000;;	  Push an "p" to represent PM.
		  INC	  CX				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MEN367:
;	      $ENDIF					     ;;AN000;;
$MIF366:
;	    $ENDIF					     ;;AN000;;
$MIF365:
							     ;;
	    XOR     AX,AX				     ;;AN000;;
	    XOR     DX,DX				     ;;AN000;;
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF372
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Hundreds
	      CALL    $M_CONVERTTIME			     ;;AN000;;
	      PUSH    WORD PTR $M_RT.$M_DECI_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF372:
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
;	    $IF     NZ,OR				     ;;AN000;;
	    JNZ $MLL374
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF374
$MLL374:
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Seconds
	      CALL    $M_CONVERTTIME			     ;;AN000;;
	      PUSH    WORD PTR $M_RT.$M_TIME_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF374:
							     ;;        Do Hour/Min (12 Hour)
	    MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+1	     ;;AN000;;	Get Minutes
	    CALL    $M_CONVERTTIME			     ;;AN000;;
	    PUSH    WORD PTR $M_RT.$M_TIME_SEPARA	     ;;AN000;;
	    INC     CX					     ;;AN000;;
							     ;;
	    MOV     AL,BYTE PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Hours
	    TEST    $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK ;;AN000;; Is this a request for current country info?
;	    $IF     NZ					     ;;AN000;; Yes,
	    JZ $MIF376
	      CMP     BYTE PTR $M_RT.$M_TIME_FORMAT,0	     ;;AN000;; Is the current country format 12 Hour?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF377
		CMP	AL,13				     ;;AN000;;	Is hour less than 12?
;		$IF	GE				     ;;AN000;;	Yes,
		JNGE $MIF378
		  SUB	  AL,12 			     ;;AN000;;	  Set to a 12 hour value
;		$ENDIF					     ;;AN000;;
$MIF378:
		CMP	AL,0				     ;;AN000;;	Is hour less than 12?
;		$IF	E				     ;;AN000;;	Yes,
		JNE $MIF380
		  MOV	  AL,12 			     ;;AN000;;	  Set to a 12 hour value
;		$ENDIF					     ;;AN000;;
$MIF380:
;	      $ENDIF					     ;;AN000;;
$MIF377:
;	    $ENDIF					     ;;AN000;;
$MIF376:
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to ASCII
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_TIME_REPLACE ENDP					     ;;AN000;;
							     ;;
$M_GET_TIME PROC    NEAR				     ;;AN000;;
	    MOV     AH,DOS_GET_COUNTRY			     ;;AN000;; Call DOS for country dependant info
	    MOV     AL,0				     ;;AN000;; Get current country info
	    LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN000;; Set up addressibility to buffer
	    INT     21H 				     ;;AN000;;
;	    $IF     C					     ;;AN000;; No,
	    JNC $MIF384
	      MOV     WORD PTR $M_RT.$M_TIME_FORMAT,$M_DEF_TIME_FORM ;;AN000;;	 Set default time format    (BH)
	      MOV     BYTE PTR $M_RT.$M_TIME_SEPARA,$M_DEF_TIME_SEP ;;AN000;;	Set default time separator (BL)
	      MOV     BYTE PTR $M_RT.$M_DECI_SEPARA,$M_DEF_DECI_SEP ;;AN000;;	Set default time separator (BL)
;	    $ENDIF					     ;;AN000;;
$MIF384:
	    RET 					     ;;AN000;;
$M_GET_TIME ENDP					     ;;AN000;;
							     ;;
$M_CONVERTTIME PROC NEAR				     ;;AN000;;
	    POP     WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    MOV     $M_RT.$M_SIZE,CL			     ;;AN000;; Save the size before conversion
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to an ASCII string
	    DEC     CX					     ;;AN000;; Test if size only grew by 1
	    CMP     CL,$M_RT.$M_SIZE			     ;;AN000;; Did size only grow by one
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF386
	      MOV     AX,$M_TIMEDATE_PAD		     ;;AN000;;	 Get a pad character (0)
	      PUSH    AX				     ;;AN000;;	 Save it
	      INC     CX				     ;;AN000;;	 Count it
;	    $ENDIF					     ;;AN000;;
$MIF386:
	    INC     CX					     ;;AN000;; Restore CX
	    PUSH    WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    RET 					     ;;AN000;;
$M_CONVERTTIME ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of TIME replace
	ENDIF						     ;;AN000;; END of include of Replacement common code
; 
	IF	INPUTmsg				     ;;AN000;; Is the request to include the code for NUM replace?
	  INPUTmsg =	FALSE				     ;;AN000;; Yes, THEN include it and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_WAIT_FOR_INPUT
;;
;;	FUNCTION:  To accept keyed input and return extended key value
;;		   in AX register
;;	INPUTS:    DL contains the DOS function requested for input
;;	OUPUTS:    AX contains the extended key value that was read
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_WAIT_FOR_INPUT PROC NEAR				     ;;AN000;;
							     ;;
	  PUSH	  CX					     ;;AN000;; Save CX
	  PUSH	  DX					     ;;AN000;; Save DX
	  PUSH	  DS					     ;;AN000;; Save Data segment
							     ;;
	  CMP	  DL,DOS_CLR_KEYB_BUF_MASK		     ;;AN001;; Are we to clear the keyboard buffer?
;	  $IF	  A					     ;;AN001;; Yes,
	  JNA $MIF388
	    MOV     AL,DL				     ;;AN001;;	 Mov function into AL
	    AND     AL,LOW_NIB_MASK			     ;;AN001;;	 Mask out the C in high nibble
	    MOV     AH,DOS_CLR_KEYB_BUF 		     ;;AN001;;	 Set input function
;	  $ELSE 					     ;;AN001;; No,
	  JMP SHORT $MEN388
$MIF388:
	    MOV     AH,DL				     ;;AN000;;	 Put DOS function in AH
;	  $ENDIF					     ;;AN001;;
$MEN388:
	  PUSH	  ES					     ;;AN000;; Get output buffer segment
	  POP	  DS					     ;;AN000;;
	  MOV	  DX,DI 				     ;;AN000;;	 Get output buffer offset in case needed
	  INT	  21H					     ;;AN000;; Get keyboard input
	  POP	  DS					     ;;AN000;;

	  CMP	  DL,DOS_BUF_KEYB_INP			     ;;AN000;;
	  CLC						     ;;AN000;;
;	  $IF	  NE					     ;;AN000;; If character input
	  JE $MIF391
	    CALL    $M_IS_IT_DBCS			     ;;AN000;;	Is this character DBCS?
;	    $IF     C					     ;;AN000;;
	    JNC $MIF392
	      MOV     CL,AL				     ;;AN000;; Save first character
	      MOV     AH,DL				     ;;AN001;; Get back function
	      INT     21H				     ;;AN000;; Get keyboard input
	      MOV     AH,CL				     ;;AN000;; Retreive first character  AX = xxxx
	      CLC					     ;;AN000;; Clear carry condition
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN392
$MIF392:
	      MOV     AH,0				     ;;AN000;; AX = 00xx where xx is SBCS
;	    $ENDIF					     ;;AN000;;
$MEN392:
;	  $ENDIF					     ;;AN000;;
$MIF391:
							     ;;
;	  $IF	  NC					     ;;AN000;;
	  JC $MIF396
	    POP     DX					     ;;AN000;;
	    POP     CX					     ;;AN000;;
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN396
$MIF396:
	    ADD     SP,4				     ;;AN000;;
	    STC 					     ;;AN000;; Reset carry flag
;	  $ENDIF					     ;;AN000;;
$MEN396:
	  RET						     ;;AN000;; Return
							     ;;
$M_WAIT_FOR_INPUT ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of Wait for Input
      ENDIF						     ;;AN000;; END of include of SYSDISPMSG
    ENDIF						     ;;AN000;; END of include of MSG_DATA_ONLY
ENDIF							     ;;AN000;; END of include of Structure only


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mshead.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)mshead.asm	1.1 85/04/10
; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
PAGE
; MS-DOS  High-performance operating system for the 8086  version 1.28
;	by Microsoft MSDOS development group:
;	    Tim Paterson (Ret.)
;	    Aaron Reynolds
;	    Nancy Panners (Parenting)
;	    Mark Zbikowski
;	    Chris Peters (BIOS) (ret.)

; ****************** Revision History *************************
;	   >> EVERY change must noted below!! <<
;
; 0.34 12/29/80 General release, updating all past customers
; 0.42 02/25/81 32-byte directory entries added
; 0.56 03/23/81 Variable record and sector sizes
; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
; 0.74 04/15/81 Recognize I/O devices with file names
; 0.75 04/17/81 Improve and correct buffer handling
; 0.76 04/23/81 Correct directory size when not 2^N entries
; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
; 1.00 04/28/81 Renumber for general release
; 1.01 05/12/81 Fix bug in `STORE'
; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
;		RENAME fix, general cleanup
; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
;		FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
;		of smaller improvements
; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
;		zero extent field in IBM version (back to 1.01!)
; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
;		is searched first when possible to minimize I/O
;      03/03/82 STORE routine optimized to tack on partial sector tail as
;		full sector write when file is growing
;      03/09/82 Multiple I/O buffers
;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
;		of directory (infinite loop possible otherwise), DSKRESET
;		must invalidate all buffers (disk and directory).
; 1.27 03/31/82 Installable device drivers
;		  Function call 47 - Get pointer to device table list
;		  Function call 48 - Assign CON AUX LIST
;      04/01/82 Spooler interrupt (INT 28) added.
; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
;		call entries.  Most CS relative references changed to SS
;		relative with an eye toward putting a portion of the DOS in
;		ROM.  DOS source also broken into header, data and code pieces
;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
;		return the current values.
;      04/15/82 INDOS flag implemented for interrupt processing along with
;		call to return flag location (call 29)
;      04/15/82 Volume ID attribute added
;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
;		avoid a CS relative reference.
;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
;      04/20/82 Added INT int_upooler into loop ^S wait
;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
;		call 49.
;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
;		address of DPB
;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
;		writting to console device via file I/O.  Added a console
;		output attribute to devices.
;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
;		as devices....	pipes, redirection now possible
;      04/30/82 Expanded GETLIST call to 2.0 standard
;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
;		(data segment) stashed in ES, INT int_fatal_abort routines must
;		preserve ES.  This mod so HARDERR can be ROMed.
; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
;		out back about 1.27 or so (oops).  ARR
; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
;		RMDIR Xenix calls
; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
;		Frees up lots of memory.
; 1.51 06/24/82 BREAKDOWN Revised to do EXACT one sector read/write through
;		system buffers
; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
;		changed to set file handle environment.
; 2.00 08/01/82 Number for IBM release
;      01/19/83 No environ bug in EXEC
;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
;      01/19/83 Performance bug fix in cooked write to NUL
;      01/27/83 Growcnt fixed for 32-bits
;      01/27/83 Find-first problem after create
; 2.01 02/17/83 International DOS
; 2.10 03/09/83 Start of NETWORK support
;		New Buffer structure
;		New Sytem file table structure
;		FCB moved to internal representation
;		DOS re-organized
; 2.11 04/21/83 Continuation of 2.10, preliminary Network
;		device interface.
; 2.50 09/12/83 More network stuff
;
; *************************************************************

;INCLUDE DOSSYM.INC
;INCLUDE DEVSYM.INC
include origin.inc


Break <SEGMENT DECLARATIONS>

; The following are all of the segments used.  They are declared in the order
; that they should be placed in the executable

;
; segment ordering for MSDOS
;

include dosseg.inc

AsmVar	<Installed>


;M022;IFNDEF IS_SHARE
;M022;	EXTRN	LIE_TABLE_LEN:ABS
;M022;	EXTRN	LIE_TABLE_OFFSET:ABS
;M022;ENDIF

DOSCODE		SEGMENT BYTE PUBLIC 'CODE'

PUBLIC	$STARTCODE
$STARTCODE	LABEL WORD

	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

; If this is disk-based DOS, then the entry point at initialization time
; will be to right here.  A jump will be made to the initialization code,
; which is at the end of the code segment.  Also, a word here (at offset 3)
; contains the offset within the DOSCODE segment of the beginning of the
; DOS code.
;
; For ROMDOS, however, these things are not needed.  The code segment will
; already be resident in ROM, and the startup entry from the BIOS will be
; directly into the initialization segment, DOSINITSEG.
;

ifndef ROMDOS

	Extrn	DOSINIT:NEAR

	JMP	near ptr DOSINIT

; The next word contains the ORG value to which the DOS has been ORGd
; See origin.inc for description.

	dw	PARASTART

endif ; ROMDOS


;hkn; Segment address of BIOS data segment in RAM
	PUBLIC	BioDataSeg
BioDataSeg	dw	70h		;Bios data segment fixed at 70h


;M022;IFNDEF IS_SHARE
;M022;	LieTableOffset	dw	LIE_TABLE_OFFSET - PARASTART
;M022;	LieTableLen	dw	LIE_TABLE_LEN
;M022;ELSE
;M022;	LieTableOffset	dw	0
;M022;	LieTableLen	dw	0
;M022;ENDIF
;M022;
;M022;	Signature	db	"PCMN", 0

;
; DosDSeg is a data word in the DOSCODE segment that is loaded with
; the segment address of DOSDATA.  This is purely an optimization, that
; allows getting the DOS data segment without going through the 
; BIOS data segment.  It is used by the "getdseg" macro.
;
; DosDSeg is allocated only if it is NOT ROMDOS. If it is ROMDOS,
; no memory is allocated unless debug is on. If ROMDOS & DEBUG then
; a debug word is allocated which is initialized to 1234h. Ideally
; this debug word should not be used by anybody. It is declared just
; to check wether somebody is trying to access/update it.
;

ifndef ROMDOS
		public	DosDSeg
DosDSeg		dw	?

else

if debug
  		public	DosDSeg
DosDSeg		dw	1234h

endif ; debug

endif ; ROMDOS

		

DOSCODE		ENDS


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\oemnum.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; DOS OEM number assignments.
; This file is for documentation purposes only.  It lists the currently
; assigned OEM numbers, for use with the DOS GetVersion call.
;
; IBM DOS             (00)
; Compaq DOS          (01)
; MS Packaged Product (02)
; AT&T DOS            (04)
; Zenith DOS          (05)
; HP DOS              (06)
; Zenith DOS for DOS 5.0 and later      (07)
; Tandon              (08)
; AST                 (09)
; Asem                (10)
; Hantarex            (11)
; SystemsLine         (12)
; Packard Bell        (13)
; Intercomp           (14)
; Unibit              (15)
; Unidata             (16)
; Olivetti DOS        (23)
; Undefined           (255)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\oemconf.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	OemConf.inc - Equates configurable by ROM DOS Oems
;
ifdef	ROMEXEC

ROMEXEC_SEG	equ	0C000h		; ROM start address of ROM module
					;  where ROM executable programs
					;  are stored
					;
					; This is where ROM scans start
					; when looking for ROM executable
					; programs.  If set to A000h, 
					; Windows may think we're dickering
					; with video memory and call us
					; a high resolution video app.

endif

DEFAULT_BUFFERS	equ	-1		; if initialized to -1 sysinit
					; will use the logic described
					; in "dodefaultbuff" in sysinit1.asm
DEFAULT_FILES	equ	8
DEFAULT_FCBS	equ	4
DEFAULT_CDSS	equ	5



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\mult.inc ===
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;

;       SCCSID = @(#)mult.asm   1.2 85/04/12
	Break <Multiplex channels>

; The current set of defined multiplex channels is (* means documented):
;
;   Channel(h)  Issuer          Receiver    Function
;      00       server          PSPRINT     print job control
;     *01       print/apps      PRINT       Queueing of files
;      02       BIOS            REDIR       signal open/close of printers
;
;      05       command         REDIR       obtain text of net int 24 message
;     *06       server/assign   ASSIGN      Install check
;
;      08       external driver IBMBIO      interface to internal routines
;
;      10       sharer/server   Sharer      install check
;      11       DOS/server      Redir       install check/redirection funcs
;      12       sharer/redir    DOS         dos functions and structure maint
;      13       MSNET           MSNET       movement of NCBs
;      13       external driver IBMBIO      Reset_Int_13, allows installation
;                                           of alternative INT_13 drivers after
;                                           boot_up
;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
;      15       APPS            MSCDEX      CD-ROM extensions interface
;      16       WIN386          WIN386      Windows communications
;      17       Clipboard       WINDOWS     Clipboard interface
;     *18       Applications    MS-Manger   Toggle interface to manager
;      19       Shell
;      1A       Ansi.sys
;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
;
;      40h      OS/2
;      41h      Lanman
;      42h      Lanman
;      43h      Himem
;                               AL = 20h    reserved for Mach 20 Himem support
;                               AL = 30h    reserved for Himem external A20 code
;      44h      Dosextender
;      45H      Windows profiler
;      46h      Windows/286 DOS extender
;      47h      Basic Compiler Vn. 7.0
;      48h      Doskey
;      49h      DOS 5.x install 
;      4ah      Multi Purpose
;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
;                multMULTGETHMAPTR      1 - Get available HMA & ptr
;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
;                multMULTTASKSHELL      5 - Shell/switcher API
;                multMULTRPLTOM         6 - Top Of Memory for RPL support
;
;                multSmartdrv           10h
;                multMagicdrv           11h
;      4bh      Task Switcher API
;
;      4ch      APPS            APM             Advanced power management
;      4dh      Kana Kanji Converter, MSKK
;
;      51h      ODI real mode support driver (for Chicago)
;
;      53h      POWER.EXE - used for broadcasting APM events    ; M036
;      54h      POWER.EXE - used for POWER API                  ; M036
;
;      55h      COMMAND.COM
;                multCOMFIRST           0 - API to determine whether 1st
;                                           instance of command.com
;                multCOMFIRSTROM        1 - API to determine whether 1st
;                                           instance of ROM COMMAND
;      56h      Sewell Development
;               INTERLNK
;
;      57h      Iomega Corp.
;
;      AB       Unspecified IBM use
;      AC       Graphics
;      AD       NLS (toronto)
;      AE
;      AF       Mode
;      B0       GRAFTABL        GRAFTABL
;
;      D7       Banyan VINES


;MUX 00-3F reserverd for IBM
;MUX 80-BF reserverd for IBM

;MUX 40-7F reserved for Microsoft

;MUX C0-FF users



MultSHARE   EQU     10h                 ; sharer
    ;   1   MFT_enter
    ;   2   MFTClose
    ;   3   MFTclU
    ;   4   MFTCloseP
    ;   5   MFTCloN
    ;   6   set_block
    ;   7   clr_block
    ;   8   chk_block
    ;   9   MFT_get
    ;   10  ShSave
    ;   11  ShChk
    ;   12  ShCol
    ;   13  ShCloseFile

MultNET     EQU     11h                 ; Network support
MultIFS     EQU     11h                 ; Network support
    ;   1   IFS_RMDIR
    ;   2   IFS_SEQ_RMDIR
    ;   3   IFS_MKDIR
    ;   4   IFS_SEQ_MKDIR
    ;   5   IFS_CHDIR
    ;   6   IFS_CLOSE
    ;   7   IFS_COMMIT
    ;   8   IFS_READ
    ;   9   IFS_WRITE
    ;   10  IFS_LOCK
    ;   11  IFS_UNLOCK
    ;   12  IFS_DISK_INFO
    ;   13  IFS_SET_FILE_ATTRIBUTE
    ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
    ;   15  IFS_GET_FILE_INFO
    ;   16  IFS_SEQ_GET_FILE_INFO
    ;   17  IFS_RENAME
    ;   18  IFS_SEQ_RENAME
    ;   19  IFS_DELETE
    ;   20  IFS_SEQ_DELETE
    ;   21  IFS_OPEN
    ;   22  IFS_SEQ_OPEN
    ;   23  IFS_CREATE
    ;   24  IFS_SEQ_CREATE
    ;   25  IFS_SEQ_SEARCH_FIRST
    ;   26  IFS_SEQ_SEARCH_NEXT
    ;   27  IFS_SEARCH_FIRST
    ;   28  IFS_SEARCH_NEXT
    ;   29  IFS_ABORT
    ;   30  IFS_ASSOPER
    ;   31  Printer_SET_STRING
    ;   32  IFSFlushBuf
    ;   33  IFSBufWrite
    ;   34  IFSResetEnvironment
    ;   35  IFSSpoolCheck
    ;   36  IFSSpoolClose
    ;   37  IFSDeviceOper
    ;   38  IFSSpoolEchoCheck
    ;   39      - - -   Unused   - - -
    ;   40      - - -   Unused   - - -
    ;   41      - - -   Unused   - - -
    ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
    ;   43  DEVICE_IOCTL
    ;   44  IFS_UPDATE_CB
    ;   45  IFS_FILE_XATTRIBUTES
    ;   46  IFS_XOPEN
    ;   47  IFS_DEPENDENT_IOCTL

MultDOS     EQU     12h                 ; DOS call back
    ;   1   DOS_CLOSE
    ;   2   RECSET
    ;   3   Get DOSGROUP
    ;   4   PATHCHRCMP
    ;   5   OUT
    ;   6   NET_I24_ENTRY
    ;   7   PLACEBUF
    ;   8   FREE_SFT
    ;   9   BUFWRITE
    ;   10  SHARE_VIOLATION
    ;   11  SHARE_ERROR
    ;   12  SET_SFT_MODE
    ;   13  DATE16
    ;   14  Unused              (was SETVISIT)
    ;   15  SCANPLACE
    ;   16  Unused              (was SKIPVISIT)
    ;   17  StrCpy
    ;   18  StrLen
    ;   19  Ucase
    ;   20  POINTCOMP
    ;   21  CHECKFLUSH
    ;   22  SFFromSFN
    ;   23  GetCDSFromDrv
    ;   24  Get_User_Stack
    ;   25  GetThisDrv
    ;   26  DriveFromText
    ;   27  SETYEAR
    ;   28  DSUM
    ;   29  DSLIDE
    ;   30  StrCmp
    ;   31  initcds
    ;   32  pjfnfromhandle
    ;   33  $NameTrans
    ;   34  CAL_LK
    ;   35  DEVNAME
    ;   36  Idle
    ;   37  DStrLen
    ;   38  NLS_OPEN      DOS 3.3
    ;   39  $CLOSE        DOS 3.3
    ;   40  NLS_LSEEK     DOS 3.3
    ;   41  $READ         DOS 3.3
    ;   42  FastInit      DOS 4.0
    ;   43  NLS_IOCTL     DOS 3.3
    ;   44  GetDevList    DOS 3.3
    ;   45  NLS_GETEXT    DOS 3.3
    ;   46  MSG_RETRIEVAL DOS 4.0
    ;   47  FAKE_VERSION  DOS 4.0
    ;
NLSFUNC     EQU     14h                 ; NLSFUNC CALL , DOS 3.3
    ;   0   NLSInstall
    ;   1   ChgCodePage
    ;   2   GetExtInfo
    ;   3   SetCodePage
    ;   4   GetCntry
    ;

multANSI    EQU     1Ah                 ; ANSI multiplex number
    ;   0   INSTALL_CHECK               ; install check for ANSI
    ;   1   IOCTL_2F                    ; 2F interface to IOCTL
    ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.

multMULT        EQU     4ah
multMAGIC       EQU     256*multMULT + 11h
 multMULTRPLTOM EQU     06h

    ;   0   swap disk function for single floppy drive m/cs
    ;       BIOS broadcasts with cx==0, and apps who handle
    ;       swap disk messaging set cx == -1. BIOS sets dl == requested
    ;       drive
    ;
    ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
    ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
    ;       returns pointer in ES:DI
    ;
    ;   3-4 currently used by nobody
    ;   5   Switcher API
    ;   6   Top of Memory for RPL.
    ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
    ;           code present in TOM should respond with a new TOM in DX
    ;           to protect itself from MSLOAD & SYSINIT tromping over it.
    ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
    ;           protect the RPL code from COMMAND.COM transient protion.
    ;           It is the responsibility of RPL program to release the mem.
    ;   7   Reserved for PROTMAN support.
    ;  10   smartdrv 4.0
    ;  11   dblspace api
    ;  12   MRCI     api
    ;  13   dblspace/mrci stealth packet api

MultAPM         EQU     4ch             ; Obselete ???
    ;       00h     APM_VER_CHK
    ;       01h     APM_SUS_SYS_REQ
    ;       FFh     APM_SUS_RES_BATT_NOTIFY


MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast        ; M036
				;  APM events                           ; M036
MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API    ; M036


;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
;         it calls Multdos 42 to set up an entry routine address
    ;   0   Install status  (reserved)
    ;   1   Lookup
    ;   2   Insert
    ;   3   Delete
    ;   4   Purge           (reserved)

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\origin.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;-------------------------------------------------------------------------
;
; FILE : ORIGIN.INC
;
; This is included in origin.asm and mshead.asm. Contains the equate that
; is used for ORGing the DOS code.
;
; Brief Description of the necessacity of this ORG:
; -------------------------------------------------
;
; A special problem exits when running out of the HMA. The HMA starts at 
; address FFFF:10. There is no place in the HMA with an offset of zero.
; This means programs running out off the HMA must use non-zero offset base
; addresses. It also means that if we're running multiple programs from the
; HMA, the base offset of each segment must atleast be as big as all of the
; HMA segments that precede it.
; 
; One solution to this problem to ORG each module at 64K minus its size.
; For instance a code segment 1234h bytes in length would org'd at edcbh.
; This gives max. flexibility regarding it's location in the HMA. By 
; selecting segment values between f124h and ffffh it could be located 
; anywhere in the HMA. The problem with this is that programs with such 
; high ORGs would not be able to run in low RAM.
;
; A comporomise solution is to set the ORG address somewhere between 0010h
; and ffffh - their size. In the particular case of the BIOS and the DOS 
; the folloowing solution has been implemented:
;
; The Bios Code segment will have a very small offset and run at the very
; front of the HMA, after the VDISK header. THE Dos Code segment will have 
; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
; DATA segment when DOS is running low>). This will reflect the lowest 
; possible physical address at which DOS code will run, while still providing
; max. possible flexibility in HMA positioning. This offset MUST NOT be 
; smaller then that 20+size of Bios Code segment when running high. This is 
; mostly true.
;
; Also this ORG'd value must be communicated to the BIOS. This is done by
; putting this value after the first jmp instruction in the DOS code in
; mshead.asm. 
;
; In order for the stripz utility to know how many zeroes to be stripped 
; out, this value is placed at the beginning of the binary in origin.asm.
;
; Revision History:
;
; Currently this is being done manually. Therefore any change in the DOS DATA
; Size or the BIOS size should be reflected here. --- Feb 90
;
; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
; A utility called getsize will obtain the corresponding values from msdos
; and msbio.map and update the values in BDSIZ.INC if they are different. 
; DOS should now be built using the batch file makedos.bat which invokes this
; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
; dependant on that.				  --- Apr 3 '90
;
; For ROMDOS, however, there is no need to org the doscode to any location
; other than zero.  Therefore the stripz utility will not need to be used,
; so the offset will not need to be included at the beginning of the code
; segment.  Also, the BIOS can just assume that the resident code begins
; at offset zero within the segment.
; 
;
;--------------------------------------------------------------------------
 	
; 	

BIODATASTART	EQU    	00700h
include	bdsize.inc		; this sets the values:
				;	BIODATASIZ
				;	BIOCODESIZ
				;	DOSDATASIZ

ifndef ROMDOS

BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	

else

BYTSTART	EQU	0
PARASTART	EQU	0

endif ; ROMDOS



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\parse.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

	PAGE				;AN000;
;  $SALUT (4,4,8,41)
;(deleted).XLIST
;(deleted)INCLUDE   STRUC.INC ;AN020;structured macro definitions for .IF,.ELSE etc.
;(deleted).LIST
;
;Revision History
;================
;
; M029	02/15/91 SR	Bug #5699. In SysParse, reinitialize $P_FileSp_Char
;			everytime because this is in the non-checksum region
;			and can get corrupted without the checksum region
;			getting corrupted. Yet another data structure that
;			should have been in the checksum region but isnt.
;


;
; NOTE:   basesw must be set properly to allow the PARSER to access psdata.
;	   - basesw undefined	 means	 CS seg. override for psdata access.
;	   - basesw = 1 	 means	 DS seg. override for psdata access &
;					 DS must point to psdata.
;	   - basesw = 0 	 means	 ES seg. override for psdata access &
;					 ES must point to psdata.
;
;
IFNDEF basesw				;AN022;
   psdata_seg EQU   CS			;AN022;
ELSE					;AN022;
   IF  basesw				;AN022;IF "basesw  EQU  1" specified by caller THEN
       psdata_seg EQU	DS		;AN022;
   ELSE 				;AN022;
       psdata_seg EQU	ES		;AN022;ELSE only other choice is ES (basesw EQU 0)
   ENDIF				;AN022;
ENDIF					;AN022;

ifndef incsw				;AN000; (tm03) Someone doesn't want to include psdata
   incsw equ	 1			;AN000; include psdata.inc (tm03)
endif					;AN000; (tm03)
if incsw				;AN000; If incsw = 1 then (tm03)
   include psdata.inc			;AN000;    include psdata.inc (tm03)
endif					;AN000; endif		  (tm03)
   PAGE 				;AN000;
IF1					;AN000;
;   %OUT INCLUDING COMP=COMMON DSN=PARSE.ASM...;AN000;
ENDIF					;AN000;
;***********************************************************************
; SysParse;
;
;  Function : Parser Entry
;
;  Input: DS:SI -> command line
;	  ES:DI -> parameter block
;	  psdata_seg -> psdata.inc
;	  CX = operand ordinal
;
;	  Note:  ES is the segment containing all the control blocks defined
;		 by the caller, except for the DOS COMMAND line parms, which
;		 is in DS.
;
;  Output: CY = 1   error of caller, means invalid parameter block or
;		    invalid value list. But this parser does NOT implement
;		    this feature. Therefore CY always zero.
;
;	   CY = 0   AX = return code
;		    BL = terminated delimiter code
;		    CX = new operand ordinal
;		    SI = set past scaned operand
;		    DX = selected result buffer
;
; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
;	$P_Chk_Sw_Control, $P_Fill_Result
;
; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
;
;-------- Modification History -----------------------------------------
;
;  4/04/87 : Created by K. K,
;  4/28/87 : $P_Val_YH assemble error (tm01)
;	   : JMP SHORT assemble error (tm02)
;  5/14/87 : Someone doesn't want to include psdata (tm03)
;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
;	     DateSW equ 1)	      (tm04)
;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
;				      (tm05) in PSDATA.INC
;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
;	     value-list block	      (tm07)
;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
;	     switch (keyword) or not. If there is, backup si for next call
;	     (tm08)
;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
;	     /+15 and /+:15 are allowed for user (tm10)
;  6/29/87 : ECS call changes DS register but it causes the address problem
;	     in user's routines. $P_Chk_DBCS (tm11)
;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
;					  (tm12)
;  7/10/87 : Invalid switch/keyword does not work correctly
;					  (tm13)
;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
;					  (tm14)
;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
;					  (tm15)
;  7/24/87 : Negative lower bound on numeric ranges cause trouble

;  7/24/87 : Quoted strings being returned with quotes.

;  7/28/87 : Kerry S (;AN018;)
;	     Non optional value on switch (match flags<>0 and <>1) not flagged
;	     as an error when missing.	Solution: return error 2.  Modules
;	     affected: $P_Chk_SW_Control.

;  7/29/87 : Kerry S (;AN019;)
;	     Now allow the optional bit in match flags for switches.  This
;	     allows the switch to be encountered with a value or without a
;	     value and no error is returned.
;

;  8/28/87 : Ed K, Kerry S (;AN020;)
;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
;	     within a date response, instead of checking just for the one
;	     character defined by the COUNTRY DEPENDENT INFO, check for
;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
;	     slashes in date strings when DateSw (assembler switch) is set.

;  9/1/87  : Kerry S (;AN021)
;	     In PROC $P_String_Comp, when comparing the switch or keyword on
;	     the command line with the string in the control block the
;	     comparing was stopping at a colon (switch) or equal (keyword)
;	     on the command line and assuming a match.	This allowed a shorter
;	     string on the command line than in the synonym list in the control
;	     block.  I put in a test for a null in the control block so the
;	     string in the control block must be the same length as the string
;	     preceeding the colon or equal on the command line.

;  8/28/87 : Kerry S (;AN022;)
;	     All references to data in PSDATA.INC had CS overrides.  This caused
;	     problems for people who included it themselves in a segment other
;	     than CS.  Added switch to allow including PSDATA.INC in any
;	     segment.

;  9/16/87 : Ed K (;AN023;) PTM1040
;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
;	     forced both TIME and DATE to use the delims, "-","/",".".
;	     Created FLag, in $P_time_Format PROC, to request the delim in
;	     BL be used if TIME is being parsed.

;  9/24/87 : Ed K
;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
;	     invocations with their normally expanded code; made comments
;	     out of the STRUC macro invocation statements to maintain readability.

;  9/24/87 : Ed K (;AN024;) PTM1222
;	     When no CONTROL for a keyword found, tried to fill in RESULT
;	     pointed to by non-existant CONTROL.

; 10/15/87 : Ed K (;AN025;) PTM1672
;	     A quoted text string can be framed only by double quote.  Remove
;	     support to frame quoted text string with single quote.
;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
;	     single quote in PROC prologues are left as is for history reasons.

;	     This fixes another bug, not mentioned in p1672, in that two
;	     quote chars within a quoted string is supposed to be reported as
;	     one quote character, but is reported as two quotes.  This changed
;	     two instructions in PROC $P_Quoted_Str.

;	     Also fixed are several JMP that caused a NOP, these changed to
;	     have the SHORT operator to avoid the unneeded NOP.

;	     The code and PSDATA.INC have been aligned for ease of reading.

; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
;	     psdata buffer should have psdata_seg.

; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
;	     positional missing.

; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
;	     as a line delimiter, should use carriage return.
;	     Define switch: LFEOLSW, if on, accept LF as end of line char.

; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".

; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
;	     endless loop since SI is returned still pointing to start
;	     of that parm.

; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
;	     Vector to returned string has CS instead of Psdata_Seg, but
;	     when tried to fix it on previous version, changed similar
;	     but wrong place.

; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
;	     delimiters between hours, minutes, seconds for time. And period
;	     and comma are valid delimiters between seconds and 100th second.

; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
;	     in a filespec, then flag an error.

; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
;	     indexed off of the psdata_seg equate instead of the DS register.
;	     Using this method, DS can point to the segment of PSP or to psdata
;  -->	     local parser data. Why were some references to local data changed
;	     to do this before, but not all ?????

; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.

; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
;
; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.

; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error

; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
;	     separator in TIME before hundredths field.
;
; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
;			strings as keywords.
;
;***********************************************************************
IF FarSW				;AN000;(Check if need far return)
SysParse proc far			;AN000;
ELSE					;AN000;
SysParse proc near			;AN000;
ENDIF					;AN000;(of FarSW)
;	$SALUT	(4,9,17,41)
	mov	psdata_seg:$P_Flags,0	;AC034; Clear all internal flags
IF	TimeSw				;AN039; FOR TIME ONLY
	MOV    PSDATA_SEG:$P_ORIG_ORD,CX ;AN039; ORIGINAL ORDINAL FROM CX
	MOV    PSDATA_SEG:$P_ORIG_STACK,SP ;AN039; ORIGINAL VALUE OF STACK FROM SP
	MOV    PSDATA_SEG:$P_ORIG_SI,SI ;AN039; ORIGINAL START PARSE POINTER FROM SI
$P_REDO_TIME:				;AN039; try to parse time again
ENDIF					;AN039; FOR TIME ONLY
	cld				      ;AN000; confirm forward direction
	mov	psdata_seg:$P_ordinal,cx      ;AC034; save operand ordinal
	mov	psdata_seg:$P_RC,$P_No_Error  ;AC034; Assume no error
	mov	psdata_seg:$P_Found_SYNONYM,0 ;AC034; initalize synonym pointer

	mov	word ptr psdata_seg:$P_DX,0   ;AC034; (tm15)

;M029 -- Begin changes
; The table of special chars $P_FileSp_Char should be initialized on every
;entry to SysParse. This is in the non-checksum region and any program that
;corrupts this table but does not corrupt the checksum region will leave
;command.com parsing in an inconsistent state.
; NB: The special characters string has been hardcoded here. If any change
;is made to it in psdata.inc, a corresponding change needs to be made here.
;
IF FileSW + DrvSW

	mov	word ptr psdata_seg:$P_FileSp_Char, ']['
	mov	word ptr psdata_seg:$P_FileSp_Char+2, '<|'
	mov	word ptr psdata_seg:$P_FileSp_Char+4, '+>'
	mov 	word ptr psdata_seg:$P_FileSp_Char+6, ';='

ENDIF
;
;M029 -- End of changes
;

IF KeySW				;AN029;
;IN CASE THE USER PUT OPTIONAL WHITESPACE CHARS AROUND THE "=" USED IN
;KEYWORD DEFINITIONS, SCAN THE COMMAND LINE AND COMPRESS OUT ANY WHITESPACES
;NEXT TO "=" BEFORE STARTING THE USUAL PARSING.
       push	 cx			;AN029;
       push	 dx			;AN029;
       push	 di			;AN029;

       push	 si			;AN029; remember where command line starts
       mov	 cx,-1			;AN029; init counter
;      $do
$P_loc_eol:				;AN029;
	  inc	    cx			;AN029; bump counter of chars up to EOL
	  lodsb 			;AN029; get a char from command line
	  CALL	    $P_Chk_EOL		;AN029; see if AL is EOL char

;      enddo z
       jnz	 $P_loc_EOL		;AN029; not found that EOL char

       mov	 psdata_seg:$P_count_to_EOL,cx ;AN029;AC034;; save count of chars up to EOL
       pop	 si			;AN029; restore start of command line

;scan command string for combinations including "=",
;      and replace each with just the simple "="

;REPEAT UNTIL ONE PASS IS MADE WHEREIN NO CHANGES WERE MADE
;  $do
$P_DO1: 			   ;AN029;
       push si			   ;AN029; remember where string started
       MOV  CX,psdata_seg:$P_COUNT_TO_EOL ;AN029;AC034;; set  count to no. chars in string,
				   ;AN029; not counting the EOL char
       XOR  BX,BX		   ;AN029;SET $P_REG_BL_DQ_SW TO "NOT IN QUOTES", AND...
				   ;AN029;SET $P_REG_BH_CG_SW TO "NO CHANGES MADE"
;MAKE ONE PASS THRU THE STRING, LOOKING AT EACH CHARACTER
;      $do			   ;AN029;
$P_DO2: 			   ;AN029;
	   cmp	BYTE PTR [SI],$P_double_quote ;AN029;
;	   $if	e		   ;AN029;if a double quote was found
	   JNE $P_IF3		   ;AN029;
	       NOT  $P_REG_BL_DQ_SW ;AN029;TOGGLE THE DOUBLE QUOTE STATE SWITCH
;	   $endif		   ;AN029;
$P_IF3: 			   ;AN029;
	   OR	$P_REG_BL_DQ_SW,$P_REG_BL_DQ_SW ;AN029;IS THE DOUBLE QUOTE SWITCH SET?
;	   $if	Z		   ;AN029;IF NOT IN DOUBLE QUOTES
	   JNZ $P_IF5		   ;AN029;
	       mov  ax,word ptr [si] ;AN029; get pair to be checked out
	       cmp  ax,$P_BL_EQ    ;AN029;" ="
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_EQ_BL    ;AN029;"= "
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_EQ_TB    ;AN029; "=<tab>"
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_TB_EQ    ;AN029;"<tab>="
;	       $if  e		   ;AN029;if this pair to be replaced with a single "="
	       JNE $P_IF6	   ;AN029;
$P_LL6: 			   ;AN029;
		   mov	BYTE PTR [SI],$P_Keyword ;AN029; "="
		   inc	si	   ;AN029;point to next char after the new "="
		   mov	di,si	   ;AN029;move target right after new "="

		   push si	   ;AN029;remember where i am, right after new "="
		   PUSH CX	   ;AN029;SAVE CURRENT COUNT
		   inc	si	   ;AN029;source is one beyond that
		   push es	   ;AN029;remember the extra segment
		   push ds	   ;AN029;temporarily, set source seg and
		   pop	es	   ;AN029; target seg to the command line seg
		   rep	movsb	   ;AN029;move chars left one position
		   pop	es	   ;AN029;restore the extra segment
		   POP	CX	   ;AN029;RESTORE CURRENT COUNT
		   pop	si	   ;AN029;back to where I was

		   DEC	SI	   ;AN029;LOOK AT FIRST CHAR JUST MOVED
		   MOV	$P_REG_BH_CG_SW,-1 ;AN029;set switch to say "a change was made"
		   DEC	psdata_seg:$P_COUNT_TO_EOL ;AN029;AC034;;because just threw away a char
		   dec	CX	   ;AN029;DITTO
;	       $endif		   ;AN029;comparand pair found?
$P_IF6: 			   ;AN029;
;	   $endif		   ;AN029;double quote switch?
$P_IF5: 			   ;AN029;
	   inc	si		   ;AN029;bump index to look at next char in command string
	   dec	CX		   ;AN029;one less char to look at
;(deleted ;AC035;)  CMP  CX,0		    ;AN029;is char count all gone yet?
;      $enddo LE		   ;AN029;quit if no more chars
       JNLE $P_DO2		   ;AN029;
       pop  si			   ;AN029;remember where string started
       OR   $P_REG_BH_CG_SW,$P_REG_BH_CG_SW ;AN029;WAS "A CHANGE MADE"?
;  $enddo Z			   ;AN029;QUIT when no changes were made
   JNZ $P_DO1			   ;AN029;
   pop	di			   ;AN029;
   pop	dx			   ;AN029;
   pop	cx			   ;AN029;

;NOW THAT ALL WHITESPACE SURROUNDING "=" HAVE BEEN COMPRESSED OUT,
;RESUME NORMAL PARSING...
ENDIF					;AN029; KEYWORDS SUPPORTED?
	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
	jnc	$P_Start		;AN000; If EOL is not encountered, do parse

;--------------------------- End of Line
	mov	ax,$P_RC_EOL		;AN000; set exit code to -1
	push	bx			;AN000;
	mov	bx,es:[di].$P_PARMSX_Address ;AN000; Get the PARMSX address to
	cmp	cl,es:[bx].$P_MinP	;AN000; check ORDINAL to see if the minimum
	jae	$P_Fin			;AN000; positional found.

	mov	ax,$P_Op_Missing	;AN000; If no, set exit code to missing operand
$P_Fin: 				;AN000;
	pop	bx			;AN000;
	jmp	$P_Single_Exit		;AN000; return to the caller

;---------------------------
$P_Start:				;AN000;
	mov	psdata_seg:$P_SaveSI_Cmpx,si ;AN000;AC034;  save ptr to command line for later use by complex,
	push	bx			;AN000; quoted string or file spec.
	push	di			;AN000;
	push	bp			;AN000;
	lea	bx,psdata_seg:$P_STRING_BUF ;AC034; set buffer to copy from command string
	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; 3/9 extra delimiter encountered ?
	jne	$P_Pack_End		;AN000; 3/9 if yes, no need to copy

$P_Pack_Loop:				;AN000;
	lodsb				;AN000; Pick a operand from buffer
	call	$P_Chk_Switch		;AN000; Check switch character
	jc	$P_Pack_End_BY_EOL	;AN020; if carry set found delimiter type slash, need backup si, else continue

	call	$P_Chk_EOL		;AN000; Check EOL character
	je	$P_Pack_End_BY_EOL	;AN000; need backup si

	call	$P_Chk_Delim		;AN000; Check delimiter
	jne	$P_PL01 		;AN000; If no, process next byte

	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; 3/9 If yes and white spec,
; (tm08)jne	$P_Pack_End		;AN000; 3/9 then
	jne	$P_Pack_End_backup_si	;AN000; (tm08)

	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end

$P_PAck_End_backup_si:			;AN000; (tm08)
	test	psdata_seg:$P_Flags2,$P_SW+$P_equ ;AN000;AC034;  (tm08)
	je	$P_Pack_End		;AN000; (tm08)

	dec	si			;AN000; (tm08)
	jmp	short $P_Pack_End	;AN025; (tm08)

$P_PL01:				;AN000;
	mov	psdata_seg:[bx],al	;AN000; move byte to STRING_BUF
	cmp	al,$P_Keyword		;AN000; if it is equal character,
	jne	$P_PL00 		;AN000; then

	or	psdata_seg:$P_Flags2,$P_equ ;AC034; remember it in flag
$P_PL00:				;AN000;
	inc	bx			;AN000; ready to see next byte
	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
	jnc	$P_Pack_Loop		;AN000; if no, process to next byte

	lodsb				;AN000; if yes, store
	mov	psdata_seg:[bx],al	;AN000;    2nd byte of DBCS
	inc	bx			;AN000; update pointer
	jmp	short $P_Pack_Loop	;AN000; process to next byte

$P_Pack_End_BY_EOL:			;AN000;
	dec	si			;AN000; backup si pointer
$P_Pack_End:				;AN000;
	mov	psdata_seg:$P_SI_Save,si     ;AC034; save next pointer, SI
	mov	byte ptr psdata_seg:[bx],$P_NULL ;AN000; put NULL at the end
	mov	psdata_seg:$P_Save_EOB,bx    ;AC034; 3/17/87 keep the address for later use of complex
	mov	bx,es:[di].$P_PARMSX_Address ;AN000; get PARMSX address
	lea	si,psdata_seg:$P_STRING_BUF  ;AC034;
	cmp	byte ptr psdata_seg:[si],$P_Switch ;AN000; the operand begins w/ switch char ?
	je	$P_SW_Manager		     ;AN000; if yes, process as switch

	cmp	byte ptr psdata_seg:[si],$P_DQuote	;M005;is it a string?
	je	$P_Positional_Manager			;M005;if so, process as one!

	test	psdata_seg:$P_Flags2,$P_equ   ;AC034; the operand includes equal char ?
	jne	$P_Key_manager		     ;AN000; if yes, process as keyword

$P_Positional_Manager:			;AN000; else process as positional
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	cmp	psdata_seg:$P_ORDINAL,ax ;AC034; too many positional ?
	jae	$P_Too_Many_Error	;AN000; if yes, set exit code to too many

	mov	ax,psdata_seg:$P_ORDINAL ;AC034; see what the current ordinal
	shl	ax,1			;AN000; ax = ax*2
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; now bx points to 1st CONTROL
;(changed ;AC035;) add	   bx,2 	;AN000; now bx points to 1st CONTROL
	add	bx,ax			;AN000; now bx points to specified CONTROL address
	mov	bx,es:[bx]		;AN000; now bx points to specified CONTROL itself
	call	$P_Chk_Pos_Control	;AN000; Do process for positional
	jmp	short $P_Return_to_Caller ;AN000; and return to the caller

$P_Too_Many_Error:			;AN000;
	mov	psdata_seg:$P_RC,$P_Too_Many ;AC034; set exit code
	jmp	short $P_Return_to_Caller ;AN000; and return to the caller
;
$P_SW_Manager:				;AN000;
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	cl,es:[bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxs
	or	cx,cx			;AN000; at least one switch ?
	je	$P_SW_Not_Found 	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL address

$P_SW_Mgr_Loop: 			;AN000;
	push	bx			;AN000;
	mov	bx,es:[bx]		;AN000; bx points to Switch CONTROL itself
	call	$P_Chk_SW_Control	;AN000; do process for switch
	pop	bx			;AN000;
	jnc	$P_Return_to_Caller	;AN000; if the CONTROL is for the switch, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
;(changed ;AC035;)  add     bx,2	;AN000; else bx points to the next CONTROL
	loop	$P_SW_Mgr_Loop		;AN000; and loop

$P_SW_Not_Found:			;AN000;
	mov	psdata_seg:$P_RC,$P_Not_In_SW ;AC034; here no CONTROL for the switch has
	jmp	short $P_Return_to_Caller0    ;AN000; not been found, means error.
;
$P_Key_Manager: 			;AN000;
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	al,es:[bx]		;AN000;
	xor	ah,ah			;AN000; ax = maxs
	shl	ax,1			;AN000;
	inc	ax			;AN000; ax = ax*2+1
	add	bx,ax			;AN000; now bx points to maxk
	mov	cl,es:[bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxk
	or	cx,cx			;AN000; at least one keyword ?
	je	$P_Key_Not_Found	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL

$P_Key_Mgr_Loop:			;AN000;
	push	bx			;AN000;
	mov	bx,es:[bx]		;AN000; bx points to keyword CONTROL itself
	call	$P_Chk_Key_Control	;AN000; do process for keyword
	pop	bx			;AN000;
	jnc	$P_Return_to_Caller	;AN000; if the CONTROL is for the keyword, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
;(changed ;AC035;)  add     bx,2	;AN000; else bx points to the next CONTROL
	loop	$P_Key_Mgr_Loop 	;AN000; and loop

$P_Key_Not_Found:			;AN000;
	mov	psdata_seg:$P_RC,$P_Not_In_Key ;AC034; here no CONTROL for the keyword has
$P_Return_to_Caller0:			;AN000; not been found, means error.

;(deleted ;AN024;)	 mov	 bx,es:[bx-2]		 ;AN000; (tm13) backup bx

;(deleted ;AN024;)	 mov	 al,$P_String		 ;AN000; Set
;(deleted ;AN024;)	 mov	 ah,$P_No_Tag		 ;AN000;     result
;(deleted ;AN024;)	 call	 $P_Fill_Result 	 ;AN000;	    buffer

$P_Return_to_Caller:			;AN000;
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	bx			;AN000;
	mov	cx,psdata_seg:$P_Ordinal    ;AC034; return next ordinal
	mov	ax,psdata_seg:$P_RC	    ;AC034; return exit code
	mov	si,psdata_seg:$P_SI_Save    ;AC034; return next operand pointer
	mov	dx,psdata_seg:$P_DX	    ;AC034; return result buffer address
	mov	bl,psdata_seg:$P_Terminator ;AC034; return delimiter code found
$P_Single_Exit: 			;AN000;
	clc				;AN000;
	ret				;AN000;
SysParse endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Pos_Control
;
; Function: Parse CONTROL block for a positional
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    None
;
; Use:	 $P_Fill_Result, $P_Check_Match_Flags
;
; Vars: $P_Ordinal(W), $P_RC(W)
;***********************************************************************
$P_Chk_Pos_Control proc 		;AN000;
	push	ax			;AN000;
	mov	ax,es:[bx].$P_Match_Flag ;AN000;
	test	ax,$P_Repeat		;AN000; repeat allowed ?
	jne	$P_CPC00		;AN000; then do not increment ORDINAL

	inc	psdata_seg:$P_ORDINAL	;AC034; update the ordinal
$P_CPC00:				;AN000;
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; no data ?
	jne	$P_CPC01		;AN000;

	test	ax,$P_Optional		;AN000; yes, then is it optional ?
	jne	$P_CPC02		;AN000;

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; no, then error	     3/17/87
	jmp	short $P_CPC_Exit	;AN000;

$P_CPC02:				;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; if it is optional return NULL
	mov	ah,$P_No_Tag		;AN000; no item tag indication
	call	$P_Fill_Result		;AN000;
	pop	ax			;AN000;
	jmp	short $P_CPC_Exit	;AN000;

$P_CPC01:				;AN000;
	call	$P_Check_Match_Flags	;AN000;
$P_CPC_Exit:				;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Chk_Pos_Control endp 		;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Key_Control
;
; Function: Parse CONTROL block for a keyword
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************
$P_Chk_Key_Control proc 		;AN000;
IF	KeySW				;AN000;(Check if keyword is supported)
	or	psdata_seg:$P_Flags2,$P_Key_Cmp ;AC034; Indicate keyword for later string comparison
	call	$P_Search_KEYorSW	;AN000; Search the keyword in the CONTROL block
	jc	$P_Chk_Key_Err0 	;AN000; not found, then try next CONTROL

	and	psdata_seg:$P_Flags2,0ffh-$P_Key_Cmp ;AC034; reset the indicator previously set
;
	push	ax			     ;AN000;	      keyword=
	mov	ax,psdata_seg:$P_KEYorSW_Ptr ;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	psdata_seg:$P_SaveSI_Cmpx,ax ;AC034; update for complex, quoted or file spec.
	pop	ax			;AN000;
;
	mov	si,psdata_seg:$P_KEYorSW_Ptr ;AC034; set si just after equal char
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; any data after equal ?
	je	$P_Chk_Key_Err1 	;AN000; if no, syntax error

	call	$P_Check_Match_Flags	;AN000; else, process match flags
	clc				;AN000;
	jmp	short $P_Chk_Key_Exit	;AN000;

$P_Chk_Key_Err0:			;AN000;
	stc				;AN000; not found in keyword synonym list
	jmp	short $P_Chk_Key_Exit	;AN000;

$P_Chk_Key_Err1:			;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; no parameter is not specified after "="
$P_Chk_Key_ErrExit:			;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
$P_Chk_Key_Exit:			;AN000;
	ret				;AN000;
ELSE					;AN000;(of IF KeySW)
	stc				;AN000;this logic works when the KeySW
	ret				;AN000;is reset.
ENDIF					;AN000;(of KeySW)
$P_Chk_Key_Control endp 		;AN000;
PAGE					;AN000;
;***********************************************************************
IF	KeySW+SwSW			;AN000;(Check if keyword or switch is supported)
; $P_Search_KEYorSW:
;
; Function: Seach specified keyword or switch from CONTROL
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
;***********************************************************************
$P_Search_KEYorSW proc			;AN000;
	push	bp			;AN000;
	push	cx			;AN000;
	mov	cl,es:[bx].$P_nid	;AN000; Get synonym count
	xor	ch,ch			;AN000; and set it to cx
	or	cx,cx			;AN000; No synonyms specified ?
	je	$P_KEYorSW_Not_Found	;AN000; then indicate not found by CY

	lea	bp,es:[bx].$P_KEYorSW	;AN000; BP points to the 1st synonym
$P_KEYorSW_Loop:			;AN000;
	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
	jnc	$P_KEYorSW_Found	;AN000; If match, set it to synonym pointer

	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
$P_KEYorSW_Not_Found:			;AN000;
	stc				;AN000; indicate not found in synonym list
	jmp	short $P_KEYorSW_Exit	;AN000; and exit

$P_KEYorSW_Found:			;AN000;
	mov	psdata_seg:$P_Found_SYNONYM,bp ;AC034; set synonym pointer
	clc				;AN000; indicate found
$P_KEYorSW_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bp			;AN000;
	ret				;AN000;
$P_Search_KEYorSW endp			;AN000;
;***********************************************************************
; $P_MoveBP_NUL
;***********************************************************************
$P_MoveBP_NUL proc			;AN000;
$P_MBP_Loop:				;AN000;
	cmp	byte ptr es:[bp],$P_NULL ;AN000; Increment BP that points
	je	$P_MBP_Exit		;AN000; to the synomym list

	inc	bp			;AN000; until
	jmp	short $P_MBP_Loop	;AN000; NULL encountered.

$P_MBP_Exit:				;AN000;
	inc	bp			;AN000; bp points to next to NULL
	ret				;AN000;
$P_MoveBP_NUL endp			;AN000;
ENDIF					;AN000;(of KeySW+SwSW)
PAGE					;AN000;
;***********************************************************************
; $P_Chk_SW_Control
;
; Function: Parse CONTROL block for a switch
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************
$P_Chk_SW_Control proc			;AN000;


IF	SwSW				;AN000;(Check if switch is supported)
	or	psdata_seg:$P_Flags2,$P_Sw_Cmp ;AC034; Indicate switch for later string comparison
	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
	jc	$P_Chk_SW_Err0		;AN000; not found, then try next CONTROL

	and	psdata_seg:$P_Flags2,0ffh-$P_Sw_Cmp ;AC034; reset the indicator previously set
;
	push	ax			;AN000; 	      /switch:
	mov	ax,psdata_seg:$P_KEYorSW_Ptr ;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	psdata_seg:$P_SaveSI_Cmpx,ax ;AC034; update for complex list
	pop	ax			;AN000;
;
	mov	si,psdata_seg:$P_KEYorSW_Ptr ;AC034; set si at the end or colon
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; any data after colon
	jne	$P_CSW00		;AN000; if yes, process match flags

	cmp	byte ptr psdata_seg:[si-1],$P_Colon ;AN000; if no, the switch terminated by colon ?
	jne	$P_Chk_if_data_required ;AN000; if yes,

	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; return syntax error
	jmp	short $P_Chk_SW_Exit	;AN000;

$P_Chk_if_data_required:		;AN018; no data, no colon
	cmp	es:[bx].$P_Match_Flag,0 ;AN018; should have data? zero match flag means switch followed by nothing is OK
	je	$P_Chk_SW_Exit		;AN018; match flags not zero so should have something if optional bit is not on

	test	es:[bx].$P_Match_Flag,$P_Optional ;AN019; see if no value is valid
	jnz	$P_Chk_SW_Exit		;AN019; if so, then leave, else yell

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; return required operand missing
	jmp	short $P_Chk_SW_Exit	;AN018;

$P_CSW00:				;AN000;
	call	$P_Check_Match_Flags	;AN000; process match flag
	clc				;AN000; indicate match
	jmp	short $P_Chk_SW_Single_Exit ;AN000;

$P_Chk_SW_Err0: 			;AN000;
	stc				;AN000; not found in switch synonym list
	jmp	short $P_Chk_SW_Single_Exit ;AN000;

$P_Chk_SW_Exit: 			;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
$P_Chk_SW_Single_Exit:			;AN000;
	ret				;AN000;
ELSE					;AN000;(of IF SwSW)
	stc				;AN000; this logic works when the SwSW
	ret				;AN000; is reset.
ENDIF					;AN000;(of SwSW)
$P_Chk_SW_Control endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Fill_Result
;
; Function: Fill the result buffer
;
; Input:    AH = Item tag
;	    AL = type
;		  AL = 1: CX,DX has 32bit number (CX = high)
;		  AL = 2: DX has index(offset) into value list
;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
;		  AL = 7: DX has year, CL has month and CH has date
;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
;			  amd CH has hundredths
;		  AL = else: psdata_seg:SI points to returned string buffer
;	    ES:BX -> CONTROL block
;
; Output:   None
;
; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
;
; Vars: $P_DX(W)
;***********************************************************************
$P_Fill_Result proc			;AN000;
	push	di			;AN000;
	mov	di,es:[bx].$P_Result_Buf ;AN000; di points to result buffer
	mov	psdata_seg:$P_DX,di	;AC034; set returned result address
	mov	es:[di].$P_Type,al	;AN000; store type
	mov	es:[di].$P_Item_Tag,ah	;AN000; store item tag
	push	ax			;AN000;
	mov	ax,psdata_seg:$P_Found_SYNONYM ;AC034; if yes,
	mov	es:[di].$P_SYNONYM_Ptr,ax ;AN000;   then set it to the result
	pop	ax			;AN000;
$P_RLT04:				;AN000;
	cmp	al,$P_Number		;AN000; if number
	jne	$P_RLT00		;AN000;

$P_RLT02:				;AN000;
	mov	word ptr es:[di].$P_Picked_Val,dx ;AN000; then store 32bit
	mov	word ptr es:[di+2].$P_Picked_Val,cx ;AN000;	number
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT00:				;AN000;
	cmp	al,$P_List_Idx		;AN000; if list index
	jne	$P_RLT01		;AN000;

	mov	word ptr es:[di].$P_Picked_Val,dx ;AN000; then store list index
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT01:				;AN000;
	cmp	al,$P_Date_F		;AN000; Date format ?
	je	$P_RLT02		;AN000;

	cmp	al,$P_Time_F		;AN000; Time format ?
	je	$P_RLT02		;AN000;
;
	cmp	al,$P_Drive		;AN000; drive format ?
	jne	$P_RLT03		;AN000;

	mov	byte ptr es:[di].$P_Picked_Val,dl ;AN000; store drive number
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT03:				;AN000;
	cmp	al,$P_Complex		;AN000; complex format ?
	jne	$P_RLT05		;AN000;

	mov	ax,psdata_seg:$P_SaveSI_Cmpx ;AC034; then get pointer in command buffer
	inc	ax			;AN000; skip left Parentheses
	mov	word ptr es:[di].$P_Picked_Val,ax ;AN000; store offset
	mov	word ptr es:[di+2].$P_Picked_Val,ds ;AN000; store segment
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT05:				;AN000;
;------------------------  AL = 3, 5, or 9
	mov	word ptr es:[di].$P_Picked_Val,si ;AN000; store offset of STRING_BUF
;(replaced ;AN031;)  mov word ptr es:[di+word].$P_Picked_Val,cs ;AN000; store segment of STRING_BUF
	mov	word ptr es:[di+2].$P_Picked_Val,Psdata_Seg ;AN031; store segment of STRING_BUF
;
	push	ax			;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_CAP_File ;AN000; need CAPS by file table?
	je	$P_RLT_CAP00		;AN000;

	mov	al,$P_DOSTBL_File	;AN000; use file upper case table
	jmp	short $P_RLT_CAP02	;AN000;

$P_RLT_CAP00:				;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_CAP_Char ;AN000; need CAPS by char table ?
	je	$P_RLT_CAP01		;AN000;

	mov	al,$P_DOSTBL_Char	;AN000; use character upper case table
$P_RLT_CAP02:				;AN000;
	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
$P_RLT_CAP01:				;AN000;
	pop	ax			;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_Rm_Colon ;AN000; removing colon at end ?
	je	$P_RLT_Exit		;AN000;

	call	$P_Remove_Colon 	;AN000; then process it.
$P_RLT_Exit:				;AN000;
	pop	di			;AN000;
	ret				;AN000;
$P_Fill_Result endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Check_Match_Flags
;
; Function:  Check the mutch_flags and make the exit code and set the
;	     result buffer
;
;	    Check for types in this order:
;		Complex
;		Date
;		Time
;		Drive
;		Filespec
;		Quoted String
;		Simple String
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
;	     $P_Drive_Format
;***********************************************************************
$P_Check_Match_Flags proc		;AN000;
	mov	psdata_seg:$P_err_flag,$P_NULL ;AN033;AC034;; clear filespec error flag.
	push	ax			;AN000;
	mov	ax,es:[bx].$P_Match_Flag ;AN000; load match flag(16bit) to ax

	or	ax,ax			;AC035; test ax for zero
;(changed ;AC035;)  cmp     ax,0	;AN000; (tm12)
	jne	$P_Mat			;AN000; (tm12)

	push	ax			;AN000; (tm12)
	push	bx			;AN000; (tm12)
	push	dx			;AN000; (tm12)
	push	di			;AN000; (tm12)
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; (tm12)
	mov	ah,$P_No_Tag		;AN000; (tm12)
	mov	al,$P_String		;AN000; (tm12)
	call	$P_Fill_Result		;AN000; (tm12)
	pop	di			;AN000; (tm12)
	pop	dx			;AN000; (tm12)
	pop	bx			;AN000; (tm12)
	pop	ax			;AN000; (tm12)
	jmp	short $P_Bridge 	;AC035; (tm12)

$P_Mat: 				;AN000; (tm12)

IF	CmpxSW				;AN000;(Check if complex item is supported)
	test	ax,$P_Cmpx_S		;AN000; Complex string
	je	$P_Match01		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Complex_Format	;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Bridge		;AN000;

$P_Match01:				;AN000;
ENDIF					;AN000;(of CmpxSW)
IF	DateSW				;AN000;(Check if date format is supported)
	test	ax,$P_Date_S		;AN000; Date string
	je	$P_Match02		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Date_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Bridge		;AN000;

$P_Match02:				;AN000;
ENDIF					;AN000;(of DateSW)
IF	TimeSW				;AN000;(Check if time format is supported)
	test	ax,$P_Time_S		;AN000; Time string
	je	$P_Match03		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Time_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
;	je	$P_Match03		;AN000:

	jne	$P_Bridge		;AN000; (tm09)

ENDIF					;AN000;(of TimeSW)  (tm04)
	jmp	short $P_Match03	;AN025; (tm09)

$P_Bridge:				;AN000;
;	jmp	short $P_Match_Exit (tm02)

	jmp	$P_Match_Exit		;AN000; (tm02)

$P_Match03:				;AN000;
; ENDIF ;AN000;(of TimeSW) (tm04)
IF	NumSW				;AN000;(Check if numeric value is supported)
	test	ax,$P_Num_Val		;AN000; Numeric value
	je	$P_Match04		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Value		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match04:				;AN000;
	test	ax,$P_SNUM_Val		;AN000; Signed numeric value
	je	$P_Match05		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_SValue		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match05:				;AN000;
ENDIF					;AN000;(of NumSW)
IF	DrvSW				;AN000;(Check if drive only is supported)
	test	ax,$P_Drv_Only		;AN000; Drive only
	je	$P_Match06		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_File_Format		;AN000; 1st, call file format
	call	$P_Drive_Format 	;AN000; check drive format, next
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examinee the next type
	jne	$P_Match_Exit		;AN000;

$P_Match06:				;AN000;
ENDIF					;AN000;(of DrvSW)
IF	FileSW				;AN000;(Check if file spec is supported)
	test	ax,$P_File_Spc		;AN000; File spec
	je	$P_Match07		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_File_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match07:				;AN000;
ENDIF					;AN000;(of FileSW)
IF	QusSW				;AN000;(Check if quoted string is supported)
	test	ax,$P_Qu_String 	;AN000; Quoted string
	je	$P_Match08		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Quoted_Format	;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match08:				;AN000;
ENDIF					;AN000;(of QusSW)
	test	ax,$P_Simple_S		;AN000; Simple string
	je	$P_Match09		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Simple_String	;AN000; do process
;;;;	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; These two lines will be alive
;;;;	jne	$P_Match_Exit			   ;when extending the match_flags.
$P_Match09:				;AN000;
$P_Match_Exit:				;AN000;
	cmp	psdata_seg:$P_err_flag,$P_error_filespec ;AC034; bad filespec ?
	jne	$P_Match2_Exit		;AN033; no, continue
	cmp	psdata_seg:$P_RC,$P_No_Error ;AN033;AC034;; check for other errors ?
	jne	$P_Match2_Exit		;AN033; no, continue
	mov	psdata_seg:$P_RC,$P_Syntax ;AN033;AC034;; set error flag
$P_Match2_Exit: 			;AN033;
	pop	ax			;AN000;
	ret				;AN000;
$P_Check_Match_Flags endp		;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Remove_Colon;
;
; Function: Remove colon at end
;
; Input:    psdata_seg:SI points to string buffer to be examineed
;
; Output:   None
;
; Use:	$P_Chk_DBCS
;***********************************************************************
$P_Remove_Colon proc			;AN000;
	push	ax			;AN000;
	push	si			;AN000;
$P_RCOL_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get character
	or	al,al			;AN000; end of string ?
	je	$P_RCOL_Exit		;AN000; if yes, just exit

	cmp	al,$P_Colon		;AN000; is it colon ?
	jne	$P_RCOL00		;AN000;

	cmp	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; if so, next is NULL ?
	jne	$P_RCOL00		;AN000; no, then next char

	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; yes, remove colon
	jmp	short $P_RCOL_Exit	;AN000; and exit.

$P_RCOL00:				;AN000;
	call	$P_Chk_DBCS		;AN000; if not colon, then check if
	jnc	$P_RCOL01		;AN000; DBCS leading byte.

	inc	si			;AN000; if yes, skip trailing byte
$P_RCOL01:				;AN000;
	inc	si			;AN000; si points to next byte
	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered

$P_RCOL_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Remove_Colon endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Do_CAPS_String;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    AL = 2 : Use character table
;	    AL = 4 : Use file table
;	    psdata_seg:SI points to string buffer to be capitalized
;
; Output:   None
;
; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
;***********************************************************************
$P_Do_CAPS_String proc			;AN000;
	push	si			;AN000;
	push	dx			;AN000;
	mov	dl,al			;AN000; save info id

$P_DCS_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; load charater and
	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
	jc	$P_DCS00		;AN000; if yes, do not need CAPS

	or	al,al			;AN000; end of string ?
	je	$P_DCS_Exit		;AN000; then exit.

	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
	mov	psdata_seg:[si],al	;AN000; stored upper case char to buffer
	jmp	short $P_DCS01		;AN000; process nexit
$P_DCS00:				;AN000;
	inc	si			;AN000; skip DBCS leading and trailing byte
$P_DCS01:				;AN000;
	inc	si			;AN000; si point to next byte
	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
$P_DCS_Exit:				;AN000;
	pop	dx			;AN000;
	pop	si			;AN000;
	ret				;AN000;
$P_Do_CAPS_String endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Do_CAPS_Char;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    DL = 2 : Use character table
;	    DL = 4 : Use file table
;	    AL = character to be capitalized
;
; Output:   None
;
; Use:	INT 21h /w AH=65h
;***********************************************************************
$P_Do_CAPS_Char proc			;AN000;
	cmp	al,$P_ASCII80		;AN000; need upper case table ?
	jae	$P_DCC_Go		;AN000;

	cmp	al,"a"                  ;AN000; if no,
	jb	$P_CAPS_Ret		;AN000;   check if  "a" <= AL <= "z"

	cmp	al,"z"                  ;AN000;
	ja	$P_CAPS_Ret		;AN000;   if yes, make CAPS

	and	al,$P_Make_Upper	;AN000;   else do nothing.
	jmp	short $P_CAPS_Ret	;AN000;

$P_DCC_Go:				;AN000;
	push	bx			;AN000;
	push	es			;AN000;
	push	di			;AN000;
IF	CAPSW				;AN000;(Check if uppercase conversion is supported)
	lea	di,psdata_seg:$P_File_CAP_Ptr ;AC034;
	cmp	dl,$P_DOSTBL_File	;AN000; Use file CAPS table ?
	je	$P_DCC00		;AN000;

ENDIF					;AN000;(of CAPSW)
	lea	di,psdata_seg:$P_Char_CAP_Ptr ;AC034; or use char CAPS table ?
$P_DCC00:				;AN000;
	cmp	psdata_seg:[di],dl	;AN000; already got table address ?
	je	$P_DCC01		;AN000; if no,

;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
; the GET COUNTYRY INFO call.  This usage of ES is required by the function
; call, regardless of what base register is currently be defined as PSDATA_SEG.
;BASESW EQU 0 means that ES is the psdata_seg reg.

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	push	PSDATA_SEG		;AN037; save current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;

	push	ax			;AN000; get CAPS table thru DOS call
	push	cx			;AN000;
	push	dx			;AN000;


	push	PSDATA_SEG		;AC036; pass current base seg into
					;(Note: this used to push CS.  BUG...
	pop	es			;AN000;   ES reg, required for
					;get extended country information
	mov	ah,$P_DOS_Get_TBL	;AN000; get extended CDI
	mov	al,dl			;AN000; upper case table
	mov	bx,$P_DOSTBL_Def	;AN000; get active CON
	mov	cx,$P_DOSTBL_BL 	;AN000; buffer length
	mov	dx,$P_DOSTBL_Def	;AN000; get for default code page
					;DI already set to point to buffer
	int	21h			;AN000; es:di point to buffer that
					;now has been filled in with info
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	pop	PSDATA_SEG		;AN037; restore current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
$P_DCC01:				;AN000;

;In this next section, ES will be used as the base of the XLAT table, provided
; by the previous GET COUNTRY INFO DOS call.  This usage of ES is made
; regardless of which base reg is currently the PSDATA_SEG reg.

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	push	PSDATA_SEG		;AN037; save current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
	mov	bx,psdata_seg:[di+$P_DOS_TBL_Off] ;AN000; get offset of table
	mov	es,psdata_seg:[di+$P_DOS_TBL_Seg] ;AN000; get segment of table
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; skip length field
;(changed ;AN035;) add	   bx,word	;AN000; skip length field
	sub	al,$P_ASCII80		;AN000; make char to index
	xlat	es:[bx] 		;AN000; perform case map

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	pop	PSDATA_SEG		;AN037; restore current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
	pop	di			;AN000;
	pop	es			;AN000;
	pop	bx			;AN000;
$P_CAPS_Ret:				;AN000;
	ret				;AN000;
$P_Do_CAPS_Char endp			;AN000;
PAGE					;AN000;
;***********************************************************************
IF	NumSW				;AN000;(Check if numeric value is supported)
; $P_Value / $P_SValue
;
; Function:  Make 32bit value from psdata_seg:SI and see value list
;	     and make result buffer.
;	     $P_SValue is an entry point for the signed value
;	     and this will simply call $P_Value after the handling
;	     of the sign character, "+" or "-"
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Check_OVF
;
; Vars: $P_RC(W), $P_Flags(RW)
;***********************************************************************
$P_SValue proc				;AN000; when signed value here
	push	ax			;AN000;
	or	psdata_seg:$P_Flags2,$P_Signed	    ;AC034; indicate a signed numeric
	and	psdata_seg:$P_Flags2,0ffh-$P_Neg  ;AC034; assume positive value
	mov	al,psdata_seg:[si]	;AN000; get sign
	cmp	al,$P_Plus		;AN000; "+" ?
	je	$P_SVal00		;AN000;

	cmp	al,$P_Minus		;AN000; "-" ?
	jne	$P_Sval01		;AN000; else

	or	psdata_seg:$P_Flags2,$P_Neg ;AC034; set this is negative value
$P_SVal00:				;AN000;
	inc	si			;AN000; skip sign char
$P_Sval01:				;AN000;
	call	$P_Value		;AN000; and process value
	pop	ax			;AN000;
	ret				;AN000;
$P_SValue endp				;AN000;
;***********************************************************************
$P_Value proc				;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	xor	cx,cx			;AN000; cx = higher 16 bits
	xor	dx,dx			;AN000; dx = lower 16 bits
	push	bx			;AN000; save control pointer
$P_Value_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get character
	or	al,al			;AN000; end of line ?
	je	$P_Value00		;AN000;

	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
	jc	$P_Value_Err0		;AN000;

	xor	ah,ah			;AN000;
	mov	bp,ax			;AN000; save binary number
	shl	dx,1			;AN000; to have 2*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	mov	bx,dx			;AN000; save low(2*x)
	mov	ax,cx			;AN000; save high(2*x)
	shl	dx,1			;AN000; to have 4*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	shl	dx,1			;AN000; to have 8*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	add	dx,bx			;AN000; now have 10*x
	adc	cx,ax			;AN000; 32bit ADD
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	add	dx,bp			;AN000; Add the current one degree decimal
	adc	cx,0			;AN000; if carry, add 1 to high 16bit
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	inc	si			;AN000; update pointer
	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
;
$P_Value_Err0:				;AN000;
	pop	bx			;AN000;
	jmp	$P_Value_Err		;AN000; Bridge
;
$P_Value00:				;AN000;
	pop	bx			;AN000; restore control pointer
	test	psdata_seg:$P_Flags2,$P_Neg ;AC034; here cx,dx = 32bit value
	je	$P_Value01		;AN000; was it negative ?

	not	cx			;AN000; +
	not	dx			;AN000; |- Make 2's complement
	add	dx,1			;AN000; |
	adc	cx,0			;AN000; +
$P_Value01:				;AN000; / nval =0
	mov	si,es:[bx].$P_Value_List ;AN000; si points to value list
	mov	al,es:[si]		;AN000; get nval
	cmp	al,$P_nval_None 	;AN000; no value list ?
	jne	$P_Value02		;AN000;

	mov	al,$P_Number		;AN000; Set type
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	$P_Value_Exit		;AN000;

$P_Value02:				;AN000; / nval = 1
IF	Val1SW				;AN000;(Check if value list id #1 is supported)
;(tm07) cmp	al,$P_nval_Range	;AN000; have range list ?
;(tm07) jne	$P_Value03		;AN000;

	inc	si			;AN000;
	mov	al,es:[si]		;AN000; al = number of range
	cmp	al,$P_No_nrng		;AN000; (tm07)
	je	$P_Value03		;AN000; (tm07)

	inc	si			;AN000; si points to 1st item_tag
$P_Val02_Loop:				;AN000;
	test	psdata_seg:$P_Flags2,$P_Signed ;AC034;
	jne	$P_Val02_Sign		;AN000;

	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jb	$P_Val02_Next		;AN000;

	ja	$P_Val_In		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	jb	$P_Val02_Next		;AN000;

$P_Val_In:				;AN000;
;;;;;;	cmp	cx,es:$P_Val_YH]	; comp cx with YH (tm01)
	cmp	cx,es:[si+$P_Val_YH]	;AN000; comp cx with YH (tm01)
	ja	$P_Val02_Next		;AN000;

	jb	$P_Val_Found		;AN000;

	cmp	dx,es:[si+$P_Val_YL]	;AN000; comp dx with YL
	ja	$P_Val02_Next		;AN000;

	jmp	short $P_Val_Found	;AN000;

$P_Val02_Sign:				;AN000;
	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jl	$P_Val02_Next		;AN000;

	jg	$P_SVal_In		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	jl	$P_Val02_Next		;AN000;

$P_SVal_In:				;AN000;
	cmp	cx,es:[si+$P_Val_YH]	;AN000; comp cx with YH
	jg	$P_Val02_Next		;AN000;

	jl	$P_Val_Found		;AN000;

	cmp	dx,es:[si+$P_Val_YL]	;AN000; comp dx with YL
	jg	$P_Val02_Next		;AN000;

	jmp	short $P_Val_Found	;AN000;

$P_Val02_Next:				;AN000;
	add	si,$P_Len_Range 	;AN000;
	dec	al			;AN000; loop nrng times in AL
	jne	$P_Val02_Loop		;AN000;
					; / Not found
	mov	psdata_seg:$P_RC,$P_Out_of_Range ;AC034;
	mov	al,$P_Number		;AN000;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val1SW)
IF	Val1SW+Val2SW			;AN000;(Check if value list id #1 or #2 is supported)
$P_Val_Found:				;AN000;
	mov	al,$P_Number		;AN000;
	mov	ah,es:[si]		;AN000; found ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val1SW+Val2SW)
$P_Value03:				;AN000; / nval = 2
IF	Val2SW				;AN000;(Check if value list id #2 is supported)
;;;;	cmp	al,$P_nval_Value	; have match list ? ASSUME nval=2,
;;;;	jne	$P_Value04		; even if it is 3 or more.
;(tm07) inc	si			;AN000;
;(tm07) mov	al,es:[si]		;AN000; al = nrng
	mov	ah,$P_Len_Range 	;AN000;
	mul	ah			;AN000;  Skip nrng field
	inc	ax			;AN000;
	add	si,ax			;AN000; si points to nnval
	mov	al,es:[si]		;AN000; get nnval
	inc	si			;AN000; si points to 1st item_tag
$P_Val03_Loop:				;AN000;
	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jne	$P_Val03_Next		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	je	$P_Val_Found		;AN000;

$P_Val03_Next:				;AN000;
	add	si,$P_Len_Value 	;AN000; points to next value choice
	dec	al			;AN000; loop nval times in AL
	jne	$P_Val03_Loop		;AN000;
					;AN000; / Not found
	mov	psdata_seg:$P_RC,$P_Not_in_Val ;AC034;
	mov	al,$P_Number		;AN000;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val2SW)
$P_Value04:				;AN000; / nval = 3 or else
$P_Value_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
	mov	al,$P_String		;AN000; Set type
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
$P_Value_Exit:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Value endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Check_OVF
;
; Function:  Check if overflow is occurred with consideration of
;	     signed or un-signed numeric value
;
; Input:     Flag register
;
; Output:    CY = 1  :	Overflow
;
; Vars:     $P_Flags(R)
;***********************************************************************
$P_Check_OVF proc			;AN000;
	pushf				;AN000;
	test	psdata_seg:$P_Flags2,$P_Neg ;AC034; is it negative value ?
	jne	$P_COVF 		;AN000; if no, check overflow

	popf				;AN000; by the CY bit
	ret				;AN000;

$P_COVF:				;AN000;
	popf				;AN000; else,
	jo	$P_COVF00		;AN000; check overflow by the OF

	clc				;AN000; indicate it with CY bit
	ret				;AN000; CY=0 means no overflow

$P_COVF00:				;AN000;
	stc				;AN000; and CY=1 means overflow
	ret				;AN000;
$P_Check_OVF endp			;AN000;
ENDIF					;AN000;(of FarSW)
;***********************************************************************
; $P_0099;
;
; Function:  Make ASCII 0-9 to Binary 0-9
;
; Input:     AL = character code
;
; Output:    CY = 1 : AL is not number
;	     CY = 0 : AL contains binary value
;***********************************************************************
$P_0099 proc				;AN000;
	cmp	al,"0"                  ;AN000;
	jb	$P_0099Err		;AN000;  must be 0 =< al =< 9

	cmp	al,"9"                  ;AN000;
	ja	$P_0099Err		;AN000;  must be 0 =< al =< 9

	sub	al,"0"                  ;AN000; make char -> bin
	clc				;AN000; indicate no error
	ret				;AN000;

$P_0099Err:				;AN000;
	stc				;AN000; indicate error
	ret				;AN000;
$P_0099 endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Simple_String
;
; Function:  See value list for the simple string
;	     and make result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_String_Comp
;
; Vars: $P_RC(W)
;***********************************************************************
$P_Simple_String proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	mov	di,es:[bx].$P_Value_List ;AN000; di points to value list
	mov	al,es:[di]		;AN000; get nval
	or	al,al			;AN000; no value list ?
	jne	$P_Sim00		;AN000; then

	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000; and set result buffer

$P_Sim00:				;AN000;
IF	Val3SW+KeySW			;AN000;(Check if keyword or value list id #3 is supported)
	cmp	al,$P_nval_String	;AN000; String choice list provided ?
	jne	$P_Sim01		;AN000; if no, syntax error

	inc	di			;AN000;
	mov	al,es:[di]		;AN000; al = nrng
	mov	ah,$P_Len_Range 	;AN000;
	mul	ah			;AN000;  Skip nrng field
	inc	ax			;AN000; ax = (nrng*9)+1
	add	di,ax			;AN000; di points to nnval
	mov	al,es:[di]		;AN000; get nnval
	mov	ah,$P_Len_Value 	;AN000;
	mul	ah			;AN000; Skip nnval field
	inc	ax			;AN000; ax = (nnval*5)+1
	add	di,ax			;AN000; di points to nstrval
	mov	al,es:[di]		;AN000; get nstrval
	inc	di			;AC035; add '2' to
	inc	di			;AC035;  DI reg
					;AN000; di points to 1st string in list
;(replaced ;AC035;) add     di,2	;AN000; di points to 1st string in list
$P_Sim_Loop:				;AN000;
	mov	bp,es:[di]		;AN000; get string pointer
	call	$P_String_Comp		;AN000; compare it with operand
	jnc	$P_Sim_Found		;AN000; found on list ?

	add	di,$P_Len_String	;AN000; if no, point to next choice
	dec	al			;AN000; loop nstval times in AL
	jne	$P_Sim_Loop		;AN000;
					;AN000; / Not found
	mov	psdata_seg:$P_RC,$P_Not_In_Str ;AC034;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000;

$P_Sim_Found:				;AN000;
	mov	ah,es:[di-1]		;AN000; set item_tag
	mov	al,$P_List_Idx		;AN000;
	mov	dx,es:[di]		;AN000; get address of STRING
	jmp	short $P_Sim_Exit0	;AN000;
ENDIF					;AN000;(of Val3SW+KeySW)
$P_Sim01:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
$P_Sim_Exit:				;AN000;
	mov	al,$P_String		;AN000; Set type
$P_Sim_Exit0:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	bx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Simple_String endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_String_Comp:
;
; Function:  Compare two string
;
; Input:     psdata_seg:SI -> 1st string
;	     ES:BP -> 2nd string  (Must be upper case)
;	     ES:BX -> CONTROL block
;
; Output:    CY = 1 if not match
;
; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
;
; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
;***********************************************************************
$P_String_Comp proc			;AN000;
	push	ax			;AN000;
	push	bp			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	mov	dl,$P_DOSTBL_Char	;AN000; use character case map table
$P_SCOM_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get command character
	call	$P_Chk_DBCS		;AN000; DBCS ?
	jc	$P_SCOM00		;AN000; yes,DBCS

	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
IF	KeySW+SwSW			;AN000;(Check if keyword or switch is supported)
	test	psdata_seg:$P_Flags2,$P_Key_Cmp ;AC034; keyword search ?
	je	$P_SCOM04		;AN000;

	cmp	al,$P_Keyword		;AN000; "=" is delimiter
	jne	$P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)

	cmp	byte ptr es:[bp+1],$P_NULL ;AN021;   at end of keyword string in the control block THEN
	jne	$P_SCOM_DIFFER		;AN021;

	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list

$P_SCOM04:				;AN000;
	test	psdata_seg:$P_Flags2,$P_SW_Cmp ;AC034; switch search ?
	je	$P_SCOM03		;AN000;

	cmp	al,$P_Colon		;AN000; ":" is delimiter, at end of switch on command line
	jne	$P_SCOM03		;AN000; continue compares

	cmp	byte ptr es:[bp],$P_NULL ;AN021; IF at end of switch on command AND
	jne	$P_SCOM_DIFFER		;AN021;   at end of switch string in the control block THEN

$P_SCOM05:				;AN000;   found a match
	inc	si			;AN000; si points to just after "=" or ":"
	jmp	short $P_SCOM_Same	;AN000; exit

$P_SCOM03:				;AN000;
ENDIF					;AN000;(of KeySW+SwSW)
	cmp	al,es:[bp]		;AN000; compare operand w/ a synonym
	jne	$P_SCOM_Differ0 	;AN000; if different, check ignore colon option

	or	al,al			;AN000; end of line
	je	$P_SCOM_Same		;AN000; if so, exit

	inc	si			;AN000; update operand pointer
	inc	bp			;AN000; 	   and synonym pointer
	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case

$P_SCOM00:				;AN000; Here al is DBCS leading byte
	cmp	al,es:[bp]		;AN000; compare leading byte
	jne	$P_SCOM_Differ		;AN000; if not match, say different

	inc	si			;AN000; else, load next byte
	mov	al,psdata_seg:[si]	;AN000; and
	inc	bp			;AN000;
	cmp	al,es:[bp]		;AN000; compare 2nd byte
	jne	$P_SCOM_Differ		;AN000; if not match, say different, too

	inc	si			;AN000; else update operand pointer
	inc	bp			;AN000; 		and synonym pointer
$P_SCOM01:				;AN000;
	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case

$P_SCOM_Differ0:			;AN000;

IF	SwSW				;AN000;(tm10)
	test	psdata_seg:$P_Flags2,$P_SW ;AC034;(tm10)
	je	$P_not_applicable	;AN000;(tm10)

	test	es:[bx].$P_Function_Flag,$P_colon_is_not_necessary ;AN000;(tm10)
	je	$P_not_applicable	;AN000;(tm10)

	cmp	byte ptr es:[bp],$P_NULL ;AN000;(tm10)
;(deleted ;AN025;) jne $P_not_applicable ;AN000;(tm10)
	je	$P_SCOM_Same		;AN025;(tm10)

$P_not_applicable:			;AN000;(tm10)
ENDIF					;AN000;(tm10)

	test	es:[bx].$P_Match_Flag,$P_Ig_Colon ;AN000; ignore colon option specified ?
	je	$P_SCOM_Differ		;AN000; if no, say different.

	cmp	al,$P_Colon		;AN000; End up with ":" and
	jne	$P_SCOM02		;AN000;    subseqently

	cmp	byte ptr es:[bp],$P_NULL ;AN000;       NULL ?
	jne	$P_SCOM_Differ		;AN000; if no, say different

	jmp	short $p_SCOM_Same	;AN000; else, say same

$P_SCOM02:				;AN000;
	cmp	al,$P_NULL		;AN000; end up NULL and :
	jne	$P_SCOM_Differ		;AN000;

	cmp	byte ptr es:[bp],$P_Colon ;AN000; if no, say different
	je	$p_SCOM_Same		;AN000; else, say same

$P_SCOM_Differ: 			;AN000;
	stc				;AN000; indicate not found
	jmp	short $P_SCOM_Exit	;AN000;

$P_SCOM_Same:				;AN000;
	mov	psdata_seg:$P_KEYorSW_Ptr,si ;AC034; for later use by keyword or switch
	clc				;AN000; indicate found
$P_SCOM_Exit:				;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	bp			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_String_Comp endp			;AN000;
PAGE					;AN000;
;***********************************************************************
IF	DateSW				;AN000;(Check if date format is supported)
; $P_Date_Format
;
; Function:  Convert a date string to DOS date format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
;
; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
;***********************************************************************
$P_Date_Format proc			;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; set country dependent information before process
;	mov	bl,psdata_seg:[si].$P_CDI_DateS ;load date separator ;AN020; (deleted)
;					note: the country info is still needed
;					to determine the order of the fields,
;					but the separator char is no longer used.
	pop	si			;AN000;
	mov	psdata_seg:$P_1st_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_2nd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_3rd_Val,0 ;AC034; set initial value
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	$P_DateF_Err0		;AN000;-----------------------+

	mov	psdata_seg:$P_1st_Val,ax ;AC034;	      |
	or	bl,bl			;AN000; end of line ?	      |
	je	$P_DateF_YMD		;AN000; 		      |

	call	$P_Get_DecNum		;AN000; get 2nd number	      |
	jc	$P_DateF_Error		;AN000; 		      |

	mov	psdata_seg:$P_2nd_Val,ax ;AC034;	      |
	or	bl,bl			;AN000; end of line ?	      |
	je	$P_DateF_YMD		;AN000; 		      |

	call	$P_Get_DecNum		;AN000; get 3rd number	      |
$P_DateF_Err0:				;AN000; Bridge	  <-----------+
	jc	$P_DateF_Error		;AN000;

	mov	psdata_seg:$P_3rd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	jne	$P_DateF_Error		;AN000;

$P_DateF_YMD:				;AN000;
	mov	bx,psdata_seg:$P_Country_Info.$P_CDI_DateF ;AC034; get date format
	cmp	bx,$P_Date_YMD		;AN000;
	je	$P_DateF00		;AN000;

	mov	ax,psdata_seg:$P_1st_Val ;AC034;
	or	ah,ah			;AN000;
	jne	$P_DateF_Error		;AN000;

	mov	cl,al			;AN000; set month
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error.
	jne	$P_DateF_Error		;AN000;

	mov	ch,al			;AN000; set date
	mov	dx,psdata_seg:$P_3rd_Val ;AC034; set year
	cmp	bx,$P_Date_DMY		;AN000; from here format = MDY
	jne	$P_DateF01		;AN000; if it is DMY

	xchg	ch,cl			;AN000;  then swap M <-> D
$P_DateF01:				;AN000;
	jmp	short $P_DateF02	;AN000;

$P_DateF00:				;AN000; / here format = YMD
	mov	dx,psdata_seg:$P_1st_Val ;AC034; set year
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error
	jne	$P_DateF_Error		;AN000;

	mov	cl,al			;AN000; set month
	mov	ax,psdata_seg:$P_3rd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error
	jne	$P_DateF_Error		;AN000;

	mov	ch,al			;AN000; set date
$P_DateF02:				;AN000;
	cmp	dx,100			;AN000; year is less that 100 ?
	jae	$P_DateF03		;AN000;

	add	dx,1900 		;AN000; set year 19xx
$P_DateF03:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Date_F		;AN000;     result
	call	$P_Fill_Result		;AN000; 	   buffer
	jmp	short $P_Date_Format_Exit ;AN000;	to Date

$P_DateF_Error: 			;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_String		;AN000;     result
	call	$P_Fill_Result		;AN000; 	   buffer  to string
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; indicate syntax error
$P_Date_Format_Exit:			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Date_Format endp			;AN000;
ENDIF					;AN000;(of DateSW)
PAGE					;AN000;
;***********************************************************************
IF	TimeSW+DateSW			;AN000;(Check if time or date format is supported)
; $P_Set_CDI:
;
; Function: Read CDI from DOS if it has not been read yet
;
; Input:    None
;
; Output:   psdata_seg:SI -> CDI
;
; Use:	INT 21h w/ AH = 38h
;***********************************************************************
$P_Set_CDI proc 			;AN000;
	lea	si,psdata_seg:$P_Country_Info ;AC034;
	cmp	psdata_seg:[si].$P_CDI_DateF,$P_NeedToBeRead ;AN000; already read ?
	je	$P_Read_CDI		;AN000;

	jmp	short $P_Set_CDI_Exit	;AN000; then do nothing

$P_Read_CDI:				;AN000; else read CDI thru DOS
	push	ds			;AN000;
	push	dx			;AN000;
	push	ax			;AN000;
	push	PSDATA_SEG		;AC023;
	pop	ds			;AN000; set segment register
	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
	mov	dx,si			;AN000; set offset of CDI in local data area
	int	21h			;AN000;
	pop	ax			;AN000;
	pop	dx			;AN000;
	pop	ds			;AN000;
$P_Set_CDI_Exit:			;AN000;
	ret				;AN000;
$P_Set_CDI endp 			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Get_DecNum:
;
; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
;	     or NULL encountered. And make a decimal number.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    BL = delimiter code or NULL
;	     AX = Decimal number
;	     SI advanced to the next number
;	     CY = 1 : Syntax error, AL = Latest examineed number
;
; Use:	$P_0099
;***********************************************************************
$P_Get_DecNum proc			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	xor	cx,cx			;AN000; cx will have final value
$P_GetNum_Loop: 			;AN000;
	mov	al,psdata_seg:[si]	;AN000; load character
	or	al,al			;AN000; end of line ?
	je	$P_GetNum00		;AN000; if yes, exit

	cmp	psdata_seg:$P_Got_Time,0 ;AC034; ;is this numeric in a time field?    ;AC023
	je	$P_Do_Date_Delims	;AN000;no, go check out Date delimiters  ;AC023

; Determine which delimiter(s) to check for.  Colon & period  or period only
	cmp	bl,$P_colon_period	;AN032; ;Time
	jne	$P_Do_Time_Delim1	;AN032; ;only check for period

	cmp	al,$P_Colon		;AN032; ;Is this a valid delimiter ?
	je	$P_GetNum01		;AN032; ;yes, exit

$P_Do_Time_Delim1:			;AN000;
	cmp	al,$P_Period		;;AC032;;AC023;Is this a valid delimiter ?
	je	$P_GetNum01		;AC023; yes, exit

	jmp	short $P_Neither_Delims ;AN023;

$P_Do_Date_Delims:			;AN000;
;Regardless of the date delimiter character specified in the country
;dependent information, check for the presence of any one of these
;three field delimiters: "-", "/", or ".".
	cmp	al,$P_Minus		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN020;if yes, exit

	cmp	al,$P_Slash		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN020;if yes, exit

	cmp	al,$P_Period		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN000; if yes, exit

$P_Neither_Delims:			;AN023;

	call	$P_0099 		;AN000; convert it to binary
	jc	$P_GetNum_Exit		;AN000; if error exit

	mov	ah,0			;AN000;
	xchg	ax,cx			;AN000;
	mov	dx,10			;AN000;
	mul	dx			;AN000; ax = ax * 10
	or	dx,dx			;AN000; overflow
	jne	$P_GetNum02		;AN000; then exit

	add	ax,cx			;AN000;
	jc	$P_GetNum_Exit		;AN000;

	xchg	ax,cx			;AN000;
	inc	si			;AN000;
	jmp	short $P_GetNum_Loop	;AN000;

$P_GetNum00:				;AN000;
	mov	bl,al			;AN000; set bl to NULL
	clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum01:				;AN000;
	inc	si			;AN000; si points to next number
	clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum02:				;AN000;
	stc				;AN000; indicate error
$P_GetNum_Exit: 			;AN000;
	mov	ax,cx			;AN000;return value
	pop	dx			;AN000;
	pop	cx			;AN000;
	ret				;AN000;
$P_Get_DecNum endp			;AN000;
ENDIF					;AN000;(of TimeSW+DateSW)
PAGE					;AN000;
;***********************************************************************
IF	TimeSW				;AN000;(Check if time format is supported)
; $P_Time_Format
;
; Function:  Convert a time string to DOS time format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
;
; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
;	$P_3rd_Val(RW), $P_4th_Val(RW)
;***********************************************************************
$P_Time_Format proc			;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; Set country independent
					; information before process
;(AN032; deleted)  mov	   bl,psdata_seg:[si].$P_CDI_TimeS ;load time separator
;(AN032; deleted)  mov	   bh,psdata_seg:[si].$P_CDI_Dec ;load decimal separator
	test	byte ptr psdata_seg:[si].$P_CDI_TimeF,1 ;AN000; 24 hour system
	pop	si			;AN000;
	jne	$P_TimeF00		;AN000; if no, means 12 hour system

	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
$P_TimeF00:				;AN000;
	mov	psdata_seg:$P_1st_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_2nd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_3rd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_4th_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_Got_Time,1 ;AN023;AC034;; use time delimiter
	mov	bl,$P_colon_period	;AN032; flag, indicates use of
					; delimiters between hours,
					;  minutes,seconds
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	$P_TimeF_Err0		;AN000;

	mov	psdata_seg:$P_1st_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	je	$P_TimeF_Rlt		;AN000;

	call	$P_Get_DecNum		;AN000; get 2nd number
	jc	$P_TimeF_Err0		;AC038; if OK

	mov	psdata_seg:$P_2nd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	je	$P_TimeF_Rlt		;AN000;

;(;AN032; deleted) mov	   bl,bh		   ;set decimal separator
	mov	bl,$P_period_only	;AN032; flag, which to decimal separator
	call	$P_Get_DecNum		;AN000; get 3rd number
	jc	$P_TimeF_Err0		;AC039; if problem, bridge to error

	mov	psdata_seg:$P_3rd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
;(DELETED ;AN039;)  je $P_TimeF_Rlt	;AN000;
	jne	$P_Time_4		;AN039; NOT END OF LINE,
					;AN039;   GO TO 4TH NUMBER
	test	psdata_seg:$P_Flags1,$P_Time_Again ;AN039; HAS TIME PARSE
					;AN039;    BEEN REPEATED?
	jnz	$P_TimeF_Rlt		;AN039; yes, this is really
					;AN039;   the end of line
					;AN039; no, time has not been repeated
	mov	si,psdata_seg:$P_SI_Save ;AN039; get where parser quit
					 ;AN039;   in command line
	cmp	byte ptr [si-1],$P_Comma ;AN039; look at delimiter
					;AN039;   from command line
	jne	$P_TimeF_Rlt		;AN039; was not a comma, this is
					;AN039;  really end of line
					;AN039; is comma before hundredths,
					;AN039;   redo TIME
	mov	byte ptr [si-1],$P_Period ;AN039; change that ambiguous
					;AN039;    comma to a decimal point
					;AN039;     parse can understand
	mov	psdata_seg:$P_Flags,0	;AN039; Clear all internal flags
	or	psdata_seg:$P_Flags1,$P_Time_Again ;AN039; indicate TIME
					;AN039; is being repeated
	mov	cx,psdata_seg:$P_ORIG_ORD ;AN039; ORIGINAL ORDINAL FROM CX
	mov	sp,psdata_seg:$P_ORIG_STACK ;AN039; ORIGINAL VALUE
					 ;AN039;   OF STACK FROM SP
	mov	si,psdata_seg:$P_ORIG_SI ;AN039; ORIGINAL START
					 ;AN039;   PARSE POINTER FROM SI
	jmp	$P_Redo_Time		;AN039; go try TIME again
; ===============================================================
$P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
	call	$P_Get_DecNum		;AN000; get 4th number
$P_TimeF_Err0:				;AN000; Bridge
	jc	$P_TimeF_Error		;AN000;

	mov	psdata_seg:$P_4th_Val,ax ;AC034;
	or	bl,bl			;AN000; After hundredth, no data allowed
	jne	$P_TimeF_Error		;AN000; if some, then error

$P_TimeF_RLT:				;AN000;
	mov	ax,psdata_seg:$P_1st_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	test	psdata_seg:$P_Flags1,$P_Time12am ;AN038;if "am" specified
	jz	$P_Time_notAM		;AN038;skip if no "AM" specified
					;since "AM" was specified,
	cmp	al,12			;AN038: if hour specified as later than noon
	ja	$P_TimeF_Err		;AN038; error if "AM" on more than noon
	jne	$P_Time_notAM		;AN038; for noon exactly,

	xor	al,al			;AN038; set hour = zero
$P_Time_notAM:				;AN038;
	test	psdata_seg:$P_Flags2,$P_Time12 ;AC034; if 12 hour system and pm is specified
	je	$P_TimeSkip00		;AN000; then

	cmp	al,12			;AN038; if 12:00 o'clock already
	je	$P_TimeSkip00		;AN038; it is PM already

	add	al,12			;AN000; add 12 hours to make it afternoon
	jc	$P_TimeF_Err		;AN000; if overflow then error

	cmp	al,24			;AN038; after adding 12, now cannot be >24
	ja	$P_TimeF_Err		;AN038; if too big, error

$P_TimeSkip00:				;AN000;
	mov	dl,al			;AN000; set hour
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	dh,al			;AN000; set minute
	mov	ax,psdata_seg:$P_3rd_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	cl,al			;AN000; set second
	mov	ax,psdata_seg:$P_4th_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	ch,al			;AN000; set hundredth
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Time_F		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	jmp	short $P_Time_Format_Exit ;AN000;    to time

$P_TimeF_Error: 			;AN000;
$P_TimeF_Err:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_String		;AN000;     result
	call	$P_Fill_Result		;AN000; 	  buffer to string
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; return syntax error
$P_Time_Format_Exit:			;AN000;
	mov	psdata_seg:$P_Got_Time,0 ;AN023;AC034;; finished with this time field
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Time_Format endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Time_2412:
;
; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    Set $P_Time12 flag when the string is terminated by "p"
;	     or "pm"
;
; Vars:  $P_Flags(W)
;***********************************************************************
$P_Time_2412 proc			;AN000;
	push	ax			;AN000;
	push	si			;AN000;
$P_T12_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; Move
	inc	si			;AN000;     si
	or	al,al			;AN000;       to
	jne	$P_T12_Loop		;AN000; 	end of string

	mov	al,psdata_seg:[si-word] ;AN000; get char just before NULL
	or	al,$P_Make_Lower	;AN000; lower case map
	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
	je	$P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; only "a" of "am" ?
	je	$P_T1201		;AN000;

	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
	jne	$P_T12_Exit		;AN000;

	dec	si			;AN000;
	mov	al,psdata_seg:[si-word] ;AN000;
	or	al,$P_Make_lower	;AN000; lower case map
	cmp	al,"p"                  ;AN000; "p" of "pm" ?
	je	$P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; "a" of "am" ?
	je	$P_T1201		;AN000; go process "a"

	jmp	short $P_T12_Exit	;AN000; no special chars found

$P_T1200:				;AN000; "P" found
	or	psdata_seg:$P_Flags2,$P_Time12 ;AC034; flag "PM" found
	jmp	short $P_Tclr_chr	;AN038; go clear the special char

$P_T1201:				;AN000; "A" found
	or	psdata_seg:$P_Flags1,$P_Time12AM ;AN038; flag "AM" found
$P_Tclr_chr:				;AN038;
	mov	byte ptr psdata_seg:[si-2],$P_NULL ;AN000; null out special char
$P_T12_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Time_2412 endp			;AN000;
ENDIF					;AN000;(of TimeSW)
PAGE					;AN000;
;***********************************************************************
IF	CmpxSW				;AN000;(Check if complex item is supported)
; $P_Complex_Format:
;
; Function:  Check if the input string is valid complex format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_Chk_EOL, $P_Skip_Delim
;	$P_Quoted_str, $P_Chk_DSQuote
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_SaveSI_Cmpx(R), $P_Save_EOB(R)
;***********************************************************************
$P_Complex_Format proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	mov	bx,psdata_seg:$P_SaveSI_Cmpx ;AC034; bx points to user buffer
	cmp	byte ptr [bx],$P_Lparen ;AN000; 1st char = left parentheses
	jne	$P_Cmpx_Err		;AN000;

	xor	ah,ah			;AN000; ah = parentheses counter
$P_Cmpx_Loop:				;AN000;
	mov	al,[bx] 		;AN000; load character from command buffer
	call	$P_Chk_EOL		;AN000; if it is one of EOL
	je	$P_CmpxErr0		;AN000; then error exit.

	cmp	al,$P_Lparen		;AN000; left parentheses ?
	jne	$P_Cmpx00		;AN000; then

	inc	ah			;AC035; add '1' to AH reg
					;AN000; increment parentheses counter
;(replaced ;AC035;) add     ah,1	;AN000; increment parentheses counter
	jc	$P_CmpxErr0		;AN000; if overflow, error
$P_Cmpx00:				;AN000;
	cmp	al,$P_Rparen		;AN000; right parentheses ?
	jne	$P_Cmpx01		;AN000; then

	dec	ah			;AC035; subtract '1' from AH reg
					;AN000; decrement parentheses counter
;(changed ;AC035;) sub	   ah,1 	;AN000; decrement parentheses counter
	jc	$P_CmpxErr0		;AN000; if overflow error

	je	$P_Cmpx03		;AN000; ok, valid complex

$P_Cmpx01:				;AN000;
;(deleted ;AN025;) call $P_Chk_DSQuote	;AN000; double or single quotation mark ? 3/17/KK
	cmp	al,$P_DQuote		;AN025; double quotation mark?
	jne	$P_Cmpx04		;AN000; 3/17/KK

	mov	psdata_seg:[si],al	;AN000; here quoted string is found in the complex list.
	inc	si			;AN000;
	inc	bx			;AN000; bx points to 2nd character
	call	$P_Quoted_Str		;AN000; skip pointers until closing of quoted string
	jc	$P_CmpxErr0		;AN000; if error in quoted string syntax then exit

	jmp	short $P_Cmpx05 	;AN000;

$P_Cmpx04:				;AN000;
	call	$P_Chk_DBCS		;AN000; was it a lead byte of DBCS ?
	jnc	$P_Cmpx02		;AN000;

	mov	psdata_seg:[si],al	;AN000; then store 1st byte
	inc	si			;AN000;
	inc	bx			;AN000;
	mov	al,[bx] 		;AN000; load 2nd byte
$P_Cmpx02:				;AN000;
	mov	psdata_seg:[si],al	;AN000; store SBCS or 2nd byte of DBCS
$P_Cmpx05:				;AN000;
	inc	si			;AN000;
	inc	bx			;AN000;
	jmp	short $P_Cmpx_Loop	;AN000; loop
;----					;AN000;
$P_Cmpx03:				;AN000;
	mov	byte ptr psdata_seg:[si],al ;AN000;
	mov	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000;
	mov	byte ptr [bx],$P_NULL	;AN000; replace right parentheses with NULL
	mov	si,bx			;AN000; skip whitespaces
	inc	si			;AN000;     after
	call	$P_Skip_Delim		;AN000;        right parentheses
	mov	psdata_seg:$P_SI_Save,si ;AC034; save next pointer, SI
	jmp	short $P_Cmpx_Exit	;AN000;

$P_CmpxErr0:				;AN000;
	mov	si,psdata_seg:$P_Save_EOB ;AC034; if EOF encountered, restore
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; EOB mark
$P_Cmpx_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
$P_Cmpx_Exit:				;AN000;
	mov	ah,$P_No_Tag		;AN000;
	mov	al,$P_Complex		;AN000;
	pop	si			;AN000;
	pop	bx			;AN000;
	call	$P_Fill_Result		;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Complex_Format endp			;AN000;
ENDIF					;AN000;(of CpmxSW)
PAGE					;AN000;
;***********************************************************************
IF	QusSW				;AN000;(Check if quoted string is supported)
; $P_Quoted_Format:
;
; Function:  Check if the input string is valid quoted string format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_Chk_EOL, $P_Skip_Delim
;	$P_Chk_DSQuote, $P_Quoted_Str
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_SaveSI_Cmpx(R),$P_Save_EOB(R)
;***********************************************************************
$P_Quoted_Format proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	mov	bx,psdata_seg:$P_SaveSI_Cmpx ;AC034; bx points to user buffer
	mov	al,byte ptr [bx]	;AN000; get 1st character
;(deleted ;AN025;) call $P_Chk_DSQuote	;AN000; is it single or double quote ?
	cmp	al,$P_DQuote		;AN025; double quotation mark?
	jne	$P_Qus_Err		;AN000; if no, error

;	mov	psdata_seg:[si],al	;AN000; move it to internal buffer
;	inc	si			;AN000;
	inc	bx			;AN000; bx points to 2nd character
	call	$P_Quoted_Str		;AN000; skip pointers to the closing of quoted string
	jc	$P_Qus_Err0		;AN000; if invali quoted string syntax, exit

	mov	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; end up with NULL
	mov	si,bx			;AN000;
	inc	si			;AN000;
	call	$P_Skip_Delim		;AN000; skip whitespaces after closing quote
	mov	psdata_seg:$P_SI_Save,si ;AC034; save next pointer, SI
	jmp	short $P_Qus_Exit	;AN000;

$P_Qus_Err0:				;AN000;
	mov	si,psdata_seg:$P_Save_EOB ;AC034; if EOF encountered, restore
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; EOB mark
$P_Qus_Err:				;AN000;AN000
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; indicate syntax error
$P_Qus_Exit:				;AN000;
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Quoted_String	;AN000;    result
	pop	si			;AN000; 	 buffer
	pop	bx			;AN000; 	       to
	call	$P_Fill_Result		;AN000; 		 quoted string
	pop	ax			;AN000;
	ret				;AN000;
$P_Quoted_Format endp			;AN000;
ENDIF					;AN000;(of QusSW)
PAGE					;AN000;
;***********************************************************************
; $P_Chk_DSQuote;
;
; Function: Check if AL is double quotation or single quotation
;
; Input:    AL = byte to be examineed
;
; Output:   ZF on if AL is single or double quotetaion
;
; Vars:  $P_SorD_Quote(W)
;***********************************************************************
IF	QusSW+CmpxSW			;AN000;(Check if quoted string or complex item is supported)
;(deleted ;AN025;) $P_Chk_DSQuote proc			   ;
;(deleted ;AN025;)	   mov	   $P_SorD_Quote,$P_SQuote ; 3/17/87   assume single quote
;(deleted ;AN025;)	   cmp	   al,$P_DQuote 	   ; 1st char = double quotation ?
;(deleted ;AN025;)	   jne	   $P_CDSQ00		   ; 3/17/87
;(deleted ;AN025;)	   mov	   $P_SorD_Quote,al	   ; 3/17/87 set bigning w/ double quote
;(deleted ;AN025;)	   ret				   ; 3/17/87
;(deleted ;AN025;) $P_CDSQ00:				   ; 3/17/87
;(deleted ;AN025;)	   cmp	   al,$P_SQuote 	   ; 1st char = single quotation ?
;(deleted ;AN025;)	   ret				   ;
;(deleted ;AN025;) $P_Chk_DSQuote endp			   ;
    PAGE				;AN000;
;***********************************************************************
; $P_Quoted_Str:
;
; Function:  Copy chracacter from ES:BX to psdata_seg:SI until closing single
;	     (double) quotation found.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> Operand in command buffer
;
; Output:    CY on indicates EOF encounterd before closing quotation
;	     BX and SI
;
;
; Vars: $P_SorD_Quote(R)
;***********************************************************************
$P_Quoted_Str proc			;AN000;
	push	ax			;AN000;
$P_Qus_Loop:				;AN000;
	mov	ax,[bx] 		;AN000; 3/17/87
	call	$P_Chk_EOL		;AN000;
	je	$P_Qustr_Err0		;AN000;

;(deleted ;AN025;) cmp al,$P_SorD_Quote ;AN000; quotation ?   3/17/87
	cmp	al,$P_DQuote		;AN025; double quote?
	jne	$P_Qus00		;AN000;

;(deleted ;AN025;) cmp ah,$P_SorD_Quote ;AN000; contiguous quotation 3/17/87
	cmp	ah,$P_DQuote		;AN025; double quote?
	jne	$P_Qus02		;AN000;

;(deleted ;AN025:) mov word ptr psdata_seg:[si],ax ;AN000; 3/17/87
	mov	byte ptr psdata_seg:[si],al ;AN025; save one of the quotes
;(deleted ;AN025:) add si,2		;AN000;

	inc	si			;AC035; add '1' to SI reg
					;AN025; adjust target index
;(changed ;AC035;) add	   si,1 	;AN025; adjust target index
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; adjust source index by 2 to skip extra quote
;(changed ;AC035;) add	   bx,2 	;AN000; adjust source index by 2 to skip extra quote
	jmp	short $P_Qus_Loop	;AN000;

$P_Qus00:				;AN000;
	call	$P_Chk_DBCS		;AN000; was it a lead byte of DBCS ?
	jnc	$P_Qus01		;AN000;

	mov	psdata_seg:[si],al	;AN000; store 1st byte
	inc	si			;AN000;
	inc	bx			;AN000;
	mov	al,[bx] 		;AN000; load 2nd byte
$P_Qus01:				;AN000;
	mov	psdata_seg:[si],al	;AN000; store SBCS or 2nd byte of DBCS
	inc	si			;AN000;
	inc	bx			;AN000;
	jmp	short $P_Qus_Loop	;AN000;

$P_Qustr_Err0:				;AN000;
	stc				;AN000; indicate error
	jmp	short $P_Quoted_Str_Exit ;AN000;

$P_Qus02:				;AN000;
	mov	byte ptr psdata_seg:[si],0 ;AN000;
	clc				;AN000; indicate no error
$P_Quoted_Str_Exit:			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Quoted_Str endp			;AN000;
ENDIF					;AN000;(of QusSW+CmpxSW)
PAGE					;AN000;
;***********************************************************************
IF	FileSW+DrvSW			;AN000;(Check if file spec or drive only is supported)
; $P_File_Format;
;
; Function:  Check if the input string is valid file spec format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
;	$P_SaveSI_Cmpx(R)
;***********************************************************************
$P_File_Format proc			;AN000;
	push	ax			;AN000;
	push	di			;AN000;
	push	si			;AN000;
	mov	di,psdata_seg:$P_SaveSI_cmpx ;AC034; get user buffer address
$P_FileF_Loop0: 			;AN000; / skip special characters
	mov	al,psdata_seg:[si]	;AN000; load character
	or	al,al			;AN000; end of line ?
	je	$P_FileF_Err		;AN000; if yes, error exit

	call	$P_FileSp_Chk		;AN000; else, check if file special character
	jne	$P_FileF03		;AN000; if yes,

;AN033; deleted   inc	  di			  ;skip
;AN033; deleted   inc	  si			  ;   the
;AN033; deleted   jmp	  short $P_FileF_Loop0	  ;	  character
	mov	psdata_seg:$P_err_flag,$P_error_filespec ;AN033;AC034;; set error flag- bad char.
	pop	si			;AN033;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN033;
	pop	di			;AN033;
	jmp	short $P_FileF02	;AN033;


$P_FileF_Err:				;AN000;
	pop	si			;AN000;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000;
;(deleted ;AN030;) mov di,$P_SaveSI_cmpx ;AN000; get user buffer address
;(deleted ;AN030;) mov $P_SI_Save,di	 ;AN000; update pointer to user buffer
	pop	di			;AN000;
	test	es:[bx].$P_Match_Flag,$P_Optional ;AN000; is it optional ?
	jne	$P_FileF02		;AN000;

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; 3/17/87
	jmp	short $P_FileF02	;AN000;

$P_FileF03:				;AN000;
	pop	ax			;AN000; discard save si
	push	si			;AN000; save new si
$P_FileF_Loop1: 			;AN000;
	mov	al,psdata_seg:[si]	;AN000; load character (not special char)
	or	al,al			;AN000; end of line ?
	je	$P_FileF_RLT		;AN000;

	call	$P_FileSp_Chk		;AN000; File special character ?
	je	$P_FileF00		;AN000;

	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
	jnc	$P_FileF01		;AN000;
	inc	di			;AN000; if yes, skip next byte
	inc	si			;AN000;
$P_FileF01:				;AN000;
	inc	di			;AN000;
	inc	si			;AN000;
	jmp	short $P_FileF_Loop1	;AN000;
;
$P_FileF00:				;AN000;
	mov	psdata_seg:$P_Terminator,al ;AC034;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; update end of string
	inc	di			;AN000;
	mov	psdata_seg:$P_SI_Save,di ;AC034; update next pointer in command line
$P_FileF_RLT:				;AN000;
	pop	si			;AN000;
	pop	di			;AN000;
$P_FileF02:				;AN000;

	pop	ax			;AN000; (tm14)
	test	ax,$P_File_Spc		;AN000; (tm14)
	je	$P_Drv_Only_Exit	;AN000; (tm14)

	push	ax			;AN000;  (tm14)

	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_File_Spec 	;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer to file spec
	pop	ax			;AN000;

$P_Drv_Only_Exit:			;AN000; (tm14)

	ret				;AN000;
$P_File_Format endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_FileSp_Chk
;
; Function:  Check if the input byte is one of file special characters
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     AL = character code to be examineed
;
; Output:    ZF = 1 , AL is one of special characters
;***********************************************************************
$P_FileSp_Chk proc			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	lea	bx,psdata_seg:$P_FileSp_Char ;AC034; special character table
	mov	cx,$P_FileSp_Len	;AN000; load length of it
$P_FileSp_Loop: 			;AN000;
	cmp	al,psdata_seg:[bx]	;AN000; is it one of special character ?
	je	$P_FileSp_Exit		;AN000;

	inc	bx			;AN000;
	loop	$P_FileSp_Loop		;AN000;

	inc	cx			;AN000; reset ZF
$P_FileSp_Exit: 			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;
$P_FileSp_Chk endp			;AN000;
ENDIF					;AN000;(of FileSW+DrvSW)
PAGE					;AN000;
;***********************************************************************
IF	DrvSW				;AN000;(Check if drive only is supported)
; $P_Drive_Format;
;
; Function:  Check if the input string is valid drive only format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS
;
; Vars: $P_RC(W)
;***********************************************************************
$P_Drive_Format proc			;AN000;
	push	ax			;AN000;
	push	dx			;AN000;
	mov	al,psdata_seg:[si]	;AN000;
	or	al,al			;AN000; if null string
	je	$P_Drv_Exit		;AN000; do nothing

	call	$P_Chk_DBCS		;AN000; is it leading byte ?
	jc	$P_Drv_Err		;AN000;

	cmp	word ptr psdata_seg:[si+byte],$P_Colon ;AN000; "d", ":", 0  ?
	je	$P_DrvF00		;AN000;

	test	es:[bx].$P_Match_Flag,$P_Ig_Colon ;AN000; colon can be ignored?
	je	$P_Drv_Err		;AN000;

	cmp	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; "d", 0  ?
	jne	$P_Drv_Err		;AN000;

$P_DrvF00:				;AN000;
	or	al,$P_Make_Lower	;AN000; lower case
	cmp	al,"a"                  ;AN000; drive letter must
	jb	$P_Drv_Err		;AN000; in range of

	cmp	al,"z"                  ;AN000; "a" - "z"
	ja	$P_Drv_Err		;AN000; if no, error

	sub	al,"a"-1                ;AN000; make text drive to binary drive
	mov	dl,al			;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	mov	al,$P_Drive		;AN000; 	 buffer
	call	$P_Fill_Result		;AN000; 	       to drive
	jmp	short $P_Drv_Exit	;AN000;

$P_Drv_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
$P_Drv_Exit:				;AN000;
	pop	dx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Drive_Format endp			;AN000;
ENDIF					;AN000;(of DrvSW)
PAGE					;AN000;
;***********************************************************************
; $P_Skip_Delim;
;
; Function: Skip delimiters specified in the PARMS list, white space
;	    and comma.
;
; Input:    DS:SI -> Command String
;	    ES:DI -> Parameter List
;
; Output:   CY = 1 if the end of line encounterd
;	    CY = 0 then SI move to 1st non-delimiter character
;	    AL = Last examineed character
;
; Use:	    $P_Chk_EOL, $P_Chk_Delim,
;
; Vars:     $P_Flags(R)
;***********************************************************************
$P_Skip_Delim proc			;AN000;
$P_Skip_Delim_Loop:			;AN000;
	LODSB				;AN000;
	call	$P_Chk_EOL		;AN000; is it EOL character ?
	je	$P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on

	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
	jne	$P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off

	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; extra delim or comma found ?
	je	$P_Skip_Delim_Loop	;AN000; if no, loop

	test	psdata_seg:$P_Flags2,$P_SW+$P_equ ;AC034; /x , or xxx=zzz , (tm08)
	je	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)

	dec	si			;AN000; backup si for next call (tm08)
	jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off

$P_Skip_Delim_CY:			;AN000;
	stc				;AN000; indicate EOL
	jmp	short $P_Skip_Delim_Exit ;AN000;

$P_Skip_Delim_NCY:			;AN000;
	clc				;AN000; indicate non delim
$P_Skip_Delim_Exit:			;AN000; in this case, need
	dec	si			;AN000;  backup index pointer
	ret				;AN000;

$P_Exit_At_Extra:			;AN000;
	clc				;AN000; indicate extra delim
	ret				;AN000;
$P_Skip_Delim endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_EOL;
;
; Function: Check if AL is one of End of Line characters.
;
; Input:    AL = character code
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of End of Line characters
;**********************************************************************
$P_Chk_EOL proc 			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	cmp	al,$P_CR		;AN000; Carriage return ?
	je	$P_Chk_EOL_Exit 	;AN000;

	cmp	al,$P_NULL		;AN000; zero ?
	je	$P_Chk_EOL_Exit 	;AN000;

IF LFEOLSW				;AN028; IF LF TO BE ACCEPTED AS EOL
	cmp	al,$P_LF		;AN000; Line feed ?
	je	$P_Chk_EOL_Exit 	;AN000;
ENDIF					;AN028;

	cmp	byte ptr es:[di].$P_Num_Extra,$P_I_Have_EOL ;AN000; EOL character specified ?
	jb	$P_Chk_EOL_Exit 	;AN000;

	xor	bx,bx			;AN000;
	mov	bl,es:[di].$P_Len_Extra_Delim ;AN000; get length of delimiter list
	add	bx,$P_Len_PARMS 	;AN000; skip it
	cmp	byte ptr es:[bx+di],$P_I_Use_Default ;AN000; No extra EOL character ?
	je	$P_Chk_EOL_NZ		;AN000;

	xor	cx,cx			;AN000; Get number of extra chcracter
	mov	cl,es:[bx+di]		;AN000;
$P_Chk_EOL_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,es:[bx+di]		;AN000; Check extra EOL character
	je	$P_Chk_EOL_Exit 	;AN000;

	loop	$P_Chk_EOL_Loop 	;AN000;

$P_Chk_EOL_NZ:				;AN000;
	cmp	al,$P_CR		;AN000; reset ZF
$P_Chk_EOL_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;
$P_Chk_EOL endp 			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Delim;
;
; Function: Check if AL is one of delimiter characters.
;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
;	    blanks.
;
; Input:    AL = character code
;	    DS:SI -> Next Character
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of delimiter characters
;	    SI points to the next character
; Vars:  $P_Terminator(W), $P_Flags(W)
;***********************************************************************
$P_Chk_Delim proc			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	mov	psdata_seg:$P_Terminator,$P_Space   ;AC034; Assume terminated by space
	and	psdata_seg:$P_Flags2,0ffh-$P_Extra ;AC034;
	cmp	al,$P_Space		;AN000; Space ?
	je	$P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_TAB		;AN000; TAB ?
	je	$P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_Comma		;AN000; Comma ?
	je	$P_Chk_Delim_Exit0	;AN000;

$P_Chk_Delim00: 			;AN000;
	cmp	al,$P_DBSP1		;AN000; 1st byte of DBCS Space ?
	jne	$P_Chk_Delim01		;AN000;

	cmp	byte ptr [si],$P_DBSP2	;AN000; 2nd byte of DBCS Space ?
	jne	$P_Chk_Delim01		;AN000;

	mov	al,$P_Space		;AN000;
	inc	si			;AN000; make si point to next character
	cmp	al,al			;AN000; Set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

$P_Chk_Delim01: 			;AN000;
	cmp	byte ptr es:[di].$P_Num_Extra,$P_I_Have_Delim ;AN000; delimiter character specified ?
	jb	$P_Chk_Delim_Exit	;AN000;

	xor	cx,cx			;AN000;
	mov	cl,es:[di].$P_Len_Extra_Delim ;AN000; get length of delimiter list
	or	cx,cx			;AN000; No extra Delim character ?
	je	$P_Chk_Delim_NZ 	;AN000;

	mov	bx,$P_Len_PARMS-1	;AN000; set bx to 1st extra delimiter
$P_Chk_Delim_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,es:[bx+di]		;AN000; Check extra Delim character
	je	$P_Chk_Delim_Exit0	;AN000;

	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter

$P_Chk_Delim_NZ:			;AN000;
	cmp	al,$P_Space		;AN000; reset ZF
$P_Chk_Delim_Exit:			;AN000;
;;;;	jne	$P_ChkDfin
;;;;	mov	psdata_seg:$P_Terminator,al ;AN034;
$P_ChkDfin:				;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;

$P_Chk_Delim_Exit0:			;AN000;
	mov	psdata_seg:$P_Terminator,al ;AC034; keep terminated delimiter
	test	psdata_seg:$P_Flags2,$P_Equ  ;AN027;AC034;; if terminating a key=
	jnz	$P_No_Set_Extra 	;AN027; then do not set the EXTRA bit

	or	psdata_seg:$P_Flags2,$P_Extra ;AC034; flag terminated extra delimiter or comma
$P_No_Set_Extra:			;AN027;
	cmp	al,al			;AN000; set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

$P_Chk_Delim endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Switch;
;
; Function: Check if AL is the switch character not in first position of
;	    $P_STRING_BUF
;
; Input:    AL = character code
;	    BX = current pointer within $P_String_Buf
;	    SI =>next char on command line (following the one in AL)
;
; Output:   CF = 1 (set)if AL is switch character, and not in first
;		 position, and has no chance of being part of a date string,
;		 i.e. should be treated as a delimiter.

;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
;		 position, or is a slash but may be part of a date string, i.e.
;		 should not be treated as a delimiter.
;
; Vars:  $P_Terminator(W)

; Use:	 $P_0099
;***********************************************************************
$P_Chk_Switch proc			;AN000;

;AN020;; Function: Check if AL is the switch character from 2nd position of $P_STRING_BUF
;AN020;; Output:   ZF = 1 if switch character
;AN020;;	lea	bp,$P_STRING_BUF ;AN000;
;AN020;;	cmp	bx,bp		 ;AN000; 1st position ?
;AN020;;	je	$P_Chk_S_Exit_1  ;AN000;
;AN020;;	cmp	al,$P_Switch	 ;AN000;
;AN020;;	jmp	short $P_Chk_S_Exit_0  ;AN000;
;AN020;;$P_Chk_S_Exit_1:		       ;AN000;
;AN020;;	cmp	al,$P_Switch	 ;AN000; (tm08)
;AN020;;	jne	$P_Nop		;AN000; (tm08)
;AN020;;	or	$P_Flags2,$P_SW  ;AN000; (tm08) It could be valid switch
;AN020;;$P_Nop: 			;AN000; (tm08)
;AN020;;	inc	bp		       ;AN000;
;AN020;;	cmp	bx,bp		       ;AN000; reset ZF
;AN020;;$P_Chk_S_Exit_0:		       ;AN000;
;AN020;;	jne	$P_Chk_S_Exit	       ;AN000;
;AN020;;	mov	   $P_Terminator,al    ;AN000; store switch character
;AN020;;$P_Chk_S_Exit:			       ;AN000;

	LEA	BP,psdata_seg:$P_String_Buf ;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
;	.IF <BX NE BP> THEN		;AN020;IF not first char THEN
	cmp	BX,BP			;AN000;
	je	$P_STRUC_L2		;AN000;

;	    .IF <AL EQ $P_Switch> THEN	;AN020;otherwise see if a slash
	    cmp     AL,$P_Switch	;AN000;
	    jne     $P_STRUC_L5 	;AN000;

		STC			;AN020;not in first position and is slash, now see if might be in date string
IF	DateSw				;AN020;caller looking for date, see if this may be part of one
		PUSH	AX		;AN020;save input char
		MOV	AL,PSDATA_SEG:[BX-1] ;AN026;AL=char before the current char
		CALL	$P_0099 	;AN020;return carry set if not numeric
;		.IF   NC ;AND		;AN020;IF previous char numeric AND
		jc	$P_STRUC_L7	;AN000;

		    MOV     AL,[SI]	;AN020;AL=char after the current char
		    CALL    $P_0099	;AN020;return carry set if not numeric
;(deleted)	    .IF     NC THEN	;AN020;IF next char numeric THEN could be a date
;(deleted)		CLC		;AN020;reset CF so "/" not treated as a delimiter
;(deleted)	    .ENDIF		;AN026;
;		.ENDIF			;AN020;ENDIF looks like date (number/number)
$P_STRUC_L7:				;AN000;
		POP	AX		;AN020;restore AL to input char
ENDIF					;AN020;DateSw
;	    .ELSE			;AN020;
	    jmp     short $P_STRUC_L1	;AN000;

$P_STRUC_L5:				;AN000;
		CLC			;AN020;not a slash
;	    .ENDIF			;AN020;
;	.ELSE				;AN020;is first char in the buffer, ZF=0
	jmp	short $P_STRUC_L1	;AN000;

$P_STRUC_L2:				;AN000;
;	    .IF <AL EQ $P_Switch> THEN	;AN020;
	    cmp     AL,$P_Switch	;AN000;
	    jne     $P_STRUC_L12	;AN000;

		OR	psdata_seg:$P_Flags2,$P_SW ;AN020;AC034;;could be valid switch, first char and is slash
;	    .ENDIF			;AN020;
$P_STRUC_L12:				;AN000;
	    CLC 			;AN020;CF=0 indicating first char
;	.ENDIF				;AN020;
$P_STRUC_L1:				;AN000;

	ret				;AN000;
$P_Chk_Switch endp			;AN000;
	PAGE				;AN000;
;**************************************************************************
; $P_Chk_DBCS:
;
;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
;
;  Input:
;	  AL	= Code to be examineed
;
;  Output:
;	  If CF is on then a lead byte of DBCS
;
; Use: INT 21h w/AH=63
;
; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
;***************************************************************************
$P_Chk_DBCS PROC			;AN000;
;
	PUSH	DS			;AN000;
	PUSH	SI			;AN000;
	PUSH	bx			;AN000; (tm11)
	CMP	psdata_seg:$P_DBCSEV_SEG,0 ;AC034; ALREADY SET ?
	JNE	$P_DBCS00		;AN000;

	PUSH	AX			;AN000;
;	PUSH	BX			;AN000; (tm11)
	PUSH	ds			;AN000; (tm11)
	PUSH	CX			;AN000;
	PUSH	DX			;AN000;
	PUSH	DI			;AN000;
	PUSH	BP			;AN000;
	PUSH	ES			;AN000;
	XOR	SI,SI			;AN000;
	MOV	DS,SI			;AN000;
	MOV	AX,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
	INT	21H			;AN000;

;	MOV	AX,DS			;AN000; (tm11)
;	OR	AX,AX			;AN000; (tm11)
	MOV	bx,DS			;AN000; (tm11)
	OR	bx,bx			;AN000; (tm11)
	POP	ES			;AN000;
	POP	BP			;AN000;
	POP	DI			;AN000;
	POP	DX			;AN000;
	POP	CX			;AN000;
;	POP	BX			;AN000; (tm11)
	POP	ds			;AN000; (tm11)
	POP	AX			;AN000;
	JE	$P_NON_DBCS		;AN000;

$P_DBCS02:				;AN000;
	MOV	psdata_seg:$P_DBCSEV_OFF,SI ;AC034; save EV offset
;	MOV	psdata_seg:$P_DBCSEV_SEG,DS ;AC034; save EV segment
	MOV	psdata_seg:$P_DBCSEV_SEG,bx ;AC034; save EV segment (tm11)
$P_DBCS00:				;AN000;
	MOV	SI,psdata_seg:$P_DBCSEV_OFF ;AC034; load EV offset
	MOV	DS,psdata_seg:$P_DBCSEV_SEG ;AC034; and segment

$P_DBCS_LOOP:				;AN000;
	CMP	WORD PTR [SI],0 	;AN000; zero vector ?
	JE	$P_NON_DBCS		;AN000; then exit

	CMP	AL,[SI] 		;AN000;
	JB	$P_DBCS01		;AN000; Check if AL is in

	CMP	AL,[SI+BYTE]		;AN000;   range of
	JA	$P_DBCS01		;AN000;      the vector

	STC				;AN000; if yes, indicate DBCS and exit
	JMP	short $P_DBCS_EXIT	;AN000;

$P_DBCS01:				;AN000;
	INC	SI			;AC035; add '2' to
	INC	SI			;AC035;  SI reg
					;AN000; get next vector
;(changed ;AC035;) ADD	   SI,2 	;AN000; get next vector
	JMP	short $P_DBCS_LOOP	;AN000; loop until zero vector found

$P_NON_DBCS:				;AN000;
	CLC				;AN000; indicate SBCS
$P_DBCS_EXIT:				;AN000;
	POP	bx			;AN000; (tm11)
	POP	SI			;AN000;
	POP	DS			;AN000;
	RET				;AN000;
$P_Chk_DBCS ENDP			;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\pcgequ.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
;	       CONDITIONAL ASSEMBLY CONTROLS
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
WINTHORN	EQU	 1	 ;OS/2 compatible

;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
;		 VIDEO REGISTER PORT ADDRESS EQUATES				  =B
;										  =B
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
seq_addr	EQU	0C4H	;Sequencer  Address				  =B
seq_data	EQU	0C5H	;Sequencer  Data				  =B
crtc_addr	EQU	0D4H	;CRT Controller Address (Color) 		  =B
crtc_addr_b	EQU	0B4H	;CRT Controller Address (Mono)			  =B
crtc_data	EQU	0D5H	;CRT Controller Data				  =B
graph_1_pos	EQU	0CCH	;Graphics 1 Position				  =B
graph_2_pos	EQU	0CAH	;Graphics 2 Position				  =B
graph_addr	EQU	0CEH	;Graphics 1 & 2 Address 			  =B
graph_data	EQU	0CFH	;Graphics 1 & 2 Data				  =B
misc_output	EQU	0C2H	;Miscellaneous Output				  =B
misc_read	EQU	0CCH	;Miscellaneous Output Read Port Address 	  =B
in_stat_0	EQU	0C2H	;Input Status Register 0			  =B
input_status_b	EQU	0BAH	;Feature Control (Mono) 			  =B
input_status	EQU	0DAH	;Feature Control (Color)			  =B
attr_read	EQU	0C1H	;Attribute Controller Read Address		  =B
attr_write	EQU	0C0H	;Attribute Controller Write Address		  =B
fctrl_read	EQU	0CAH	;Feature Control Regiester Read Address 	  =B

;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
;	     SEQUENCER ADDRESS REGISTER EQUATES
;
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
s_reset 	EQU	00H	;Reset						  =B
s_clock 	EQU	01H	;Clocking Mode					  =B
s_map		EQU	02H	;Map Mask					  =B
s_cgen		EQU	03H	;Character Map Select				  =B
s_mem		EQU	04H	;Memory Mode					  =B


;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
;	     GRAPHICS ADDRESS REGISTER EQUATES
;
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
g_set_reset	EQU	00H	;set/reset					  =B
g_enbl_set	EQU	01H	;enable set/reset				  =B
g_clr_comp	EQU	02H	;color compare					  =B
g_data_rot	EQU	03H	;data rotate					  =B
g_read_map	EQU	04H	;read map select				  =B
g_mode		EQU	05H	;mode						  =B
g_misc		EQU	06H	;miscellaneous					  =B
g_color 	EQU	07H	;color don't care                                 =B
g_bit_mask	EQU	08H	;bit mask					  =B

;---------------------------------------------------------------------+
;								      |
;	 Miscellaneous Equates					      |
;								      |
;---------------------------------------------------------------------+

LINELEN        EQU  80			     ; Length of a Graphics Buffer Line
COLPELS        EQU  8			     ; Number of pels per text column
;DEFROFFU	EQU  1			      ; Default Pointer Icon Row Center Offset
;DEFROFFD	EQU  14 		      ; Default Pointer Icon Row Center Offset
;DEFCOFFR	EQU  11 		      ; Default Pointer Icon Column Center Offst
;DEFCOFFL	EQU  4			      ; Default Pointer Icon Column Center Offst
;ICONROWS	EQU  16 		      ; Number of Rows in Pointer Icon
;M_WHITE	EQU  15 		      ;default foreground color (icon)
;M_DAXIS	EQU  11 		      ;default axis mouse pointer

DEFROFFU       EQU  1			     ; Default Pointer Icon Row Center Offset
DEFROFFD       EQU  14			     ; Default Pointer Icon Row Center Offset
DEFCOFFR       EQU  14			     ; Default Pointer Icon Column Center Offst
DEFCOFFL       EQU  2			     ; Default Pointer Icon Column Center Offst
ICONROWS       EQU  20			     ; Number of Rows in Pointer Icon
M_DAXIS        EQU  800 		     ;default axis mouse pointer

ICONCOLS       EQU  16			     ; Number of Columns in Pointer Icon
SHFTMSK        EQU  07H 		     ; Column Shift Count Bit Mask (Hi-Res)
M_BLACK        EQU  0			     ;default background color (icon)
M_WHITE        EQU  15			     ;default foreground color (icon)
VSICONR        EQU  28			     ;# pel rows
VSICONC        EQU  2*8 		     ;# pel columns
MVSICONR       EQU  16			     ;minimun pel rows in sb icon
MHSICONC       EQU  3*8 		     ;minimum pel cols in sb icon

;;
;;  Long Conditional Jump Macros
;;
lja		macro	Farlabel
		local	Nearlabel
		jna	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljae		macro	Farlabel
		local	Nearlabel
		jnae	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljb		macro	Farlabel
		local	Nearlabel
		jnb	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljc		macro	Farlabel
		local	Nearlabel
		jnc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljbe		macro	Farlabel
		local	Nearlabel
		jnbe	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
lje		macro	Farlabel
		local	Nearlabel
		jne	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljz		macro	Farlabel
		local	Nearlabel
		jnz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljg		macro	Farlabel
		local	Nearlabel
		jng	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljge		macro	Farlabel
		local	Nearlabel
		jnge	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljl		macro	Farlabel
		local	Nearlabel
		jnl	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljle		macro	Farlabel
		local	Nearlabel
		jnle	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnc		macro	Farlabel
		local	Nearlabel
		jc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljne		macro	Farlabel
		local	Nearlabel
		je	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnz		macro	Farlabel
		local	Nearlabel
		jz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljno		macro	Farlabel
		local	Nearlabel
		jo	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljo		macro	Farlabel
		local	Nearlabel
		jno	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\pathmac.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;;***********************************************************************
;; NAME: pathlabl
;; DESC: creates a public label at the spot it is placed, using the name
;;       given.
;; INPUT: either module name or procedure name
;; OUTPUT: public label
;; LOGIC: LBL-parameter-name will have four values -
;;            - one for each pass (2)
;;            - one for start and one for stop
;;        if LBL is not defined, it is first pass, at beginning label
;;              - set it to 1 and create the start label
;;        if LBL = 1, it is first pass, at end label
;;              - set it to 2 and create stop label
;;        if LBL = 2, it is second pass, at beginning label
;;              - set it to 3 and create the start label
;;        if LBL = 3, it is second pass, at end label
;;              - set it to 4 and create stop label
;;        if LBL = 4, it is second pass,
;;              - this macro has been invoked more than twice with same parm
;;              - issue error message
;;***********************************************************************
IF1
;    %OUT COMPONENT=COMMON, MODULE=PATHMAC.INC ...
ENDIF

pathlabl MACRO pnam
IFNDEF LBL_&pnam                        ;;IF THIS IS THE FIRST TIME,
    LBL_&pnam = 0                       ;;DEFINE IT, INITIALLY ZERO
ELSE                                    ;;SINCE IT IS DEFINED
    IF (LBL_&pnam GT 3)                 ;;IF USED TOO MANY TIMES,
        .ERR NON-UNIQUE OPERAND ON PATHLABL
        EXITM                           ;;ABORT THIS GENERATION
    ENDIF
ENDIF

IF (LBL_&pnam EQ 0) OR (LBL_&pnam EQ 2) ;;ready for START?
    $$A_START_&pnam:                    ;;create START label
    PUBLIC $$A_START_&pnam              ;;make it public
ELSE                                    ;;SINCE SWITCH MAY BE 1 OR 3,
    $$A_STOP_&pnam:                     ;;create STOP label
    PUBLIC $$A_STOP_&pnam               ;;make it public
ENDIF
LBL_&pnam = LBL_&pnam + 1               ;;INCREMENT SWITCH
ENDM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\pcinput.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; Source...: PCINPUT.INC						      :
; Created..: 01-01-82							      :
; Standards: 01-07-86							      :
; Revised..: 11-17-87							      :
; Version..: PC DOS							      :
; Called as: FAR, NEAR or INT						      :
; Public as: INPUT							      :
;									      :
;-----------------------------------------------------------------------------+
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; DEFAULT								      :
;									      :
;	  Performs the following functions:				      :
;									      :
;	  - Initializes pointers and counters				      :
;	  - Initializes input buffer with default value (from screen or strg) :
;	  - Set options and display input buffer as default on screen	      :
;	  - Display field delimiters					      :
;	  - Display minus or plus sign					      :
;									      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
;	  WR_CURSIZE   = Current cursor size				      :
;									      :
; Exit:   Default displayed						      :
;									      :
;-----------------------------------------------------------------------------+
;
DEFAULT        PROC NEAR
;
; Initialize input buffer with default buffer
;
	       PUSH BP
	       PUSH ES			     ;save registers
	       PUSH DS
	       PUSH DI
	       PUSH SI
;
	       MOV  DX,ES:[SI]+ICB_FIELDLEN  ;save for later				 ;=W
	       MOV  BX,ES:[SI]+ICB_DEFLEN    ;save for later				 ;=W
;
	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;get source string segment 		 ;=W
	       MOV  DS,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;get destination offset			 ;=W
	       MOV  DI,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get destination segment			 ;=W
	       MOV  CX,ES:[SI]+ICB_DEFOFF    ;get source string offset			 ;=W
	       MOV  SI,CX								 ;=W
	       MOV  ES,AX								 ;=W
;
	       PUSH DI
	       MOV  CX,DX		     ;clear input buffer			 ;=W
	       MOV  AL,WR_SPACE 							 ;=W
	       CLD									 ;=W
	       REP  STOSB								 ;=W
	       POP  DI
;											 ;=W
	       MOV  BP,0
	       MOV  CX,BX		     ;initialize number of bytes in		 ;=W
					     ; default string
	       CMP  CX,DX		     ;check if default string is
	       JBE  DEF10		     ; longer than input buffer
;
	       MOV  CX,DX		     ;error set to input buffer leng
	       MOV  BP,ICB_STRU 	     ;set error indicating default was
					     ; truncated
DEF10:
	       CLD
	       REP  MOVSB		     ;move default into input buffer
;
	       POP  SI			     ;restore registers
	       POP  DI
	       POP  DS
	       POP  ES
;
	       OR   ES:[SI]+ICB_STATUS,BP    ;save error status
	       POP  BP
;
; Calculate row and column of input field and set the desired display attribute
;
	       MOV  AX,ES:[SI]+ICB_ROW	     ;get input field row
	       MOV  [DI]+CR_ROW,AX
;
	       MOV  AX,ES:[SI]+ICB_COL	     ;get input field column
	       MOV  [DI]+CR_COL,AX
;
	       CALL PCROWCL_CALL	     ;calculate row and column info
					     ; return CR_RCOFF and CR_BEGROWOFF
	       MOV  AL,[DI]+WR_EATTR	     ;set the entry attribute to the
	       MOV  [DI]+WR_CATTR,AL	     ; current attribute
;
; Initialize variables for left justified field
;
	       TEST ES:[SI]+ICB_OPT1,ICB_RJU ;check if right justified
	       JNE  DEF20
;
	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character marker to
					     ;beginning of input field
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get max field length			 ;=W
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if horizontal scrolling		 ;=W
	       JE   DEF15		     ;no					 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;get field width for horizontal scrolling	 ;=W
					     ;because we only show a windowful of field  ;=W
DEF15:											 ;=W
	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set ptr to rightmost character		 ;=W
	       CALL CAL_COORS		     ;get end of field char, byte		 ;=W
	       JMP  DEF30		     ;and next byte positions
;
; Initialize variables for right justified field
;
DEF20:	       ;
	       ; code here
	       ;
;
; Display default even if password option is active
;
DEF30:	       PUSH ES:[SI]+ICB_OPT1	     ;save option word
;
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JE   DEF40
;
	       AND  ES:[SI]+ICB_OPT1,NOT ICB_PSW
					     ;set option word to force disp
					     ; of default value
DEF40:
	       MOV  AX,2		     ;set option to actually display
	       CALL WORD PTR [DI]+WR_DISPLAY ; default value in proper
					     ; justification
	       POP  ES:[SI]+ICB_OPT1	     ;restore original password
;
; Display initial cursor in proper size and location
;
	       MOV  AX,[DI]+IN_CURNOR	     ;set cursor size for replace
	       MOV  [DI]+WR_CURSIZE,AX
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   DEF45		     ;check if insert is active
;
	       MOV  AX,[DI]+IN_CURINS	     ;set cursor size for insert
	       MOV  [DI]+WR_CURSIZE,AX
;
DEF45:
	       CALL CAL_COORS		     ;calculate coordinates			 ;=W
	       CALL CURSOR		     ;initialize cursor size and locat
;
; Determine if characters in input buffer are allowonce chars and set flags
;

    jmp  Def65	 ;temp until bug in allowonce scan fixed

	       PUSH ES			     ;save registers
	       PUSH SI
;
	       MOV  BX,ES		     ;set segment of ICB
	       MOV  DX,SI		     ;set offset of ICB
;
	       MOV  CX,ES:[SI]+ICB_FIELDLEN  ;get field length
;
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get field offset
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get field segment
	       POP  ES
	       POP  SI
;
DEF50:	       MOV  AL,ES:[SI]		     ;get character from input buffer
	       MOV  [DI]+DBC_KS,AL	     ; and set to PCINDBC PB
;
	       INC  SI			     ;point to next byte
;
	       CALL PCINDBC_CALL	     ;call PCINDBC

	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if keystroke double byte
	       JE   DEF60
;
	       CMP  CX,0		     ;if last loop is double character
	       JBE  DEF60		     ; and is missing trailing byte
					     ; then, consider a single byte
;
	       MOV  AH,ES:[SI]		     ;get character from input buffer
	       MOV  [DI]+DBC_KS,AH	     ; and set to PCINDBC PB
	       INC  SI			     ;point to next byte
	       DEC  CX			     ;adjust loop pointer for additial
					     ; character read (double byte)
;
DEF60:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       MOV  ES,BX		     ;load ICB
	       MOV  SI,DX
;
	       CALL ON_ALLOWONCE	     ;Scan the allowonce string for
					     ; the character in AX and set flag
					     ; if found
	       POP  SI			     ;restore registers
	       POP  ES
;
	       LOOP DEF50		     ;get next keystroke
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Display field delimiters
;
DEF65:											 ;=W
	       MOV  AX,01		     ;assume "[ ]" as delimiters                 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_BEN ;display entry delimiters			 ;=W
	       JE   DEF100		     ;no, leave 				 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_WIN ;does field use windowing			 ;=W
	       JE   DEF70		     ;no, check others				 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if delimiter = box			 ;=W
	       JE   DEF90		     ;no, display normal delimiters		 ;=W
;											 ;=W
	       MOV  AX,06		     ;display box				 ;=W
	       JMP  DEF90		     ;done with delimiters			 ;=W
DEF70:											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;does field use horiz. window		 ;=W
	       JE   DEF80								 ;=W
;											 ;=W
	       MOV  AX,03		     ;display "[ >"                              ;=W
	       CMP  ES:[SI]+ICB_HRSTART,01H  ;are we at beginning of window ?		 ;=W
	       JLE  DEF80		     ;yes					 ;=W
;
	       MOV  AX,04		     ;no, display "< >"                          ;=W
DEF80:											 ;=W
	       CALL DELIMITER		     ;do it					 ;=W
;
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if also need box			 ;=W
	       JE   DEF100								 ;=W
;											 ;=W
	       MOV  AX,06		     ;display box				 ;=W
DEF90:											 ;=W
	       CALL DELIMITER		     ;do it					 ;=W
;
; Display minus or plus sign if active
;
DEF100:
	       TEST ES:[SI]+ICB_OPT1,ICB_MUS ;Check if minus/plus sign
	       JE   DEFEXIT		     ; display option is active
;
	       MOV  [DI]+WR_KEYCONF,0	     ;initialize to plus sign key
;
	       TEST ES:[SI]+ICB_OPT1,ICB_SMU ;Check if default is negative
	       JE   DEF110
;
	       OR   [DI]+WR_KEYCONF,WR_MUS   ;initialize to minus sign key
;
DEF110:        CALL PLUS_MINUS		     ;display plus or minus sign and
					     ; set status
;
DEFEXIT:				     ;continue
;
	       RET
DEFAULT        ENDP
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; PRE_EXIT								      :
;									      :
;	  Performs the following functions:				      :
;									      :
;	  - Removes field delimiters					      :
;	  - Inserts commas as specified 				      :
;	  - Inserts decimal point as specified				      :
;	  - Adjusts field to specified significant digits		      :
;	  - Displays buffer contents in exit color			      :
;	  - Checks if original default has changed			      :
;	  - Check if entry is in specified numeric range		      :
;	  - Sets minus or plus sign indicator in exit color		      :
;	  - Remove thousand separators from input string buffer 	      :
;	  - Restore original cursor position and size, only in text mode      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
; Exit:   None								      :
;									      :
;-----------------------------------------------------------------------------+
;
PRE_EXIT       PROC NEAR

;
; Inserts commas as specified
;
	       ;
	       ; Code here
	       ;
;
; Inserts decimal point as specified
;
	       ;
	       ; Code here
	       ;
;
; Adjusts field to specified significant digits
;
	       ;
	       ; Code here
	       ;
;
; Calculate color attribute of exit colors
;
	       TEST ES:[SI]+ICB_OPT1,ICB_XCL ;check if option to use exit
	       JE   PRE10		     ; colors is active
;
	       MOV  AL,[DI]+WR_XATTR	     ;set the exit attribute to the
	       MOV  [DI]+WR_CATTR,AL	     ; current attribute
;
; Display default value of input buffer in proper justification
;
PRE10:	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set right marker
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;horizontal scrolling mode ?		 ;=W
	       JE   PRE15		     ;no, display all buffer			 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;use width instead of all buffer		 ;=W
PRE15:
	       MOV  [DI]+WR_RIGHTCHAR,AX
;
	       MOV  AX,2		     ;set option to actually display
	       CALL WORD PTR [DI]+WR_DISPLAY ; default value in proper
;					     ; justification
; Process minus/plus key options
;
	       TEST ES:[SI]+ICB_OPT1,ICB_MUS ;Check if minus/plus sign
	       JE   PRE40		     ; display option is active
;
	       MOV [DI]+WR_KEYCONF,0	     ;initialize to plus sign
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SMUS
	       JE   PRE20		     ;Check if sign is negative
;
	       OR   [DI]+WR_KEYCONF,WR_MUS   ;initialize to minus sign key
;
PRE20:	       TEST ES:[SI]+ICB_STATUS,ICB_SPUS
	       JE   PRE30		     ;Check if sign is positive
;
	       OR   [DI]+WR_KEYCONF,WR_PUS   ;initialize to plus sign key
;
PRE30:	       CALL PLUS_MINUS		     ;display plus or minus sign
					     ; according to WR_KEYCONF setting
;
; Replace field entry delimiters with exit delimiters
;
PRE40:	       TEST ES:[SI]+ICB_OPT1,ICB_BEX ;check if field delimiters
	       JE   PRE60		     ; should be displayed on exit
;
	       MOV  AX,2		     ;option to remove delimiters
	       CALL DELIMITER		     ;display delimiters
;
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if box around field
	       JE   PRE60		     ; should be displayed
;
	       MOV  AX,7		     ;set option to remove box
	       CALL DELIMITER		     ;display delimiters
;
; Check if default value has changed and set return flag
;
PRE60:	       PUSH DS			     ;save registers
	       PUSH SI
	       PUSH ES
	       PUSH DI
;
	       MOV  CX,ES:[SI]+ICB_DEFLEN    ;initialize to default length
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if default length is less
	       JBE  PRE70		     ; than field length
;
	       MOV  CX,ES:[SI]+ICB_FIELDLEN  ;initialize to field length
;
PRE70:	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;compare default string to 		 ;=W
	       MOV  DS,AX								 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDOFF						 ;=W
	       MOV  DI,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_DEFOFF    ;	current input string			 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDSEG						 ;=W
	       MOV  ES,BX								 ;=W
	       MOV  SI,AX								 ;=W
;
	       REPE CMPSB		     ;compare default and input strings
;
	       POP  DI			     ;restore registers
	       POP  ES
	       POP  SI
	       POP  DS
;
	       CMP  CX,0		     ;are we done ?				 ;=W
	       JE   PRE80		     ;check if strings compared
;
	       OR   ES:[SI]+ICB_STATUS,ICB_SDEF
					     ;set flag that default changed
;
; Check if entry is within specified numeric range, if not set flag
;
PRE80:	       ;
	       ; code here
	       ;
;
; Remove thousand separators if specified from input string buffer
;
PRE90:	       ;
	       ; code here
	       ;
;
; Restore original cursor position and size
;
PRE95:
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON  ;is cursor on ?
	       JE   PRE100			   ;no, quit
	       CALL CURSOR		     ;erase the graphics cursor
PRE100:
	       OR   ES:[SI]+ICB_STATUS,ICB_DONE ;exit condition found, exit		 ;=W
;											 ;=W
; Check if ICB_SAV option selected. If selected, then save contents of the		 ;=W
; input buffer to the default buffer.							 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT4,ICB_SAV ;check ?					 ;=W
	       JE   PRE200		     ;no, exit now				 ;=W
;											 ;=W
	       PUSH ES			     ;save registers				 ;=W
	       PUSH DS									 ;=W
	       PUSH DI									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  CX,ES:[SI]+ICB_ENDBYTE   ;# of bytes to copy from input		 ;=W
					     ; buffer to default buffer 		 ;=W
	       MOV  ES:[SI]+ICB_DEFLEN,CX    ;reset default length
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get destination segment			 ;=W
	       MOV  DS,AX								 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_DEFOFF    ;get source string offset			 ;=W
	       MOV  DI,AX								 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;get source string segment 		 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDOFF  ;get destination offset			 ;=W
	       MOV  SI,BX								 ;=W
	       MOV  ES,AX								 ;=W
;											 ;=W
	       CLD									 ;=W
	       REP  MOVSB		     ;move default into input buffer		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  DS									 ;=W
	       POP  ES									 ;=W
PRE200: 										 ;=W
	       RET
PRE_EXIT       ENDP
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHT_H_JUST								      : 	 ;=W
;									      : 	 ;=W
;	  Process keystroke and update display with input buffer changes      : 	 ;=W
;	  for the following functions:					      : 	 ;=W
;									      : 	 ;=W
;	  Home key	  Up arrow	  Allowonce replace mode	      : 	 ;=W
;	  End key	  Down arrow	  Allowonce insert mode 	      : 	 ;=W
;	  Left arrow	  Control end	  Allow replace mode		      : 	 ;=W
;	  Right arrow	  Delete key	  Allow insert mode		      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHT_H_JUST   PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHT_H_JUST   ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; RIGHT_JUST								      :
;									      :
;	  Process keystroke and update display with input buffer changes      :
;	  for the following functions:					      :
;									      :
;	  Home key	  Up arrow	  Allowonce replace mode	      :
;	  End key	  Down arrow	  Allowonce insert mode 	      :
;	  Left arrow	  Control end	  Allow replace mode		      :
;	  Right arrow	  Delete key	  Allow insert mode		      :
;									      :
;-----------------------------------------------------------------------------+
;
RIGHT_JUST     PROC NEAR
;
	       ;
	       ; code here
	       ;
;
	       RET
RIGHT_JUST     ENDP
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFT_H_JUST								      : 	 ;=W
;									      : 	 ;=W
;	  Process keystroke and update display with input buffer changes      : 	 ;=W
;	  for the following functions:					      : 	 ;=W
;									      : 	 ;=W
;	  Home key	  Up arrow	  Allowonce replace mode	      : 	 ;=W
;	  End key	  Down arrow	  Allowonce insert mode 	      : 	 ;=W
;	  Left arrow	  Control end	  Allow replace mode		      : 	 ;=W
;	  Right arrow	  Delete key	  Allow insert mode		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  Following information is used:				      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				   buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_CUBYTE)	 Byte offset into the input buffer    : 	 ;=W
;	    				 of where characters will be added    : 	 ;=W
;	    				 to input buffer.		      : 	 ;=W
;	    								      : 	 ;=W
;	  	      : 	 ;=W
;	   S  L  T  L  T  S  S                      	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		 (ICB_FIELDLEN) Length of input field in bytes. 	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following demonstrates the before and after input buffer	      : 	 ;=W
;	  images.  (S = Single byte, L = DBCS lead byte, T = DBCS trailing    : 	 ;=W
;	  byte) 							      : 	 ;=W
;									      : 	 ;=W
;	  Deleting a double byte:					      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	   	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Deleting a single byte:					      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Backspace removal of a double byte:				      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	   	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Backspace removal of a single byte:				      : 	 ;=W
;		   	      : 	 ;=W
;		 S  S  S  S  L  T     S  S  S  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a double byte:			      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a single byte: (Option 1)	      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S  S    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a single byte: (Option 2)	      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	 S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a single byte:			      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a double byte.			      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S    	    S  L  T  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a double byte without enough buffer:   : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a single byte.					      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T 	    S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a single byte without enough buffer generate an error:    : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S  S 	    S  L  T  S  S    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a double byte character:				      : 	 ;=W
;		   	      : 	 ;=W
;		 S  L  T  S    	    S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI       = Points to current ICB				      : 	 ;=W
;	  DS:DI       = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  INC_KS      = Keystroke from returned from PCINCHA		      : 	 ;=W
;									      : 	 ;=W
;	  WR_KEYCONF  = Bit flag inidicating the options set for INC_KS       : 	 ;=W
;	  WR_KEYCONF2	keystroke.					      : 	 ;=W
;									      : 	 ;=W
; Exit:   None. 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFT_H_JUST    PROC NEAR								 ;=W
;											 ;=W
; Initialize right and left boundary markers						 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF,WR_MASK  ;check to see if editing key entered	 ;=W
	       JNE  LHJ5		     ;yes, must check for editing keys		 ;=W
	       JMP  LHJ190		     ;no, skip checks for editing keys		 ;=W
											 ;=W
;											 ;=W
; Process home key									 ;=W
;											 ;=W
LHJ5:	       TEST [DI]+WR_KEYCONF,WR_HOM   ;check if home key pressed 		 ;=W
	       JE   LHJ10								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WHM option to process window home key movement 		 ;=W
	       ;									 ;=W
;											 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;initialize cursor to 1st byte		 ;=W
					     ; position, assuming no windowing		 ;=W
					     ; wrap is occurring			 ;=W
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJEXIT		     ; returns WR_CURROW, WR_CURROW		 ;=W
					     ; and WR_CUBYTE				 ;=W
;											 ;=W
; Process end key									 ;=W
;											 ;=W
LHJ10:	       TEST [DI]+WR_KEYCONF,WR_END   ;check if home key pressed 		 ;=W
	       JNE  LHJ12								 ;=W
	       JMP  LHJ20
LHJ12:											 ;=W
	       ;									 ;=W
	       ; add ICB_WEN to move cursor to end of current window row		 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get current end of field info		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;adjust one past end buffer charac 	 ;=W
	       INC  AX									 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;set current cursor position to		 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ17		     ;no					 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ15
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       JMP  LHJ19		     ;exit
LHJ15:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ16		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
LHJ16:											 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
	       JMP  LHJ19								 ;=W
LHJ17:											 ;=W
	       MOV  CX,[DI]+WR_CUBYTE	     ;check if need to adjust horz.		 ;=W
	       CMP  CX,ES:[SI]+ICB_WIDTH     ; window					 ;=W
	       JA   LHJ18								 ;=W
	       MOV  [DI]+WR_HRCHAR,1							 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       JMP  LHJ19								 ;=W
LHJ18:											 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;yes, adjust it				 ;=W
	       SUB  BX,ES:[SI]+ICB_WIDTH						 ;=W
	       ADD  BX,2								 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
LHJ19:											 ;=W
	       CALL CAL_COORS		     ;re-calculate display			 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process left arrow									 ;=W
;											 ;=W
LHJ20:	       TEST [DI]+WR_KEYCONF,WR_LFT   ;check if left arrow key pressed		 ;=W
	       JE   LHJ40								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_CSW option to wrap cursor from top/bottom end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WAR option to wrap cursor on same row end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;get cursor position			 ;=W
	       CMP  BX,1		     ;is cursor in first position ?		 ;=W
	       JA   LHJ30		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ23
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,BX   ;wrap to first character position
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
;
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ32		     ;exit
LHJ23:
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ25		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LHJ400								 ;=W
LHJ25:											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ30:											 ;=W
	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position		 ;=W
;
	       CMP  BX,[DI]+WR_HRCHAR	     ;is cursor to the left of horz.wind. ?	 ;=W
	       JG   LHJ32		     ;no					 ;=W
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust horiz. window 		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ32:					     ; towards the left 			 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process right arrow									 ;=W
;											 ;=W
LHJ40:	       TEST [DI]+WR_KEYCONF,WR_RGT   ;check if left arrow key pressed		 ;=W
	       JE   LHJ60								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WAR option to wrap cursor on same row end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
;											 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ50								 ;=W
;											 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
LHJ50:	       INC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position		 ;=W
					     ; towards the right			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ52		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ52:											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ55		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ53
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ55		     ;exit
LHJ53:
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ55		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ55:											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process up arrow									 ;=W
;											 ;=W
LHJ60:	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											 ;=W
; Process down arrow									 ;=W
;											 ;=W
LHJ70:	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											;=W
; Process cntrl+end key 								 ;=W
;											 ;=W
LHJ80:	       TEST [DI]+WR_KEYCONF,WR_CED   ;check if control+end key pressed		 ;=W
	       JE   LHJ100								 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ90								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ90:
	       MOV  BX,[DI]+WR_CUBYTE	     ;delete from current byte position 	 ;=W
	       CALL CLEAR_BUFFER							 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process delete key									 ;=W
;											 ;=W
LHJ100:        TEST [DI]+WR_KEYCONF,WR_DEL   ;check if delete key pressed		 ;=W
	       JE   LHJ130								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; Add ICB_WDL option in off state to delete on current line only 	 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
;											 ;=W
	       CMP  [DI]+WR_FIELDEND,1	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ110								 ;=W
;											 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst 	 ;=W
					     ; and shift remaining in place		 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
LHJ110:        CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process backspace key 								 ;=W
;											 ;=W
LHJ130:        TEST [DI]+WR_KEYCONF,WR_BCK   ;check if backspace key pressed		 ;=W
	       JE   LHJ160								 ;=W
;											 ;=W
	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;get cursor position			 ;=W
	       CMP  BX,1		     ;check if cursor is at first		 ;=W
	       JA   LHJ140		     ; field position				 ;=W
;
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ133
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,BX   ;wrap to first character position
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
;
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ145		     ;exit
LHJ133:
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ135		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ400								 ;=W
LHJ135: 										 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ140: 										 ;=W
	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left 			 ;=W
	       CMP  BX,[DI]+WR_HRCHAR	     ;is cursor in front of the wind. ? 	 ;=W
	       JG   LHJ142		     ;no					 ;=W
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ142: 										 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst 	 ;=W
					     ; and shift remaining in place		 ;=W
LHJ145: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process insert key toggle								 ;=W
;											 ;=W
LHJ160:        TEST [DI]+WR_KEYCONF,WR_INS   ;check if insert key pressed		 ;=W
	       JE   LHJ180		     ; if not, continue 			 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS  ;check if in insert mode ?		 ;=W
	       JE   LHJ165		     ;no, put in insert mode			 ;=W
;											 ;=W
	       MOV  BX,[DI]+IN_CURNOR	     ;set cursor size for normal		 ;=W
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor					 ;=W
;											 ;=W
	       AND  ES:[SI]+ICB_STATUS,NOT ICB_SINS					 ;=W
	       JMP  LHJ170		     ;turn insert mode off			 ;=W
;											 ;=W
LHJ165:        MOV  BX,[DI]+IN_CURINS	     ;set cursor size for insert		 ;=W
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor					 ;=W
;											 ;=W
	       OR   ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
					     ;turn insert mode on			 ;=W
;											 ;=W
LHJ170: 										 ;=W
;											 ;=W
	       PUSH DS			     ;save registers				 ;=W
	       PUSH DI									 ;=W
;											 ;=W
	       MOV  DI,40H		     ;point DS:DI to KB_FLAG in BIOS		 ;=W
	       MOV  DS,DI								 ;=W
	       MOV  DI,17H								 ;=W
	       MOV  AX,[DI]		     ;get current BIOS KB_FLAG			 ;=W
;											 ;=W
	       AND  AX,NOT WR_INSSTATE	     ;set BIOS insert active flag off		 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
	       JE   LHJ175		     ;check if insert should be set on		 ;=W
;											 ;=W
	       OR   AX,WR_INSSTATE	     ;set BIOS insert active flag on		 ;=W
;											 ;=W
LHJ175:        POP  DI			     ;restore registers 			 ;=W
	       POP  DS									 ;=W
;											 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process allowonce key option								 ;=W
;											 ;=W
LHJ180:        ;									 ;=W
	       ; insert or replace							 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; adjust input buffer							 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
;											 ;=W
; Process allowed keystroke in replace mode						 ;=W
;											 ;=W
LHJ190:        TEST [DI]+WR_KEYCONF,WR_ALL   ;check if allow key pressed		 ;=W
	       JNE  LHJ195								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
LHJ195:        TEST ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
	       JE   LHJ198		     ;check if insert is active 		 ;=W
;											 ;=W
	       JMP  LHJ270		     ;do insert display 			 ;=W
;											 ;=W
LHJ198: 										 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ200								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Check if character to be replaced in field buffer is double byte character		 ;=W
;											 ;=W
LHJ200:        PUSH ES			     ;save registers				 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer		 ;=W
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer		 ;=W
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       ADD  SI,[DI]+WR_CUBYTE	     ;add cursor offset into buffer		 ;=W
	       DEC  SI			     ;make zero based				 ;=W
;											 ;=W
	       MOV  CX,ES		     ;save offset of character to		 ;=W
	       MOV  DX,SI		     ; replace					 ;=W
;											 ;=W
	       MOV  AL,ES:[SI]		     ;get byte that cursor is pointing		 ;=W
	       MOV  [DI]+DBC_KS,AL	     ; to check if DBCS 			 ;=W
	       CALL PCINDBC_CALL	     ;call routine to check if char		 ;=W
					     ; is lead double byte char 		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS		 ;=W
	       JE   LHJ220		     ; if no, jump to single byte code		 ;=W
;											 ;=W
; Replace double byte character with double byte character				 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if keystroke is DBC 		 ;=W
	       JE   LHJ210		     ;continue with single byte 		 ;=W
;											 ;=W
	       MOV  AX,[DI]+INC_KS	     ;set double byte character to		 ;=W
					     ; input buffer replacing			 ;=W
					     ; double byte character			 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace					 ;=W
	       MOV  ES:[SI],AX		     ;replace double byte			 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace double byte character with single byte character				 ;=W
;											 ;=W
LHJ210:        MOV  AX,[DI]+INC_KS	     ;get keystroke and replace double		 ;=W
					     ; byte with single byte			 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte				 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX						 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       INC  AX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  BX,1		     ;set number of positions to shift		 ;=W
	       MOV  AX,2		     ;set option to shift left			 ;=W
	       CALL SHIFT		     ;call shift 1 position toward left 	 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace single byte character with single byte character				 ;=W
;											 ;=W
LHJ220:        TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if double byte character		 ;=W
	       JNE  LHJ230		     ; continue with single byte		 ;=W
;											 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace single byte character with double byte character				 ;=W
;											 ;=W
LHJ230: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;get end byte of input field		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character		 ;=W
	       JA   LHJ240								 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set cursor character position		 ;=W
LHJ240: 										 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get end of field position 		 ;=W
	       SUB  AX,BX		     ;subtract to get the remaining space	 ;=W
	       CMP  AX,1		     ;will byte fit ?				 ;=W
	       JGE  LHJ250		     ;yes					 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep because replace char		 ;=W
	       JMP  LHJEXIT		     ; will not fit and exit			 ;=W
;											 ;=W
LHJ250:        MOV  BX,ES:[SI]+ICB_FIELDLEN  ;set ending byte				 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,BX						 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       INC  BX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,BX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  BX,1		     ;set number of positions to shift		 ;=W
	       MOV  AX,1		     ;set option to shift right 		 ;=W
	       CALL SHIFT		     ;call shift 1 position toward		 ;=W
					     ; left					 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace double byte			 ;=W
	       MOV  ES:[SI],AX								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Calculate new ending and cursor coordinates						 ;=W
;											 ;=W
LHJ260: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ265		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ265: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ267		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ266
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ267		     ;exit
LHJ266:

	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LHJ267		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ267: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process allowed keystroke in insert mode						 ;=W
;											 ;=W
LHJ270: 										 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ280								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		      ;exit					 ;=W
;											 ;=W
; Check if enough room available to insert single or double byte character		 ;=W
;											 ;=W
LHJ280: 										 ;=W
	       MOV  CX,ES:[SI]+ICB_FIELDSEG  ;get segment of input buffer		 ;=W
	       MOV  DX,ES:[SI]+ICB_FIELDOFF  ;get offset of input buffer		 ;=W
;											 ;=W
	       ADD  DX,[DI]+WR_CUBYTE	     ;add cursor offset into buffer		 ;=W
	       DEC  DX			     ;make zero based				 ;=W
;											 ;=W
	       MOV  BX,1		     ;initialize to single byte 		 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check for double byte character		 ;=W
	       JE   LHJ290								 ;=W
;											 ;=W
	       MOV  BX,2		     ;reset to double byte character		 ;=W
LHJ290: 										 ;=W
	       PUSH BX									 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;get end byte of input field		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character		 ;=W
	       JA   LHJ300								 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set cursor character position		 ;=W
LHJ300: 										 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get end of field position 		 ;=W
	       SUB  AX,BX		     ;subtract to get the remaining space	 ;=W
	       POP  BX									 ;=W
	       CMP  AX,BX		     ;will byte fit ?				 ;=W
	       JGE  LHJ310		     ;yes					 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep replace character		 ;=W
	       JMP  LHJEXIT		     ; will not fit and exit			 ;=W
;											 ;=W
; Shift to insert single or double byte character, BX= # bytes to shift 		 ;=W
;											 ;=W
LHJ310:        MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte to make room in		 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; buffer by shifting characters		 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  AX,1		     ;set option to shift right, BX=		 ;=W
					     ; number of bytes to insert		 ;=W
	       CALL SHIFT		     ;call shift 1 position toward		 ;=W
					     ; left					 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
; Insert single byte character								 ;=W
;											 ;=W
	       CMP  BX,2		     ;check how many bytes should be		 ;=W
	       JE   LHJ320		     ; inserted 				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL		     ;insert single byte character		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ330								 ;=W
;											 ;=W
; Insert double byte character								 ;=W
;											 ;=W
LHJ320:        PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace					 ;=W
	       MOV  ES:[SI],AX		     ;insert double byte character		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Calculate new ending and cursor coordinates						 ;=W
;											 ;=W
LHJ330: 										 ;=W
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
;											 ;=W
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ332		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ332: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ335		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ333
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ335		     ;exit
LHJ333:
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LHJ335		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ335:
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;display cursor
;											 ;=W
; Display field & Exit									 ;=W
;											 ;=W
LHJ400:
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer		 ;=W
					     ; in left justified field			 ;=W
	       JMP  LHJCUR
LHJEXIT:										 ;=W
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer		 ;=W
					     ; in left justified field			 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON ;is cursor on ?
	       JNE  LHJCUR			  ;cursor is already on, don't turn it on ;=W
	       CALL CURSOR		     ;display cursor				 ;=W
LHJCUR:
;											 ;=W
	       RET									 ;=W
LEFT_H_JUST    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; LEFT_JUST								      :
;									      :
;	  Process keystroke and update display with input buffer changes      :
;	  for the following functions:					      :
;									      :
;	  Home key	  Up arrow	  Allowonce replace mode	      :
;	  End key	  Down arrow	  Allowonce insert mode 	      :
;	  Left arrow	  Control end	  Allow replace mode		      :
;	  Right arrow	  Delete key	  Allow insert mode		      :
;									      :
;									      :
;	  Following information is used:				      :
;									      :
;									      :
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      :
;	    				   buffer in memory.		      :
;	    								      :
;	    		 (WR_CUBYTE)	 Byte offset into the input buffer    :
;	    				 of where characters will be added    :
;	    				 to input buffer.		      :
;	    								      :
;	  	      :
;	   S  L  T  L  T  S  S                      	      :
;	  	      :
;	    	      :
;				     					      :
;		 (ICB_FIELDLEN) Length of input field in bytes. 	      :
;									      :
;									      :
;	  The following demonstrates the before and after input buffer	      :
;	  images.  (S = Single byte, L = DBCS lead byte, T = DBCS trailing    :
;	  byte) 							      :
;									      :
;	  Deleting a double byte:					      :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  S 	   	      :
;		   	      :
;									      :
;	  Deleting a single byte:					      :
;		   	      :
;		 S  L  T  S  L  T     S  L  T  L  T    	      :
;		   	      :
;									      :
;	  Backspace removal of a double byte:				      :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  S 	   	      :
;		   	      :
;									      :
;	  Backspace removal of a single byte:				      :
;		   	      :
;		 S  S  S  S  L  T     S  S  S  L  T    	      :
;		   	      :
;									      :
;	  Replacing a double byte with a double byte:			      :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      :
;		   	      :
;									      :
;	  Replacing a double byte with a single byte: (Option 1)	      :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  S  S    	      :
;		   	      :
;									      :
;	  Replacing a double byte with a single byte: (Option 2)	      :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  S 	 S 	      :
;		   	      :
;									      :
;	  Replacing a single byte with a single byte:			      :
;		   	      :
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Replacing a single byte with a double byte.			      :
;		   	      :
;		 S  L  T  S    	    S  L  T  L  T    	      :
;		   	      :
;									      :
;	  Replacing a single byte with a double byte without enough buffer:   :
;		   	      :
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Inserting a single byte.					      :
;		   	      :
;		 S  L  T  L  T 	    S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Inserting a single byte without enough buffer generate an error:    :
;		   	      :
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      :
;		   	      :
;		   	      :
;		 S  L  T  S  S 	    S  L  T  S  S    	      :
;		   	      :
;									      :
;	  Inserting a double byte character:				      :
;		   	      :
;		 S  L  T  S    	    S  L  T  L  T  S 	      :
;		   	      :
;									      :
;									      :
; Entry:  ES:SI       = Points to current ICB				      :
;	  DS:DI       = Points to PB					      :
;									      :
;	  INC_KS      = Keystroke from returned from PCINCHA		      :
;									      :
;	  WR_KEYCONF  = Bit flag inidicating the options set for INC_KS       :
;	  WR_KEYCONF2	keystroke.					      :
;									      :
; Exit:   None. 							      :
;									      :
;-----------------------------------------------------------------------------+
;
LEFT_JUST      PROC NEAR
;
; Initialize right and left boundary markers
;
	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character to beginning
					     ; of field
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set right marker past end of
	       INC  AX			     ; field
	       MOV  [DI]+WR_RIGHTCHAR,AX
;
	       TEST [DI]+WR_KEYCONF,WR_MASK  ;check to see if editing key entered	 ;=W
	       JNE  LJ5 		     ;yes, must check for editing keys		 ;=W
	       JMP  LJ190		     ;no, skip checks for editing keys		 ;=W

;
; Process home key
;
LJ5:	       TEST [DI]+WR_KEYCONF,WR_HOM   ;check if home key pressed
	       JE   LJ10
;
	       ;
	       ; add ICB_WHM option to process window home key movement
	       ;
;
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;initialize cursor to 1st byte
					     ; position, assuming no windowing
					     ; wrap is occurring
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJEXIT		     ; returns WR_CURROW, WR_CURROW
					     ; and WR_CUBYTE
;
; Process end key
;
LJ10:	       TEST [DI]+WR_KEYCONF,WR_END   ;check if home key pressed
	       JE   LJ20
;
	       ;
	       ; add ICB_WEN to move cursor to end of current window row
	       ;
;
	       CALL CAL_COORS		     ;get current end of field info		 ;=W
;
	       MOV  AX,[DI]+WR_ENCHAR	     ;adjust one past end buffer charac
	       INC  AX
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;set current cursor position to
					     ; end of field
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ17		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ16
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       CALL CAL_COORS		     ;get cursor position
	       JMP  LJEXIT		     ;exit
LJ16:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ17		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
LJ17:											 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process left arrow
;
LJ20:	       TEST [DI]+WR_KEYCONF,WR_LFT   ;check if left arrow key pressed
	       JE   LJ40
;
	       ;
	       ; add ICB_WAR option to wrap cursor on same row end to end
	       ;
;
	       CMP  ES:[SI]+ICB_CURCHAR,1    ;check if cursor is at first
	       JA   LJ30		     ; field position
;
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ25		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LJCUR								 ;=W
LJ25:											 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ27
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get last position
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;put as current position
	       CALL CAL_COORS
	       JMP  LJEXIT
LJ27:
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ30:	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process right arrow
;
LJ40:	       TEST [DI]+WR_KEYCONF,WR_RGT   ;check if left arrow key pressed
	       JE   LJ60
;
	       ;
	       ; add ICB_CSW option to wrap cursor from top/bottom end to end
	       ;
;
	       ;
	       ; add ICB_AXC option to auto enter if cursor reaches end
	       ;
;
	       ;
	       ; add ICB_WAR option to wrap cursor on same row end to end
	       ;
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ50
;
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ50:	       INC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ55		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ52
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       CALL CAL_COORS		     ;get cursor position
	       JMP  LJEXIT		     ;exit
LJ52:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ55		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LJ55:											 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process up arrow
;
LJ60:	       ;
	       ; adjust cursor position
	       ;

	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
; Process down arrow
;
LJ70:	       ;
	       ; adjust cursor position
	       ;

	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
; Process cntrl+end key
;
LJ80:	       TEST [DI]+WR_KEYCONF,WR_CED   ;check if control+end key pressed
	       JE   LJ100
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ90
;
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ90:	       CALL CAL_COORS		     ;get current end of field info		 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set rightmost area to refresh on
	       MOV  [DI]+WR_RIGHTDISP,AX     ; display to entire field
;
	       MOV  BX,[DI]+WR_CUBYTE	     ;delete from current byte position
	       CALL CLEAR_BUFFER
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process delete key
;
LJ100:	       TEST [DI]+WR_KEYCONF,WR_DEL   ;check if delete key pressed
	       JE   LJ130
;
	       ;
	       ; Add ICB_WDL option in off state to delete on current line only
	       ;
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,1	     ;check if cursor past end of field
	       JE   LJ110
;
	       CALL REMOVE_CHAR 	     ;remove character at current offst
					     ; and shift remaining in place
	       JMP  LJ340		     ;display field, set cursor, exit
;
LJ110:	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
; Process backspace key
;
LJ130:	       TEST [DI]+WR_KEYCONF,WR_BCK   ;check if backspace key pressed
	       JE   LJ160
;
	       CMP  ES:[SI]+ICB_CURCHAR,1    ;check if cursor is at first
	       JA   LJ140		     ; field position
;
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ135		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LJCUR								 ;=W
LJ135:											 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ137
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get last position
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;put as current position
	       CALL CAL_COORS
	       JMP  LJEXIT
LJ137:
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ140:	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst
					     ; and shift remaining in place
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process insert key toggle
;
LJ160:	       TEST [DI]+WR_KEYCONF,WR_INS   ;check if insert key pressed
	       JE   LJ180		     ; if not, continue
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS  ;check if in insert mode ?
	       JE   LJ165		     ;no, put in insert mode
;
	       MOV  BX,[DI]+IN_CURNOR	     ;set cursor size for normal
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor
;
	       AND  ES:[SI]+ICB_STATUS,NOT ICB_SINS
	       JMP  LJ170		     ;turn insert mode off
;
LJ165:	       MOV  BX,[DI]+IN_CURINS	     ;set cursor size for insert
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor
;
	       OR   ES:[SI]+ICB_STATUS,ICB_SINS
					     ;turn insert mode on
;
LJ170:
;
	       PUSH DS			     ;save registers
	       PUSH DI
;
	       MOV  DI,40H		     ;point DS:DI to KB_FLAG in BIOS
	       MOV  DS,DI
	       MOV  DI,17H
	       MOV  AX,[DI]		     ;get current BIOS KB_FLAG
;
	       AND  AX,NOT WR_INSSTATE	     ;set BIOS insert active flag off
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   LJ175		     ;check if insert should be set on
;
	       OR   AX,WR_INSSTATE	     ;set BIOS insert active flag on
;
LJ175:	       POP  DI			     ;restore registers
	       POP  DS
;
	       JMP  LJEXIT		     ;exit
;
; Process allowonce key option
;
LJ180:	       ;
	       ; insert or replace
	       ;
;
	       ;
	       ; adjust input buffer
	       ;
;
	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
	       ;
	       ; adjust cursor position
	       ;
;
; Process allowed keystroke in replace mode
;
LJ190:	       TEST [DI]+WR_KEYCONF,WR_ALL   ;check if allow key pressed
	       JNE  LJ195
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
LJ195:	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   LJ198		     ;check if insert is active
;
	       JMP  LJ270		     ;do insert display
;
LJ198:
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ200
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
; Check if character to be replaced in field buffer is double byte character
;
LJ200:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       ADD  SI,[DI]+WR_CUBYTE	     ;add cursor offset into buffer
	       DEC  SI			     ;make zero based
;
	       MOV  CX,ES		     ;save offset of character to
	       MOV  DX,SI		     ; replace
;
	       MOV  AL,ES:[SI]		     ;get byte that cursor is pointing
	       MOV  [DI]+DBC_KS,AL	     ; to check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS
	       JE   LJ220		     ; if no, jump to single byte code
;
; Replace double byte character with double byte character
;
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if keystroke is DBC
	       JE   LJ210		     ;continue with single byte
;
	       MOV  AX,[DI]+INC_KS	     ;set double byte character to
					     ; input buffer replacing
					     ; double byte character
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace
	       MOV  ES:[SI],AX		     ;replace double byte
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ260		     ;exit
;
; Replace double byte character with single byte character
;
LJ210:	       MOV  AX,[DI]+INC_KS	     ;get keystroke and replace double
					     ; byte with single byte
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte
	       MOV  [DI]+WR_RIGHTBYTE,AX
;
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       INC  AX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte
;
	       MOV  BX,1		     ;set number of positions to shift
	       MOV  AX,2		     ;set option to shift left
	       CALL SHIFT		     ;call shift 1 position toward left
	       JMP  LJ260		     ;exit
;
; Replace single byte character with single byte character
;
LJ220:	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if double byte character
	       JNE  LJ230		     ; continue with single byte
;
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ260		     ;exit
;
; Replace single byte character with double byte character
;
LJ230:	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;set cursor character position
	       MOV  [DI]+WR_LEFTCHAR,BX      ; to left marker
;
	       CALL CAL_COORS		     ;get the current end of field		 ;=W
					     ; coordinates
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character
	       JA   LJ240
;
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;cursor is past last char
;
LJ240:	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set right marker
;
	       MOV  BX,1		     ;One byte is already available
					     ; check if room for trailing byte
	       MOV  AX,1		     ;set up call to LEFT_DISP to
	       CALL WORD PTR [DI]+WR_DISPLAY ; determine if additional byte
					     ; will fit in input buffer
	       CMP  AX,0		     ;check if double byte character
	       JE   LJ250		     ; will fit
;
	       CALL PCMBEEP_CALL	     ;error beep because replace char
	       JMP  LJEXIT		     ; will not fit and exit
;
LJ250:	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;set ending byte
	       MOV  [DI]+WR_RIGHTBYTE,BX
;
	       MOV  BX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       INC  BX			     ;adjust past replaced leading byte
	       MOV  [DI]+WR_LEFTBYTE,BX      ; trailing byte
;
	       MOV  BX,1		     ;set number of positions to shift
	       MOV  AX,1		     ;set option to shift right
	       CALL SHIFT		     ;call shift 1 position toward
					     ; left
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace double byte
	       MOV  ES:[SI],AX
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Calculate new ending and cursor coordinates
;
LJ260:
	       MOV  BX,[DI]+WR_ENCHAR	     ;set rightmost area to refresh on		 ;=W
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
	       CMP  BX,[DI]+WR_ENCHAR	     ;is old END_CHAR > new END_CHAR ?		 ;=W
	       JG   LJ261		     ;yes, use old END_CHAR (so display 	 ;=W
	       MOV  BX,[DI]+WR_ENCHAR	     ; is updated correctly)

LJ261:					     ;set rightmost area to refresh on		 ;=W
	       MOV  [DI]+WR_RIGHTDISP,BX     ; display to new ending character

	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char

	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ265		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ262
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       JMP  LJ340		     ;display field, set cursor, exit
LJ262:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LJ265		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LJ265:											 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process allowed keystroke in insert mode
;
LJ270:
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ280
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
; Check if enough room available to insert single or double byte character
;
LJ280:
	       MOV  CX,ES:[SI]+ICB_FIELDSEG  ;get segment of input buffer
	       MOV  DX,ES:[SI]+ICB_FIELDOFF  ;get offset of input buffer
;
	       ADD  DX,[DI]+WR_CUBYTE	     ;add cursor offset into buffer
	       DEC  DX			     ;make zero based
;
	       MOV  BX,1		     ;initialize to single byte
;
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check for double byte character
	       JE   LJ290
;
	       MOV  BX,2		     ;reset to double byte character
;
LJ290:	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;set cursor character position
	       MOV  [DI]+WR_LEFTCHAR,AX      ; to left marker
;
	       CALL CAL_COORS		     ;get the current end of field		 ;=W
					     ; coordinates
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field
;
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character
	       JA   LJ300
;
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;cursor is past last char
	       DEC  AX
;
LJ300:	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set right marker
;
	       MOV  AX,1		     ;set up call to LEFT_DISP to
	       CALL WORD PTR [DI]+WR_DISPLAY ; determine if additional byte
					     ; will fit in input buffer
					     ; BX= number of bytes to insert
	       CMP  AX,0		     ;check if double byte character
	       JE   LJ310		     ; will fit
;
	       CALL PCMBEEP_CALL	     ;error beep replace character
	       JMP  LJEXIT		     ; will not fit and exit
;
; Shift to insert single or double byte character, BX= # bytes to shift
;
LJ310:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte to make room in
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; buffer by shifting characters
;
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte
;
	       MOV  AX,1		     ;set option to shift right, BX=
					     ; number of bytes to insert
	       CALL SHIFT		     ;call shift 1 position toward
					     ; left
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
; Insert single byte character
;
	       CMP  BX,2		     ;check how many bytes should be
	       JE   LJ320		     ; inserted
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL		     ;insert single byte character
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ330
;
; Insert double byte character
;
LJ320:	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace
	       MOV  ES:[SI],AX		     ;insert double byte character
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Calculate new ending and cursor coordinates
;
LJ330:
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
;
	       MOV  AX,[DI]+WR_ENCHAR	     ;set rightmost area to refresh on
	       MOV  [DI]+WR_RIGHTDISP,AX     ; display to old ending character
;
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ340		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ335
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       JMP  LJ340		     ;display field, set cursor, exit
LJ335:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LJ340		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
;
; Display field
;
LJ340:
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;set left character to cursor
	       DEC  AX			     ; last cursor position
	       MOV  [DI]+WR_LEFTCHAR,AX
;
	       MOV  AX,[DI]+WR_RIGHTDISP     ;set right character marker to		 ;=W
	       MOV  [DI]+WR_RIGHTCHAR,AX     ; max possible field length
;
	       CALL CAL_COORS		     ;get end of field char, byte		 ;=W
					     ; and next byte positions

	       MOV  AX,2		     ;set display option
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer
					     ; in left justified field
;
; Exit
;
LJEXIT: 					  ;continue
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON ;is cursor on ?
	       JNE  LJCUR			  ;cursor is already on, don't turn it on ;=W
	       CALL CURSOR			  ;display cursor			      ;=W
LJCUR:
;
	       RET
LEFT_JUST      ENDP
;-----------------------------------------------------------------------------+
;									      :
; CAL_COORS								      :
;									      :
;	 Calculates character coordinates based on the display format	      :
;	 currently active (windowing and horizontal display).		      :
;									      :
;	 The following examples demonstrate the values that are set on	      :
;	 exit from this routine:					      :
;									      :
;									      :
;	 Example: Horizontal field coordinates calculated.		      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2							      :
;		  3	   [sLtLtssss....]				      :
;			       ^					      :
;			          					      :
;			           WR_ENCHAR = 7			      :
;			             WR_ENBYTE = 9			      :
;			             WR_RGCHAR = 7			      :
;			      					      :
;			       WR_CUCHAR = 3			      :
;			    	       WR_CUBYTE = 4			      :
;			    	       WR_UPCHAR = 3			      :
;			    	       WR_DNCHAR = 3			      :
;			    	       WR_CURROW = 3			      :
;			    	       WR_CURCOL = 13			      :
;			    						      :
;			     WR_LFCHAR = 1			      :
;				       WR_HRCHAR = 1			      :
;									      :
;									      :
;	 Example: Horizontal field scroll coordinates calculated:	      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2	     					      :
;		  3	    sLtLt Ltsss.....				      :
;			    					      :
;			      ^					      :
;			      					      :
;			      	 WR_ENCHAR = 7 		      :
;			      	  WR_ENBYTE = 10		      :
;			      	  WR_RGCHAR = 7 		      :
;			      					      :
;			       WR_CUCHAR = 3 		      :
;			      	  WR_CUBYTE = 4 		      :
;			      	  WR_UPCHAR = 3 		      :
;			      	  WR_DNCHAR = 3 		      :
;			      	  WR_CURROW = 3 		      :
;			      	  WR_CURCOL = 14		      :
;			      					      :
;			      WR_HRCHAR = 2 		      :
;			    						      :
;			     WR_LFCHAR = 1 		      :
;									      :
;									      :
;									      :
;	 Example: Windowed field coordinates calculated.		      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2		      WR_LFCHAR=	6	      :
;		  3		     	   WR_UPCHAR=	3	      :
;		  4		      				      :
;		  5		      ABCDE				      :
;		  6		     FGHI.				      :
;		  7		         WR_RGCHAR= 10	      :
;		  8		        WR_ENCHAR=	9	      :
;		  9			 				      :
;					  WR_CUCHAR=	8	      :
;					 	  WR_CURCOL= 24	      :
;					 	  WR_CURROW=	6	      :
;					 				      :
;					  WR_DNCHAR= 13	      :
;									      :
;									      :
; Entry: ICB_CURCHAR   = The character position into the input field from     :
;			 which the exit coordinates will be calculated.       :
;									      :
;	 WR_HRCHAR     = The character position into the input field that     :
;			 is currently the first displayed character of the    :
;			 horizontal window.				      :
;									      :
;	 ICB_WIDTH     = The width of windowed or horizontal scroll field.    :
;									      :
;	 ICB_FIELDLEN  = Input field buffer length.			      :
;									      :
;	 ICB_FIELDOFF  = Input field buffer offset.			      :
;									      :
;	 ICB_FIELDSEG  = Input field buffer segment.			      :
;									      :
;									      :
; Exit:  WR_RGCHAR     = Character offset into input buffer of the character  :
;			 appearing at the beginning of the current line that  :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_LFCHAR     = Character offset into input buffer of the character  :
;			 appearing at the end of the current line that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_UPCHAR     = Character offset into input buffer of the character  :
;			 displayed directly above the position that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_DNCHAR     = Character offset into input buffer of the character  :
;			 displayed directly below the position that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_ENCHAR     = Number of characters currently entered in the	      :
;			 field.  This value may be less than the number       :
;			 of bytes used to represent the characters if	      :
;			 double byte characters are present.		      :
;									      :
;	 WR_CURROW     = Actual row offset into the video buffer of the       :
;			 character specified by WR_CURCHAR.		      :
;									      :
;	 WR_CURCOL     = Actual column offset into the video buffer of the    :
;			 character specified by WR_CUCHAR.		      :
;									      :
;	 WR_ENBYTE     = Number of bytes currently used to represent	      :
;			 entered characters in the buffer.  This counter      :
;			 can be used to calculate the current end	      :
;			 position of the entered data in the field.	      :
;									      :
;	 WR_CUBYTE     = Number of bytes into input field where WR_CUCHAR     :
;			 appears.					      :
;									      : 	 ;=W
;	 WR_CUCHAR     = Offset of current cursor position in input field.    : 	 ;=W
;									      : 	 ;=W
;	 WR_HRBYTE     = Number of bytes into input field where WR_HRCHAR     :
;			 appears.					      :
;									      :
;	 WR_FIELDEND   = Boolean flag,	 0 = cursor not past end of field     : 	 ;=W
;					 1 = cursor is past end of field      : 	 ;=W
;									      :
;-----------------------------------------------------------------------------+
;
CAL_COORS      PROC NEAR
;
	       PUSH AX			     ;save registers
	       PUSH BX
	       PUSH CX
	       PUSH DX
	       PUSH ES
	       PUSH SI
	       PUSH BP									 ;=W
;											 ;=W
; initialize general variables for all display modes					 ;=W
;
	       MOV  [DI]+WR_FIELDEND,0	     ;initialize boolean flag that		 ;=W
					     ;cursor is not past end of field		 ;=W
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;get current char. offset			 ;=W
	       MOV  [DI]+WR_CUCHAR,AX	     ;save it					 ;=W
;
	       MOV  AX,ES:[SI]+ICB_ROW	     ;initialize row offset of field		 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_CURROW,AX	     ;char row offset inot video buf		 ;=W
	       MOV  AX,ES:[SI]+ICB_COL	     ;initialize col offset of field		 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_CURCOL,AX	     ;char col offset into video buf		 ;=W
;
	       MOV  [DI]+WR_LFCHAR,1	     ;leftmost character possible char		 ;=W
	       MOV  [DI]+WR_RGCHAR,1	     ;rightmost character possible char 	 ;=W
	       MOV  [DI]+WR_ENBYTE,0	     ;end byte of data in input buffer		 ;=W
	       MOV  [DI]+WR_ENCHAR,0	     ;end character in input buffer		 ;=W
	       MOV  [DI]+WR_HRBYTE,1	     ;byte of first char in horz. window	 ;=W
;
	       MOV  AX,[DI]+WR_CUCHAR	     ;get current position			 ;=W
	       MOV  [DI]+WR_UPCHAR,1	     ;topmost char in current column		 ;=W
	       MOV  [DI]+WR_DNCHAR,1	     ;bottommost char in current column 	 ;=W
;
	       MOV  BP,0		     ;have not found current char yet		 ;=W
	       MOV  CX,1		     ;counter tracking number of bytes		 ;=W
	       MOV  DX,1		     ;counter tracking number of chars		 ;=W
;
; Determine display format of field
;
	       TEST ES:[SI]+ICB_OPT3,ICB_WIN ;check if windowing option on
	       JE   CC10
;
	       JMP  CC200		     ;process window option
;
CC10:	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if horizontal scroll option
	       JE   CC20		     ; on
;
	       JMP  CC100		     ;process horizontal scroll
;
; Process fully displayed horizontal field
;
CC20:											 ;=W
	       MOV  [DI]+WR_HRCHAR,1	     ;leftmost character possible char
;
; Examine the next byte in the input buffer
;
CC30:	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been
	       JBE  CC35		     ; scanned and exit
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC40		     ;no, find it				 ;=W
	       JMP  CCEXIT
;
CC35:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       DEC  CX			     ;make byte count zero based
	       ADD  SI,CX		     ;add byte count to input fld offst
	       INC  CX			     ;make byte count one based
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Check if end data byte and character should be updated
;
	       CMP  AL,WR_BLANK 	     ;check if blanking character found
	       JE   CC40		     ;now adjust pointers
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character
;
; Check if current character pointer
;
CC40:	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found
	       JNE  CC50
;
	       MOV  BP,1		     ;current char found			 ;=W
	       MOV  [DI]+WR_UPCHAR,DX	     ;set up and down character
	       MOV  [DI]+WR_DNCHAR,DX	     ; to current character
;
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count
	       ADD  [DI]+WR_CURCOL,CX	     ;set actual column of cursor based
	       DEC  [DI]+WR_CURCOL	     ; on current character byte count		 ;=W
;
; Increment pointers and counters to next character and byte position check
;
CC50:	       INC  CX			     ;adjust byte counter
	       INC  DX			     ;adjust character counter
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte
	       JE   CC30
;
	       INC  CX			     ;adjust byte count for trail byte
	       JMP  CC30





;
; Calculate horizontal scroll coordinates
;
CC100:
	       MOV  AX,[DI]+WR_CUCHAR	     ;initialize current character
	       CMP  AX,[DI]+WR_HRCHAR	     ;horizontal display position must
	       JAE  CC120		     ; not be less than current char
					     ; position
	       MOV  [DI]+WR_HRCHAR,AX	     ;set current char position as
					     ; new horizontal position
;
; Examine the next byte in the input buffer
;
CC120:	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been
	       JBE  CC122		     ; scanned and exit 			 ;=W
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC130		     ;no, find it				 ;=W
;
	       JMP  CCEXIT								 ;=W
CC122:											 ;=W
	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       DEC  CX			     ;make byte count zero based
	       ADD  SI,CX		     ;add byte count to input fld offst
	       INC  CX			     ;make byte count one based
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;											 ;=W
; Set WR_HRBYTE to correct byte count							 ;=W
;											 ;=W
	       CMP  [DI]+WR_HRCHAR,DX	     ;is this position the first char		 ;=W
					     ;in the horizl. window ?			 ;=W
	       JNE  CC125		     ;no					 ;=W
;
	       MOV  [DI]+WR_HRBYTE,CX	     ;save # byte for first char in h. wind.	 ;=W
;
; Check if end data byte and character should be updated
;
CC125:	       CMP  AL,WR_BLANK 	     ;check if blanking character found
	       JE   CC130		     ;now adjust pointers
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character
;
; Check if current character pointer
;
CC130:	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found
	       JNE  CC140
;
	       MOV  BP,1		     ;current char found
	       MOV  [DI]+WR_UPCHAR,DX	     ;set up and down character
	       MOV  [DI]+WR_DNCHAR,DX	     ; to current character
;
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count
	       MOV  BX,CX		     ;set actual column of cursor based 	 ;=W
					     ; on current character byte count		 ;=W
	       SUB  BX,[DI]+WR_HRBYTE	     ;subtract beginning of horiz. wind.	 ;=W
	       ADD  [DI]+WR_CURCOL,BX	     ;add to window offset = new column 	 ;=W
;
; Increment pointers and counters to next character and byte position check
;
CC140:	       INC  CX			     ;adjust byte counter
	       INC  DX			     ;adjust character counter
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte
	       JE   CC120
;
	       INC  CX			     ;adjust byte count for trail byte
	       JMP  CC120





;
; Calculate windowing coordinates							 ;=W
;
CC200:											 ;=W
;
; Examine the next byte in the input buffer						 ;=W
;
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been		 ;=W
	       JBE  CC235		     ; scanned and exit 			 ;=W
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC240		     ;no, find it				 ;=W
;
	       JMP  CCBYE		     ;boolean flag should have been set 	 ;=W
					     ; already, if needed			 ;=W
CC235:	       PUSH ES			     ;save registers				 ;=W
	       PUSH SI									 ;=W
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer		 ;=W
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer		 ;=W
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;
	       DEC  CX			     ;make byte count zero based		 ;=W
	       ADD  SI,CX		     ;add byte count to input fld offst 	 ;=W
	       INC  CX			     ;make byte count one based 		 ;=W
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to		 ;=W
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS				 ;=W
	       CALL PCINDBC_CALL	     ;call routine to check if char		 ;=W
					     ; is lead double byte char 		 ;=W
;
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Check if end data byte and character should be updated				 ;=W
;											 ;=W
	       CMP  AL,WR_BLANK 	     ;check if blanking character found 	 ;=W
	       JE   CC240		     ;now adjust pointers			 ;=W
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count			 ;=W
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count		 ;=W
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character			 ;=W
;											 ;=W
; Check if current character pointer							 ;=W
;											 ;=W
CC240:
	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found		 ;=W
	       JNE  CC250		     ;no					 ;=W
;
	       MOV  BP,1		     ;found current char
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count		 ;=W
;
	       PUSH DX			     ;needed for division			 ;=W
	       MOV  AX,CX		     ;get current cursor pos. in field		 ;=W
	       DEC  AX			     ;make it zero based for divide		 ;=W
;
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;are we past end of field ?		 ;=W
	       JLE  CC241		     ;no					 ;=W
	       MOV  [DI]+WR_FIELDEND,1	     ;yes, set boolean flag			 ;=W
	       DEC  AX			     ;make cursor pos. be inside field		 ;=W
					     ; for division				 ;=W
	       CWD			     ;calculate current row,column		 ;=W
	       IDIV ES:[SI]+ICB_WIDTH	     ; row = cur_byte / width-1 		 ;=W
					     ; col = cur_byte mod width-1		 ;=W
	       INC  DX			     ;reposition cursor in correct pos. 	 ;=W
	       JMP  CC244								 ;=W
CC241:											 ;=W
	       CWD			     ;calculate current row,column for		 ;=W
	       IDIV ES:[SI]+ICB_WIDTH	     ; cursor positions inside the field	 ;=W
					     ; row = cur_byte / width of field		 ;=W
					     ; col = cur_byte mod width of field	 ;=W
CC244:											 ;=W
	       ADD  [DI]+WR_CURROW,AX	     ;set actual row of cursor			 ;=W
	       ADD  [DI]+WR_CURCOL,DX	     ;set actual column of cursor		 ;=W
;
	       MOV  BX,CX		     ;calculate WR_LFCHAR			 ;=W
CC245:	       DEC  BX			     ;get the correct cur_byte			 ;=W
	       MOV  AX,BX		     ;cur_byte/width				 ;=W
	       CWD									 ;=W
	       IDIV ES:[SI]+ICB_WIDTH							 ;=W
	       CMP  DX,0		     ;is the remainder zero ?			 ;=W
	       JNE  CC245		     ;no, not at beginning of row, do again	 ;=W
;
	       MOV  [DI]+WR_LFCHAR,BX	     ;yes, this is beginning of row		 ;=W
;
	       POP  DX									 ;=W
;
; Increment pointers and counters to next character and byte position check		 ;=W
;											 ;=W
CC250:	       INC  CX			     ;adjust byte counter			 ;=W
	       INC  DX			     ;adjust character counter			 ;=W
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte 	 ;=W
	       JE   CC260								 ;=W
;
	       INC  CX			     ;adjust byte count for trail byte		 ;=W
CC260:
	       JMP  CC200								 ;=W
;
; Exit
;
CCEXIT: 										 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;is cursor past end of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_FIELDLEN  ;??					 ;=W
	       JLE  CCBYE		     ;no					 ;=W
;
	       MOV  [DI]+WR_FIELDEND,1	     ;yes, set boolean flag			 ;=W
CCBYE:
	       MOV  AX,[DI]+WR_ENBYTE	     ;set ICB_ENDBYTE				 ;=W
	       MOV  ES:[SI]+ICB_ENDBYTE,AX						 ;=W
;
	       MOV  AX,[DI]+WR_HRBYTE	     ;set ICB_HRSTART				 ;=W
	       MOV  ES:[SI]+ICB_HRSTART,AX						 ;=W
;
	       POP  BP
	       POP  SI			     ;restore registers
	       POP  ES
	       POP  DX			     ;restore registers
	       POP  CX
	       POP  BX
	       POP  AX
;
	       RET
CAL_COORS      ENDP
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; SET_DISP_ADDR 							      : 	 ;=W
;									      : 	 ;=W
;	    Determine which display routine to use. The choice is between     : 	 ;=W
;	    left justified, right justified, double byte support, no double   : 	 ;=W
;	    byte support, windowing, horizontal scrolling.		      : 	 ;=W
;	    Also pick the justify routine to use.			      : 	 ;=W
;									      : 	 ;=W
;			     			      : 	 ;=W
;			     	   DISPLAY				      : 	 ;=W
;			     			      : 	 ;=W
;	 	      : 	 ;=W
;          		          	      : 	 ;=W
;  LEFT_DISP        		 RIGHT_DISP         	      : 	 ;=W
;          		          	      : 	 ;=W
;	  		         	      : 	 ;=W
;	 LEFT_H_DISP 		       RIGHT_H_DISP  	      : 	 ;=W
;	  		         	      : 	 ;=W
;		 			       	      : 	 ;=W
;		 LEFTS_DISP			       RIGHTS_DISP	      : 	 ;=W
;		 			       	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; DISPLAY ROUTINES							      : 	 ;=W
;  LEFT_DISP	 - left justified, double byte support, windowing	      : 	 ;=W
;  LEFTS_DISP	 - left justified, no double byte support, windowing	      : 	 ;=W
;  LEFT_H_DISP	 - left justified, double byte support, horizontal scrolling  : 	 ;=W
;  RIGHT_DISP	 - right justified, double byte support, windowing	      : 	 ;=W
;  RIGHTS_DISP	 - right justified, no double byte support, windowing	      : 	 ;=W
;  RIGHT_H_DISP  - right justified, double byte support, horizontal scrolling : 	 ;=W
;									      : 	 ;=W
; JUSTIFY ROUTINES							      : 	 ;=W
;  LEFT_H_JUST	 - left justified, horizontal scrolling 		      : 	 ;=W
;  LEFT_JUST	 - left justified, windowing				      : 	 ;=W
;  RIGHT_H_JUST  - right justified, horizontal scrolling		      : 	 ;=W
;  RIGHT_JUST	 - right justified, windowing				      : 	 ;=W
;									      : 	 ;=W
; Entry:    ES:SI - ICB control block					      : 	 ;=W
;	    DS:DI - IN control block					      : 	 ;=W
; Exit:     none							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
SET_DISP_ADDR  PROC NEAR								 ;=W
;
	       PUSH AX									 ;=W
	       PUSH BX									 ;=W
;
	       TEST ES:[SI]+ICB_OPT1,ICB_RJU ;check if field right just 		 ;=W
	       JNE  SD20		     ;if yes, jump				 ;=W
;
; Display value of input buffer left justified						 ;=W
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if field is in horizontial		 ;=W
	       JE   SD10		     ;no,  windowing mode			 ;=W
;
	       MOV  AX,OFFSET LEFT_H_DISP						 ;=W
	       MOV  BX,OFFSET LEFT_H_JUST						 ;=W
;
	       JMP  SDEXIT								 ;=W
SD10:											 ;=W
	       MOV  AX,OFFSET LEFT_DISP 						 ;=W
	       MOV  BX,OFFSET LEFT_JUST 						 ;=W
;
	       TEST DS:[DI]+IN_OPT,IN_ADBCS  ;check if double byte is active		 ;=W
	       JNE  SDEXIT		     ;yes					 ;=W
	       MOV  AX,OFFSET LEFTS_DISP     ;no, single byte only			 ;=W
	       JMP  SDEXIT								 ;=W
;
; Display default value of input buffer right justified 				 ;=W
;
SD20:											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if field is in horizontial		 ;=W
	       JE   SD30		     ;no,  windowing mode			 ;=W
;
	       MOV  AX,OFFSET RIGHT_H_DISP						 ;=W
	       MOV  BX,OFFSET RIGHT_H_JUST						 ;=W
;
	       JMP  SDEXIT								 ;=W
SD30:											 ;=W
	       MOV  AX,OFFSET RIGHT_DISP						 ;=W
	       MOV  BX,OFFSET RIGHT_DISP						 ;=W
;
	       TEST DS:[DI]+IN_OPT,IN_ADBCS  ;check if double byte is active		 ;=W
	       JNE  SDEXIT		     ;yes					 ;=W
	       MOV  AX,OFFSET RIGHTS_DISP    ;no, single byte only			 ;=W
;
SDEXIT: 										 ;=W
	       MOV  DS:[DI]+WR_DISPLAY,AX    ;save addr of routine to call		 ;=W
	       MOV  DS:[DI]+WR_JUSTIFY,BX    ;save addr of routine to call		 ;=W
;
	       POP  BX									 ;=W
	       POP  AX									 ;=W
;
	       RET									 ;=W
SET_DISP_ADDR  ENDP									 ;=W
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHTS_DISP								      : 	 ;=W
;									      : 	 ;=W
; Entry:								      : 	 ;=W
;									      : 	 ;=W
; Exit: 								      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHTS_DISP    PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHTS_DISP    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; RIGHT_H_DISP								      :
;									      :
; Entry:								      :
;									      :
; Exit: 								      :
;									      :
;-----------------------------------------------------------------------------+
;
RIGHT_H_DISP   PROC NEAR
;
	       ;
	       ; code here
	       ;
;
	       RET
RIGHT_H_DISP   ENDP
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHT_DISP								      : 	 ;=W
;									      : 	 ;=W
; Entry:								      : 	 ;=W
;									      : 	 ;=W
; Exit: 								      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHT_DISP     PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHT_DISP     ENDP									 ;=W
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFT_H_DISP								      : 	 ;=W
;									      : 	 ;=W
;	  Calculates if the specified character will fit in the input	      : 	 ;=W
;	  buffer at the specified character position without display.	      : 	 ;=W
;	  The byte offset where this character should be inserted is	      : 	 ;=W
;	  returned or a flag indicating that the character will not fit.      : 	 ;=W
;									      : 	 ;=W
;	  Displays the specified portion of the input field buffer from       : 	 ;=W
;	  the left character marker to the end of the field.  The following   : 	 ;=W
;	  display options are handled by this routine:			      : 	 ;=W
;									      : 	 ;=W
;	  - Display of the input field in a wrapped window		      : 	 ;=W
;	  - Adjustment of double byte characters to prevent malformed	      : 	 ;=W
;	    characters							      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following pointers are used:				      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				 buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_HRCHAR)	 Left marker delimiting the left      : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.			      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	  	      : 	 ;=W
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      	      : 	 ;=W
;	    	          Area to display (ICB_WIDTH)			      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		ICB_FIELDLEN  Length of input field in bytes.		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI        = Points to current ICB				      : 	 ;=W
;	  DS:DI        = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  WR_CATTR     = Logical color attribute to use when updating screen  : 	 ;=W
;			 if the use of the color attribute string is not      : 	 ;=W
;			 specified.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_RCOFF     = Beginning offset of the upper left input field       : 	 ;=W
;			 display corner from the beginning of the video       : 	 ;=W
;			 buffer.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      : 	 ;=W
;			 attributes.					      : 	 ;=W
;									      : 	 ;=W
;	  WR_HRCHAR    = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where to begin display.			      : 	 ;=W
;									      : 	 ;=W
; Exit:   (none)							      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFT_H_DISP    PROC NEAR								 ;=W
;
	       PUSH ES			     ;save PB pointers				 ;=W
	       PUSH DI									 ;=W
	       PUSH BX									 ;=W
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;											 ;=W
; Initialize MOVEG parm block								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;get offset of the input buffer		 ;=W
	       MOV  [DI]+WR_FIELDOFF,AX 						 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get segment of the input buffer		 ;=W
	       MOV  [DI]+MG_TEXTSEG,AX							 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_ATTROFF   ;get offset of color attribute buffer	 ;=W
	       MOV  [DI]+MG_ATTOFF,AX							 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_ATTRSEG   ;get segment of color attribute		 ;=W
	       MOV  [DI]+MG_ATTSEG,AX	     ;buffer					 ;=W
											 ;=W
	       MOV  AX,[DI]+IN_LVBSEG	     ;get segment of the LVB			 ;=W
	       MOV  [DI]+MG_MIXSEG,AX							 ;=W
											 ;=W
	       MOV  AL,[DI]+WR_CATTR	     ;get logical color attribute		 ;=W
	       MOV  [DI]+MG_SOURCE_A,AL 						 ;=W
;											 ;=W
; Display all characters in input buffer starting with WR_HRCHAR			 ;=W
; and continuing until ICB_WIDTH-1 number of characters has been displayed.		 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;calcuate beginning character		 ;=W
	       ADD  AX,[DI]+WR_HRBYTE	     ;to display				 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_FIELDOFF,AX      ;save it					 ;=W
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display				 ;=W
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LHD10								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option		 ;=W
LHD10:											 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;get field width				 ;=W
	       MOV  [DI]+MG_NUM,AX	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
;											 ;=W
; Check if last character is DBCS							 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG ;get input buffer segment			 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDOFF ;get input buffer offset			 ;=W
	       ADD  BX,[DI]+WR_HRBYTE	    ;add offset of beginning of window		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH    ;add width to get last character		 ;=W
	       SUB  BX,2		    ;subtract to get correct byte		 ;=W
	       MOV  ES,AX								 ;=W
	       MOV  SI,BX								 ;=W
	       MOV  AL,ES:[SI]		    ;get the character				 ;=W
;
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;
	       PUSH AX									 ;=W
	       MOV  [DI]+DBC_KS,AL							 ;=W
	       CALL PCINDBC_CALL	    ;check if char is lead DBCS 		 ;=W
	       POP  AX									 ;=W
	       TEST [DI]+DBC_STAT,DBC_DBCS  ;is it ?					 ;=W
	       JE   LHD30		    ;no, display the character			 ;=W
;
	       MOV  AL,1DH		    ;display '', can't split DBCS char          ;=W
;											 ;=W
; Display the last character								 ;=W
;											 ;=W
LHD30:											 ;=W
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LHD40								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC+MG_UC  ;set write character option		 ;=W
LHD40:											 ;=W
	       MOV  [DI]+MG_SOURCE_C,AL      ;character to display			 ;=W
	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;add width to get last character		 ;=W
	       MOV  BX,2								 ;=W
	       MUL  BX			     ;x2 to account for attr. bytes		 ;=W
	       ADD  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       SUB  AX,2		     ;subtract to get correct byte		 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
LHDEXIT:										 ;=W
	       POP  [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
	       POP  BX			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  ES									 ;=W
;
	       RET									 ;=W
LEFT_H_DISP    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; LEFT_DISP								      :
;									      :
;	  Calculates if the specified character will fit in the input	      :
;	  buffer at the specified character position without display.	      :
;	  The byte offset where this character should be inserted is	      :
;	  returned or a flag indicating that the character will not fit.      :
;									      :
;	  Displays the specified portion of the input field buffer from       :
;	  the left character marker to the end of the field.  The following   :
;	  display options are handled by this routine:			      :
;									      :
;	  - Display of the input field in a wrapped window		      :
;	  - Adjustment of double byte characters to prevent malformed	      :
;	    characters							      :
;									      :
;									      :
;	  The following pointers are used:				      :
;									      :
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      :
;	    				 buffer in memory.		      :
;	    								      :
;	    		 (WR_LEFTCHAR) Left marker delimiting the left      :
;	    				 most character position in the       :
;	    				 input buffer.			      :
;	    								      :
;	    				 Right marker delimiting the right    :
;	    				 most character position in the       :
;	    				 input buffer.	 (WR_RIGHTCHAR)       :
;	    								      :
;	  	      :
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      :
;	  	      :
;	    	      	      :
;	    	          Area to display				      :
;	    	      :
;				     					      :
;		ICB_FIELDLEN  Length of input field in bytes.		      :
;									      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
;	  AX	     1 = This option will calculate if the specified number   :
;			 of bytes in BX can fit into input buffer at the      :
;			 specified character position considering the display :
;			 coordinates and options.  No update of the display   :
;			 screen will occur.  A flag indicating if the bytes   :
;			 can be inserted or not is returned.  If the bytes    :
;			 will fit the offset from the beginning of the input  :
;			 field in bytes is returned indicating where the      :
;			 characters should be inserted. 		      :
;									      :
;		     2 = This option will update the display screen in the    :
;			 proper format with the input buffer characters       :
;			 starting at the specified left offset character      :
;			 to the right character marker. 		      :
;									      :
;	  BX	       = Number of bytes to insert starting at the specified  :
;			 character position.				      :
;									      :
;	  WR_CATTR     = Logical color attribute to use when updating screen  :
;			 if the use of the color attribute string is not      :
;			 specified.					      :
;									      :
;	  CR_RCOFF     = Beginning offset of the upper left input field       :
;			 display corner from the beginning of the video       :
;			 buffer.					      :
;									      :
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      :
;			 attributes.					      :
;									      :
;	  WR_LEFTCHAR  = The offset into the input buffer, in characters,     :
;			 of where the specified bytes should fit.	      :
;									      :
;	  WR_RIGHTCHAR = The offset into the input buffer, in characters,     :
;			 of where the right most character position.	      :
;									      :
;									      :
; Exit:   If AX on entry is set to 1 then on exit:			      :
;									      :
;	  AX	     0 = The specified number of characters will fit.	      :
;		     1 = The specified number of characters will not fit.     :
;									      :
;	  WR_LEFTBYTE  = The offset into the input buffer, in bytes, of the   :
;			 left most character position.			      :
;									      :
;	  WR_RIGHTBYTE = The offset into the input buffer, in bytes, of the   :
;			 right most character position. 		      :
;									      :
;									      :
;	 If AX on entry is set to 2 then the input field buffer is	      :
;	 displayed on the screen.					      :
;									      :
;-----------------------------------------------------------------------------+
;
LEFT_DISP      PROC NEAR
;
	       PUSH ES			     ;save PB pointers
	       PUSH DI
	       PUSH BX
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset
;
	       CALL LEFT_DISP_INIT	     ;initialize internal counter & vars	 ;=W
;
	       JMP  LF20		     ;begin of first row
;
; Start a new row in LVB
;
LF10:	       MOV  AX,[DI]+CR_RCOFF	     ;set ptr into LVB to next row.
	       ADD  AX,[DI]+CR_SCRWIDTH      ; Start with current position in
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; LVB, add screen width in text
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; and attributes, then subtract
	       MOV  [DI]+CR_RCOFF,AX	     ; the length of the input field
					     ; twice since length is just in
					     ; text chars
;
; Do not start new row
;
LF20:	       MOV  AX,ES:[SI]+ICB_WIDTH     ;counter contains number of bytes
	       MOV  [DI]+WR_CNTR2,AX	     ; available in current row of
					     ; input field
;
; Prepare to place next byte into LVB, verify chars remaining in input buffer
;
LF30:	       MOV  AX,[DI]+WR_CNTR3	     ;check if last character has been
	       CMP  [DI]+WR_RIGHTCHAR,AX     ; written in LVB (rightmost)
	       JGE  LF40		     ;if not last char jump ?
;
	       JMP  LF160		     ;yes, last character written
					     ; prepare to exit
;
; Check if end of field on display has been reached
;
LF40:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;loop if number chars moved is
	       CMP  [DI]+WR_CNTR1,AX	     ; less than input buffer length
	       JLE  LF50		     ;
;
	       JMP  LF160
;
; Not complete
;
LF50:	       CMP  [DI]+WR_CNTR2,0	     ;loop while number of bytes
	       JE   LF10		     ; remaining in the row is greater
					     ; than zero, jump if bytes avail
;
	       CMP  [DI]+WR_MOVE,1	     ;check if entry option is to
	       JNE  LF60		     ; determine if bytes may be
					     ; inserted in displayed field
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if insertion calculations
	       CMP  [DI]+WR_CNTR3,AX	     ; should begin by comparing
	       JNE  LF60		     ; current counter with beginning
					     ; left character marker
;
	       MOV  AL,1		     ;check if insertion calculations
	       CMP  [DI]+WR_INSDONE,AL	     ; are complete
	       JE   LF60		     ;if yes, jump
;
; Adjust counters after pretending to insert a character into string and LVB
;
	       MOV  AX,[DI]+WR_BYTESINST     ;dec number bytes avail in row
	       ADD  [DI]+WR_CNTR1,AX	     ;inc number bytes moved into LVB
	       SUB  [DI]+WR_CNTR2,AX	     ;dec number bytes remaining in row
	       MOV  [DI]+WR_INSDONE,1	     ;set flag indicating insert calc
	       JMP  LF30		     ; complete
;
; Determine if current byte is a DBCS lead byte
;
LF60:	       MOV  BX,[DI]+WR_FIELDOFF      ;get the current byte in the
;
	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ; input field buffer
	       PUSH [DI]+WR_FIELDOFF	     ;get the current byte in the
	       POP  SI
	       POP  ES
;
	       MOV  AL,ES:[SI]		     ;get character in input buffer
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       MOV  [DI]+DBC_KS,AL
;
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS
	       JNE  LF70		     ;if yes, jump to double byte code
;
	       JMP  LF130		     ;if no, jump to single byte code
;
; Current byte is leading byte of a double byte character
;
LF70:	       CMP  [DI]+WR_CNTR2,1	     ;check if there is room in current
	       JNE  LF80		     ; row for double byte character
;
	       JMP  LF110		     ;no room, adjust to next row
;
; Double byte character fits on current row
;
LF80:	       CMP  [DI]+WR_MOVE,2	     ;check if option to actually
	       JNE  LF100		     ; update display is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if character should be
	       CMP  [DI]+WR_CNTR3,AX	     ; displayed by verifying that
	       JL   LF100		     ; current character falls
					     ; between the left and right
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF100
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC  ;set write attribute option
;
	       TEST ES:[SI]+ICB_OPT1,ICB_USC ;use attribute string
	       JNE  LF84
;
	       OR   [DI]+MG_OPT,MG_UA	     ;set use logical attribute option
;
LF84:	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;is option for password write
	       JNE  LF85		     ; active
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF85:	       MOV  [DI]+MG_NUM,2	     ;number of words to move into LVB
	       MOV  AX,[DI]+IN_LVBOFF	     ;set actual offset into LVB
	       ADD  AX,[DI]+CR_RCOFF	     ; where character(s) will be
	       MOV  [DI]+MG_MIXOFF,AX	     ; written
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write characters
;
; Adjust pointers and counters after moving double byte character
;
LF100:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and
	       JNE  LF104		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4,
	       JMP  LF106		     ; into WR_LEFTBYTE
;
; Update right byte marker
;
LF104:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and
	       JNE  LF106		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4,
					     ; into WR_RIGHTBYTE
;
LF106:	       ADD  [DI]+WR_FIELDOFF,2	     ;inc number bytes moved from input
					     ; buffer
	       ADD  [DI]+CR_RCOFF,4	     ;inc pointer into LVB
	       ADD  [DI]+WR_CNTR1,2	     ;inc number of bytes moved into
					     ; LVB
	       SUB  [DI]+WR_CNTR2,2	     ;dec number of bytes remain
	       INC  [DI]+WR_CNTR3	     ;inc number of characters moved
					     ; into LVB from input string
	       ADD  [DI]+WR_CNTR4,2	     ;inc number of bytes moved from
	       JMP  LF30		     ; input string
;
; Blank fill remaining screen character positions on current row to prevent
;  double byte character from being split
;
LF110:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display
	       JNE  LF120		     ; is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying
	       JL   LF120		     ; that the character falls
					     ; within  the left and right
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF120
;
	       MOV  AL,WR_BLANK 	     ;get blanking character
	       MOV  [DI]+MG_SOURCE_C,AL
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UC
					     ;set write attr, char and syn chk
	       TEST ES:[SI]+ICB_OPT1,ICB_USC
	       JNE  LF114		     ;use attribute string
;
	       OR   [DI]+MG_OPT,MG_UA	     ;set use logical attribute option
;
LF114:	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JNE  LF115
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF115:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the
					     ; LVB
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write
	       MOV  [DI]+MG_MIXOFF,AX
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s)
;
; Adjust pointers and counters after writing blanking character to LVB
;
LF120:	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into the LVB
	       INC  [DI]+WR_CNTR1	     ;inc number of bytes moved into
					     ; the LVB
	       DEC  [DI]+WR_CNTR2	     ;dec number of bytes remaining in
	       JMP  LF10		     ; the current row
;
; Byte is a single byte character
;
LF130:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display
	       JNE  LF150		     ; is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying
	       JL   LF150		     ; that the character falls
;
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF150
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA
					     ;set write attribute option
					     ;set use logical attribute option
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JNE  LF135
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF135:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the
					     ; LVB
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write
	       MOV  [DI]+MG_MIXOFF,AX
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s)
;
; Adjust pointers and counters after moving single byte character
;
LF150:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and
	       JNE  LF154		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4,
	       JMP  LF156		     ; into WR_LEFTBYTE
;
; Update right byte marker
;
LF154:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and
	       JNE  LF156		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4,
					     ; into WR_RIGHTBYTE
;
LF156:	       INC  [DI]+WR_FIELDOFF	     ;inc pointer input buffer
	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into LVB
	       INC  [DI]+WR_CNTR1	     ;inc counter with number bytes
					     ; moved into LVB
	       DEC  [DI]+WR_CNTR2	     ;dec counter with number of bytes
					     ; remaining in current row
	       ADD  [DI]+WR_CNTR3,1	     ;inc counter with number of chars
					     ; moved into the LVB from input
					     ; buffer
	       ADD  [DI]+WR_CNTR4,1	     ;inc counter with number of bytes
	       JMP  LF30		     ; moved into the LVB from input
					     ; buffer
;
; Completed updating LVB, adjust pointers
;
LF160:	       CMP  [DI]+WR_MOVE,1	     ;Check if option to calculate
	       JNE  LFEXIT		     ; if chars fit in buffer
;
; Set up proper return values for insert calculation
;
	       MOV  AX,1		     ;set flag indicating insert did
					     ; not fit
	       MOV  BX,[DI]+WR_CNTR3	     ;see if input field fit into LVB
	       DEC  BX			     ; by comparing the right char
	       CMP  [DI]+WR_RIGHTCHAR,BX     ; number with the number of chars
	       JNE  LFEXIT		     ; moved into the LVB.  If they
					     ; are equal the string fit into
					     ; the LVB.
	       CMP  [DI]+WR_INSDONE,1	     ;see if insert has been done
	       JE   LF170		     ;if yes set up return values
;
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;if no, then insert is at end of
	       SUB  BX,[DI]+WR_CNTR1	     ; line i.e. past right char
	       INC  BX			     ;see if there is enough room left
	       CMP  BX,[DI]+WR_BYTESINST     ; to display char being inserted
	       JL   LFEXIT
;
LF170:	       MOV  AX,0		     ;set flag indicating insert fits
;
; Restores the registers to entry values and exits
;
LFEXIT:        POP  [DI]+CR_RCOFF	     ;save input field display offset
;
	       POP  BX			     ;restore registers
	       POP  DI
	       POP  ES
;
	       RET
LEFT_DISP      ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFTS_DISP			     (no double byte support)		      : 	 ;=W
;									      : 	 ;=W
;	  Calculates if the specified character will fit in the input	      : 	 ;=W
;	  buffer at the specified character position without display.	      : 	 ;=W
;	  The byte offset where this character should be inserted is	      : 	 ;=W
;	  returned or a flag indicating that the character will not fit.      : 	 ;=W
;									      : 	 ;=W
;	  Displays the specified portion of the input field buffer from       : 	 ;=W
;	  the left character marker to the end of the field.  The following   : 	 ;=W
;	  display options are handled by this routine:			      : 	 ;=W
;									      : 	 ;=W
;	  - Display of the input field in a wrapped window		      : 	 ;=W
;	  - Adjustment of double byte characters to prevent malformed	      : 	 ;=W
;	    characters							      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following pointers are used:				      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				 buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_LEFTCHAR) Left marker delimiting the left      : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.			      : 	 ;=W
;	    								      : 	 ;=W
;	    				 Right marker delimiting the right    : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.	 (WR_RIGHTCHAR)       : 	 ;=W
;	    								      : 	 ;=W
;	  	      : 	 ;=W
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      	      : 	 ;=W
;	    	          Area to display				      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		ICB_FIELDLEN  Length of input field in bytes.		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI        = Points to current ICB				      : 	 ;=W
;	  DS:DI        = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  AX	     1 = This option will calculate if the specified number   : 	 ;=W
;			 of bytes in BX can fit into input buffer at the      : 	 ;=W
;			 specified character position considering the display : 	 ;=W
;			 coordinates and options.  No update of the display   : 	 ;=W
;			 screen will occur.  A flag indicating if the bytes   : 	 ;=W
;			 can be inserted or not is returned.  If the bytes    : 	 ;=W
;			 will fit the offset from the beginning of the input  : 	 ;=W
;			 field in bytes is returned indicating where the      : 	 ;=W
;			 characters should be inserted. 		      : 	 ;=W
;									      : 	 ;=W
;		     2 = This option will update the display screen in the    : 	 ;=W
;			 proper format with the input buffer characters       : 	 ;=W
;			 starting at the specified left offset character      : 	 ;=W
;			 to the right character marker. 		      : 	 ;=W
;									      : 	 ;=W
;	  BX	       = Number of bytes to insert starting at the specified  : 	 ;=W
;			 character position.				      : 	 ;=W
;									      : 	 ;=W
;	  WR_CATTR     = Logical color attribute to use when updating screen  : 	 ;=W
;			 if the use of the color attribute string is not      : 	 ;=W
;			 specified.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_RCOFF     = Beginning offset of the upper left input field       : 	 ;=W
;			 display corner from the beginning of the video       : 	 ;=W
;			 buffer.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      : 	 ;=W
;			 attributes.					      : 	 ;=W
;									      : 	 ;=W
;	  WR_LEFTCHAR  = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where the specified bytes should fit.	      : 	 ;=W
;									      : 	 ;=W
;	  WR_RIGHTCHAR = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where the right most character position.	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Exit:   If AX on entry is set to 1 then on exit:			      : 	 ;=W
;									      : 	 ;=W
;	  AX	     0 = The specified number of characters will fit.	      : 	 ;=W
;		     1 = The specified number of characters will not fit.     : 	 ;=W
;									      : 	 ;=W
;	  WR_LEFTBYTE  = The offset into the input buffer, in bytes, of the   : 	 ;=W
;			 left most character position.			      : 	 ;=W
;									      : 	 ;=W
;	  WR_RIGHTBYTE = The offset into the input buffer, in bytes, of the   : 	 ;=W
;			 right most character position. 		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	 If AX on entry is set to 2 then the input field buffer is	      : 	 ;=W
;	 displayed on the screen.					      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFTS_DISP    PROC NEAR 								;=W
;
	       PUSH ES			     ;save PB pointers				 ;=W
	       PUSH DI									 ;=W
	       PUSH BX									 ;=W
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;
	       CALL LEFT_DISP_INIT	     ;initialize internal counters & vars	 ;=W
;
	       JMP  LS20		     ;begin of first row			 ;=W
;											 ;=W
; Start a new row in LVB								 ;=W
;											 ;=W
LS10:	       MOV  AX,[DI]+CR_RCOFF	     ;set ptr into LVB to next row.		 ;=W
	       ADD  AX,[DI]+CR_SCRWIDTH      ; Start with current position in		 ;=W
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; LVB, add screen width in text		 ;=W
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; and attributes, then subtract		 ;=W
	       MOV  [DI]+CR_RCOFF,AX	     ; the length of the input field		 ;=W
					     ; twice since length is just in		 ;=W
					     ; text chars				 ;=W
;											 ;=W
; Do not start new row									 ;=W
;											 ;=W
LS20:	       MOV  AX,ES:[SI]+ICB_WIDTH     ;counter contains number of bytes		 ;=W
	       MOV  [DI]+WR_CNTR2,AX	     ; available in current row of		 ;=W
					     ; input field				 ;=W
;											 ;=W
; Prepare to place next byte into LVB, verify chars remaining in input buffer		 ;=W
;											 ;=W
LS30:	       MOV  AX,[DI]+WR_CNTR3	     ;check if last character has been		 ;=W
	       CMP  [DI]+WR_RIGHTCHAR,AX     ; written in LVB (rightmost)		 ;=W
	       JGE  LS40		     ;if not last char jump ?			 ;=W
;
	       JMP  LS160		     ;yes, last character written		 ;=W
					     ; prepare to exit				 ;=W
;											 ;=W
; Check if end of field on display has been reached					 ;=W
;											 ;=W
LS40:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;loop if number chars moved is		 ;=W
	       CMP  [DI]+WR_CNTR1,AX	     ; less than input buffer length		 ;=W
	       JLE  LS50		     ;						 ;=W
;
	       JMP  LS160								 ;=W
;											 ;=W
; Not complete										 ;=W
;											 ;=W
LS50:	       CMP  [DI]+WR_CNTR2,0	     ;loop while number of bytes		 ;=W
	       JE   LS10		     ; remaining in the row is greater		 ;=W
					     ; than zero, jump if bytes avail		 ;=W
;
	       CMP  [DI]+WR_MOVE,1	     ;check if entry option is to		 ;=W
	       JNE  LS130		     ; determine if bytes may be		 ;=W
					     ; inserted in displayed field		 ;=W
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if insertion calculations		 ;=W
	       CMP  [DI]+WR_CNTR3,AX	     ; should begin by comparing		 ;=W
	       JNE  LS130		     ; current counter with beginning		 ;=W
					     ; left character marker			 ;=W
;
	       MOV  AL,1		     ;check if insertion calculations		 ;=W
	       CMP  [DI]+WR_INSDONE,AL	     ; are complete				 ;=W
	       JE   LS130		     ;if yes, jump				 ;=W
;											 ;=W
; Adjust counters after pretending to insert a character into string and LVB		 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_BYTESINST     ;dec number bytes avail in row		 ;=W
	       ADD  [DI]+WR_CNTR1,AX	     ;inc number bytes moved into LVB		 ;=W
	       SUB  [DI]+WR_CNTR2,AX	     ;dec number bytes remaining in row 	 ;=W
	       MOV  [DI]+WR_INSDONE,1	     ;set flag indicating insert calc		 ;=W
	       JMP  LS30		     ; complete 				 ;=W
;											 ;=W
; Byte is a single byte character							 ;=W
;											 ;=W
LS130:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display 	 ;=W
	       JNE  LS150		     ; is active				 ;=W
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character		 ;=W
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying 	 ;=W
	       JL   LS150		     ; that the character falls 		 ;=W
					     ; within  the left and right		 ;=W
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers			 ;=W
	       CMP  [DI]+WR_CNTR3,AX							 ;=W
	       JG   LS150								 ;=W
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)		 ;=W
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display				 ;=W
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LS135								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option		 ;=W
;
LS135:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
;											 ;=W
; Adjust pointers and counters after moving single byte character			 ;=W
;											 ;=W
LS150:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left		 ;=W
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and		 ;=W
	       JNE  LS154		     ; left chars.  See if the current		 ;=W
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so		 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4, 	 ;=W
	       JMP  LS156		     ; into WR_LEFTBYTE 			 ;=W
;											 ;=W
; Update right byte marker								 ;=W
;											 ;=W
LS154:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left		 ;=W
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and		 ;=W
	       JNE  LS156		     ; left chars.  See if the current		 ;=W
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so		 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4, 	 ;=W
					     ; into WR_RIGHTBYTE			 ;=W
LS156:	       INC  [DI]+WR_FIELDOFF	     ;inc pointer input buffer			 ;=W
	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into LVB			 ;=W
	       INC  [DI]+WR_CNTR1	     ;inc counter with number bytes		 ;=W
					     ; moved into LVB				 ;=W
	       DEC  [DI]+WR_CNTR2	     ;dec counter with number of bytes		 ;=W
					     ; remaining in current row 		 ;=W
	       ADD  [DI]+WR_CNTR3,1	     ;inc counter with number of chars		 ;=W
					     ; moved into the LVB from input		 ;=W
					     ; buffer					 ;=W
	       ADD  [DI]+WR_CNTR4,1	     ;inc counter with number of bytes		 ;=W
	       JMP  LS30		     ; moved into the LVB from input		 ;=W
					     ; buffer					 ;=W
;											 ;=W
; Completed updating LVB, adjust pointers						 ;=W
;											 ;=W
LS160:	       CMP  [DI]+WR_MOVE,1	     ;Check if option to calculate		 ;=W
	       JNE  LSEXIT		     ; if chars fit in buffer			 ;=W
;											 ;=W
; Set up proper return values for insert calculation					 ;=W
;											 ;=W
	       MOV  AX,1		     ;set flag indicating insert did		 ;=W
					     ; not fit					 ;=W
	       MOV  BX,[DI]+WR_CNTR3	     ;see if input field fit into LVB		 ;=W
	       DEC  BX			     ; by comparing the right char		 ;=W
	       CMP  [DI]+WR_RIGHTCHAR,BX     ; number with the number of chars		 ;=W
	       JNE  LSEXIT		     ; moved into the LVB.  If they		 ;=W
					     ; are equal the string fit into		 ;=W
					     ; the LVB. 				 ;=W
	       CMP  [DI]+WR_INSDONE,1	     ;see if insert has been done		 ;=W
	       JE   LS170		     ;if yes set up return values		 ;=W
;
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;if no, then insert is at end of		 ;=W
	       SUB  BX,[DI]+WR_CNTR1	     ; line i.e. past right char		 ;=W
	       INC  BX			     ;see if there is enough room left		 ;=W
	       CMP  BX,[DI]+WR_BYTESINST     ; to display char being inserted		 ;=W
	       JL   LSEXIT								 ;=W
;
LS170:	       MOV  AX,0		     ;set flag indicating insert fits		 ;=W
;											 ;=W
; Restores the registers to entry values and exits					 ;=W
;											 ;=W
LSEXIT:        POP  [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;
	       POP  BX			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  ES									 ;=W
;
	       RET									 ;=W
LEFTS_DISP     ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  DRAW_DEM								      : 	 ;=W
;	    Draw a input field delimiter				      : 	 ;=W
;									      : 	 ;=W
;  Entry:								      : 	 ;=W
;	   ES:SI  address of icon					      : 	 ;=W
;	   GC_ROW - character row to display delimiter			      : 	 ;=W
;	   GC_COL - character column to display delimiter		      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
DRAW_DEM       PROC NEAR								 ;=W
;
	       PUSH AX									 ;=W
	       PUSH BX									 ;=W
	       PUSH CX									 ;=W
	       PUSH DX									 ;=W
	       PUSH DI									 ;=W
	       PUSH SI									 ;=W
	       PUSH DS									 ;=W
	       PUSH ES									 ;=W
	       PUSH BP									 ;=W
;
	       MOV  BP,AX
;
	       MOV  DX,300H + graph_addr						 ;=W
	       MOV  AH,2		     ; Write Mode 2				 ;=W
	       MOV  AL,5		     ; Write Mode Register			 ;=W
	       OUT  DX,AX								 ;=W
;
	       MOV  DL,seq_addr 							 ;=W
	       MOV  AH,0FFH		     ;enable all maps				 ;=W
	       MOV  AL,s_map		     ;map mask					 ;=W
	       OUT  DX,AX		     ;set the registers 			 ;=W
;
	       MOV  AX,[DI]+WR_ROWBYTES 						 ;=W
	       MOV  BX,50H								 ;=W
	       MUL  BX									 ;=W
											 ;=W
	       MOV  BX,[DI]+GC_ROW							 ;=W
	       MUL  BX									 ;=W
	       ADD  AX,[DI]+GC_COL							 ;=W
;
	       MOV  BH,[DI]+WR_CATTR	     ;get current color attribute		 ;=W
;
	       CMP  [DI]+WR_VIDMODE,11H      ;check for graphics mode 11H
	       JNE  DD05		     ;nop, continue
	       MOV  BH,0FH		     ;yes, mode 11 is only black &
;
DD05:	       MOV  CL,4		     ;count for shift				 ;=W
	       SHR  BX,CL		     ;separate background/foreground		 ;=W
	       MOV  CL,4		     ;count for shift				 ;=W
	       SHR  BL,CL		     ;put in low order nibble			 ;=W
	       XCHG BL,BH		     ;foreground/background are reversed	 ;=W
					     ; for delimiter
; BL = background color, BH = foreground color
	       CMP  BP,02		     ;check if we want to remove delimiters	 ;=W
	       JNE  DD10		     ;no, ok					 ;=W
	       MOV  BH,BL		     ;make both background color		 ;=W
											 ;=W
DD10:											 ;=W
	       MOV  CL,[DI]+WR_VIDMODE							 ;=W
	       MOV  DX,[DI]+IN_OPT
;
	       PUSH ES			     ;make DS:SI point to bit maps		 ;=W
	       POP  DS									 ;=W
;
	       MOV  DI,AX								 ;=W
	       MOV  AX,0A000H								 ;=W
	       MOV  ES,AX								 ;=W
;
	       TEST DX,IN_MCGA		     ;mode 11H, non-VGA hardware?
	       JNE  DD100		     ;if so, go do it
;---------------------------------------------						 ;=W
; Mode 10,11,12 with VGA		     :						 ;=W
;---------------------------------------------						 ;=W
	       MOV  DX,300H + graph_addr       ;graphics chip				 ;=W
	       XOR  CH,CH								 ;=W
;
	       MOV  AL,CL		       ;save vid mode
	       MOV  CL,0EH		       ;# pixel rows in delimiter		 ;=W
	       CMP  AL,10H		       ;are we in graphics mode 10H
	       JE   DD40		       ;yes, # rows ok
	       ADD  CL,2		       ;no, mode 11,12 have 16 pixel rows
DD40:					       ; instead of 14 pixel rows.
	       MOV  BP,02H		       ;# pixel columns/8 in delimiter		 ;=W
;
	       MOV  AH,0FFH								 ;=W
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
DD50:											 ;=W
	       PUSH CX									 ;=W
	       PUSH DI									 ;=W
	       MOV  CX,BP								 ;=W
DD60:											 ;=W
	       MOV  AH,0FFH		       ;background				 ;=W
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
;
	       MOV  AL,ES:[DI]		       ;latch data				 ;=W
	       MOV  ES:[DI],BH		       ;set the dot				 ;=W
;
	       LODSB			       ;foreground				 ;=W
	       XCHG AL,AH								 ;=W
;
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
;
	       MOV  AL,ES:[DI]		       ;latch data				 ;=W
	       MOV  ES:[DI],BL		       ;set the dot				 ;=W
;
	       INC  DI									 ;=W
	       LOOP DD60								 ;=W
;
	       POP  DI									 ;=W
	       ADD  DI,LINELEN								 ;=W
	       POP  CX									 ;=W
	       LOOP DD50								 ;=W
	       JMP  DDEXIT								 ;=W
;---------------------------------------------						 ;=W
; Mode 11H with no VGA			     :						 ;=W
;---------------------------------------------						 ;=W
DD100:	       XOR  CH,CH
	       MOV  CL,10H		     ;# pixel rows in delimiter
	       MOV  BP,02H		     ;# of pixel columns in delimiter

DD110:	       PUSH CX
	       PUSH DI
;
	       MOV  CX,BP
;
DD120:	       LODSB			     ;get icon row
;
DD130:	       XOR  AL,0FFH
	       MOV  ES:[DI],AL		     ;set the dot
	       INC  DI
	       LOOP DD120
;
	       POP  DI
;
	       ADD  DI,50H		     ;line length, 80
;
	       POP  CX
;
	       LOOP DD110
;
DDEXIT:        POP  BP
	       POP  ES
	       POP  DS
	       POP  SI
	       POP  DI
	       POP  DX
	       POP  CX
	       POP  BX
	       POP  AX
;
	       RET
DRAW_DEM       ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  GET_MONO_DOS 							      : 	 ;=W
;	    Get segment and offset of the DOS monocasing table and return it  : 	 ;=W
;									      : 	 ;=W
;  Entry:  None 							      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
GET_MONO_DOS   PROC NEAR								 ;=W
;
	       PUSH SI			     ;save registers				 ;=W
	       PUSH ES									 ;=W
	       PUSH DI									 ;=W
;
	       MOV  AH,65H		     ;extended country info			 ;=W
	       MOV  AL,02H		     ;get uppercase table ptrs			 ;=W
	       MOV  BX,-1		     ;default code page 			 ;=W
	       MOV  DX,-1		     ;default country id			 ;=W
	       MOV  CX,05H		     ;# bytes returned				 ;=W
	       PUSH DS									 ;=W
	       POP  ES			     ;ES:DI ptrs to return buffer		 ;=W
	       MOV  DI,OFFSET WR_CUCHAR      ;use as temp buffer			 ;=W
;
	       INT  21H 								 ;=W
;
	       INC  DI			     ;skip info id				 ;=W
	       MOV  SI,DI		     ;we need DI so use SI			 ;=W
	       POP  DI									 ;=W
;
	       MOV  AX,WORD PTR [SI]	     ;get DOS monocasing table offset		 ;=W
	       MOV  [DI]+IN_MONOOFF,AX	     ;save it					 ;=W
	       ADD  SI,2								 ;=W
	       MOV  AX,WORD PTR [SI]	     ;get DOS monocasing table segment		 ;=W
	       MOV  [DI]+IN_MONOSEG,AX	     ;save it					 ;=W
;
	       POP  ES			     ;restore registers 			 ;=W
	       POP  SI									 ;=W
;
	       RET									 ;=W
GET_MONO_DOS   ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  GET_DBCS								      : 	 ;=W
;	    Get segment and offset of the DOS double byte support table.      : 	 ;=W
;									      : 	 ;=W
;  Entry:  DS:DI							      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
GET_DBCS       PROC NEAR								 ;=W
;
	       PUSH SI
	       PUSH ES									 ;=W
	       PUSH DI									 ;=W
	       PUSH DI									 ;=W
;
	       MOV  AH,65H		     ;get extended country info
	       MOV  AL,07H		     ;get DBCS environment table
	       INT  21H 		     ;DOS function call,vector returned
					     ; in ES:DI
	       POP  SI			     ;ptr, SI -> IN_PB
	       INC  DI			     ;skip over id byte returned
	       MOV  AX,WORD PTR ES:[DI]      ;get offset of DBCS table
	       MOV  [DI]+IN_DBCSOFF,AX	     ;save it
;
	       ADD  DI,2		     ;skip over offset to get segment
	       MOV  BX,WORD PTR ES:[DI]      ;get segment of DBCS table
	       MOV  [DI]+IN_DBCSSEG,BX	     ;save it
;
	       POP  DI
;
	       MOV  SI,AX		     ;Point to DBCS table to get length
	       MOV  ES,BX
	       MOV  AX,WORD PTR ES:[SI]
	       MOV  [DI]+IN_DBCSLEN,AX
	       ADD  [DI]+IN_DBCSOFF,2	     ;change offset to point to table
;
	       POP  ES
	       POP  SI
;
	       RET
GET_DBCS       ENDP

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\path.asm ===
title   Path Searching Routines
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1993
; *                      All Rights Reserved.
; */
        Page    ,132

; PATH.ASM - Code to search the environment for a particular data string,
; and to search the path for a particular file.  Adapted from the original
; COMMAND.COM version.
;
; Routines supported:
;       Find_in_Environment - locate the start of a given string
;                               in the environment
;       Path_Crunch - concantenates a file name with a directory path from
;                       the PATH environment variable
;       Search - Finds executable or other files, given a base name
;
        include dossym.inc
        include curdir.inc
        include find.inc
        include pdb.inc
        include syscall.inc

	DATA segment para public 'DATA'
Path_str        db      "PATH="
Path_str_size   equ     $ - offset Path_Str

Comspec_str     db      "COMSPEC="
Comspec_str_size equ    $ - offset Comspec_str

comext  db      ".COM",0
exeext	db	".EXE",0

        DATA ends

	CODE segment para public 'CODE'
        assume	cs:CODE,ds:DATA

IFDEF DBCS
        extrn   IsDBCSLeadByte:near
ENDIF

;----------------------------------------------------------------------------
; Path_Crunch - takes a pointer into a environment PATH string and a file
; name, and sticks them together, for subsequent searching.
;
; ENTRY:
;   BH			--	additional terminator character (i.e., ';')
;   DS:SI		--	pointer into pathstring to be dissected
;   ES:DI               --      buffer to store target name
;   DX			--	pointer to filename
; EXIT:
;   SI			--	moves along pathstring from call to call
;   ES:DI               --      filled in with concatenated name
;   Carry set if end of path string has been reached.
;
;---------------
Path_Crunch PROC NEAR
        public  Path_Crunch
;---------------
        assume  ds:nothing
        assume  es:DATA

IFDEF DBCS
	xor	cl,cl				; clear flag for later use 3/3/KK
ENDIF

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment

IFDEF DBCS
	invoke	IsDBCSLeadByte			;
	jz	NotKanj2			;
	stosb					;
	movsb					;
	MOV	CL,1				; CL=1 means latest stored char is DBCS
	jmp	path_cr_copy			;

NotKanj2:					;
	xor	cl,cl				; CL=0 means latest stored char is SBCS
ENDIF

	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
        push    si                              ; save resting place in env. seg.
	mov	BL, AL				; remember if we saw null or not...

path_cr_look:					; form complete pathname
	mov	al, '\'      			; add pathname separator for suffix

IFDEF DBCS
	or	cl,cl				;
	jnz	path_cr_store			; this is a trailing byte of ECS code 3/3/KK
ENDIF
	cmp	al,es:byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lods	byte ptr es:[si]       		; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	clc
        jnz	path_cr_exit			; null in BL means all gone...
	cmc

path_cr_exit:
        pop     si                              ; retrieve
	ret

        assume  es:nothing

;---------------
Path_Crunch endp
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   BX  	--	dma buffer for findfirst/next
;   AL          --      0 if we should look for .COM and .EXE extensions
;                       1 if extensions is pre-specified
; EXIT:
;   AX		--	8)  file found with .com extension, or file with
;                           pre-specified extension found
;			4)  file found with .exe extension
;			0)  no such file to be found
;   DX          --      points to resolved path name 
;   DS          --      DATA
; NOTES:
;   1)	Requires caller to have allocated executed a setdma.
;       
;---------------
; CONSTANTS:
;---------------
search_attr                 equ         attr_read_only+attr_hidden
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
fname_len		    equ 	8
fname_max_len		    equ 	23
dot			    equ 	'.'
wildchar		    equ 	'?'

search_best                 db          (?)
;---------------
Search PROC NEAR
        public Search
;---------------
        push    si                              ; 
        push    ax                              ; save extension flag
	mov	DI, DX				; working copy of pathname

	mov	CX, search_attr 		; filetypes to search for
        mov     ah, Find_First			; request first match, if any
        int     21h
        pop     ax                              
	jc	search_no_file
        
        or      al,al                           ; looking for specific ext?
        jz      search_no_ext                   ; no, jump
        mov     search_best,search_com          ; report we found best match
        jmp     short search_file_found         ; yes, found it

search_no_ext:
        mov     search_best, search_file_not_found

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
        mov     ah, Find_Next                   ; next match
        int     21h
	jnc	search_loop

search_done:					; it's all over with...
        cmp     search_best, search_file_not_found
        je      search_no_file
        cmp     search_best, search_com
        mov     si, offset comext
        je      search_move_ext
        mov     si, offset exeext

search_move_ext:
        mov     di, dx
        mov     al, '.'
        mov     cx, DIRSTRLEN
        rep     scasb
        dec     di
        movsw   
        movsw   

search_file_found:
        mov     al, search_best
	jmp	short search_exit

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
        pop     si
	ret
Search endp
;----------------------------------------------------------------------------


;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   BX    --	    dma buffer containing filename
; EXIT:
;   AL	    --	    file code, as given in search header
;---------------

Search_Ftype PROC NEAR
        public Search_Ftype

	push	DI
	mov	AL, search_file_not_found	; find the end of the filename
	mov	DI, BX
	add	di,Find_Buf_Pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
;
; Scan backwards to find the start of the extension
;
        dec     di                              ; point back to null
        mov     cx, 5                           ; . + E + X + T + null
        std                                     ; scan back
        mov     al, '.'
        repnz   scasb
        jnz     ftype_exit                      ; must not be any extension
        inc     di                              ; point to start of extension
        cld
;
; Compare .COM
;
	mov	si,offset comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AL, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;
ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset exeext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AL, search_exe			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	al,search_file_not_found

ftype_exit:
	pop	DI
	ret

Search_Ftype endp

;----------------------------------------------------------------------------
;
; Find_Comspec_In_Environment - find the beginning of the COMSPEC string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Comspec path
;       

FIND_COMSPEC_IN_environment PROC NEAR
        public Find_Comspec_In_Environment
        lea     si,Comspec_str
	mov     cx,Comspec_str_size		; cx = length of name
        jmp     short Find_in_Environment
Find_Comspec_in_Environment        endp

;----------------------------------------------------------------------------
;
; Find_Path_In_Environment - find the beginning of the PATH string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Path directory list
;       

FIND_PATH_IN_environment PROC NEAR
        public Find_Path_In_Environment
        lea     si,Path_str
	mov     cx,Path_str_size		; cx = length of name
; fall through to following
Find_Path_in_Environment        endp


; Find_In_Environment - locate a given string in the environment
;        
; Input :       SI = name to find in environment
;               CX = length of name
;               DS = DATA
;               ES = PSP segment
;
; Output: ES:DI points to the arguments in the environment
;	  carry is set if name not found
;

Find_in_Environment PROC NEAR
        public Find_In_Environment

	cld
        xor     di,di
        mov     ax,es:[di].PDB_Environ
        or      ax,ax                          ; is there an environment?
        jz      find_nf_exit                   ; no, quit now
        mov     es,ax
        assume  es:nothing        

find1:
        push    si
        push    cx                              ; save starting values
find11:

ifdef dbcs
	lodsb
	call	IsDBCSLeadByte
	jz	notkanj3
	dec	si
	lodsw
	inc	di
	inc	di
	cmp	ax,es:[di-2]
	jnz	find12
	dec	cx
	loop	find11
	jmp	short find12

notkanj3:
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

else    ;dbcs

        repe cmpsb   

endif   ;dbcs

find12:
        pop     dx
        pop     si                              ; clear stack
	jz      find_exit
        dec     di
	xor	al,al				; scan for a nul
	mov	cx,100h                         ; arbitrary size 
	repnz	scasb
	cmp	byte ptr es:[di],0              ; check for trailing null
        mov     cx,dx                           ; original count back in CX
	jnz	find1
	
find_nf_exit:
        stc					; indicate not found

find_exit:
	ret

Find_in_environment endp


CODE    ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\pdb.inc ===
;	SCCSID = @(#)pdb.asm	1.1 85/04/10
BREAK <Process data block>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


;**	Process data block (otherwise known as program header)
;

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever.  Reserved areas are probably safe
;	for use.


FilPerProc	    EQU     20

Process_data_block  STRUC
PDB_Exit_Call	DW	?		; INT int_abort system terminate
PDB_block_len	DW	?		; size of execution block
		DB	?
PDB_CPM_Call	DB	5 DUP (?)	; ancient call to system
PDB_Exit	DD	?		; pointer to exit routine
PDB_Ctrl_C	DD	?		; pointer to ^C routine
PDB_Fatal_abort DD	?		; pointer to fatal error
PDB_Parent_PID	DW	?		; PID of parent (terminate PID)
PDB_JFN_Table	DB	FilPerProc DUP (?)
PDB_environ	DW	?		; seg addr of environment
PDB_User_stack	DD	?		; stack of self during system calls
PDB_JFN_Length	DW	?		; number of handles allowed
PDB_JFN_Pointer DD	?		; pointer to JFN table
PDB_Next_PDB	DD	?		; pointer to nested PDB's

PDB_InterCon	DB	?		; *** jh-3/28/90 *** 
PDB_Append	DB	?		; *** Not sure if still used ***

PDB_Novell_Used	DB	2 DUP (?)	; Novell shell (redir) uses these

PDB_Version	DW	?		; DOS version reported to this app

PDB_PAD1	DB	0Eh DUP (?)
PDB_Call_system DB	5   DUP (?)	; portable method of system call
PDB_PAD2	DB	7h  DUP (?)	; reserved so FCB 1 can be used as
					;  an extended FCB
PDB_FCB1	DB	10h dup (?)	; default FCB 1
PDB_FCB2	DB	10h dup (?)	; default FCB 2
PDB_PAD3	DB	4   dup (?)	; not sure if this is used by PDB_FCB2
PDB_TAIL	DB	128 dup (?)	; command tail and default DTA



Process_data_block  ENDS


;
;PDB_Append	equ	BYTE PTR  PDB_PAD1 + 1    ; reincluded because APPEND
;                        ; wouldn't build w/o it.  feb 1990, leaf
;
;PDB_InterCon	EQU	BYTE PTR PDB_PAD1	; 2/12/KK
;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\rombios.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; Definitions of interesting variables in ROM BIOS data segment at 40:0
;
; Revision History
; ================
; 7/13/90	md		Created


	ROMBIOS_DATA	segment AT 040h

	org 049h

CRT_Mode	db	?	; current screen mode
CRT_Cols	dw	?	; current number of columns

	org 084h

CRT_Rows	db	?	; current number of screen rows
DEFAULT_ROWS	equ	24	; standard default for screen height

	ROMBIOS_DATA	ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\romloc.inc ===
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.

;	ROM DOS Locations
;	Being the locations and sizes (in para's) of ROM DOS ROM modules.

ROMSEG		equ	08000h		; ROM recorded at 70:0

ROM1SEG		equ	08000h		; 1st module contains resident
ROM1SIZ		equ	01000h		; BIOS and DOS

ROM2SEG		equ	09000h		; 2nd module contains complete
ROM2SIZ		equ	01000h		; ROM COMMAND


RESBIOSSEG	equ	08000h
RESBIOSSIZ	equ	00800h

RESDOSSEG	equ	08800h
RESDOSSIZ	equ	00800h

RESCOMSEG	equ	09000h
RESCOMSIZ	equ	01000h

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\redirsym.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector MACROS
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

EDW	MACRO	name
	extrn	name:near
	DW	OFFSET	RG:name
ENDM

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

CHECK_DIALECT	  MACRO   name

    IF2 					;AN000; If not defined yet,
       IFNDEF CHECKDIALECT			;AN000;  THEN Extrn
	  Extrn CHECKDIALECT&name:NEAR		;AN000;
       ENDIF					;AN000;
    ENDIF					;AN000;
	CALL	CHECKDIALECT&name		;AN000; Call the appropriate routine

ENDM

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

CallREDIRSub MACRO   name,fn,save,restore	;AN000;
    IF2 					;AN000; If not defined yet,
       IFNDEF REDIRSub&fn			;AN000;  THEN Extrn
	  Extrn REDIRSub&fn:NEAR		;AN000;
       ENDIF					;AN000;
    ENDIF					;AN000;
    IFNB    <save>				;AN000; If not blank
	SAVE <save>				;AN000;    Save the regs
    ENDIF					;AN000;
	CALL	REDIRSub&fn			;AN000; Call the appropriate routine
    IFNB    <restore>				;AN000; If not blank
	RESTORE	<restore>			;AN000;    Save the regs
    ENDIF					;AN000;
ENDM						;AN000;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector structures
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	INCLUDE IFSSYM.INC		 ;AN000;
	INCLUDE ERROR.INC		 ;AN000;
	INCLUDE FILEMODE.INC		 ;AN000;

;; CD_FSDA STRUCTURE

   CD_FSDA_OFF	   EQU WORD PTR CD_FSDA        ;AN000;
   CD_FSDA_SEG	   EQU WORD PTR CD_FSDA+2      ;AN000;
   CD_FSDA_FLAGS   EQU WORD PTR CD_FSDA+4      ;AN000;

;; DFL_FSDA STRUCTURE

   DF_FSDA_OFF	   EQU WORD PTR DFL_FSDA        ;AN000;
   DF_FSDA_SEG	   EQU WORD PTR DFL_FSDA+2      ;AN000;
   DF_FSDA_FLAGS   EQU WORD PTR DFL_FSDA+4      ;AN000;

;; SFF_FSDA STRUCTURE

   SFF_FSDA_OFF    EQU WORD PTR SFF_FSDA       ;AN000;
   SFF_FSDA_SEG    EQU WORD PTR SFF_FSDA+2     ;AN000;
   SFF_FSDA_FLAGS  EQU WORD PTR SFF_FSDA+4     ;AN000;

;; IFS Structure fixes

   ifsr_fcn_def    EXECAPI		 ;AN000;
   ifsr_api_def    OPENFILE		 ;AN000;
IFSR_OPENNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    SEARCHFILE		 ;AN000;
IFSR_SRCHNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    MKDIR		 ;AN000;
IFSR_DIRNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    DELFILE		 ;AN000;
IFSR_DELNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    FILEATTR		 ;AN000;
IFSR_ATTRNAME@	=  IFSR_NAME@		 ;AN000;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector Equates
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Get_Interrupt_Vector EQU     35H      ;AN000;
Set_Interrupt_Vector EQU     25H      ;AN000;
Deallocate_memory    EQU     49H      ;AN000;

GET_SYS_CONFIG	     EQU     0C000H   ;AN000; INT 15H to get configuration
CONFIG_STRUC	STRUC		      ;AN001;
   LENGTH	DW   ?		      ;AN001;
   MODEL_BYTE	DB   ?		      ;AN001;
CONFIG_STRUC	ENDS		      ;AN001;

LOWEST_386_MODEL     EQU     0F8H     ;AN001;

INCOR_DOS	     EQU     1	      ;AN000;
ALREADY_INST	     EQU     2	      ;AN000;
NOT_INST	     EQU     3	      ;AN000;
NET_NOT_STARTED      EQU     4	      ;AN000;
INSUFF_MEM	     EQU     5	      ;AN000;
BAD_PARM	     EQU     10       ;AN000;
INSUFFICENT_MEM      EQU     76       ;AN001; Extended Error

ONE_REPLACE	     EQU     1	      ;AN000;
SINGLE_COUNT	     EQU     1	      ;AN000;
TESTDIALECT	     =	     0	      ;AN001;

REDIR_INSTALLED      EQU     -1       ;AN000;
REDIR_SYS_INSTALL    EQU     0BF80H   ;AN000; REDIR.SYS 2FH Function number
REDIR_EXE_INSTALL    EQU     0BF00H   ;AN000; REDIR.EXE 2FH Function number

FASSIGN_ON	     EQU     -1       ;AN000;
FASSIGN_OFF	     EQU     0	      ;AN000;
FPRINT_ON	     EQU     -1       ;AN000;
FPRINT_OFF	     EQU     0	      ;AN000;

EXT_ERR_72	     EQU     72       ;AN000;
PSP_ENVIRO_SEG	     EQU     002CH    ;AN000; Offset into the PSP of the Enviroment Segment

PrnIO		     EQU     17H      ; Int vector for Printer IO
PrntScr 	     EQU     05H      ; Int vector for Print Screen
PrnRdrMark	     EQU     2	      ; Mark for port addr

VER12		     EQU     00000010b ;AN001;
VER13		     EQU     00000100b ;AN001;

FIRST_TIME	     EQU     1		 ;AN001;
SECOND_TIME	     EQU     2		 ;AN001;

SHIFT_BY_7	     EQU     7		 ;AN001;

HI_BIT_SHARING_MASK  EQU     1111111101111111b ;AN001; Turns off Hi bit in nibble


;; ###############################################################
;;		MISC.INC
;; ###############################################################

; NETFILE

attr_read_only	       = 00000001b

; NETINIT

IFSR_INVALID_CMD	=   -1							      ;AN000;

; NETUTIL

MACRO_4 	=	4
DATE_TIME	=	0


; NETHAND

LOCK_ALL_OPERS	   =	   0
POS_LEN_PTR_SIZE   =	   8		  ;AN001; 8 bytes for position/length

FIND_BUF    STRUC

find_buf_drive	    DB	?		; drive of search
find_buf_name	    DB	11 DUP (?)	; formatted name
find_buf_sattr	    DB	?		; attribute of search
find_buf_LastEnt    DW	?		; LastEnt
find_buf_DirStart   DW	?		; DirStart
find_buf_NetID	    DB	4 DUP (?)	; Reserved for NET
find_buf_attr	    DB	?		; attribute found
find_buf_time	    DW	?		; time
find_buf_date	    DW	?		; date
find_buf_size_l     DW	?		; low(size)
find_buf_size_h     DW	?		; high(size)
find_buf_pname	    DB	13 DUP (?)	; packed name

FIND_BUF    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\postequ.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; M024 MD 01/28/91      Added new keyboard commands
;
;----------------------------------------------------------------------------
;               EQUATES                 :
;----------------------------------------------------------------------------
TTEST           EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KY_LOCK         EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KEY_NUMS        EQU     0               ; CONDITIONAL ASM (KYBD.SRC)
;----------------------------------------------------------------------------
X287            EQU     0F0H            ; MATH PROCESSOR
;----------------------------------------------------------------------------
LOOP_POST       EQU     020H            ; MFG LOOP POST JUMPER
;----------------------------------------------------------------------------
REFRESH_BIT     EQU     010H            ; REFRESH TEST BIT
;----------------------------------------------------------------------------
POST_SS         EQU     0H              ; POST STACK SEGMENT
POST_SP         EQU     8000H           ; POST STACK POINTER
TEMP_STACK_LO   EQU     0FFFFH          ;
TEMP_STACK_HI   EQU     0               ; SET PROTECTED MODE TEMP_SS
                                        ; 0:FFFFH
;----------------------------------------------------------------------------
PORT_A          EQU     60H             ; 8042 KEYBOARD SCAN/DIAG OUTPUTS
PORT_B          EQU     61H             ; 8042 READ WRITE REGISTER
PARITY_ERR      EQU     0C0H            ; RAM/IO CHANNEL PARITY ERROR
RAM_PAR_ON      EQU     11110011B       ; AND THIS VALUE
RAM_PAR_OFF     EQU     00001100B       ; OR THIS VALUE
IO_CHK          EQU     01000000B       ; IO CHECK?
PRTY_CHK        EQU     10000000B       ; PARITY CHECK?

STATUS_PORT     EQU     64H             ;8042 STATUS PORT
OUT_BUF_FULL    EQU     01H             ; 0 = +OUTPUT BUFFER FULL
INPT_BUF_FULL   EQU     02H             ; 1 = +INPUT BUFFER FULL
SYS_FLAG        EQU     04H             ; 2 = -SYSTEM FLAG -POR/-SELF TEST
CMD_DATA        EQU     08H             ; 3 = -COMMAND/+DATA
KYBD_INH        EQU     10H             ; 4 = +KEYBOARD INHIBITED
TRANS_TMOUT     EQU     20H             ; 5 = +TRANSMIT TIMEOUT
RCV_TMOUT       EQU     40H             ; 6 = +RECEIVE TIME OUT
PARITY_EVEN     EQU     80H             ; 7 = +PARITY IS EVEN
SHUT_CMD        EQU     0FEH            ; CAUSE A SHUTDOWN COMMAND
INTR_FACE_CK    EQU     0ABH            ; CHECK 8042 INTERFACE CMD
KYBD_CLK_DATA   EQU     0E0H            ; GET KYBD CLOCK AND DATA CMD
KYBD_CLK        EQU     001H            ; KEYBOARD CLOCK BIT 0
;----------MANUFACTURING PORT------------------------------------------------
MFG_PORT        EQU     80H             ; MANUFACTURING CHECKPOINT PORT
;----------MANUFACTURING BIT DEFINITION FOR MFG_ERR_FLAG+1-------------------
MEM_FAIL        EQU     00000001B      ; STORAGE TEST FAILED (ERROR 20X)
PRO_FAIL        EQU     00000010B      ; VIRTUAL MODE TEST FAILED (ERROR 104)
LMCS_FAIL       EQU     00000100B      ; LOW MEG CHIP SELECT FAILED (ERROR 109)
KYCLK_FAIL      EQU     00001000B      ; KEYBOARD CLOCK TEST FAILED (ERROR 304)
KY_SYS_FAIL     EQU     00010000B      ; KEYBOARD OR SYSTEM FAILED (ERROR 303)
KYBD_FAIL       EQU     00100000B      ; KEYBOARD FAILED (ERROR 301)
DSK_FAIL        EQU     01000000B      ; DISKETTE TEST FAILED (ERROR 601)
KEY_FAIL        EQU     10000000B      ; KEYBOARD LOCKED (ERROR 302)
;----------8042 INPUT PORT BIT DEFINITION------------------------------------
BASE_RAM        EQU     10H             ;BASE R/W MEMORY
MFG_JMP         EQU     20H             ;LOOP POST JUMPER
DSP_JMP         EQU     40H             ;DISPLAY TYPE JUMPER
KEY_BD_INHIB    EQU     80H             ;KEYBOARD INHIBIT SWITCH
;----------8042 RAM DEFINITION-----------------------------------------------
INH_KEYBOARD    EQU     10H             ;BYTE 0 BIT 4 OF 8042 RAM
;-------------- COMMANDS ----------------------------------------------------
READ_8042_RAM   EQU     20H             ; BITS 0-4 = ADDRESS (20-3F)
WRITE_8042_RAM  EQU     60H             ;
SELF_8042_TEST  EQU     0AAH            ; 8042 SELF TEST
READ_8042_INPUT EQU     0C0H            ; READ 8042 INPUT PORT
ENA_KBD         EQU     0AEH            ; ENABLE KEYBOARD COMMAND
DIS_KBD         EQU     0ADH            ; DISABLE KEYBOARD COMMAND
ENABLE_BIT20    EQU     0DFH            ; ENABLE ADDR LINE BIT 20
DISABLE_BIT20   EQU     0DDH            ; DISABLE ADDR LINE BIT 20
ENABLE_AUX      EQU     0A8H            ; ENABLE AUX DEVICE COMMAND    ;M024
DISABLE_AUX     EQU     0A7H            ; DISABLE AUX DEVICE COMMAND   ;M024
;-------------- KEYBOARD/LED COMMANDS --------------------------------------
KB_MENU         EQU     0F1H            ; SELECT MENU COMMAND
KB_TYPA_RD      EQU     0F3H            ; SET TYPAMATIC RATE/DELAY         RWV 10-07-85
KB_ENABLE       EQU     0F4H            ; KEYBOARD ENABLE
KB_MAKE_BREAK   EQU     0F7H            ; TYPAMATIC
KB_ECHO         EQU     0FEH            ; ECHO COMMAND
KB_RESET        EQU     0FFH            ; SELF DIAGNOSTIC COMMAND
LED_CMD         EQU     0EDH            ; LED WRITE COMMAND
;--------------- KEYBOARD RESPONSE -----------------------------------------
KB_OK           EQU     0AAH            ; RESPONSE FROM SELF DIAG
KB_ACK          EQU     0FAH            ; ACKNOWLEDGE FROM TRANSMISSION
KB_OVER_RUN     EQU     0FFH            ; OVER RUN
KB_RESEND       EQU     0FEH            ; RESEND REQUEST
KB_BREAK        EQU     0F0H            ; KEYBOARD BREAK CODE
;-------------- CMOS EQUATES -------------------------------------------------
CMOS_PORT       EQU     070H            ; IO ADDRESS OF CMOS PORT
CLK_UP          EQU     08AH            ; CLOCK UPDATE STATUS
CMOS_ALARM      EQU     08BH            ;
CMOS_BEGIN      EQU     090H            ;
CMOS_END        EQU     0ADH            ;
SHUT_DOWN       EQU     08FH            ; SHUTDOWN OFFSET
BATTERY_COND_STATUS EQU 08DH            ; BATTERY STATUS
M_SIZE_HI       EQU     0B1H            ; IO MEMORY SIZE HIGH BYTE (POST)
M_SIZE_LO       EQU     0B0H            ; IO MEMORY SIZE LO BYTE   (POST)
M1_SIZE_HI      EQU     096H            ; 0->640K CONFIG MEMORY SIZE (SETUP)
M1_SIZE_LO      EQU     095H            ;   LOW BYTE (SETUP)
M2_SIZE_HI      EQU     098H            ; 640K->UP CONFIG MEMORY SIZE (SETUP)
M2_SIZE_LO      EQU     097H            ;   LOW BYTE (SETUP)
C_EQUIP         EQU     094H            ; CMOS EQUIPMENT FLAG
HD_FILE_TYPE    EQU     092H            ; HARD FILE TYPE BYTE
PAGE
;--------------- CMOS DIAG_STATUS ERROR FLAGS--------------------------------
DIAG_STATUS     EQU     08EH            ; CMOS ADDRESS OF DIAG_STATUS
BAD_BAT         EQU     080H            ; DEAD BATTERY
BAD_CKSUM       EQU     040H            ; CHECKSUM ERROR
BAD_CONFIG      EQU     020H            ; MINIMUM CONFIG USED INSTEAD OF CMOS
W_MEM_SIZE      EQU     010H            ; MEMORY SIZE NOT EQUAL TO CONFIG
HF_FAIL         EQU     008H            ; HARD FILE FAILURE ON INIT
CMOS_CLK_FAIL   EQU     004H            ; CMOS CLK NOT UPDATING OR NOT VALID
;--------------- CMOS INFORMATION FLAGS--------------------------------------
INFO_STATUS     EQU     0B3H            ; CMOS ADDRESS OF INFO BYTE
M640K           EQU     080H            ; 512K -> 640K CARD INSTALLED
NEW_INST        EQU     040H            ; FLAG USED BY CMOS SETUP UTILITY
HF_BOOT         EQU     020H            ; BOOT HARD FILE FLAG
;--------------- INTERRUPT EQUATES ------------------------------------------
INTA00          EQU     20H             ; 8259 PORT
INTA01          EQU     21H             ; 8259 PORT
EOI             EQU     20H
INTB00          EQU     0A0H            ; 2ND 8259
INTB01          EQU     0A1H            ;
INT_TYPE        EQU     070H            ; START OF 8259 INTERRUPT TABLE LOCATION
INT_VIDEO       EQU     010H            ; VIDEO VECTOR
;---------------------------------------------------------------------------
TIMER           EQU     40H
TIM_CTL         EQU     43H             ; 8253 TIMER CONTROL PORT ADDR
TIMER0          EQU     40H             ; 8253 TIMER/CNTER 0 PORT ADDR
TMINT           EQU     01              ; TIMER 0 INTR RECVD MASK
;--------------------------------------------------------------------------
DMA08           EQU     08              ; DMA STATUS REG PORT ADDR
DMA             EQU     00              ; DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA18           EQU     0D0H            ; 2ND DMA STATUS PORT ADDR
DMA1            EQU     0C0H            ; 2ND DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA_PAGE        EQU     81H             ; START OF DMA PAGE REGISTERS
LAST_DMA_PAGE   EQU     8FH             ; LAST DMA PAGE REGISTER
;--------------------------------------------------------------------------
MAX_PERIOD      EQU     540H
MIN_PERIOD      EQU     410H
KBD_IN          EQU     60H             ; KEYBOARD DATA IN ADDR PORT
KBDINT          EQU     02              ; KEYBOARD INTR MASK
KB_DATA         EQU     60H             ; KEYBOARD SCAN CODE PORT
KB_CTL          EQU     61H             ; CONTROL BITS FOR KEYBOARD SENSE DATA
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG
INS_STATE       EQU     80H             ; INSERT STATE IS ACTIVE
CAPS_STATE      EQU     40H             ; CAPS LOCK STATE HAS BEEN TOGGLED
NUM_STATE       EQU     20H             ; NUM LOCK STATE HAS BEEN TOGGLED
SCROLL_STATE    EQU     10H             ; SCROLL LOCK STATE HAS BEEN TOGGLED
ALT_SHIFT       EQU     08H             ; ALTERNATE SHIFT KEY DEPRESSED
CTL_SHIFT       EQU     04H             ; CONTROL SHIFT KEY DEPRESSED
LEFT_SHIFT      EQU     02H             ; LEFT SHIFT KEY DEPRESSED
RIGHT_SHIFT     EQU     01H             ; RIGHT SHIFT KEY DEPRESSED
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG_1
INS_SHIFT       EQU     80H             ; INSERT KEY IS DEPRESSED
CAPS_SHIFT      EQU     40H             ; CAPS LOCK KEY IS DEPRESSED
NUM_SHIFT       EQU     20H             ; NUM LOCK KEY IS DEPRESSED
SCROLL_SHIFT    EQU     10H             ; SCROLL LOCK KEY IS DEPRESSED
HOLD_STATE      EQU     08H             ; SUSPEND KEY HAS BEEN TOGGLED
SYS_SHIFT       EQU     04H             ; SYSTEM KEY DEPRESSED AND HELD
L_ALT_SHIFT     EQU     02H             ; LEFT ALT KEY DOWN                RWV 8-28-85
L_CTL_SHIFT     EQU     01H             ; LEFT CTL KEY DOWN                RWV 8-28-85
;---------------FLAGS WITHIN KB_FLAG_2
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
KB_PR_LED       EQU     40H             ; MODE INDICATOR UPDATE
KB_FE           EQU     20H             ; RESEND RECEIVED FLAG
KB_FA           EQU     10H             ; ACK RECEIVED
CIRCUS_SYSTEM   EQU     08H             ; CIRCUS SYSTEM INDICATOR
KB_LEDS         EQU     07H             ; KEYBOARD LED STATE BITS
;                       04H             ; CAPS LOCK INDICATOR
;                       02H             ; NUM LOCK INDICATOR
;                       01H             ; SCROLL LOCK INDICATOR
;---------------FLAGS WITHIN KB_FLAG_3
RD_ID           EQU     80H             ; DOING A READ ID (MUST BE BIT0)   AEV
LC_AB           EQU     40H             ; LAST CHAR WAS FIRST ID CHAR      AEV
SET_NUM_LK      EQU     20H             ; FORCE NUM LOCK IF RD ID & KBX    AEV
KBX             EQU     10H             ; ENHANCED KEYBOARD INSTALLED      RWV 7-18-85
R_ALT_SHIFT     EQU     08H             ; RIGHT ALT KEY DOWN               RWV 7-18-85
GRAPH_ON        EQU     08H             ; ALT GRAPHICS KEY DOWN (WT ONLY)  AEV
R_CTL_SHIFT     EQU     04H             ; RIGHT CTL KEY DOWN               RWV 7-18-85
LC_E0           EQU     02H             ; LAST CODE WAS THE E0 HIDDEN CODE RWV 7-18-85
LC_E1           EQU     01H             ; LAST CODE WAS THE E1 HIDDEN CODE RWV 7-18-85
;----- SCAN CODE EQUATES FOR THE KEYBOARD
NUM_KEY         EQU     69              ; SCAN CODE FOR NUMBER LOCK
SCROLL_KEY      EQU     70              ; SCAN CODE FOR SCROLL LOCK
ALT_KEY         EQU     56              ; SCAN CODE FOR ALTERNATE KEY
CTL_KEY         EQU     29              ; SCAN CODE FOR CONTROL KEY
CAPS_KEY        EQU     58              ; SCAN CODE FOR SHIFT LOCK
LEFT_KEY        EQU     42              ; SCAN CODE FOR LEFT SHIFT
RIGHT_KEY       EQU     54              ; SCAN CODE FOR RIGHT SHIFT
INS_KEY         EQU     82              ; SCAN CODE FOR INSERT KEY
DEL_KEY         EQU     83              ; SCAN CODE FOR DELETE KEY
SYS_KEY         EQU     84              ; SCAN CODE FOR SYSTEM KEY
;-------------- ENHANCED KEYBOARD EQUATES
ID_1            EQU     0ABH            ; 1ST ID CHAR FOR KBX
ID_2            EQU     041H            ; 2ND ID CHAR FOR KBX              AEV
ID_2A           EQU     054H            ; ALTERNATE 2ND ID CHAR FOR KBX    RWV 8-16-85
F11_M           EQU     87              ; F11 KEY MAKE
F12_M           EQU     88              ; F12 KEY MAKE
MC_E0           EQU     224             ; GENERAL MARKER CODE
MC_E1           EQU     225             ; PAUSE KEY MARKER CODE

;-------------- DISKETTE EQUATES
INT_FLAG        EQU     080H            ; INTERRUPT OCCURRENCE FLAG
MOTOR_WAIT      EQU     37              ; 2 SECS OF COUNTS FOR MOTOR TURN OFF
TIME_OUT        EQU     80H             ; ATTACHMENT FAILED TO RESPOND
BAD_SEEK        EQU     40H             ; SEEK OPERATION FAILED
BAD_NEC         EQU     20H             ; NEC CONTROLLER HAS FAILED
BAD_CRC         EQU     10H             ; BAD CRC ON DISKETTE READ
DMA_BOUNDARY    EQU     09H             ; ATTEMPT TO DMA ACROSS 64K BOUNDARY
BAD_DMA         EQU     08H             ; DMA OVERRUN ON OPERATION
MEDIA_CHANGE    EQU     06H             ; MEDIA REMOVED ON DUAL ATTACH CARD
RECORD_NOT_FND  EQU     04H             ; REQUESTED SECTOR NOT FOUND
WRITE_PROTECT   EQU     03H             ; WRITE ATTEMPTED ON WRITE PROT DISK
BAD_ADDR_MARK   EQU     02H             ; ADDRESS MARK NOT FOUND
BAD_CMD         EQU     01H             ; BAD COMMAND PASSED TO DISKETTE I/O

XRATE           EQU     02H             ; 250KBS DATA TRANSFER RATE
DUAL            EQU     01H             ; DUAL ATTACH CARD PRESENT FLAG

DSK_CHG         EQU     080H            ; DISKETTE CHANGE FLAG MASK BIT
STATE_MSK       EQU     007H            ; USED TO STRIP OFF STATE OF MEDIA
REV_STATE       EQU     0F8H            ; USED AS MASK FOR STATE BITS
DETERMINED      EQU     010H            ; SET STATE DETERMINED IN STATE BITS
TRAN_MSK        EQU     03H             ; ISOLATE SHIFTED TRANSFER RATE BITS
DOUBLE_STEP     EQU     020H            ; MASK TO TURN ON DOUBLE STEPPING
MOTOR_MSK       EQU     0F0H            ; MASK TO CLEAR MOTOR ON BITS
MAX_DRV         EQU     002H            ; MAX NUMBER OF DRIVES
;HOME            EQU     010H            ; TRACK 0 MASK
SENSE_DRV_ST    EQU     004H            ; SENSE DRIVE STATUS COMMAND
ONE             EQU     001H            ; SEEK ONE TRACK
TRK_SLAP        EQU     030H            ; CRASH STOP (48 TPI DRIVES)
QUIET_SEEK      EQU     00AH            ; SEEK TO TRACK 10
HD12_SETTLE     EQU     015D            ; 1.2 M HEAD SETTLE TIME
HD320_SETTLE    EQU     020D            ; 320 K HEAD SETTLE TIME
WRITE_OP        EQU     080H            ; WRITE OPERATION FLAG
DD_MASK         EQU     010H            ; MASK TO INDICATE DRIVE IS 80 TRACKS
PAGE
;------ DISK CHANGE LINE EQUATES
NOCHGLN         EQU     001H            ; NO DISK CHANGE LINE AVAILABLE
CHGLN           EQU     002H            ; DISK CHANGE LINE AVAILABLE
;------ MEDIA/DRIVE STATE INDICATORS
M326D326        EQU     093H            ; STATE MACHINE - 320/360 MEDIA/DRIVE
M326D12         EQU     074H            ; STATE MACHINE - 320/360 MEDIA,1.2DRIVE
M12D12          EQU     015H            ; STATE MACHINE - 1.2 MEDIA/DRIVE
POA_DUAL        EQU     061H            ; 300K DATA TRANSFER RATE & STATE 1
POA_START       EQU     080H            ; 250K DATA TRANSFER RATE & STATE 0
TRK_80          EQU     008H            ; DISKETTE DRIVE HAS 80 TRACKS
;------ CMOS NON-VOLATILE RAM EQUATES
CMOSDSB_ADDR    EQU     00EH            ; DISKETTE STATUS BYTE ADDRESS
CADR_PRT        EQU     070H            ; CMOS ADDRESS PORT ADDRESS
CDATA_PRT       EQU     071H            ; CMOS DATA PORT ADDRESS
CMOS_GOOD       EQU     0C0H            ; BATTERY AND CHECKSUM INDICATOR
CMOSDSK_BYTE    EQU     010H            ; DISKETTE BYTE ADDRESS
LOWNIB          EQU     00FH            ; ISOLATE LOW NIBBLE IN REGISTER MASK
INVALID_DRV     EQU     002H            ; FIRST INVALID DISKETTE TYPE
;----------------------------------------
;       TIMER DATA AREA                 :
;----------------------------------------
; COUNTS_SEC    EQU     18
; COUNTS_MIN    EQU     1092
; COUNTS_HOUR   EQU     65543
; COUNTS_DAY    EQU     1573040 = 1800B0H
PAGE

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\inc\psdata.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;*******************************************************************
; Parser include file
;*******************************************************************
IF1					;AN000;
;        %OUT    INCLUDING COMP=COMMON DSN=PSDATA.INC...;AN000;
ENDIF					;AN000;

	INCLUDE version.inc

;
;**** Default assemble switches definition *************************

IFNDEF	FarSW				;AN000;
FarSW	equ	0			;AN000; Near call expected
ENDIF					;AN000;

IFNDEF	DateSW				;AN000;
DateSW	equ	1			;AN000; Check date format
ENDIF					;AN000;

IFNDEF	TimeSW				;AN000;
TimeSW	equ	1			;AN000; Check time format
ENDIF					;AN000;

IFNDEF	FileSW				;AN000;
FileSW	equ	1			;AN000; Check file specification
ENDIF					;AN000;

IFNDEF	CAPSW				;AN000;
CAPSW	equ	1			;AN000; Perform CAPS if specified
ENDIF					;AN000;

IFNDEF	CmpxSW				;AN000;
CmpxSW	equ	1			;AN000; Check complex list
ENDIF					;AN000;

IFNDEF	NumSW				;AN000;
NumSW	equ	1			;AN000; Check numeric value
ENDIF					;AN000;

IFNDEF	KeySW				;AN000;
KeySW	equ	1			;AN000; Support keywords
ENDIF					;AN000;

IFNDEF	SwSW				;AN000;
SwSW	equ	1			;AN000; Support switches
ENDIF					;AN000;

IFNDEF	Val1SW				;AN000;
Val1SW	equ	1			;AN000; Support value definition 1
ENDIF					;AN000;

IFNDEF	Val2SW				;AN000;
Val2SW	equ	1			;AN000; Support value definition 2
ENDIF					;AN000;

IFNDEF	Val3SW				;AN000;
Val3SW	equ	1			;AN000; Support value definition 3
ENDIF					;AN000;

IFNDEF	DrvSW				;AN000;
DrvSW	equ	1			;AN000; Support drive only format
ENDIF					;AN000;

IFNDEF	QusSW				;AN000;
QusSW	equ	1			;AN000; Support quoted string format
ENDIF					;AN000;

IFNDEF	LFEOLSW 			;AN028;
LFEOLSW EQU	1			;AN028; Accept Line feed (0AH) as end of line
ENDIF					;AN028;

;**** Equation field
;-------- Character code definition

$P_DBSP1	   equ	DB_SP_HI	;AN000; 1st byte of DBCS blank
$P_DBSP2	   equ	DB_SP_LO	;AN000; 2nd byte of DBCS blank
$P_Period	   equ	"."             ;AN020;
$P_Slash	   equ	"/"             ;AN020;
$P_Space	   equ	" "             ;AN000; SBCS blank
$P_Comma	   equ	","             ;AN000;
$P_Switch	   equ	"/"             ;AN000;
$P_Keyword	   equ	"="             ;AN000;
$P_Colon	   equ	":"             ;AN000;
$P_Plus 	   equ	"+"             ;AN000;
$P_Minus	   equ	"-"             ;AN000;
$P_Rparen	   equ	")"             ;AN000;
$P_Lparen	   equ	"("             ;AN000;
;(deleted ;AN025;) $P_SQuote	      equ  "'"
$P_DQuote	   equ	'"'             ;AN000;
$P_NULL 	   equ	0		;AN000;
$P_TAB		   equ	9		;AN000;
$P_CR		   equ	0Dh		;AN000;
$P_LF		   equ	0Ah		;AN000;
$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code

;-------- Masks
$P_Make_Lower	   equ	20h		;AN000; make lower case character
$P_Make_Upper	   equ	0ffh-$P_Make_Lower ;AN000; make upper case character

		   PAGE 		   ;AN000;
;-------- DOS function call related equs

$P_DOS_Get_CDI	   equ	3800h		;AN000; get country dependent information
					; by this call, following information
$P_CDI		   struc		;AN000; is returned.
$P_CDI_DateF	   dw	0		;AN000;
$P_CDI_Money	   db	0,0,0,0,0	;AN000;
$P_CDI_1000	   db	0,0		;AN000;
$P_CDI_Dec	   db	0,0		;AN000;
$P_CDI_DateS	   db	0,0		;AN000;
$P_CDI_TimeS	   db	0,0		;AN000;
		   db	0		;AN000;
		   db	0		;AN000;
$P_CDI_TimeF	   db	0		;AN000;
		   dw	0,0		;AN000;
		   db	0,0		;AN000;
		   dw	5 dup(0)	;AN000;
$P_CDI		   ends 		;AN000;

$P_Date_MDY	   equ	0		;AN000;
$P_Date_DMY	   equ	1		;AN000;
$P_Date_YMD	   equ	2		;AN000;
;-------------
$P_DOS_GetEV	   equ	6300h		;AN000; get DBCS EV call
					;AN000; DS:SI will points to DBCS EV
;-------------
$P_DOS_Get_TBL	   equ	65h		;AN000; get uppercase table call
					;AN000; following parameters are set
					;AN000; to get casemap table.
$P_DOSTBL_Def	   equ	-1		;AN000; get default
$P_DOSTBL_BL	   equ	5		;AN000; buffer length for Tbl pointer
$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
					; By this call following information
					; is returned.
$P_DOS_TBL	   struc		;AN000;
$P_DOS_InfoID	   db	0		;AN000; information id for the table
$P_DOS_TBL_Off	   dw	0		;AN000; offset address of the table
$P_DOS_TBL_Seg	   dw	0		;AN000; segment address of the table
$P_DOS_TBL	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; PARMS 	LABEL	BYTE
;		DW	PARMSX
;		DB	2			; NUMBER OF STRINGS (0, 1, 2)
;		DB	length			; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "                  ; EXTRA DELIMITER LIST,
;						; TYPICAL ARE ";", "="
;						; "," & WHITESPACE ALWAYS
;		DB	length			; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "                  ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
;---------------------------------------------------------------------------------------------------------

;-------------------------------- PARMS block structure
$P_PARMS_Blk	   struc		;AN000;
$P_PARMSX_Address  dw	0		;AN000; Address of PARMSX
$P_Num_Extra	   db	0		;AN000; Number of extra stuff
$P_Len_Extra_Delim db	0		;AN000; Length of extra delimiter
$P_PARMS_Blk	   ends 		;AN000;

$P_Len_PARMS	   equ	4		;AN000;
$P_I_Use_Default   equ	0		;AN000; no extra stuff specified
$P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified

;---------------------------------------------------------------------------------------------------------
; PARMSX	LABEL	BYTE
;		DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
;		DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
;		:				; REPEATS maxp-1 TIMES
;		DB	maxs			; # OF SWITCHES
;		DW	CONTROL 		; DESCRIPTION OF SWITCH 1
;		:				; REPEATS maxs-1 TIMES
;		DB	maxk			; # OF KEYWORD
;		DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
;		:				; REPEATS maxk-1 TIMES
;---------------------------------------------------------------------------------------------------------

;-------------------------------- PARMSX block structure
$P_PARMSX_Blk	   struc		;AN000;
$P_MinP 	   db	0		;AN000; Minimum positional number
$P_Maxp 	   db	0		;AN000; Maximum positional number
$P_1st_Control	   dw	0		;AN000; Address of the 1st CONTROL block
$P_PARMSX_Blk	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Control field definition  >>
;
;
;CONTROL   LABEL   BYTE
;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0010H=IGNORE ":" AT END IN MATCH
;				   ; 0002H=REPEATS ALLOWED
;				   ; 0001H=OPTIONAL
;	   DW	   FUNCTION_FLAGS
;				   ; 0001H=CAP RESULT BY FILE TABLE
;				   ; 0002H=CAP RESULT BY CHAR TABLE
;				   ; 0010H=REMOVE ":" AT END
; (tm10)			   ; 0020H=colon is not necessary for switch
;	   DW	   RESULT	   ; RESULT BUFFER
;	   DW	   VALUES	   ; VALUE LISTS
;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
;	   DB	   "...",0         ; IF n >0, KEYWORD 1
;	   :
;
;Note:
;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
;      DATE bit simalteniously.
;
;      The parser examins each bit along with the following priority.
;
;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
;      FILE SPEC -> SIMPLE STRING.
;
;
;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
;      in the result buffer is capitalized.
;
;    - Match_Flags 0001H and 0002H have meaning only for the positional.
;
;
;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
;      switch, for example, '/A', then STRING points to;
;
;			DB    1 	; number of following synonyms
;			DB   '/A',0
;
;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
;
;			DB    1 	; number of following synonyms
;			DB   'CODEPAGE=',0
;
;
;    - "..." must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;
;
;    - One "..." can contain only one switch or keyword. If you need, for
;      example /A and /B, the format will be;
;
;			DB    2 	; number of following synonyms
;			DB    '/A',0
;			DB    '/B',0
;---------------------------------------------------------------------------------------------------------

;**** Match_Flags

$P_Num_Val	   equ	8000h		;AN000; Numeric Value
$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
$P_Simple_S	   equ	2000h		;AN000; Simple string
$P_Date_S	   equ	1000h		;AN000; Date string
$P_Time_S	   equ	0800h		;AN000; Time string
$P_Cmpx_S	   equ	0400h		;AN000; Complex string
$P_File_Spc	   equ	0200h		;AN000; File Spec
$P_Drv_Only	   equ	0100h		;AN000; Drive Only
$P_Qu_String	   equ	0080h		;AN000; Quoted string
$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
$P_Repeat	   equ	0002h		;AN000; Repeat allowed
$P_Optional	   equ	0001h		;AN000; Optional

;**** Function flags

$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10

;-------------------------------- Control block structure
$P_Control_Blk	   struc		;AN000;
$P_Match_Flag	   dw	0		;AN000; Controls type matched
$P_Function_Flag   dw	0		;AN000; Function should be taken
$P_Result_Buf	   dw	0		;AN000; Result buffer address
$P_Value_List	   dw	0		;AN000; Value list address
$P_nid		   db	0		;AN000; # of keyword/SW synonyms
$P_KeyorSW	   db	0		;AN000; keyword or sw
$P_Control_Blk	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Value List Definition >>
;
;VALUES 	LABEL	BYTE
;		DB	nval			; NUMBER OF VALUE DEFINITIONS (0 - 3)
;	     +-
;	     |	DB	nrng			; NUMBER OF RANGES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF RANGE MATCHED
;	     | +DD	X,Y			; RANGE OF VALUES
;	     |	:
;	     |	DB	nnval			; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF NUMBER CHOICE MATCHED
;	     | +DD	VALUE			; SPECIFIC CHOICE IF NUMBER
;	     |	:
;	     |	DB	nstrval 		; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF STRING CHOICE MATCHED
;	     | +DW	STRING			; SPECIFIC CHOICE IF STING
;	     +-	:
;
;STRING 	DB	"...",0                 ; ASCIIZ STRING IMAGE
;
;Note:
;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
;      when no choice lists are provided.
;
;    - STRING must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;---------------------------------------------------------------------------------------------------------

$P_nval_None	   equ	0		;AN000; no value list ID
$P_nval_Range	   equ	1		;AN000; range list ID
$P_nval_Value	   equ	2		;AN000; value list ID
$P_nval_String	   equ	3		;AN000; string list ID
$P_Len_Range	   equ	9		;AN000; Length of a range choice(two DD plus one DB)
$P_Len_Value	   equ	5		;AN000; Length of a value choice(one DD plus one DB)
$P_Len_String	   equ	3		;AN000; Length of a string choice(one DW plus one DB)
$P_No_nrng	   equ	0		;AN000; (tm07) no nrng. nnval must not be 0.

$P_Val_List	   struc		;AN000;
$P_NumofList	   db	0		;AN000; number of following choice
$P_Val_XL	   dw	0		;AN000; lower word of value
$P_Val_XH	   dw	0		;AN000; higher word of value
$P_Val_YL	   dw	0		;AN000; lower word of another value
$P_Val_YH	   dw	0		;AN000; higher word of another value
$P_Val_List	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Result Buffer Definition  >>
;
;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
;		DB	type			; TYPE RETURNED: 0=RESERVED,
;						;	1=NUMBER, 2=LIST INDEX,
;						;	3=STRING, 4=COMPLEX,
;						;	5=FILESPEC, 6=DRIVE
;						;	7=DATE, 8=TIME
;						;	9=QUOTED STRING
;		DB	ITEM_TAG		; MATCHED ITEM TAG
;
;		dw	synonym@		; es:@ points to found SYNONYM if provided.
;
;            +-
;	    | DD	n			; VALUE IF NUMBER
;	    | or
;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
;	    |					; (ES presents Segment address)
;	    | or
;	    |	DD	STRING			; OFFSET OF STRING VALUE
;	    | or
;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
;	    | or
;	    |	DW	YEAR	   ;(1980-2099)  IN CASE OF DATE
;	    |	DB	MONTH	   ;(1-12)	 Note: Range check is not performed.
;	    |	DB	DATE	   ;(1-31)	       0 is filled when the corresponding field was not specified.
;	    | or
;	    |	DB	HOUR	   ;(0-23)	  IN CASE OF TIME
;	    |	DB	MINUTES    ;(0-59)	  Note: Range check is not performed .
;	    |	DB	SECONDS    ;(0-59)		0 is filled when the corresponding field was not specified .
;	    |	DB	HUNDREDTHS ;(0-99)
;	    +-
;
;
;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
;      list.
;
;      YEAR: If the input value for the year is less than 100, parser
;	     adds 1900 to it.  For example, when 87 is input to parser for
;	     the year value, he returns 1987.
;---------------------------------------------------------------------------------------------------------

;-------------------------------- Result block structure
$P_Result_Blk	   struc		;AN000;
$P_Type 	   db	0		;AN000; Type returned
$P_Item_Tag	   db	0		;AN000; Matched item tag
$P_SYNONYM_Ptr	   dw	0		;AN000; pointer to Synonym list returned
$P_Picked_Val	   db	0,0,0,0 	;AN000; value
$P_Result_Blk	   ends 		;AN000;
;--------------------------------
;**** values for the type field 