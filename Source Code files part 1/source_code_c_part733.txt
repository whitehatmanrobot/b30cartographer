TER_OK               |
                                             PRINTER_PENDING_CREATION );

                } else {

                    pIniPrinter->Status |= PRINTER_PENDING_CREATION ;

                }

                // Half formed printers should be deleted
                // before they cause us trouble

                if ( pIniPrinter->Status & PRINTER_PENDING_CREATION ) {

                    pIniPrinter->Status |= PRINTER_PENDING_DELETION ;

                }



                cbData = sizeof(pIniPrinter->Priority);

                SplRegQueryValue( hPrinterKey,
                                  szPriority,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->Priority,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->DefaultPriority);

                SplRegQueryValue( hPrinterKey,
                                  szDefaultPriority,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->DefaultPriority,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->UntilTime);

                SplRegQueryValue( hPrinterKey,
                                  szUntilTime,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->UntilTime,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->StartTime);

                SplRegQueryValue( hPrinterKey,
                                  szStartTime,
                                  &Type,
                                  (LPBYTE)&pIniPrinter->StartTime,
                                  &cbData,
                                  pIniSpooler );

                cbData = sizeof(pIniPrinter->dnsTimeout);

                if ( SplRegQueryValue( hPrinterKey,
                                       szDNSTimeout,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->dnsTimeout,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    pIniPrinter->dnsTimeout = DEFAULT_DNS_TIMEOUT;
                }

                cbData = sizeof(pIniPrinter->txTimeout);

                if ( SplRegQueryValue( hPrinterKey,
                                       szTXTimeout,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->txTimeout,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    pIniPrinter->txTimeout = DEFAULT_TX_TIMEOUT;
                }

                cbData = sizeof( pIniPrinter->cChangeID ) ;

                if ( SplRegQueryValue( hPrinterKey,
                                       szTimeLastChange,
                                       &Type,
                                       (LPBYTE)&pIniPrinter->cChangeID,
                                       &cbData,
                                       pIniSpooler ) != ERROR_SUCCESS ) {

                    // Current Registry Doesn't have a UniqueID
                    // Make sure one gets written

                    bUpdateRegistryForThisPrinter = TRUE;

                }

                pIniPrinter->dwPrivateFlag = 0;
                pIniPrinter->cbDevMode = 0;
                pIniPrinter->pDevMode = NULL;

                if (SplRegQueryValue( hPrinterKey,
                                      szDevMode,
                                      &Type,
                                      NULL,
                                      &pIniPrinter->cbDevMode,
                                      pIniSpooler ) == ERROR_SUCCESS) {

                    if (pIniPrinter->cbDevMode) {

                        pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode);

                        SplRegQueryValue( hPrinterKey,
                                          szDevMode,
                                          &Type,
                                          (LPBYTE)pIniPrinter->pDevMode,
                                          &pIniPrinter->cbDevMode,
                                          pIniSpooler );
                    }
                }

                //
                //  A Provider might want to Read Extra Data from Registry
                //


                if ( pIniSpooler->pfnReadRegistryExtra != NULL ) {

                    pIniPrinter->pExtraData = (LPBYTE)(*pIniSpooler->pfnReadRegistryExtra)(hPrinterKey);

                }

                /* SECURITY */

                Status = SplRegQueryValue( hPrinterKey,
                                           szSecurity,
                                           NULL,
                                           NULL,
                                           &cbSecurity,
                                           pIniSpooler );

                if ((Status == ERROR_MORE_DATA) || (Status == ERROR_SUCCESS)) {

                    /* Use the process' heap to allocate security descriptors,
                     * so that they can be passed to the security API, which
                     * may need to reallocate them.
                     */
                    if (pIniPrinter->pSecurityDescriptor =
                                                   LocalAlloc(0, cbSecurity)) {

                        if (Status = SplRegQueryValue( hPrinterKey,
                                                       szSecurity,
                                                       NULL,
                                                       pIniPrinter->pSecurityDescriptor,
                                                       &cbSecurity,
                                                       pIniSpooler ) != ERROR_SUCCESS) {

                            LocalFree(pIniPrinter->pSecurityDescriptor);

                            pIniPrinter->pSecurityDescriptor = NULL;

                            DBGMSG( DBG_WARNING,
                                    ( "RegQueryValue returned %d on Permissions for %ws (%ws)\n",
                                      Status,
                                      pIniPrinter->pName ?
                                          pIniPrinter->pName :
                                          szNull,
                                      PrinterName) );
                        }
                    }

                } else {

                    pIniPrinter->pSecurityDescriptor = NULL;

                    DBGMSG( DBG_WARNING,
                            ( "RegQueryValue (2) returned %d on Permissions for %ws (%ws)\n",
                              Status,
                              pIniPrinter->pName ?
                                  pIniPrinter->pName :
                                  szNull,
                              PrinterName) );
                }

                pIniPrinter->MasqCache.bThreadRunning = FALSE;
                pIniPrinter->MasqCache.cJobs = 0;
                pIniPrinter->MasqCache.Status = 0;
                pIniPrinter->MasqCache.dwError = ERROR_SUCCESS;

                /* END SECURITY */

                if ( pIniPrinter->pName         &&
                     pIniPrinter->pShareName    &&
                     pKeyData                   &&
                     pIniPrinter->ppIniPorts    &&
                     pIniPrinter->pIniPrintProc &&
                     pIniPrinter->pIniDriver    &&
                     pIniPrinter->pLocation     &&
                     pIniPrinter->pComment      &&
                     pIniPrinter->pSecurityDescriptor
#if DBG
                     && ( IsValidSecurityDescriptor (pIniPrinter->pSecurityDescriptor)
                    ? TRUE
                    : (DBGMSG( DBG_SECURITY,
                               ( "The security descriptor for %ws (%ws) is invalid\n",
                                 pIniPrinter->pName ?
                                     pIniPrinter->pName :
                                     szNull,
                                     PrinterName)),  /* (sequential evaluation) */
                       FALSE) )
#endif /* DBG */
                    ) {


                    pIniPrinter->pIniFirstJob = pIniPrinter->pIniLastJob = NULL;

                    pIniPrinter->pIniPrintProc->cRef++;

                    INCDRIVERREF( pIniPrinter->pIniDriver );

                    for (i=0; i<pKeyData->cTokens; i++) {

                        pIniPort = (PINIPORT)pKeyData->pTokens[i];
                        pIniPrinter->ppIniPorts[i] = pIniPort;

                        pIniPort->ppIniPrinter =

                            ReallocSplMem(pIniPort->ppIniPrinter,
                                          pIniPort->cPrinters *
                                              sizeof(pIniPort->ppIniPrinter),
                                          (pIniPort->cPrinters+1) *
                                              sizeof(pIniPort->ppIniPrinter));

                        if (!pIniPort->ppIniPrinter) {
                            DBGMSG(DBG_WARNING, ("Failed to allocate memory for printer info\n." ));
                        }

                        pIniPort->ppIniPrinter[pIniPort->cPrinters] =
                                                                pIniPrinter;

                        //
                        // With the new monitors localspl does the
                        // redirection for LPT, COM ports
                        //
                        if ( !pIniPort->cPrinters++ )
                            CreateRedirectionThread(pIniPort);

                    }


                    pIniPrinter->cPorts = pKeyData->cTokens;
                    pIniPrinter->Priority =
                                  pIniPrinter->Priority ? pIniPrinter->Priority
                                                        : DEF_PRIORITY;

                    if ((pIniPrinter->Attributes &
                        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) ==
                        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT))

                        pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_DIRECT;

                    //
                    // I f we're upgrading, fix the NT4 bug that broke Masc printers.
                    // UpdateChangeID is passed into us as dwUpgradeFlag, so it determines
                    // if we're in an upgrade state.
                    //
                    // The rules: Printer name starts with \\
                    //            Port Name starts with \\
                    //            It's on a local IniSpooler.
                    //            The NETWORK and LOCAL bits are not set.
                    //
                    // If all the rules are met, set the NETWORK and LOCAL bits so the printer
                    // will behave properly.
                    //
                    if ( UpdateChangeID && (wcslen(pIniPrinter->pName) > 2) && pIniPrinter->cPorts &&
                         (*pIniPrinter->ppIniPorts)->pName && (wcslen((*pIniPrinter->ppIniPorts)->pName) > 2) &&
                         pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
                    {
                        WCHAR * pNameStr = pIniPrinter->pName;
                        WCHAR * pPortStr = (*pIniPrinter->ppIniPorts)->pName;
                        DWORD MascAttr   = (PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL);

                        if ((pNameStr[0] == L'\\') && (pNameStr[1] == L'\\') &&
                            (pPortStr[0] == L'\\') && (pPortStr[1] == L'\\') &&
                            ((pIniPrinter->Attributes & MascAttr) == 0))
                        {
                            pIniPrinter->Attributes |= MascAttr;
                        }

                    }

                    //
                    // If there were no ports for the printer, we set the state to
                    // work offline, but not if this was a masque printer. (In
                    // which case PRINTER_ATTRIBUTE_NETWORK is also set).
                    //
                    if (bNoPorts && !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_NETWORK)) {
                        pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;
                    }

                    pIniPrinter->pNext = pIniSpooler->pIniPrinter;

                    pIniPrinter->pIniSpooler = pIniSpooler;

                    pIniSpooler->pIniPrinter = pIniPrinter;

                    if ( bUpdateRegistryForThisPrinter ) {

                        UpdatePrinterIni( pIniPrinter , UPDATE_CHANGEID );
                        bUpdateRegistryForThisPrinter = UpdateChangeID;
                    }

                } else {

                    DBGMSG( DBG_WARNING,
                            ( "Initialization of printer failed:\
                               \n\tpPrinterName:\t%ws\
                               \n\tKeyName:\t%ws\
                               \n\tpShareName:\t%ws\
                               \n\tpKeyData:\t%08x\
                               \n\tpIniPrintProc:\t%08x",
                              pIniPrinter->pName ? pIniPrinter->pName : szNull,
                              PrinterName,
                              pIniPrinter->pShareName ? pIniPrinter->pShareName : szNull ,
                              pKeyData,
                              pIniPrinter->pIniPrintProc ) );

                    /* Do this in two lumps, because otherwise NTSD might crash.
                     * (Raid bug #10650)
                     */
                    DBGMSG( DBG_WARNING,
                            ( " \n\tpIniDriver:\t%08x\
                               \n\tpLocation:\t%ws\
                               \n\tpComment:\t%ws\
                               \n\tpSecurity:\t%08x\
                               \n\tStatus:\t\t%08x %s\n\n",
                              pIniPrinter->pIniDriver,
                              pIniPrinter->pLocation ? pIniPrinter->pLocation : szNull,
                              pIniPrinter->pComment ? pIniPrinter->pComment : szNull,
                              pIniPrinter->pSecurityDescriptor,
                              pIniPrinter->Status,
                              ( pIniPrinter->Status & PRINTER_PENDING_DELETION
                              ? "Pending deletion" : "" ) ) );

                    FreeStructurePointers((LPBYTE)pIniPrinter,
                                          NULL,
                                          IniPrinterOffsets);

                    if (pIniPrinter->pSecurityDescriptor) {
                        LocalFree(pIniPrinter->pSecurityDescriptor);
                        pIniPrinter->pSecurityDescriptor = NULL;
                    }

                    if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
                        ( pIniPrinter->pExtraData != NULL )) {

                        (*pIniSpooler->pfnFreePrinterExtra)( pIniPrinter->pExtraData );

                    }

                    //
                    // Reference count the pIniSpooler.
                    //
                    DECSPOOLERREF( pIniSpooler );

                    FreeSplMem(pIniPrinter);
                }

                FreePortTokenList(pKeyData);
                pKeyData = NULL;
            }
            SplRegCloseKey( hPrinterKey, pIniSpooler );
        }

        cPrinters++;

        cbData = COUNTOF(PrinterName);
    }

    if ( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {

        WCHAR szFilename[MAX_PATH];
        HRESULT RetVal;

        szFilename[0] = L'\0';

        //
        // FP Change
        // Initialize the File pool.
        //
        if (pIniSpooler->hFilePool == INVALID_HANDLE_VALUE)
        {
            if (GetPrinterDirectory(NULL, FALSE, szFilename, MAX_PATH, pIniSpooler))
            {
                RetVal = CreateFilePool(
                    &pIniSpooler->hFilePool,
                    szFilename,
                    L"FP",
                    L".SPL",
                    L".SHD",
                    POOL_TIMEOUT,
                    MAX_POOL_FILES
                    );
                if (FAILED(RetVal))
                {
                    DBGMSG( DBG_WARN,
                            ( "SplCreateSpooler: Initialization of FilePool Failed %x\n",
                              RetVal ));
                }
            }
            else
            {
                DBGMSG( DBG_WARN, ("CreateFilePool: GetPrinterDirectory Failed\n"));
            }
        }

        // Read .SHD/.SPL files from common printer directory
        ProcessShadowJobs( NULL, pIniSpooler );

        // If any printer has a separate Printer directory process them
        // also

        if( GetPrinterDirectory(NULL, FALSE, szData, COUNTOF(szData), pIniSpooler) ) {

            for ( pIniPrinter = pIniSpooler->pIniPrinter;
                  pIniPrinter;
                  pIniPrinter = pIniPrinter->pNext ) {

                if ((pIniPrinter->pSpoolDir != NULL) &&
                    (_wcsicmp(szData, pIniPrinter->pSpoolDir) != 0)) {

                        ProcessShadowJobs(pIniPrinter, pIniSpooler);

                }
            }
        }
    }


    UpdateReferencesToChainedJobs( pIniSpooler );

    // Finally, go through all Printers looking for PENDING_DELETION
    // if there are no jobs for that Printer, then we can delete it now

    CleanupDeletedPrinters(pIniSpooler);

    DBGMSG( DBG_TRACE, ("BuildPrinterInfo returned\n"));

    return TRUE;
}


/* InitializePrintProcessor
 *
 * Allocates and initialises an INIPRINTPROC structure for the specified
 * print processor and environment.
 *
 * Arguments:
 *
 *     hLibrary - Handle to a previously loaded library ,
 *
 *     pIniEnvironment - Data structure for the requested environment
 *         The pIniPrintProc field is initialised with the chain of print
 *         processor structures
 *
 *     pPrintProcessorName - The Print Processor name e.g. WinPrint
 *
 *     pDLLName - The DLL name, e.g. WINPRINT
 *
 * Returns:
 *
 *     The allocated PiniPrintProc if no error was detected, otherwise FALSE.
 *
 *
 */
PINIPRINTPROC
InitializePrintProcessor(
    HINSTANCE       hLibrary,
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName
)
{
    DWORD cb, cbNeeded, cReturned;
    PINIPRINTPROC pIniPrintProc;
    BOOL    rc;
    DWORD   Error;
    SIZE_T  cchString = 0;

    DBGMSG(DBG_TRACE, ("InitializePrintProcessor( %08x, %08x ,%ws, %ws)\n",
                        hLibrary, pPrintProcessorName, pPrintProcessorName, pDLLName));


    cb = sizeof(INIPRINTPROC) +
         wcslen(pPrintProcessorName)*sizeof(WCHAR) +
         sizeof(WCHAR) +
         wcslen(pDLLName)*sizeof(WCHAR) +
         sizeof(WCHAR);

    if (!(pIniPrintProc = (PINIPRINTPROC)AllocSplMem(cb))) {

        DBGMSG(DBG_WARNING, ("Failed to allocate %d bytes for print processor\n.", cb));
        return NULL;
    }

    __try {

        InitializeCriticalSection(&pIniPrintProc->CriticalSection);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        FreeSplMem(pIniPrintProc);
        SetLastError(GetExceptionCode());
        return NULL;
    }


    /* Typical strings used to build the full path of the DLL:
     *
     * pPathName    = C:\NT\SYSTEM32\SPOOL\PRTPROCS
     * pEnvironment = W32X86
     * pDLLName     = WINPRINT.DLL
     */

    pIniPrintProc->hLibrary = hLibrary;

    if (!pIniPrintProc->hLibrary) {

        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeSplMem(pIniPrintProc);
        DBGMSG(DBG_WARNING, ("Failed to LoadLibrary(%ws)\n", pDLLName));
        return NULL;
    }

    pIniPrintProc->EnumDatatypes = (pfnEnumDatatypes) GetProcAddress(pIniPrintProc->hLibrary,
                                             "EnumPrintProcessorDatatypesW");

    if (!pIniPrintProc->EnumDatatypes) {

        DBGMSG(DBG_WARNING, ("Failed to GetProcAddress(EnumDatatypes)\n"));
        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeLibrary(pIniPrintProc->hLibrary);
        FreeSplMem(pIniPrintProc);
        return NULL;
    }

    rc = (*pIniPrintProc->EnumDatatypes)(NULL, pPrintProcessorName, 1, NULL, 0, &cbNeeded, &cReturned);

    if (!rc && ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)) {

        pIniPrintProc->cbDatatypes = cbNeeded;

        if (!(pIniPrintProc->pDatatypes = AllocSplMem(cbNeeded))) {

            DBGMSG(DBG_WARNING, ("Failed to allocate %d bytes for print proc datatypes\n.", cbNeeded));
            DeleteCriticalSection(&pIniPrintProc->CriticalSection);
            FreeLibrary(pIniPrintProc->hLibrary);
            FreeSplMem(pIniPrintProc);
            return NULL;
        }

        if (!(*pIniPrintProc->EnumDatatypes)(NULL, pPrintProcessorName, 1,
                                             (LPBYTE)pIniPrintProc->pDatatypes,
                                             cbNeeded, &cbNeeded,
                                             &pIniPrintProc->cDatatypes)) {

            Error = GetLastError();
            DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) failed: Error %d\n",
                                 pPrintProcessorName, Error));
        }

    } else if(rc) {

        DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) returned no data\n",
                             pPrintProcessorName));

    } else {

        DBGMSG(DBG_WARNING, ("EnumPrintProcessorDatatypes(%ws) failed: Error %d\n",
                             pPrintProcessorName, Error));
    }

    pIniPrintProc->Install = (pfnInstallPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                            "InstallPrintProcessor");

    pIniPrintProc->Open = (pfnOpenPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                "OpenPrintProcessor");

    pIniPrintProc->Print = (pfnPrintDocOnPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                        "PrintDocumentOnPrintProcessor");

    pIniPrintProc->Close = (pfnClosePrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                    "ClosePrintProcessor");

    pIniPrintProc->Control = (pfnControlPrintProcessor) GetProcAddress(pIniPrintProc->hLibrary,
                                                                       "ControlPrintProcessor");

    pIniPrintProc->GetPrintProcCaps = (pfnGetPrintProcCaps) GetProcAddress(pIniPrintProc->hLibrary,
                                                     "GetPrintProcessorCapabilities");

    /* pName and pDLLName are contiguous with the INIPRINTPROC structure:
     */
    pIniPrintProc->pName = (LPWSTR)(pIniPrintProc+1);

    StringCbCopy(pIniPrintProc->pName, cb - sizeof(*pIniPrintProc), pPrintProcessorName);

    cchString = wcslen(pIniPrintProc->pName) + 1;

    pIniPrintProc->pDLLName = (LPWSTR)(pIniPrintProc->pName + cchString);

    StringCbCopy(pIniPrintProc->pDLLName, cb - sizeof(*pIniPrintProc) - cchString*sizeof(WCHAR), pDLLName);

    pIniPrintProc->signature = IPP_SIGNATURE;

    pIniPrintProc->pNext = pIniEnvironment->pIniPrintProc;

    pIniEnvironment->pIniPrintProc = pIniPrintProc;

    return pIniPrintProc;
}

/*++

Routine Name:

    InitializeLocalPrintProcessor

Routine Description:

    We start up the local print processor, we need to bump the reference count
    on it library instance so that the cleanup code does not accidentally
    unload localspl.dll while it is running.

Arguments:

    pIniEnvironment     -   The environment to add the print processor to.

Return Value:

    An HRESULT.

--*/
HRESULT
InitializeLocalPrintProcessor(
    IN      PINIENVIRONMENT     pIniEnvironment
    )
{
    HRESULT     hRetval     = E_FAIL;
    HINSTANCE   hLocalSpl   = NULL;
    WCHAR       szFilename[MAX_PATH];

    hRetval = pIniEnvironment ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetModuleFileName(hInst, szFilename, COUNTOF(szFilename)) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hLocalSpl = LoadLibrary(szFilename);

        hRetval = hLocalSpl ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = InitializePrintProcessor(hLocalSpl, pIniEnvironment, L"WinPrint", L"localspl.dll") ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval))
        {
            hLocalSpl = NULL;
        }
    }

    FreeLibrary(hLocalSpl);

    return hRetval;
}


/* LoadPrintProcessor
 *
 * Loads the DLL for the required Print Processor and then calls
 * InitializePrintProcessor for the necesary allocation and
 * initialization of an INIPRINTPROC structure for the specified
 * print processor and environment.
 *
 * Arguments:
 *
 *     pIniEnvironment - Data structure for the requested environment
 *         The pIniPrintProc field is initialised with the chain of print
 *         processor structures
 *
 *     pPrintProcessorName - The Print Processor name e.g. WinPrint
 *
 *     pDLLName - The DLL name, e.g. WINPRINT
 *
 *     pInitSpooler
 *
 * Returns:
 *
 *     PINIPRINTPROC if no error was detected, otherwise NULL.
 *
 *
 */
PINIPRINTPROC
LoadPrintProcessor(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR          pPrintProcessorName,
    LPWSTR          pDLLName,
    PINISPOOLER     pIniSpooler
)
{
    WCHAR        string[MAX_PATH];
    DWORD        dwOldErrMode = 0;
    HINSTANCE    hLibrary;
    DWORD         MinorVersion = 0;
    DWORD         MajorVersion = 0;
    PINIPRINTPROC pIniProc;


    DBGMSG(DBG_TRACE, ("LoadPrintProcessor( %08x, %ws, %ws )\n", pIniEnvironment, pPrintProcessorName, pDLLName));


    /* Originally:
     * Typical strings used to build the full path of the DLL:
     *
     * pPathName    = C:\NT\SYSTEM32\SPOOL\PRTPROCS
     * pEnvironment = W32X86
     * pDLLName     = WINPRINT.DLL
     * But after merging winprint and localspl , e.g. of setting
     * pPathName    = C:\NT\SYSTEM32
     * pDllName     = LOCALSPL.DLL
     */

    if( StrNCatBuff ( string,
                     COUNTOF(string),
                     pIniSpooler->pDir,
                     L"\\PRTPROCS\\",
                     pIniEnvironment->pDirectory,
                     L"\\",
                     pDLLName,
                     NULL) != ERROR_SUCCESS) {

        SetLastError(ERROR_BAD_PATHNAME);

        return NULL;
    }

    dwOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    hLibrary = LoadLibrary(string);

    //
    // We are a cluster spooler and we cannot find the library for a print
    // processor. We will try to copy the print processor from the cluster.
    // disk.
    //
    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        !hLibrary                                    &&
        GetLastError() == ERROR_MOD_NOT_FOUND)
    {
        WCHAR szSourceFile[MAX_PATH];
        WCHAR szDestDir[MAX_PATH];
        DWORD dwError;

        DBGMSG(DBG_CLUSTER, ("LoadPrintProcessor File not found "TSTR"\n", string));

        if ((dwError = StrNCatBuff(szDestDir,
                                   COUNTOF(szDestDir),
                                   pIniSpooler->pDir,
                                   L"\\PRTPROCS\\",
                                   pIniEnvironment->pDirectory,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szSourceFile,
                                   COUNTOF(szSourceFile),
                                   pIniSpooler->pszClusResDriveLetter,
                                   L"\\",
                                   szClusterDriverRoot,
                                   L"\\",
                                   pIniEnvironment->pDirectory,
                                   L"\\",
                                   pDLLName,
                                   NULL)) == ERROR_SUCCESS)
        {
            //
            // Make sure the destination directory exists
            //
            CreateCompleteDirectory(szDestDir);

            //
            // Try to copy the print proc file from the cluster disk
            //
            if (CopyFile(szSourceFile, string, FALSE) &&
                (hLibrary = LoadLibrary(string)))
            {
                DBGMSG(DBG_CLUSTER, ("LoadPrintProc copied "TSTR" to "TSTR"\n", szSourceFile, string));
            }
            else
            {
                dwError = GetLastError();
            }
        }
    }

    if (hLibrary)
    {
        if (!GetBinaryVersion(string, &MajorVersion, &MinorVersion))
        {
            DBGMSG(DBG_ERROR, ("GetBinaryVersion failed. Error %u\n", GetLastError()));
        }
    }

    SetErrorMode( dwOldErrMode );       /* Restore error mode */

    pIniProc = InitializePrintProcessor(hLibrary,
                                        pIniEnvironment,
                                        pPrintProcessorName,
                                        pDLLName);

    if (pIniProc)
    {
        pIniProc->FileMajorVersion = MajorVersion;
        pIniProc->FileMinorVersion = MinorVersion;
    }

    return pIniProc;
}


/*
   Current Directory == c:\winspool\drivers
   pFindFileData->cFileName == win32.x86
*/


/* BuildEnvironmentInfo
 *
 *
 * The registry tree for Environments is as follows:
 *
 *     Print
 *      
 *       Environments
 *         
 *          Windows NT x86
 *            
 *             Drivers
 *               
 *                Agfa Compugraphic Genics (e.g.)
 *            
 *                  :
 *                  :
 *            
 *             Print Processors
 *                
 *                 WINPRINT : WINPRINT.DLL (e.g.)
 *         
 *                   :
 *                   :
 *         
 *          Windows NT R4000
 *      
 *       Printers
 *
 *
 *
 */
BOOL
BuildEnvironmentInfo(
    PINISPOOLER pIniSpooler
    )
{
    WCHAR   Environment[MAX_PATH];
    WCHAR   szData[MAX_PATH];
    DWORD   cbData, cb;
    DWORD   cchBuffer = COUNTOF(Environment);
    DWORD   cEnvironments=0, Type;
    HKEY    hEnvironmentsKey, hEnvironmentKey;
    LPWSTR  pDirectory;
    PINIENVIRONMENT pIniEnvironment;
    LONG    Status;

    //
    // The local spooler and cluster spooler have each different places
    // where they store information about environments
    //
    if (pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG)
    {
        Status = SplRegOpenKey(pIniSpooler->hckRoot,
                               pIniSpooler->pszRegistryEnvironments,
                               KEY_READ,
                               &hEnvironmentsKey,
                               pIniSpooler);
    }
    else
    {
        Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pIniSpooler->pszRegistryEnvironments, 0, KEY_READ, &hEnvironmentsKey);
    }

    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_CLUSTER, ("RegOpenKey of %ws Failed: Error = %d\n", szEnvironmentsKey, Status));

        return FALSE;
    }

    //
    // Enumerate the subkeys of "Environment".
    // This will give us "Windows NT x86", "Windows NT R4000", * and maybe others:
    //
    while (SplRegEnumKey(hEnvironmentsKey, cEnvironments, Environment, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS) {

        DBGMSG(DBG_CLUSTER, ("Found environment "TSTR"\n", Environment));

        //
        // For each environment found, create or open the key:
        //
        if (SplRegCreateKey(hEnvironmentsKey, Environment, 0, KEY_READ, NULL, &hEnvironmentKey, NULL, pIniSpooler) == ERROR_SUCCESS) {

            cbData = sizeof(szData);

            pDirectory = NULL;

            //
            // Find the name of the directory associated with this environment,
            // e.g. "Windows NT x86"   -> "W32X86"
            //      "Windows NT R4000" -> "W32MIPS"
            //
            if (RegGetString(hEnvironmentKey, szDirectory, &pDirectory, &cbData, &Status, TRUE, pIniSpooler)) {

                DBGMSG(DBG_CLUSTER, ("BuildEnvInfo pDirectory "TSTR"\n", pDirectory));
            }

            cb = sizeof(INIENVIRONMENT) + wcslen(Environment)*sizeof(WCHAR) + sizeof(WCHAR);

            if (pDirectory && (pIniEnvironment=AllocSplMem(cb))) {

                StringCbCopy((LPWSTR)(pIniEnvironment+1), cb - sizeof(*pIniEnvironment), Environment);

                pIniEnvironment->pName         = (LPWSTR)(pIniEnvironment+1);
                pIniEnvironment->signature     = IE_SIGNATURE;
                pIniEnvironment->pDirectory    = pDirectory;
                pIniEnvironment->pNext         = pIniSpooler->pIniEnvironment;
                pIniSpooler->pIniEnvironment   = pIniEnvironment;
                pIniEnvironment->pIniVersion   = NULL;
                pIniEnvironment->pIniPrintProc = NULL;
                pIniEnvironment->pIniSpooler   = pIniSpooler;
                if(!_wcsicmp(Environment,LOCAL_ENVIRONMENT)) {

                    (VOID)InitializeLocalPrintProcessor(pIniEnvironment);
                }

                BuildDriverInfo(hEnvironmentKey, pIniEnvironment, pIniSpooler);
                BuildPrintProcInfo (hEnvironmentKey, pIniEnvironment, pIniSpooler);

                DBGMSG(DBG_TRACE, ("Data for environment %ws created:\
                                    \n\tpDirectory: %ws\n",
                                   Environment,
                                   pDirectory));
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        cEnvironments++;

        cchBuffer = COUNTOF(Environment);
    }

    SplRegCloseKey(hEnvironmentsKey, pIniSpooler);

    if (!(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER))
    {
        pThisEnvironment = FindEnvironment(szEnvironment, pIniSpooler);
    }

    return FALSE;
}



BOOL
BuildDriverInfo(
    HKEY            hKeyEnvironment,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    )

/*++

Routine Description:

    Creates driver and version ini structures based on environment.

Arguments:

    hKeyEnvironment - Registry key specifying environment.

    pIniEnvironment - Structure for environemnt.  Will be initialized
        to hold pIniVersions and pIniDrivers.

Return Value:

    TRUE - Success,
    False - Failure.

--*/

{
    WCHAR   szVersionName[MAX_PATH];
    DWORD   cchBuffer;
    DWORD   cVersion;
    HKEY    hDriversKey;
    DWORD   Status;
    PINIVERSION pIniVersionList, pIniVersion;

    Status = SplRegCreateKey(hKeyEnvironment,szDriversKey, 0, KEY_READ, NULL, &hDriversKey, NULL, pIniSpooler);

    if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("RegOpenKeyEx of %ws failed: Error = %d\n", szDriversKey, Status));
        return FALSE;
    }

    DBGMSG(DBG_TRACE,("RegCreateKeyEx succeeded in BuildDriverInfo\n"));

    for( pIniVersionList = NULL, cVersion = 0;

         cchBuffer = COUNTOF( szVersionName ),
         SplRegEnumKey(hDriversKey, cVersion, szVersionName, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS;

         cVersion++ ){

        DBGMSG(DBG_TRACE,("Version found %ws\n", szVersionName));

        //
        // If it isn't a version -- remember we look for current
        // drivers before we upgrade, just move on.
        //
        if (_wcsnicmp(szVersionName, L"Version-", 8)) {
            continue;
        }

        pIniVersion = GetVersionDrivers( hDriversKey,
                                         szVersionName,
                                         pIniSpooler,
                                         pIniEnvironment );

        if( pIniVersion ){
            InsertVersionList( &pIniVersionList, pIniVersion );
        }
    }
    SplRegCloseKey(hDriversKey, pIniSpooler);
    pIniEnvironment->pIniVersion = pIniVersionList;

    return TRUE;
}


/* BuildPrintProcInfo
 *
 * Opens the printproc subkey for the specified environment and enumerates
 * the print processors listed.
 *
 * For each print processor found, calls InitializePrintProcessor to allocate
 * and inintialize a data structure.
 *
 * This function was adapted to use SplReg functions. Those functions are
 * cluster aware.
 *
 * Arguments:
 *
 *     hKeyEnvironment - The key for the specified environment,
 *         used for Registry API calls.
 *
 *     pIniEnvironment - Data structure for the environment.
 *         The pIniPrintProc field will be initialised to contain a chain
 *         of one or more print processors enumerated from the registry.
 *
 * Return:
 *
 *     TRUE if operation was successful, otherwise FALSE
 */
BOOL
BuildPrintProcInfo(
    HKEY            hKeyEnvironment,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    WCHAR   PrintProcName[MAX_PATH];
    WCHAR   DLLName[MAX_PATH];
    DWORD   cchBuffer, cbDLLName;
    DWORD   cPrintProcs = 0;
    HKEY    hPrintProcKey, hPrintProc;
    DWORD   Status;
    PINIPRINTPROC pIniPrintProc;

    if ((Status = SplRegOpenKey(hKeyEnvironment,
                                szPrintProcKey,
                                KEY_READ,
                                &hPrintProcKey,
                                pIniSpooler)) == ERROR_SUCCESS)
    {
        cchBuffer = COUNTOF(PrintProcName);

        while (SplRegEnumKey(hPrintProcKey,
                             cPrintProcs,
                             (LPTSTR)PrintProcName,
                             &cchBuffer,
                             NULL,
                             pIniSpooler) == ERROR_SUCCESS)
       {
            DBGMSG(DBG_TRACE, ("BuildPrintProcInfo Print processor found: %ws\n", PrintProcName));

            if (SplRegOpenKey(hPrintProcKey,
                              PrintProcName,
                              KEY_READ,
                              &hPrintProc,
                              pIniSpooler) == ERROR_SUCCESS)
            {
                cbDLLName = sizeof(DLLName);

                if (SplRegQueryValue(hPrintProc,
                                     szDriverFile,
                                     NULL,
                                     (LPBYTE)DLLName,
                                     &cbDLLName,
                                     pIniSpooler) == ERROR_SUCCESS)
                {
                    pIniPrintProc = LoadPrintProcessor(pIniEnvironment,
                                                       PrintProcName,
                                                       DLLName,
                                                       pIniSpooler);
                }

                SplRegCloseKey(hPrintProc, pIniSpooler);
            }

            //
            // Don't delete the key !! If winprint.dll was corrupt,
            // then we nuke it and we are hosed since there is no UI
            // to add print procs.
            // We can afford to be a little slow on init, since we only
            // do it once.
            //
            cchBuffer = COUNTOF(PrintProcName);
            cPrintProcs++;
        }

        SplRegCloseKey(hPrintProcKey, pIniSpooler);

        DBGMSG(DBG_TRACE, ("End of print processor initialization.\n"));

    } else {

        DBGMSG (DBG_WARNING, ("SplRegOpenKey failed: Error = %d\n", Status));

        return FALSE;
    }

    return TRUE;
}


#define SetOffset(Dest, Source, End)                                      \
              if (Source) {                                               \
                 Dest=End;                                                \
                 End+=wcslen(Source)+1;                                   \
              }

#define SetPointer(struc, off)                                            \
              if (struc->off) {                                           \
                 struc->off += (ULONG_PTR)struc/sizeof(*struc->off);      \
              }

#define WriteString(hFile, pStr)  \
              if (pStr) {\
                  rc = WriteFile(hFile, pStr, wcslen(pStr)*sizeof(WCHAR) + \
                            sizeof(WCHAR), &BytesWritten, NULL);    \
                  if (!rc) { \
                      DBGMSG(DBG_WARNING, ("WriteShadowJob: WriteFile failed %d\n", \
                                            GetLastError())); \
                  } \
              }

#define AddSize(pStr, dwSize)                                         \
              if (pStr) {                                             \
                  dwSize = dwSize + (wcslen(pStr) + 1)*sizeof(WCHAR); \
              }

VOID
__inline
CopyString(
    IN  OUT     BYTE           *pBuffer,
    IN  OUT     ULONG_PTR      *pdwOffset,
    IN  OUT     SIZE_T         *pcbRemaining,
    IN          PCWSTR         pStr)
{
    if (pStr) {

        PWSTR     pszEnd = 0;

        StrCbCopyMultipleStr((LPWSTR)(pBuffer + *pdwOffset), *pcbRemaining, pStr, &pszEnd, pcbRemaining);

        *pdwOffset = (pszEnd - (LPWSTR)pBuffer) * sizeof(WCHAR);
    }
}

BOOL
WriteShadowJob(
    IN      PINIJOB      pIniJob,
    IN      BOOL         bLeaveCS
    )
{
   BOOL         bAllocBuffer        = FALSE;
   BOOL         bRet                = FALSE;
   BOOL         bFileCreated        = FALSE;
   HANDLE       hFile               = INVALID_HANDLE_VALUE;
   HANDLE       hImpersonationToken = INVALID_HANDLE_VALUE;
   DWORD        BytesWritten, cbSize, dwType, dwData, dwcbData;
   SIZE_T       cbRemaining = 0;
   ULONG_PTR    dwOffset, cb;
   SHADOWFILE_3 ShadowFile = {0};
   LPWSTR       pEnd;
   WCHAR        szFileName[MAX_PATH];
   BYTE         ShdFileBuffer[MAX_STATIC_ALLOC];
   LPBYTE       pBuffer;
   HKEY         hPrintRegKey = NULL;
   BOOL         UsePools = TRUE;

   SplInSem();

   //
   // Only update if this is not a direct job and the spooler requests it.
   // Also don't update if the shadow file has been deleted at some other point.
   // This check must be performed in the CS else the FilePool starts leaking
   // jobs.
   //
   if ( (pIniJob->Status & JOB_DIRECT) ||
        (pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags
                        & SPL_NO_UPDATE_JOBSHD) ||
        (pIniJob->Status & JOB_SHADOW_DELETED) ) {

        bRet = TRUE;

        //
        // Setting this to FALSE prevents us reentering the CS accidentally.
        //
        bLeaveCS = FALSE;
        goto CleanUp;
   }

   if (bLeaveCS)  {

       LeaveSplSem();
       SplOutSem();
   }

   //
   // FP Change
   // if we don't have a handle to a filepool item, we
   // revert to the old methods.
   //
   if (pIniJob->hFileItem == INVALID_HANDLE_VALUE)
   {
       UsePools = FALSE;
   }


   if (!UsePools)
   {
       GetFullNameFromId(pIniJob->pIniPrinter, pIniJob->JobId, FALSE, szFileName, COUNTOF(szFileName), FALSE);
   }

   hImpersonationToken = RevertToPrinterSelf();

   if (UsePools)
   {
       HRESULT      RetVal              = S_OK;
       //
       // FP Change
       // We Get a write handle from the pool for the shadow files and
       // truncate it for use.
       //
       RetVal = GetWriterFromHandle(pIniJob->hFileItem, &hFile, FALSE);

       if (SUCCEEDED(RetVal))
       {
           //
           // Even if we can't set the file pointer, we have signalled to the
           // file pool that a writer is busy with this file pool object.
           //
           bFileCreated = TRUE;

           if (INVALID_SET_FILE_POINTER == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
           {
               DBGMSG( DBG_WARNING,
                   ( "WriteShadowJob Failed to set File pointer. Error %d\n", GetLastError() ));
               hFile = INVALID_HANDLE_VALUE;
           }
       }
       else
       {
           DBGMSG( DBG_WARNING,
               ( "WriteShadowJob Failed to get File Handle from Pool Item. Error %x\n", RetVal ));
           hFile = INVALID_HANDLE_VALUE;
       }
    }
   else
   {
       //
       // Open file in Cached IO. Big performance gain.
       //
       hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_READ,
                          NULL, CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);

       if (hFile != INVALID_HANDLE_VALUE) {

            bFileCreated = TRUE;
       }
   }

   bRet = ImpersonatePrinterClient(hImpersonationToken);

   if(!bRet)
   {
       DBGMSG( DBG_WARNING,
               ( "Failed ot impersonate client \n" ));

       goto CleanUp;

   }

   if ( hFile == INVALID_HANDLE_VALUE ) {

      DBGMSG( DBG_WARNING,
              ( "WriteShadowJob failed to open shadow file "TSTR"\n Error %d\n",
                szFileName, GetLastError() ));

      bRet = FALSE;

      goto CleanUp;

   }

   //
   // We need to be able to tell if a shadow file was saved in .NET or in a previous OS
   // version before an upgrade.
   //
   ShadowFile.signature = SF_SIGNATURE_3_DOTNET;
   ShadowFile.cbSize    = sizeof( SHADOWFILE_3 );
   ShadowFile.Version   = SF_VERSION_3;
   ShadowFile.Status    = pIniJob->Status;
   ShadowFile.JobId     = pIniJob->JobId;
   ShadowFile.Priority  = pIniJob->Priority;
   ShadowFile.Submitted = pIniJob->Submitted;
   ShadowFile.StartTime = pIniJob->StartTime;
   ShadowFile.UntilTime = pIniJob->UntilTime;
   ShadowFile.Size      = pIniJob->Size;
   ShadowFile.dwValidSize = pIniJob->dwValidSize;
   ShadowFile.cPages    = pIniJob->cPages;
   ShadowFile.dwReboots  = pIniJob->dwReboots;
   if(pIniJob->pSecurityDescriptor)
       ShadowFile.cbSecurityDescriptor=GetSecurityDescriptorLength(
                                           pIniJob->pSecurityDescriptor);

   pEnd=(LPWSTR)sizeof(ShadowFile);

   if (pIniJob->pDevMode) {
      ShadowFile.pDevMode=(LPDEVMODE)pEnd;
      cb = pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra;
      cb = ALIGN_UP(cb,ULONG_PTR);
      cb /= sizeof(WCHAR);
      pEnd += cb;
   }

   if (pIniJob->pSecurityDescriptor) {
      ShadowFile.pSecurityDescriptor=(PSECURITY_DESCRIPTOR)pEnd;
      cb = ShadowFile.cbSecurityDescriptor;
      cb = ALIGN_UP(cb,ULONG_PTR);
      cb /= sizeof(WCHAR);
      pEnd += cb;
   }

   ShadowFile.NextJobId = pIniJob->NextJobId;

   SetOffset( ShadowFile.pNotify, pIniJob->pNotify, pEnd );
   SetOffset( ShadowFile.pUser, pIniJob->pUser, pEnd );
   SetOffset( ShadowFile.pDocument, pIniJob->pDocument, pEnd );
   SetOffset( ShadowFile.pOutputFile, pIniJob->pOutputFile, pEnd );
   SetOffset( ShadowFile.pPrinterName, pIniJob->pIniPrinter->pName, pEnd );
   SetOffset( ShadowFile.pDriverName, pIniJob->pIniDriver->pName, pEnd );
   SetOffset( ShadowFile.pPrintProcName, pIniJob->pIniPrintProc->pName, pEnd );
   SetOffset( ShadowFile.pDatatype, pIniJob->pDatatype, pEnd );
   SetOffset( ShadowFile.pParameters, pIniJob->pParameters, pEnd );
   SetOffset( ShadowFile.pMachineName, pIniJob->pMachineName, pEnd );

   cbSize = (DWORD)ALIGN_UP(pEnd, ULONG_PTR);

   if (cbSize > MAX_STATIC_ALLOC) {

       if (!(pBuffer = (LPBYTE) AllocSplMem(cbSize))) {

           DBGMSG( DBG_WARNING, ("WriteShadowJob: Memory Allocation failed %d\n", GetLastError()));

           bRet = FALSE;

           goto CleanUp;
       }
       bAllocBuffer = TRUE;

       cbRemaining = cbSize;

   } else {

       pBuffer = (LPBYTE) ShdFileBuffer;

       cbRemaining = COUNTOF(ShdFileBuffer);
   }


   //
   // Copy SHADOWFILE_3 and data pointed thru it, into the buffer
   //

   dwOffset = 0;

   CopyMemory(pBuffer + dwOffset, &ShadowFile, sizeof(SHADOWFILE_3));
   dwOffset += sizeof(SHADOWFILE_3);

   if (pIniJob->pDevMode) {

       CopyMemory(pBuffer + dwOffset, pIniJob->pDevMode, pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra);
       dwOffset += (pIniJob->pDevMode->dmSize + pIniJob->pDevMode->dmDriverExtra);
       dwOffset = ALIGN_UP(dwOffset,ULONG_PTR);
   }

   if (pIniJob->pSecurityDescriptor) {

       CopyMemory(pBuffer + dwOffset, pIniJob->pSecurityDescriptor, ShadowFile.cbSecurityDescriptor);
       dwOffset += ShadowFile.cbSecurityDescriptor;
       dwOffset = ALIGN_UP(dwOffset,ULONG_PTR);
   }

   //
   // CopyString is defined at the start of the function
   //
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pNotify);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pUser);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pDocument);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pOutputFile);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pIniPrinter->pName);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pIniDriver->pName);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pIniPrintProc->pName);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pDatatype);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pParameters);
   CopyString(pBuffer, &dwOffset, &cbRemaining, pIniJob->pMachineName);

   //
   // Copy the structure into the Shadow file. Buffers need not be buffered since the
   // file is opened in WRITE_THROUGH mode.
   //
   bRet = WriteFile( hFile, pBuffer, cbSize, &BytesWritten, NULL);

   //
   // Flush the file buffers if the corresponding flag is set in the registry
   //
   if (dwFlushShadowFileBuffers == 0) {

       // Avoid repeated initializations
       dwFlushShadowFileBuffers = 2;

       // flag has to be initialized from the registry
       dwcbData = sizeof(DWORD);
       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        szRegistryRoot,
                        0,
                        KEY_READ,
                        &hPrintRegKey) == ERROR_SUCCESS) {

           if (RegQueryValueEx(hPrintRegKey,
                               szFlushShadowFileBuffers,
                               NULL,
                               &dwType,
                               (LPBYTE) &dwData,
                               &dwcbData) == ERROR_SUCCESS) {

                if (dwData == 1) {
                    // Flush the shadow file buffers
                    dwFlushShadowFileBuffers = 1;
                }
           }

           RegCloseKey(hPrintRegKey);
       }
   }

   if (dwFlushShadowFileBuffers == 1) {
       bRet = FlushFileBuffers(hFile);
   }

   if (!bRet) {

       DBGMSG( DBG_WARNING, ("WriteShadowJob: WriteFile failed %d\n", GetLastError()));
   }

CleanUp:

   if (bAllocBuffer) {
       FreeSplMem(pBuffer);
   }

   if (!UsePools && hFile != INVALID_HANDLE_VALUE)
   {
       //
       // FP Change
       // Only close the file if it's a non-pooled file.
       //
       if (!CloseHandle(hFile)) {
           DBGMSG(DBG_WARNING, ("WriteShadowJob CloseHandle failed %d %d\n",
                                 hFile, GetLastError()));
       }
   }

   //
   // Reenter the CS if we were asked to leave it.
   //
   if (bLeaveCS) {

       EnterSplSem();
   }

   //
   // We can be called just before the shadow file was deleted (or sent back to
   // the file pool) and then either recreate the shadow file on the disk or
   // potentially leak a file pool handle. The final DeleteJob when the reference
   // count is zero will see that the shadow file has already been deleted and will
   // not attempt to clean it up. So, we remove the JOB_SHADOW_DELETED bit here to
   // ensure that this will not happen.
   //
   if (bFileCreated) {

        InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_SHADOW_DELETED);
   }

   return bRet;
}

#undef CopyString

#undef AddSize


VOID
ProcessShadowJobs(
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler
    )
{
    WCHAR   wczPrintDirAllSpools[MAX_PATH];
    WCHAR   wczPrinterDirectory[MAX_PATH];
    HANDLE  fFile;
    BOOL    b;
    PWIN32_FIND_DATA pFindFileData;
    PINIJOB pIniJob;
    UINT ErrorMode;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    //
    //  Don't Process Shadow Jobs during Upgrade
    //

    if ( dwUpgradeFlag != 0 || !( pIniSpooler->SpoolerFlags & SPL_PRINT )) {

        return;
    }

    ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if( GetPrinterDirectory(pIniPrinter,
                            FALSE,
                            wczPrintDirAllSpools,
                            (COUNTOF(wczPrintDirAllSpools) - COUNTOF(szAllSpools)),
                            pIniSpooler) &&

        GetPrinterDirectory(pIniPrinter,
                            FALSE,
                            wczPrinterDirectory,
                            COUNTOF(wczPrinterDirectory),
                            pIniSpooler) ) {

        StringCchCat(wczPrintDirAllSpools, COUNTOF(wczPrintDirAllSpools), szAllSpools);

        if ( pFindFileData = AllocSplMem(sizeof(WIN32_FIND_DATA) )) {

            fFile =  FindFirstFile( wczPrintDirAllSpools, pFindFileData );

            if ( fFile != (HANDLE)-1 ) {

                b=TRUE;

                while( b ) {

                    if ( !(pFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        ReadShadowJob(wczPrinterDirectory, pFindFileData, pIniSpooler);
                    }

                    b = FindNextFile(fFile, pFindFileData);
                }

                FindClose( fFile );

            }

            FreeSplMem( pFindFileData );
        }
    }

    SetErrorMode(ErrorMode);
}



#define CheckPointer( strptr )                                        \
    if( strptr ) {                                                    \
        if( (ULONG_PTR)(strptr + wcslen(strptr) + 1) > (ULONG_PTR)pEnd ) {    \
            bRet = FALSE;                                             \
            goto BailOut;                                             \
        }                                                             \
    }

//
// make sure all pointers contain embedded data bounded within the pShadowFile (not passed the end).
//
BOOL
CheckAllPointers(
    PSHADOWFILE_3 pShadowFile,
    DWORD dwSize
    )
{
    LPBYTE pEnd = (LPBYTE)pShadowFile + dwSize;
    BOOL bRet = TRUE;

    try {

        CheckPointer(pShadowFile->pDatatype);
        CheckPointer(pShadowFile->pNotify);
        CheckPointer(pShadowFile->pUser);
        CheckPointer(pShadowFile->pDocument);
        CheckPointer(pShadowFile->pOutputFile);
        CheckPointer(pShadowFile->pPrinterName);
        CheckPointer(pShadowFile->pDriverName);
        CheckPointer(pShadowFile->pPrintProcName);
        CheckPointer(pShadowFile->pParameters);
        CheckPointer(pShadowFile->pMachineName);

        // Now check the rest of the two data structures
        if( (ULONG_PTR)pShadowFile->pSecurityDescriptor + pShadowFile->cbSecurityDescriptor > (ULONG_PTR)pEnd ) {
            bRet = FALSE;
            goto BailOut;
        }

        if( pShadowFile->pDevMode ) {

            bRet = ((ULONG_PTR)pShadowFile->pDevMode < (ULONG_PTR)pEnd) ?
                        BoolFromHResult(SplIsValidDevmodeW((PDEVMODE)pShadowFile->pDevMode,
                                                          (ULONG_PTR)pEnd - (ULONG_PTR)pShadowFile->pDevMode)) :
                        FALSE;
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {
        bRet = FALSE;
    }

BailOut:
    return bRet;
}

#undef CheckPointer


PINIJOB
ReadShadowJob(
    LPWSTR  szDir,
    PWIN32_FIND_DATA pFindFileData,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Reads a *.spl/*.shd file and partially validates the file.

Arguments:

    szDir -- pointer to spool directory string

    pFindFileData -- found file data (spl file)

    pIniSpooler -- spooler the *.spl belongs to

Return Value:

    Allocated pIniJob.

Notes:

    Warning: Changing the format of SHADOWFILE requires modifying the
    data integrity checks performed here!

    If the shadow file structure size is grown, then when reading,
    you must check the old sizes before touching memory.  Current layout is:

    | DWORD | ... | String | DWORD | DWORD | StringData | StringData |
    *--------------------------------------*
                      ^ This is the SHADOWFILE_3 structure.

    If you grow it, then the next field will point to StringData, and
    won't be valid--you can't touch it since you'll corrupt the string.

--*/

{
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HANDLE   hFileSpl = INVALID_HANDLE_VALUE;
    DWORD    BytesRead;
    PSHADOWFILE_3 pShadowFile3 = NULL;
    PSHADOWFILE_3 pShadowFile = NULL;
    PINIJOB  pIniJob;
    DWORD    cb,i;
    WCHAR    szFileName[MAX_PATH];
    LPWSTR    pExt;
    BOOL     rc;
    LPWSTR   pFileSpec;
    DWORD    nFileSizeLow;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if (!BoolFromStatus(StrNCatBuff(szFileName, COUNTOF(szFileName), szDir, L"\\", pFindFileData->cFileName, NULL))) {

        goto Fail;
    }

    hFileSpl = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFileSpl == INVALID_HANDLE_VALUE) {
        DBGMSG(DBG_WARNING, ("ReadShadowJob CreateFile( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }

    CharUpper(szFileName);
    pExt = wcsstr(szFileName, L".SPL");

    if (!pExt)
        goto Fail;

    pExt[2] = L'H';
    pExt[3] = L'D';

    hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DBGMSG(DBG_WARNING, ("ReadShadowJob CreateFile( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }

    nFileSizeLow = GetFileSize(hFile, NULL);

    if (nFileSizeLow == 0xffffffff)
    {
        DBGMSG(DBG_WARNING, ("ReadShadowJob GetFileSize( %ws ) failed: LastError = %d\n",
                             szFileName, GetLastError()));

        goto Fail;
    }


    if ( nFileSizeLow < sizeof( SHADOWFILE ) ||
         !(pShadowFile=AllocSplMem(nFileSizeLow))) {

        goto Fail;
    }

    rc = ReadFile(hFile, pShadowFile, nFileSizeLow, &BytesRead, NULL);

    // If Shadow file is old style, then convert it to new
    if (rc && (BytesRead == nFileSizeLow) &&
        ( pShadowFile->signature == SF_SIGNATURE ||
          pShadowFile->signature == SF_SIGNATURE_2 )) {

        BOOL bStatus;

        if (!(pShadowFile3 = AllocSplMem(nFileSizeLow +
            sizeof(SHADOWFILE_3) - sizeof(SHADOWFILE))) ) {

            goto Fail;
        }

        bStatus = Old2NewShadow((PSHADOWFILE)pShadowFile, pShadowFile3, &BytesRead);
        nFileSizeLow = BytesRead;        // This is used in CheckAllPointers, below
        FreeSplMem(pShadowFile);
        pShadowFile = pShadowFile3;

        if( !bStatus ){
            goto Fail;
        }
    }

    //
    // Initial size of SF_3/SF_3_DOTNET must include pMachineName.
    //
    if (!rc ||
        (pShadowFile->signature != SF_SIGNATURE_3 && pShadowFile->signature != SF_SIGNATURE_3_DOTNET) ||
        (BytesRead != nFileSizeLow) ||
        (BytesRead < pShadowFile->cbSize ) ||
        (BytesRead < sizeof( SHADOWFILE_3 )) ||
        (pShadowFile->Status & (JOB_SPOOLING | JOB_PENDING_DELETION))) {

        DBGMSG(DBG_WARNING, ( "Error reading shadow job:\
                               \n\tReadFile returned %d: Error %d\
                               \n\tsignature = %08x\
                               \n\tBytes read = %d; expected %d\
                               \n\tFile size = %d; expected %d\
                               \n\tStatus = %08x %s\n",
                              rc, ( rc ? 0 : GetLastError() ),
                              pShadowFile->signature,
                              BytesRead, nFileSizeLow,
                              sizeof(*pShadowFile), pShadowFile->Size,
                              pShadowFile->Status,
                              ( (pShadowFile->Status & JOB_SPOOLING) ?
                                "Job is spooling!" : "" ) ) );

        goto Fail;
    }

    if (!CloseHandle(hFile)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }
    hFile = INVALID_HANDLE_VALUE;

    if (!CloseHandle(hFileSpl)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }
    hFileSpl = INVALID_HANDLE_VALUE;

    // Check number of reboots on this file & delete if too many
    if (pShadowFile->dwReboots > 1) {
        DBGMSG(DBG_WARNING, ("Corrupt shadow file %ws\n", szFileName));

        if ( pShadowFile->pDocument && pShadowFile->pDriverName ) {
            SplLogEvent(pIniSpooler,
                        LOG_ERROR,
                        MSG_BAD_JOB,
                        FALSE,
                        pShadowFile->pDocument + (ULONG_PTR)pShadowFile/sizeof(*pShadowFile->pDocument),
                        pShadowFile->pDriverName + (ULONG_PTR)pShadowFile/sizeof(*pShadowFile->pDriverName),
                        NULL);
        }
        goto Fail;
    }

    //
    // If the job is a TS Job, and the registry printer policies DiscardTSJobs
    // key is set, we just discard it.
    //
    if ((pShadowFile->Status & JOB_TS) && (pIniSpooler->dwSpoolerSettings & SPOOLER_DISCARDTSJOBS)) {
        goto Fail;
    }

    if (pIniJob = AllocSplMem(sizeof(INIJOB))) {

        pIniJob->signature = IJ_SIGNATURE;
        pIniJob->Status = pShadowFile->Status & (JOB_PAUSED | JOB_REMOTE | JOB_PRINTED | JOB_COMPLETE );
        pIniJob->JobId     = pShadowFile->JobId;
        pIniJob->Priority  = pShadowFile->Priority;
        pIniJob->Submitted = pShadowFile->Submitted;
        pIniJob->StartTime = pShadowFile->StartTime;
        pIniJob->UntilTime = pShadowFile->UntilTime;
        pIniJob->Size      = pShadowFile->Size;
        pIniJob->dwValidSize = pShadowFile->dwValidSize;
        pIniJob->cPages    = pShadowFile->cPages;
        pIniJob->cbPrinted = 0;
        pIniJob->NextJobId = pShadowFile->NextJobId;
        pIniJob->dwReboots = pShadowFile->dwReboots;

        pIniJob->dwJobNumberOfPagesPerSide = 0;
        pIniJob->dwDrvNumberOfPagesPerSide = 0;
        pIniJob->cLogicalPages             = 0;
        pIniJob->cLogicalPagesPrinted      = 0;

        pIniJob->WaitForWrite = NULL;
        pIniJob->WaitForRead  = NULL;
        pIniJob->hWriteFile   = INVALID_HANDLE_VALUE;

        // Additional fields for SeekPrinter.
        pIniJob->WaitForSeek  = NULL;
        pIniJob->bWaitForEnd  = FALSE;
        pIniJob->bWaitForSeek = FALSE;
        pIniJob->liFileSeekPosn.u.HighPart = 0;
        pIniJob->liFileSeekPosn.u.LowPart  = 0;

        SetPointer(pShadowFile, pDatatype);
        SetPointer(pShadowFile, pNotify);
        SetPointer(pShadowFile, pUser);
        SetPointer(pShadowFile, pDocument);
        SetPointer(pShadowFile, pOutputFile);
        SetPointer(pShadowFile, pPrinterName);
        SetPointer(pShadowFile, pDriverName);
        SetPointer(pShadowFile, pPrintProcName);
        SetPointer(pShadowFile, pParameters);
        SetPointer(pShadowFile, pMachineName);

        if( (pShadowFile->cbSecurityDescriptor > 0) && pShadowFile->pSecurityDescriptor )
            pShadowFile->pSecurityDescriptor = (PSECURITY_DESCRIPTOR)((LPBYTE)pShadowFile +
                                                 (ULONG_PTR)pShadowFile->pSecurityDescriptor);

        if (pShadowFile->pDevMode)
            pShadowFile->pDevMode = (LPDEVMODEW)((LPBYTE)pShadowFile +
                                                 (ULONG_PTR)pShadowFile->pDevMode);


        // check the length of the embedded strings as well as DevMode and Security structs.
        if( !CheckAllPointers( pShadowFile, nFileSizeLow )) {
            DBGMSG( DBG_WARNING, ("CheckAllPointers() failed; bad shadow file %ws\n", pFindFileData->cFileName ));

            FreeSplMem(pIniJob);

            goto Fail;
        }

        //
        //  Discard any jobs which were NT JNL 1.000 since the fonts might not
        //                   be correct

        if ( pShadowFile->pDatatype != NULL ) {
            if (!lstrcmpi( pShadowFile->pDatatype, L"NT JNL 1.000" )) {

                DBGMSG(DBG_WARNING, ("Deleteing job Datatype %ws %ws %ws\n",
                                      pShadowFile->pDatatype,
                                      pFindFileData->cFileName, szFileName));
                FreeSplMem(pIniJob);
                goto Fail;
            }
        }

        pIniJob->pIniDriver = (PINIDRIVER)FindLocalDriver(pIniSpooler, pShadowFile->pDriverName);

        if ((pIniJob->pIniPrinter = FindPrinter(pShadowFile->pPrinterName,pIniSpooler)) &&
             pIniJob->pIniDriver &&
            (pIniJob->pIniPrintProc = FindPrintProc(pShadowFile->pPrintProcName, FindEnvironment(szEnvironment, pIniSpooler)))) {


            // Notice that MaxJobId is really the number of job slots in the pJobIdMap, so
            // the maximum job id we can allow is (MaxJobId - 1).
            if (pIniJob->JobId >= MaxJobId( pIniSpooler->hJobIdMap )) {
                // If the job id is too huge (i.e. from a corrupt file) then we might allocate
                // too much unnecessary memory for the JobIdMap!
                // Notice we need to ask for (JobId+1) number of slots in the map!.
                if( !ReallocJobIdMap( pIniSpooler->hJobIdMap,
                                      pIniJob->JobId + 1 )) {

                    // probably a bad job id, dump the job!
                    DBGMSG( DBG_WARNING, ("Failed to alloc JobIdMap in ShadowFile %ws for JobId %d\n", pFindFileData->cFileName, pIniJob->JobId ));

                    FreeSplMem(pIniJob);

                    goto Fail;
                }
            }
            else {

                if( bBitOn( pIniSpooler->hJobIdMap, pIniJob->JobId )) {

                    // A bad job id from a corrupt shadowfile; dump the job!
                    DBGMSG( DBG_WARNING, ("Duplicate Job Id in ShadowFile %ws for JobId %d\n", pFindFileData->cFileName, pIniJob->JobId ));

                    FreeSplMem(pIniJob);

                    goto Fail;
                }
            }

            SPLASSERT( pIniSpooler->hJobIdMap != NULL );
            vMarkOn( pIniSpooler->hJobIdMap, pIniJob->JobId);

            pIniJob->pIniPrinter->cJobs++;
            pIniJob->pIniPrinter->cTotalJobs++;

            INCDRIVERREF( pIniJob->pIniDriver );

            pIniJob->pIniPrintProc->cRef++;
            pIniJob->pIniPort = NULL;


            if (pShadowFile->pSecurityDescriptor)
            {
                if (pIniJob->pSecurityDescriptor = LocalAlloc(LPTR, pShadowFile->cbSecurityDescriptor))
                {
                    memcpy(pIniJob->pSecurityDescriptor, pShadowFile->pSecurityDescriptor, pShadowFile->cbSecurityDescriptor);

                    if (pShadowFile->signature != SF_SIGNATURE_3_DOTNET && !GrantJobReadPermissionToLocalSystem(&pIniJob->pSecurityDescriptor))
                    {
                        LocalFree(pIniJob->pSecurityDescriptor);

                        pIniJob->pSecurityDescriptor = NULL;

                        goto Fail;
                    }
                }
                else
                {
                   DBGMSG(DBG_WARNING, ("Failed to alloc ini job security descriptor.\n"));
                }
            }

            if (pShadowFile->pDevMode) {

                cb=pShadowFile->pDevMode->dmSize +
                                pShadowFile->pDevMode->dmDriverExtra;
                if (pIniJob->pDevMode=AllocSplMem(cb))
                    memcpy(pIniJob->pDevMode, pShadowFile->pDevMode, cb);
                else
                    DBGMSG(DBG_WARNING, ("Failed to alloc ini job devmode.\n"));
            }

            pIniJob->pNotify      = AllocSplStr( pShadowFile->pNotify);
            pIniJob->pUser        = AllocSplStr( pShadowFile->pUser);
            pIniJob->pDocument    = AllocSplStr( pShadowFile->pDocument);
            pIniJob->pOutputFile  = AllocSplStr( pShadowFile->pOutputFile);
            pIniJob->pDatatype    = AllocSplStr( pShadowFile->pDatatype);
            pIniJob->pParameters  = AllocSplStr( pShadowFile->pParameters);

            if( pShadowFile->pMachineName ){
                pIniJob->pMachineName = AllocSplStr( pShadowFile->pMachineName );
            } else {
                pIniJob->pMachineName = AllocSplStr( pIniSpooler->pMachineName );
            }

            //
            // FP Change
            // Add the files to the File pool if :-
            //     a. We dont want to KeepPrintedJobs for the printer,
            //     b. the printer does not have its own spool directory; or
            //     c. SpoolerSettings do not have filepooling disabled.
            //
            if ( !(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS) &&
                 pIniJob->pIniPrinter->pSpoolDir == NULL &&
                 !(pIniSpooler->dwSpoolerSettings & SPOOLER_NOFILEPOOLING))
            {
                pIniJob->pszSplFileName = AllocSplStr( szFileName );

                if ((pIniJob->pIniPrinter->pIniSpooler->hFilePool != INVALID_HANDLE_VALUE)
                    && pIniJob->pszSplFileName && SUCCEEDED(ConvertFileExt(pIniJob->pszSplFileName, L".SHD", L".SPL")))
                {
                    if (FAILED(GetFileItemHandle(
                                     pIniJob->pIniPrinter->pIniSpooler->hFilePool,
                                     &pIniJob->hFileItem,
                                     pIniJob->pszSplFileName )))
                    {
                        pIniJob->hFileItem = INVALID_HANDLE_VALUE;
                        FreeSplStr(pIniJob->pszSplFileName);
                        pIniJob->pszSplFileName = NULL;
                    }
                }
                else
                {
                    FreeSplStr(pIniJob->pszSplFileName);
                    pIniJob->pszSplFileName = NULL;
                }
            }
            else
            {
                pIniJob->pszSplFileName = NULL;
                pIniJob->hFileItem = INVALID_HANDLE_VALUE;
            }


            pIniJob->pIniNextJob = NULL;
            pIniJob->pStatus = NULL;

            if (pIniJob->pIniPrevJob = pIniJob->pIniPrinter->pIniLastJob)
                pIniJob->pIniPrevJob->pIniNextJob=pIniJob;

            if (!pIniJob->pIniPrinter->pIniFirstJob)
                pIniJob->pIniPrinter->pIniFirstJob = pIniJob;

            pIniJob->pIniPrinter->pIniLastJob=pIniJob;

        } else {

            DBGMSG( DBG_WARNING, ("Failed to find printer %ws\n",pShadowFile->pPrinterName));

            FreeSplMem(pIniJob);

            goto Fail;
        }

    } else {

        DBGMSG(DBG_WARNING, ("Failed to allocate ini job.\n"));
    }

    FreeSplMem( pShadowFile );

    return pIniJob;

Fail:

    if (pShadowFile) {
        FreeSplMem(pShadowFile);
    }

    if (hFile != INVALID_HANDLE_VALUE && !CloseHandle(hFile)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFile, GetLastError()));
    }
    if (hFileSpl != INVALID_HANDLE_VALUE && !CloseHandle(hFileSpl)) {
        DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", hFileSpl, GetLastError()));
    }

    DeleteFile(szFileName);

    pFileSpec = wcsrchr(szFileName, L'\\');

    if (pFileSpec) {

        pFileSpec++;

        StringCchCopy(pFileSpec, COUNTOF(szFileName) - (pFileSpec - szFileName), pFindFileData->cFileName);
    }

    DeleteFile(szFileName);

    return FALSE;
}

VOID
GetDiscardTSJobsSettings(
    PINISPOOLER pIniSpooler
    )
{
    //
    // If the Printer Policy to Discard TS Jobs is set we shall
    // discard the jobs on spooler restart as a security precaution
    // otherwise the normal behaviour is that we keep the jobs.
    // However this by design causes a job to print on the TS port
    // irrespective of the current user or printer.
    //
    DWORD   RegValue  = 0;
    DWORD   RegValueSize = sizeof(RegValue);
    HKEY    RegKey       = NULL;
    DWORD   dwError      = ERROR_SUCCESS;
    DWORD   RegValueType;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szPrintPublishPolicy,
                            0,
                            KEY_READ,
                            &RegKey );

    if (dwError == ERROR_SUCCESS)
    {
        dwError = RegQueryValueEx( RegKey,
                                   szDiscardTSJobs,
                                   NULL,
                                   (LPDWORD) &RegValueType,
                                   (LPBYTE) &RegValue,
                                   &RegValueSize );

        if ( RegValueType == REG_DWORD && dwError == ERROR_SUCCESS && RegValue > 0)
        {
            pIniSpooler->dwSpoolerSettings |= SPOOLER_DISCARDTSJOBS;
        }
    }

    if (RegKey)
    {
        RegCloseKey( RegKey );
    }
}

BOOL
Old2NewShadow(
    PSHADOWFILE   pShadowFile1,
    PSHADOWFILE_3 pShadowFile3,
    DWORD         *pnBytes
    )

/*++

Routine Description:

    Converts an original format *.shd file to a new format (version 2).

Arguments:

    pShadowFile1 -- pointer to version 1 shadow file

    pShadowFile2 -- pointer to version 2 shadow file

    *pnBytes      -- pointer to number of bytes read from version 1 shadow file.  On
                    return, pnBytes contains the number of bytes in the version 2 shadow file.

Return Value:

    None


Author: Steve Wilson (NT)

--*/

{
    DWORD cbOld;
    DWORD cbDiff;

    switch( pShadowFile1->signature ){
    case SF_SIGNATURE:
        cbOld = sizeof( SHADOWFILE );
        cbDiff = sizeof( SHADOWFILE_3 ) - sizeof( SHADOWFILE );
        break;
    case SF_SIGNATURE_2:
        cbOld = sizeof ( SHADOWFILE_2 );
        cbDiff = sizeof( SHADOWFILE_3 ) - sizeof( SHADOWFILE_2 );
        break;
    default:
        return FALSE;
    }

    if( *pnBytes < cbOld ){
        return FALSE;
    }

    //
    // Copy everything except signature.
    //
    MoveMemory((PVOID)(&pShadowFile3->Status),
               (PVOID)(&pShadowFile1->Status),
               cbOld - sizeof( pShadowFile1->signature ));

    //
    // Now update signature and size.
    //
    pShadowFile3->signature = SF_SIGNATURE_3_DOTNET;
    pShadowFile3->cbSize = *pnBytes + cbDiff;

    //
    // Move strings.
    //
    MoveMemory((PVOID)(pShadowFile3 + 1),
               ((PBYTE)pShadowFile1) + cbOld,
               *pnBytes - cbOld );

    pShadowFile3->pNotify += pShadowFile1->pNotify ? cbDiff/sizeof *pShadowFile1->pNotify : 0;
    pShadowFile3->pUser += pShadowFile1->pUser ? cbDiff/sizeof *pShadowFile1->pUser  : 0;
    pShadowFile3->pDocument += pShadowFile1->pDocument ? cbDiff/sizeof *pShadowFile3->pDocument : 0;
    pShadowFile3->pOutputFile += pShadowFile1->pOutputFile ? cbDiff/sizeof *pShadowFile3->pOutputFile : 0;
    pShadowFile3->pPrinterName += pShadowFile1->pPrinterName ? cbDiff/sizeof *pShadowFile3->pPrinterName : 0;
    pShadowFile3->pDriverName += pShadowFile1->pDriverName ? cbDiff/sizeof *pShadowFile3->pDriverName : 0;
    pShadowFile3->pPrintProcName += pShadowFile1->pPrintProcName ? cbDiff/sizeof *pShadowFile3->pPrintProcName : 0;
    pShadowFile3->pDatatype += pShadowFile1->pDatatype ? cbDiff/sizeof *pShadowFile3->pDatatype : 0;
    pShadowFile3->pParameters += pShadowFile1->pParameters ? cbDiff/sizeof *pShadowFile3->pParameters : 0;

    pShadowFile3->pDevMode = (PDEVMODE) (pShadowFile1->pDevMode ?
                             (ULONG_PTR) pShadowFile1->pDevMode + cbDiff : 0);

    pShadowFile3->pSecurityDescriptor = (PSECURITY_DESCRIPTOR) (pShadowFile1->pSecurityDescriptor ?
                                        (ULONG_PTR) pShadowFile1->pSecurityDescriptor + cbDiff : 0);

    pShadowFile3->Version = SF_VERSION_3;

    //
    // The first shadow file didn't have dwReboots.
    //
    if( pShadowFile1->signature == SF_SIGNATURE ){
        pShadowFile3->dwReboots = 0;
    }

    pShadowFile3->pMachineName = NULL;

    *pnBytes += cbDiff;

    return TRUE;
}


PINIVERSION
GetVersionDrivers(
    HKEY hDriversKey,
    LPWSTR szVersionName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment
    )
{
    HKEY hVersionKey;
    WCHAR szDirectoryValue[MAX_PATH];
    PINIDRIVER pIniDriver;
    DWORD cMajorVersion, cMinorVersion;
    DWORD cbData;
    DWORD Type;
    PINIVERSION pIniVersion = NULL;

    if (SplRegOpenKey(hDriversKey, szVersionName, KEY_READ, &hVersionKey, pIniSpooler) != ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("GetVersionDrivers SplRegOpenKey on "TSTR" failed\n", szVersionName));
        return NULL;
    }

    cbData = sizeof(szDirectoryValue);

    if (SplRegQueryValue(hVersionKey, szDirectory, &Type, (LPBYTE)szDirectoryValue, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for directory in version structure\n"));
        goto Done;
    }

    cbData = sizeof(DWORD);

    if (SplRegQueryValue(hVersionKey, szMajorVersion, &Type, (LPBYTE)&cMajorVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for major version in version structure\n"));
        goto Done;
    }

    cbData = sizeof(DWORD);

    if (SplRegQueryValue(hVersionKey, szMinorVersion, &Type, (LPBYTE)&cMinorVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
    {
        DBGMSG(DBG_TRACE, ("Couldn't query for minor version in version structure\n"));
        goto Done;
    }

    DBGMSG(DBG_TRACE, ("Got all information to build the version entry\n"));

    //
    // Now build the version node structure.
    //
    pIniVersion = AllocSplMem(sizeof(INIVERSION));

    if( pIniVersion ){

        pIniVersion->signature     = IV_SIGNATURE;
        pIniVersion->pName         = AllocSplStr(szVersionName);
        pIniVersion->szDirectory   = AllocSplStr(szDirectoryValue);
        pIniVersion->cMajorVersion = cMajorVersion;
        pIniVersion->cMinorVersion = cMinorVersion;
        pIniVersion->pDrvRefCnt    = NULL;

        if (!pIniVersion->pName || !pIniVersion->szDirectory) {
            FreeIniVersion(pIniVersion);
            pIniVersion = NULL;
        } else {

            pIniDriver = GetDriverList(hVersionKey,
                                       pIniSpooler,
                                       pIniEnvironment,
                                       pIniVersion);

            pIniVersion->pIniDriver  = pIniDriver;

            while (pIniDriver) {
                if (!UpdateDriverFileRefCnt(pIniEnvironment,pIniVersion,pIniDriver,NULL,0,TRUE)) {
                    FreeIniVersion(pIniVersion);
                    pIniVersion = NULL;
                    break;
                }
                pIniDriver = pIniDriver->pNext;
            }
        }
    }


Done:
    SplRegCloseKey(hVersionKey, pIniSpooler);
    return pIniVersion;
}

/*++

Routine Name:

    FreeIniDriver

Routine Description:

    This handles the memory in an inidriver after first decrementing the driver
    ref-count correctly.

Arguments:

    pIniEnvironment     -   The environment of the driver.
    pIniVersion         -   The version of the driver.
    pIniDriver          -   The driver to delete.


Return Value:

    None.

--*/
VOID
FreeIniDriver(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver
    )
{
    if (pIniEnvironment && pIniVersion && pIniDriver)
    {
        //
        // This is to reverse the ref-count for when the spooler is first created.
        //
        UpdateDriverFileRefCnt(pIniEnvironment, pIniVersion, pIniDriver, NULL, 0, FALSE);

        //
        // The monitors will be deleted shortly. So we don't need to worry about
        // the language monitors.
        //
        FreeStructurePointers((LPBYTE) pIniDriver, NULL, IniDriverOffsets);
        FreeSplMem(pIniDriver);
    }
}

/*++

Routine Name:

    FreeIniVersion

Routine Description:

    This frees all the memory in an ini-version without handling either the
    drivers or the driver ref-counts in it.

Arguments:

    pIniVersion         -   The version to delete.

Return Value:

    None.

--*/
VOID
FreeIniVersion(
    IN      PINIVERSION pIniVersion
    )
{
    PDRVREFCNT pdrc,pdrctemp;

    FreeSplStr( pIniVersion->pName );
    FreeSplStr( pIniVersion->szDirectory );

    pdrc = pIniVersion->pDrvRefCnt;

    while (pdrc) {
       FreeSplStr(pdrc->szDrvFileName);
       pdrctemp = pdrc->pNext;
       FreeSplMem(pdrc);
       pdrc = pdrctemp;
    }

    FreeSplMem( pIniVersion );
}

/*++

Routine Name:

    DeleteIniVersion

Routine Description:

    This runs all of the drivers in an iniVersion and then calls FreeIniVersion
    to free the contents of the iniversion.

Arguments:

    pIniEnvironment     -   The environment used for handling driver ref-counts.
    pIniVersion         -   The version to delete.

Return Value:

    None.

--*/
VOID
DeleteIniVersion(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion
    )
{
    if (pIniVersion && pIniEnvironment)
    {
        PINIDRIVER  pIniDriver      = NULL;
        PINIDRIVER  pNextIniDriver  = NULL;

        for(pIniDriver = pIniVersion->pIniDriver; pIniDriver; pIniDriver = pNextIniDriver)
        {
            pNextIniDriver = pIniDriver->pNext;

            FreeIniDriver(pIniEnvironment, pIniVersion, pIniDriver);
        }

        FreeIniVersion(pIniVersion);
    }
}

/*++

Routine Name:

    FreeIniEnvironment

Routine Description:

    This runs all of the ini-versions in an environvironment
    and then deletes the environment.

Arguments:

    pIniEnvironment     -   The environment to free.

Return Value:

    None.

--*/
VOID
FreeIniEnvironment(
    IN      PINIENVIRONMENT     pIniEnvironment
    )
{
    if (pIniEnvironment)
    {
        PINIVERSION pIniVersion     = NULL;
        PINIVERSION pNextIniVersion = NULL;

        for(pIniVersion = pIniEnvironment->pIniVersion; pIniVersion; pIniVersion = pNextIniVersion)
        {
            pNextIniVersion = pIniVersion->pNext;

            DeleteIniVersion(pIniEnvironment, pIniVersion);
        }

        FreeIniPrintProc(pIniEnvironment->pIniPrintProc);
        FreeStructurePointers((LPBYTE)pIniEnvironment, NULL, IniEnvironmentOffsets);
        FreeSplMem(pIniEnvironment);
    }
}

/*++

Routine Name:

    FreeIniPrintProc

Routine Description:

    This deletes all of the print processor fields.

Arguments:

    pIniPrintProc   -   The print processor to delete.

Return Value:

    None.

--*/
VOID
FreeIniPrintProc(
    IN      PINIPRINTPROC       pIniPrintProc
    )
{
    if (pIniPrintProc)
    {
        FreeLibrary(pIniPrintProc->hLibrary);
        DeleteCriticalSection(&pIniPrintProc->CriticalSection);
        FreeStructurePointers((LPBYTE)pIniPrintProc, NULL, IniPrintProcOffsets);
        FreeSplMem(pIniPrintProc);
    }
}

PINIDRIVER
GetDriverList(
    HKEY hVersionKey,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
    )
{
    PINIDRIVER pIniDriverList = NULL;
    DWORD      cDrivers = 0;
    PINIDRIVER pIniDriver;
    WCHAR      DriverName[MAX_PATH];
    DWORD      cchBuffer =0;

    pIniDriverList = NULL;

    cchBuffer = COUNTOF(DriverName);

    while (SplRegEnumKey(hVersionKey, cDrivers++, DriverName, &cchBuffer, NULL, pIniSpooler) == ERROR_SUCCESS)
    {
        cchBuffer = COUNTOF(DriverName);

        DBGMSG(DBG_TRACE, ("Found a driver - "TSTR"\n", DriverName));

        pIniDriver = GetDriver(hVersionKey, DriverName, pIniSpooler, pIniEnvironment, pIniVersion);

        if (pIniDriver != NULL)
        {
            pIniDriver->pNext = pIniDriverList;
            pIniDriverList    = pIniDriver;
        }

        //
        // On a cluster, a driver may have changed while the cluster spooler
        // was hosted by another node. Here we check if we need to update or
        // add a new driver
        //
        if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
            ClusterCheckDriverChanged(hVersionKey,
                                      DriverName,
                                      pIniEnvironment->pName,
                                      pIniVersion->pName,
                                      pIniSpooler))
        {
            DWORD dwError;

            //
            // Add or update the driver.
            //
            LeaveSplSem();

            if ((dwError = ClusterAddOrUpdateDriverFromClusterDisk(hVersionKey,
                                                                   DriverName,
                                                                   pIniEnvironment->pName,
                                                                   pIniEnvironment->pDirectory,
                                                                   pIniSpooler)) != ERROR_SUCCESS)

            {
                WCHAR szError[20];

                DBGMSG(DBG_CLUSTER, ("GetDriverList failed to add/update driver "TSTR". Win32 error %u\n",
                                     DriverName, dwError));

                StringCchPrintf(szError, COUNTOF(szError), L"%u", dwError);

                SplLogEvent(pIniSpooler,
                            LOG_ERROR,
                            MSG_CANT_ADD_UPDATE_CLUSTER_DRIVER,
                            FALSE,
                            DriverName,
                            pIniSpooler->pMachineName,
                            szError,
                            NULL);
            }

            EnterSplSem();
        }
    }

    return pIniDriverList;
}


PINIDRIVER
GetDriver(
    HKEY hVersionKey,
    LPWSTR DriverName,
    PINISPOOLER pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion
)
{
    HKEY        hDriverKey = NULL;
    DWORD       Type;
    WCHAR       szData[MAX_PATH];
    WCHAR       szTempDir[MAX_PATH];
    DWORD       cbData;
    DWORD       Version;
    DWORD       DriverAttributes;
    LPWSTR      pConfigFile, pDataFile, pDriver;
    LPWSTR      pHelpFile, pMonitorName, pDefaultDataType, pDependentFiles, pTemp;
    LPWSTR      pDriverName, pszzPreviousNames;
    LPWSTR      pszMfgName, pszOEMUrl, pszHardwareID, pszProvider;
    FILETIME    DriverDate;
    DWORDLONG   DriverVersion;
    PINIDRIVER  pIniDriver = NULL;
    DWORD       cb, cLen, cchDependentFiles = 0, cchPreviousNames = 0;
    DWORD       dwTempDir, dwLastError = ERROR_SUCCESS;

    pDriverName = pConfigFile = pDataFile = pDriver = pHelpFile = pTemp = NULL;
    pMonitorName = pDefaultDataType = pDependentFiles = pszzPreviousNames = NULL;
    pszMfgName = pszOEMUrl = pszHardwareID =  pszProvider = NULL;

    if ((dwLastError = SplRegOpenKey(hVersionKey, DriverName, KEY_READ, &hDriverKey, pIniSpooler)) != ERROR_SUCCESS) {
        goto Fail;
    }
    else {

        if ( !(pDriverName=AllocSplStr(DriverName)) ) {
            dwLastError = GetLastError();
            goto Fail;
        }

        RegGetString( hDriverKey, szConfigurationKey, &pConfigFile, &cLen, &dwLastError, TRUE, pIniSpooler );
        if (!pConfigFile) {
            goto Fail;
        }

        RegGetString( hDriverKey, szDataFileKey, &pDataFile, &cLen, &dwLastError, TRUE, pIniSpooler );
        if ( !pDataFile ) {
            goto Fail;
        }

        RegGetString( hDriverKey, szDriverFile, &pDriver, &cLen, &dwLastError, TRUE, pIniSpooler );
        if ( !pDriver ) {
            goto Fail;
        }

        RegGetString( hDriverKey, szHelpFile,  &pHelpFile, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szMonitor, &pMonitorName, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szDatatype, &pDefaultDataType, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetMultiSzString( hDriverKey, szDependentFiles, &pDependentFiles, &cchDependentFiles, &dwLastError, FALSE, pIniSpooler );

        RegGetMultiSzString( hDriverKey, szPreviousNames, &pszzPreviousNames, &cchPreviousNames, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szMfgName, &pszMfgName, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szOEMUrl, &pszOEMUrl, &cLen, &dwLastError, FALSE, pIniSpooler );

        RegGetString( hDriverKey, szHardwareID, &pszHardwareID, &cLen, &dwLastError, TRUE, pIniSpooler );

        RegGetString( hDriverKey, szProvider, &pszProvider, &cLen, &dwLastError, TRUE, pIniSpooler );

        cbData = sizeof(DriverDate);
        if (SplRegQueryValue(hDriverKey, szDriverDate, NULL, (LPBYTE)&DriverDate, &cbData, pIniSpooler)!=ERROR_SUCCESS)
        {
            //
            // don't leave the data uninitialized
            //
            DriverDate.dwLowDateTime = DriverDate.dwHighDateTime = 0;
        }

        cbData = sizeof(DriverVersion);
        if (SplRegQueryValue(hDriverKey, szLongVersion, NULL, (LPBYTE)&DriverVersion, &cbData, pIniSpooler)!=ERROR_SUCCESS)
        {
            //
            // don't leave the data uninitialized
            //
            DriverVersion = 0;
        }

        // Retrieve the version number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szDriverAttributes, &Type, (LPBYTE)&DriverAttributes, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             DriverAttributes = 0;
        }

        // Retrieve the version number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szDriverVersion, &Type, (LPBYTE)&Version, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             Version = 0;
        }

        // Retrieve the TempDir number
        cbData = sizeof(DWORD);
        if (SplRegQueryValue(hDriverKey, szTempDir, &Type, (LPBYTE)&dwTempDir, &cbData, pIniSpooler) != ERROR_SUCCESS)
        {
             dwTempDir = 0;
        }

        // After REBOOT temp directories are deleted. So check for the presence of the
        // directory on spooler startup.
        if (dwTempDir && pIniEnvironment && pIniVersion)
        {
           StringCchPrintf(szTempDir, COUNTOF(szTempDir), L"%d", dwTempDir);

           if(StrNCatBuff(szData,
                         COUNTOF(szData),
                         pIniSpooler->pDir,
                         L"\\drivers\\",
                         pIniEnvironment->pDirectory,
                         L"\\",
                         pIniVersion->szDirectory,
                         L"\\",
                         szTempDir,
                         NULL) == ERROR_SUCCESS)
           {
               if (!DirectoryExists(szData))
               {
                   // Files must have been moved in Reboot, reset dwTempDir to 0
                   dwTempDir = 0;
               }
           }
        }

        SplRegCloseKey(hDriverKey, pIniSpooler);
        hDriverKey = NULL;
    }

    //
    // Win95 driver needs every file as a dependent file for point and print.
    // For others we eliminate duplicates
    //
    if ( pIniEnvironment && _wcsicmp(pIniEnvironment->pName, szWin95Environment) ) {

        pTemp = pDependentFiles;
        pDependentFiles = NULL;

        if ( !BuildTrueDependentFileField(pDriver,
                                          pDataFile,
                                          pConfigFile,
                                          pHelpFile,
                                          pTemp,
                                          &pDependentFiles) )
            goto Fail;

        FreeSplMem(pTemp);
        for ( pTemp = pDependentFiles ; pTemp && *pTemp ;
              pTemp += wcslen(pTemp) + 1 )
        ;

        if ( pTemp )
            cchDependentFiles = (DWORD) (pTemp - pDependentFiles + 1);
        else
            cchDependentFiles = 0;

        pTemp = NULL;
    }

    cb = sizeof( INIDRIVER );

    if ( pIniDriver = AllocSplMem( cb )) {

        pIniDriver->signature               = ID_SIGNATURE;
        pIniDriver->pName                   = pDriverName;
        pIniDriver->pDriverFile             = pDriver;
        pIniDriver->pDataFile               = pDataFile;
        pIniDriver->pConfigFile             = pConfigFile;
        pIniDriver->cVersion                = Version;
        pIniDriver->pHelpFile               = pHelpFile;
        pIniDriver->pMonitorName            = pMonitorName;
        pIniDriver->pDefaultDataType        = pDefaultDataType;
        pIniDriver->pDependentFiles         = pDependentFiles;
        pIniDriver->cchDependentFiles       = cchDependentFiles;
        pIniDriver->pszzPreviousNames       = pszzPreviousNames;
        pIniDriver->cchPreviousNames        = cchPreviousNames;
        pIniDriver->dwTempDir               = dwTempDir;
        pIniDriver->pszMfgName              = pszMfgName;
        pIniDriver->pszOEMUrl               = pszOEMUrl;
        pIniDriver->pszHardwareID           = pszHardwareID;
        pIniDriver->pszProvider             = pszProvider;
        pIniDriver->dwlDriverVersion        = DriverVersion;
        pIniDriver->ftDriverDate            = DriverDate;
        pIniDriver->dwDriverAttributes      = DriverAttributes;

        DBGMSG( DBG_TRACE, ("Data for driver %ws created:\
                             \n\tpDriverFile:\t%ws\
                             \n\tpDataFile:\t%ws\
                             \n\tpConfigFile:\t%ws\n\n",
                             pDriverName, pDriver, pDataFile, pConfigFile));

        if ( pIniDriver->pMonitorName && *pIniDriver->pMonitorName ) {

            //
            // Don't we add ref the monitor here?
            //
            pIniDriver->pIniLangMonitor = FindMonitor(pIniDriver->pMonitorName, pIniSpooler);

            //
            // Cluster spoolers do not have keep their own lists of language monitors.
            // This is because most language monitors are not cluster aware. Therefore,
            // cluster spooler share language monitors with the local spooler.
            //
            if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
                !pIniDriver->pIniLangMonitor                 &&
                pLocalIniSpooler)
            {
                //
                // We try to find the langauge monitor off the local spooler
                //
                pIniDriver->pIniLangMonitor = FindMonitor(pIniDriver->pMonitorName, pLocalIniSpooler);
            }

            if (!pIniDriver->pIniLangMonitor)
            {
                DBGMSG(DBG_TRACE, ("Can't find print monitor %ws\n", pIniDriver->pMonitorName));
            }

        }

        return pIniDriver;
    }


Fail:

        FreeSplStr( pDriverName );
        FreeSplStr( pConfigFile );
        FreeSplStr( pDataFile );
        FreeSplStr( pHelpFile );
        FreeSplStr( pMonitorName );
        FreeSplStr( pDefaultDataType );
        FreeSplStr( pDependentFiles );
        FreeSplStr( pszzPreviousNames );
        FreeSplStr( pDriver );
        FreeSplStr( pTemp);
        FreeSplStr( pszMfgName);
        FreeSplStr( pszOEMUrl);
        FreeSplStr( pszProvider);
        FreeSplStr( pszHardwareID);

        if( hDriverKey ) {
            SplRegCloseKey(hDriverKey, pIniSpooler);
        }

        SetLastError( dwLastError );
        return NULL;
}

PINIDRIVER
FindLocalDriver(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz
)
{
    PINIVERSION pIniVersion;

    if ( !pz || !*pz ) {
        return NULL;
    }

    //
    // During Upgrade we load any driver so we have a valid printer, which might not be able to boot.
    //
    return FindCompatibleDriver(GetLocalArchEnv(pIniSpooler),
                                &pIniVersion,
                                pz,
                                dwMajorVersion,
                                dwUpgradeFlag);
}


BOOL
FindLocalDriverAndVersion(
    PINISPOOLER pIniSpooler,
    LPWSTR      pz,
    PINIDRIVER  *ppIniDriver,
    PINIVERSION *ppIniVersion
)
{
    if ( !pz || !*pz || !ppIniDriver || !ppIniVersion) {
        return FALSE;
    }

    //
    // During Upgrade we load any driver so we have a valid printer, which might not be able to boot.
    //
    *ppIniDriver = FindCompatibleDriver( GetLocalArchEnv(pIniSpooler),
                                         ppIniVersion,
                                         pz,
                                         dwMajorVersion,
                                         dwUpgradeFlag );

    if ( !*ppIniDriver || !*ppIniVersion ) {

        return FALSE;
    }

    return TRUE;
}

#if DBG
VOID
InitializeDebug(
    PINISPOOLER pIniSpooler
)
{
    DWORD   Status;
    HKEY    hKey = pIniSpooler->hckRoot;
    DWORD   cbData;
    INT     TimeOut = 60;

    cbData = sizeof(DWORD);

    Status = SplRegQueryValue( hKey,
                               szDebugFlags,
                               NULL,
                               (LPBYTE)&MODULE_DEBUG,
                               &cbData,
                               pIniSpooler );

    // Wait until someone turns off the Pause Flag

    if ( Status != NO_ERROR )
        return;

    while ( MODULE_DEBUG & DBG_PAUSE ) {
        Sleep(1*1000);
        if ( TimeOut-- == 0)
            break;
    }

    DBGMSG(DBG_TRACE, ("DebugFlags %x\n", MODULE_DEBUG));
}
#endif



VOID
GetPrintSystemVersion(
    PINISPOOLER pIniSpooler
    )
{
    DWORD Status;
    HKEY hKey;
    DWORD cbData;

    hKey = pIniSpooler->hckRoot;

    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, szMinorVersion, NULL, NULL,
                                           (LPBYTE)&dwMinorVersion, &cbData);
    DBGMSG(DBG_TRACE, ("This Minor Version - %d\n", dwMinorVersion));



    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintWaitTimeout", NULL, NULL,
                                      (LPBYTE)&dwFastPrintWaitTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintWaitTimeout - %d\n", dwFastPrintWaitTimeout));



    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintThrottleTimeout", NULL, NULL,
                                  (LPBYTE)&dwFastPrintThrottleTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintThrottleTimeout - %d\n", dwFastPrintThrottleTimeout));



    // If the values look invalid use Defaults

    if (( dwFastPrintThrottleTimeout == 0) ||
        ( dwFastPrintWaitTimeout < dwFastPrintThrottleTimeout)) {

        DBGMSG( DBG_WARNING, ("Bad timeout values FastPrintThrottleTimeout %d FastPrintWaitTimeout %d using defaults\n",
                           dwFastPrintThrottleTimeout, dwFastPrintWaitTimeout));

        dwFastPrintThrottleTimeout = FASTPRINT_THROTTLE_TIMEOUT;
        dwFastPrintWaitTimeout = FASTPRINT_WAIT_TIMEOUT;

    }

    // Calculate a reasonable Threshold based on the two timeouts

    dwFastPrintSlowDownThreshold = dwFastPrintWaitTimeout / dwFastPrintThrottleTimeout;


    // FastPrintSlowDownThreshold
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"FastPrintSlowDownThreshold", NULL, NULL,
                                (LPBYTE)&dwFastPrintSlowDownThreshold, &cbData);
    DBGMSG(DBG_TRACE, ("dwFastPrintSlowDownThreshold - %d\n", dwFastPrintSlowDownThreshold));

    // PortThreadPriority
    cbData = sizeof dwPortThreadPriority;
    Status = RegQueryValueEx(hKey, SPLREG_PORT_THREAD_PRIORITY, NULL, NULL,
                             (LPBYTE)&dwPortThreadPriority, &cbData);

    if (Status != ERROR_SUCCESS ||
       (dwPortThreadPriority != THREAD_PRIORITY_LOWEST          &&
        dwPortThreadPriority != THREAD_PRIORITY_BELOW_NORMAL    &&
        dwPortThreadPriority != THREAD_PRIORITY_NORMAL          &&
        dwPortThreadPriority != THREAD_PRIORITY_ABOVE_NORMAL    &&
        dwPortThreadPriority != THREAD_PRIORITY_HIGHEST)) {

        dwPortThreadPriority = DEFAULT_PORT_THREAD_PRIORITY;

        SetPrinterDataServer(   pIniSpooler,
                                SPLREG_PORT_THREAD_PRIORITY,
                                REG_DWORD,
                                (LPBYTE) &dwPortThreadPriority,
                                sizeof dwPortThreadPriority
                            );
    }
    DBGMSG(DBG_TRACE, ("dwPortThreadPriority - %d\n", dwPortThreadPriority));


    // SchedulerThreadPriority
    cbData = sizeof dwSchedulerThreadPriority;
    Status = RegQueryValueEx(hKey, SPLREG_SCHEDULER_THREAD_PRIORITY, NULL, NULL,
                                   (LPBYTE)&dwSchedulerThreadPriority, &cbData);

    if (Status != ERROR_SUCCESS ||
       (dwSchedulerThreadPriority != THREAD_PRIORITY_LOWEST          &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_BELOW_NORMAL    &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_NORMAL          &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_ABOVE_NORMAL    &&
        dwSchedulerThreadPriority != THREAD_PRIORITY_HIGHEST)) {

        dwSchedulerThreadPriority = DEFAULT_SCHEDULER_THREAD_PRIORITY;

        SetPrinterDataServer(   pIniSpooler,
                                SPLREG_SCHEDULER_THREAD_PRIORITY,
                                REG_DWORD,
                                (LPBYTE) &dwSchedulerThreadPriority,
                                sizeof dwSchedulerThreadPriority
                            );
    }
    DBGMSG(DBG_TRACE, ("dwSchedulerThreadPriority - %d\n", dwSchedulerThreadPriority));

    // WritePrinterSleepTime
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"WritePrinterSleepTime", NULL, NULL,
                    (LPBYTE)&dwWritePrinterSleepTime, &cbData);
    DBGMSG(DBG_TRACE, ("dwWritePrinterSleepTime - %d\n", dwWritePrinterSleepTime));

    // ServerThreadPriority
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"ServerThreadPriority", NULL, NULL,
                    (LPBYTE)&dwServerThreadPriority, &cbData);
    DBGMSG(DBG_TRACE, ("dwServerThreadPriority - %d\n", dwServerThreadPriority));

    // ServerThreadTimeout
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"ServerThreadTimeout", NULL, NULL,
                    (LPBYTE)&ServerThreadTimeout, &cbData);
    DBGMSG(DBG_TRACE, ("ServerThreadTimeout - %d\n", ServerThreadTimeout));


    // EnableBroadcastSpoolerStatus

    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"EnableBroadcastSpoolerStatus", NULL, NULL,
                    (LPBYTE)&dwEnableBroadcastSpoolerStatus, &cbData);
    DBGMSG(DBG_TRACE, ("EnableBroadcastSpoolerStatus - %d\n",
                       dwEnableBroadcastSpoolerStatus ));

    // NetPrinterDecayPeriod
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"NetPrinterDecayPeriod", NULL, NULL,
                    (LPBYTE)&NetPrinterDecayPeriod, &cbData);
    DBGMSG(DBG_TRACE, ("NetPrinterDecayPeriod - %d\n", NetPrinterDecayPeriod));


    // RefreshTimesPerDecayPeriod
    cbData = sizeof(DWORD);
    RegQueryValueEx(hKey, L"RefreshTimesPerDecayPeriod", NULL, NULL,
                    (LPBYTE)&RefreshTimesPerDecayPeriod, &cbData);
    DBGMSG(DBG_TRACE, ("RefreshTimesPerDecayPeriod - %d\n", RefreshTimesPerDecayPeriod));

    if ( RefreshTimesPerDecayPeriod == 0 ) {

        RefreshTimesPerDecayPeriod = DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD;
    }

    // BrowsePrintWorkstations
    cbData = sizeof( BrowsePrintWorkstations );
    RegQueryValueEx( hKey, L"BrowsePrintWorkstations", NULL, NULL, (LPBYTE)&BrowsePrintWorkstations, &cbData );

    DBGMSG( DBG_TRACE, ("BrowsePrintWorkstations - %d\n", BrowsePrintWorkstations ));
}

/*++

Routine Name:

    AllowFaxSharing

Routine Description:

    This routine looks at the sku to determine whether we should allowing sharing
    out and printing to a fax driver.

    We don't allow sharing the fax printer on Personal & Professional.
    We also don't allow sharing of the fax printer on a Web Blade.

Arguments:

    None.

Return Value:

    TRUE - We can share out the fax driver.

--*/
BOOL
AllowFaxSharing(
    VOID
    )
{
    BOOL  bAllowFaxSharing = TRUE;

    DWORDLONG dwlConditionMask = 0;
    OSVERSIONINFOEX osvi = { 0 };

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    osvi.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    //
    // We allow sharing if it isn't WORKSTATION or PRO.
    //
    bAllowFaxSharing = !VerifyVersionInfo(&osvi, VER_PRODUCT_TYPE, dwlConditionMask);

    if (bAllowFaxSharing)
    {
        ZeroMemory(&osvi, sizeof(osvi));

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        osvi.wSuiteMask = VER_SUITE_BLADE;

        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        //
        // We allow sharing if it isn't a web blade.
        //
        bAllowFaxSharing = !VerifyVersionInfo(&osvi, VER_SUITENAME, dwlConditionMask);
    }

    return bAllowFaxSharing;
}

VOID
InitializeSpoolerSettings(
    PINISPOOLER pIniSpooler
    )
{
    HKEY hKey;
    HKEY hKeyProvider;
    DWORD cbData;
    DWORD dwLastError;
    DWORD Status;
    DWORD CacheMasqPrinters;

    DWORDLONG dwlConditionMask = 0;
    OSVERSIONINFOEX osvi;

    hKey = pIniSpooler->hckRoot;

    //
    // BeepEnabled
    //
    cbData = sizeof pIniSpooler->dwBeepEnabled;
    Status = SplRegQueryValue(hKey,
                              SPLREG_BEEP_ENABLED,
                              NULL,
                              (LPBYTE)&pIniSpooler->dwBeepEnabled,
                              &cbData,
                              pIniSpooler);

    if (Status!=ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("BeepEnabled - SplRegQueryValue failed with error %u\n", Status));
    }

    pIniSpooler->dwBeepEnabled = !!pIniSpooler->dwBeepEnabled;

    SetPrinterDataServer(pIniSpooler,
                         SPLREG_BEEP_ENABLED,
                         REG_DWORD,
                         (LPBYTE) &pIniSpooler->dwBeepEnabled,
                         sizeof pIniSpooler->dwBeepEnabled);

    if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

        //
        // Restart job time.
        //
        cbData = sizeof( pIniSpooler->dwJobCompletionTimeout );
        Status = SplRegQueryValue( hKey,
                                   L"JobCompletionTimeout",
                                   NULL,
                                   (LPBYTE)&pIniSpooler->dwJobCompletionTimeout,
                                   &cbData,
                                   pIniSpooler );

        if( Status != ERROR_SUCCESS ){
            pIniSpooler->dwJobCompletionTimeout = DEFAULT_JOB_COMPLETION_TIMEOUT;
        }

        DBGMSG( DBG_TRACE, ("JobCompletionTimeout - %d\n", pIniSpooler->dwJobCompletionTimeout ));
    }

    //
    // Retrieve whether we want to cache masq printer settings, default is FALSE.
    //
    cbData = sizeof(CacheMasqPrinters);

    Status = SplRegQueryValue(hKey,
                              gszCacheMasqPrinters,
                              NULL,
                              (BYTE *)&CacheMasqPrinters,
                              &cbData,
                              pIniSpooler);

    //
    // We only set the bit for caching masq printers if CacbeMasqPrinters is
    // non-NULL.
    //
    if (Status == ERROR_SUCCESS && CacheMasqPrinters != 0) {

        pIniSpooler->dwSpoolerSettings |= SPOOLER_CACHEMASQPRINTERS;
    }

    //
    //  Some Folks like the NT FAX Service Don't want people to be able
    //  to remotely print with specific printer drivers.
    //
    if (!AllowFaxSharing()) {

        pIniSpooler->pNoRemotePrintDrivers = AllocSplStr(szNTFaxDriver);
        pIniSpooler->cchNoRemotePrintDrivers = wcslen(szNTFaxDriver) + 1;
        gbRemoteFax = FALSE;
    }

    //
    // If this is embedded NT, then allow masq printers to get non-RAW
    // jobs.  This is for Xerox.
    //
    dwlConditionMask = 0;
    ZeroMemory(&osvi, sizeof(osvi));

    osvi.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    if (VerifyVersionInfo( &osvi,
                           VER_SUITENAME,
                           dwlConditionMask)) {

        pIniSpooler->SpoolerFlags |= SPL_NON_RAW_TO_MASQ_PRINTERS;
    }

    Status = SplRegCreateKey( pIniSpooler->hckRoot,
                              pIniSpooler->pszRegistryProviders,
                              0,
                              KEY_READ,
                              NULL,
                              &hKeyProvider,
                              NULL,
                              pIniSpooler );

    if( Status == NO_ERROR ){

        DWORD Flags;

        // NonRawToMasqPrinters

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NON_RAW_TO_MASQ_PRINTERS,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            if (Flags) {
                pIniSpooler->SpoolerFlags |= SPL_NON_RAW_TO_MASQ_PRINTERS;
            }
        }

        // EventLog

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_EVENT_LOG,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->dwEventLogging = Flags;

        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_EVENT_LOG,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->dwEventLogging,
                                           sizeof( pIniSpooler->dwEventLogging ));
        }

        // NetPopup

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NET_POPUP,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableNetPopups = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_NET_POPUP,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableNetPopups,
                                               sizeof( pIniSpooler->bEnableNetPopups ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_NET_POPUP,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableNetPopups,
                                           sizeof( pIniSpooler->bEnableNetPopups ));
        }

        // NetPopupToComputer

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_NET_POPUP_TO_COMPUTER,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableNetPopupToComputer = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_NET_POPUP_TO_COMPUTER,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableNetPopupToComputer,
                                               sizeof( pIniSpooler->bEnableNetPopupToComputer ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_NET_POPUP_TO_COMPUTER,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableNetPopupToComputer,
                                           sizeof( pIniSpooler->bEnableNetPopupToComputer ));
        }

        // RetryPopup

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RETRY_POPUP,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bEnableRetryPopups = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_RETRY_POPUP,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bEnableRetryPopups,
                                               sizeof( pIniSpooler->bEnableRetryPopups ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RETRY_POPUP,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bEnableRetryPopups,
                                           sizeof( pIniSpooler->bEnableRetryPopups ));
        }

        // RestartJobOnPoolError

        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RESTART_JOB_ON_POOL_ERROR,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->dwRestartJobOnPoolTimeout = Flags;

        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RESTART_JOB_ON_POOL_ERROR,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->dwRestartJobOnPoolTimeout,
                                           sizeof( pIniSpooler->dwRestartJobOnPoolTimeout ));
        }

        // RestartJobOnPoolEnabled
        cbData = sizeof( Flags );
        Status = SplRegQueryValue( hKeyProvider,
                                   SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                   NULL,
                                   (LPBYTE)&Flags,
                                   &cbData,
                                   pIniSpooler );

        if (Status == ERROR_SUCCESS) {

            pIniSpooler->bRestartJobOnPoolEnabled = !!Flags;

            if (Flags != 1 && Flags != 0) {
                Status = SetPrinterDataServer( pIniSpooler,
                                               SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                               REG_DWORD,
                                               (LPBYTE)&pIniSpooler->bRestartJobOnPoolEnabled,
                                               sizeof( pIniSpooler->bRestartJobOnPoolEnabled ));
            }
        } else {

            Status = SetPrinterDataServer( pIniSpooler,
                                           SPLREG_RESTART_JOB_ON_POOL_ENABLED,
                                           REG_DWORD,
                                           (LPBYTE)&pIniSpooler->bRestartJobOnPoolEnabled,
                                           sizeof( pIniSpooler->bRestartJobOnPoolEnabled ));
        }

        SplRegCloseKey( hKeyProvider, pIniSpooler );
    }
    GetDiscardTSJobsSettings( pIniSpooler );
    GetServerFilePoolSettings( pIniSpooler );
}

VOID
GetServerFilePoolSettings(
    PINISPOOLER pIniSpooler
    )
{
    //
    // We read the registry key DisableServerFilePooling from
    // HKLM\System\CurrentControlSet\Control\Print once on spooler startup.
    // If the value is set, filepooling for the server is disabled.
    //
    DWORD   RegValue  = 0;
    DWORD   RegValueSize = sizeof(RegValue);
    HKEY    RegKey       = NULL;
    DWORD   dwError      = ERROR_SUCCESS;
    DWORD   RegValueType;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            ipszRegistryRoot,
                            0,
                            KEY_READ,
                            &RegKey );

    if (dwError == ERROR_SUCCESS)
    {
        dwError = RegQueryValueEx( RegKey,
                                   szDisableFilePooling,
                                   NULL,
                                   (LPDWORD) &RegValueType,
                                   (LPBYTE) &RegValue,
                                   &RegValueSize );

        if ( RegValueType == REG_DWORD && dwError == ERROR_SUCCESS && RegValue > 0)
        {
            pIniSpooler->dwSpoolerSettings |= SPOOLER_NOFILEPOOLING;
        }
    }

    if (RegKey)
    {
        RegCloseKey( RegKey );
    }
}


DWORD
FinalInitAfterRouterInitComplete(
    DWORD dwUpgrade,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    This thread does LocalSpl initialization that has to happen after
    the router has completely initialized.

    There are 2 jobs:-
        Upgrading Printer Driver Data
        Sharing Printers

    Ensures that printers are shared.  This case occurs when the spooler
    service not running on startup (and the server is), and then the
    user starts the spooler.

    We also get the benefit of closing down any invalid printer handles
    (in the server).

Arguments:

    dwUpgrade != 0 upgrade printer driver data.

Return Value:

    DWORD - ignored

--*/

{
    DWORD           dwPort;
    PINIPORT        pIniPort;
    PINIMONITOR     pIniLangMonitor;
    PINIPRINTER     pIniPrinter;
    PINIPRINTER     pIniPrinterNext;

    // Do Not share all the printers during an Upgrade.

    if ( dwUpgrade ) {

        return 0;
    }


    WaitForSpoolerInitialization();

    // Try pending driver upgrades on spooler startup
    PendingDriverUpgrades(NULL);

    EnterSplSem();

    // Delete printers in pending deletion state with no jobs
    CleanupDeletedPrinters(pIniSpooler);


    //
    // Re-share all shared printers.
    //

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ) {

        if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {
            //
            // Up the ref count to prevent deletion
            //
            INCPRINTERREF( pIniPrinter );

            //
            // Unshare it first. We are doing it both to close all handles in the
            // server ( for the case when the printer is shared ) or to just unshare
            // the printer if the policy says so ( we cleared the attribute above )
            //
            ShareThisPrinter( pIniPrinter,
                              pIniPrinter->pShareName,
                              FALSE );

            //
            // We are checking if the printer is still shared ( the attribute could have been
            // cleared as a result of the remote connctions policy being off or , if that's
            // not the case, as a result of leaving the Spooler semaphore in ShareThisPrinter)
            //
            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

                BOOL bReturn;

                //
                // Now share it again.
                //
                bReturn = ShareThisPrinter( pIniPrinter,
                                            pIniPrinter->pShareName,
                                            TRUE );

                if( !bReturn ){

                    DWORD rc = GetLastError();

                    if( rc != NERR_ServerNotStarted &&
                        rc != NERR_DuplicateShare ){

                        WCHAR szError[256];

                        DBGMSG( DBG_WARNING,
                                ( "NetShareAdd failed %lx\n", rc));

                        StringCchPrintf(szError, COUNTOF(szError), L"+ %d", rc);

                        SplLogEvent( pIniSpooler,
                                     LOG_ERROR,
                                     MSG_SHARE_FAILED,
                                     TRUE,
                                     szError,
                                     pIniPrinter->pName,
                                     pIniPrinter->pShareName,
                                     NULL );
                     }
                 }
            }

            DECPRINTERREF( pIniPrinter );
            pIniPrinterNext = pIniPrinter->pNext;


        } else {

            //
            // The unshared case.
            //
            pIniPrinterNext = pIniPrinter->pNext;
        }  

        INCPRINTERREF(pIniPrinter);

        if (pIniPrinterNext)
            INCPRINTERREF(pIniPrinterNext);

        for ( dwPort = 0 ; dwPort < pIniPrinter->cPorts ; ++dwPort ) {

            pIniPort = pIniPrinter->ppIniPorts[dwPort];

            //
            // Bidi monitor can inform spooler of errors. First
            // printer will keep the port at the beginning
            //
            if ( pIniPort->ppIniPrinter[0] != pIniPrinter )
                continue;

            if ( !pIniPort->hMonitorHandle && dwUpgradeFlag == 0 ) {

                LPTSTR pszPrinter;
                TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];

                if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

                    pszPrinter = szFullPrinter;
                    StringCchPrintf(szFullPrinter, 
                                COUNTOF(szFullPrinter), 
                                L"%ws\\%ws", 
                                pIniSpooler->pMachineName, 
                                pIniPrinter->pName);
                } else {

                    pszPrinter = pIniPrinter->pName;
                }

                if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI )
                    pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
                else
                    pIniLangMonitor = NULL;

                OpenMonitorPort(pIniPort,
                                pIniLangMonitor,
                                pszPrinter);  
                ReleaseMonitorPort(pIniPort);
              
            }
        }

        if (pIniPrinterNext)
            DECPRINTERREF(pIniPrinterNext);

        DECPRINTERREF(pIniPrinter);
   }

   LeaveSplSem();

    return 0;
}


DWORD
FinalInitAfterRouterInitCompleteThread(
    DWORD dwUpgrade
    )

/*++

Routine Description:

    Async thread called when initializing provider.

Arguments:

Return Value:

--*/

{
    return FinalInitAfterRouterInitComplete( dwUpgrade, pLocalIniSpooler );
}

// DEBUG PURPOSE ONLY - - returns TRUE if pMem is an IniSpooler, FALSE otherwise
BOOL
NotIniSpooler(
    BYTE *pMem
    )
{
    PINISPOOLER pIniSpooler;

    for (pIniSpooler = pLocalIniSpooler ; pIniSpooler ; pIniSpooler = pIniSpooler->pIniNextSpooler)
        if (pIniSpooler == (PINISPOOLER) pMem)
            return FALSE;

    return TRUE;

}


BOOL
ValidateProductSuite(
    PWSTR pszSuiteName
    )
{
    BOOL bRet = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    PWSTR pszProductSuite = NULL;
    PWSTR psz;


    Rslt = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        ipszRegistryProductOptions,
                        0,
                        KEY_READ,
                        &hKey);

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx(
        hKey,
        L"ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (!Size || Rslt != ERROR_SUCCESS)
        goto exit;

    pszProductSuite = AllocSplMem(Size);
    if (!pszProductSuite) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        L"ProductSuite",
        NULL,
        &Type,
        (LPBYTE) pszProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    for(psz = pszProductSuite ; *psz && wcscmp(psz, pszSuiteName) ; psz += wcslen(psz) + 1)
        ;
    if (*psz)
        bRet = TRUE;

exit:

    FreeSplMem(pszProductSuite);

    if (hKey)
        RegCloseKey(hKey);

    return bRet;
}

/*++

Routine Name:

    ClusterAddOrUpdateDriverFromClusterDisk

Routine Description:

    Takes in a driver key and a cluster type pIniSpooler. It will add
    a driver from the cluster disk to the cluster spooler. If the driver
    already exists in the list of drivers, then it will attempt to upgrade
    it.

Arguments:

    hKeyVersion   - key to Ex. "Environments\Windows NT x86\Drivers\Version-3"
    pszDriverName - name a a driver
    pszEnvName    - environemnt of the driver
    pszenvDir     - directory for the driver files on the disk (Ex. w32x86)
    pIniSpooler   - cluster type pIniSpooler

Return Value:

    Win32 error code

--*/
DWORD
ClusterAddOrUpdateDriverFromClusterDisk(
    IN HKEY         hKeyVersion,
    IN LPCWSTR      pszDriverName,
    IN LPCWSTR      pszEnvName,
    IN LPCWSTR      pszEnvDir,
    IN PINISPOOLER  pIniSpooler
    )
{
    LPWSTR        pszzPathDepFiles = NULL;
    DRIVER_INFO_6 Drv              = {0};
    HKEY          hDrvKey          = NULL;
    WCHAR         szVerPath[10]    = {0};
    DWORD         dwError          = ERROR_SUCCESS;
    WCHAR         szData[MAX_PATH];
    WCHAR         szPathConfigFile[MAX_PATH];
    WCHAR         szPathDataFile[MAX_PATH];
    WCHAR         szPathDriverFile[MAX_PATH];
    WCHAR         szPathHelpFile[MAX_PATH];
    DWORD         cbData;
    DWORD         cLen;

    //
    // Open the driver's key
    //
    if ((dwError = SplRegOpenKey(hKeyVersion,
                                 pszDriverName,
                                 KEY_READ,
                                 &hDrvKey,
                                 pIniSpooler)) == ERROR_SUCCESS &&
        (dwError = (Drv.pName = AllocSplStr(pszDriverName)) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
        RegGetString(hDrvKey, szConfigurationKey, &Drv.pConfigFile,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szDataFileKey,      &Drv.pDataFile,        &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szDriverFile,       &Drv.pDriverPath,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        (dwError = Drv.pConfigFile &&
                   Drv.pDataFile   &&
                   Drv.pDriverPath ?  ERROR_SUCCESS : ERROR_INVALID_PARAMETER) == ERROR_SUCCESS                &&
        RegGetString(hDrvKey, szHelpFile,         &Drv.pHelpFile,        &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szMonitor,          &Drv.pMonitorName,     &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szDatatype,         &Drv.pDefaultDataType, &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetMultiSzString(hDrvKey, szDependentFiles,   &Drv.pDependentFiles,  &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetMultiSzString(hDrvKey, szPreviousNames,    &Drv.pszzPreviousNames,&cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szMfgName,          &Drv.pszMfgName,       &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szOEMUrl,           &Drv.pszOEMUrl,        &cLen, &dwError, FALSE, pIniSpooler)  &&
        RegGetString(hDrvKey, szHardwareID,       &Drv.pszHardwareID,    &cLen, &dwError, TRUE,  pIniSpooler)  &&
        RegGetString(hDrvKey, szProvider,         &Drv.pszProvider,      &cLen, &dwError, TRUE,  pIniSpooler)  &&
        (dwError = ClusterFindLanguageMonitor(Drv.pMonitorName, pszEnvName, pIniSpooler))  == ERROR_SUCCESS)
    {
        cbData = sizeof(Drv.ftDriverDate);
        SplRegQueryValue(hDrvKey,
                         szDriverDate,
                         NULL,
                         (LPBYTE)&Drv.ftDriverDate,
                         &cbData,
                         pIniSpooler);

        cbData = sizeof(Drv.dwlDriverVersion);
        SplRegQueryValue(hDrvKey,
                         szLongVersion,
                         NULL,
                         (LPBYTE)&Drv.dwlDriverVersion,
                         &cbData,
                         pIniSpooler);

        cbData = sizeof(Drv.cVersion);
        SplRegQueryValue(hDrvKey,
                         szDriverVersion,
                         NULL,
                         (LPBYTE)&Drv.cVersion,
                         &cbData,
                         pIniSpooler);

        //
        // We need the matching version <-> directory on disk
        // Ex. Version-3 <-> 3
        //
        StringCchPrintf(szVerPath, COUNTOF(szVerPath), L"%u", Drv.cVersion);

        //
        // Get fully qualified driver file paths. We will do an add printer driver
        // without using the scratch directory. So the files have to be fully
        // qualified
        //
        if ((dwError = StrNCatBuff(szPathDriverFile,
                                   COUNTOF(szPathDriverFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pDriverPath,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathDataFile,
                                   COUNTOF(szPathDataFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pDataFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathConfigFile,
                                   COUNTOF(szPathConfigFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pConfigFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szPathHelpFile,
                                   COUNTOF(szPathHelpFile),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   Drv.pHelpFile,
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrNCatBuff(szData,
                                   COUNTOF(szData),
                                   pIniSpooler->pszClusResDriveLetter, L"\\",
                                   szClusterDriverRoot, L"\\",
                                   pszEnvDir, L"\\",
                                   szVerPath, L"\\",
                                   NULL)) == ERROR_SUCCESS &&
            (dwError = StrCatPrefixMsz(szData,
                                       Drv.pDependentFiles,
                                       &pszzPathDepFiles)) == ERROR_SUCCESS)
        {
            LPWSTR pszTempDriver = Drv.pDriverPath;
            LPWSTR pszTempData   = Drv.pDataFile;
            LPWSTR pszTempConfig = Drv.pConfigFile;
            LPWSTR pszTempHelp   = Drv.pHelpFile;
            LPWSTR pszTempDep    = Drv.pDependentFiles;

            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathDriverFile = "TSTR"\n", szPathDriverFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathDataFile   = "TSTR"\n", szPathDataFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathConfigFile = "TSTR"\n", szPathConfigFile));
            DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpDrv   szPathHelpFile   = "TSTR"\n", szPathHelpFile));

            Drv.pDriverPath        = szPathDriverFile;
            Drv.pEnvironment       = (LPWSTR)pszEnvName;
            Drv.pDataFile          = szPathDataFile;
            Drv.pConfigFile        = szPathConfigFile;
            Drv.pHelpFile          = szPathHelpFile;
            Drv.pDependentFiles    = pszzPathDepFiles;

            if (!SplAddPrinterDriverEx(NULL,
                                       6,
                                       (LPBYTE)&Drv,
                                       APD_COPY_NEW_FILES | APD_DONT_COPY_FILES_TO_CLUSTER,
                                       pIniSpooler,
                                       FALSE,
                                       DO_NOT_IMPERSONATE_USER))
            {
                dwError = GetLastError();
            }

            //
            // Restore pointers
            //
            Drv.pDriverPath     = pszTempDriver;
            Drv.pConfigFile     = pszTempConfig;
            Drv.pDataFile       = pszTempData;
            Drv.pHelpFile       = pszTempHelp;
            Drv.pDependentFiles = pszTempDep;
        }
    }

    FreeSplStr(Drv.pName);
    FreeSplStr(Drv.pDriverPath);
    FreeSplStr(Drv.pConfigFile);
    FreeSplStr(Drv.pDataFile);
    FreeSplStr(Drv.pHelpFile);
    FreeSplStr(Drv.pMonitorName);
    FreeSplStr(Drv.pDefaultDataType);
    FreeSplStr(Drv.pDependentFiles);
    FreeSplStr(Drv.pszzPreviousNames);
    FreeSplStr(Drv.pszMfgName);
    FreeSplStr(Drv.pszOEMUrl);
    FreeSplStr(Drv.pszProvider);
    FreeSplStr(Drv.pszHardwareID);
    FreeSplStr(pszzPathDepFiles);

    if (hDrvKey)
    {
        SplRegCloseKey(hDrvKey, pIniSpooler);
    }

    DBGMSG(DBG_CLUSTER, ("ClusterAddOrUpdateDriverFromClusterDisk returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name:

    SplCreateSpoolerWorkerThread

Routine Description:

    This routine will be launched in a separate thread to perform time consuming
    initialization as part of SplCreateSpooler when the spooler is a cluster spooler.
    Tasks that it will do include copying down ICM profiles from the cluster disk.
    The caller needs to AddRef the pIniSpooler so that it doesn't become invalid
    (deleted) while we are using it.

    This function closes the hClusSplReady event handle.

Arguments:

    PINISPOOLER pIniSpooler

Return Value:

    None

--*/
VOID
SplCreateSpoolerWorkerThread(
    IN PVOID pv
    )
{
    PINISPOOLER pIniSpooler;
    WCHAR       szDir[MAX_PATH];

    pIniSpooler = (PINISPOOLER)pv;

    if (pIniSpooler &&
        pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER &&
        pIniSpooler->hClusSplReady)
    {
        HANDLE hSplReady = pIniSpooler->hClusSplReady;

        //
        // Waiting for the creating function (SplCreateSpooler) to terminate
        //
        WaitForSingleObject(pIniSpooler->hClusSplReady, INFINITE);

        EnterSplSem();

        pIniSpooler->hClusSplReady = NULL;

        LeaveSplSem();

        //
        // We use hSplReady so we do not hold the critical section while doing CloseHandle
        //
        CloseHandle(hSplReady);

        CopyICMFromClusterDiskToLocalDisk(pIniSpooler);

        //
        // If the node was upgraded, we need to upgrade the print drivers
        // We cannot load ntprint and printui. So we create a process and
        // call an entry point in ntprint. That one will enumerate all the
        // cluster drivers and will try to upgrade them based on the new cab.
        //
        if (pIniSpooler->dwClusNodeUpgraded)
        {
            DWORD  dwError;
            DWORD  dwCode     = 0;
            LPWSTR pszCommand = NULL;
            LPWSTR pszExe     = NULL;

            //
            // We need to pass as argument the name of the cluster spooler
            //
            if ((dwError = StrCatSystemPath(L"rundll32.exe",
                                            kSystemDir,
                                            &pszExe)) == ERROR_SUCCESS &&
                (dwError = StrCatAlloc(&pszCommand,
                                       L"rundll32.exe ntprint.dll,PSetupUpgradeClusterDrivers ",
                                       pIniSpooler->pMachineName,
                                       NULL)) == ERROR_SUCCESS &&
                (dwError = RunProcess(pszExe, pszCommand, INFINITE, &dwCode)) == ERROR_SUCCESS)
            {
                //
                // dwCode is the return code of the function PSetupUpgradeClusterDrivers in ntprint,
                // executed inside the rundll32 process
                //
                if (dwCode == ERROR_SUCCESS)
                {
                    //
                    // We upgraded all the printer drivers, now we delete the key from the registry
                    // so we don't go though upgrading printer drivers again next time when the
                    // cluster group comes online on this node
                    //
                    ClusterSplDeleteUpgradeKey(pIniSpooler->pszClusResID);
                }
                else
                {
                    DBGMSG(DBG_WARN, ("Error upgrading cluster drivers! dwCode %u\n", dwCode));
                }
            }

            FreeSplMem(pszCommand);
            FreeSplMem(pszExe);

            DBGMSG(DBG_CLUSTER, ("SplCreateSpoolerWorkerThread dwError %u  dwCode %u\n", dwError, dwCode));
        }

        //
        // Set resource private property ClusterDriverDirectry. This will be used by the
        // ResDll to perform clean up when the spooler is deleted
        //
        if (StrNCatBuff(szDir,
                        COUNTOF(szDir),
                        pIniSpooler->pszClusResDriveLetter,
                        L"\\",
                        szClusterDriverRoot,
                        NULL) == ERROR_SUCCESS)
        {
            SplRegSetValue(pIniSpooler->hckRoot,
                           SPLREG_CLUSTER_DRIVER_DIRECTORY,
                           REG_SZ,
                           (LPBYTE)szDir,
                           (wcslen(szDir) + 1) * sizeof(WCHAR),
                           pIniSpooler);
        }

        EnterSplSem();

        DECSPOOLERREF(pIniSpooler);

        LeaveSplSem();

        DBGMSG(DBG_CLUSTER, ("SplCreateSpoolerWorkerThread terminates pIniSpooler->cRef %u\n", pIniSpooler->cRef));
    }
}

/*++

Routine Name:

    LogFatalPortError

Routine Description:

    This routine logs a message when a printer cannot be brought up because its
    ports are missing.

Arguments:

    pszName -   The name of the printer.

Return Value:

    None.

--*/
VOID
LogFatalPortError(
    IN      PINISPOOLER pIniSpooler,
    IN      PCWSTR      pszName
    )
{
    DWORD  LastError    = ERROR_SUCCESS;
    WCHAR  szError[40]  = {0};

    LastError = GetLastError();

    StringCchPrintf(szError, COUNTOF(szError), L"%u (0x%x)", LastError, LastError);

    SplLogEvent(pIniSpooler,
                LOG_ERROR,
                MSG_PORT_INITIALIZATION_ERROR,
                FALSE,
                (PWSTR)pszName,
                szError,
                NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\jobid.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    jobid.h

Abstract:

    Handles job id bitmap.

Author:

    Albert Ting (AlbertT) 24-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Ported from spooler.c code.

--*/

#ifndef _JOBID_H
#define _JOBID_H

typedef struct _JOB_ID_MAP {
    PDWORD pMap;
    DWORD dwMaxJobId;
    DWORD dwCurrentJobId;
} JOB_ID_MAP, *PJOB_ID_MAP;


#define pMapFromHandle( hJobIdMap ) (((PJOB_ID_MAP)hJobIdMap)->pMap)
#define MaxJobId( hJobIdMap ) (((PJOB_ID_MAP)hJobIdMap)->dwMaxJobId)

#define vMarkOn( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[(Id) / 32] |= (1 << ((Id) % 32) ))

#define vMarkOff( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[(Id) / 32] &= ~(1 << ((Id) % 32) ))

#define bBitOn( hJobId, Id) \
    ((pMapFromHandle( hJobId ))[Id / 32] & ( 1 << ((Id) % 32) ) )

BOOL
ReallocJobIdMap(
    HANDLE hJobIdMap,
    DWORD dwNewMinSize
    );

DWORD
GetNextId(
    HANDLE hJobIdMap
    );

HANDLE
hCreateJobIdMap(
    DWORD dwMinSize
    );

VOID
vDeleteJobIdMap(
    HANDLE hJobIdMap
    );

#endif // ifdef _JOBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\mapsd.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    mapsd.c

Abstract:

    Mapping Security Descriptors


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>

// Object types
//


extern GENERIC_MAPPING GenericMapping[];

PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    );

BOOL
ProcessSecurityDescriptorDacl(
    PSECURITY_DESCRIPTOR pSourceSD,
    PACL   *ppDacl,
    LPBOOL  pDefaulted
    );

DWORD
MapPrinterMaskToShareMask(
    DWORD PrinterMask
    );

PSECURITY_DESCRIPTOR
MapPrinterSDToShareSD(
    PSECURITY_DESCRIPTOR pPrinterSD
    )
{
    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative;
    BOOL Defaulted = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    BOOL ErrorOccurred = FALSE;
    DWORD   SDLength = 0;
    

    if (!IsValidSecurityDescriptor(pPrinterSD)) {
        return(NULL);
    }
    if (!InitializeSecurityDescriptor (&AbsoluteSD ,SECURITY_DESCRIPTOR_REVISION1)) {
        return(NULL);
    }

    if(GetSecurityDescriptorOwner( pPrinterSD,
                                    &pOwnerSid, &Defaulted ) )
        SetSecurityDescriptorOwner( &AbsoluteSD,
                                    pOwnerSid, Defaulted );
    else
        ErrorOccurred = TRUE;

    if( GetSecurityDescriptorGroup( pPrinterSD,
                                    &pGroupSid, &Defaulted ) )
        SetSecurityDescriptorGroup( &AbsoluteSD,
                                    pGroupSid, Defaulted );
    else
        ErrorOccurred = TRUE;

    if (ProcessSecurityDescriptorDacl(pPrinterSD, &pDacl, &Defaulted)) {
        (VOID)SetSecurityDescriptorDacl (&AbsoluteSD, TRUE, pDacl, FALSE );
    }
    else
        ErrorOccurred = TRUE;

    if (ErrorOccurred) {
        if (pDacl) {
            LocalFree(pDacl);
        }
        return(NULL);
    }


    SDLength = GetSecurityDescriptorLength( &AbsoluteSD);
    pRelative = LocalAlloc(LPTR, SDLength);
    if (!pRelative) {
        LocalFree(pDacl);
        return(NULL);
    }
    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &SDLength)) {
        LocalFree(pRelative);
        LocalFree(pDacl);
        return(NULL);
    }
    LocalFree(pDacl);
    return(pRelative);
}

BOOL
ProcessSecurityDescriptorDacl(
    PSECURITY_DESCRIPTOR pSourceSD,
    PACL   *ppDacl,
    LPBOOL  pDefaulted
    )

{
    BOOL                DaclPresent     = FALSE;
    BOOL                bRet            = FALSE;
    DWORD               DestAceCount    = 0;
    DWORD               DaclLength      = 0;
    PACL                TmpAcl          = NULL;
    PACL                pDacl           = NULL;
    PSID                *ppSid          = NULL;
    ACCESS_MASK         *pAccessMask    = NULL;
    BYTE                *pInheritFlags  = NULL;
    UCHAR               *pAceType       = NULL;
    PACCESS_ALLOWED_ACE pAce            = NULL;
    DWORD               dwLengthSid     = 0;
    PSID                pSourceSid      = NULL;
    PSID                pDestSid        = NULL;
    DWORD               i               = 0;
    PACCESS_ALLOWED_ACE TmpAce          = NULL;       
    ACL_SIZE_INFORMATION AclSizeInfo;


    *ppDacl = NULL;

    bRet = GetSecurityDescriptorDacl( pSourceSD, &DaclPresent, &pDacl, pDefaulted );

    if (bRet) {

        bRet = DaclPresent; 

        //
        // NULL is a valid DACL
        //
        if (!pDacl)
        {
            return TRUE;
        }
    }

    if (bRet) {

        GetAclInformation(pDacl, &AclSizeInfo,  sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        ppSid = LocalAlloc(LPTR, sizeof(PSID)* AclSizeInfo.AceCount);
        pAccessMask = LocalAlloc(LPTR, sizeof(ACCESS_MASK)* AclSizeInfo.AceCount);
        pInheritFlags = LocalAlloc(LPTR, sizeof(BYTE)*AclSizeInfo.AceCount);
        pAceType = LocalAlloc(LPTR, sizeof(UCHAR)*AclSizeInfo.AceCount);

        bRet = ppSid && pAccessMask && pInheritFlags && pAceType;
    }

    for (i = 0 ; bRet && i < AclSizeInfo.AceCount; i++) {
         GetAce(pDacl, i, (LPVOID *)&pAce);
         //
         // Skip the Ace if it is inherit only
         //
         if ( ((PACE_HEADER)pAce)->AceFlags & INHERIT_ONLY_ACE ) {
             continue;
         }

         *(pAceType + DestAceCount) = ((PACE_HEADER)pAce)->AceType;
         *(pAccessMask + DestAceCount) = MapPrinterMaskToShareMask(((PACCESS_ALLOWED_ACE)pAce)->Mask);
         *(pInheritFlags + DestAceCount) =  ((PACE_HEADER)pAce)->AceFlags;
         //
         // Copy the sid information
         //
         pSourceSid = (PSID)(&(((PACCESS_ALLOWED_ACE)pAce)->SidStart));
         dwLengthSid = GetLengthSid(pSourceSid);
         pDestSid = (LPBYTE)LocalAlloc(LPTR, dwLengthSid);

         if (pDestSid) {

             CopySid(dwLengthSid, pDestSid, pSourceSid);

             *(ppSid + DestAceCount) = pDestSid;

         } else {
                    
             //
             // We failed to allocate the memory, we signal that we failed and 
             // fall down to the cleanup code below.
             // 
             bRet = FALSE;

             break;
         }

         DestAceCount++;
    }

    //
    // Compute size of the Dacl
    //
    if (bRet) {

        DaclLength = (DWORD)sizeof(ACL);
        for (i = 0; i < DestAceCount; i++) {

            DaclLength += GetLengthSid( *(ppSid + i)) +
                          (DWORD)sizeof(ACCESS_ALLOWED_ACE) -
                          (DWORD)sizeof(DWORD);  //Subtract out SidStart field length
        }

        TmpAcl = LocalAlloc(LPTR, DaclLength);

        bRet = (TmpAcl != NULL);
    }

    if (bRet) {
        
        bRet = InitializeAcl(TmpAcl, DaclLength, ACL_REVISION2);
    }

    for (i = 0; bRet && i < DestAceCount; i++) {
        if( *(pAceType +i) == ACCESS_ALLOWED_ACE_TYPE )
            (VOID)AddAccessAllowedAce ( TmpAcl, ACL_REVISION2, *(pAccessMask + i), *(ppSid + i));
        else
            (VOID)AddAccessDeniedAce ( TmpAcl, ACL_REVISION2, *(pAccessMask + i), *(ppSid + i));
        if (*(pInheritFlags + i) != 0) {
            (VOID)GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
            TmpAce->Header.AceFlags = *(pInheritFlags + i);
        }
    }

    //
    // Write the Dacl back from the TmpAcl.
    // 
    if (bRet) {

        *ppDacl = TmpAcl;

        TmpAcl = NULL;
    }

    //
    // Free all of our temporary space.
    //
    if (ppSid) {

        for (i = 0; i < DestAceCount; i++) {
            LocalFree(*(ppSid + i));
        }

        LocalFree(ppSid);
    }

    if (pAccessMask) {

        LocalFree(pAccessMask);
    }
    
    if (pInheritFlags) {

        LocalFree(pInheritFlags);
    }
    
    if (pAceType) {

        LocalFree(pAceType);
    }

    if (TmpAcl) {

        LocalFree(TmpAcl);
    }
        
    return bRet;
}

DWORD
MapPrinterMaskToShareMask(
    DWORD PrinterMask
    )
{
    DWORD   ReturnMask = 0;

    MapGenericMask(&PrinterMask, &GenericMapping[SPOOLER_OBJECT_PRINTER]);

    if ((PrinterMask & PRINTER_ACCESS_ADMINISTER)
        || (PrinterMask & PRINTER_ACCESS_USE)) {
        ReturnMask |= GENERIC_ALL;
    }
    return(ReturnMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\monhndl.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    monitorhndl.cxx

Abstract:

   This is the class that wrapps the port/language monitor
   handle.
   
Author:

    Adina Trufinescu July 16th, 2002

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "monhndl.hxx"


WCHAR   TMonitorHandle::m_szFILE[] = L"FILE:";

/*++

Routine Name:   

    Constructor

Routine Description:

    Returns number of elements that could be enumerated.
    NOT thread safe.

Arguments:

    pIniPort        - pointer to INIPORT structure
    pIniLangMonitor - pointer to INIMONITOR structure 
                      represented the preffered language monitor.
    pszPrinterName  - string representing the printer name

Return Value:

    NONE

Last Error:

    Not Set.

--*/
TMonitorHandle::
TMonitorHandle(
    IN  PINIPORT    pIniPort,
    IN  PINIMONITOR pIniLangMonitor,
    IN  LPWSTR      pszPrinterName
    ) : m_pIniPort(pIniPort),
        m_pIniLangMonitor(pIniLangMonitor),
        m_pszPrinterName(pszPrinterName),
        m_RefCnt(0),
        m_hPort(NULL),
        m_OpenedMonitorType(kNone),
        m_hValid(E_FAIL)
{
    SplInSem();

    if (SUCCEEDED(m_hValid = (m_pIniPort) ? S_OK : E_INVALIDARG))
    {
        if (SUCCEEDED(m_hValid))
        {
            if (m_pIniPort->Status & PP_FILE)
            {
                m_hValid = OpenMonitorForFILEPort();                
            }
            else
            {
                if (m_pIniLangMonitor && !m_pIniLangMonitor->Monitor2.pfnOpenPortEx)
                {
                    m_pIniLangMonitor = NULL;
                }
                            
                m_hValid = Open();
                
            }

            if (SUCCEEDED(m_hValid))
            {
                INCPORTREF(m_pIniPort);
                INCSPOOLERREF(m_pIniPort->pIniSpooler);                
                INCMONITORREF(static_cast<PINIMONITOR>(*this));
            }            
        }

    }
}

/*++

Routine Name:   

    Destructor

Routine Description:

    Destructor

Arguments:

    NONE

Return Value:

    NONE

Last Error:

    Not Set.

--*/
TMonitorHandle::
~TMonitorHandle(
    VOID
    )
{
    SplInSem();   

    if (SUCCEEDED(m_hValid))
    {
        Close();

        DECPORTREF(m_pIniPort);           
        DECSPOOLERREF(m_pIniPort->pIniSpooler);

    }

}

/*++

Routine Name:   

    Open

Routine Description:

    Opens the correct monitor.
    If the language monitor is NULL or it 
    doesn't support OpenPortEx, it will open the port monitor.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
Open(
    VOID
    )
{
    HRESULT hr;

    hr = m_pIniLangMonitor ? 
              (m_pIniLangMonitor->bUplevel ? 
                    OpenLangMonitorUplevel() :
                    OpenLangMonitorDownlevel()):
               OpenPortMonitor();    
               
    return hr;
}

/*++

Routine Name:   

    Close

Routine Description:

    Closes the opened monitor.

Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
Close(
    VOID
    )
{
    HRESULT hr    = m_hValid;
    HANDLE  hPort = m_hPort;

    if (SUCCEEDED(hr))
    {
        PINIMONITOR pIniMonitor = static_cast<PINIMONITOR>(*this);

        if (pIniMonitor)
        {
            LeaveSpoolerSem();

            if (!(pIniMonitor->Monitor2.pfnClosePort)(hPort))
            {
                hPort = NULL;
                hr    = HResultFromWin32(GetLastError());
            }

            ReEnterSpoolerSem();

            if (SUCCEEDED(hr))
            {
                if (pIniMonitor == m_pIniPort->pIniLangMonitor)
                {
                    m_pIniPort->pIniLangMonitor = NULL;
                }

                m_hPort = NULL;                
                DECMONITORREF(pIniMonitor);
            }
        }        
    }

    return hr;
}

/*++

Routine Name:   

    OpenLangMonitorUplevel

Routine Description:

    Opens the language monitor using Monitor2.OpenPortEx.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
OpenLangMonitorUplevel(
    VOID
    )
{
    HRESULT hr = S_OK;
    
    INCMONITORREF(m_pIniLangMonitor);
    LeaveSpoolerSem();
    SetLastError(ERROR_SUCCESS);

    if (!(*(m_pIniLangMonitor)->Monitor2.pfnOpenPortEx)(m_pIniLangMonitor->hMonitor, 
                                                        m_pIniPort->pIniMonitor->hMonitor,
                                                        m_pIniPort->pName,
                                                        m_pszPrinterName,
                                                        &m_hPort,
                                                        &m_pIniPort->pIniMonitor->Monitor2))
    {
        if (SUCCEEDED(hr = HResultFromWin32(GetLastError())))
        {
            hr = HResultFromWin32(ERROR_INVALID_HANDLE);
        }        
    }
    else
    {
        hr = m_hPort ? 
                S_OK :
                HResultFromWin32(ERROR_INVALID_HANDLE);
    }

    ReEnterSpoolerSem();
    DECMONITORREF(m_pIniLangMonitor);

    if (SUCCEEDED(hr))
    {
        m_OpenedMonitorType = kLanguage;
        m_pIniPort->pIniLangMonitor = m_pIniLangMonitor;
    }

    SetLastError(HRESULT_CODE(hr));
    return hr;
}

/*++

Routine Name:   

    OpenLangMonitorDownlevel

Routine Description:

    Opens the language monitor using Monitor.OpenPortEx.
    If the port monitor is downlevel, create unique name string.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
OpenLangMonitorDownlevel(
    VOID
    )
{
    HRESULT hr        = S_OK;
    LPWSTR  pszPort   = NULL;
    WCHAR   szPortNew[MAX_PATH];    

    if (m_pIniPort->pIniMonitor->bUplevel)
    {        
        //
        // Downlevel port monitor; create hack string.
        //
        if (SUCCEEDED(StringCchPrintf(szPortNew, 
                                     COUNTOF(szPortNew), 
                                     TEXT("%s,%p"), 
                                     m_pIniPort->pName, 
                                     m_pIniPort->pIniMonitor)))      
        {
            pszPort = szPortNew;
        }

    }
    else
    {
        pszPort = m_pIniPort->pName;
    }

    if (pszPort)
    {
        INCMONITORREF(m_pIniLangMonitor);
        LeaveSpoolerSem();
        SetLastError(ERROR_SUCCESS);

        if (!(*(m_pIniLangMonitor)->Monitor.pfnOpenPortEx)(pszPort,
                                                           m_pszPrinterName,
                                                           &m_hPort,
                                                           &m_pIniPort->pIniMonitor->Monitor))
        {
            if (SUCCEEDED(hr = HResultFromWin32(GetLastError())))
            {
                hr = HResultFromWin32(ERROR_INVALID_HANDLE);
            }
        }
        else
        {
            hr = m_hPort ? 
                    S_OK :
                    HResultFromWin32(ERROR_INVALID_HANDLE);
        }

        ReEnterSpoolerSem();
        DECMONITORREF(m_pIniLangMonitor);

        if (SUCCEEDED(hr))
        {
            m_OpenedMonitorType = kLanguage;
            m_pIniPort->pIniLangMonitor = m_pIniLangMonitor;
        }

    }
    else
    {
        m_pIniLangMonitor = NULL;
        hr = OpenPortMonitor();
    }

    SetLastError(HRESULT_CODE(hr));
    return hr;

}

/*++

Routine Name:   

    OpenPortMonitor

Routine Description:

    Opens the port monitor using Monitor2.pfnOpenPort.    
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
OpenPortMonitor(
    VOID
    )
{
    HRESULT hr = E_INVALIDARG;

    if (m_pIniPort && 
        m_pIniPort->pIniMonitor && 
        m_pIniPort->pIniMonitor->Monitor2.pfnOpenPort)
    {
        INCMONITORREF(m_pIniPort->pIniMonitor);
        LeaveSpoolerSem();
        SetLastError(ERROR_SUCCESS);

        if ((m_pIniPort->pIniMonitor->Monitor2.pfnOpenPort)(m_pIniPort->pIniMonitor->hMonitor,
                                                            m_pIniPort->pName,
                                                            &m_hPort))
        {
            hr = m_hPort ? 
                    S_OK :
                    HResultFromWin32(ERROR_INVALID_HANDLE);
        }
        else
        {
            if (SUCCEEDED(hr = HResultFromWin32(GetLastError())))
            {
                hr = HResultFromWin32(ERROR_INVALID_HANDLE);
            }
        }

        ReEnterSpoolerSem();
        DECMONITORREF(m_pIniPort->pIniMonitor);

        if (SUCCEEDED(hr))
        {
            m_OpenedMonitorType = kPort;
        }
    }

    SetLastError(HRESULT_CODE(hr));
    return hr;

}

/*++

Routine Name:   

    OpenMonitorForFILEPort

Routine Description:

    Opens the port monitor for FILE: port.    
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
OpenMonitorForFILEPort(
    VOID
    )
{
    HRESULT hr = E_INVALIDARG;

    if (m_pIniPort &&
        m_pIniPort->pIniMonitor && 
        m_pIniPort->pIniMonitor->Monitor2.pfnOpenPort)
    {

        INCMONITORREF(m_pIniPort->pIniMonitor);
        LeaveSpoolerSem();
        SetLastError(ERROR_SUCCESS);

        if ((m_pIniPort->pIniMonitor->Monitor2.pfnOpenPort)(m_pIniPort->pIniMonitor->hMonitor,
                                                            m_szFILE,
                                                            &m_hPort))
        {
            hr = m_hPort ? 
                     S_OK : 
                     HResultFromWin32(ERROR_INVALID_HANDLE);
        }
        else
        {
            if (SUCCEEDED(hr = HResultFromWin32(GetLastError())))
            {
                hr = HResultFromWin32(ERROR_INVALID_HANDLE);
            }
        }

        ReEnterSpoolerSem();
        DECMONITORREF(m_pIniPort->pIniMonitor);

        if (SUCCEEDED(hr))
        {
            m_OpenedMonitorType = kFile;
        }
    }

    SetLastError(HRESULT_CODE(hr));
    return hr;

}

/*++

Routine Name:   

    AddRef

Routine Description:

    Increments object refcount.   
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
ULONG
TMonitorHandle ::
AddRef(
    VOID
    )
{
    return InterlockedIncrement(&m_RefCnt);
    
}

/*++

Routine Name:   

    Release

Routine Description:

    Decrements object refcount.   
    Notice that it doesn't delete the object as 
    the destructor would exit the Spooler CS while the 
    pIniPort still has a reference to the object. 
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
ULONG 
TMonitorHandle ::
Release(
    VOID
    )
{
    ULONG RefCnt = InterlockedDecrement(&m_RefCnt);

    InterlockedCompareExchange(&m_RefCnt, 0, ULONG(-1));

    return RefCnt;    
}

/*++

Routine Name:   

    InUse

Routine Description:

    Checks whether the ref count is zero.
    If it is, then the object can be deleted.
    
Arguments:

    NONE

Return Value:

    ULONG - the ref count value.

Last Error:

    Not Set.

--*/
ULONG 
TMonitorHandle ::
InUse(
    VOID
    )
{
    return InterlockedCompareExchange(&m_RefCnt, 0 , 0);
}
/*++

Routine Name:   

    IsValid

Routine Description:

    Checks object validity.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
TMonitorHandle::
IsValid(
    VOID
    )
{
    return m_hValid;
}


/*++

Routine Name:   

    LeaveSpoolerSem

Routine Description:

    Leaves Spooler CS
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
VOID
TMonitorHandle::
LeaveSpoolerSem(
    VOID
    )
{
    INCPORTREF(m_pIniPort);
    INCSPOOLERREF(m_pIniPort->pIniSpooler);                
    LeaveSplSem();
    SplOutSem();
}

/*++

Routine Name:   

    ReEnterSpoolerSem

Routine Description:

    Enters Spooler CS
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
VOID
TMonitorHandle::
ReEnterSpoolerSem(
    VOID
    )
{
    
    EnterSplSem();
    DECPORTREF(m_pIniPort);
    DECSPOOLERREF(m_pIniPort->pIniSpooler);
    SplInSem();
}



/*++

Routine Name:   

    operator PINIMONITOR

Routine Description:

    Returns a pointer to the opened monitor.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
TMonitorHandle::
operator PINIMONITOR(
    VOID
    )
{
    PINIMONITOR pIniMonitor = NULL;

    switch (m_OpenedMonitorType)
    {
        case kLanguage:
        {
            pIniMonitor = m_pIniLangMonitor;
            break;
        }
        case kPort:
        case kFile:
        {
            pIniMonitor = m_pIniPort->pIniMonitor;
            break;
        }
        default:
        {
            break;
        }
    }

    return pIniMonitor;
}

/*++

Routine Name:   

    operator HANDLE

Routine Description:

    Returns a monitor handle.
    
Arguments:

    NONE

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
TMonitorHandle::
operator HANDLE(
    VOID
    )
{
    return m_hPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\monitor.c ===
/*++


Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    monitor.c

Abstract:

   This module contains all code for Monitor-based Spooler apis

   LocalEnumPorts
   LocalAddMonitor
   LocalDeleteMonitor
   LocalEnumMonitors
   LocalAddPort
   LocalConfigurePort
   LocalDeletePort

   Support Functions in monitor.c - (Warning! Do Not Add to this list!!)

   CopyIniMonitorToMonitor          -- KrishnaG
   GetMonitorSize                   -- KrishnaG

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:
    Khaled Sedky (khaleds) 15-March-2000
        - Added LocalSendRecvBidiData

    Muhunthan Sivapragasam (MuhuntS) 15-Jun-1995
        - Port info 2 changes

    Krishna Ganugapati (KrishnaG) 2-Feb-1994
        - reorganized the entire source file

    Matthew Felton (mattfe) June 1994 pIniSpooler

--*/

#include <precomp.h>
#include <offsets.h>
#include <clusspl.h>

//
// Private declarations
//

HDESK ghdeskServer = NULL;

//
// Function declarations
//



LPBYTE
CopyIniMonitorToMonitor(
    PINIMONITOR pIniMonitor,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    LPBYTE  pEnd
    );

DWORD
GetMonitorSize(
    PINIMONITOR  pIniMonitor,
    DWORD       Level
    );



BOOL
LocalEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPorts( pName,
                            Level,
                            pPorts,
                            cbBuf,
                            pcbNeeded,
                            pcReturned,
                            pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}


VOID
SplReenumeratePorts(
    )
{
    LPVOID  pBuf;
    DWORD   cbNeeded, dwDontCare;

    //
    // EnumPorts checks for new ports enumerated by port monitors and updates
    // localspl pIniPorts list
    //
    if ( !SplEnumPorts(NULL, 1, NULL, 0, &cbNeeded,
                       &dwDontCare, pLocalIniSpooler)               &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER                &&
         (pBuf = AllocSplMem(cbNeeded)) ) {

        SplEnumPorts(NULL, 1, pBuf, cbNeeded, &cbNeeded,
                     &dwDontCare, pLocalIniSpooler);
        FreeSplMem(pBuf);
    }
}


BOOL
GetPortInfo2UsingPortInfo1(
    PINIMONITOR     pIniMonitor,
    LPWSTR          pName,
    LPBYTE          pPorts,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    LPDWORD         pcReturned
    )
{

    BOOL            bRet;
    LPPORT_INFO_1   pPortInfo1;
    LPPORT_INFO_2   pPortInfo2;
    DWORD           cReturned;

    bRet =  (*pIniMonitor->Monitor2.pfnEnumPorts)(
                pIniMonitor->hMonitor,
                pName,
                1,
                pPorts,
                cbBuf,
                pcbNeeded,
                pcReturned );

    if ( !bRet ) {

        //
        // This is the upperbound
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            *pcbNeeded += (*pcbNeeded / sizeof(PORT_INFO_1)) *
                                  (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));
    } else {

        *pcbNeeded += *pcReturned * (sizeof(PORT_INFO_2) - sizeof(PORT_INFO_1));

        if ( *pcbNeeded <= cbBuf ) {

            cReturned = *pcReturned;
            while ( cReturned-- ) {

                pPortInfo1 = (LPPORT_INFO_1) (pPorts + cReturned * sizeof(PORT_INFO_1));
                pPortInfo2 = (LPPORT_INFO_2) (pPorts + cReturned * sizeof(PORT_INFO_2));

                pPortInfo2->pPortName    = pPortInfo1->pName;
                pPortInfo2->pMonitorName = NULL;
                pPortInfo2->pDescription = NULL;
                pPortInfo2->fPortType    = 0;
                pPortInfo2->Reserved     = 0;
            }
        } else {

            *pcReturned = 0;
            bRet = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    return bRet;
}


BOOL
SplEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR     pIniMonitor;
    DWORD           dwIndex, cReturned=0, cbStruct, TotalcbNeeded=0;
    LPBYTE          pBuffer = pPorts, pTemp;
    DWORD           Error=0, TempError  = 0;
    DWORD           BufferSize=cbBuf;
    LPWSTR          pPortName;
    PINIPORT        pIniPort;
    HANDLE          hToken;
    BOOL            bRemoteCall = FALSE;


    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    //
    // HACK: Some monitors choke if pName is non-NULL.  We can make
    // it NULL at this point since we know that we're using the same
    // ports on the local machine.
    //
    pName = NULL;

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    {
        HRESULT hRes = CheckLocalCall();

        if (hRes == S_FALSE)
        {
            bRemoteCall = TRUE;
        }
        else if (hRes != S_OK)
        {
            SetLastError(SCODE_CODE(hRes));
            return FALSE;
        }
    }

    //
    // We revert to local system context only when the caller is remote.
    // The monitors may load dlls from system32 and remote users like
    // guest or anonymous logon do not have sufficient privileges for that.
    // This is safe to revert to self since we do not support delegation, so
    // we will never use the credentials of the remote user to go remote again.
    // If the caller is logged on interactively, then we do not switch the
    // context. Thus, a monitor may be able to go on the network for the port
    // enumeration.
    //
    if (bRemoteCall && !(hToken = RevertToPrinterSelf()))
    {
        return FALSE;
    }

    for ( pIniMonitor = pIniSpooler->pIniMonitor ;
          pIniMonitor ;
          pIniMonitor = pIniMonitor->pNext ) {

        //
        // Lang monitor does not have to define this
        //
        if ( !pIniMonitor->Monitor2.pfnEnumPorts )
            continue;

        *pcReturned = 0;

        *pcbNeeded = 0;

        if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
                   pIniMonitor->hMonitor,
                   pName,
                   Level,
                   pPorts,
                   BufferSize,
                   pcbNeeded,
                   pcReturned)) {

            TempError = GetLastError();
            //
            // Level 2 is a superset of level 1. So we can make a level 1
            // call if the monitor does not support it
            //
            if ( Level == 2 && TempError == ERROR_INVALID_LEVEL ) {

                TempError = 0;
                if ( !GetPortInfo2UsingPortInfo1(pIniMonitor,
                                                 pName,
                                                 pPorts,
                                                 BufferSize,
                                                 pcbNeeded,
                                                 pcReturned) )
                    TempError = GetLastError();
            }

            if ( TempError ) {

                Error = TempError;

                *pcReturned = 0;

                if ( TempError != ERROR_INSUFFICIENT_BUFFER ) {

                    *pcbNeeded  = 0;
                    break;
                }
            }
        } else {

            //
            // Now we look for new ports not in pIniPort list and add them
            //
            EnterSplSem();

            for ( dwIndex = 0, pTemp = pPorts ;
                  dwIndex < *pcReturned ;
                  ++dwIndex ) {

                switch ( Level ) {

                    case 1:
                        pPortName   = ((LPPORT_INFO_1)pTemp)->pName;
                        pTemp      += sizeof(PORT_INFO_1);
                        break;

                    case 2:
                        pPortName   = ((LPPORT_INFO_2)pTemp)->pPortName;
                        pTemp      += sizeof(PORT_INFO_2);
                        break;

                    default:
                        SPLASSERT(Level == 1 || Level == 2);
                }

                pIniPort = FindPort(pPortName, pIniSpooler);
                if ( !pIniPort ) {
                    CreatePortEntry(pPortName, pIniMonitor, pIniSpooler);

                } else if ( !pIniPort->pIniMonitor ) {
                    //
                    // If a fake port gets eventually enumerated by a monitor,
                    // update the pIniPort structure (USB monitor). It is no
                    // longer a placeholder port at this point.
                    //
                    pIniPort->pIniMonitor = pIniMonitor;
                    pIniPort->Status |= PP_MONITOR;
                    pIniPort->Status &= ~PP_PLACEHOLDER;
                }
            }

            LeaveSplSem();
        }


        cReturned += *pcReturned;

        pPorts += *pcReturned * cbStruct;

        if (*pcbNeeded <= BufferSize)
            BufferSize -= *pcbNeeded;
        else
            BufferSize = 0;

        TotalcbNeeded += *pcbNeeded;
    }

    if (bRemoteCall)
    {
        ImpersonatePrinterClient(hToken);
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cReturned;


    if (Error) {

        SetLastError(Error);
        return FALSE;
    } else if (TotalcbNeeded > cbBuf ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    } else {

        //
        // Stop routing if this is a cluster'd spooler.  Otherwise,
        // we'll talk to win32spl, which RPCs to us again.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){
            return ROUTER_STOP_ROUTING;
        }
        return TRUE;
    }
}


BOOL
LocalEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumMonitors( pName, Level, pMonitors, cbBuf,
                               pcbNeeded, pcReturned, pIniSpooler );


    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR pIniMonitor;
    DWORD   cReturned=0, cbStruct, cb;
    LPBYTE  pBuffer = pMonitors;
    DWORD   BufferSize=cbBuf, rc;
    LPBYTE  pEnd;

    if (!MyName( pName, pIniSpooler )) {

        return ROUTER_UNKNOWN;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return ROUTER_UNKNOWN;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return ROUTER_UNKNOWN;
    }

   EnterSplSem();

    for ( cb = 0, pIniMonitor = pIniSpooler->pIniMonitor ;
          pIniMonitor ;
          pIniMonitor = pIniMonitor->pNext ) {

        //
        // We'll not enumerate monitors which do not support AddPort
        //
        if ( pIniMonitor->Monitor2.pfnAddPort ||
             pIniMonitor->Monitor2.pfnXcvOpenPort)
            cb+=GetMonitorSize(pIniMonitor, Level);
    }

    *pcbNeeded = cb;
    *pcReturned = 0;

    if (cb <= cbBuf) {

        pEnd=pMonitors + cbBuf;

        for ( pIniMonitor = pIniSpooler->pIniMonitor ;
              pIniMonitor ;
              pIniMonitor = pIniMonitor->pNext ) {

            //
            // We'll not enumerate monitors which do not support AddPort
            //
            if ( !pIniMonitor->Monitor2.pfnAddPort &&
                 !pIniMonitor->Monitor2.pfnXcvOpenPort )
                continue;

            pEnd = CopyIniMonitorToMonitor(pIniMonitor, Level, pMonitors, pEnd);

            switch (Level) {

            case 1:
                pMonitors+=sizeof(MONITOR_INFO_1);
                break;

            case 2:
                pMonitors+=sizeof(MONITOR_INFO_2);
                break;
            }

            (*pcReturned)++;
        }

        if( pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

            //
            // Stop routing, since we don't want any one else to report
            // back monitors.  If we're on the local machine now and
            // we continue routing, win32spl will RPC back to ourself
            // and re-enumerate the same ports.
            //
            rc = ROUTER_STOP_ROUTING;

        } else {

            rc = ROUTER_SUCCESS;
        }

    } else {

        rc = ROUTER_UNKNOWN;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

   LeaveSplSem();

    return rc;
}

BOOL
LocalAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddPort( pName, hWnd, pMonitorName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}





BOOL
SplAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR pIniMonitor;
    BOOL        rc=FALSE;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();
   SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );
   pIniMonitor = FindMonitor(pMonitorName, pIniSpooler);

   //
   // The monitor could be deleted while we are adding a port.
   //
   if (pIniMonitor) {
       INCMONITORREF(pIniMonitor);
   }

   LeaveSplSem();

    if ( pIniMonitor ) {

        if ( pIniMonitor->Monitor2.pfnAddPort )
            rc = (*pIniMonitor->Monitor2.pfnAddPort)(
                       pIniMonitor->hMonitor,
                       pName,
                       hWnd,
                       pMonitorName );
        else
            SetLastError(ERROR_INVALID_PARAMETER);
    }
    else {

        SetLastError(ERROR_INVALID_NAME);
    }

    if (rc)
        rc = AddPortToSpooler(pName, pIniMonitor, pIniSpooler);

    EnterSplSem();

    if (pIniMonitor) {
        DECMONITORREF(pIniMonitor);
    }

    LeaveSplSem();

    return rc;
}


BOOL
AddPortToSpooler(
    PCWSTR      pName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler
)
{
    DWORD i, cbNeeded, cbDummy, cReturned;
    PPORT_INFO_1    pPorts;
    PINIPORT        pIniPort;


    /* If we don't already have the port in our local cache, add it:
     */
    if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
               pIniMonitor->hMonitor,
               (PWSTR)pName,
               1,
               NULL,
               0,
               &cbNeeded,
               &cReturned)) {

        pPorts = AllocSplMem(cbNeeded);

        if (pPorts) {

            if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                      pIniMonitor->hMonitor,
                      (PWSTR)pName,
                      1,
                      (LPBYTE)pPorts,
                      cbNeeded,
                      &cbDummy,
                      &cReturned)) {

               EnterSplSem();

                for (i = 0 ; i < cReturned ; ++i) {

                    pIniPort = FindPort(pPorts[i].pName, pIniSpooler);
                    if ( !pIniPort ) {
                        CreatePortEntry(pPorts[i].pName, pIniMonitor, pIniSpooler);

                    //
                    // If we have a port without a monitor and it gets added at
                    // this time. Remove the placeholder status from it.
                    //
                    } else if ( !pIniPort->pIniMonitor ) {
                            pIniPort->pIniMonitor = pIniMonitor;
                            pIniPort->Status |= PP_MONITOR;
                            pIniPort->Status &= ~PP_PLACEHOLDER;
                    }
                }

               LeaveSplSem();
            }

            FreeSplMem(pPorts);
        }
    }

    EnterSplSem();
    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PORT,
                     pIniSpooler);
    LeaveSplSem();

    return TRUE;
}


BOOL
LocalConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplConfigurePort( pName, hWnd, pPortName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc = FALSE;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();

   pIniPort = FindPort(pPortName, pIniSpooler);

   //
   // Port could be deleted while we are configuring it.
   //
   if (pIniPort) {
       INCPORTREF(pIniPort);
   }

   LeaveSplSem();

    if ((pIniPort) && (pIniPort->Status & PP_MONITOR)) {

        if ( !pIniPort->pIniMonitor->Monitor2.pfnConfigurePort ) {

            SetLastError(ERROR_NOT_SUPPORTED);
        }
        else if (rc = (*pIniPort->pIniMonitor->Monitor2.pfnConfigurePort)(
                       pIniPort->pIniMonitor->hMonitor,
                       pName,
                       hWnd,
                       pPortName)) {

            EnterSplSem();

            SetPrinterChange(NULL,
                             NULL,
                             NULL,
                             PRINTER_CHANGE_CONFIGURE_PORT,
                             pIniSpooler);
            LeaveSplSem();
        }
    }
    else {

        SetLastError(ERROR_UNKNOWN_PORT);
    }

    EnterSplSem();

    if (pIniPort) {

        DECPORTREF(pIniPort);
    }

    LeaveSplSem();

    return rc;
}


BOOL
LocalDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePort( pName,
                             hWnd,
                             pPortName,
                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc=FALSE;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniPort = FindPort(pPortName, pIniSpooler);

    if ( !pIniPort || !(pIniPort->Status & PP_MONITOR) ) {
        LeaveSplSem();
        SetLastError(ERROR_UNKNOWN_PORT);
        return FALSE;
    }

    if( !pIniPort->pIniMonitor->Monitor2.pfnDeletePort ){
        LeaveSplSem();
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    rc = DeletePortFromSpoolerStart( pIniPort );

    LeaveSplSem();

    if (!rc)
        goto Cleanup;

    rc = (*pIniPort->pIniMonitor->Monitor2.pfnDeletePort)(
               pIniPort->pIniMonitor->hMonitor,
               pName,
               hWnd,
               pPortName);

    rc = DeletePortFromSpoolerEnd(pIniPort, pIniSpooler, rc);

Cleanup:
    SplOutSem();
    return rc;
}



BOOL
DeletePortFromSpoolerEnd(
    PINIPORT    pIniPort,
    PINISPOOLER pIniSpooler,
    BOOL        bSuccess
)
{

    EnterSplSem();

    if(bSuccess) {

        DeletePortEntry( pIniPort );

        //
        // Success, delete the port data and send a notification.
        //
        SetPrinterChange( NULL,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_DELETE_PORT,
                          pIniSpooler );
    } else {

        //
        // Add it back.  If the name is already used (e.g., just added
        // while we were out of the critical section), we're in trouble,
        // but there's not much we can do about it.  (When we restart,
        // we'll re-enumerate the duplicate name from the monitors
        // anyway.)
        //
        DBGMSG( DBG_WARN, ( "SplDeletePort: port.DeletePort failed %d\n", GetLastError()));
        LinkPortToSpooler( pIniPort, pIniSpooler );
    }

    LeaveSplSem();
    SplOutSem();

    return bSuccess;
}


BOOL
DeletePortFromSpoolerStart(
    PINIPORT    pIniPort
    )
{
    BOOL        rc = FALSE;
    PINISPOOLER pIniSpooler = pIniPort->pIniSpooler;

    SplInSem();

    if ( pIniPort->cPrinters || pIniPort->cRef || pIniPort->cJobs ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    //
    // Remove it from the linked list so that no one will try to grab
    // a reference to while we're deleting it.
    //
    DelinkPortFromSpooler( pIniPort, pIniSpooler );
    rc = TRUE;


Cleanup:

    return rc;
}



BOOL
LocalAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddMonitor( pName,
                             Level,
                             pMonitorInfo,
                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}


BOOL
SplAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    PINISPOOLER pIniSpooler
)
{
    PINIMONITOR  pIniMonitor;
    PMONITOR_INFO_2  pMonitor = (PMONITOR_INFO_2)pMonitorInfo;
    HANDLE  hToken;
    HKEY    hKey;
    LONG    Status;
    BOOL    rc = FALSE;
    DWORD   dwPathLen = 0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    if (Level != 2) {

        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    if (!pMonitor            ||
        !pMonitor->pName     ||
        !*pMonitor->pName) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!pMonitor->pEnvironment  ||
        !*pMonitor->pEnvironment ||
        lstrcmpi(pMonitor->pEnvironment, szEnvironment)) {

        SetLastError( ERROR_INVALID_ENVIRONMENT );
        return FALSE;
    }

    if (!pMonitor->pDLLName  ||
        !*pMonitor->pDLLName ){

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }


   EnterSplSem();

    if (FindMonitor(pMonitor->pName, pIniSpooler)) {

        LeaveSplSem();
        SetLastError(ERROR_PRINT_MONITOR_ALREADY_INSTALLED);
        return FALSE;
    }

    hToken = RevertToPrinterSelf();

    pIniMonitor = CreateMonitorEntry(pMonitor->pDLLName,
                                     pMonitor->pName,
                                     pIniSpooler);

    if (pIniMonitor != (PINIMONITOR)-1) {

        WCHAR   szRegistryRoot[MAX_PATH];
        PINISPOOLER pIniSpoolerMonitor;
        HANDLE hKeyOut;
        LPCWSTR pszPathOut;

        //
        // Note that even though this is built once per pIniSpooler, the
        // list of monitors is the same for all spoolers.  However, the
        // ports that the monitor returns from EnumPorts is different for
        // each pIniSpooler (for clustering).
        //
        // If it's not local, then it could be a cached win32 monitor.
        //
        if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
            pIniSpoolerMonitor = pLocalIniSpooler;
        } else {
            pIniSpoolerMonitor = pIniSpooler;
        }

        //
        // Build the registry path.  In some cases it's a relative
        // path from hckRoot; other times it's a hard coded path from
        // HKLM (e.g., win32spl).
        //
        GetRegistryLocation( pIniSpoolerMonitor->hckRoot,
                             pIniSpoolerMonitor->pszRegistryMonitors,
                             &hKeyOut,
                             &pszPathOut );

        Status = StrNCatBuff( szRegistryRoot,
                              COUNTOF(szRegistryRoot),
                              pszPathOut,
                              L"\\",
                              pMonitor->pName,
                              NULL );

        if (Status == ERROR_SUCCESS)
        {

            Status = RegCreateKeyEx( hKeyOut,
                                     szRegistryRoot,
                                     0,
                                     NULL,
                                     0,
                                     KEY_WRITE,
                                     NULL,
                                     &hKey,
                                     NULL );

            if (Status == ERROR_SUCCESS) {

                Status = RegSetValueEx( hKey,
                                        L"Driver",
                                        0,
                                        REG_SZ,
                                        (LPBYTE)pMonitor->pDLLName,
                                        (wcslen(pMonitor->pDLLName) + 1)*sizeof(WCHAR));

                if (Status == ERROR_SUCCESS) {
                    rc = TRUE;
                } else {
                    SetLastError( Status );
                }

                RegCloseKey(hKey);

            } else {
                SetLastError( Status );
            }
        }
        else
        {
            SetLastError(Status);
        }

    }

    if(!ImpersonatePrinterClient(hToken))
    {
        rc = FALSE;
    }

    //
    //  Bug 54843 if this fails we could still have a IniMonitor on the linked list that
    //  is BAD, it should be removed.
    //  Note *maybe* we do this because a monitor might fail to initialize
    //  but will correctly function next time you reboot, like hpmon ( dlc doesn't become active until
    //  the next reboot.   Please Verify.

   LeaveSplSem();

    if ( !rc ) {
        DBGMSG( DBG_WARNING, ("SplAddMonitor failed %d\n", GetLastError() ));
    }

    return rc;
}

BOOL
LocalDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeleteMonitor( pName,
                                pEnvironment,
                                pMonitorName,
                                pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}




BOOL
SplDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
    BOOL    Remote=FALSE;
    PINIMONITOR pIniMonitor;
    PINIPORT    pIniPort, pIniPortNext;
    HKEY    hKeyMonitors, hKey;
    LONG    Status;
    BOOL    rc = FALSE;
    HANDLE  hToken;
    HANDLE hKeyOut;
    LPCWSTR pszPathOut;

    if (pName && *pName) {

        if (!MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            Remote=TRUE;
        }
    }

    if ((pMonitorName == NULL) || (*pMonitorName == L'\0')) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    if (!(pIniMonitor=(PINIMONITOR)FindMonitor(pMonitorName,
                                               pIniSpooler))) {

        SetLastError(ERROR_UNKNOWN_PRINT_MONITOR);
        LeaveSplSem();
        return FALSE;
    }

    if ( pIniMonitor->cRef ) {

        SetLastError(ERROR_PRINT_MONITOR_IN_USE);
        LeaveSplSem();
        return FALSE;
    }

    pIniPort = pIniSpooler->pIniPort;

    while (pIniPort) {

        if ((pIniPort->pIniMonitor == pIniMonitor) &&
            (pIniPort->cPrinters || pIniPort->cRef)) {

            SetLastError(ERROR_BUSY);
            LeaveSplSem();
            return FALSE;
        }

        pIniPort = pIniPort->pNext;
    }

    hToken = RevertToPrinterSelf();

    GetRegistryLocation( pIniSpooler->hckRoot,
                         pIniSpooler->pszRegistryMonitors,
                         &hKeyOut,
                         &pszPathOut );

    Status = SplRegOpenKey(hKeyOut,
                           pszPathOut,
                           KEY_READ | KEY_WRITE | DELETE,
                           &hKeyMonitors,
                           pIniSpooler);

    if (Status == ERROR_SUCCESS)
    {
        Status = SplRegOpenKey(hKeyMonitors,
                               pMonitorName,
                               KEY_READ | KEY_WRITE,
                               &hKey,
                               pIniSpooler);

        if (Status == ERROR_SUCCESS)
        {
            Status = DeleteSubkeys(hKey, pIniSpooler);

            SplRegCloseKey(hKey, pIniSpooler);

            if (Status == ERROR_SUCCESS)
                Status = SplRegDeleteKey(hKeyMonitors, pMonitorName, pIniSpooler);
        }

        SplRegCloseKey(hKeyMonitors, pIniSpooler);
    }


    if (Status == ERROR_SUCCESS) {

        pIniPort = pIniSpooler->pIniPort;

        while (pIniPort) {

            pIniPortNext = pIniPort->pNext;

            if (pIniPort->pIniMonitor == pIniMonitor)
                DeletePortEntry(pIniPort);

            pIniPort = pIniPortNext;
        }

        RemoveFromList((PINIENTRY *)&pIniSpooler->pIniMonitor,
                       (PINIENTRY)pIniMonitor);

        FreeIniMonitor( pIniMonitor );

        rc = TRUE;

    }

    if (Status != ERROR_SUCCESS)
        SetLastError(Status);

    if(!ImpersonatePrinterClient(hToken))
    {
        rc = FALSE;
    }

    LeaveSplSem();

    return rc;
}

LPBYTE
CopyIniMonitorToMonitor(
    PINIMONITOR pIniMonitor,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    DWORD j;
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = MonitorInfo1Strings;
        break;

    case 2:
        pOffsets = MonitorInfo2Strings;
        break;

    default:
        return pEnd;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if (!SourceStrings) {
        DBGMSG(DBG_WARNING, ("Failed to alloc Port source strings.\n"));
        return pEnd;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniMonitor->pName;
        break;

    case 2:
        *pSourceStrings++=pIniMonitor->pName;
        *pSourceStrings++=szEnvironment;
        *pSourceStrings++=pIniMonitor->pMonitorDll;
        break;
    }

    pEnd = PackStrings(SourceStrings, pMonitorInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);

    return pEnd;
}

DWORD
GetMonitorSize(
    PINIMONITOR  pIniMonitor,
    DWORD       Level
)
{
    DWORD cb=0;

    switch (Level) {

    case 1:
        cb=sizeof(MONITOR_INFO_1) + wcslen(pIniMonitor->pName)*sizeof(WCHAR) +
                                    sizeof(WCHAR);
        break;

    case 2:
        cb = wcslen(pIniMonitor->pName) + 1 + wcslen(pIniMonitor->pMonitorDll) + 1
                                            + wcslen(szEnvironment) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(MONITOR_INFO_2);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}


BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    return  ( SplAddPortEx( pName,
                            Level,
                            pBuffer,
                            pMonitorName,

                            pLocalIniSpooler ));
}


BOOL
SplAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName,
    PINISPOOLER pIniSpooler
)
{
   PINIMONITOR pIniMonitor;
    BOOL        rc=FALSE;
    DWORD       i, cbNeeded, cReturned, cbDummy;
    PPORT_INFO_1    pPorts = NULL;
    PINIPORT        pIniPort;

    SplOutSem();

    //
    // At this time we do not know if the server name in pName refers to our local
    // machine. We are trying to add the server name to the name cache. The name
    // cache functions decide if the name refers to the local machine and if positive,
    // add an entry for it in the cache.
    //
    CacheAddName(pName);

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

   EnterSplSem();
   pIniMonitor = FindMonitor(pMonitorName, pIniSpooler);
   LeaveSplSem();

   if (!pIniMonitor) {
       SetLastError(ERROR_INVALID_NAME);
       return(FALSE);
   }

   if (pIniMonitor->Monitor2.pfnAddPortEx) {
    rc = (*pIniMonitor->Monitor2.pfnAddPortEx)(
               pIniMonitor->hMonitor,
               pName,
               Level,
               pBuffer,
               pMonitorName);
   }
   if (!rc) {
       return(FALSE);
   }

   if (!(*pIniMonitor->Monitor2.pfnEnumPorts)(
              pIniMonitor->hMonitor,
              pName,
              1,
              NULL,
              0,
              &cbNeeded,
              &cReturned)) {

       pPorts = AllocSplMem(cbNeeded);
   }

   if (pPorts) {
       if ((*pIniMonitor->Monitor2.pfnEnumPorts)(
                 pIniMonitor->hMonitor,
                 pName,
                 1,
                 (LPBYTE)pPorts,
                 cbNeeded,
                 &cbDummy,
                 &cReturned)) {

           EnterSplSem();

           for (i = 0; i < cReturned; i++) {

                pIniPort = FindPort(pPorts[i].pName, pIniSpooler);
                if ( !pIniPort ) {
                    CreatePortEntry(pPorts[i].pName, pIniMonitor, pIniSpooler);

                } else if ( !pIniPort->pIniMonitor ) {
                    pIniPort->pIniMonitor = pIniMonitor;
                    pIniPort->Status |= PP_MONITOR;
                }
           }
           LeaveSplSem();
       }

       FreeSplMem(pPorts);
   }

    EnterSplSem();
    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_ADD_PORT,
                     pIniSpooler);
    LeaveSplSem();

    return rc;
}


VOID
LinkPortToSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Links a pIniPort onto the pIniSpooler.

Arguments:

    pIniPort - Port to link; must not already be on a ll.

    pIniSpooler - Provides ll for pIniPort.

Return Value:

--*/

{
    SplInSem();
    SPLASSERT( !pIniPort->pIniSpooler );

    pIniPort->pNext = pIniSpooler->pIniPort;
    pIniPort->pIniSpooler = pIniSpooler;
    pIniSpooler->pIniPort = pIniPort;
}

VOID
DelinkPortFromSpooler(
    PINIPORT pIniPort,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Remove a pIniPort from a pIniSpooler->pIniPort linked list.  The
    pIniPort may or may not be on the list; if it isn't, then this
    routine does nothing.

    Generic delink code ripped out into a subroutine.

    The refcount on pIniPort must be zero.  Anyone that uses pIniPort
    must hold a reference, since it may be deleted outside the
    SplSem when cRef==0.

Arguments:

    pIniPort - Port to delink from the list.  May or may not be on
        pIniSpooler->pIniPort.

    pIniSpooler - Linked list from which the pIniPort will be removed.

Return Value:

--*/

{
    PINIPORT *ppCurPort;

    SplInSem();
    SPLASSERT( !pIniPort->cRef );

    //
    // Keep searching for pIniPort until we hit the end of the
    // list or we've found it.
    //
    for( ppCurPort = &pIniSpooler->pIniPort;
         *ppCurPort && *ppCurPort != pIniPort;
         ppCurPort = &((*ppCurPort)->pNext )){

        ; // Don't do anything.
    }

    //
    // If we found it, delink it.
    //
    if( *ppCurPort ){
        *ppCurPort = (*ppCurPort)->pNext;

        //
        // Null out the back pointer since we have removed it from
        // the pIniSpooler.
        //
        pIniPort->pIniSpooler = NULL;
    }
}

/*++
    Function Name:
        LocalSendRecvBidiData

    Description:
        This function is the providor point of communicating with
        Monitors supporting BIDI data. It allows the providor to
        set data in the printer and query data from the printer

     Parameters:
        hPrinter    : This could be a Printer/Port Handle
        dwAccessBit : Priverledges allowed to the accessing thread
        pAction     :
        pReqData    : Request encapsulatig the queries in an array
        ppResData   : Response returned to client in an array of Data


     Return Value:
        Win32 Error Code
--*/

DWORD
LocalSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD        dwRet        = ERROR_SUCCESS;
    PSPOOL       pSpool       = (PSPOOL)hPrinter;
    PINIPORT     pIniPort     = NULL;
    PINIMONITOR  pIniMonitor  = NULL;
    PINIMONITOR  pIniLangMonitor = NULL;
    PINIPRINTER  pIniPrinter  = NULL;                    
    LPTSTR       pszPrinter   = NULL;
    TCHAR        szFullPrinter[ MAX_UNC_PRINTER_NAME ];

    EnterSplSem();
    
    //
    // Process of validating the parameters
    //
    if((!pAction || !*pAction)   ||
       (!pReqData && !ppResData))
    {
        dwRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if (!ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER ))
        {
            dwRet = ERROR_INVALID_HANDLE;
        }
        else
        {
            if(pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER)
            {                    
                if ((pIniPrinter = pSpool->pIniPrinter) && 
                    (pIniPort = FindIniPortFromIniPrinter(pIniPrinter)) && 
                    (pIniPort->Status & PP_MONITOR))
                {
                    pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;

                    if (pIniLangMonitor &&
                        !pIniLangMonitor->Monitor2.pfnSendRecvBidiDataFromPort)
                    {
                        pIniLangMonitor = NULL;
                    }
                              
                    if (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
                    {
                        pszPrinter = szFullPrinter;

                        dwRet = StatusFromHResult(StringCchPrintf(szFullPrinter,
                                                                  COUNTOF(szFullPrinter),
                                                                  L"%ws\\%ws",
                                                                  pIniPrinter->pIniSpooler->pMachineName,
                                                                  pIniPrinter->pName));
                    } 
                    else 
                    {
                        pszPrinter = pIniPrinter->pName;
                    }
                }
                else
                {
                    dwRet = ERROR_INVALID_HANDLE;
                }
            }
            else if(pSpool->TypeofHandle & PRINTER_HANDLE_PORT &&
                    (pSpool->pIniPort->Status & PP_MONITOR))
            {
                pIniPort = pSpool->pIniPort;
            }
            else
            {
                dwRet = ERROR_INVALID_HANDLE;
            }

            if (dwRet == ERROR_SUCCESS)
            {    	 
                //
                // Port always must be opened
                //
                dwRet = StatusFromHResult(OpenMonitorPort(pIniPort,
                                                          pIniLangMonitor,
                                                          pszPrinter));

                if (dwRet == ERROR_SUCCESS)
                {
                    pIniMonitor = GetOpenedMonitor(pIniPort);

                    //
                    // Calling into the monitor
                    //
                    if(pIniMonitor->Monitor2.pfnSendRecvBidiDataFromPort)
                    {
                        LeaveSplSem();
                        SplOutSem();

                        dwRet = (*pIniMonitor->Monitor2.pfnSendRecvBidiDataFromPort)(GetMonitorHandle(pIniPort),
                                                                                     pSpool->GrantedAccess,
                                                                                     pAction,
                                                                                     pReqData,
                                                                                     ppResData);
                        EnterSplSem();                        
                    }
                    else
                    {
                        //
                        // Here we could use a simulation code;
                        //
                        dwRet = ERROR_NOT_SUPPORTED;
                    }
                    
                    ReleaseMonitorPort(pIniPort);
                } 
            }
        }
    }

    LeaveSplSem();

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\net.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module provides all the network stuuf for localspl

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Notes:

    We just need to get the winspool printer name associated with a given
    queue name.   The SHARE_INFO_2 structure has a shi2_path field that would
    be nice to use, but NetShareGetInfo level 2 is privileged.  So, by
    DaveSn's arm twisting and agreement with windows/spooler/localspl/net.c,
    we're going to use the shi1_remark field for this.  This allows us to
    do NetShareGetInfo level 1, which is not privileged.

    This has been fixed by allowing OpenPrinter to succeed on share names.
    If there is no comment, we put the printer name in as the remark
    (for graceful upgrades from pre-PPC).

Revision History:

    Jun 93 mattfe pIniSpooler

--*/

#define UNICODE 1

#define NOMINMAX

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#ifdef DBG_SHARE
#include <messages.h>
#endif



NET_API_STATUS (*pfnNetShareAdd)();
NET_API_STATUS (*pfnNetShareSetInfo)();
NET_API_STATUS (*pfnNetShareDel)();
NET_API_STATUS (*pfnNetServerEnum)();
NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
NET_API_STATUS (*pfnNetApiBufferFree)();
NET_API_STATUS (*pfnNetAlertRaiseEx)();
NET_API_STATUS (*pfnNetShareGetInfo)(LPWSTR, LPWSTR, DWORD, LPBYTE *);

extern  SHARE_INFO_2 PrintShareInfo;
extern  SHARE_INFO_2 PrtProcsShareInfo;

BOOL
InitializeNet(
    VOID
)
{
    HANDLE  hNetApi;
    UINT    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hNetApi = LoadLibrary(TEXT("netapi32.dll"));

    SetErrorMode(uOldErrorMode);
    if ( !hNetApi )
        return FALSE;

    pfnNetShareAdd = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareAdd");
    pfnNetShareSetInfo = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareSetInfo");
    pfnNetShareDel = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetShareDel");
    pfnNetServerEnum = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetServerEnum");
    pfnNetWkstaUserGetInfo = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetWkstaUserGetInfo");
    pfnNetApiBufferFree = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetApiBufferFree");
    pfnNetAlertRaiseEx = (NET_API_STATUS (*)()) GetProcAddress(hNetApi,"NetAlertRaiseEx");
    pfnNetShareGetInfo = (NET_API_STATUS (*)(LPWSTR, LPWSTR, DWORD, LPBYTE *))GetProcAddress(hNetApi, "NetShareGetInfo");

    if ( pfnNetShareAdd == NULL ||
         pfnNetShareSetInfo == NULL ||
         pfnNetShareDel == NULL ||
         pfnNetServerEnum == NULL ||
         pfnNetWkstaUserGetInfo == NULL ||
         pfnNetApiBufferFree == NULL ||
         pfnNetAlertRaiseEx == NULL ||
         pfnNetShareGetInfo == NULL) {

        return FALSE;
    }

    return TRUE;
}


BOOL
SetPrinterShareInfo(
    PINIPRINTER pIniPrinter
    )

/*++

Routine Description:

    Sets the share information about a printer.

    Note: This does not update the share path.  We need to
    delete and re-create the share in order to change the path.

Arguments:

    pIniPrinter - Printer that needs to be updated.

Return Value:

    TRUE - Success
    FALSE - Failed

--*/

{
    SHARE_INFO_502          ShareInfo;
    HANDLE                  hToken;
    PSECURITY_DESCRIPTOR    pShareSecurityDescriptor = NULL;
    DWORD                   ParmError, rc;

    SplInSem();

    pShareSecurityDescriptor = MapPrinterSDToShareSD(pIniPrinter->pSecurityDescriptor);

    if ( !pShareSecurityDescriptor ) {

        rc = ERROR_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    ZeroMemory((LPVOID)&ShareInfo, sizeof(ShareInfo));

    ShareInfo.shi502_netname                = pIniPrinter->pShareName;
    ShareInfo.shi502_type                   = STYPE_PRINTQ;
    ShareInfo.shi502_permissions            = 0;
    ShareInfo.shi502_max_uses               = SHI_USES_UNLIMITED;
    ShareInfo.shi502_current_uses           = SHI_USES_UNLIMITED;
    ShareInfo.shi502_passwd                 = NULL;
    ShareInfo.shi502_security_descriptor    = pShareSecurityDescriptor;

    if ( pIniPrinter->pComment && pIniPrinter->pComment[0] ) {

        ShareInfo.shi502_remark = pIniPrinter->pComment;

    } else {

        ShareInfo.shi502_remark = pIniPrinter->pName;
    }


    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();

    SplOutSem();  // We *MUST* be out of our semaphore as the NetShareSet may
                  // come back and call spooler

    hToken = RevertToPrinterSelf();

    rc = (*pfnNetShareSetInfo)(NULL,
                               ShareInfo.shi502_netname,
                               502,
                               &ShareInfo,
                               &ParmError);

    if ( rc ) {

        if (rc == NERR_NetNameNotFound)
        {
            //
            // This can happen deny all access to a shared printer, then
            // restart the computer.  The server service tries to validate
            // it's share on startup, but since it has no access, it fails
            // and deletes it (it also wants a handle to the printer).  When
            // you grant everyone access, we try to change the ACL on the
            // SMB share, but since it was deleted, we fail.  Recreate
            // the share here.
            //
            EnterSplSem();

            if (!ShareThisPrinter(pIniPrinter,
                                  pIniPrinter->pShareName,
                                  TRUE)) {
                rc = GetLastError();
            } else {

                rc = ERROR_SUCCESS;
            }

            LeaveSplSem();
        }

        if (rc) {

            DBGMSG(DBG_WARNING,
                   ("NetShareSetInfo/ShareThisPrinter failed: Error %d, Parm %d\n",
                    rc, ParmError));

            SetLastError(rc);
        }
    }

    ImpersonatePrinterClient(hToken);

    EnterSplSem();
    DECPRINTERREF(pIniPrinter);

Cleanup:
    SplInSem();

    LocalFree(pShareSecurityDescriptor);

    return rc == ERROR_SUCCESS;
}


BOOL
ShareThisPrinter(
    PINIPRINTER pIniPrinter,
    LPWSTR   pShareName,
    BOOL     bShare
    )
/*++

Routine Description:

    Shares or UnShares a Printer.

    Note: this really should be two functions, and the return value
    is very confusing.

    Note: no validation of sharename is done.  This must be done by
    callee, usually in ValidatePrinterInfo.

Arguments:

Return Value:

    Returns whether the printer is shared after this call.

        TRUE  - Shared
        FALSE - Not Shared

--*/
{
    SHARE_INFO_502    ShareInfo = {0};
    DWORD   rc;
    DWORD   ParmError;
    PSECURITY_DESCRIPTOR pShareSecurityDescriptor = NULL;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    LPTSTR pszPrinterNameWithToken = NULL;
    HRESULT hr;

    HANDLE  hToken;
    BOOL    bReturn = FALSE;
    BOOL    bSame   = FALSE;
    LPWSTR  pShareNameCopy = NULL;

    SPLASSERT( pIniPrinter->pName );
    SplInSem();

    pShareNameCopy = AllocSplStr(pShareName);

    if (!pShareNameCopy) {
        goto Done;
    }

    if ( bShare ) {

        if (!pfnNetShareAdd) {
            SetLastError( ERROR_PROC_NOT_FOUND );
            goto Done;
        }

        //
        // Share name validation has been moved into ValidatePrinterInfo.
        //

        if ((pShareSecurityDescriptor =
            MapPrinterSDToShareSD(pIniPrinter->pSecurityDescriptor)) == NULL) {
            SetLastError(ERROR_INVALID_SECURITY_DESCR);
            goto Done;
        }

        ShareInfo.shi502_netname = pShareNameCopy;  // hplaser

        //
        // If there is a comment, use it; otherwise set the remark
        // to be the printer name.
        //
        // Note: if the printer name changes and we don't have a comment,
        // we will reshare the printer to update the remark.
        //
        if( pIniPrinter->pComment && pIniPrinter->pComment[0] ){

            ShareInfo.shi502_remark = pIniPrinter->pComment;

        } else {

            ShareInfo.shi502_remark = pIniPrinter->pName;
        }

        //
        // Use the fully qualifed name, and make sure it exists in
        // localspl by using LocalsplOnlyToken.
        //
        pszPrinterNameWithToken = pszGetPrinterName(
                                      pIniPrinter,
                                      pIniSpooler != pLocalIniSpooler,
                                      pszLocalsplOnlyToken );

        if( !pszPrinterNameWithToken ){
            goto Done;
        }

        ShareInfo.shi502_path = pszPrinterNameWithToken;
        ShareInfo.shi502_type = STYPE_PRINTQ;
        ShareInfo.shi502_permissions = 0;
        ShareInfo.shi502_max_uses = SHI_USES_UNLIMITED;
        ShareInfo.shi502_current_uses = SHI_USES_UNLIMITED;
        ShareInfo.shi502_passwd = NULL;
        ShareInfo.shi502_security_descriptor = pShareSecurityDescriptor;

        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();

        //
        // We *MUST* be out of our semaphore as the NetShareAdd is
        // going to come round and call OpenPrinter.
        //
        SplOutSem();

        // Go add the Print Share

        hToken = RevertToPrinterSelf();

        //
        // Add a share for the spool\drivers directory:
        //
        if (rc = AddPrintShare(pIniSpooler))
        {
            if (rc != NERR_ServerNotStarted)
            {
                EnterSplSem();
                DECPRINTERREF(pIniPrinter);
                ImpersonatePrinterClient(hToken);

                SetLastError(rc);
                goto Done;
            }
        }

#if DBG
        {
            WCHAR UserName[256];
            DWORD cbUserName=256;

            if (MODULE_DEBUG & DBG_SECURITY)
                GetUserName(UserName, &cbUserName);

            DBGMSG( DBG_SECURITY, ( "Calling NetShareAdd in context %ws\n", UserName ) );
        }
#endif

        //
        // Add the printer share. Even if we failed above because Server Service is not started,
        // we still want to try. At boot time, it's worthwhile, since the Server service might
        // start accepting calls if it's done initializing.
        //
        rc = (*pfnNetShareAdd)(NULL, 502, (LPBYTE)&ShareInfo, &ParmError);

        //
        // Now take care of Web sharing. i.e. make sure wwwroot\sharename is created if the
        // printer is either local or masqurading. We cannot allow sharing of RPC connections.
        //
        if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL)
        {
            WebShare( pShareNameCopy );
        }

        //
        // If the return code is that the share already exists, then check to
        // see whether this share is to the same device, if it is we just
        // update the info on the share and return success.
        //
        if (rc == NERR_DuplicateShare) {

            if (ERROR_SUCCESS == CheckShareSame(pIniPrinter, &ShareInfo, &bSame) && bSame)  {

                rc = ERROR_SUCCESS;
            }
        }

        //
        // Allow remote connections by calling into spoolsv and register the named pipe protocol.
        // The server keeps track of these calls, so doing it for each share is fine.
        // This is policy driven. The policy value is read in spoolsv.
        //
        if ((rc == ERROR_SUCCESS || rc == NERR_ServerNotStarted) &&
            FAILED(hr = AllowRemoteCalls()))
        {
            //
            // If we fail enabling the RPC named pipe, then just unshare the printer
            // and fail the call.
            // A futher attempt to share the printer will try again to enable the RPC pipe.
            //
            if (rc == ERROR_SUCCESS)
            {
                (*pfnNetShareDel)(NULL, ShareInfo.shi502_netname, 0);
            }

            rc = HRESULT_CODE(hr);
        }

        ImpersonatePrinterClient(hToken);

        EnterSplSem();
        DECPRINTERREF(pIniPrinter);

        if (ERROR_SUCCESS != rc) {

            DBGMSG( DBG_WARNING,
                    ( "NetShareAdd failed %lx, Parameter %d\n",
                      rc, ParmError ));

            if ((rc == ERROR_INVALID_PARAMETER) &&
                (ParmError == SHARE_NETNAME_PARMNUM)) {

                rc = ERROR_INVALID_SHARENAME;
            }

            SetLastError(rc);
            goto Done;

        }

        SPLASSERT( pIniPrinter != NULL);
        SPLASSERT( pIniPrinter->signature == IP_SIGNATURE);
        SPLASSERT( pIniPrinter->pIniSpooler != NULL);
        SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

        CreateServerThread();

        //
        // The Printer is shared.
        //
        bReturn = TRUE;

    } else {

        if ( !pfnNetShareDel ) {
            bReturn = TRUE;
            goto Done;

        }

        INCPRINTERREF( pIniPrinter );
        LeaveSplSem();

        SplOutSem();

        hToken = RevertToPrinterSelf();
       
        rc = hToken ? ERROR_SUCCESS : GetLastError();

        if ( rc == ERROR_SUCCESS ) {

            rc = (*pfnNetShareDel)(NULL, pShareName, 0);

            // Now take care of Web unsharing. i.e. make sure wwwroot\sharename is deleted.
            if((pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) && !(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER))
                WebUnShare( pShareName );             
        }

        if ( hToken ) {

            if ( !ImpersonatePrinterClient(hToken) && rc == ERROR_SUCCESS ) {
                rc = GetLastError();
            }
        }


        EnterSplSem();
        DECPRINTERREF(pIniPrinter);

        // The share may have been deleted manually, so don't worry
        // if we get NERR_NetNameNotFound:

        if ( rc && ( rc != NERR_NetNameNotFound )){

            DBGMSG(DBG_WARNING, ("NetShareDel failed %lx\n", rc));
            SetLastError( rc );
            bReturn = TRUE;
        }
    }

Done:

    if( pShareSecurityDescriptor ){
        LocalFree(pShareSecurityDescriptor);
    }

    FreeSplStr(pszPrinterNameWithToken);
    FreeSplStr(pShareNameCopy);

    return bReturn;
}


/*--
    FillAlertStructWithJobStrings

    Allocates memory which has to be freed by caller.



--*/

HRESULT
FillAlertStructWithJobStrings(
    PINIJOB pIniJob,
    PRINT_OTHER_INFO **pAlertInfo,
    PDWORD size
    )
{
    HRESULT RetVal = E_FAIL;
    DWORD   cchSizeToAlloc = 0;
    PBYTE   pBuffer = NULL;
    LPWSTR  psz = NULL;


    if (pIniJob && pAlertInfo && !(*pAlertInfo) && size)
    {
        //
        // Do this in the splSem so that no one can jo a SetJob While we're not looking
        //
        EnterSplSem();

        //
        // We don't know how big these strings are going to be in future, so size
        // them dynamically and alloc the structure to always be big enough.
        //
        cchSizeToAlloc = sizeof(PRINT_OTHER_INFO);

        //
        // We don't have to check some of these for existence, we know they exist.
        //
        cchSizeToAlloc += wcslen(pIniJob->pNotify) + 1 +
                          wcslen(pIniJob->pIniPrinter->pName) + 1 +
                          wcslen(pIniJob->pIniPrinter->pIniSpooler->pMachineName) + 1;

        if ( pIniJob->pDocument )
        {
            cchSizeToAlloc += wcslen(pIniJob->pDocument) + 1;
        }
        else
        {
            cchSizeToAlloc += 2;
        }

        if (pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopupToComputer &&
            pIniJob->pMachineName)
        {
            cchSizeToAlloc += wcslen(pIniJob->pMachineName) + 1;
        }
        else
        {
            cchSizeToAlloc += wcslen(pIniJob->pNotify) + 1;
        }

        if ( pIniJob->pStatus )
        {
            cchSizeToAlloc += wcslen(pIniJob->pStatus) + 1;
        }
        else
        {
            cchSizeToAlloc += 2;
        }

        //
        // Alloc the memory
        //
        pBuffer = AllocSplMem(cchSizeToAlloc * sizeof(WCHAR));

        if ( pBuffer )
        {
            SIZE_T      cchRemaining = cchSizeToAlloc;

            psz = (LPWSTR)ALERT_VAR_DATA((PRINT_OTHER_INFO *)pBuffer);

            //
            // We know that pBuffer will at a minimum be as big as a PRINT_OTHER_INFO.
            //
            cchRemaining -= sizeof(PRINT_OTHER_INFO);

            //
            // Do the copying
            //

            //
            // Computer Name
            //
            if(pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopupToComputer &&
                pIniJob->pMachineName ){

                StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pMachineName, &psz, &cchRemaining);

            } else {

                StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pNotify, &psz, &cchRemaining);
            }


            //
            // UserName
            //
            StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pNotify, &psz, &cchRemaining);

            //
            // Document Name
            //
            if (pIniJob->pDocument)
                StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pDocument, &psz, &cchRemaining);
            else
                StrCchCopyMultipleStr(psz, cchRemaining, L"", &psz, &cchRemaining);

            //
            // Printer Name
            //
            StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pIniPrinter->pName, &psz, &cchRemaining);

            //
            // Server Name
            //
            StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pIniPrinter->pIniSpooler->pMachineName, &psz, &cchRemaining);

            //
            // Status_string
            // We should pass in other status strings for the other status errors, too.
            //
            if (pIniJob->pStatus && (pIniJob->Status & (JOB_ERROR | JOB_OFFLINE | JOB_PAPEROUT)))
                StrCchCopyMultipleStr(psz, cchRemaining, pIniJob->pStatus, &psz, &cchRemaining);
            else
                StrCchCopyMultipleStr(psz, cchRemaining, L"", &psz, &cchRemaining);

            //
            // Pass back the size and struct
            //
            *size = (DWORD)((PBYTE)psz - pBuffer);
            *pAlertInfo = (PRINT_OTHER_INFO *)pBuffer;
            RetVal = NOERROR;

        }
        else
        {
            RetVal = E_OUTOFMEMORY;
        }
        //
        // Leave the Spooler Semaphore
        //
        LeaveSplSem();

    }
    else
    {
        RetVal = E_INVALIDARG;
    }

    return RetVal;

}

VOID
SendJobAlert(
    PINIJOB pIniJob
    )
{
    PRINT_OTHER_INFO *pinfo = NULL;
    DWORD   RetVal = ERROR_SUCCESS;
    DWORD   Status;
    FILETIME    FileTime;
    DWORD  AlertSize = 0;

    //
    // Allow Hydra Sessions to be notified since they are remote
    //
    if( (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) ) {
        if ( !pIniJob->pNotify               ||
             !pIniJob->pNotify[0]            ||
             !pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups ) {
             return;
        }
    }
    else {
        if ( !pIniJob->pNotify               ||
             !pIniJob->pNotify[0]            ||
             !(pIniJob->Status & JOB_REMOTE) ||
             !pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups ) {
             return;
        }
    }

    if ( FAILED(RetVal = FillAlertStructWithJobStrings(pIniJob, &pinfo, &AlertSize)))
    {
        if ( pinfo )
            FreeSplMem(pinfo);

        return;
    }

    pinfo->alrtpr_jobid = pIniJob->JobId;

    if (pIniJob->Status & (JOB_PRINTING | JOB_DESPOOLING | JOB_PRINTED | JOB_COMPLETE))
        Status = PRJOB_QS_PRINTING;
    else if (pIniJob->Status & JOB_PAUSED)
        Status = PRJOB_QS_PAUSED;
    else if (pIniJob->Status & JOB_SPOOLING)
        Status = PRJOB_QS_SPOOLING;
    else
        Status = PRJOB_QS_QUEUED;

    if (pIniJob->Status & (JOB_ERROR | JOB_OFFLINE | JOB_PAPEROUT)) {

        Status |= PRJOB_ERROR;

        if (pIniJob->Status & JOB_OFFLINE)
            Status |= PRJOB_DESTOFFLINE;

        if (pIniJob->Status & JOB_PAPEROUT)
            Status |= PRJOB_DESTNOPAPER;
    }

    if (pIniJob->Status & JOB_PRINTED)
        Status |= PRJOB_COMPLETE;

    else if (pIniJob->Status & JOB_PENDING_DELETION)
        Status |= PRJOB_DELETED;

    pinfo->alrtpr_status = Status;

    SystemTimeToFileTime( &pIniJob->Submitted, &FileTime );

    //    FileTimeToDosDateTime(&FileTime, &DosDate, &DosTime);
    //    pinfo->alrtpr_submitted  = DosDate << 16 | DosTime;

    RtlTimeToSecondsSince1970((PLARGE_INTEGER) &FileTime,
                              &pinfo->alrtpr_submitted);

    pinfo->alrtpr_size       = pIniJob->Size;


    (*pfnNetAlertRaiseEx)(ALERT_PRINT_EVENT,
                          (PBYTE) pinfo,
                          AlertSize,
                          L"SPOOLER");

    if ( pinfo )
        FreeSplMem(pinfo);
}

DWORD
AddPrintShare(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Adds the print$ share based on pIniSpooler.

Arguments:

    pIniSpooler - Share path is based on this information.  pDriversShareInfo
        must be initialized before calling this routine.

Return Value:

    TRUE - Success.

    FALSE - Failed.  LastError set.

--*/
{
    DWORD rc;
    DWORD ParmError;
    SHARE_INFO_1501 ShareInfo1501 = {0};
    PSHARE_INFO_2 pShareInfo = (PSHARE_INFO_2)pIniSpooler->pDriversShareInfo;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    //
    // Assert that the path is identical to the local one since there's
    // only one print$ share.  It should always be.
    //
    SPLASSERT( !lstrcmpi( pShareInfo->shi2_path,
                          ((PSHARE_INFO_2)pLocalIniSpooler->pDriversShareInfo)->shi2_path ));

    rc = (*pfnNetShareAdd)( NULL,
                            2,
                            (LPBYTE)pShareInfo,
                            &ParmError );

    //
    // If it already exists, assume it is set up correctly.
    //
    if( rc == NERR_DuplicateShare ){
        return ERROR_SUCCESS;
    }

    //
    // If we didn't create the share, fail.
    //
    if( rc != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "AddPrintShare: Error %d, Parm %d\n", rc, ParmError));

        return rc;
    }

    //
    // Set security on the newly created share.
    //
    // Bug 54844
    // If this fails, we've created the share but haven't put security
    // on it.  Then since it exists, we'll never try and set it again.
    //

    pSecurityDescriptor = CreateDriversShareSecurityDescriptor();

    if( !pSecurityDescriptor ){
        return GetLastError();
    }

    ShareInfo1501.shi1501_security_descriptor = pSecurityDescriptor;

    rc = (*pfnNetShareSetInfo)( NULL,
                                pShareInfo->shi2_netname,
                                1501,
                                &ShareInfo1501,
                                &ParmError );

    if( rc != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "NetShareSetInfo failed: Error %d, Parm %d\n",
                  rc, ParmError));
    }

    LocalFree(pSecurityDescriptor);

    return rc;
}

/*++

Routine Name:

    CheckShareSame

Routine Description:

    This checks to see whether the given share name is the same on both the
    local and remote machines.

Arguments:

    pIniPrinter     -   The iniprinter for which we are adding the share.
    pShareInfo502   -   The share info that we are attempting to add the share
                        with.
    pbSame          -   The return parameter is TRUE if the shares were the same
                        If the rc is not ERROR_SUCCESS, then the info could not
                        be set.

Return Value:

    An error code.

--*/
DWORD
CheckShareSame(
    IN      PINIPRINTER         pIniPrinter,
    IN      SHARE_INFO_502      *pShareInfo502,
        OUT BOOL                *pbSame
    )
{
    DWORD           rc = ERROR_SUCCESS;
    SHARE_INFO_2    *pShareInfoCompare = NULL;
    BOOL            bPathEquivalent = FALSE;
    BOOL            bSame           = FALSE;
    DWORD           ParmError;

    SplOutSem();

    //
    // Get the share info for the share, we should already have determined
    // that this share exists.
    //
    rc = pfnNetShareGetInfo(NULL, pShareInfo502->shi502_netname, 2, (LPBYTE *)&pShareInfoCompare);

    if (ERROR_SUCCESS == rc)
    {

        if (STYPE_PRINTQ  == pShareInfoCompare->shi2_type)
        {
            //
            // Check to see whether the paths are the same, in the upgrade case, the
            // LocalSplOnly will be taken off, so, compare this too.
            //
            bSame = !_wcsicmp(pShareInfoCompare->shi2_path, pShareInfo502->shi502_path);

            //
            // If they are not the same, compare it to the name of the printer.
            //
            if (!bSame)
            {
                EnterSplSem();

                bSame = bPathEquivalent = !_wcsicmp(pIniPrinter->pName, pShareInfoCompare->shi2_path);

                LeaveSplSem();
            }
        }
    }

    *pbSame = bSame;

    if (ERROR_SUCCESS == rc && bSame)
    {
        //
        // If the paths are identical, we can just set the share info, otherwise
        // we have to delete and recreate the share.
        //
        if (!bPathEquivalent)
        {
            //
            // OK, they are the same, set the share info instead.
            //
            rc = (*pfnNetShareSetInfo)(NULL, pShareInfo502->shi502_netname, 502, pShareInfo502, &ParmError);
        }
        else
        {
            rc = (*pfnNetShareDel)(NULL, pShareInfo502->shi502_netname, 0);

            if (ERROR_SUCCESS == rc)
            {
                rc = (*pfnNetShareAdd)(NULL, 502, (LPBYTE)pShareInfo502, &ParmError);
            }
        }
    }

    if (pShareInfoCompare)
    {
        pfnNetApiBufferFree(pShareInfoCompare);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\openprn.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    openprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    LocalOpenPrinter
    SplClosePrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew A Felton (mattfe) June 1994 RapidPrint
    Jan 95 Cleanup CreatePrinterHandle

--*/
#define NOMINMAX
#include <precomp.h>
#include "jobid.h"
#include "filepool.hxx"

#define SZXCVPORT       L"XcvPort "
#define SZXCVMONITOR    L"XcvMonitor "

LPCTSTR pszLocalOnlyToken = L"LocalOnly";
LPCTSTR pszLocalsplOnlyToken = L"LocalsplOnly";


HANDLE
CreatePrinterHandle(
    LPWSTR      pPrinterName,
    LPWSTR      pFullMachineName,
    PINIPRINTER pIniPrinter,
    PINIPORT    pIniPort,
    PINIPORT    pIniNetPort,
    PINIJOB     pIniJob,
    DWORD       TypeofHandle,
    HANDLE      hPort,
    PPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD       DesiredAccess,
    LPBYTE      pSplClientInfo,
    DWORD       dwLevel,
    HANDLE      hReadFile
    )
{
    PSPOOL              pSpool = NULL;
    BOOL                bStatus = FALSE;
    HANDLE              hReturnHandle = NULL;
    LPDEVMODE           pDevMode = NULL;
    PSPLCLIENT_INFO_1   pSplClientInfo1 = (PSPLCLIENT_INFO_1)pSplClientInfo;
    DWORD               ObjectType;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if ( dwLevel && ( dwLevel != 1 || !pSplClientInfo) ) {

        DBGMSG(DBG_ERROR,
               ("CreatePrintHandle: Invalid client info %x - %d\n",
                pSplClientInfo, dwLevel));
        pSplClientInfo = NULL;
    }

 try {

    pSpool = (PSPOOL)AllocSplMem( SPOOL_SIZE );

    if ( pSpool == NULL ) {
        DBGMSG( DBG_WARNING, ("CreatePrinterHandle failed to allocate SPOOL %d\n", GetLastError() ));
        leave;
    }

    pSpool->signature = SJ_SIGNATURE;
    pSpool->pIniPrinter = pIniPrinter;
    pSpool->hReadFile = hReadFile;

    pSpool->pIniPort            = pIniPort;
    pSpool->pIniNetPort         = pIniNetPort;
    pSpool->pIniJob             = pIniJob;
    pSpool->TypeofHandle        = TypeofHandle;
    pSpool->hPort               = hPort;
    pSpool->Status              = 0;
    pSpool->pDevMode            = NULL;
    pSpool->pName               = AllocSplStr( pPrinterName );
    pSpool->pFullMachineName    = AllocSplStr( pFullMachineName );
    pSpool->pSplMapView         = NULL;
    pSpool->pMappedJob          = NULL;
    pSpool->hClientToken        = NULL;

    if ( pSpool->pName == NULL ||
         ( pFullMachineName && !pSpool->pFullMachineName )) {

        leave;
    }

    pSpool->pIniSpooler = pIniSpooler;

    if (!GetClientSessionData(&pSpool->SessionId))
    {
        leave;
    }

    //
    // Check if it's a local call.
    //
    if( TypeofHandle & PRINTER_HANDLE_REMOTE_CALL ) {

        //
        // We get other useful info like build #, client architecture
        // we do not need this info now -- so we do not put it in PSPOOL
        //
        if ( !pSplClientInfo ) {

            if ( IsNamedPipeRpcCall() )
                TypeofHandle |= PRINTER_HANDLE_3XCLIENT;
        } else if ( dwLevel == 1 ) {
            SPLASSERT(pSplClientInfo1->pUserName && pSplClientInfo1->pMachineName);

            CopyMemory(&pSpool->SplClientInfo1, pSplClientInfo1, sizeof(SPLCLIENT_INFO_1));

            pSpool->SplClientInfo1.pUserName = AllocSplStr(pSplClientInfo1->pUserName);
            pSpool->SplClientInfo1.pMachineName = AllocSplStr(pSplClientInfo1->pMachineName);
            if ( !pSpool->SplClientInfo1.pUserName ||
                 !pSpool->SplClientInfo1.pMachineName ) {

                DBGMSG(DBG_WARNING, ("CreatePrinterHandle: could not allocate memory for user name or machine name\n"));
            }
        }
    }

    if ((TypeofHandle & PRINTER_HANDLE_SERVER) ||
        (TypeofHandle & PRINTER_HANDLE_XCV_PORT)) {

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                        DesiredAccess,
                                        pSpool,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        if ( bStatus                                            &&
             (TypeofHandle & PRINTER_HANDLE_REMOTE_CALL)        &&
             ( (DesiredAccess & SERVER_ACCESS_ADMINISTER)       &&
               ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                    SERVER_ACCESS_ADMINISTER,
                                    NULL,
                                    NULL,
                                    pIniSpooler)) ){
            pSpool->TypeofHandle |= PRINTER_HANDLE_REMOTE_ADMIN;
        }

        ObjectType = SPOOLER_OBJECT_SERVER;

    } else if( TypeofHandle & PRINTER_HANDLE_JOB ){

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_DOCUMENT,
                                        DesiredAccess,
                                        pSpool->pIniJob,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        ObjectType = SPOOLER_OBJECT_DOCUMENT;

    } else {

        bStatus = ValidateObjectAccess( SPOOLER_OBJECT_PRINTER,
                                        DesiredAccess,
                                        pSpool,
                                        &pSpool->GrantedAccess,
                                        pIniSpooler );

        ObjectType = SPOOLER_OBJECT_PRINTER;
    }

    MapGenericToSpecificAccess( ObjectType,
                                pSpool->GrantedAccess,
                                &pSpool->GrantedAccess);

    if ( !bStatus ) {

        SetLastError(ERROR_ACCESS_DENIED);
        leave;
    }

    if ( pIniPrinter ) {

        if ( pDefaults ) {

            //
            // Allocate DevMode
            //


            if ( pDefaults->pDevMode ) {

                pDevMode = pDefaults->pDevMode;

            } else {

                pDevMode = pIniPrinter->pDevMode;
            }

            if ( pDevMode != NULL  ) {

                pSpool->pDevMode = AllocSplMem( pDevMode->dmSize + pDevMode->dmDriverExtra );

                if ( pSpool->pDevMode == NULL ) {

                    DBGMSG(DBG_WARNING, ("CreatePrinterHandle failed allocation for devmode %d\n", GetLastError() ));
                    leave;
                }
                memcpy( pSpool->pDevMode, pDevMode, pDevMode->dmSize + pDevMode->dmDriverExtra );
            }
        }

        //
        //  Allocate Datype and Print Processor
        //

        if ( pDefaults && pDefaults->pDatatype ) {

                pSpool->pDatatype = AllocSplStr( pDefaults->pDatatype );
                pSpool->pIniPrintProc = FindDatatype( pIniPrinter->pIniPrintProc, pSpool->pDatatype );

        } else {

            pSpool->pDatatype = AllocSplStr( pIniPrinter->pDatatype );
            pSpool->pIniPrintProc = pIniPrinter->pIniPrintProc;
        }


        if ( pSpool->pIniPrintProc == NULL ) {
            DBGMSG( DBG_WARNING,("CreatePrinterHandle failed to PrintProcessor for datatype %ws %d\n",
                    pSpool->pDatatype, GetLastError() ));
            SetLastError( ERROR_INVALID_DATATYPE );
            leave;
        }

        SPLASSERT( pSpool->pIniPrintProc->signature == IPP_SIGNATURE );

        pSpool->pIniPrintProc->cRef++;

        if ( pSpool->pDatatype == NULL ) {
            DBGMSG( DBG_WARNING,("CreatePrinterHandle failed to allocate DataType %x\n", GetLastError() ));
            SetLastError( ERROR_INVALID_DATATYPE );
            leave;
        }

    }

    //
    // Add us to the linked list of handles for this printer.
    // This will be scanned when a change occurs on the printer,
    // and will be updated with a flag indicating what type of
    // change it was.
    // There is a flag for each handle, because we cannot guarantee
    // that all threads will have time to reference a flag in the
    // INIPRINTER before it is updated.
    //
    if ( TypeofHandle & PRINTER_HANDLE_PRINTER ) {

        pSpool->pNext = pSpool->pIniPrinter->pSpool;
        pSpool->pIniPrinter->pSpool = pSpool;

    } else if ( (TypeofHandle & PRINTER_HANDLE_SERVER) ||
                (TypeofHandle & PRINTER_HANDLE_XCV_PORT) ) {

        //
        // For server handles, hang them off the global IniSpooler:
        //

        pSpool->pNext = pIniSpooler->pSpool;
        pIniSpooler->pSpool = pSpool;

        INCSPOOLERREF( pIniSpooler );

    } else if( TypeofHandle & PRINTER_HANDLE_JOB ){

        INCJOBREF( pIniJob );
    }

    //  Note Only PRINTER_HANDLE_PRINTER are attatched to the
    //  pIniPrinter, since those are the handle which will require
    //  change notifications.

    if ( pSpool->pIniPrinter != NULL ) {

        INCPRINTERREF( pSpool->pIniPrinter );
    }

    hReturnHandle = (HANDLE)pSpool;

 } finally {

    if ( hReturnHandle == NULL ) {

        // Failure CleanUP

        if ( pSpool != NULL ) {

            FreeSplStr(pSpool->SplClientInfo1.pUserName);
            FreeSplStr(pSpool->SplClientInfo1.pMachineName);
            FreeSplStr( pSpool->pName ) ;
            FreeSplStr( pSpool->pDatatype );
            FreeSplStr(pSpool->pFullMachineName);

            if ( pSpool->pIniPrintProc != NULL )
                pSpool->pIniPrintProc->cRef--;

            if ( pSpool->pDevMode )
                FreeSplMem( pSpool->pDevMode );

            FreeSplMem( pSpool );
            pSpool = NULL;

        }
    }
}
    return hReturnHandle;
}



BOOL
DeletePrinterHandle(
    PSPOOL  pSpool
    )
{

    BOOL bRet = FALSE;

    SplInSem();

    if (pSpool->pIniPrintProc) {
        pSpool->pIniPrintProc->cRef--;
    }

    if (pSpool->pDevMode)
        FreeSplMem(pSpool->pDevMode);

    if (pSpool->hClientToken)
    {
        CloseHandle(pSpool->hClientToken);
    }

    FreeSplStr(pSpool->SplClientInfo1.pUserName);
    FreeSplStr(pSpool->SplClientInfo1.pMachineName);
    FreeSplStr(pSpool->pDatatype);

    SetSpoolClosingChange(pSpool);

    FreeSplStr(pSpool->pName);
    FreeSplStr(pSpool->pFullMachineName);

    bRet = ObjectCloseAuditAlarm( szSpooler, pSpool, pSpool->GenerateOnClose );

    //
    // If there is a WaitForPrinterChange outstanding, we can't free
    // the pSpool, since we may try and reference it.
    //

    // Log warning for freed printer handle
    DBGMSG(DBG_TRACE, ("DeletePrinterHandle 0x%x", pSpool));

    if (pSpool->ChangeEvent) {

        pSpool->eStatus |= STATUS_PENDING_DELETION;

    } else {

        FreeSplMem(pSpool);
    }

    return TRUE;
}


DWORD
CreateServerHandle(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults,
    PINISPOOLER pIniSpooler,
    DWORD   dwTypeofHandle
)
{
    DWORD DesiredAccess;
    DWORD ReturnValue = ROUTER_STOP_ROUTING;

    DBGMSG(DBG_TRACE, ("OpenPrinter(%ws)\n",
                       pPrinterName ? pPrinterName : L"NULL"));

    EnterSplSem();

    if (!pDefaults || !pDefaults->DesiredAccess)
        DesiredAccess = SERVER_READ;
    else
        DesiredAccess = pDefaults->DesiredAccess;

    if (*pPrinterHandle = CreatePrinterHandle( pIniSpooler->pMachineName,
                                               pPrinterName,
                                               NULL, NULL, NULL, NULL,
                                               dwTypeofHandle,
                                               NULL,
                                               pDefaults,
                                               pIniSpooler,
                                               DesiredAccess,
                                               NULL,
                                               0,
                                               INVALID_HANDLE_VALUE )){
        ReturnValue = ROUTER_SUCCESS;

    }
    LeaveSplSem();

    DBGMSG(DBG_TRACE, ("OpenPrinter returned handle %08x\n", *pPrinterHandle));

    return ReturnValue;
}


PINIPRINTER
FindPrinterShare(
   LPCWSTR pszShareName,
   PINISPOOLER pIniSpooler
   )

/*++

Routine Description:

    Try and find the share name in our list of printers.

    Note: Even if the printer isn't shared, we still return a match.

    The caching code will work because it explicitly turns off
    the PRINTER_ATTRIBUTE_SHARE bit so that the cache pIniSpooler
    doesn't create a server thread or call NetShareAdd/Del.

    In the future, consider changing this to check the share bit.
    Create a new bit SPL_SHARE_PRINTERS that indicates whether sharing
    housekeeping should be done.

Arguments:

    pszShareName - Name of share to search for.

Return Value:

    PINIPRINTER Printer that has the share name, NULL if no printer.

--*/
{
    PINIPRINTER pIniPrinter;

    SplInSem();

    if (pszShareName && pszShareName[0]) {

        for( pIniPrinter = pIniSpooler->pIniPrinter;
             pIniPrinter;
             pIniPrinter = pIniPrinter->pNext ){

            if (pIniPrinter->pShareName                              &&
                !lstrcmpi(pIniPrinter->pShareName, pszShareName)) {

                return pIniPrinter;
            }
        }
    }
    return NULL;
}

PINISPOOLER
LocalFindSpoolerByNameIncRef(
    LPWSTR      pszPrinterName,
    LPTSTR      *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    See if the printer is owned by localspl.  This is a special
    case to check if it's a masquarading printer.

    Normally we would check for \\Server\Printer to see if \\Server
    is our machine, but we have to look for \\MasqServer\Printer
    too.

Arguments:

    pPrinterName - Name to check.

    ppszLocalName - Returns pointer to local name.  OPTIONAL

Return Value:

    PINISPOOLER - Spooler match.
    NULL - No match.

--*/

{
    PINISPOOLER pIniSpooler;
    LPWSTR      pTemp;

    if (!ppszLocalName)
        ppszLocalName = &pTemp;

    SplOutSem();

    //
    // At this time we do not know if the server name in pName refers to our local
    // machine. We are trying to add the server name to the name cache. The name
    // cache functions decide if the name refers to the local machine and if positive,
    // add an entry for it in the cache.
    //
    CacheAddName(pszPrinterName);

    EnterSplSem();

    pIniSpooler = FindSpoolerByName( pszPrinterName,
                                     ppszLocalName );

    if( !pIniSpooler ){

        //
        // Check if it's a masq printer.
        //
        // If the local name isn't the same as the original name, it
        // is in the syntax "\\server\printer."  In this case it may
        // be a masq printer, so check if the printer exists in the
        // local spooler by this name.
        //
        if(*ppszLocalName != pszPrinterName ){

            //
            // Search for the printer, but remove any suffixes it
            // may have.
            //
            WCHAR string[MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX];

            //
            // The pIniSpooler is NULL, so if this function fails, we will
            // set the last error is BoolFromHResult and return NULL for
            // failue.
            //
            if (BoolFromHResult(StringCchCopy(string, COUNTOF(string), pszPrinterName))) {

                if( pTemp = wcschr( string, L',' )){
                    *pTemp = 0;
                }

                if(FindPrinter(string, pLocalIniSpooler )){

                    //
                    // The masq printer exists.  The local name for this
                    // masq printer is "\\MasqServer\Printer," so we must
                    // reflect this change in ppszLocalName.  This will ensure
                    // that the pIniPrinter is found.
                    //
                    *ppszLocalName = pszPrinterName;
                    pIniSpooler = pLocalIniSpooler;
                }
            }
        }
    }

    if( pIniSpooler ){
        INCSPOOLERREF( pIniSpooler );
    }

    LeaveSplSem();

    return pIniSpooler;
}


VOID
LocalFindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Matching call to LocalFindSpoolerByNameIncRef.

Arguments:

    pIniSpooler - Spooler to derement; can be NULL.

Return Value:

--*/

{
    EnterSplSem();

    if( pIniSpooler ){
        DECSPOOLERREF( pIniSpooler );
    }
    LeaveSplSem();
}


DWORD
LocalOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE pPrinterHandle,
    LPPRINTER_DEFAULTS pDefaults
    )
{
    return LocalOpenPrinterEx( pPrinterName,
                               pPrinterHandle,
                               pDefaults,
                               NULL,
                               0 );
}

DWORD
LocalOpenPrinterEx(
    LPWSTR              pPrinterName,
    LPHANDLE            pPrinterHandle,
    LPPRINTER_DEFAULTS  pDefaults,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )
{
    DWORD dwReturn;
    LPWSTR pszLocalName;
    PINISPOOLER pIniSpooler = LocalFindSpoolerByNameIncRef( pPrinterName,
                                                            &pszLocalName);

    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(0, EVENT_TRACE_TYPE_SPL_ENDTRACKTHREAD, NULL);

    if( !pIniSpooler ) {

        //
        // Check for PrinterName,LocalsplOnly.
        // If we see this token, then fail the call since
        // we only want to check localspl.
        //
        LPCTSTR pSecondPart;

        if( pSecondPart = wcschr( pPrinterName, L',' )){

            ++pSecondPart;

            if( wcscmp( pSecondPart, pszLocalsplOnlyToken ) == STRINGS_ARE_EQUAL ){
                SetLastError( ERROR_INVALID_PRINTER_NAME );
                return ROUTER_STOP_ROUTING;
            }
        }

        SetLastError( ERROR_INVALID_NAME );
        return ROUTER_UNKNOWN;
    }

    dwReturn = SplOpenPrinter( pPrinterName,
                               pPrinterHandle,
                               pDefaults,
                               pIniSpooler,
                               pSplClientInfo,
                               dwLevel);

    LocalFindSpoolerByNameDecRef( pIniSpooler );

    //
    // We need to give other provider a chance to get the printer name
    //

    return dwReturn;
}

DWORD
OpenLocalPrinterName(
    LPCWSTR pPrinterName,
    PINISPOOLER pIniSpooler,
    PDWORD pTypeofHandle,
    PINIPRINTER* ppIniPrinter,
    PINIPORT* ppIniPort,
    PINIPORT* ppIniNetPort,
    PHANDLE phPort,
    PDWORD pOpenPortError,
    LPPRINTER_DEFAULTS pDefaults
    )
{
    PINIPRINTER pIniPrinter;
    PINIPORT pIniPort;
    PINIPORT pIniNetPort = NULL;
    BOOL bOpenPrinterPort;
    LPWSTR pDatatype;

    //
    // If the printer name is the name of a local printer:
    //
    //    Find the first port the printer's attached to.
    //
    //    If the port has a monitor (e.g. LPT1:, COM1 etc.),
    //       we're OK,
    //    Otherwise
    //       try to open the port - this may be a network printer
    //

    if( ( pIniPrinter = FindPrinter( pPrinterName, pIniSpooler )) ||
        ( pIniPrinter = FindPrinterShare( pPrinterName, pIniSpooler ))) {


        pIniPort = FindIniPortFromIniPrinter( pIniPrinter );

        if( pIniPort && ( pIniPort->Status & PP_MONITOR )){

            //
            // A Printer that has a Port with a Monitor is not a
            // DownLevel Connection (or LocalPrinter acting as a
            // remote printer - "Masquarade" case).
            //
            pIniPort = NULL;
        }

        pDatatype = (pDefaults && pDefaults->pDatatype) ?
                        pDefaults->pDatatype :
                        NULL;

        //
        // Validate datatypes for both masq and local.
        //
        if( pDatatype && !FindDatatype( NULL, pDatatype )){
            goto BadDatatype;
        }

        if( pIniPort ){

            //
            // DownLevel Connection Printer; save it in pIniNetPort.
            // SetPrinterPorts checks this value.
            //
            pIniNetPort = pIniPort;

            //
            // Validate datatype.  We only send RAW across the net
            // to masq printers.
            //
            if( pDatatype && !ValidRawDatatype( pDatatype )){
                goto BadDatatype;
            }

            //
            // There is a network port associated with this printer.
            // Make sure we can open it, and get the handle to use on
            // future API calls:
            //
            INCPRINTERREF(pIniPrinter);
            LeaveSplSem();
            bOpenPrinterPort = OpenPrinterPortW( pIniPort->pName, phPort, pDefaults );
            EnterSplSem();
            DECPRINTERREF(pIniPrinter);

            if( !bOpenPrinterPort ){

                *phPort = INVALID_PORT_HANDLE;
                *pOpenPortError = GetLastError();

                //
                // Must be non-zero otherwise it looks like success.
                //
                SPLASSERT( *pOpenPortError );

                if( *pOpenPortError == ERROR_INVALID_PASSWORD ) {

                    //
                    // This call should fail if it's because the password
                    // is invalid, then winspool or printman can prompt
                    // for the password.
                    //
                    DBGMSG(DBG_WARNING, ("OpenPrinterPort1( %ws ) failed with ERROR_INVALID_PASSWORD .  OpenPrinter returning FALSE\n", pIniPort->pName ));
                    return ROUTER_STOP_ROUTING;
                }

                DBGMSG(DBG_WARNING, ("OpenPrinterPort1( %ws ) failed: Error %d.  OpenPrinter returning TRUE\n", pIniPort->pName, *pOpenPortError));

            } else {
                //
                // Clear the placeholder bit from the pIniPort status. This
                // belongs to a partial print provider.
                //
                pIniPort->Status &= ~PP_PLACEHOLDER;
            }

        } else {

            //
            // Not a masq case.  If it's direct, it must be raw.
            //
            // Note: we will use the default if no datatype is specified.
            // However, if the default datatype is non-RAW and the
            // printer is direct, the open will succeed using a
            // non-RAW datatype!
            //
            if(( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT ) &&
                pDatatype &&
                !ValidRawDatatype( pDatatype )) {

                goto BadDatatype;
            }
        }

        //
        // If this is a placeholder port, assume that it is a monitor port for now.
        //
        if (pIniPort && pIniPort->Status & PP_PLACEHOLDER) {
            pIniPort    = NULL;
            pIniNetPort = NULL;
        }

        *pTypeofHandle |= ( pIniPort ?
                                PRINTER_HANDLE_PORT :
                                PRINTER_HANDLE_PRINTER );

        *ppIniPort = pIniPort;
        *ppIniNetPort = pIniNetPort;
        *ppIniPrinter = pIniPrinter;

        return ROUTER_SUCCESS;
    }

    SetLastError( ERROR_INVALID_NAME );
    return ROUTER_UNKNOWN;

BadDatatype:

    SetLastError( ERROR_INVALID_DATATYPE );
    return ROUTER_STOP_ROUTING;
}


DWORD
CheckPrinterTokens(
    LPCWSTR string,
    LPCWSTR pSecondPart,
    PDWORD pTypeofHandle,
    PINISPOOLER pIniSpooler,
    PINIPRINTER *ppIniPrinter,
    PINIPORT *ppIniPort,
    PINIPORT *ppIniNetPort,
    PHANDLE phPort,
    PDWORD  pOpenPortError,
    PPRINTER_DEFAULTS pDefaults
    )
{
    typedef enum {
        kNone = 0,
        kLocalOnly = 1,
        kLocalsplOnly = 2
    } ETOKEN_TYPE;

    ETOKEN_TYPE eTokenType = kNone;

    DWORD RouterReturnValue = ROUTER_UNKNOWN;

    //
    // LocalOnly
    //
    //     Do not call OpenPrinterPort--use local settings only.
    //     If not recognized by localspl, stop routing.
    //
    //     This is used during upgrade of a downlevel printer connection.
    //     The remote server may not be up, but we can return a print
    //     handle to the local printer.  Get/SetPrinterData calls will
    //     succeed (for upgrade purposes), but printing will fail.
    //
    // LocalsplOnly
    //
    //     Call OpenPrinterPort if necessary.
    //     Stop routing after localspl even if not found.
    //
    //     This is used when the system knows that the printer must exist
    //     on the local machine, and does not want to route further.
    //     This fixes the clustering problem when the server has a stale
    //     print share and successfully validates it against win32spl since
    //     it is cached.
    //

    if( wcsncmp( pSecondPart, pszLocalOnlyToken, wcslen(pszLocalOnlyToken) ) == STRINGS_ARE_EQUAL ){

        eTokenType = kLocalOnly;

    } else if( wcsncmp( pSecondPart, pszLocalsplOnlyToken, wcslen(pszLocalsplOnlyToken) ) == STRINGS_ARE_EQUAL ){

        eTokenType = kLocalsplOnly;
    }

    //
    // If we have a valid token, process it.
    //
    if( eTokenType != kNone ){

        switch( eTokenType ){
        case kLocalOnly:

            //
            // Find the printer associate with it.
            //
            *ppIniPrinter = FindPrinter( string, pIniSpooler );

            if( *ppIniPrinter ){
                *pTypeofHandle |= PRINTER_HANDLE_PRINTER;
                RouterReturnValue = ROUTER_SUCCESS;
            } else {
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }

            break;

        case kLocalsplOnly:

            RouterReturnValue = OpenLocalPrinterName( string,
                                                      pIniSpooler,
                                                      pTypeofHandle,
                                                      ppIniPrinter,
                                                      ppIniPort,
                                                      ppIniNetPort,
                                                      phPort,
                                                      pOpenPortError,
                                                      pDefaults );

            *pTypeofHandle = *pTypeofHandle & (~PRINTER_HANDLE_REMOTE_CALL);

            if( RouterReturnValue == ROUTER_UNKNOWN ){
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }
        }
    }

    DBGMSG( DBG_TRACE,
            ( "CheckPrinterTokens: %ws %d Requested %d %x\n",
              string, RouterReturnValue, *ppIniPrinter ));

    return RouterReturnValue;
}

DWORD
CheckPrinterPortToken(
    LPCWSTR string,
    LPCWSTR pSecondPart,
    PDWORD pTypeofHandle,
    PINIPRINTER* ppIniPrinter,
    PINIPORT* ppIniPort,
    PINIJOB* ppIniJob,
    const LPPRINTER_DEFAULTS pDefaults,
    const PINISPOOLER pIniSpooler
    )
{
    if( wcsncmp( pSecondPart, L"Port", 4 ) != STRINGS_ARE_EQUAL ||
        !( *ppIniPort = FindPort( string, pIniSpooler ))){

        return ROUTER_UNKNOWN;
    }

    //
    // The name is the name of a port:
    //
    if( pDefaults            &&
        pDefaults->pDatatype &&
        !ValidRawDatatype( pDefaults->pDatatype )) {

        SetLastError( ERROR_INVALID_DATATYPE );
        return ROUTER_STOP_ROUTING;
    }

    if ( *ppIniJob = (*ppIniPort)->pIniJob ) {

        *ppIniPrinter = (*ppIniJob)->pIniPrinter;
        *pTypeofHandle |= PRINTER_HANDLE_PORT;

    } else if( (*ppIniPort)->cPrinters ){

        //
        // There is no current job assigned to the port
        // So Open the First Printer Associated with
        // this port.
        //
        *ppIniPrinter = (*ppIniPort)->ppIniPrinter[0];
        *pTypeofHandle |= PRINTER_HANDLE_PRINTER;
    }
    return ROUTER_SUCCESS;
}


DWORD
CheckPrinterJobToken(
    IN      PWSTR               string,
    IN      size_t              cchString,
    IN      LPCWSTR             pSecondPart,
        OUT PDWORD              pTypeofHandle,
        OUT PINIPRINTER         *ppIniPrinter,
        OUT PINIJOB             *ppIniJob,
        OUT PHANDLE             phReadFile,
    IN      const PINISPOOLER   pIniSpooler
    )
{
    HANDLE      hImpersonationToken;
    DWORD       Position, dwShareMode, dwDesiredAccess;
    DWORD       JobId;
    PINIPRINTER pIniPrinter;
    PINIJOB     pIniJob, pCurrentIniJob;
    PWSTR       pszStr = NULL;

    if( wcsncmp( pSecondPart, L"Job ", 4 ) != STRINGS_ARE_EQUAL ||
        !( pIniPrinter = FindPrinter( string, pIniSpooler ))){

        return ROUTER_UNKNOWN;
    }

    //
    //  Get the Job ID ",Job xxxx"
    //
    pSecondPart += 4;

    JobId = Myatol( (LPWSTR)pSecondPart );

    pIniJob = FindJob( pIniPrinter, JobId, &Position );

    if( pIniJob == NULL ) {

        DBGMSG( DBG_WARN, ("OpenPrinter failed to find Job %d\n", JobId ));
        return ROUTER_UNKNOWN;
    }

    DBGMSG( DBG_TRACE, ("OpenPrinter: pIniJob->cRef = %d\n", pIniJob->cRef));

    if( pIniJob->Status & JOB_DIRECT ) {

        SplInSem();

        *pTypeofHandle |= PRINTER_HANDLE_JOB | PRINTER_HANDLE_DIRECT;
        goto Success;
    }

    //
    //  If this job is assigned to a port
    //  Then pick up the correct chained jobid file instead of the master
    //  JobId.
    //


    if ( pIniJob->pCurrentIniJob != NULL ) {

        SPLASSERT( pIniJob->pCurrentIniJob->signature == IJ_SIGNATURE );

        DBGMSG( DBG_TRACE,("CheckPrinterJobToken pIniJob %x JobId %d using chain JobId %d\n",
                pIniJob, pIniJob->JobId, pIniJob->pCurrentIniJob->JobId ));


        pCurrentIniJob = pIniJob->pCurrentIniJob;


        SPLASSERT( pCurrentIniJob->signature == IJ_SIGNATURE );

    } else {

        pCurrentIniJob = pIniJob;

    }

    if ( pCurrentIniJob->hFileItem != INVALID_HANDLE_VALUE )
    {
        LeaveSplSem();

        hImpersonationToken = RevertToPrinterSelf();

        GetReaderFromHandle(pCurrentIniJob->hFileItem, phReadFile);

        if (hImpersonationToken && !ImpersonatePrinterClient(hImpersonationToken))
        {
            DBGMSG( DBG_WARNING,("Client impersonation failed.\n"));
        }
        else
        {

            if ( *phReadFile && (*phReadFile != INVALID_HANDLE_VALUE))
            {
                GetNameFromHandle(pCurrentIniJob->hFileItem, &pszStr, TRUE);

                if (BoolFromHResult(StringCchCopy(string, cchString, pszStr)))
                {
                    EnterSplSem();

                    *pTypeofHandle |= PRINTER_HANDLE_JOB;

                    goto Success;
                }
            }
        }

        DBGMSG( DBG_WARN,("Filepools: Failed to get valid reader handle\n"));

        EnterSplSem();
    }
    else
    {
        GetFullNameFromId(pCurrentIniJob->pIniPrinter,
                          pCurrentIniJob->JobId,
                          TRUE,
                          string,
                          cchString,
                          FALSE);

        //  Bug 54845
        //  Even a user without previledge can open a ", JOB #"
        //  if he is physically running on the machine.

        LeaveSplSem();

        hImpersonationToken = RevertToPrinterSelf();

        dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

        if (pCurrentIniJob->Status & JOB_TYPE_OPTIMIZE) {
            dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
        } else {
            dwDesiredAccess = GENERIC_READ;
        }

        //
        // This is OK, it can only open a job file since we generate the name from
        // the id.
        //
        *phReadFile = CreateFile(string,
                                 dwDesiredAccess,
                                 dwShareMode,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

        EnterSplSem();

        if (hImpersonationToken && !ImpersonatePrinterClient(hImpersonationToken))
        {
            DBGMSG( DBG_WARNING,("Client impersonation failed.\n"));
        }
        else
        {
            if( *phReadFile != INVALID_HANDLE_VALUE ) {

                DBGMSG( DBG_TRACE,
                        (  "OpenPrinter JobID %d pIniJob %x CreateFile( %ws ), hReadFile %x success",
                           JobId, pIniJob, string, *phReadFile ));

                SplInSem();

                *pTypeofHandle |= PRINTER_HANDLE_JOB;
                goto Success;
            }
        }
    }


    DBGMSG( DBG_WARNING,
            ( "LocalOpenPrinter CreateFile(%ws) GENERIC_READ failed : %d\n",
              string, GetLastError()));

    SPLASSERT( GetLastError( ));

    //
    // Cleanup for the function.
    // This function does not have a common cleanup area, this should be fixed,
    // but it requires a overhaul of this function.
    //
    FreeSplStr(pszStr);

    return ROUTER_STOP_ROUTING;

Success:

    FreeSplStr(pszStr);

    *ppIniJob = pIniJob;
    *ppIniPrinter = pIniPrinter;

    return ROUTER_SUCCESS;
}


DWORD
CheckXcvPortToken(
    LPCWSTR pszSecondPart,
    PDWORD pTypeofHandle,
    const LPPRINTER_DEFAULTS pDefaults,
    const PINISPOOLER pIniSpooler,
    PHANDLE phXcv
    )
{

    DWORD dwRet = ROUTER_SUCCESS;
    DWORD dwType;
    PCWSTR pszPort;
    DWORD dwTypeofHandle = *pTypeofHandle;

    if (!wcsncmp(pszSecondPart, SZXCVPORT, COUNTOF(SZXCVPORT) - 1)) {
        dwType = XCVPORT;
        dwTypeofHandle |= PRINTER_HANDLE_XCV_PORT;
        pszPort = (PCWSTR) pszSecondPart + COUNTOF(SZXCVPORT) - 1;
    }
    else if (!wcsncmp(pszSecondPart, SZXCVMONITOR, COUNTOF(SZXCVMONITOR) - 1)) {
        dwType = XCVMONITOR;
        dwTypeofHandle |= PRINTER_HANDLE_XCV_PORT;
        pszPort = (PCWSTR) pszSecondPart + COUNTOF(SZXCVMONITOR) - 1;
    }
    else
        dwRet = ROUTER_UNKNOWN;

    if (dwRet == ROUTER_SUCCESS) {
        dwRet = XcvOpen(NULL,
                        pszPort,
                        dwType,
                        pDefaults,
                        phXcv,
                        pIniSpooler);

        if (dwRet == ROUTER_SUCCESS)
            *pTypeofHandle = dwTypeofHandle;
    }

    return dwRet;
}




DWORD
SplOpenPrinter(
    LPWSTR              pFullPrinterName,
    LPHANDLE            pPrinterHandle,
    LPPRINTER_DEFAULTS  pDefaults,
    PINISPOOLER         pIniSpooler,
    LPBYTE              pSplClientInfo,
    DWORD               dwLevel
    )

/*++

Routine Description:

    OpenPrinter can open any of the following by specifying a string
    in pPrinterName:-

        Server
            \\MachineName
            NULL

        Job
            PrinterName, Job xxxx

        Port
            PortName, Port

        XcvPort
            \\MachineName\,XcvPort Port
            ,XcvPort Port

        XcvMonitor
            \\MachineName\,XcvMonitor Monitor
            ,XcvMonitor Monitor

        Printer
            PrinterName
            ShareName
            \\MachineName\PrinterName
            \\MachineName\ShareName
            PrinterName, LocalOnly
            ShareName, LocalOnly
            PrinterName, LocalsplOnly
            ShareName, LocalsplOnly

        Note for Printer there are two Types
            1 - Regular LocalPrinter
            2 - DownLevel Connection Printer

        For type 2 a LocalPrinter exists ( pIniPrinter ) but its port
        does not have a monitor associated with it.   In this case
        we also open the port ( typically \\share\printer of a remote
        machine ) before we return success.

    GUI Applications usually use Server and Printer

    Type Job and Port are used by Print Processors:-

        A print processor will Open a Job then read the job using
        ReadPrinter.  A print processor will output to a Port by opening
        the PortName, Port and using WritePrinter.  Usually these strings
        "PrinterName, Job xxx" "PortName, Port" are passed to the print
        processor by the spooler and are currently not documented.   We
        do know that some OEMs have figured out the extentions and we
        might break someone if we change them.

    Type LocalOnlyToken is used by a Printer Driver:-

        Used when we need to upgrade a printer's settings from an older
        version of the driver to a newer one (see drvupgrd.c for details).
        This was added in NT 3.51.

    Type LocasplOnlyToken is used by server:-

        Indicates that we should check localspl only (local or masq).
        Other providers will not be called.

Arguments:

    pPrinterName   - PrinterName ( see above for different types of
                     PrinterName )
    pPrinterHandle - Address to put hPrinter on Success
    pDefaults      - Optional, allows user to specify Datatype,
                     DevMode, DesiredAccess.
    pIniSpooler    - This spooler "owns" the printer.  We will only check
                     against this spooler, and we assume that the callee
                     has already checked that "\\server\printer" lives
                     on this pIniSpooler (i.e., we are \\server).

    ( see SDK Online Help for full explanation )


Return Value:

    TRUE    - *pPrinterHandle will have a PrinterHandle
    FALSE   - use GetLastError

--*/

{
    PINIPRINTER pIniPrinter = NULL;
    PINIPORT    pIniPort = NULL;
    PINIPORT    pIniNetPort = NULL;
    DWORD       LastError = 0;
    LPWSTR      pPrinterName = pFullPrinterName;
    WCHAR       string[MAX_UNC_PRINTER_NAME + PRINTER_NAME_SUFFIX_MAX];
    PINIJOB     pIniJob = NULL;
    HANDLE      hReadFile = INVALID_HANDLE_VALUE;
    DWORD       TypeofHandle = 0;
    LPWSTR      pSecondPart = NULL;
    HANDLE      hPort = INVALID_PORT_HANDLE;
    DWORD       OpenPortError = NO_ERROR;
    BOOL        bRemoteUserPrinterNotShared = FALSE;
    DWORD       MachineNameLength;
    DWORD       RouterReturnValue = ROUTER_UNKNOWN;
    DWORD       DesiredAccess;
    LPTSTR      pcMark;
    BOOL        bRemoteNameRequest = FALSE;
    BOOL        bLocalCall         = FALSE;

#if DBG
    //
    // On DBG builds, force last error to zero so we can catch people
    // that don't set it when they should.
    //
    SetLastError( ERROR_SUCCESS );
#endif

    //
    // Reject "" - pointer to a NULL string.
    //
    if (pFullPrinterName && !pFullPrinterName[0]) {
        SetLastError(ERROR_INVALID_NAME);
        return ROUTER_UNKNOWN;
    }

    if (!pFullPrinterName) {
        return CreateServerHandle( pFullPrinterName,
                                   pPrinterHandle,
                                   pDefaults,
                                   pIniSpooler,
                                   PRINTER_HANDLE_SERVER );
    }

    if( pFullPrinterName[0] == TEXT( '\\' ) && pFullPrinterName[1] == TEXT( '\\' )) {

        //
        // If this is truncated, MyName will just fail a little later.
        //
        StringCchCopy(string, COUNTOF(string), pFullPrinterName);

        if(pcMark = wcschr(string + 2, TEXT( '\\' ))) {
            *pcMark = TEXT('\0');
        }

        if (MyName(string, pIniSpooler)) { // \\Server\Printer or \\Server

            if (!pcMark) {  // \\Server
                return CreateServerHandle( pFullPrinterName,
                                           pPrinterHandle,
                                           pDefaults,
                                           pIniSpooler,
                                           PRINTER_HANDLE_SERVER );
            }

            // Have \\Server\Printer, Set pPrinterName = Printer
            pPrinterName = pFullPrinterName + (pcMark - string) + 1;
            bRemoteNameRequest = TRUE;

        }
    }

    DBGMSG( DBG_TRACE, ( "OpenPrinter(%ws, %ws)\n", pFullPrinterName, pPrinterName ));

    {
        HRESULT hRes = CheckLocalCall();

        if (hRes == S_OK)
        {
            bLocalCall = TRUE;
        }
        else if (hRes == S_FALSE)
        {
            bLocalCall = FALSE;
        }
        else
        {
            SetLastError(SCODE_CODE(hRes));
            return FALSE;
        }
    }

    EnterSplSem();


    //
    // For the Mars folks who will come in with the same printer
    // connection, do a DeletePrinterCheck; this will allow
    // Mars connections that have been deleted to be proceed
    // to the Mars print providor
    //
    if (( pIniPrinter = FindPrinter( pPrinterName, pIniSpooler )) ||
        ( pIniPrinter = FindPrinterShare( pPrinterName, pIniSpooler ))) {

        DeletePrinterCheck( pIniPrinter );
        pIniPrinter = NULL;
    }

    //
    // The strategy for the rest of this code is to walk through each
    // different printer handle type, searching for a match.
    //
    // RouterReturnValue will be set to the current state of routing.
    // If a section recognizes and "owns" a printer and successfully
    // opens it, it sets RouterReturnValue to ROUTER_SUCCESS and
    // jumps to DoneRouting which allocs the handle.
    //
    // If it recoginzes the printer but fails to open it, and
    // guarentees that no one else (localspl code or other providers)
    // will recognize it, it should set RouterReturnValue to
    // ROUTER_STOP_ROUTING.  We will quit at this point.
    //
    // If it doesn't recognize the printer, set RouterReturnValue
    // to ROUTER_UNKNOWN and we will keep looking.
    //

    //
    // Try regular printer name: "My Printer" "TestPrinter."
    //

    RouterReturnValue = OpenLocalPrinterName( pPrinterName,
                                              pIniSpooler,
                                              &TypeofHandle,
                                              &pIniPrinter,
                                              &pIniPort,
                                              &pIniNetPort,
                                              &hPort,
                                              &OpenPortError,
                                              pDefaults );

    if( RouterReturnValue != ROUTER_UNKNOWN ){

        if( bRemoteNameRequest ){

            //
            // On success, determine whether the user is remote or local.
            // Note: we only do this for fully qualified names
            // (\\server\share), since using just the share or printer
            // name can only succeed locally.
            //

            if (bLocalCall) {
                if( (pIniSpooler->SpoolerFlags & SPL_REMOTE_HANDLE_CHECK) &&
                    (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) )
                    TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
            } else {
                if( pIniSpooler->SpoolerFlags & SPL_REMOTE_HANDLE_CHECK )
                    TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
                TypeofHandle |= PRINTER_HANDLE_REMOTE_CALL;
            }

            //
            // This is a remote open.
            //
            // If the printer is not shared, ensure the caller
            // has Administer access to the printer.
            //
            // The following seems to belong to the inside of the above "if"
            // clause. As it is, if an interactive user calls in with UNC name,
            // we require him to have ADMIN access if the printer is not shared;
            // but if he uses the printer friendly name, we let him go.
            //
            if( pIniPrinter &&
                !( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED )){

                bRemoteUserPrinterNotShared = TRUE;
            }
        }

        goto DoneRouting;
    }

    SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
               !pIniNetPort && !pIniJob && !hPort );

    //
    // Try LocalPrinter with an extention e.g.
    //
    // PortName, Port
    // PrinterName, Job xxxx
    // PrinterName, LocalOnlyToken
    // PrinterName, LocalsplOnlyToken
    //
    // See if the name includes a comma.  Look for qualifiers:
    //    Port Job LocalOnly LocalsplOnly
    //

    StringCchCopy(string, COUNTOF(string), pPrinterName);

    if( pSecondPart = wcschr( string, L',' )){

        DWORD dwError;
        UINT uType;

        //
        // Turn into 2 strings
        // First PrintName
        // pSecondPart points to the rest.
        //
        *pSecondPart++ = 0;

        //
        // Get rid of Leading Spaces
        //
        while ( *pSecondPart == L' ' && *pSecondPart != 0 ) {
            pSecondPart++;
        }

        SPLASSERT( *pSecondPart );

        //
        //  PrintName, {LocalOnly|LocalsplOnly}
        //
        RouterReturnValue = CheckPrinterTokens( string,
                                                pSecondPart,
                                                &TypeofHandle,
                                                pIniSpooler,
                                                &pIniPrinter,
                                                &pIniPort,
                                                &pIniNetPort,
                                                &hPort,
                                                &OpenPortError,
                                                pDefaults );

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  PortName, Port
        //
        RouterReturnValue = CheckPrinterPortToken( string,
                                                   pSecondPart,
                                                   &TypeofHandle,
                                                   &pIniPrinter,
                                                   &pIniPort,
                                                   &pIniJob,
                                                   pDefaults,
                                                   pIniSpooler );

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  PrinterName, Job ###
        //
        RouterReturnValue = CheckPrinterJobToken(string,
                                                 COUNTOF(string),
                                                 pSecondPart,
                                                 &TypeofHandle,
                                                 &pIniPrinter,
                                                 &pIniJob,
                                                 &hReadFile,
                                                 pIniSpooler);

        if( RouterReturnValue != ROUTER_UNKNOWN ){
            goto DoneRouting;
        }

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        //  "\\Server\,XcvPort Object" or ",XcvPort Object"
        //  "\\Server\,XcvMonitor Object" or ",XcvMonitor Object"
        //

        // Verify that we're looking at the right server

        if (bRemoteNameRequest || *pPrinterName == L',') {
            RouterReturnValue = CheckXcvPortToken( pSecondPart,
                                                   &TypeofHandle,
                                                   pDefaults,
                                                   pIniSpooler,
                                                   pPrinterHandle );

        } else {
            RouterReturnValue = ROUTER_UNKNOWN;
        }

        goto WrapUp;
    }

    //
    // We have completed all routing.  Anything other than success
    // should exit now.
    //

DoneRouting:

    if( RouterReturnValue == ROUTER_SUCCESS) {

        //
        // It's an error if the printer is pending deletion or pending creation.
        //
        SPLASSERT( pIniPrinter );

        if (!pIniPrinter                                                          ||
            (pIniPrinter->Status       & PRINTER_PENDING_DELETION)                &&
            (pIniSpooler->SpoolerFlags & SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION) &&
            (pIniPrinter->cJobs == 0)                                             ||
            (pIniPrinter->Status & PRINTER_PENDING_CREATION)) {

            RouterReturnValue = ROUTER_STOP_ROUTING;
            SetLastError( ERROR_INVALID_PRINTER_NAME );
            goto DoneRouting;
        }

        //
        // When the printer is opened, access type may be specified in
        // pDefaults.  If no defaults are supplied (or request access
        // is unspecified), we use PRINTER_ACCESS_USE.
        //
        // Future calls with the handle will check against both the
        // current user privileges on this printer but also this initial
        // access.  (Even if the user is an admin of the printer, unless
        // they open the printer with PRINTER_ALL_ACCESS, they can't
        // administer it.)
        //
        // If the user requires more access, the printer must be reopened.
        //
        if( !pDefaults || !pDefaults->DesiredAccess ){

            if( TypeofHandle & PRINTER_HANDLE_JOB ){
                DesiredAccess = JOB_READ;
            } else {
                DesiredAccess = PRINTER_READ;
            }

        } else {
            DesiredAccess = pDefaults->DesiredAccess;
        }

        //
        // If the user is remote and the printer is not shared, only allow
        // administrators succeed.
        //
        // This allows administrators to admin printers even if they
        // are not shared, and prevents non-admins from opening non-shared
        // printers.
        //

        if( bRemoteUserPrinterNotShared &&
            !(DesiredAccess & PRINTER_ACCESS_ADMINISTER )) {

            PSPOOL pSpool;

            // Get a quick and dirty pSpool to pass in
            pSpool = (PSPOOL)AllocSplMem( SPOOL_SIZE );
            if( pSpool == NULL ) {
                DBGMSG( DBG_WARNING, ("SplOpenPrinter failed to allocate memory %d\n", GetLastError() ));
                RouterReturnValue = ROUTER_STOP_ROUTING;
                goto WrapUp;
            }
            pSpool->signature = SJ_SIGNATURE;
            pSpool->pIniPrinter = pIniPrinter;


            // Add admin request, and see if user has the right.
            DesiredAccess |= PRINTER_ACCESS_ADMINISTER;
            if( !ValidateObjectAccess( SPOOLER_OBJECT_PRINTER,
                                       DesiredAccess,
                                       pSpool,
                                       &pSpool->GrantedAccess,
                                       pIniSpooler )) {
                SetLastError(ERROR_ACCESS_DENIED);
                RouterReturnValue = ROUTER_STOP_ROUTING;
            }
            DesiredAccess &= ~PRINTER_ACCESS_ADMINISTER;

            // clean up
            FreeSplMem( pSpool );

            // If the user had no ADMIN privilege, fail the open call.
            if( RouterReturnValue == ROUTER_STOP_ROUTING )
                goto WrapUp;
        }

        //
        // Create the printer handle that we will return to the user.
        //


        if( pFullPrinterName != pPrinterName) {
            SIZE_T  cchMaxString = 0;

            cchMaxString = min(COUNTOF(string), (size_t) (pPrinterName - pFullPrinterName));

            StringCchCopy(string, cchMaxString, pFullPrinterName);

        } else {

            StringCchCopy(string, COUNTOF(string), pIniSpooler->pMachineName);
        }


        *pPrinterHandle = CreatePrinterHandle( pFullPrinterName,
                                               string,
                                               pIniPrinter,
                                               pIniPort,
                                               pIniNetPort,
                                               pIniJob,
                                               TypeofHandle,
                                               hPort,
                                               pDefaults,
                                               pIniSpooler,
                                               DesiredAccess,
                                               pSplClientInfo,
                                               dwLevel,
                                               hReadFile );

        if( *pPrinterHandle ){

            //
            // Update the OpenPortError.
            //
            ((PSPOOL)*pPrinterHandle)->OpenPortError = OpenPortError;

        } else {
            SPLASSERT( GetLastError( ));
            RouterReturnValue = ROUTER_STOP_ROUTING;
        }
    }

WrapUp:

    LeaveSplSem();
    //
    // Don't have an SplOutSem as we could be called recursively.
    //

    switch( RouterReturnValue ){
    case ROUTER_SUCCESS:

        DBGMSG( DBG_TRACE, ("OpenPrinter returned handle %x\n", *pPrinterHandle));
        SPLASSERT( *pPrinterHandle );
        break;

    case ROUTER_UNKNOWN:

        SPLASSERT( !TypeofHandle && !pIniPrinter && !pIniPort &&
                   !pIniNetPort && !pIniJob && !hPort );

        //
        // hPort should not be valid.  If it is, we have leaked a handle.
        //
        SPLASSERT( !hPort );
        SPLASSERT( hReadFile == INVALID_HANDLE_VALUE );
        DBGMSG( DBG_TRACE, ( "OpenPrinter failed, invalid name "TSTR"\n",
                             pFullPrinterName ));
        SetLastError( ERROR_INVALID_NAME );
        break;

    case ROUTER_STOP_ROUTING:

        LastError = GetLastError();
        SPLASSERT( LastError );

        //
        // On failure, we may have opened a port or file handle. We need
        // to close it since we won't return a valid handle, and
        // so ClosePrinter will never get called.
        //

        if( hPort != INVALID_PORT_HANDLE ) {
            ClosePrinter( hPort );
        }

        if ( pIniJob && (pIniJob->hFileItem == INVALID_HANDLE_VALUE) )
        {
            if ( hReadFile != INVALID_HANDLE_VALUE ) {
                CloseHandle( hReadFile );
                hReadFile = INVALID_HANDLE_VALUE;
            }
        }

        DBGMSG( DBG_TRACE, ("OpenPrinter "TSTR" failed: Error %d\n",
                            pFullPrinterName, GetLastError()));

        SetLastError( LastError );
        break;
    }

    return RouterReturnValue;
}


BOOL
SplClosePrinter(
    HANDLE hPrinter
    )
{
    PSPOOL pSpool=(PSPOOL)hPrinter;
    PSPOOL *ppIniSpool = NULL;
    PINISPOOLER pIniSpoolerDecRef = NULL;
    PSPLMAPVIEW pSplMapView;
    PMAPPED_JOB pMappedJob;
    BOOL bValid;
    DWORD Position;

    //
    // Allow us to close zombied handles.
    //
    EnterSplSem();

    pSpool->Status &= ~SPOOL_STATUS_ZOMBIE;

    if (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT) {
        bValid = ValidateXcvHandle(pSpool->pIniXcv);
    } else {
        bValid = ValidateSpoolHandle(pSpool, 0);
    }


    LeaveSplSem();

    if( !bValid ){
        return FALSE;
    }

    if (pSpool->Status & SPOOL_STATUS_STARTDOC) {

        // it looks as though this might cause a double
        // decrement of pIniJob->cRef once inside LocalEndDocPrinter
        // and the other later in this routine.

        LocalEndDocPrinter(hPrinter);
    }

    if ((pSpool->TypeofHandle & PRINTER_HANDLE_JOB) && 
        (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT)) {

        //
        // If EndDoc is still waiting for a final ReadPrinter
        //
        if (pSpool->pIniJob->cbBuffer) { // Amount last transmitted

            //
            // Wake up the EndDoc Thread
            //
            SetEvent(pSpool->pIniJob->WaitForRead);

            SplOutSem();

            //
            // Wait until he is finished
            //
            WaitForSingleObject(pSpool->pIniJob->WaitForWrite, INFINITE);

            EnterSplSem();

            //
            // Now it is ok to close the handles
            //
            if (!CloseHandle(pSpool->pIniJob->WaitForWrite)) {
                DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n",
                                   pSpool->pIniJob->WaitForWrite, GetLastError()));
            }

            if (!CloseHandle(pSpool->pIniJob->WaitForRead)) {
                DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n",
                                   pSpool->pIniJob->WaitForRead, GetLastError()));
            }
            pSpool->pIniJob->WaitForRead = NULL;
            pSpool->pIniJob->WaitForWrite = NULL;

            LeaveSplSem();
        }

        DBGMSG(DBG_TRACE, ("ClosePrinter(DIRECT):cRef = %d\n", pSpool->pIniJob->cRef));
    }

    //
    // Unmap all views of the spool file and close file mapping handles
    //
    while (pSplMapView = pSpool->pSplMapView) {

        pSpool->pSplMapView = pSplMapView->pNext;

        if (pSplMapView->pStartMapView) {
            UnmapViewOfFile( (LPVOID) pSplMapView->pStartMapView);
        }

        //
        // CreateFileMapping returns NULL (not INVALID_HANDLE_VALUE) for failure
        //
        if (pSplMapView->hMapSpoolFile) {
            CloseHandle(pSplMapView->hMapSpoolFile);
        }

        FreeSplMem(pSplMapView);
    }

    //
    // Delete all mapped spool files that are not required
    //
    EnterSplSem();

    //
    // Mark the handle as being in a closing state, this is to prevent the 
    // mapped files being deleted in DeleteJob    
    // 
    pSpool->eStatus |= STATUS_CLOSING;

    while (pMappedJob = pSpool->pMappedJob)
    {

        PMAPPED_JOB     pNextMappedJob = NULL;

        pNextMappedJob = pMappedJob->pNext;

        //
        // Since we can have multiple addjobs on any one handle, we run through
        // all of the mapped jobs, check to see if the mapped job is marked
        // as being added through AddJob and then we schedule it. We need to
        // call this before we remove the job from the handle list or
        // LocalScheduleJob will not recognize the job.
        //
        if (!(pSpool->TypeofHandle & PRINTER_HANDLE_JOB) && (pMappedJob->fStatus & kMappedJobAddJob)) {

            LeaveSplSem();

            LocalScheduleJob(hPrinter, pMappedJob->JobId);

            EnterSplSem();
        }

        //
        // We rely on serialization of the pSpool handle here at the RPC level.
        //
        pSpool->pMappedJob = pNextMappedJob;

        if (!pSpool->pIniPrinter ||
            !FindJob(pSpool->pIniPrinter, pMappedJob->JobId, &Position))
        {
            //
            // The job is gone and we have to delete the spool file
            //
            LeaveSplSem();

            //
            // This may need looking at for File Pooling
            //
            DeleteFile(pMappedJob->pszSpoolFile);

            EnterSplSem();

            if (pSpool->pIniPrinter)
            {
                vMarkOff( pSpool->pIniPrinter->pIniSpooler->hJobIdMap,
                          pMappedJob->JobId );
            }
        }

        FreeSplMem(pMappedJob->pszSpoolFile);
        FreeSplMem(pMappedJob);
    }

    LeaveSplSem();
       
    if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

        //
        // Move the file pointer to the number of bytes committed and set the end of
        // file.
        //
        if ((pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) &&
            SetFilePointer(pSpool->hReadFile, pSpool->pIniJob->dwValidSize,
                           NULL, FILE_BEGIN) != 0xffffffff) {

             SetEndOfFile(pSpool->hReadFile);
        }

        //
        // File pooling Change, we close the file handle if we aren't file
        // pooling and we reset the seek pointer if we are file pooling.
        //
        if (pSpool->pIniJob)
        {
            if (pSpool->pIniJob->hFileItem == INVALID_HANDLE_VALUE)
            {
                if ( !CloseHandle( pSpool->hReadFile ) ) {

                    DBGMSG(DBG_WARNING, ("ClosePrinter CloseHandle(%d) failed %d\n", pSpool->hReadFile, GetLastError()));
                }
            }
            else
            {
                //
                // People call ClosePrinter / OpenPrinter in sequence to be able
                // to read from the beginning of the spool file again. To get the
                // same effect, we need to set the seek pointer back to the
                // beginning of the hReadFile.
                //
                DWORD rc = ERROR_SUCCESS;

                rc = SetFilePointer(pSpool->hReadFile, 0, NULL, FILE_BEGIN);

                if (rc != ERROR_SUCCESS)
                {
                    DBGMSG(DBG_WARNING, ("ClosePrinter SetFilePointer(%p) failed %d\n", pSpool->hReadFile, rc));
                }
            }
        }
    }

    //
    // Close the handle that was opened via OpenPrinterPort:
    //
    if (pSpool->hPort) {

        if (pSpool->hPort != INVALID_PORT_HANDLE) {

            ClosePrinter(pSpool->hPort);

        } else {

            DBGMSG(DBG_WARNING, ("ClosePrinter ignoring bad port handle.\n"));
        }
    }

   EnterSplSem();

    //
    // Right at the end remove our reference to the job if this is a job handle.
    // 
    if (pSpool->TypeofHandle & PRINTER_HANDLE_JOB) {

        DBGMSG(DBG_TRACE, ("ClosePrinter:cRef = %d\n", pSpool->pIniJob->cRef));
        DECJOBREF(pSpool->pIniJob);
        DeleteJobCheck(pSpool->pIniJob);
    }   

    //
    // Remove us from the linked list of handles:
    //
    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        SPLASSERT( pSpool->pIniPrinter->signature == IP_SIGNATURE );

        ppIniSpool = &pSpool->pIniPrinter->pSpool;
    }
    else if ((pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) ||
             (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT)) {

        SPLASSERT( pSpool->pIniSpooler->signature == ISP_SIGNATURE );

        if (pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT)
            XcvClose(pSpool->pIniXcv);

        pIniSpoolerDecRef = pSpool->pIniSpooler;
        ppIniSpool = &pSpool->pIniSpooler->pSpool;
    }

    if (ppIniSpool) {

        while (*ppIniSpool && *ppIniSpool != pSpool)
            ppIniSpool = &(*ppIniSpool)->pNext;

        if (*ppIniSpool)
            *ppIniSpool = pSpool->pNext;

        else {

            DBGMSG( DBG_WARNING, ( "Didn't find pSpool %08x in linked list\n", pSpool ) );
        }
    }

    if (pSpool->pIniPrinter) {

        DECPRINTERREF( pSpool->pIniPrinter );

        DeletePrinterCheck(pSpool->pIniPrinter);

    }

    DeletePrinterHandle(pSpool);

    if (pIniSpoolerDecRef) {
        DECSPOOLERREF( pIniSpoolerDecRef );
    }

   LeaveSplSem();

    //
    // Don't call SplOutSem() since SplAddPrinter calls
    // use from inside the critical section.
    //

    return TRUE;
}

/*++

Routine Name:

    GetClientSessionData

Routine Description:

    This returns the session ID and the token handle for the current user. If the
    token handle is not requested we will only return the session id. As long as
    we can get a token, we will return a session ID of 0.

Arguments:

    plSessionId         -   The returned session id.

Return Value:

    TRUE if the session ID and token could be retrieved.

--*/
BOOL
GetClientSessionData(
    OUT ULONG           *plSessionId    
    )
{
    BOOL          Result;
    HANDLE        TokenHandle = NULL;
    ULONG         SessionId   = 0;
    ULONG         ReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // SessionId from out token.
    //
    // We may not have a valid one if this is a remote network
    // connection.
    Result = plSessionId != NULL;

    if (!Result)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    //
    // Get the thread token handle, failing that the process handle.
    //
    if (Result)
    {
        Result = GetTokenHandle(&TokenHandle);
    }

    if(Result)
    {

        //
        // Query the SessionID from the token added by HYDRA
        //
        Result = GetTokenInformation(
                     TokenHandle,
                     (TOKEN_INFORMATION_CLASS)TokenSessionId,
                     &SessionId,
                     sizeof(SessionId),
                     &ReturnLength);

        if (!Result)
        {
            Result = TRUE;
            SessionId = 0;
        }
    }

    if (TokenHandle) 
    {
        CloseHandle(TokenHandle);
    }

    if (plSessionId)
    {
        *plSessionId = SessionId;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\msgbox.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    msgbox.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    LocalAddPrinterConnection
    LocalDeletePrinterConnection
    LocalPrinterMessageBox

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/
#define NOMINMAX

#include <precomp.h>

#pragma hdrstop
#include "winsta.h"
#define WINSTATION_PRINTER_MESSAGE_TIMEOUT  (5*60)


HANDLE WinStaDllHandle = NULL;
PWINSTATION_SEND_MESSAGEW pWinStationSendMessage = NULL;


DWORD
LocalPrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    //
    // Always fail this call.  It's completely bogus and shouldn't be
    // supported.  The router always passes us a bad handle anyway, so
    // we will always return invalid handle.
    //
    SetLastError(ERROR_INVALID_HANDLE);
    return FALSE;
}

BOOL
UpdateJobStatus(
    PSPOOL pSpool,
    DWORD Error
    )

/*++

Routine Description:

    Update job status based on Error.

Arguments:

    pSpool - Handle of session.

    Error - Error returned from port monitor.

Return Value:

    TRUE - Job is still valid.
    FALSE - Job is pending deletion.

--*/

{
    DWORD   dwJobStatus;

    PINIJOB pIniJob = NULL;

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if (pIniJob) {

        EnterSplSem();

        dwJobStatus = pIniJob->Status;

        switch  (Error) {

        case ERROR_BAD_DEV_TYPE:
        case ERROR_INVALID_NAME:
        case ERROR_PRINT_CANCELLED:
            //
            // If we have a problem with the port name, we will not find
            // a WinStation to put the message on. So kill the job to
            // prevent the spooler from looping.
            //
            pSpool->Status |= SPOOL_STATUS_CANCELLED;
            InterlockedOr((LONG*)&(pIniJob->Status), JOB_PENDING_DELETION);

            //
            // Release any thread waiting on LocalSetPort
            //
            SetPortErrorEvent(pIniJob->pIniPort);

            //
            // Release any thread waiting on SeekPrinter
            //
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);

            SetLastError(ERROR_PRINT_CANCELLED);
            LeaveSplSem();
            SplOutSem();
            return FALSE;

        case ERROR_OUT_OF_PAPER:

            if( !( pIniJob->Status & JOB_PAPEROUT )){

                InterlockedOr((LONG*)&(pIniJob->Status), JOB_PAPEROUT);
                pIniJob->pIniPrinter->cErrorOutOfPaper++;
            }
            break;

        case ERROR_NOT_READY:

            if( !( pIniJob->Status & JOB_OFFLINE )){

                InterlockedOr((LONG*)&(pIniJob->Status), JOB_OFFLINE);
                pIniJob->pIniPrinter->cErrorNotReady++;
            }
            break;

        default:

            if( !( pIniJob->Status & JOB_ERROR )){

                InterlockedOr((LONG*)&(pIniJob->Status), JOB_ERROR);
                pIniJob->pIniPrinter->cJobError++;
            }

            pIniJob->pIniPrinter->dwLastError = Error;

            // Release any thread waiting on SeekPrinter
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);
            break;
        }

        if( dwJobStatus != pIniJob->Status ){

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatus,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler );
        }

        LeaveSplSem();

        if(( pIniJob->Status & JOB_REMOTE ) &&
             pIniJob->pIniPrinter->pIniSpooler->bEnableNetPopups) {

            if (!(pIniJob->Status & JOB_NOTIFICATION_SENT)) {
                SendJobAlert(pIniJob);
                InterlockedOr((LONG*)&(pIniJob->Status), JOB_NOTIFICATION_SENT);
            }
            MyMessageBeep( MB_ICONEXCLAMATION,
                           pIniJob->pIniPrinter->pIniSpooler );
        }
    }
    return TRUE;
}


DWORD
MyMessageBox(
    HWND    hWnd,
    PSPOOL  pSpool,
    DWORD   Error,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
    )
{
    PINIJOB pIniJob = NULL;
    LPWSTR  pErrorString, pDocumentName;
    HANDLE  hToken;
    WCHAR   szUnnamed[80];
    DWORD   dwJobStatus;

    DWORD SessionId = DetermineJobSessionId(pSpool);

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if (pIniJob) {

        if (pText) {

            Error = WinStationMessageBox(SessionId, hWnd, pText, pCaption, dwType);

        } else {

            pErrorString = Error == ERROR_NOT_READY ||
                           Error == ERROR_OUT_OF_PAPER ||
                           Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
                           Error == ERROR_DEVICE_REQUIRES_CLEANING ||
                           Error == ERROR_DEVICE_DOOR_OPEN ||
                           Error == ERROR_DEVICE_NOT_CONNECTED ? GetErrorString(Error) : NULL;


            if (hToken = RevertToPrinterSelf())
            {

                pDocumentName = pIniJob->pDocument;

                if (!pDocumentName) {
                    *szUnnamed = L'\0';
                    LoadString( hInst, IDS_UNNAMED, szUnnamed,
                                sizeof szUnnamed / sizeof *szUnnamed );
                    pDocumentName = szUnnamed;
                }

                if (pSpool->pIniPort) {


                    Error = WinStationMessage(SessionId,
                                    NULL,
                                    MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                                    IDS_LOCALSPOOLER,
                                    IDS_ERROR_WRITING_TO_PORT,
                                    pDocumentName,
                                    pSpool->pIniPort->pName,
                                    pErrorString ? pErrorString : szNull);
                } else {

                    Error = WinStationMessage(SessionId,
                                    NULL,
                                    MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                                    IDS_LOCALSPOOLER,
                                    IDS_ERROR_WRITING_TO_DISK,
                                    pDocumentName,
                                    pErrorString ? pErrorString : szNull);
                }

                if (!ImpersonatePrinterClient(hToken))
                {
                    Error = IDCANCEL;
                }
            }

            FreeSplStr(pErrorString);
            
        }

    } else {

        PWCHAR pPrinterName = NULL;

        //
        // There is no pIniJob or pIniPort, so we can't be very informative:
        //
        pErrorString = Error == ERROR_NOT_READY ||
                       Error == ERROR_OUT_OF_PAPER ||
                       Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
                       Error == ERROR_DEVICE_REQUIRES_CLEANING ||
                       Error == ERROR_DEVICE_DOOR_OPEN ||
                       Error == ERROR_DEVICE_NOT_CONNECTED ? GetErrorString(Error) : NULL;

        if (pSpool->pIniPrinter)
            pPrinterName = pSpool->pIniPrinter->pName;

        if (!pPrinterName) {

            *szUnnamed = L'\0';
            LoadString( hInst, IDS_UNNAMED, szUnnamed,
                        COUNTOF( szUnnamed ));
            pPrinterName = szUnnamed;
        }


        Error = WinStationMessage(SessionId,
                        NULL,
                        MB_ICONSTOP | MB_RETRYCANCEL | MB_SETFOREGROUND,
                        IDS_LOCALSPOOLER,
                        IDS_ERROR_WRITING_GENERAL,
                        pSpool->pIniPrinter->pName,
                        pErrorString ? pErrorString : szNull);

        FreeSplStr(pErrorString);
    }

    if (Error == IDCANCEL) {
        EnterSplSem();
        pSpool->Status |= SPOOL_STATUS_CANCELLED;
        if (pIniJob) {
            InterlockedOr((LONG*)&(pIniJob->Status), JOB_PENDING_DELETION);
            // Release any thread waiting on LocalSetPort
            SetPortErrorEvent(pIniJob->pIniPort);
            pIniJob->dwAlert |= JOB_NO_ALERT;
            // Release any thread waiting on SeekPrinter
            SeekPrinterSetEvent(pIniJob, NULL, TRUE);
        }
        LeaveSplSem();
        SplOutSem();
        SetLastError(ERROR_PRINT_CANCELLED);

    }
    return Error;
}


// Exclusively for use of the following routines. This is done so we would not have
// to store LastError in PSPOOL.
typedef struct _AUTORETRYTHDINFO {
    PSPOOL       pSpool;
    DWORD        LastError;
} AUTORETRYTHDINFO;
typedef AUTORETRYTHDINFO *PAUTORETRYTHDINFO;


// ------------------------------------------------------------------------
// SpoolerBMThread
//
// Thread start up routine for the spooler error message box thread. Exit
// code is the return ID from MessageBox.
//
// ------------------------------------------------------------------------
DWORD
WINAPI
SpoolerMBThread(
    PAUTORETRYTHDINFO pThdInfo
)
{
    DWORD rc;

    rc = MyMessageBox( NULL, pThdInfo->pSpool, pThdInfo->LastError, NULL, NULL, 0 );

    FreeSplMem( pThdInfo );
    return rc;
}


#define _ONE_SECOND     1000                         // in milliseconds
#define SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND   5     // seconds

// ------------------------------------------------------------------------
// PromptWriteError
//
// we'll start a seperate thread to bring up
// the message box while we'll (secretly) automatically retry on this
// current thread, until user has chosen to retry or cancel. Call the error UI
// on the main thread if printing direct.
//
// ------------------------------------------------------------------------
DWORD
PromptWriteError(
    PSPOOL   pSpool,
    PHANDLE  phThread,
    PDWORD   pdwThreadId
)
{
    DWORD Error = GetLastError();
    DWORD dwExitCode;
    DWORD dwWaitCount = 0;

    SplOutSem();

    if( !UpdateJobStatus( pSpool, Error )){
        return IDCANCEL;
    }

    //
    // If the spooler doesn't have popup retry messageboxes enabled, then
    // just sleep and return.
    //
    if( !pSpool->pIniSpooler->bEnableRetryPopups ){

        Sleep( SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND * _ONE_SECOND );
        return IDRETRY;
    }

    // start a seperate thread to display the message box
    // so we can continue to retry here
    // or simply sleep for 5 seconds if we have already done so

    if( !*phThread ) {

        // start a thread to bring up the message box

        PAUTORETRYTHDINFO pThdInfo;

        pThdInfo = (PAUTORETRYTHDINFO)AllocSplMem( sizeof(AUTORETRYTHDINFO));

        if ( pThdInfo == NULL ) {
            DBGMSG( DBG_WARNING, ("PromptWriteError failed to allocate AUTORETRYTHDINFO %d\n", GetLastError() ));
            goto _DoItOnCurrentThread;
        }

        pThdInfo->pSpool    = pSpool;
        pThdInfo->LastError = Error;

        if (!(*phThread = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)SpoolerMBThread,
            pThdInfo, 0, pdwThreadId))) {

            DBGMSG(DBG_WARNING, ("PromptWriteError: CreateThread Failed.\n"));
            FreeSplMem( pThdInfo );
            goto _DoItOnCurrentThread;
        }
    }

    while (1) {

        // we've already started a MB thread, check if user has terminated
        // the message box

        if (GetExitCodeThread( *phThread, &dwExitCode) && (dwExitCode != STILL_ACTIVE)) {

            // if the thread has been terminated, find out the exit code
            // which is the return ID from MessageBox, then close the
            // thread handle.

            CloseHandle( *phThread );
            *phThread = 0;
            return dwExitCode;
        }

        if (dwWaitCount++ >= SPOOL_WRITE_RETRY_INTERVAL_IN_SECOND)
            break;

        Sleep(_ONE_SECOND);
    }

    return IDRETRY;

_DoItOnCurrentThread:

    return MyMessageBox(NULL, pSpool, Error, NULL, NULL, 0 );
}

DWORD
DetermineJobSessionId(
    PSPOOL pSpool
    )

/*++

Routine Description:

    Determine which session to notify for the current job.

Arguments:

    pSpool - Open spooler handle

Return Value:

    SessionId to send notification message to.

--*/

{
    PINIJOB pIniJob = NULL;

    if (pSpool->pIniJob)
        pIniJob = pSpool->pIniJob;
    else if (pSpool->pIniPort)
        pIniJob = pSpool->pIniPort->pIniJob;

    if( pIniJob ) return( pIniJob->SessionId );

    return( pSpool->SessionId );
}

int
WinStationMessageBox(
    DWORD   SessionId,
    HWND    hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT    uType
    )

/*++

Routine Description:

    Displays a message on the WinStation named by SessionId.

    If any problems in actually displaying the message, wait for the
    the message box timeout interval before returning. This prevents
    a spin in the spooler attempting to retry the print job without a
    message box to block the thread.

Arguments:

    SessionId - ID of session to display the message on.

Return Value:

    Result of MessageBox().

--*/

{
    UINT    uOldErrorMode;
    DWORD   MsgLength, CaptionLength, Response;
    BOOL    Result;
    va_list vargs;

    //
    // Standard NT is always SessionId == 0.
    // On Hydra, the system console is always SessionId == 0.
    //
    if( SessionId == 0 ) {
        return( MessageBox( hWnd, lpText, lpCaption, uType ) );
    }

    //
    // If its not SessionId == 0, then we must deliver
    // the message to a session connected on a Hydra
    // server. Non-Hydra will not ever allocate a
    // SessionId != 0.
    //
    // On failure, we send the message to the console.
    //

    if( pWinStationSendMessage == NULL ) {

        uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        WinStaDllHandle = LoadLibrary(L"winsta.dll");
        SetErrorMode(uOldErrorMode);

        if( WinStaDllHandle == NULL ) {
            return( MessageBox( hWnd, lpText, lpCaption, uType ) );
        }

        pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                     WinStaDllHandle,
                                     "WinStationSendMessageW"
                                     );

        if( pWinStationSendMessage == NULL ) {
            return( MessageBox( hWnd, lpText, lpCaption, uType ) );
        }
    }

    CaptionLength = (wcslen( lpCaption ) + 1) * sizeof(WCHAR);
    MsgLength = (wcslen( lpText ) + 1) * sizeof(WCHAR);

    // Send the message to the WinStation and wait for a response
    Result = pWinStationSendMessage(
                 SERVERNAME_CURRENT,
                 SessionId,
                 (LPWSTR)lpCaption,
                 CaptionLength,
                 (LPWSTR)lpText,
                 MsgLength,
                 uType,
                 WINSTATION_PRINTER_MESSAGE_TIMEOUT,
                 &Response,
                 FALSE
                 );

    if( Result ) {
        // If not an expected response, wait to prevent spinning
        if( (Response != IDTIMEOUT) &&
            (Response != IDOK) &&
            (Response != IDCANCEL) &&
            (Response != IDRETRY) &&
            (Response != IDIGNORE) &&
            (Response != IDYES) &&
            (Response != IDNO) ) {
            // Sleep to prevent a spin
            Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        }
        return( Response );
    }
    else {
        // Sleep to prevent a spin
        Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        return( 0 );
    }
}

int
WinStationMessage(
    DWORD SessionId,
    HWND  hWnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
    )

/*++

Routine Description:

    Displays a message on the WinStation named by SessionId. This takes
    the message text and caption from the resource file.

    If any problems in actually display the message, wait for the
    the message box timeout interval before returning. This prevents
    a spin in the spooler attempting to retry the print job without a
    message box to block the thread.

Arguments:

    SessionId - ID of session to display the message on.

Return Value:

    Result of MessageBox().

--*/

{
    UINT    uOldErrorMode;
    WCHAR   MsgText[512];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    DWORD   MsgLength, CaptionLength, Response;
    BOOL    Result;
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        StringCchVPrintf(MsgText, COUNTOF(MsgText), MsgFormat, vargs);
        MsgText[COUNTOF(MsgText)-1] = 0;
        va_end( vargs );

        if( SessionId == 0 ) {
            return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
        }

        if( pWinStationSendMessage == NULL ) {

            uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
            WinStaDllHandle = LoadLibrary(L"winsta.dll");
            SetErrorMode(uOldErrorMode);

            if( WinStaDllHandle == NULL ) {
                return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
            }

            pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                         WinStaDllHandle,
                                         "WinStationSendMessageW"
                                         );

            if( pWinStationSendMessage == NULL ) {
                return( MessageBox( hWnd, MsgText, MsgCaption, Type ) );
            }
        }

        CaptionLength = (wcslen( MsgCaption ) + 1) * sizeof(WCHAR);
        MsgLength = (wcslen( MsgText ) + 1) * sizeof(WCHAR);

        // Send the message to the WinStation and wait for a response
        Result = pWinStationSendMessage(
                     SERVERNAME_CURRENT,
                     SessionId,
                     MsgCaption,
                     CaptionLength,
                     MsgText,
                     MsgLength,
                     Type,     // Style
                     WINSTATION_PRINTER_MESSAGE_TIMEOUT,
                     &Response,
                     FALSE     // DoNotWait
                     );

        if( Result ) {
            // If not an expected response, wait to prevent spinning
            if( (Response != IDTIMEOUT) &&
                (Response != IDOK) &&
                (Response != IDCANCEL) &&
                (Response != IDRETRY) &&
                (Response != IDIGNORE) &&
                (Response != IDYES) &&
                (Response != IDNO) ) {
                // Sleep to prevent a spin
                Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
            }
            return( Response );
        }
        else {
            // Sleep to prevent a spin
            Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
            return( 0 );
        }
    }
    else {
        // Sleep to prevent a spin
        Sleep( WINSTATION_PRINTER_MESSAGE_TIMEOUT*1000);
        return 0;
    }
}

DWORD
LclIsSessionZero (
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
)
/*++

Routine Description:

    Determines if the Job was submitted in Session 0.

Arguments:

    hPrinter  - printer handle
    JobId     - Job ID
    pResponse - TRUE if the Job was submitted in Session0

Return Value:

    Last Error

--*/
{
    DWORD   dwRetValue  = ERROR_SUCCESS;
    DWORD   SessionId   = -1;
    PSPOOL  pSpool      = (PSPOOL)hPrinter;


    if (pSpool && JobId && pIsSessionZero)
    {
        SessionId = GetJobSessionId(pSpool, JobId);
    }

    if(SessionId == -1)
    {
        dwRetValue = ERROR_INVALID_PARAMETER;
    }
    else
    {
        *pIsSessionZero = (SessionId == 0);
    }

    return dwRetValue;

}


BOOL
LclPromptUIPerSessionUser(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
)
/*++

Routine Description:

    Pops TS Message Box in the Session that created the Job.

Arguments:

    hPrinter  - printer handle
    JobId     - Job ID
    pUIParams - UI Parameters
    pResponse - user's response

Return Value:

    TRUE if it was able to show the UI

--*/
{
    PSPOOL      pSpool      = (PSPOOL)hPrinter;
    DWORD       SessionId   = -1;
    PINIJOB     pIniJob     = NULL;
    DWORD       dwReturnVal = 0;
    DWORD       MessageLength;
    DWORD       TitleLength;
    BOOL        bRetValue   = FALSE;

    if (pSpool && JobId && pUIParams && pResponse)
    {
        SessionId = GetJobSessionId(pSpool, JobId);
    }

    if(SessionId == -1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        switch (pUIParams->UIType)
        {
            case kMessageBox:
            {
                if (pUIParams->MessageBoxParams.cbSize == sizeof(MESSAGEBOX_PARAMS) &&
                    pUIParams->MessageBoxParams.pTitle &&
                    pUIParams->MessageBoxParams.pMessage &&
                    InitializeMessageBoxFunction())
                {
                    TitleLength   = (wcslen(pUIParams->MessageBoxParams.pTitle) + 1) * sizeof(WCHAR);
                    MessageLength = (wcslen(pUIParams->MessageBoxParams.pMessage) + 1) * sizeof(WCHAR);

                    bRetValue   =  pWinStationSendMessage(
                                        SERVERNAME_CURRENT,
                                        SessionId,
                                        pUIParams->MessageBoxParams.pTitle,
                                        TitleLength,
                                        pUIParams->MessageBoxParams.pMessage,
                                        MessageLength,
                                        pUIParams->MessageBoxParams.Style,
                                        pUIParams->MessageBoxParams.dwTimeout,
                                        pResponse,
                                        !pUIParams->MessageBoxParams.bWait);
                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                }
            }
            default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return bRetValue;
}


BOOL
InitializeMessageBoxFunction(
)
/*++

Routine Description:

    Returns the address of WinStationSendMessageW exported by winsta.dll.
    WTSSendMessage could have been used instead of doing this.


Arguments:

    None.

Return Value:

    The address of WinStationSendMessageW.

--*/
{
    UINT    uOldErrorMode;

    if (!pWinStationSendMessage)
    {
        if (WinStaDllHandle == NULL)
        {
            uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

            WinStaDllHandle = LoadLibrary(L"winsta.dll");

            SetErrorMode(uOldErrorMode);
        }

        if(WinStaDllHandle != NULL)
        {
            pWinStationSendMessage = (PWINSTATION_SEND_MESSAGEW)GetProcAddress(
                                      WinStaDllHandle,
                                      "WinStationSendMessageW"
                                      );
        }
    }

    return !!pWinStationSendMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\port.c ===
/*++


Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains functions to control port threads

    PrintDocumentThruPrintProcessor
    CreatePortThread
    DestroyPortThread
    PortThread

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

   KrishnaG  3-Feb-1991 - moved all monitor based functions to monitor.c
   Matthew Felton (mattfe) Feb 1994    Added OpenMonitorPort CloseMonitorPort

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include "filepool.hxx"

WCHAR *szFilePort = L"FILE:";


VOID
PrintDocumentThruPrintProcessor(
    PINIPORT pIniPort,
    PPRINTPROCESSOROPENDATA pOpenData
    );


// ShutdownPorts
//
// Called when the DLL_PROCESS_DETATCH is called
// Close all portthreads
// Close all monitorports

VOID
ShutdownPorts(
    PINISPOOLER pIniSpooler
)
{
    PINIPORT pIniPort;

    if (!pIniSpooler || (pIniSpooler == INVALID_HANDLE_VALUE))
    {
        return;
    }

    EnterSplSem();
    SplInSem();

    pIniPort = pIniSpooler->pIniPort;

    while(pIniPort) {

        DestroyPortThread(pIniPort, TRUE);

        //
        // Don't close monitor port since DLL_ATTACH may have been called
        //
        // CloseMonitorPort(pIniPort);

        RemoveDeviceName(pIniPort);
        pIniPort = pIniPort->pNext;
    }

   LeaveSplSem();

    return;
}

BOOL
CreatePortThread(
   PINIPORT pIniPort
)
{
    DWORD   ThreadId;
    BOOL    bReturnValue = FALSE;

    SplInSem();

    SPLASSERT (( pIniPort != NULL) &&
               ( pIniPort->signature == IPO_SIGNATURE));

    // Don't bother creating a thread for ports that don't have a monitor:

    if (!(pIniPort->Status & PP_MONITOR))
        return TRUE;


    if ( pIniPort->Status & PP_THREADRUNNING)
        return TRUE;


 try {

    pIniPort->Semaphore = CreateEvent(NULL, FALSE, FALSE, NULL);

    if ( pIniPort->Semaphore == NULL )
        leave;

    pIniPort->Ready     = CreateEvent(NULL, FALSE, FALSE, NULL);
    if ( pIniPort->Ready == NULL ) {
        leave;
    }

    pIniPort->Status |= PP_RUNTHREAD;

    pIniPort->hPortThread = CreateThread(NULL, INITIAL_STACK_COMMIT,
                             (LPTHREAD_START_ROUTINE)PortThread,
                             pIniPort,
                            0, &ThreadId);


    if( pIniPort->hPortThread == NULL ) {

        pIniPort->Status &= ~PP_RUNTHREAD;
        leave;
    }

     if ( !SetThreadPriority(pIniPort->hPortThread, dwPortThreadPriority) ) {
         DBGMSG(DBG_WARNING, ("CreatePortThread - Setting thread priority failed %d\n", GetLastError()));
     }

     LeaveSplSem();

     // Make CreatePortThread Synchronous

     WaitForSingleObject( pIniPort->Ready, INFINITE );

     EnterSplSem();
     SplInSem();

     pIniPort->Status |= PP_THREADRUNNING;

     bReturnValue = TRUE;

 } finally {

    if ( !bReturnValue ) {

        if ( pIniPort->Semaphore != NULL ) {

            CloseHandle( pIniPort->Semaphore );
            pIniPort->Semaphore = NULL;
        }

        if ( pIniPort->Ready != NULL ) {

            CloseHandle( pIniPort->Ready );
            pIniPort->Ready = NULL;
            SetEvent( pIniPort->hPortThreadRunning );
        }
    }
 }
    return bReturnValue;

}






BOOL
DestroyPortThread(
    PINIPORT    pIniPort,
    BOOL        bShutdown
)
{
    SplInSem();

    // PortThread checks for PP_RUNTHREAD
    // and exits if it is not set.

    pIniPort->Status &= ~PP_RUNTHREAD;

    if (pIniPort->Semaphore && !SetEvent(pIniPort->Semaphore)) {
        return  FALSE;
    }

    if( pIniPort->hPortThread != NULL) {

        INCPORTREF(pIniPort);
        LeaveSplSem();

        if ( WaitForSingleObject( pIniPort->hPortThread, INFINITE) == WAIT_FAILED ) {

            EnterSplSem();
            DECPORTREF(pIniPort);
            return FALSE;
        }

        EnterSplSem();
        DECPORTREF(pIniPort);
    }

    if (pIniPort->hPortThread != NULL) {

        CloseHandle(pIniPort->hPortThread);
        pIniPort->hPortThread = NULL;

    }

    //
    // The port may have been changed while the printer was printing.
    // Thus when the port thread finally goes away now is the time to
    // close the monitor. However we can't call the monitor during shutdown
    // since DLL_DETACH may already have been issued to the monitor dll
    //
    if ( !pIniPort->cPrinters && !bShutdown)
        CloseMonitorPort(pIniPort);

    return TRUE;
}


VOID
RemoveIniPortFromIniJob(
    PINIJOB     pIniJob,
    PINIPORT    pIniPort
    )
{
    PINISPOOLER pIniSpooler = pIniJob->pIniPrinter->pIniSpooler;

    NOTIFYVECTOR NotifyVector;

    SplInSem();

    //
    // Increment the refcount since deleting the job may delete the
    // pIniJob, which would delete the pIniSpooler.
    //
    INCSPOOLERREF( pIniSpooler );

    SPLASSERT(pIniJob &&
              pIniJob->signature == IJ_SIGNATURE &&
              pIniJob->pIniPort);

    SPLASSERT( pIniJob->pIniPort == pIniPort );

    pIniPort->cJobs--;

    pIniJob->pIniPort = NULL;

    SPLASSERT( pIniJob->Status & JOB_DESPOOLING );

    //  Chained Jobs
    //  For a Chained Master Job do not remove JOB_DESPOOLING
    //  since we don't want the scheduler to reschedule this
    //  to another port

    if ( pIniPort->pIniJob != pIniJob ) {

        //  Normal Path
        //  When NOT a chained job.

        InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_DESPOOLING);

        COPYNV(NotifyVector, NVJobStatus);
        NotifyVector[JOB_NOTIFY_TYPE] |= BIT(I_JOB_PORT_NAME) |
                                         BIT(I_JOB_PAGES_PRINTED) |
                                         BIT(I_JOB_BYTES_PRINTED);

        SetPrinterChange( pIniJob->pIniPrinter,
                          pIniJob,
                          NotifyVector,
                          PRINTER_CHANGE_SET_JOB,
                          pIniSpooler);
    }

    //  RestartJob() doesn't remove JOB_PRINTED or JOB_BLOCKED_DEVQ
    //  or JOB_DESPOOLING or JOB_COMPLETE if the despooling bit is on
    //  this is to avoid problems where we have completed "Printing"
    //  the job via a print processor and now the port thread is logging
    //  the job printed and sending an alert message.


    if ( pIniJob->Status & JOB_RESTART )
        InterlockedAnd((LONG*)&(pIniJob->Status), ~( JOB_PRINTED | JOB_BLOCKED_DEVQ | JOB_COMPLETE));

    DeleteJobCheck(pIniJob);

    //
    // pIniJob may be gone at this point.
    //

    //
    // If we're at zero then set hEventNoPrintingJobs if it exists.
    //
    if( !pIniSpooler->cFullPrintingJobs &&
        pIniSpooler->hEventNoPrintingJobs ){

        SetEvent( pIniSpooler->hEventNoPrintingJobs );
    }

    //
    // Matches INCSPOOLERREF at beginning of this function.
    //
    DECSPOOLERREF( pIniSpooler );
}

DWORD
PortThread(
    PINIPORT  pIniPort
)
{
    DWORD rc;
    PRINTPROCESSOROPENDATA  OpenData;
    PINIJOB pIniJob;
    DWORD   NextJobId = 0;
    DWORD   Position;
    DWORD   dwDevQueryPrint = 0;
    DWORD   dwJobDirect = 0;
    DWORD   dwDevQueryPrintStatus = 0;
    WCHAR   ErrorString[MAX_PATH];
    BOOL    bRawDatatype;

    //
    // Power management.  While we have port threads, we don't want the
    // system to go to sleep.  Note that if we have a hung job, we will
    // not go to sleep.
    //
    SetThreadExecutionState( ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

   EnterSplSem();

    INCSPOOLERREF( pIniPort->pIniSpooler );

    SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

    if ( pIniPort->Status & PP_MONITOR ) {

        if ( pIniPort->Status & PP_FILE ) 
        {
            rc = StatusFromHResult(OpenMonitorPort(pIniPort,
                                                   NULL,
                                                   NULL));
            if (rc == ERROR_SUCCESS)
            {
                ReleaseMonitorPort(pIniPort);
            }
        
            DBGMSG(DBG_TRACE, (" After opening the file pseudo monitor port %d\n", rc));
            
        } else {
            // LPRMON returns NULL ( fails and expect us to open it again
            // inside PrintingDirectlyToPort, so for now remove this assert
            // since OpenMonitorPort was added to PrintingDirectlyToPort
            // SPLASSERT( pIniPort->hPort != NULL );
        }
    }

    SetEvent( pIniPort->Ready );
    ResetEvent( pIniPort->hPortThreadRunning );

    while (TRUE) {

       SplInSem();
        SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

        DBGMSG(DBG_TRACE, ("Re-entering the Port Loop -- will blow away any Current Job\n"));

        pIniPort->Status |= PP_WAITING;
        //
        // Signal Ready event, to tell CreatePortThread that the Loop has successfully started.
        // hPortThreadRunning is signalled in the loop for each port it goes through. (and once
        // before leaving the port thread).
        //
        
        CHECK_SCHEDULER();

        DBGMSG( DBG_PORT, ("Port %ws: WaitForSingleObject( %x )\n",
                            pIniPort->pName, pIniPort->Semaphore ) );

       LeaveSplSem();
       SplOutSem();

        //
        // Any modification to the pIniPort structure by other threads
        // can be done only at this point.
        //

        rc = WaitForSingleObject( pIniPort->Semaphore, INFINITE );

       EnterSplSem();
       SplInSem();

        SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

        DBGMSG( DBG_PORT, ("Port %ws: WaitForSingleObject( %x ) returned\n",
                            pIniPort->pName, pIniPort->Semaphore));

        if ( !( pIniPort->Status & PP_RUNTHREAD ) ) {

            DBGMSG(DBG_TRACE, ("Thread for Port %ws Closing Down\n", pIniPort->pName));

            pIniPort->Status &= ~(PP_THREADRUNNING | PP_WAITING);
            CloseHandle( pIniPort->Semaphore );
            pIniPort->Semaphore = NULL;
            CloseHandle( pIniPort->Ready );
            pIniPort->Ready = NULL;
            SetEvent(pIniPort->hPortThreadRunning);


            if ( pIniPort->Status & PP_FILE ) 
            {
                rc = StatusFromHResult(CloseMonitorPort(pIniPort));
                DBGMSG(DBG_TRACE, (" After closing  the file pseudo monitor port\n %d\n"));

                DBGMSG( DBG_WARN,
                        ( "PortThread: DecSpoolerRef %x\n",
                          pIniPort->pIniSpooler ));                
            }

            DECSPOOLERREF( pIniPort->pIniSpooler );

            LeaveSplSem();
            SplOutSem();

            //
            // Power management.  We are done.
            //
            SetThreadExecutionState(ES_CONTINUOUS);

            ExitThread (FALSE);
        }

        //
        // Bad assumption -- that at this point we definitely have a Job
        //

        if ( ( pIniJob = pIniPort->pIniJob ) &&
               pIniPort->pIniJob->pIniPrintProc ) {

            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );
            SPLASSERT( pIniJob->Status & JOB_DESPOOLING );
            //
            // WMI Trace Events
            //
            INCJOBREF(pIniJob);
            LeaveSplSem();
            LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PRINTJOB, NULL);
            EnterSplSem();
            DECJOBREF(pIniJob);



            DBGMSG(DBG_PORT, ("Port %ws: received job\n", pIniPort->pName));

            SPLASSERT(pIniJob->cRef != 0);
            DBGMSG(DBG_PORT, ("PortThread(1):cRef = %d\n", pIniJob->cRef));

            //
            // !! HACK !!
            //
            // If the datatype is 1.008 but the print proc doesn't support it,
            // then change it to 1.003 just for the print proc.
            //
            // This happens for the lexmark print processor.  They support
            // NT EMF 1.003, but not 1.008.  They just call GdiPlayEMF, so
            // they really can support 1.008 since they don't look at the
            // data.  However, since they don't advertise this, they can't
            // print.
            //
            // We work around this by switching the datatype back to 1.003.
            //
            if (!_wcsicmp(pIniJob->pDatatype, gszNT5EMF) &&
                !CheckDataTypes(pIniJob->pIniPrintProc, gszNT5EMF))
            {
                OpenData.pDatatype     = AllocSplStr(gszNT4EMF);
            }
            else
            {
                OpenData.pDatatype     = AllocSplStr(pIniJob->pDatatype);
            }

            OpenData.pDevMode      = AllocDevMode(pIniJob->pDevMode);
            OpenData.pParameters   = AllocSplStr(pIniJob->pParameters);
            OpenData.JobId         = pIniJob->JobId;
            OpenData.pDocumentName = AllocSplStr(pIniJob->pDocument);
            OpenData.pOutputFile   = AllocSplStr(pIniJob->pOutputFile);

            //
            // Check if we have RAW Printing
            //
            bRawDatatype = ValidRawDatatype(pIniJob->pDatatype);

            OpenData.pPrinterName = pszGetPrinterName(
                                        pIniJob->pIniPrinter,
                                        pIniPort->pIniSpooler != pLocalIniSpooler,
                                        NULL );

            //
            // If all of the allocations succeeded, then call into the print
            // processor, otherwise, we discard the job for now. Some of this
            // data can be NULL (pParameters, pOutputFile).
            //
            if (OpenData.pDatatype && OpenData.pPrinterName &&
                (OpenData.pDevMode      || !pIniJob->pDevMode) &&
                (OpenData.pParameters   || !pIniJob->pParameters) &&
                (OpenData.pDocumentName || !pIniJob->pDocument) &&
                (OpenData.pOutputFile   || !pIniJob->pOutputFile) ) {


                dwDevQueryPrint = pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_DEVQ;

                if ((pIniJob->Status & JOB_DIRECT) ||
                   ((pIniJob->Status & JOB_DOWNLEVEL) &&
                   ValidRawDatatype(pIniJob->pDatatype))) {

                    dwJobDirect = 1;

                }

                //
                // If we are restarting to print a document
                // clear its counters and remove the restart flag
                //
                if ( pIniJob->Status & JOB_RESTART ) {

                    InterlockedAnd((LONG*)&(pIniJob->Status), ~(JOB_RESTART | JOB_INTERRUPTED));

                    pIniJob->cbPrinted     = 0;
                    pIniJob->cPagesPrinted = 0;

                    //
                    // Only use dwReboots if not RAW.
                    //
                    if (!bRawDatatype)
                    {
                        //
                        // Solves bug 229913;
                        // Decrement number of reboots if job is restarted.
                        // ReadShadowJob checks the number of reboots and delete the job if too many
                        //
                        if( pIniJob->dwReboots ){
                            pIniJob->dwReboots--;
                        }
                    }

                }

                //
                // Job is being restarted, so clear all errors?
                //
                ClearJobError( pIniJob );
                pIniJob->dwAlert = 0;

                //
                // Only use dwReboots if not RAW.
                //
                if (!bRawDatatype)
                {
                    pIniJob->dwReboots++;
                    WriteShadowJob(pIniJob, TRUE);
                }

                LeaveSplSem();
                SplOutSem();

                if ( ( dwDevQueryPrintStatus = CallDevQueryPrint(OpenData.pPrinterName,
                                                                 OpenData.pDevMode,
                                                                 ErrorString,
                                                                 MAX_PATH,
                                                                 dwDevQueryPrint,
                                                                 dwJobDirect) ) ) {

                        PrintDocumentThruPrintProcessor( pIniPort, &OpenData );

                }

                SplOutSem();
                EnterSplSem();
            }
            else {

                DiscardJobFromPortThread(pIniJob, TRUE);
            }

            //
            // Decrement number of EMF jobs rendering and update available memory
            //
            RemoveFromJobList(pIniJob, JOB_SCHEDULE_LIST);

            SPLASSERT( pIniPort->signature == IPO_SIGNATURE );
            SPLASSERT( pIniPort->pIniJob != NULL );
            SPLASSERT( pIniJob == pIniPort->pIniJob);
            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            //
            //  Chained Jobs
            //  If we have a chain of jobs, we now need to find the next job in the chain
            //  and make sure its printed to the same port.
            //

            if (!( pIniJob->Status & ( JOB_PENDING_DELETION | JOB_RESTART )) &&
                 ( pIniJob->pCurrentIniJob != NULL )                 &&
                 ( pIniJob->pCurrentIniJob->NextJobId != 0 )) {

                // Follow the Chained Job to the Next Job
                // Look at scheduler to see where it picks up this job and assigns it back
                // to this port thread.

                pIniJob->pCurrentIniJob = FindJob( pIniJob->pIniPrinter, pIniJob->pCurrentIniJob->NextJobId, &Position );

                if ( pIniJob->pCurrentIniJob == NULL ) {

                    pIniPort->pIniJob = NULL;

                    DBGMSG( DBG_WARNING, ("PortThread didn't find NextJob\n"));

                } else {

                    SPLASSERT( pIniJob->pCurrentIniJob->signature == IJ_SIGNATURE );

                    DBGMSG( DBG_WARNING, ("PortThread completed JobId %d, NextJobId %d\n", pIniJob->JobId,
                                           pIniJob->pCurrentIniJob->JobId ));

                }

            } else {

                //
                //  Nothing More in Chain
                //

                pIniJob->pCurrentIniJob = NULL;
                pIniPort->pIniJob       = NULL;
            }

            if( !pIniJob->pCurrentIniJob ){

                //
                // Decrement the pIniSpooler job count.  We only decrement
                // at the end of a chain since we don't increment in the
                // middle of a chained job.
                //
                --pIniJob->pIniPrinter->pIniSpooler->cFullPrintingJobs;
            }

            DBGMSG(DBG_PORT, ("PortThread job has now printed - status:0x%0x\n", pIniJob->Status));

            FreeDevMode(OpenData.pDevMode);
            FreeSplStr(OpenData.pDatatype);
            FreeSplStr(OpenData.pParameters);
            FreeSplStr(OpenData.pDocumentName);
            FreeSplStr(OpenData.pOutputFile);
            FreeSplStr(OpenData.pPrinterName);

            pIniJob->Time = GetTickCount() - pIniJob->Time;

            if (!dwDevQueryPrintStatus) {

                DBGMSG(DBG_PORT, ("PortThread Job has not printed because of DevQueryPrint failed\n"));

                InterlockedOr((LONG*)&(pIniJob->Status), JOB_BLOCKED_DEVQ);
                SPLASSERT( !(pIniJob->Status & JOB_PRINTED));
                pIniJob->Time = 0;

                FreeSplStr( pIniJob->pStatus );
                pIniJob->pStatus = AllocSplStr(ErrorString);

                SetPrinterChange(pIniJob->pIniPrinter,
                                 pIniJob,
                                 NVJobStatusAndString,
                                 PRINTER_CHANGE_SET_JOB,
                                 pIniJob->pIniPrinter->pIniSpooler );

            } else if ( !( pIniJob->Status & JOB_TIMEOUT ) ) {


                //
                //  Only Log the event and send a popup if the last in the chain
                //

                if ( !(pIniJob->Status & JOB_RESTART) &&
                     pIniJob->pCurrentIniJob == NULL ) {

                    //
                    // A job can be in JOB_COMPLETE state when it was sent ot printer
                    // but the last page isn't ejected yet. A job completely sent to printer
                    // can be either in JOB_COMPLETE or JOB_PRINTED state.
                    // Monitors that doesn't support TEOJ will set the job as JOB_PRINTED
                    // right after the job was sent to printer and we don't want to set it on
                    // JOB_COMPLETE.
                    // For BIDI Monitors we'll come down here possibly before
                    // the monitor sets the job as JOB_PRINTED. We set the job as JOB_COMPLETE
                    // so that the scheduler will ignore it.
                    //
                    if (!(pIniJob->Status & (JOB_ERROR | JOB_PAPEROUT | JOB_OFFLINE)) &&
                        !(pIniJob->Status & JOB_PRINTED))
                    {
                        if (pIniJob->cPages == 0 &&
                           (pIniJob->Size == 0 || pIniJob->dwValidSize == 0) &&
                           !(pIniJob->Status & JOB_TYPE_ADDJOB))
                        {
                            //
                            // Set empty document to Printed as the monitor won't do it.
                            // Make exception for job submitted with AddJob. The monitor
                            // is still in charge for doing it.
                            //
                            InterlockedOr((LONG*)&(pIniJob->Status), JOB_PRINTED);
                        }
                        else
                        {
                            InterlockedOr((LONG*)&(pIniJob->Status), JOB_COMPLETE);
                        }
                    }


                    // For Remote NT Jobs cPagesPrinted and cTotalPagesPrinted
                    // are NOT updated since we are getting RAW data.   So we
                    // use the cPages field instead.

                    if (pIniJob->cPagesPrinted == 0) {
                        pIniJob->cPagesPrinted = pIniJob->cPages;
                        pIniJob->pIniPrinter->cTotalPagesPrinted += pIniJob->cPages;
                    }

                    INCJOBREF(pIniJob);
                    LeaveSplSem();

                    LogJobPrinted(pIniJob);

                    EnterSplSem();
                    DECJOBREF(pIniJob);
                }

            }

            SplInSem();

            DBGMSG(DBG_PORT, ("PortThread(2):cRef = %d\n", pIniJob->cRef));

            //  Hi End Print Shops like to keep around jobs after they have
            //  completed.   They do this so they can print a proof it and then
            //  print it again for the final run.   Spooling the job again may take
            //  several hours which they want to avoid.
            //  Even if KEEPPRINTEDJOBS is set they can still manually delete
            //  the job via printman.

            if (( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ) ||
                ( pIniJob->Status & JOB_TIMEOUT ) ) {

                //
                // WMI Trace Events.
                //
                // Treat a keep and restart as a delete and spool new job.
                WMI_SPOOL_DATA WmiData;
                DWORD CreateInfo;
                if (GetFileCreationInfo(pIniJob->hFileItem, &CreateInfo) != S_OK) {
                    // Assume all file created.
                    CreateInfo = FP_ALL_FILES_CREATED;
                }
                SplWmiCopyEndJobData(&WmiData, pIniJob, CreateInfo);

                InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_PENDING_DELETION);
                pIniJob->cbPrinted = 0;

                //
                // Set the job as JOB_COMPLETE if not already set as JOB_PRINTED
                // by Monitor.
                // Monitors that doesn't support TEOJ will set the job as JOB_PRINTED
                // right after the job was sent to printer and we don't want to set it on
                // JOB_COMPLETE.
                // For BIDI Monitors we'll come down here possibly before
                // the monitor sets the job as JOB_PRINTED. We set the job as JOB_COMPLETE
                // so that the scheduler will ignore it.
                //
                if (!(pIniJob->Status & JOB_PRINTED)) {
                    InterlockedOr((LONG*)&(pIniJob->Status), JOB_COMPLETE);
                }

                //
                // Only use dwReboots if not RAW.
                //
                if (!bRawDatatype)
                {
                    --pIniJob->dwReboots;
                }

                //
                // We need to update the shadow file regardless the job type.
                // There is the job status that we need to update.
                //
                INCJOBREF(pIniJob);

                //
                // WriteShadowJob leaves the CS, So make sure that the ref on the
                // pIniJob is kept high.
                //
                WriteShadowJob(pIniJob, TRUE);

                LeaveSplSem();
                //
                // WMI Trace Events.
                //
                // The job is done.  If it is restarted you get a new spool job event.
                LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_DELETEJOB,
                                 &WmiData);

                EnterSplSem();
                DECJOBREF(pIniJob);


                SPLASSERT( pIniPort->signature == IPO_SIGNATURE );
                SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

            }

            SplInSem();

            SPLASSERT( pIniJob->cRef != 0 );
            DECJOBREF(pIniJob);

            RemoveIniPortFromIniJob(pIniJob, pIniPort);

            //
            // N.B. The pIniJob may be gone at this point.
            //

        } else {

            //
            // !! VERIFY !!
            //
            SPLASSERT(pIniJob != NULL);

            if (pIniJob != NULL) {

                DBGMSG(DBG_PORT, ("Port %ws: deleting job\n", pIniPort->pName));

                // SPLASSERT( pIniJob->Time != 0 );
                pIniJob->Time = GetTickCount() - pIniJob->Time;
                //pIniJob->Status |= JOB_PRINTED;

                if ( pIniJob->hFileItem == INVALID_HANDLE_VALUE )
                {
                    CloseHandle( pIniJob->hWriteFile );
                }
                pIniJob->hWriteFile = INVALID_HANDLE_VALUE;

                DBGMSG(DBG_PORT, ("Port %ws - calling DeleteJob because PrintProcessor wasn't available\n"));
                RemoveIniPortFromIniJob(pIniJob, pIniPort);

                DeleteJob(pIniJob,BROADCAST);

                //
                // N.B. The pIniJob may be gone at this point.
                //
            }
        }

        //SetCurrentSid(NULL);
        DBGMSG(DBG_PORT,("Returning back to pickup a new job or to delete the PortThread\n"));

    }

    SetEvent( pIniPort->hPortThreadRunning );
    
    SPLASSERT( FALSE );
    return 0;
}

VOID
PrintDocumentThruPrintProcessor(
    PINIPORT pIniPort,
    PPRINTPROCESSOROPENDATA pOpenData
    )
/*++

Routine Description:

    Print the document associated with pIniPort on the print
    processor.

    Status of pIniPort->Status = PP_RUNTHREAD
                                 PP_THREADRUNNING
                                 PP_MONITOR
                                 ~PP_WAITING

    NOTE: If PrintProc->Open is called and succeeds, PrintProc->Close
          must be called to cleanup.

Arguments:

Return Value:

--*/
{
    PINIJOB pIniJob = pIniPort->pIniJob;
    WCHAR szSpecialPortorPrinterName[MAX_UNC_PRINTER_NAME + MAX_PATH + PRINTER_NAME_SUFFIX_MAX];
    BOOL bJobError = FALSE;
    NOTIFYVECTOR NotifyVector;
    LPTSTR pszModify;
    UINT cchLen;
    BOOL    bFailJob           = FALSE;
    BOOL    bRemoteGuest       = FALSE;
    BOOL    bSpecialCaseDriver = FALSE;
    DWORD   Error;
    
    //
    // Check if printing principal is remote guest. Remote guest does not have enough 
    // permissions to print EMF. The EMF playback code in GDI32 fails for certain EMF records.
    // Because of this, we create an impersonation token based on the process token.
    //
    if ((bSpecialCaseDriver = IsSpecialDriver(pIniJob->pIniDriver, pIniJob->pIniPrintProc, pIniJob->pIniPrinter->pIniSpooler)) || 
        (Error = PrincipalIsRemoteGuest(pIniJob->hToken, &bRemoteGuest)) == ERROR_SUCCESS)
    {
        if (bRemoteGuest || bSpecialCaseDriver)
        {
            Error = ImpersonateSelf(SecurityImpersonation) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            Error = SetCurrentSid(pIniJob->hToken) ? ERROR_SUCCESS : GetLastError();
        }
    }

    if (Error != ERROR_SUCCESS)
    {
        LogPrintProcError(Error, pIniJob);

        bFailJob = TRUE;

        goto Complete;
    }
    
    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor pIniPort %x pOpenData %x\n", pIniPort, pOpenData));

    COPYNV(NotifyVector, NVJobStatus);

    cchLen = lstrlen( pIniJob->pIniPrinter->pIniSpooler->pMachineName );

    //
    // Do a length check. PRINTER_NAME_SUFFIX_MAX holds the extra 4 separator
    // characters and the NULL terminator.
    // We need to be able to fit both the port name and the printer name into
    // the buffer, plus the suffix and internal characters.
    //
    if (lstrlen(pIniPort->pName) + cchLen + PRINTER_NAME_SUFFIX_MAX > COUNTOF(szSpecialPortorPrinterName) ||
        lstrlen(pIniJob->pIniPrinter->pName) + cchLen + PRINTER_NAME_SUFFIX_MAX > COUNTOF(szSpecialPortorPrinterName)) {

        //
        // We should log an event, but this is a very rare event, only
        // in the print api tests.
        //
        bFailJob = TRUE;
        goto Complete;
    }

    //
    // For clustered spoolers, make sure it is fully qualified.
    // pszModify points to the string immediately after the server
    // name that can be modified.
    //
    // Always modify the string at pszModify, but pass in
    // szSpecialPortorPrinterName.
    //
    StrNCatBuff(szSpecialPortorPrinterName, COUNTOF(szSpecialPortorPrinterName), pIniJob->pIniPrinter->pIniSpooler->pMachineName, L"\\", NULL);

    pszModify = &szSpecialPortorPrinterName[cchLen+1];

    //
    // \\Server\
    // ^---------------------- szSpecialPortorPrinterName
    //          ^------------- pszModify
    //
    // Append the rest of the string at pszModify:
    //
    // \\Server\PortName, Port
    // \\Server\PrinterName, Job 33
    //

    //
    // Now create the port name, so that we can do the
    // secret open printer. the printer name will be
    // "FILE:, Port" and this will open a PRINTER_HANDLE_PORT
    // If we fail, then if the app thread may be waiting for
    // the pIniJob->StartDocComplete to be set, which would
    // ordinarily be done in the StartDocPrinter of the port.
    // We will do this little courtesy,
    //
    StringCchPrintf(pszModify, COUNTOF(szSpecialPortorPrinterName) - (pszModify - szSpecialPortorPrinterName), L"%ws, Port", pIniPort->pName );

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Attempting PrintProcessor Open on %ws\n", szSpecialPortorPrinterName ));

    if (!(pIniPort->hProc = (HANDLE)(*pIniJob->pIniPrintProc->Open)
                                        (szSpecialPortorPrinterName, pOpenData))) {


        DBGMSG( DBG_WARNING, ("PrintDocumentThruPrintProcessor Failed Open error %d\n", GetLastError() ));

        bFailJob = TRUE;
        goto Complete;
    }

    //
    // For Jobs, turn this off even if it's not clustered.
    //
    if( !( pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER )){

        pszModify = szSpecialPortorPrinterName;

        //
        //
        // ^---------------------- szSpecialPortorPrinterName
        // ^---------------------- pszModify
        //
        // PortName, Port
        // PrinterName, Job 33
        //
    }

    EnterSplSem();

    InterlockedOr((LONG*)&(pIniJob->Status), JOB_PRINTING);
    pIniJob->Time    = GetTickCount();

    NotifyVector[JOB_NOTIFY_TYPE] |= BIT(I_JOB_PORT_NAME);

    SetPrinterChange(pIniJob->pIniPrinter,
                     pIniJob,
                     NotifyVector,
                     PRINTER_CHANGE_SET_JOB,
                     pIniJob->pIniPrinter->pIniSpooler);


    LeaveSplSem();

    //
    //  Create Special Name "PrinterName, Job xxx"
    //
    StringCchPrintf(pszModify, COUNTOF(szSpecialPortorPrinterName) - (pszModify - szSpecialPortorPrinterName), L"%ws, Job %d", pIniJob->pIniPrinter->pName, pIniJob->JobId);

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor calling Print hProc %x file %ws\n",
                         pIniPort->hProc, szSpecialPortorPrinterName ));

    if (!(*pIniJob->pIniPrintProc->Print)(pIniPort->hProc, szSpecialPortorPrinterName)) {

        Error = GetLastError();

        if (ERROR_PRINT_CANCELLED != Error)
        {
            LogPrintProcError(Error, pIniJob);
        }

        DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Print hProc %x Error %d\n", pIniPort->hProc, Error));


        EnterSplSem();

        if ( pIniJob->StartDocComplete ) {
            SetEvent( pIniJob->StartDocComplete );
        }

        bJobError = TRUE;

        LeaveSplSem();

    } else {

        DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor Print hProc %x %ws Success\n",
                pIniPort->hProc, szSpecialPortorPrinterName ));
    }

    //
    // Now close the print processor.
    //

    EnterSplSem();

    SPLASSERT( pIniPort->hProc != NULL );

    DBGMSG( DBG_TRACE, ("PrintDocumentThruPrintProcessor calling Close hProc %x\n", pIniPort->hProc ));

    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_PRINTING);

    LeaveSplSem();

    //
    // JOB_PP_CLOSE is used to prevent the print processor from recursively
    // calling back into itself. This happens for some third party print processor.
    // Race conditions don't apply for this flag since 2 threads don't access it
    // simultaneously.
    //

    if (!(pIniJob->Status & JOB_PP_CLOSE))
    {

        EnterCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);
        InterlockedOr((LONG*)&(pIniJob->Status), JOB_PP_CLOSE);

        if (!(*pIniJob->pIniPrintProc->Close)(pIniPort->hProc))
        {
            DBGMSG( DBG_WARNING, ("PrintDocumentThruPrintProcessor failed Close hProc %x Error %d\n",
                                   pIniPort->hProc, GetLastError() ));
        }

        pIniPort->hProc = NULL;
        InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_PP_CLOSE);
        LeaveCriticalSection(&pIniJob->pIniPrintProc->CriticalSection);

        //
        // WMI Trace Events
        //
        if (pIniJob->pDevMode)
        {
            WMI_SPOOL_DATA Data;
            SplWmiCopyRenderedData(&Data, pIniJob->pDevMode);
            LogWmiTraceEvent(pIniJob->JobId, EVENT_TRACE_TYPE_SPL_JOBRENDERED, &Data);
        }
    }

Complete:

    if (bFailJob || bJobError)
    {
        DiscardJobFromPortThread(pIniJob, bFailJob);
    }

    //
    // RevertToSelf and SetCurrentSid have identical behavior. If one call ImpersonateSelf
    // and the SetCurrentSid instead of RevertToSelf, that's still fine. 
    //
    if (bRemoteGuest || bSpecialCaseDriver)
    {
        RevertToSelf();
    }
    else
    {
        SetCurrentSid(NULL);
    } 

}


VOID
UpdatePortStatusForAllPrinters(
    PINIPORT        pIniPort
    )
/*++

Routine Description:
    This routine is called when an IniPorts status changed so that we go
    through each printer connected to the port and update their port status

Arguments:
    pIniPort    - Port whose status chanegd

Return Value:
    Nothing

--*/
{
    PINIPRINTER     pIniPrinter;
    PINIPORT        pIniPrinterPort;
    DWORD           dwIndex1, dwIndex2, dwPortStatus, dwSeverity;

    for ( dwIndex1 = 0 ; dwIndex1 < pIniPort->cPrinters ; ++dwIndex1 ) {

        pIniPrinter     = pIniPort->ppIniPrinter[dwIndex1];
        dwSeverity      = 0;
        dwPortStatus    = 0;

        //
        // Pick the most severe status associated with all ports
        //
        for ( dwIndex2 = 0 ; dwIndex2 < pIniPrinter->cPorts ; ++dwIndex2 ) {

            pIniPrinterPort = pIniPrinter->ppIniPorts[dwIndex2];

            if ( pIniPrinterPort->Status & PP_ERROR ) {

                dwSeverity      = PP_ERROR;
                dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                break; // no need to go thru rest of the ports for this printer
            } else if ( pIniPrinterPort->Status & PP_WARNING ) {

                if ( dwSeverity != PP_WARNING ) {

                    dwSeverity      = PP_WARNING;
                    dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                }
            } else if ( pIniPrinterPort->Status & PP_INFORMATIONAL ) {

                if ( dwSeverity == 0 ) {

                    dwSeverity      = PP_INFORMATIONAL;
                    dwPortStatus    = PortToPrinterStatus(pIniPrinterPort->PrinterStatus);
                }
            }
        }

        if ( pIniPrinter->PortStatus != dwPortStatus ) {

            pIniPrinter->PortStatus = dwPortStatus;
            SetPrinterChange(pIniPrinter,
                             NULL,
                             NVPrinterStatus,
                             PRINTER_CHANGE_SET_PRINTER,
                             pIniPrinter->pIniSpooler);
        }
    }
}


//
// Table is by port status values in winspool.h
//
DWORD PortToPrinterStatusMappings[] = {

    0,
    PRINTER_STATUS_OFFLINE,
    PRINTER_STATUS_PAPER_JAM,
    PRINTER_STATUS_PAPER_OUT,
    PRINTER_STATUS_OUTPUT_BIN_FULL,
    PRINTER_STATUS_PAPER_PROBLEM,
    PRINTER_STATUS_NO_TONER,
    PRINTER_STATUS_DOOR_OPEN,
    PRINTER_STATUS_USER_INTERVENTION,
    PRINTER_STATUS_OUT_OF_MEMORY,
    PRINTER_STATUS_TONER_LOW,
    PRINTER_STATUS_WARMING_UP,
    PRINTER_STATUS_POWER_SAVE,
};


BOOL
LocalSetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    PINIPORT        pIniPort;
    PPORT_INFO_3    pPortInfo3 = (PPORT_INFO_3) pPortInfo;
    DWORD           dwLastError = ERROR_SUCCESS;
    DWORD           dwNewStatus, dwOldStatus;
    BOOL            bJobStatusChanged = FALSE;
    WCHAR           szPort[MAX_PATH + 9];
    LPWSTR          pszComma;
    PINISPOOLER     pIniSpooler = FindSpoolerByNameIncRef( pszName, NULL );
    BOOL            SemEntered = FALSE;

    if( !pIniSpooler )
    {
        dwLastError = ERROR_INVALID_NAME;
        goto Cleanup;
    }


    if ( !MyName(pszName, pIniSpooler) ) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    //
    // The monitor needs to be able to set or clear the error for the port. The monitor
    // is loaded by the spooler. If the monitor doesn't link to winspool.drv, then the
    // call to SetPort comes directly, i.e. not via RPC. In this case we do not want
    // to check for admin privileges. We allow any user to set the port status.
    //
    if (!ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                              IsCallViaRPC() ? SERVER_ACCESS_ADMINISTER : SERVER_ACCESS_ENUMERATE,
                              NULL,
                              NULL,
                              pIniSpooler )) {

        dwLastError = GetLastError();
        goto Cleanup;
    }

    if( !pszPortName ){

        dwLastError = ERROR_UNKNOWN_PORT ;
        goto Cleanup;
    }

    //
    // Some ports will come in as "port,1234abcd" so truncate the
    // suffix.
    //
    StringCchCopy(szPort, COUNTOF(szPort), pszPortName);

    pszComma = wcschr( szPort, TEXT( ',' ));
    if( pszComma ){
        *pszComma = 0;
    }

    SemEntered = TRUE;

    EnterSplSem();
    pIniPort = FindPort(szPort, pIniSpooler);

    if ( !pIniPort ) {

        dwLastError = ERROR_UNKNOWN_PORT;
        goto Cleanup;
    }

    if ( dwLevel != 3 ) {

        dwLastError = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    if ( !pPortInfo ) {

        dwLastError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pPortInfo3->dwSeverity) {
        case    0:
            if ( pPortInfo3->dwStatus || pPortInfo3->pszStatus ) {

                dwLastError = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            dwNewStatus = 0;
            break;

        case    PORT_STATUS_TYPE_ERROR:
            dwNewStatus = PP_ERROR;
            break;

        case    PORT_STATUS_TYPE_WARNING:
            dwNewStatus = PP_WARNING;
            break;

        case    PORT_STATUS_TYPE_INFO:
            dwNewStatus = PP_INFORMATIONAL;
            break;

        default:
            dwLastError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
    }

    dwOldStatus             = pIniPort->Status;

    //
    // Clear old status
    //
    pIniPort->PrinterStatus = 0;
    pIniPort->Status       &= ~(PP_ERROR | PP_WARNING | PP_INFORMATIONAL);

    if ( pIniPort->pszStatus ) {

        //
        // If the job currently has the same status as port free it
        //
        if ( pIniPort->pIniJob              &&
             pIniPort->pIniJob->pStatus     &&
             !wcscmp(pIniPort->pIniJob->pStatus, pIniPort->pszStatus) ) {

            FreeSplStr(pIniPort->pIniJob->pStatus);
            pIniPort->pIniJob->pStatus = NULL;
            bJobStatusChanged = TRUE;
        }

        FreeSplStr(pIniPort->pszStatus);
        pIniPort->pszStatus = NULL;
    }

    //
    // If string field is used for status use it, else look at dwStatus
    //
    if ( pPortInfo3->pszStatus && *pPortInfo3->pszStatus ) {

        pIniPort->pszStatus = AllocSplStr(pPortInfo3->pszStatus);
        if ( !pIniPort->pszStatus ) {
            dwLastError = GetLastError();
            goto Cleanup;
        }

        if ( pIniPort->pIniJob && !pIniPort->pIniJob->pStatus ) {

            pIniPort->pIniJob->pStatus = AllocSplStr(pIniPort->pszStatus);
            bJobStatusChanged = TRUE;
        }

    } else {

        //
        // If we add new entries to winspool.h they should be added here too
        //
        if ( pPortInfo3->dwStatus >=
                    sizeof(PortToPrinterStatusMappings)/sizeof(PortToPrinterStatusMappings[0]) ) {

            dwLastError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        pIniPort->PrinterStatus = pPortInfo3->dwStatus;
    }

    if( bJobStatusChanged ){

        SetPrinterChange( pIniPort->pIniJob->pIniPrinter,
                          pIniPort->pIniJob,
                          NVJobStatusString,
                          PRINTER_CHANGE_SET_JOB,
                          pIniPort->pIniJob->pIniPrinter->pIniSpooler );
    }

    pIniPort->Status    |= dwNewStatus;

    UpdatePortStatusForAllPrinters(pIniPort);
    if ( (dwOldStatus & PP_ERROR)   &&
         !(dwNewStatus & PP_ERROR) ) {

        //
        // if it is a transition to an non - error state , set event to unlock LocalWritePrinter
        //
        pIniPort->ErrorTime = 0;
        if( pIniPort->hErrorEvent != NULL ){

            SetEvent(pIniPort->hErrorEvent);
        }

        CHECK_SCHEDULER();
    }

    if ( !(dwOldStatus & PP_ERROR)   &&
         !(dwNewStatus & PP_ERROR) ) {

        //
        // when non-error state persists(after two calls with an non - error state) ,
        // close the hErrorEvent handle
        //
        if( pIniPort->hErrorEvent != NULL ){

            CloseHandle(pIniPort->hErrorEvent);
            pIniPort->hErrorEvent = NULL;
        }
    }


    if ( !(dwOldStatus & PP_ERROR)   &&
          (dwNewStatus & PP_ERROR)   &&
          (pIniPort->cJobs)          &&
          (pIniSpooler->bRestartJobOnPoolEnabled) &&
          ( pPortInfo3->dwStatus ==  PORT_STATUS_OFFLINE ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_JAM ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_OUT ||
            pPortInfo3->dwStatus ==  PORT_STATUS_DOOR_OPEN ||
            pPortInfo3->dwStatus ==  PORT_STATUS_PAPER_PROBLEM ||
            pPortInfo3->dwStatus ==  PORT_STATUS_NO_TONER)) {

        //
        // If it is a transition to an error state and port has an job assigned, create event as non-signalled or Reset event it
        // LocalWritePrinter will get stuck if the port is in error state and this event is reset
        //
        if( pIniPort->ErrorTime == 0 ){

            pIniPort->ErrorTime  = GetTickCount();

            if( pIniPort->hErrorEvent == NULL ){

                pIniPort->hErrorEvent = CreateEvent(NULL,
                                                    EVENT_RESET_MANUAL,
                                                    EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                    NULL );
            }else{

                ResetEvent( pIniPort->hErrorEvent );
            }
        }

    }

    if ( (dwOldStatus & PP_ERROR)   &&
         (dwNewStatus & PP_ERROR)   &&
         (pIniPort->cJobs)          &&
         (pIniPort->hErrorEvent != NULL) ) {

        //
        // When error state persists , check the time since error occured.
        //
        if( (GetTickCount() - pIniPort->ErrorTime) > pIniSpooler->dwRestartJobOnPoolTimeout * 1000 ){

            //
            // If time out and printer is a pool ( more than one port assigned ),
            // clear job error and restart the job.
            //
            if( (pIniPort->pIniJob) &&
                (pIniPort->pIniJob->pIniPrinter) &&
                (pIniPort->pIniJob->pIniPrinter->cPorts > 1) ){

                //
                // Don't restart the job if it is already deleted or restarted.
                //
                BOOL bWasRestarted = pIniPort->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART);

                if( !bWasRestarted ){

                    ClearJobError( pIniPort->pIniJob );

                    RestartJob( pIniPort->pIniJob );
                }

                SetEvent( pIniPort->hErrorEvent );
            }



        }

    }

Cleanup:
    if(pIniSpooler)
    {
        FindSpoolerByNameDecRef( pIniSpooler );
    }

    if(SemEntered)
    {
        LeaveSplSem();
        SplOutSem();
    }

    if(dwLastError != ERROR_SUCCESS)
    {
        SetLastError(dwLastError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

VOID
SetPortErrorEvent(
    PINIPORT pIniPort
)
{
    SplInSem();
    if(pIniPort && pIniPort->hErrorEvent) {
        SetEvent(pIniPort->hErrorEvent);
    }
}


/*++

Routine Name:

    DiscardJob

Description:

    This routine discards the given job when an irrecoverable error occurs
    in the port thread.

Arguments:

    pIniJob             - The job we are wanting to discard.
    bStartDocComplete   - If TRUE, we should set the StartDocComplete event.

Returns:

    Nothing.

--*/
VOID
DiscardJobFromPortThread(
    IN      PINIJOB         pIniJob,
    IN      BOOL            bStartDocComplete
    )
{
    EnterSplSem();

    //
    // App might be waiting for the StartDoc to Complete
    //
    if (pIniJob->StartDocComplete && bStartDocComplete) {

        SetEvent(pIniJob->StartDocComplete);
    }

    //
    // If the job had an error, mark it pending deletion.  The port monitor
    // may not do this if EndDocPort was never called.
    //
    if (!(pIniJob->Status & JOB_RESTART)){

        InterlockedOr((LONG*)&(pIniJob->Status), JOB_PENDING_DELETION);

        //
        // Release any thread waiting on LocalSetPort
        //
        SetPortErrorEvent(pIniJob->pIniPort);

        //
        // Release any thread waiting on SeekPrinter
        //
        SeekPrinterSetEvent(pIniJob, NULL, TRUE);
    }

    LeaveSplSem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\openmon.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    openmon.cxx

Abstract:

    Methods to interact with the language/port monitor.
    The methods in this file are a replacement for the old OpenMonitorPort/CloseMonitorPort
    that used to close an opened handle on OpenMonitorPort while another thread was using it.

        OpenMonitorPort -  Opens a handle to the language or port monitor.
                           If the port has already an opened handle to the requested
                           monitor, then bump the handle's refcount and use it.If the 
                           port has already an opened handle to another monitor then the
                           one requested, then fail the call with ERROR_BUSY.
        CloseMonitorPort - Decrements the monitor handle's refcount and deletes the object
                           if no longer in use.                          
        GetMonitorHandle - Returns the monitor handle curently opened
                           on the port.
        GetOpenedMonitor - Returns a pointer to the INIMONITOR curently opened.
                           on the port.
        ReleaseMonitorPort - Releases the port handle so that it can be closed.
   
Author:

    Adina Trufinescu July 16th, 2002

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "monhndl.hxx"



HRESULT
InternalCloseMonitorPort(
    IN  PINIPORT    pIniPort
    );

void
AquirePortCriticalSection(
    PINIPORT pIniPort
    );

void
ReleasePortCriticalSection(
    PINIPORT pIniPort
    );

/*++

Routine Name:   

    OpenMonitorPort

Routine Description:

    Opens a handle to either the language monitor or 
    the port monitor. If a handle is already opened, then 
    use it.


Arguments:

    pIniPort        - pointer to INIPORT structure
    pIniLangMonitor - pointer to INIMONITOR structure 
                      represented the preffered language monitor.
    pszPrinterName  - string representing the printer name

Return Value:

    HANDLE

Last Error:

    Not Set.

--*/
HRESULT
OpenMonitorPort(
    PINIPORT        pIniPort,
    PINIMONITOR     pIniLangMonitor,
    LPWSTR          pszPrinterName
    )
{
    HRESULT  hRes = S_OK;

    SplInSem();

    SPLASSERT (pIniPort != NULL && pIniPort->signature == IPO_SIGNATURE);

    if(pIniPort &&
       pIniPort->signature == IPO_SIGNATURE)
    {
        //
        // If no monitor associated, do not have to open
        //
        if (!(pIniPort->Status & PP_MONITOR)) 
        {
            hRes = S_OK;
        }
        else
        {
            TMonitorHandle* pMonitorHandle  = NULL;

            //
            // If a LM is passed and it does not have an OpenPortEx can't use it
            //
            if (pIniLangMonitor && 
                !(pIniLangMonitor)->Monitor2.pfnOpenPortEx)
            {
                pIniLangMonitor = NULL;
            }

            AquirePortCriticalSection(pIniPort);
            
            //
            // If the port already has a handle opened to the wanted language monitor
            // or if we don't care about the language monitor, then just use it.
            //
            pMonitorHandle = reinterpret_cast<TMonitorHandle*>(pIniPort->hMonitorHandle);

            if (pMonitorHandle)
            {
                if (static_cast<PINIMONITOR>(*pMonitorHandle) == 
                    (pIniLangMonitor ? pIniLangMonitor : pIniPort->pIniMonitor))
                {
                    pMonitorHandle->AddRef();
                    hRes = S_OK;
                }
                else
                {
                    if (SUCCEEDED(hRes = InternalCloseMonitorPort(pIniPort)))
                    {
                        pMonitorHandle = NULL;
                    }
                }
            }

            if (SUCCEEDED(hRes) && !pMonitorHandle)
            {
                //
                // Open a monitor handle. On constructor we exit Spooler CS.
                //
                pMonitorHandle = new TMonitorHandle(pIniPort, 
                                                    pIniLangMonitor,
                                                    pszPrinterName);

                //
                // We could get an invalid handle because another thread could try open 
                // monitor and succeed.OpenPort fails when called multiple times.
                //
                if (SUCCEEDED(hRes = pMonitorHandle ? S_OK : E_OUTOFMEMORY))
                {
                    //
                    // Delete the object.
                    //
                    if (FAILED(hRes = pMonitorHandle->IsValid()))
                    {
                        delete pMonitorHandle; 
                        pMonitorHandle = NULL;
                    }

                    if (pMonitorHandle)
                    {
                        pIniPort->hMonitorHandle = reinterpret_cast<HANDLE>(pMonitorHandle); 
                        pMonitorHandle->AddRef();
                        hRes = S_OK;

                    }
                }
            }

            
            ReleasePortCriticalSection(pIniPort);
            
        }
    }
    else
    {
        hRes = E_INVALIDARG;
    }

    return hRes;
}

/*++

Routine Name:   

    InternalCloseMonitorPort     

Routine Description:

    Closes the monitor handle if the refcount reaches 0.
    It assumes the port MonitorCS is aquired.

Arguments:

    pIniPort - pointer to INIPORT structure
    
Return Value:

    HANDLE

Last Error:

    Not Set.

--*/
HRESULT
InternalCloseMonitorPort(
    IN  PINIPORT    pIniPort
    )
{   
    HRESULT         hRes           = S_OK;
    TMonitorHandle* pMonitorHandle = NULL;

    SplInSem();

    if (pIniPort->hMonitorHandle) 
    {
        pMonitorHandle = reinterpret_cast<TMonitorHandle*>(pIniPort->hMonitorHandle);

        //
        // If the handle refcount reached 0, then we close the handle. On the destructor,
        // we exit the Spooler CS.
        //
        if (pMonitorHandle->InUse() == 0)
        {
            pIniPort->hMonitorHandle = NULL;
            //
            // The destructor exits the Spooler CS.
            //
            delete pMonitorHandle;  
        }
        else
        {
            hRes = HResultFromWin32(ERROR_BUSY);
        }
    }
    else
    {
        hRes = E_INVALIDARG;
    }

    return hRes;

}   
/*++

Routine Name:   

    CloseMonitorPort     

Routine Description:

    Decrement the handle object refcount and 
    closes the monitor handle if the refcount reaches 0.

Arguments:

    pIniPort - pointer to INIPORT structure
    
Return Value:

    HANDLE

Last Error:

    Not Set.

--*/
HRESULT
CloseMonitorPort(
    IN  PINIPORT    pIniPort
    )
{   
    HRESULT hr = E_INVALIDARG;
       
    SplInSem();

    hr = (pIniPort &&
          pIniPort->signature == IPO_SIGNATURE &&
          pIniPort->hMonitorHandle) ? 
              S_OK : 
              E_INVALIDARG;

    if (SUCCEEDED(hr))
    {
        AquirePortCriticalSection(pIniPort);
        
        hr = InternalCloseMonitorPort(pIniPort);

        ReleasePortCriticalSection(pIniPort);
    }

    return hr;
}


/*++

Routine Name:   

    GetMonitorHandle     

Routine Description:

    Returns the monitor handle curently opened
    on the port.

Arguments:

    pIniPort  - pointer to INIPORT structure

Return Value:

    HANDLE

Last Error:

    Not Set.

--*/
HANDLE
GetMonitorHandle(
    IN  PINIPORT    pIniPort
    )
{
    HANDLE          hMonitor       = NULL;
    
    if (pIniPort                             && 
        pIniPort->signature == IPO_SIGNATURE &&
        pIniPort->hMonitorHandle)
    {
        TMonitorHandle* pMonitorHandle = NULL;
    
        pMonitorHandle = reinterpret_cast<TMonitorHandle*>(pIniPort->hMonitorHandle);

        hMonitor = static_cast<HANDLE>(*pMonitorHandle);
    }

    return hMonitor;
}

/*++

Routine Name:   

    GetOpenedMonitor     

Routine Description:

    Returns a pointer to the INIMONITOR curently opened.
    on the port.

Arguments:

    pIniPort  - pointer to INIPORT structure

Return Value:

    HANDLE

Last Error:

    Not Set.

--*/
PINIMONITOR
GetOpenedMonitor(
    IN  PINIPORT    pIniPort
    )
{
    PINIMONITOR pIniMonitor = NULL;

    if (pIniPort && pIniPort->hMonitorHandle)
    {
        TMonitorHandle* pMonitorHandle = NULL;

        pMonitorHandle = reinterpret_cast<TMonitorHandle*>(pIniPort->hMonitorHandle);

        pIniMonitor = static_cast<PINIMONITOR>(*pMonitorHandle);
    }

    return pIniMonitor;
}

/*++

Routine Name:   

    ReleaseMonitorPort     

Routine Description:

    This will decrement the port handle ref count. When the ref count is 0, 
    the port handle is "not in use" and another thread can close it.

Arguments:

    pIniPort  - pointer to INIPORT structure

Return Value:

    HRESULT

Last Error:

    Not Set.

--*/
HRESULT
ReleaseMonitorPort(
    PINIPORT        pIniPort
    )
{
    HRESULT hr = E_INVALIDARG;
       
    SplInSem();

    hr = (pIniPort && 
          pIniPort->signature == IPO_SIGNATURE &&              
          pIniPort->hMonitorHandle) ? 
              S_OK : 
              E_INVALIDARG;

    if (SUCCEEDED(hr))
    {
        TMonitorHandle* pMonitorHandle;

        AquirePortCriticalSection(pIniPort);

        pMonitorHandle = reinterpret_cast<TMonitorHandle*>(pIniPort->hMonitorHandle);

        if (pMonitorHandle)
        {
            pMonitorHandle->Release();
        }
        else 
        {
            hr = E_POINTER;
        }

        ReleasePortCriticalSection(pIniPort);
    }

    return hr;
}

/*++

Routine Name:   

    AquirePortCriticalSection     

Routine Description:

    This method aquires the IniPort section. Because Spooler cannot 
    open the monitor multiple times, it needs to do the open/close calls
    inside a critical section. Because the Spooler section cannot be used,
    the port was added a new CS. The method must be called inside Spooler section.
    The method aquires the port CS outside the Spooler section and then reenters.

Arguments:

    pIniPort  - pointer to INIPORT structure

Return Value:

    void

Last Error:

    Not Set.

--*/
void
AquirePortCriticalSection(
    IN PINIPORT pIniPort
    )
{
    if (pIniPort)
    {
        INCPORTREF(pIniPort);           
        INCSPOOLERREF(pIniPort->pIniSpooler);        
        INCMONITORREF(pIniPort->pIniMonitor);

        LeaveSplSem();
        SplOutSem();

        EnterCriticalSection(&pIniPort->MonitorCS);

        EnterSplSem();
        SplInSem();

        DECPORTREF(pIniPort);           
        DECSPOOLERREF(pIniPort->pIniSpooler);
        DECMONITORREF(pIniPort->pIniMonitor);
    }
}

/*++

Routine Name:   

    ReleasePortCriticalSection     

Routine Description:

    This method releases the IniPort section. 

Arguments:

    pIniPort  - pointer to INIPORT structure

Return Value:

    void

Last Error:

    Not Set.

--*/
void
ReleasePortCriticalSection(
    PINIPORT pIniPort
    )
{
    if (pIniPort)
    {
        LeaveCriticalSection(&pIniPort->MonitorCS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\precomp.h ===
/*++ BUILD Version: 0001
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  precomp.h
 *  Combined precompiled header source
 *
 *  This file is a collection of all the common .h files used by the
 *  various source files in this directory. It is precompiled by the
 *  build process to speed up the overall build time.
 *
 *  Put new .h files in here if it has to be seen by multiple source files.
 *  Keep in mind that the definitions in these .h files are potentially
 *  visible to all source files in this project.
 *
 *  History:
 *  mattfe jan 26 95
--*/

#define INC_OLE2


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>

#include <windows.h>
#include <winspool.h>
#include <splapip.h>
#include <winsplp.h>
#include <rpc.h>
#include <dsrole.h>

#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <spltypes.h>
#include <messages.h>
#include <wininet.h>

#include <tchar.h>
#include <activeds.h>
#include <winldap.h>

#include <ctype.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <change.h>

#include <memory.h>
#include <ntfytab.h>

#include <winsprlp.h>
#include <gdispool.h>

#include <setupapi.h>
#include <splsetup.h>
#include <sddl.h>

#include <dsgetdc.h>
#include <oleauto.h>
#include <accctrl.h>
#include <winsock2.h>

#define SECURITY_WIN32
#include <security.h>

#include <sfcapip.h>
#include <userenv.h>
#include <sddl.h>
#include <aclapi.h>

//
// WMI stuff
//
#include <wmidata.h>
#include <wmistr.h>
#include <evntrace.h>

#include <strsafe.h>
#include <local.h>
#include <spoolsec.h>
#include "ds.h"
#include "varconv.hxx"
#include "property.hxx"
#include "dsutil.hxx"
#include "splmrg.h"
#include "NCshared.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\portredn.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation
All rights reserved.

Module Name:

    portredn.c

Abstract:

    This module contains functions to handle port redirection.
    Earlier this was done by localmon, the code is a modified version of
    localmon code.

Author:

    Muhunthan Sivapragasam (MuhuntS) 10-Sep-1995

Revision History:

--*/

#include <precomp.h>

WCHAR   szDeviceNameHeader[]    = L"\\Device\\NamedPipe\\Spooler\\";
WCHAR   szCOM[]     = L"COM";
WCHAR   szLPT[]     = L"LPT";

//
// Definitions for MonitorThread:
//
#define TRANSMISSION_DATA_SIZE  0x400
#define NUMBER_OF_PIPE_INSTANCES 10


typedef struct _TRANSMISSION {
    HANDLE       hPipe;
    BYTE         Data[TRANSMISSION_DATA_SIZE];
    LPOVERLAPPED pOverlapped;
    HANDLE       hPrinter;
    DWORD        JobId;
    PINIPORT     pIniPort;
} TRANSMISSION, *PTRANSMISSION;

typedef struct _REDIRECT_INFO {
    PINIPORT    pIniPort;
    HANDLE      hEvent;
} REDIRECT_INFO, *PREDIRECT_INFO;


VOID
FreeRedirectInfo(
    PREDIRECT_INFO  pRedirectInfo
    )
{
    SplInSem();

    //
    // This is to handle the case when Redirection thread did not initialize
    // correctly and is terminating abnormally
    // Since CloseHandle has not been called it is ok to do this
    //
    if ( pRedirectInfo->pIniPort->hEvent == pRedirectInfo->hEvent )
        pRedirectInfo->pIniPort->hEvent = NULL;

    DECPORTREF(pRedirectInfo->pIniPort);
    CloseHandle(pRedirectInfo->hEvent);
    FreeSplMem(pRedirectInfo);
}


VOID
RemoveColon(
    LPWSTR  pName)
{
    DWORD   Length;

    Length = wcslen(pName);

    if (pName[Length-1] == L':')
        pName[Length-1] = 0;
}


VOID
RemoveDeviceName(
    PINIPORT pIniPort
    )
{
    SplInSem();

    if ( pIniPort->hEvent ) {

        //
        // Redirection thread is told to terminate here; It will close the
        // handle. If it has already terminated then this call will fail
        //
        SetEvent(pIniPort->hEvent);
        pIniPort->hEvent = NULL;
    }

}

#define MAX_ACE 6

PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID)

/*++

Routine Description:

    Creates a security descriptor giving everyone access.

Arguments:

Return Value:

    The security descriptor returned by BuildPrintObjectProtection.

--*/

{

    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];
    BYTE InheritFlags[MAX_ACE];
    DWORD AceCount;
    PSECURITY_DESCRIPTOR ServerSD = NULL;

    //
    // For Code optimization we replace 5 individaul
    // SID_IDENTIFIER_AUTHORITY with an array of
    // SID_IDENTIFIER_AUTHORITYs
    // where
    // SidAuthority[0] = UserSidAuthority
    // SidAuthority[1] = PowerSidAuthority
    // SidAuthority[2] = EveryOneSidAuthority
    // SidAuthority[3] = CreatorSidAuthority
    // SidAuthority[4] = SystemSidAuthority
    // SidAuthority[5] = AdminSidAuthority
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority[MAX_ACE] = {
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_WORLD_SID_AUTHORITY,
                                                      SECURITY_CREATOR_SID_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY
                                                     };
    //
    // For code optimization we replace 5 individual Sids with
    // an array of Sids
    // where
    // Sid[0] = UserSid
    // Sid[1] = PowerSid
    // Sid[2] = EveryOne
    // Sid[3] = CreatorSid
    // Sid[4] = SystemSid
    // Sid[5] = AdminSid
    //
    PSID Sids[MAX_ACE] = {NULL,NULL,NULL,NULL,NULL,NULL};

    ACCESS_MASK AceMask[MAX_ACE] = {
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE ,
                                     (FILE_GENERIC_READ | FILE_WRITE_DATA | FILE_ALL_ACCESS) &
                                     ~WRITE_DAC &~WRITE_OWNER & ~DELETE & ~FILE_CREATE_PIPE_INSTANCE,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_ALL_ACCESS
                                   };

    DWORD SubAuthorities[3*MAX_ACE] = {
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_USERS ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_POWER_USERS ,
                                       1 , SECURITY_WORLD_RID          , 0 ,
                                       1 , SECURITY_CREATOR_OWNER_RID  , 0 ,
                                       1 , SECURITY_LOCAL_SYSTEM_RID   , 0 ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_ADMINS
                                      };
    //
    // Name Pipe SD
    //

    for(AceCount = 0;
        ( (AceCount < MAX_ACE) &&
          AllocateAndInitializeSid(&SidAuthority[AceCount],
                                   (BYTE)SubAuthorities[AceCount*3],
                                   SubAuthorities[AceCount*3+1],
                                   SubAuthorities[AceCount*3+2],
                                   0, 0, 0, 0, 0, 0,
                                   &Sids[AceCount]));
        AceCount++)
    {
        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = Sids[AceCount];
        InheritFlags[AceCount]     = 0;
    }

    if(AceCount == MAX_ACE)
    {
        if(!BuildPrintObjectProtection(AceType,
                                      AceCount,
                                      AceSid,
                                      AceMask,
                                      InheritFlags,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ServerSD ) )
        {
            DBGMSG( DBG_WARNING,( "Couldn't buidl Named Pipe protection" ) );
        }
    }
    else
    {
        DBGMSG( DBG_WARNING,( "Couldn't Allocate and initialize SIDs" ) );
    }

    for(AceCount=0;AceCount<MAX_ACE;AceCount++)
    {
        if(Sids[AceCount])
            FreeSid( Sids[AceCount] );
    }
    return ServerSD;
}


LPWSTR
SetupDosDev(
    PINIPORT pIniPort,
    LPWSTR szPipeName,
    DWORD   cchPipeName,
    PSECURITY_ATTRIBUTES pSecurityAttributes,
    PSECURITY_ATTRIBUTES* ppSecurityAttributes
    )
{
    WCHAR                   NewNtDeviceName[MAX_PATH];
    WCHAR                   OldNtDeviceName[MAX_PATH];
    WCHAR                   DosDeviceName[MAX_PATH];
    LPWSTR                  pszNewDeviceName = NULL;
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor = NULL;
    BOOL                    bRet = FALSE;


    if (!BoolFromHResult(StringCchCopy(DosDeviceName, COUNTOF(DosDeviceName), pIniPort->pName))) {
        goto Cleanup;
    }

    RemoveColon(DosDeviceName);

    if(StrNCatBuff(NewNtDeviceName,
                   COUNTOF(NewNtDeviceName),
                   szDeviceNameHeader,
                   pIniPort->pName,
                   NULL) != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    RemoveColon(NewNtDeviceName);

    pszNewDeviceName = AllocSplStr(NewNtDeviceName);

    if ( !pszNewDeviceName ||
         !QueryDosDevice(DosDeviceName, OldNtDeviceName,
                       sizeof(OldNtDeviceName)/sizeof(OldNtDeviceName[0]))) {

        goto Cleanup;
    }

    lpSecurityDescriptor = CreateNamedPipeSecurityDescriptor();

    if (lpSecurityDescriptor) {
        pSecurityAttributes->nLength = sizeof(SECURITY_ATTRIBUTES);
        pSecurityAttributes->lpSecurityDescriptor = lpSecurityDescriptor;
        pSecurityAttributes->bInheritHandle = FALSE;
    } else {
        pSecurityAttributes = NULL;
    }

    //
    // If clause added to preclude multiple entries of the same named pipe in the device
    // name definition.
    // Ram 1\16
    //

    if (lstrcmp(NewNtDeviceName, OldNtDeviceName) != 0) {
       DefineDosDevice(DDD_RAW_TARGET_PATH, DosDeviceName, NewNtDeviceName);
    }

    if (StrNCatBuff(szPipeName,
                    cchPipeName,
                    L"\\\\.\\Pipe\\Spooler\\",
                    pIniPort->pName,
                    NULL) != ERROR_SUCCESS) {
        goto Cleanup;
    }

    RemoveColon(szPipeName);


    *ppSecurityAttributes = pSecurityAttributes;
    bRet = TRUE;

Cleanup:
    if ( !bRet ) {

        FreeSplStr(pszNewDeviceName);
        pszNewDeviceName = NULL;
    }

    return pszNewDeviceName;
}


VOID
ReadThread(
    PTRANSMISSION pTransmission)
{
    DOC_INFO_1W DocInfo;
    DWORD BytesRead;
    DWORD BytesWritten;
    BOOL bStartDocPrinterResult = FALSE;
    BOOL bReadResult;

    LPWSTR pszPrinter=NULL;

    //
    // ImpersonateNamedPipeClient requires that some data is read before
    // the impersonation is done.
    //
    bReadResult = ReadFile(pTransmission->hPipe,
                           pTransmission->Data,
                           sizeof(pTransmission->Data),
                           &BytesRead,
                           NULL);

    if (!bReadResult)
        goto Fail;

    if (!ImpersonateNamedPipeClient(pTransmission->hPipe)) {

        DBGMSG(DBG_ERROR,("ImpersonateNamedPipeClient failed %d\n",
                          GetLastError()));

        goto Fail;
    }

    SPLASSERT(pTransmission->pIniPort->cPrinters);
    pszPrinter = AllocSplStr(pTransmission->pIniPort->ppIniPrinter[0]->pName);

    if ( !pszPrinter ) {

        goto Fail;
    }


    //
    // Open the printer.
    //
    if (!OpenPrinter(pszPrinter, &pTransmission->hPrinter, NULL)) {

        DBGMSG(DBG_WARN, ("OpenPrinter(%ws) failed: Error %d\n",
                           pszPrinter,
                           GetLastError()));
        goto Fail;
    }

    memset(&DocInfo, 0, sizeof(DOC_INFO_1W));

    if (StartDocPrinter(pTransmission->hPrinter, 1, (LPBYTE)&DocInfo)) {

        DBGMSG(DBG_INFO, ("StartDocPrinter succeeded\n"));
        bStartDocPrinterResult = TRUE;

    } else {

        DBGMSG(DBG_WARN, ("StartDocPrinter failed: Error %d\n",
                           GetLastError()));

        goto Fail;
    }

    while (bReadResult && BytesRead) {

        if (!WritePrinter(pTransmission->hPrinter,
                          pTransmission->Data,
                          BytesRead,
                          &BytesWritten))
        {
            DBGMSG(DBG_WARN, ("WritePrinter failed: Error %d\n",
                               GetLastError()));

            goto Fail;
        }

        bReadResult = ReadFile(pTransmission->hPipe,
                               pTransmission->Data,
                               sizeof(pTransmission->Data),
                               &BytesRead,
                               NULL);
    }

    DBGMSG(DBG_INFO, ("bool %d  BytesRead 0x%x (Error = %d) EOT\n",
                      bReadResult,
                      BytesRead,
                      GetLastError()));


Fail:

    if (bStartDocPrinterResult) {

        if (!EndDocPrinter(pTransmission->hPrinter)) {

            DBGMSG(DBG_WARN, ("EndDocPrinter failed: Error %d\n",
                               GetLastError()));
        }
    }

    FreeSplStr(pszPrinter);
    if (pTransmission->hPrinter)
        ClosePrinter(pTransmission->hPrinter);

    if ( !SetEvent(pTransmission->pOverlapped->hEvent)) {

        DBGMSG(DBG_ERROR, ("SetEvent failed %d\n", GetLastError()));
    }

    FreeSplMem(pTransmission);
}


BOOL
ReconnectNamedPipe(
    HANDLE hPipe,
    LPOVERLAPPED pOverlapped)
{
    DWORD Error;
    BOOL bIOPending = FALSE;

    DisconnectNamedPipe(hPipe);

    if (!ConnectNamedPipe(hPipe,
                          pOverlapped)) {

        Error = GetLastError( );

        if (Error == ERROR_IO_PENDING) {

            DBGMSG(DBG_INFO, ("re-ConnectNamedPipe 0x%x IO pending\n", hPipe));
            bIOPending = TRUE;

        } else {

            DBGMSG(DBG_ERROR, ("re-ConnectNamedPipe 0x%x failed. Error %d\n",
                               hPipe,
                               Error));
        }
    } else {

        DBGMSG(DBG_INFO, ("re-ConnectNamedPipe successful 0x%x\n", hPipe));
    }
    return bIOPending;
}


BOOL
RedirectionThread(
    PREDIRECT_INFO  pRedirectInfo
    )
/*++
    Redirection thread is responsible for freeing pRedirectInfo. Since
    the ref count on port thread is incremented before this is called we
    know that the IniPort will be valid till we decrement the ref count.

    We are also passed the event we should wait to die on.
    This is pIniPort->hEvent. But redirection thread should use the local
    copy passed and not the one in pIniPort. The reason is there could be a
    lag from the time this event is set and the redirection dies. In the
    meantime a new rediction thread could be spun off and in which case the
    pIniPort->hEvent will not be for this thread

    When redirection thread is told to die:
        a. it should decrement the ref count on the pIniPort object when it is
           done with it's reference to pIniPort
        b. it should call CloseHandle on pRedirectInfo->hEvent
--*/
{
    WCHAR   szPipeName[MAX_PATH];
    HANDLE  hPipe[NUMBER_OF_PIPE_INSTANCES];
    SECURITY_ATTRIBUTES SecurityAttributes;
    PSECURITY_ATTRIBUTES pSecurityAttributes;

    //
    // One extra event for our trigger (pIniPort->hEvent)
    //
    HANDLE          ahEvent[NUMBER_OF_PIPE_INSTANCES+1];
    BOOL            abReconnect[NUMBER_OF_PIPE_INSTANCES];
    OVERLAPPED      Overlapped[NUMBER_OF_PIPE_INSTANCES];
    DWORD           WaitResult, i, j, Error, dwThreadId;
    PTRANSMISSION   pTransmission;
    HANDLE          hThread;
    BOOL            bTerminate = FALSE;
    LPWSTR          pszNewDeviceName = NULL;

    SecurityAttributes.lpSecurityDescriptor = NULL;

    //
    // Setup the redirection.
    //
    if ( !(pszNewDeviceName = SetupDosDev(pRedirectInfo->pIniPort,
                                          szPipeName,
                                          COUNTOF(szPipeName),
                                          &SecurityAttributes,
                                          &pSecurityAttributes)) ) {

        EnterSplSem();
        FreeRedirectInfo(pRedirectInfo);
        LeaveSplSem();

        return FALSE;
    }

    //
    // Initialization
    //
    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        hPipe[i] = INVALID_HANDLE_VALUE;
        Overlapped[i].hEvent = ahEvent[i] = NULL;
    }

    //
    // Put the event in the extra member of the event array.
    //
    ahEvent[NUMBER_OF_PIPE_INSTANCES] = pRedirectInfo->hEvent;

    //
    // Create several instances of a named pipe, create an event for each,
    // and connect to wait for a client:
    //
    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        abReconnect[i] = FALSE;

        hPipe[i] = CreateNamedPipe(szPipeName,
                                   PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                   PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE,
                                   PIPE_UNLIMITED_INSTANCES,
                                   4096,
                                   64*1024,   // 64k
                                   0,
                                   pSecurityAttributes);

        if ( hPipe[i] == INVALID_HANDLE_VALUE ) {

            DBGMSG(DBG_ERROR, ("CreateNamedPipe failed for %ws. Error %d\n",
                               szPipeName, GetLastError()));
            goto Cleanup;
        }

        ahEvent[i] = Overlapped[i].hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!ahEvent[i]) {

            DBGMSG(DBG_ERROR, ("CreateEvent failed. Error %d\n",
                               GetLastError()));
            goto Cleanup;
        }

        if (!ConnectNamedPipe(hPipe[i], &Overlapped[i])){

            Error = GetLastError();

            if (Error == ERROR_IO_PENDING) {

                DBGMSG(DBG_INFO, ("ConnectNamedPipe %d, IO pending\n",
                                  i));

            } else {

                DBGMSG(DBG_ERROR, ("ConnectNamedPipe failed. Error %d\n",
                                   GetLastError()));

                goto Cleanup;
            }
        }
    }

    while (TRUE) {

        DBGMSG(DBG_INFO, ("Waiting to connect...\n"));

        WaitResult = WaitForMultipleObjectsEx(NUMBER_OF_PIPE_INSTANCES + 1,
                                              ahEvent,
                                              FALSE,
                                              INFINITE,
                                              TRUE);

        DBGMSG(DBG_INFO, ("WaitForMultipleObjectsEx returned %d\n",
                          WaitResult));

        if ((WaitResult >= NUMBER_OF_PIPE_INSTANCES)
            && (WaitResult != WAIT_IO_COMPLETION)) {

            DBGMSG(DBG_INFO, ("WaitForMultipleObjects returned %d; Last error = %d\n",
                              WaitResult,
                              GetLastError( ) ) );

            //
            // We need to terminate. But wait for any read thread that is spun
            // off by this redirection thread
            //
            for ( i = 0 ; i < NUMBER_OF_PIPE_INSTANCES ; ++i )
                if ( abReconnect[i] ) {

                    bTerminate = TRUE;
                    break; // the for loop
                }

            if ( i < NUMBER_OF_PIPE_INSTANCES )
                continue; // for the while loop
            else
                goto Cleanup;
        }

        i = WaitResult;

        //
        // If disco and reconnect was pending, do it again here.
        //
        if (abReconnect[i]) {

            abReconnect[i] = FALSE;

            //
            // If redirection thread has been told to quit check for termination
            //
            if ( bTerminate ) {

                for ( j = 0 ; j < NUMBER_OF_PIPE_INSTANCES ; ++j )
                    if ( abReconnect[j] )
                        break; // the for loop

                if ( j < NUMBER_OF_PIPE_INSTANCES )
                    continue; // for while loop
                else
                    goto Cleanup;
            } else {

                ReconnectNamedPipe(hPipe[i], &Overlapped[i]);
                continue;
            }

        }

        //
        // If we have been told to terminate do not spin a read thread
        //
        if ( bTerminate )
            continue;

        //
        // Set up the transmission structure with the handles etc. needed by
        // the completion callback routine:
        //
        pTransmission = (PTRANSMISSION)AllocSplMem(sizeof(TRANSMISSION));

        if (pTransmission) {

            pTransmission->hPipe        = hPipe[i];
            pTransmission->pOverlapped  = &Overlapped[i];
            pTransmission->hPrinter     = NULL;
            pTransmission->pIniPort     = pRedirectInfo->pIniPort;
            abReconnect[i]              = TRUE;

            hThread = CreateThread(NULL,
                                   INITIAL_STACK_COMMIT,
                                   (LPTHREAD_START_ROUTINE)ReadThread,
                                   pTransmission,
                                   0,
                                   &dwThreadId);

            if (hThread) {

                CloseHandle(hThread);
            } else {

                abReconnect[i] = FALSE;
                FreeSplMem(pTransmission);
                DBGMSG(DBG_WARN, ("CreateThread failed. Error %d\n",
                                   GetLastError()));
            }

        } else {

            DBGMSG(DBG_WARN, ("Alloc failed. Error %d\n",
                               GetLastError()));
        }
    }

Cleanup:

    if ( pszNewDeviceName ) {

        WCHAR DosDeviceName[MAX_PATH];

        if (SUCCEEDED(StringCchCopy(DosDeviceName, COUNTOF(DosDeviceName), pRedirectInfo->pIniPort->pName)))
        {
            RemoveColon(DosDeviceName);

            DefineDosDevice(DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE | DDD_RAW_TARGET_PATH,
                            DosDeviceName,
                            pszNewDeviceName);
        }

        FreeSplStr(pszNewDeviceName);
    }

    EnterSplSem();
    FreeRedirectInfo(pRedirectInfo);
    LeaveSplSem();


    for (i = 0; i < NUMBER_OF_PIPE_INSTANCES; i++) {

        if ( hPipe[i] != INVALID_HANDLE_VALUE ) {

            CloseHandle(hPipe[i]);
            hPipe[i]    = INVALID_HANDLE_VALUE;
        }
        if ( ahEvent[i] ) {

            CloseHandle(ahEvent[i]);
            ahEvent[i]  = NULL;
            Overlapped[i].hEvent = NULL;
        }
    }

    if (SecurityAttributes.lpSecurityDescriptor)
        DestroyPrivateObjectSecurity(&SecurityAttributes.lpSecurityDescriptor);

    return TRUE;
}


BOOL
CreateRedirectionThread(
   PINIPORT pIniPort)
{
    HANDLE hThread;
    DWORD  dwThreadId;
    PREDIRECT_INFO  pRedirectInfo = NULL;

    SplInSem();
    SPLASSERT(pIniPort->hEvent == NULL);

    //
    // Create redirection thread only once and only for LPT and COM ports
    //
    if ( !IsPortType(pIniPort->pName, szLPT) &&
         !IsPortType(pIniPort->pName, szCOM) ) {

        return TRUE;
    }

    pIniPort->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    pRedirectInfo       = (PREDIRECT_INFO)  AllocSplMem(sizeof(REDIRECT_INFO));

    if ( !pIniPort->hEvent || !pRedirectInfo ) {

        FreeSplMem(pRedirectInfo);
        if ( pIniPort->hEvent ) {

            CloseHandle(pIniPort->hEvent);
            pIniPort->hEvent = NULL;
        }
        return FALSE;
    }

    INCPORTREF(pIniPort);
    pRedirectInfo->pIniPort = pIniPort;
    pRedirectInfo->hEvent   = pIniPort->hEvent;

    hThread = CreateThread(NULL,
                           INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE)RedirectionThread,
                           pRedirectInfo,
                           0,
                           &dwThreadId);

    if (hThread) {

        CloseHandle(hThread);

    } else {

        pIniPort->hEvent = NULL;
        FreeRedirectInfo(pRedirectInfo);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\prndata.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    mattfe Apr 5 95 - we keep the driver data key open
    and then just do the read / write operations here.

    Steve Wilson (SWilson) Jan 11 96 - Added Server handle functionality to Get & setprinterdata
                                       and pretty much changed everything in the process.

    Steve Wilson (SWilson) May 31 96 - Added SplEnumPrinterData and SplDeletePrinterData
    Steve Wilson (SWilson) Dec 96 - Added SetPrinterDataEx, GetPrinterDataEx, EnumPrinterDataEx,
                                    EnumPrinterKey, DeletePrinterDataEx, and DeleteKey

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"
#include "filepool.hxx"
#include <lmcons.h>
#include <lmwksta.h>
#include <lmerr.h>
#include <lmapibuf.h>

#define SECURITY_WIN32
#include <security.h>

#define OPEN_PORT_TIMEOUT_VALUE     3000   // 3 seconds
#define DELETE_PRINTER_DATA 0
#define SET_PRINTER_DATA    1
#define DELETE_PRINTER_KEY  2
extern DWORD   dwMajorVersion;
extern DWORD   dwMinorVersion;
extern BOOL    gbRemoteFax;

extern HANDLE    ghDsUpdateThread;
extern DWORD     gdwDsUpdateThreadId;

DWORD
SetPrinterDataPrinter(
    HANDLE  hPrinter,
    HKEY    hParentKey,
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData,
    DWORD   bSet
);

typedef enum {
    REG_PRINT,
    REG_PRINTERS,
    REG_PROVIDERS
} REG_PRINT_KEY;

DWORD
GetServerKeyHandle(
    PINISPOOLER     pIniSpooler,
    REG_PRINT_KEY   eKey,
    HKEY            *hPrintKey,
    PINISPOOLER*    ppIniSpoolerOut
);

DWORD
CloseServerKeyHandle(
    REG_PRINT_KEY   eKey,
    HKEY            hPrintKey,
    PINISPOOLER     pIniSpooler
);

DWORD
NonRegDsPresent(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegDsPresentForUser(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegGetDNSMachineName(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegWebPrintingInstalled(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
NonRegWebShareManagement(
    PINISPOOLER pIniSpooler,
    DWORD       dwType,
    LPBYTE      pData,
    DWORD       cbData
);

DWORD
PrinterNonRegGetDefaultSpoolDirectory(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
PrinterNonRegGetChangeId(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
);

DWORD
RegSetDefaultSpoolDirectory(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetPortThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetSchedulerThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNoRemoteDriver(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNetPopupToComputer(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);


DWORD
RegSetRestartJobOnPoolError(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetRestartJobOnPoolEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);


DWORD
RegSetBeepEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetEventLog(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetNetPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD
RegSetRetryPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
);

DWORD               dwDefaultServerThreadPriority       = DEFAULT_SERVER_THREAD_PRIORITY;
DWORD               dwDefaultSchedulerThreadPriority    = DEFAULT_SCHEDULER_THREAD_PRIORITY;
OSVERSIONINFO       OsVersionInfo;
OSVERSIONINFOEX     OsVersionInfoEx;

typedef struct {
    LPWSTR          pValue;
    BOOL            (*pSet) (   LPWSTR  pValueName,
                                DWORD   dwType,
                                LPBYTE  pData,
                                DWORD   cbData,
                                HKEY    *hKey,
                                PINISPOOLER pIniSpooler
                            );
    REG_PRINT_KEY   eKey;
} SERVER_DATA, *PSERVER_DATA;


typedef struct {
    LPWSTR      pValue;
    LPBYTE      pData;
    DWORD       dwType;
    DWORD       dwSize;
} NON_REGISTRY_DATA, *PNON_REGISTRY_DATA;

typedef struct {
    PWSTR   pValue;
    DWORD    (*pSet)(   PINISPOOLER pIniSpooler,
                        DWORD       dwType,
                        LPBYTE      pData,
                        DWORD       cbData
                    );
} NON_REGSET_FCN, *PNON_REGSET_FCN;

typedef struct {
    PWSTR   pValue;
    DWORD    (*pGet)(   PINISPOOLER pIniSpooler,
                        LPDWORD     pType,
                        LPBYTE      pData,
                        DWORD       nSize,
                        LPDWORD     pcbNeeded
                    );
} NON_REGISTRY_FCN, *PNON_REGISTRY_FCN;

typedef struct {
    PWSTR   pValue;
    DWORD    (*pGet)(   PSPOOL      pSpool,
                        LPDWORD     pType,
                        LPBYTE      pData,
                        DWORD       nSize,
                        LPDWORD     pcbNeeded
                    );
} PRINTER_NON_REGISTRY_FCN, *PPRINTER_NON_REGISTRY_FCN;


SERVER_DATA    gpServerRegistry[] = {{SPLREG_DEFAULT_SPOOL_DIRECTORY, RegSetDefaultSpoolDirectory, REG_PRINTERS},
                                    {SPLREG_PORT_THREAD_PRIORITY, RegSetPortThreadPriority, REG_PRINT},
                                    {SPLREG_SCHEDULER_THREAD_PRIORITY, RegSetSchedulerThreadPriority, REG_PRINT},
                                    {SPLREG_BEEP_ENABLED, RegSetBeepEnabled, REG_PRINT},
                                    {SPLREG_NET_POPUP, RegSetNetPopup, REG_PROVIDERS},
                                    {SPLREG_RETRY_POPUP, RegSetRetryPopup, REG_PROVIDERS},
                                    {SPLREG_EVENT_LOG, RegSetEventLog, REG_PROVIDERS},
                                    {SPLREG_NO_REMOTE_PRINTER_DRIVERS, RegSetNoRemoteDriver, REG_PRINT},
                                    {SPLREG_NET_POPUP_TO_COMPUTER, RegSetNetPopupToComputer, REG_PROVIDERS},
                                    {SPLREG_RESTART_JOB_ON_POOL_ERROR, RegSetRestartJobOnPoolError, REG_PROVIDERS},
                                    {SPLREG_RESTART_JOB_ON_POOL_ENABLED, RegSetRestartJobOnPoolEnabled, REG_PROVIDERS},
                                    {0,0,0}};

NON_REGSET_FCN gpNonRegSetFcn[] = { {SPLREG_WEBSHAREMGMT, NonRegWebShareManagement},
                                    {0,0}};

NON_REGISTRY_DATA gpNonRegistryData[] = {{SPLREG_PORT_THREAD_PRIORITY_DEFAULT, (LPBYTE)&dwDefaultServerThreadPriority, REG_DWORD, sizeof(DWORD)},
                                        {SPLREG_SCHEDULER_THREAD_PRIORITY_DEFAULT, (LPBYTE)&dwDefaultSchedulerThreadPriority, REG_DWORD, sizeof(DWORD)},
                                        {SPLREG_ARCHITECTURE,   (LPBYTE)&LOCAL_ENVIRONMENT, REG_SZ, 0},
                                        {SPLREG_MAJOR_VERSION,  (LPBYTE)&dwMajorVersion,    REG_DWORD,  sizeof(DWORD)},
                                        {SPLREG_MINOR_VERSION,  (LPBYTE)&dwMinorVersion,    REG_DWORD,  sizeof(DWORD)},
                                        {SPLREG_OS_VERSION,     (LPBYTE)&OsVersionInfo,     REG_BINARY, sizeof(OsVersionInfo)},
                                        {SPLREG_OS_VERSIONEX,   (LPBYTE)&OsVersionInfoEx,   REG_BINARY, sizeof(OsVersionInfoEx)},
                                        {SPLREG_REMOTE_FAX,     (LPBYTE)&gbRemoteFax,       REG_BINARY, sizeof(gbRemoteFax)},
                                        {0,0,0,0}};

NON_REGISTRY_FCN gpNonRegistryFcn[] = { {SPLREG_DS_PRESENT, NonRegDsPresent},
                                        {SPLREG_DS_PRESENT_FOR_USER, NonRegDsPresentForUser},
                                        {SPLREG_DNS_MACHINE_NAME, NonRegGetDNSMachineName},
                                        {SPLREG_W3SVCINSTALLED, NonRegWebPrintingInstalled},
                                        {0,0}};

PRINTER_NON_REGISTRY_FCN gpPrinterNonRegistryFcn[] =
{
    { SPLREG_DEFAULT_SPOOL_DIRECTORY, PrinterNonRegGetDefaultSpoolDirectory },
    { SPLREG_CHANGE_ID, PrinterNonRegGetChangeId },
    { 0, 0 }
};

extern WCHAR *szPrinterData;

BOOL
AvailableBidiPort(
    PINIPORT        pIniPort,
    PINIMONITOR     pIniLangMonitor
    )
{
    //
    // File ports and ports with no monitor are useless
    //
    if ( (pIniPort->Status & PP_FILE) || !(pIniPort->Status & PP_MONITOR) )
        return FALSE;

    //
    // If no LM then PM should support pfnGetPrinterDataFromPort
    //
    if ( !pIniLangMonitor &&
         !pIniPort->pIniMonitor->Monitor2.pfnGetPrinterDataFromPort )
        return FALSE;

    //
    // A port with no jobs or same monitor is printing then it is ok
    //
    return !pIniPort->pIniJob ||
           pIniLangMonitor == pIniPort->pIniLangMonitor;
}


DWORD
GetPrinterDataFromPort(
    PINIPRINTER     pIniPrinter,
    LPWSTR          pszValueName,
    LPBYTE          pData,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded
    )
/*++

Routine Description:
    Tries to use GetPrinterDataFromPort monitor function to satisfy a
    GetPrinterData call

Arguments:
    pIniPrinter  - Points to an INIPRINTER

Return Value:
    Win32 error code

--*/
{
    DWORD           rc = ERROR_INVALID_PARAMETER;
    DWORD           i, dwFirstPortWithNoJobs, dwFirstPortHeld;
    PINIMONITOR     pIniLangMonitor = NULL;
    PINIMONITOR     pIniMonitor = NULL;
    PINIPORT        pIniPort;
    LPTSTR          pszPrinter = NULL;
    TCHAR           szFullPrinter[ MAX_UNC_PRINTER_NAME ];


    SplInSem();

    //
    // Is the printer bidi enabled with the LM supporting
    // pfnGetPrinterDataFromPort? (Note: even PM can support this function)
    //
    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI ) {

        pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
        // SPLASSERT(pIniLangMonitor);

        if ( pIniLangMonitor &&
             !pIniLangMonitor->Monitor2.pfnGetPrinterDataFromPort )
            pIniLangMonitor = NULL;
    }

    //
    // Initialize to max
    //
    dwFirstPortWithNoJobs = dwFirstPortHeld = pIniPrinter->cPorts;

    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        //
        // Skip ports that can't be used
        //
        if ( !AvailableBidiPort(pIniPort, pIniLangMonitor) )
            continue;

        //
        // Port does not need closing?
        //
        if ( pIniLangMonitor == pIniPort->pIniLangMonitor ) {

            //
            // If no jobs also then great let's use it
            //
            if ( !pIniPort->pIniJob )
                goto PortFound;

            if ( dwFirstPortHeld == pIniPrinter->cPorts ) {

                dwFirstPortHeld = i;
            }
        } else if ( !pIniPort->pIniJob &&
                    dwFirstPortWithNoJobs == pIniPrinter->cPorts ) {

            dwFirstPortWithNoJobs = i;
        }
    }

    //
    // If all ports need closing as well as have jobs let's quit
    //
    if ( dwFirstPortWithNoJobs == pIniPrinter->cPorts &&
         dwFirstPortHeld == pIniPrinter->cPorts ) {

        return rc; //Didn't leave CS and did not unset event
    }

    //
    // We will prefer a port with no jobs (even thought it requires closing)
    //
    if ( dwFirstPortWithNoJobs < pIniPrinter->cPorts )
        pIniPort = pIniPrinter->ppIniPorts[dwFirstPortWithNoJobs];
    else
        pIniPort = pIniPrinter->ppIniPorts[dwFirstPortHeld];

PortFound:

    SPLASSERT(AvailableBidiPort(pIniPort, pIniLangMonitor));

    //
    // Port always need to be opened.
    //    
    if(pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) 
    {
        pszPrinter = szFullPrinter;

        StringCchPrintf(szFullPrinter,
                        COUNTOF(szFullPrinter),
                        L"%ws\\%ws",
                        pIniPrinter->pIniSpooler->pMachineName,
                        pIniPrinter->pName);

    } 
    else 
    {

        pszPrinter = pIniPrinter->pName;
    }

    if ((rc = StatusFromHResult(OpenMonitorPort(pIniPort,
                                                pIniLangMonitor,
                                                pszPrinter))) == ERROR_SUCCESS)
    {
        pIniMonitor = GetOpenedMonitor(pIniPort);

        if (!pIniMonitor->Monitor2.pfnGetPrinterDataFromPort)
        {
            rc = ERROR_NOT_SUPPORTED;
        }
        else
        {
            LeaveSplSem();
            SplOutSem();

            if ((*pIniMonitor->Monitor2.pfnGetPrinterDataFromPort)(GetMonitorHandle(pIniPort),
                                                                    0,
                                                                    pszValueName,
                                                                    NULL,
                                                                    0,
                                                                    (LPWSTR)pData,
                                                                    cbBuf,
                                                                    pcbNeeded)) 
            {
                rc = ERROR_SUCCESS;
            } 
            else 
            {

                //
                // If monitor fails the call but did not do a SetLastError()
                // we do not want to corrupt the registry
                //
                if ((rc = GetLastError()) == ERROR_SUCCESS) 
                {

                    ASSERT(rc != ERROR_SUCCESS);
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

            EnterSplSem();
            SplInSem();                
        }

        ReleaseMonitorPort(pIniPort);
    }
    
    return rc;
}

DWORD
SplGetPrintProcCaps(
    PSPOOL   pSpool,
    LPWSTR   pDatatype,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
/*++
Function Description: SplGetPrintProcCaps calls the GetPrintProcCaps function of the
                      Print processor that supports the given datatype.

Parameters:       pSpool    --  handle to the printer
                  pDatatype --  string containing the datatype
                  pData     --  pointer to buffer
                  nSize     --  size of the buffer
                  pcbNeeded --  pointer to the variable to store the required size of
                                buffer.

Return Value:  Error Code
--*/
{
    PINIPRINTPROC   pIniPrintProc;
    PINIPRINTER     pIniPrinter;
    DWORD           dwAttributes, dwIndex, dwReturn;

    // Find the print processor that supports this datatype
    pIniPrintProc = pSpool->pIniPrintProc ? pSpool->pIniPrintProc
                                          : pSpool->pIniPrinter->pIniPrintProc;

    pIniPrintProc = FindDatatype( pIniPrintProc, pDatatype);

    if (!pIniPrintProc)
    {
        return ERROR_INVALID_DATATYPE;
    }

    // Get the features supported by that print processor
    if (!pIniPrintProc->GetPrintProcCaps)
    {
        return ERROR_NOT_SUPPORTED;
    }
    else
    {
        pIniPrinter = pSpool->pIniPrinter;

        dwAttributes = pIniPrinter->Attributes;

        // Check for FILE: port which forces RAW spooling
        for (dwIndex = 0;
             dwIndex < pIniPrinter->cPorts;
             ++dwIndex)
        {
            if (!lstrcmpi(pIniPrinter->ppIniPorts[dwIndex]->pName,
                          L"FILE:"))
            {
                // Found a FILE: port
                dwAttributes |= PRINTER_ATTRIBUTE_RAW_ONLY;
                break;
            }
        }

        // Disable EMF simulated features for version < 3 drivers
        if (pIniPrinter->pIniDriver &&
            (pIniPrinter->pIniDriver->cVersion < 3))
        {
            dwAttributes |= PRINTER_ATTRIBUTE_RAW_ONLY;
        }

        LeaveSplSem();

        dwReturn  = (*(pIniPrintProc->GetPrintProcCaps))(pDatatype,
                                                         dwAttributes,
                                                         pData,
                                                         nSize,
                                                         pcbNeeded);

        EnterSplSem();

        return dwReturn;
    }
}

DWORD
SplGetNonRegData(
    PINISPOOLER         pIniSpooler,
    LPDWORD             pType,
    LPBYTE              pData,
    DWORD               nSize,
    LPDWORD             pcbNeeded,
    PNON_REGISTRY_DATA  pNonRegData
    )
{
    if ( pNonRegData->dwType == REG_SZ && pNonRegData->dwSize == 0 )
        *pcbNeeded = wcslen((LPWSTR) pNonRegData->pData) * sizeof(WCHAR) + sizeof(WCHAR);
    else
        *pcbNeeded = pNonRegData->dwSize;

    if ( *pcbNeeded > nSize )
        return ERROR_MORE_DATA;

    CopyMemory(pData, (LPBYTE)pNonRegData->pData, *pcbNeeded);
    *pType = pNonRegData->dwType;

    return ERROR_SUCCESS;
}


DWORD
SplGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    PSPOOL              pSpool=(PSPOOL)hPrinter;
    DWORD               rc = ERROR_INVALID_HANDLE;
    DWORD               dwResult;
    PSERVER_DATA        pRegistry;  // points to table of Print Server registry entries
    PNON_REGISTRY_DATA  pNonReg;
    PNON_REGISTRY_FCN   pNonRegFcn;
    HKEY                hPrintKey;
    PINIPRINTER         pIniPrinter;
    HKEY                hKey = NULL;
    DWORD               dwType;
    PINISPOOLER         pIniSpoolerOut;
    HANDLE              hToken = NULL;
    WCHAR               szPrintProcKey[] = L"PrintProcCaps_";
    LPWSTR              pDatatype;

    if (!ValidateSpoolHandle(pSpool, 0)) {
        return rc;
    }

    if (!pValueName || !pcbNeeded) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    if (pType)
        dwType = *pType;        // pType may be NULL

    //
    // Server Handle
    //
    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

        //
        // Check Registry Table
        //
        for (pRegistry = gpServerRegistry ; pRegistry->pValue ; ++pRegistry) {

            if (!_wcsicmp(pRegistry->pValue, pValueName)) {

                //
                // Retrieve the handle for the Get.
                if ((rc = GetServerKeyHandle(pSpool->pIniSpooler,
                                             pRegistry->eKey,
                                             &hPrintKey,
                                             &pIniSpoolerOut)) == ERROR_SUCCESS) {

                    *pcbNeeded = nSize;
                    rc = SplRegQueryValue(hPrintKey, pValueName, pType, pData, pcbNeeded, pIniSpoolerOut);

                    CloseServerKeyHandle( pRegistry->eKey,
                                          hPrintKey,
                                          pIniSpoolerOut );
                }
                break;
            }
        }

        if (!pRegistry->pValue) {   // May be a non-registry entry

            for (pNonReg = gpNonRegistryData ; pNonReg->pValue ; ++pNonReg) {
                if (!_wcsicmp(pNonReg->pValue, pValueName)) {

                    rc = SplGetNonRegData(pSpool->pIniSpooler,
                                          &dwType,
                                          pData,
                                          nSize,
                                          pcbNeeded,
                                          pNonReg);

                    if (pType)
                        *pType = dwType;

                    goto FinishNonReg;
                }
            }

            for (pNonRegFcn = gpNonRegistryFcn ; pNonRegFcn->pValue ; ++pNonRegFcn) {
                if (!_wcsicmp(pNonRegFcn->pValue, pValueName)) {

                    rc = (*pNonRegFcn->pGet)(pSpool->pIniSpooler, &dwType, pData, nSize, pcbNeeded);

                    if (pType)
                        *pType = dwType;

                    goto FinishNonReg;
                }
            }

FinishNonReg:

            if (!pNonReg->pValue && !pNonRegFcn->pValue) {
                rc = ERROR_INVALID_PARAMETER;
            }
        }
    // Printer handle
    } else {

        PPRINTER_NON_REGISTRY_FCN pPrinterNonRegFcn;

        EnterSplSem();
        pIniPrinter = pSpool->pIniPrinter;

        SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

        //
        // If the pValueName is "PrintProcCaps_[datatype]" call the print processor which
        // supports that datatype and return the options that it supports.
        //
        if (pValueName == wcsstr(pValueName, szPrintProcKey)) {

           pDatatype = (LPWSTR) (pValueName+(wcslen(szPrintProcKey)));
           if (!pDatatype) {

              LeaveSplSem();
              return ERROR_INVALID_DATATYPE;
           } else {

               rc = SplGetPrintProcCaps(pSpool,
                                        pDatatype,
                                        pData,
                                        nSize,
                                        pcbNeeded);
               LeaveSplSem();
               return rc;
           }
        }

        //
        // Check for PrinterNonReg calls.
        //
        for (pPrinterNonRegFcn = gpPrinterNonRegistryFcn ;
             pPrinterNonRegFcn->pValue ;
             ++pPrinterNonRegFcn) {

            if (!_wcsicmp(pPrinterNonRegFcn->pValue, pValueName)) {

                rc = (*pPrinterNonRegFcn->pGet)( pSpool,
                                                 &dwType,
                                                 pData,
                                                 nSize,
                                                 pcbNeeded );

                if( pType ){
                    *pType = dwType;
                }
                LeaveSplSem();
                return rc;
            }
        }

        if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
            LeaveSplSem();
            rc = ERROR_INVALID_PRINTER_STATE;

        } else {

            //
            // During upgrade do not try to talk to the port since we
            // will not be on the net
            //
            if ( dwUpgradeFlag == 0         &&
                 AccessGranted(SPOOLER_OBJECT_PRINTER,
                               PRINTER_ACCESS_ADMINISTER,
                               pSpool ) ) {

                rc = GetPrinterDataFromPort(pIniPrinter,
                                            pValueName,
                                            pData,
                                            nSize,
                                            pcbNeeded);
            }

            hToken = RevertToPrinterSelf();

            dwResult = OpenPrinterKey(pIniPrinter,
                                     KEY_READ | KEY_WRITE,
                                     &hKey,
                                     szPrinterData,
                                     FALSE);

            if (hToken && !ImpersonatePrinterClient(hToken))
            {
                dwResult = GetLastError();
            }

            if (dwResult != ERROR_SUCCESS) {
                LeaveSplSem();
                return dwResult;
            }

            if ( rc == ERROR_SUCCESS ) {

                *pType = REG_BINARY;

                (VOID)SetPrinterDataPrinter(hPrinter,
                                            NULL,
                                            hKey,
                                            pValueName,
                                            *pType,
                                            pData,
                                            *pcbNeeded,
                                            SET_PRINTER_DATA);

            } else if ( rc != ERROR_INSUFFICIENT_BUFFER ) {

                *pcbNeeded = nSize;
                rc = SplRegQueryValue( hKey,
                                       pValueName,
                                       pType,
                                       pData,
                                       pcbNeeded,
                                       pIniPrinter->pIniSpooler );
            }

            LeaveSplSem();
        }
    }


    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    SplOutSem();

    return rc;
}



DWORD
SplGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    PSPOOL              pSpool=(PSPOOL)hPrinter;
    DWORD               rc = ERROR_INVALID_HANDLE;
    PSERVER_DATA        pRegistry;  // points to table of Print Server registry entries
    PINIPRINTER         pIniPrinter;
    HKEY                hKey = NULL;
    HANDLE              hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, 0)) {
        goto Cleanup;
    }

    if (!pValueName || !pcbNeeded) {
        rc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {
        rc = SplGetPrinterData( hPrinter,
                                (LPWSTR) pValueName,
                                pType,
                                pData,
                                nSize,
                                pcbNeeded);

    } else {

        if (!pKeyName || !*pKeyName) {
            rc = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        EnterSplSem();

        pIniPrinter = pSpool->pIniPrinter;
        INCPRINTERREF(pIniPrinter);

        SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

        if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
            LeaveSplSem();
            rc = ERROR_INVALID_PRINTER_STATE;

        } else if (!_wcsicmp(pKeyName, szPrinterData)) {
            LeaveSplSem();
            rc = SplGetPrinterData( hPrinter,
                                    (LPWSTR) pValueName,
                                    pType,
                                    pData,
                                    nSize,
                                    pcbNeeded);
        } else {

            hToken = RevertToPrinterSelf();

            rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

            if (hToken && !ImpersonatePrinterClient(hToken)) {

                rc = GetLastError();
            }

            LeaveSplSem();

            if (rc == ERROR_SUCCESS) {
                *pcbNeeded = nSize;
                rc = SplRegQueryValue(hKey,
                                      pValueName,
                                      pType,
                                      pData,
                                      pcbNeeded,
                                      pIniPrinter->pIniSpooler);
            }
        }

        EnterSplSem();
        if (hKey)
            SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

        DECPRINTERREF(pIniPrinter);
        LeaveSplSem();
    }

Cleanup:

    SplOutSem();

    return rc;
}




DWORD
SplEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       rc = ERROR_INVALID_HANDLE;
    HKEY        hKey = NULL;
    PINIPRINTER pIniPrinter;
    HANDLE      hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        return rc;
    }

    if (!pValueName || !pcbValueName) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }


    EnterSplSem();
    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;

    } else {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_READ, &hKey, szPrinterData, TRUE);

        if (hToken && !ImpersonatePrinterClient(hToken))
        {
            rc = GetLastError();
        }

        LeaveSplSem();

        if (rc == ERROR_SUCCESS) {
            if (!cbValueName && !cbData) {    // Both sizes are NULL, so user wants to get buffer sizes

                rc = SplRegQueryInfoKey( hKey,
                                         NULL,
                                         NULL,
                                         NULL,
                                         pcbValueName,
                                         pcbData,
                                         NULL,
                                         NULL,
                                         pIniPrinter->pIniSpooler );

            } else {
                *pcbValueName = cbValueName/sizeof(WCHAR);
                *pcbData = cbData;
                rc = SplRegEnumValue( hKey,
                                      dwIndex,
                                      pValueName,
                                      pcbValueName,
                                      pType,
                                      pData,
                                      pcbData,
                                      pIniPrinter->pIniSpooler );

                *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);
            }
        }

        if (hKey)
        {
            SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
        }
    }

    return rc;
}


DWORD
SplEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,         // key name
    LPBYTE  pEnumValueStart,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues      // number of values returned
)
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    BOOL        bRet = FALSE;
    DWORD       rc = ERROR_SUCCESS;
    PINIPRINTER pIniPrinter;
    HKEY        hKey = NULL;
    DWORD       i;
    LPWSTR      pNextValueName, pValueName = NULL;
    LPBYTE      pData = NULL;
    PPRINTER_ENUM_VALUES pEnumValue;
    DWORD       cchValueName, cbData, cchValueNameTemp, cbDataTemp;
    DWORD       dwType, cbSourceDir=0, cbTargetDir=0;
    HANDLE      hToken = NULL;
    LPWSTR      pszSourceDir = NULL, pszTargetDir = NULL;

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        LeaveSplSem();
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName || !*pKeyName) {
        LeaveSplSem();
        return ERROR_INVALID_PARAMETER;
    }

    *pcbEnumValues = 0;
    *pnEnumValues = 0;

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;
        goto Cleanup;
    }

    //
    // open specified key
    //
    hToken = RevertToPrinterSelf();

    rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

    if (hToken && !ImpersonatePrinterClient(hToken))
    {
        rc = GetLastError();
    }

    LeaveSplSem();

    if (rc != ERROR_SUCCESS) {
        goto Cleanup;
    }

    do {
        // Get the max size
        rc = SplRegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 pnEnumValues,
                                 &cchValueName,
                                 &cbData,
                                 NULL,
                                 NULL,
                                 pIniPrinter->pIniSpooler );

        if (rc != ERROR_SUCCESS)
            goto Cleanup;

        cchValueName = (cchValueName + 1);
        cbData = (cbData + 1) & ~1;

        // Allocate temporary buffers to determine true required size
        if (!(pValueName = AllocSplMem(cchValueName * sizeof (WCHAR)))) {
            rc = GetLastError();
            goto Cleanup;
        }

        if (!(pData = AllocSplMem(cbData))) {
            rc = GetLastError();
            goto Cleanup;
        }

        // Run through Values and accumulate sizes
        for (i = 0 ; rc == ERROR_SUCCESS && i < *pnEnumValues ; ++i) {

            cchValueNameTemp = cchValueName;
            cbDataTemp = cbData;

            rc = SplRegEnumValue( hKey,
                                  i,
                                  pValueName,
                                  &cchValueNameTemp,
                                  &dwType,
                                  pData,
                                  &cbDataTemp,
                                  pIniPrinter->pIniSpooler);

            *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) +
                             (cchValueNameTemp + 1)*sizeof(WCHAR);

            *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, dwType) +
                             cbDataTemp;
        }

        //
        // If the key is a sub key of "CopyFiles" we need to generate
        // the paths for the source/target directories if the call is remote
        //
        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA)     &&
             !wcsncmp(pKeyName, L"CopyFiles\\", wcslen(L"CopyFiles\\")) ) {

            if ( !GenerateDirectoryNamesForCopyFilesKey(pSpool,
                                                        hKey,
                                                        &pszSourceDir,
                                                        &pszTargetDir,
                                                        cchValueName*sizeof (WCHAR)) ) {

                rc = GetLastError();
                goto Cleanup;

            } else {

                SPLASSERT(pszSourceDir && pszTargetDir);

                if ( pszSourceDir ) {

                    cbSourceDir = (wcslen(pszSourceDir) + 1)*sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) +
                                     sizeof(L"SourceDir") + sizeof(WCHAR);

                    *pcbEnumValues = (DWORD) AlignToRegType(*pcbEnumValues, REG_SZ) +
                                     cbSourceDir;

                    (*pnEnumValues)++;
                }
                if ( pszTargetDir ) {

                    cbTargetDir = (wcslen(pszTargetDir) + 1)*sizeof(WCHAR);

                    *pcbEnumValues = (DWORD)AlignToRegType(*pcbEnumValues, REG_SZ) +
                                     sizeof(L"TargetDir") + sizeof(WCHAR);

                    *pcbEnumValues = (DWORD)AlignToRegType(*pcbEnumValues, REG_SZ) +
                                     cbTargetDir;

                    (*pnEnumValues)++;
                }
            }
        }

        *pcbEnumValues += sizeof(PRINTER_ENUM_VALUES) * *pnEnumValues;

        if (rc == ERROR_SUCCESS) {
            if (*pcbEnumValues > cbEnumValues) {
                rc = ERROR_MORE_DATA;
                break;

            } else {

                //
                // Adjust pointers & Get data
                //
                pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValueStart;

                pNextValueName = (LPWSTR) (pEnumValueStart + *pnEnumValues*sizeof(PRINTER_ENUM_VALUES));

                pNextValueName = (LPWSTR) AlignToRegType((ULONG_PTR)pNextValueName, REG_SZ);

                for(i = 0 ; rc == ERROR_SUCCESS && i < *pnEnumValues ; ++i, ++pEnumValue) {

                    //
                    // bytes left in the allocated buffer
                    //
                    DWORD cbRemaining = (DWORD)(pEnumValueStart + cbEnumValues - (LPBYTE)pNextValueName);

                    pEnumValue->pValueName  = pNextValueName;
                    //
                    // use minimum of cbRemaining and max size
                    //
                    pEnumValue->cbValueName = (cbRemaining < cchValueName*sizeof (WCHAR)) ? cbRemaining :  cchValueName*sizeof (WCHAR);
                    pEnumValue->cbData = cbData;

                    if (i == *pnEnumValues - 2 && cbSourceDir) {

                        pEnumValue->dwType      = REG_SZ;

                        pEnumValue->cbData      = cbSourceDir;

                        pEnumValue->cbValueName = sizeof(L"SourceDir") + sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName +
                                                     pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR)pEnumValue->pData,
                                                                    pEnumValue->dwType);

                        //
                        // We have calculated the minimum buffer size necessary already.
                        //
                        StringCbCopy(pEnumValue->pValueName, pEnumValue->cbValueName, L"SourceDir");

                        StringCbCopy((LPWSTR)pEnumValue->pData, cbRemaining, pszSourceDir);

                    } else if ( i == *pnEnumValues - 1 && cbTargetDir ) {

                        pEnumValue->dwType      = REG_SZ;

                        pEnumValue->cbData      = cbTargetDir;

                        pEnumValue->cbValueName = sizeof(L"TargetDir") +
                                                  sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName +
                                                     pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR )pEnumValue->pData,
                                                                     pEnumValue->dwType);

                        StringCbCopy(pEnumValue->pValueName, pEnumValue->cbValueName, L"TargetDir");

                        StringCbCopy((LPWSTR)pEnumValue->pData, cbRemaining, pszTargetDir);

                    } else {
                        DWORD cchValueName = pEnumValue->cbValueName / sizeof (WCHAR);

                        //
                        // adjust to count of characters
                        //
                        rc = SplRegEnumValue(hKey,
                                             i,
                                             pEnumValue->pValueName,
                                             &cchValueName,
                                             &pEnumValue->dwType,
                                             pData,
                                             &pEnumValue->cbData,
                                             pIniPrinter->pIniSpooler);

                        pEnumValue->cbValueName = (cchValueName + 1)*sizeof(WCHAR);

                        pEnumValue->pData = (LPBYTE) pEnumValue->pValueName + pEnumValue->cbValueName;

                        pEnumValue->pData = (LPBYTE) AlignToRegType((ULONG_PTR)pEnumValue->pData,
                                                                     pEnumValue->dwType);

                        CopyMemory(pEnumValue->pData, pData, pEnumValue->cbData);
                    }

                    if (i + 1 < *pnEnumValues) {
                        pNextValueName = (LPWSTR) AlignToRegType((ULONG_PTR)(pEnumValue->pData +
                                                                 pEnumValue->cbData), REG_SZ);
                    }

                    if (pEnumValue->cbData == 0) {
                        pEnumValue->pData = NULL;
                    }

                }
                if (rc == ERROR_NO_MORE_ITEMS)
                    rc = ERROR_SUCCESS;
            }
        }

        FreeSplMem(pValueName);
        FreeSplMem(pData);
        pValueName = (LPWSTR) pData = NULL;

    } while(rc == ERROR_MORE_DATA);

    if ( rc == ERROR_SUCCESS )
        bRet = TRUE;

Cleanup:

    SplOutSem();

    FreeSplStr(pszTargetDir);
    FreeSplStr(pszSourceDir);

    FreeSplMem(pValueName);
    FreeSplMem(pData);

    // Close handle
    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    if ( !bRet && rc == ERROR_SUCCESS ) {

        // SPLASSERT(dwLastError == ERROR_SUCCESS); -- after ICM is fixed
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}


DWORD
SplEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // key name
    LPWSTR  pSubKey,        // address of buffer for value string
    DWORD   cbSubKey,       // size of buffer for value string
    LPDWORD pcbSubKey       // address for size of value buffer
)
{
    HKEY        hKey = NULL;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       rc = ERROR_SUCCESS;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler;
    LPWSTR      pRootKeyName;
    DWORD       cbSubKeyMax;
    DWORD       cwSubKeyMax;
    DWORD       cwSubKey, cwSubKeyTotal, cbSubKeyTotal, cwSubKeyOutput;
    DWORD       dwIndex;
    DWORD       nSubKeys;
    LPWSTR      pKeys = NULL;
    HANDLE      hToken = NULL;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {
        return ERROR_INVALID_HANDLE;
    }

    if (!pKeyName || !pcbSubKey) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterSplSem();

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter && pIniPrinter->signature == IP_SIGNATURE);

    if (pIniPrinter->Status & PRINTER_PENDING_CREATION) {
        LeaveSplSem();
        rc = ERROR_INVALID_PRINTER_STATE;
        goto Cleanup;
    }

    //
    // open specified key
    //
    hToken = RevertToPrinterSelf();

    rc = OpenPrinterKey(pIniPrinter, KEY_READ, &hKey, pKeyName, TRUE);

    if (hToken && !ImpersonatePrinterClient(hToken))
    {
        rc = GetLastError();
    }

    LeaveSplSem();

    if (rc != ERROR_SUCCESS)
        goto Cleanup;

    do {

        // Get the max size
        rc = SplRegQueryInfoKey( hKey,           // Key
                                 &nSubKeys,      // lpcSubKeys
                                 &cwSubKeyMax,   // lpcbMaxSubKeyLen
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pIniPrinter->pIniSpooler );

        if (rc != ERROR_SUCCESS)
            goto Cleanup;


        ++cwSubKeyMax;  // Add terminating NULL
        cbSubKeyMax = (cwSubKeyMax + 1)*sizeof(WCHAR);

        if (!(pKeys = AllocSplMem(cbSubKeyMax))) {
            rc = GetLastError();
            goto Cleanup;
        }

        // Enumerate keys to get exact size
        for(dwIndex = cwSubKeyTotal = 0 ; dwIndex < nSubKeys && rc == ERROR_SUCCESS ; ++dwIndex) {

            cwSubKey = cwSubKeyMax;

            rc = SplRegEnumKey( hKey,
                                dwIndex,
                                pKeys,
                                &cwSubKey,
                                NULL,
                                pIniPrinter->pIniSpooler );

            cwSubKeyTotal += cwSubKey + 1;
        }

        //
        // cwSubKeyTotal is being reset in the initialization list of the foor loop. Thus
        // its value is not accurate if we do not enter the loop at all (when nSubKeys is 0)
        //
        *pcbSubKey = nSubKeys ? cwSubKeyTotal*sizeof(WCHAR) + sizeof(WCHAR) : 2*sizeof(WCHAR);


        if (rc == ERROR_SUCCESS) {
            if(*pcbSubKey > cbSubKey) {
                rc = ERROR_MORE_DATA;
                break;

            } else {

                //
                // cwSubKeyOutput is the size of the output buffer in wchar
                //
                cwSubKeyOutput = cbSubKey/sizeof(WCHAR);

                for(dwIndex = cwSubKeyTotal = 0 ; dwIndex < nSubKeys && rc == ERROR_SUCCESS ; ++dwIndex) {

                    //
                    // Calculate the remaining output buffer size in characters.
                    // If we're out of room, exit with ERROR_MORE_DATA.
                    // This is needed since it is possible the registry has changed.
                    //
                    if (cwSubKeyOutput < cwSubKeyTotal + 1) {
                        rc = ERROR_MORE_DATA;
                        break;
                    }
                    cwSubKey = cwSubKeyOutput - cwSubKeyTotal;

                    rc = SplRegEnumKey( hKey,
                                        dwIndex,
                                        pSubKey + cwSubKeyTotal,
                                        &cwSubKey,
                                        NULL,
                                        pIniPrinter->pIniSpooler );

                    cwSubKeyTotal += cwSubKey + 1;
                }

                //
                // cwSubKeyTotal is being reset in the initialization list of the foor loop. Thus
                // its value is not accurate if we do not enter the loop at all (when nSubKeys is 0)
                // If we don't enter the for loop, then we don't need to update *pcbSubKey
                //
                if (nSubKeys && (dwIndex == nSubKeys || rc == ERROR_NO_MORE_ITEMS)) {
                    //
                    // Get the most recent data size just in case something changed
                    //
                    *pcbSubKey = cwSubKeyTotal*sizeof(WCHAR) + sizeof(WCHAR);
                    rc = ERROR_SUCCESS;
                }
            }
        }
        FreeSplMem(pKeys);
        pKeys = NULL;

    } while(rc == ERROR_MORE_DATA);

Cleanup:

    //
    // Close handles
    //
    if (hKey)
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    FreeSplMem(pKeys);

    return rc;
}


DWORD
SplDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HKEY    hKey = NULL;
    HANDLE  hToken = NULL;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE, &hKey, szPrinterData, FALSE);

        if (hToken && !ImpersonatePrinterClient(hToken))
        {
            rc = GetLastError();
        }

        if (rc == ERROR_SUCCESS) {

            rc = SetPrinterDataPrinter( hPrinter,
                                        NULL,
                                        hKey,
                                        pValueName,
                                        0, NULL, 0, DELETE_PRINTER_DATA);
        }
    }

    LeaveSplSem();

    if (hKey)
    {
        SplRegCloseKey(hKey, pSpool->pIniPrinter->pIniSpooler);
    }

    return rc;
}


DWORD
SplDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL;

    if (!pKeyName || !*pKeyName) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE, &hKey, pKeyName, TRUE);

        if (hToken && !ImpersonatePrinterClient(hToken))
        {
            rc = GetLastError();
        }

        if (rc == ERROR_SUCCESS)
            rc = SetPrinterDataPrinter(hPrinter,
                                       NULL,
                                       hKey,
                                       (LPWSTR) pValueName,
                                       0, NULL, 0, DELETE_PRINTER_DATA);
    }

    LeaveSplSem();

    if (hKey)
        SplRegCloseKey(hKey, pSpool->pIniSpooler);

    return rc;
}


DWORD
SplDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL, hPrinterKey = NULL;

    if (!pKeyName)
        return ERROR_INVALID_PARAMETER;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE | KEY_READ | DELETE, &hKey, pKeyName, TRUE);

        if (rc == ERROR_SUCCESS)
            rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_WRITE | KEY_READ | DELETE, &hPrinterKey, NULL, TRUE);

        if (hToken)
            ImpersonatePrinterClient(hToken);

        if (rc == ERROR_SUCCESS) {
            rc = SetPrinterDataPrinter(hPrinter,
                                       hPrinterKey,
                                       hKey,
                                       (LPWSTR) pKeyName,
                                       0, NULL, 0, DELETE_PRINTER_KEY);

        }
    }

    LeaveSplSem();

    if (hPrinterKey)
        SplRegCloseKey(hPrinterKey, pSpool->pIniSpooler);


    return rc;
}


DWORD
SplSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    HKEY    hKey = NULL;

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, 0)) {
        LeaveSplSem();
        return rc;
    }


    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

        if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                    SERVER_ACCESS_ADMINISTER,
                                    NULL, NULL, pSpool->pIniSpooler)) {

            rc = ERROR_ACCESS_DENIED;

        } else {

            rc = SetPrinterDataServer(pSpool->pIniSpooler, pValueName, Type, pData, cbData);
        }
    } else {

        hToken = RevertToPrinterSelf();

        rc = OpenPrinterKey(pSpool->pIniPrinter, KEY_READ | KEY_WRITE, &hKey, szPrinterData, FALSE);

        if (hToken && !ImpersonatePrinterClient(hToken))
        {
            rc = GetLastError();
        }

        if (rc == ERROR_SUCCESS) {
            rc = SetPrinterDataPrinter( hPrinter,
                                        NULL,
                                        hKey,
                                        pValueName,
                                        Type, pData, cbData, SET_PRINTER_DATA);
        }
    }

    LeaveSplSem();

    if (hKey)
    {
        SplRegCloseKey(hKey, pSpool->pIniPrinter->pIniSpooler);
    }

    return rc;
}


DWORD
SplSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;
    HKEY    hKey = NULL;
    PINISPOOLER pIniSpooler;
    LPWSTR  pPrinterKeyName;
    DWORD   DsUpdate = 0;


    if (!ValidateSpoolHandle(pSpool, 0)){
        goto Done;
    }

    if (!pValueName) {
        rc = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {
        return SplSetPrinterData(hPrinter, (LPWSTR) pValueName, Type, pData, cbData);
    }

    if (!pKeyName || !*pKeyName) {
        rc = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    if (!_wcsicmp(szPrinterData, pKeyName)) {
        return SplSetPrinterData(hPrinter, (LPWSTR) pValueName, Type, pData, cbData);
    }

    EnterSplSem();
    pIniPrinter = pSpool->pIniPrinter;
    pIniSpooler = pIniPrinter->pIniSpooler;

    DBGMSG( DBG_EXEC, ("SetPrinterDataEx: %ws %ws %ws %d cbSize=cbData\n",
                       pIniPrinter->pName,
                       pKeyName,
                       pValueName,
                       Type,
                       cbData ));

    SPLASSERT(pIniPrinter &&
              pIniPrinter->signature == IP_SIGNATURE);

    if ( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                         PRINTER_ACCESS_ADMINISTER,
                         pSpool ) ) {

        rc = ERROR_ACCESS_DENIED;
        goto DoneFromSplSem;
    }

    hToken = RevertToPrinterSelf();

    //
    // If this is a DS Key then parse out OID, if any, and write to Registry
    // Also check that data type is correct
    //
    if (!wcscmp(pKeyName, SPLDS_SPOOLER_KEY)){
        DsUpdate = DS_KEY_SPOOLER;
    } else if (!wcscmp(pKeyName, SPLDS_DRIVER_KEY)){
        DsUpdate = DS_KEY_DRIVER;
    } else if (!wcscmp(pKeyName, SPLDS_USER_KEY)){
        DsUpdate = DS_KEY_USER;
    }

    if (DsUpdate) {
        if (Type != REG_SZ && Type != REG_MULTI_SZ && Type != REG_DWORD && !(Type == REG_BINARY && cbData == 1)) {
            rc = ERROR_INVALID_PARAMETER;
            goto DoneFromSplSem;
        }
    }

    //
    // Open or Create the key
    // Create the hPrinterKey if it doesn't exist
    //
    rc = OpenPrinterKey(pIniPrinter,
                        KEY_READ | KEY_WRITE,
                        &hKey,
                        pKeyName,
                        FALSE);

    if (rc != ERROR_SUCCESS)
        goto DoneFromSplSem;


    //
    // Set the value
    //
    rc = SplRegSetValue(hKey,
                        pValueName,
                        Type,
                        pData,
                        cbData,
                        pIniPrinter->pIniSpooler );
    if (rc != ERROR_SUCCESS)
        goto DoneFromSplSem;

    //
    // Set Data succeeded. If the color profiles assocaiated with the
    // print queue were updated we send a notification. TS listens for it
    // and saves print queues settings. Updating color profiles implies
    // touching 4 regitry keys. We want to send the notify only after the
    // last key is updated.
    //
    if (!_wcsicmp(pKeyName, L"CopyFiles\\ICM") &&
        !_wcsicmp(pValueName, L"Module"))
    {
        UpdatePrinterIni(pIniPrinter, CHANGEID_ONLY);

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_PRINTER_DRIVER,
                         pSpool->pIniSpooler );
    }


    if (hToken) {
        ImpersonatePrinterClient(hToken);
        hToken = NULL;
    }

    if (ghDsUpdateThread && gdwDsUpdateThreadId == GetCurrentThreadId()) {
        // We are in the background thread
        pIniPrinter->DsKeyUpdate |= DsUpdate;
    } else {
        pIniPrinter->DsKeyUpdateForeground |= DsUpdate;
    }
    UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);

DoneFromSplSem:

    if (hToken) {
        ImpersonatePrinterClient(hToken);
    }

    LeaveSplSem();

    if ( rc == ERROR_SUCCESS    &&
         !wcsncmp(pKeyName, L"CopyFiles\\", wcslen(L"CopyFiles\\")) ) {

        (VOID)SplCopyFileEvent(pSpool,
                               (LPWSTR)pKeyName,
                               COPYFILE_EVENT_SET_PRINTER_DATAEX);
    }

Done:

    DBGMSG( DBG_EXEC, ("SetPrinterDataEx: return %d\n", rc));

    if (hKey) {
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
    }

    return rc;
}

//
// SetPrinterDataServer - also called during initialization
//
DWORD
SetPrinterDataServer(
    PINISPOOLER pIniSpooler,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    LPWSTR  pKeyName;
    DWORD    rc;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;
    PSERVER_DATA    pRegistry;  // points to table of Print Server registry entries
    PNON_REGSET_FCN pNonRegSetFcn;
    HKEY hKey;
    PINISPOOLER pIniSpoolerOut;


    //
    // Server Handle
    //
    if (!pValueName) {

        rc =  ERROR_INVALID_PARAMETER;

    } else {

        for (pRegistry = gpServerRegistry ; pRegistry->pValue ; ++pRegistry) {

            if (!_wcsicmp(pRegistry->pValue, pValueName)) {

                if ((rc = GetServerKeyHandle(pIniSpooler,
                                             pRegistry->eKey,
                                             &hKey,
                                             &pIniSpoolerOut)) == ERROR_SUCCESS) {

                    hToken = RevertToPrinterSelf();

                    if (pRegistry->pSet) {
                        rc = (*pRegistry->pSet)(pValueName, Type, pData, cbData, hKey, pIniSpoolerOut);
                    }
                    else {
                        rc = ERROR_INVALID_PARAMETER;
                    }

                    CloseServerKeyHandle( pRegistry->eKey,
                                          hKey,
                                          pIniSpoolerOut );


                    if (hToken)
                        ImpersonatePrinterClient(hToken);
                }
                break;
            }
        }

        if (!pRegistry->pValue) {

            for (pNonRegSetFcn = gpNonRegSetFcn ; pNonRegSetFcn->pValue ; ++pNonRegSetFcn) {
                if (!_wcsicmp(pNonRegSetFcn->pValue, pValueName)) {

                    rc = (*pNonRegSetFcn->pSet)(pIniSpooler, Type, pData, cbData);
                    goto FinishNonReg;
                }
            }

FinishNonReg:

            if (!pNonRegSetFcn->pValue) {
                rc = ERROR_INVALID_PARAMETER;
            }
        }
    }

    return rc;
}



DWORD
SetPrinterDataPrinter(
    HANDLE  hPrinter,
    HKEY    hParentKey,
    HKEY    hKey,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData,
    DWORD   dwSet        // SET_PRINTER_DATA, DELETE_PRINTER_DATA, or DELETE_PRINTER_KEY
)
{
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    LPWSTR  pKeyName;
    DWORD   rc = ERROR_INVALID_HANDLE;
    HANDLE  hToken = NULL;
    PINIPRINTER pIniPrinter;
    PINIJOB pIniJob;

    SplInSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )){
        goto Done;
    }

    pIniPrinter = pSpool->pIniPrinter;

    SPLASSERT(pIniPrinter &&
              pIniPrinter->signature == IP_SIGNATURE && hKey);

    if ( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                         PRINTER_ACCESS_ADMINISTER,
                         pSpool ) ) {

        rc = ERROR_ACCESS_DENIED;
        goto Done;
    }

    hToken = RevertToPrinterSelf();

    if (dwSet == SET_PRINTER_DATA) {

        rc = SplRegSetValue(hKey,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            pIniPrinter->pIniSpooler );

    } else if (dwSet == DELETE_PRINTER_DATA) {

        rc = SplRegDeleteValue(hKey, pValueName, pIniPrinter->pIniSpooler );

    } else if (dwSet == DELETE_PRINTER_KEY) {

        rc = SplDeleteThisKey(hParentKey,
                              hKey,
                              pValueName,
                              FALSE,
                              pIniPrinter->pIniSpooler);
    }


    if (hToken)
        ImpersonatePrinterClient(hToken);


    if ( rc == ERROR_SUCCESS ) {

        UpdatePrinterIni(pIniPrinter, CHANGEID_ONLY);

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_SET_PRINTER_DRIVER,
                         pSpool->pIniSpooler );
    }

    //
    // Now if there are any Jobs waiting for these changes because of
    // DevQueryPrint fix them as well
    //
    pIniJob = pIniPrinter->pIniFirstJob;
    while (pIniJob) {
        if (pIniJob->Status & JOB_BLOCKED_DEVQ) {
            InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_BLOCKED_DEVQ);
            FreeSplStr(pIniJob->pStatus);
            pIniJob->pStatus = NULL;

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler );
        }
        pIniJob = pIniJob->pIniNextJob;
    }

    CHECK_SCHEDULER();


Done:

    return rc;
}



DWORD
GetServerKeyHandle(
    PINISPOOLER     pIniSpooler,
    REG_PRINT_KEY   eKey,
    HKEY            *phKey,
    PINISPOOLER*    ppIniSpoolerOut
)
{
    DWORD    rc = ERROR_SUCCESS;
    HANDLE   hToken;
    *ppIniSpoolerOut = NULL;

    hToken = RevertToPrinterSelf();

    switch (eKey) {
        case REG_PRINT:

            *phKey = pIniSpooler->hckRoot;
            *ppIniSpoolerOut = pIniSpooler;

            break;

        case REG_PRINTERS:

            *phKey = pIniSpooler->hckPrinters;
            *ppIniSpoolerOut = pIniSpooler;

            break;

        case REG_PROVIDERS:

            rc = SplRegCreateKey( pIniSpooler->hckRoot,
                                  pIniSpooler->pszRegistryProviders,
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  phKey,
                                  NULL,
                                  pIniSpooler);

            *ppIniSpoolerOut = pIniSpooler;

            break;

        default:
            rc = ERROR_INVALID_PARAMETER;
            break;
    }

    if (hToken && !ImpersonatePrinterClient(hToken))
    {
        rc = GetLastError();

        CloseServerKeyHandle( eKey,
                              *phKey,
                              pIniSpooler );
        *phKey = NULL;
        *ppIniSpoolerOut = NULL;
    }

    return rc;
}


DWORD
CloseServerKeyHandle(
    REG_PRINT_KEY   eKey,
    HKEY            hKey,
    PINISPOOLER     pIniSpooler
)
{
    DWORD    rc = ERROR_SUCCESS;
    HANDLE   hToken = NULL;

    hToken = RevertToPrinterSelf();

    switch (eKey) {
        case REG_PRINT:
            break;

        case REG_PRINTERS:
            break;

        case REG_PROVIDERS:
            SplRegCloseKey( hKey, pIniSpooler );
            break;

        default:
            rc = ERROR_INVALID_PARAMETER;
            break;
    }

    if (hToken && !ImpersonatePrinterClient(hToken))
    {
        rc = GetLastError();
    }

    return rc;
}

DWORD
RegSetDefaultSpoolDirectory(
    LPWSTR      pValueName,
    DWORD       dwType,
    LPBYTE      pData,
    DWORD       cbData,
    HKEY        hKey,
    PINISPOOLER pIniSpooler
)
{
    DWORD               rc = ERROR_SUCCESS;
    LPWSTR              pszNewSpoolDir = NULL;
    SECURITY_ATTRIBUTES SecurityAttributes;

    if ( pIniSpooler == NULL )
    {
        //
        // This check is probably not needed.
        // Old code was checking for NULL so instead of just removing it I
        // changed it to an assert and fail gracefully w/o crash
        //
        rc = ERROR_INVALID_PARAMETER;
        SPLASSERT(pIniSpooler != NULL);
    }
    else if (!pData || wcslen((LPWSTR)pData) > MAX_PATH - 12)
    {
        rc = ERROR_INVALID_PARAMETER;
    }
    else if ( !(pszNewSpoolDir = AllocSplStr((LPWSTR) pData)) )
    {
        rc = ERROR_OUTOFMEMORY;
    }

    if ( rc == ERROR_SUCCESS )
    {
        //
        // Create the directory with the proper security, or fail trying
        //
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.lpSecurityDescriptor = CreateEverybodySecurityDescriptor();
        SecurityAttributes.bInheritHandle = FALSE;

        if ( !CreateDirectory(pszNewSpoolDir, &SecurityAttributes) )
        {
            rc = GetLastError();
            //
            // If the directory already exists it is not a failure
            //
            if ( rc == ERROR_ALREADY_EXISTS )
            {
                rc = ERROR_SUCCESS;
            }
            else if ( rc == ERROR_SUCCESS )
            {
                //
                // Don't rely on last error being set
                //
                rc = ERROR_OUTOFMEMORY;
            }
        }

        LocalFree(SecurityAttributes.lpSecurityDescriptor);
    }

    if ( rc == ERROR_SUCCESS )
    {
        EnterSplSem();
        rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);
        if ( rc == ERROR_SUCCESS ) {

            FreeSplStr(pIniSpooler->pDefaultSpoolDir);
            pIniSpooler->pDefaultSpoolDir = pszNewSpoolDir;
            pszNewSpoolDir = NULL;

            if ( pIniSpooler->hFilePool != INVALID_HANDLE_VALUE )
            {
                (VOID) ChangeFilePoolBasePath(pIniSpooler->hFilePool,
                                              pIniSpooler->pDefaultSpoolDir);
            }
        }
        LeaveSplSem();
    }

    FreeSplStr(pszNewSpoolDir);

    return rc;
}

DWORD
RegSetPortThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD))) {

        dwPortThreadPriority = *(LPDWORD)pData;
    }

    return rc;
}

DWORD
RegSetSchedulerThreadPriority(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD))) {

        dwSchedulerThreadPriority = *(LPDWORD)pData;
    }

    return rc;
}

DWORD
RegSetBeepEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwBeepEnabled = *(LPDWORD)pData;

        // Make it 1 or 0
        pIniSpooler->dwBeepEnabled = !!pIniSpooler->dwBeepEnabled;
    }

    return rc;
}

DWORD
RegSetRetryPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableRetryPopups = *(LPDWORD) pData;
        // Make it 1 or 0
        pIniSpooler->bEnableRetryPopups = !!pIniSpooler->bEnableRetryPopups;
    }

    return rc;
}

DWORD
RegSetNetPopup(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableNetPopups = *(LPDWORD) pData;

        //
        // Make it 1 or 0
        //
        pIniSpooler->bEnableNetPopups = !!pIniSpooler->bEnableNetPopups;
    }

    return rc;
}

DWORD
RegSetEventLog(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwEventLogging = *(LPDWORD) pData;
    }

    return rc;
}


DWORD
RegSetNetPopupToComputer(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bEnableNetPopupToComputer = *(LPDWORD) pData;

        // Make it 1 or 0
        pIniSpooler->bEnableNetPopupToComputer = !!pIniSpooler->bEnableNetPopupToComputer;
    }

    return rc;
}


DWORD
RegSetRestartJobOnPoolError(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->dwRestartJobOnPoolTimeout = *(LPDWORD) pData;

    }

    return rc;
}

DWORD
RegSetRestartJobOnPoolEnabled(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    BOOL    rc;

    rc = SplRegSetValue(hKey, pValueName, dwType, pData, cbData, pIniSpooler);

    if ((rc == ERROR_SUCCESS) &&
        (cbData >= sizeof(DWORD)) &&
        pIniSpooler) {

        pIniSpooler->bRestartJobOnPoolEnabled = *(LPDWORD) pData;

        // Make it 1 or 0
        pIniSpooler->bRestartJobOnPoolEnabled = !!pIniSpooler->bRestartJobOnPoolEnabled;
    }

    return rc;
}

DWORD
RegSetNoRemoteDriver(
    LPWSTR  pValueName,
    DWORD   dwType,
    LPBYTE  pData,
    DWORD   cbData,
    HKEY    hKey,
    PINISPOOLER pIniSpooler
)
{
    return  ERROR_NOT_SUPPORTED;
}

DWORD
PrinterNonRegGetDefaultSpoolDirectory(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
    )
{
    WCHAR szDefaultSpoolDirectory[MAX_PATH];
    DWORD cch;

    cch = GetPrinterDirectory( pSpool->pIniPrinter,
                               FALSE,
                               szDefaultSpoolDirectory,
                               COUNTOF(szDefaultSpoolDirectory),
                               pSpool->pIniSpooler );
    if(!cch) {

        return GetLastError();
    }

    *pcbNeeded = ( cch + 1 ) * sizeof( szDefaultSpoolDirectory[0] );
    *pType = REG_SZ;

    if( nSize < *pcbNeeded ){
        return ERROR_MORE_DATA;
    }

    StringCbCopy((LPWSTR)pData, nSize, szDefaultSpoolDirectory );

    return ERROR_SUCCESS;
}

DWORD
PrinterNonRegGetChangeId(
    PSPOOL      pSpool,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
    )
{
    LPDWORD pdwChangeID = (LPDWORD)pData;
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;

    //
    // We need a valid handle, piniPrinter
    //
    if (pSpool && pSpool->pIniPrinter)
    {
        if (pcbNeeded)
        {
            *pcbNeeded = sizeof(pSpool->pIniPrinter->cChangeID);
        }

        //
        // The type is optional.
        //
        if (pType)
        {
            *pType = REG_DWORD;
        }

        //
        // Is the provided buffer large enough.
        //
        if (nSize < sizeof(pSpool->pIniPrinter->cChangeID))
        {
            dwRetval = ERROR_MORE_DATA;
        }
        else
        {
            //
            // Is the provided buffer valid.
            //
            if (pdwChangeID)
            {
                //
                // Get the printer change id.  We really would like
                // more granularity on this.  Just knowing if something
                // changed about this printer is very general.
                //
                *pdwChangeID = pSpool->pIniPrinter->cChangeID;
                dwRetval = ERROR_SUCCESS;
            }
        }
    }

    return dwRetval;
}


DWORD
NonRegGetDNSMachineName(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    DWORD   cChars;
    if(!pIniSpooler || !pIniSpooler->pszFullMachineName) {
        return ERROR_INVALID_PARAMETER;
    }

    cChars = wcslen(pIniSpooler->pszFullMachineName);
    *pcbNeeded = ( cChars + 1 ) * sizeof( WCHAR );
    *pType = REG_SZ;

    if( nSize < *pcbNeeded ){
        return ERROR_MORE_DATA;
    }

    StringCbCopy((LPWSTR)pData, nSize, _wcslwr(pIniSpooler->pszFullMachineName));

    return ERROR_SUCCESS;
}

DWORD
NonRegDsPresent(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    HANDLE hToken = NULL;
    DWORD  rc = ERROR_SUCCESS;

    *pcbNeeded = sizeof(DWORD);
    *pType = REG_DWORD;

    if (nSize < sizeof(DWORD))
        rc = ERROR_MORE_DATA;

    if (rc == ERROR_SUCCESS)
    {

        hToken = RevertToPrinterSelf();

        *(PDWORD) pData = IsDsPresent();

        if (hToken && !ImpersonatePrinterClient(hToken))
        {
            rc = GetLastError();
        }
    }

    return rc;
}


BOOL
IsDsPresent(
)
{
    DOMAIN_CONTROLLER_INFO              *pDCI = NULL;
    BOOL                                bDsPresent;
    DWORD                               dwRet;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;


    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);

    bDsPresent = (dwRet == ERROR_SUCCESS &&
                  pDsRole->MachineRole != DsRole_RoleStandaloneServer &&
                  pDsRole->MachineRole != DsRole_RoleStandaloneWorkstation);

    if (pDsRole) {
        DsRoleFreeMemory((PVOID) pDsRole);
    }

    if (bDsPresent) {
        if (DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pDCI) == ERROR_SUCCESS)
            bDsPresent = !!(pDCI->Flags & DS_DS_FLAG);
        else
            bDsPresent = FALSE;

        if (pDCI)
            NetApiBufferFree(pDCI);
    }

    return bDsPresent;
}



DWORD
NonRegDsPresentForUser(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    WCHAR                   pUserName[MAX_PATH + 1];
    PWSTR                   pszUserName = pUserName;
    DWORD                   cchUserName = MAX_PATH + 1;
    DWORD                   dwError = ERROR_SUCCESS;
    PWSTR                   pszDomain;
    DOMAIN_CONTROLLER_INFO  *pDCI = NULL;
    WCHAR                   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    *pcbNeeded = sizeof(DWORD);
    *pType = REG_DWORD;

    if (nSize < sizeof(DWORD))
        return ERROR_MORE_DATA;


    // GetUserNameEx returns "Domain\User" in pszUserName.
    if (!GetUserNameEx(NameSamCompatible, pszUserName, &cchUserName)) {
        if (cchUserName > MAX_PATH + 1) {

            pszUserName = AllocSplMem(cchUserName);
            if (!pszUserName || !GetUserNameEx(NameSamCompatible, pszUserName, &cchUserName)) {
                dwError = GetLastError();
                goto error;
            }

        } else {
            dwError = GetLastError();
            goto error;
        }
    }

    // Chop off user name
    pszDomain = wcschr(pszUserName, L'\\');

    SPLASSERT(pszDomain);

    if (pszDomain) {  // pszDomain should never be NULL, but just in case...
        *pszDomain =  L'\0';
    } else {
        *(PDWORD) pData = 0;
        goto error;
    }

    // If domain is same a machine name, then we're logged on locally
    nSize = COUNTOF(szComputerName);
    if (GetComputerName(szComputerName, &nSize) && !wcscmp(szComputerName, pszUserName)) {
        *(PDWORD) pData = 0;
        goto error;
    }

    pszDomain = pszUserName;

    if (DsGetDcName(NULL, pszDomain, NULL, NULL, DS_DIRECTORY_SERVICE_PREFERRED, &pDCI) == ERROR_SUCCESS)
        *(PDWORD) pData = !!(pDCI->Flags & DS_DS_FLAG);

error:

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pszUserName != pUserName)
        FreeSplMem(pszUserName);

    return dwError;
}

DWORD
NonRegWebPrintingInstalled(
    PINISPOOLER pIniSpooler,
    LPDWORD     pType,
    LPBYTE      pData,
    DWORD       nSize,
    LPDWORD     pcbNeeded
)
{
    DWORD  rc = ERROR_SUCCESS;
    BOOL   bWebPrintingInstalled;

    *pcbNeeded = sizeof(DWORD);
    *pType = REG_DWORD;

    if (nSize < sizeof(DWORD))
        rc = ERROR_MORE_DATA;

    if (rc == ERROR_SUCCESS)
    {
        rc = CheckWebPrinting( &bWebPrintingInstalled);

        if (rc == ERROR_SUCCESS)
            *(PDWORD) pData = bWebPrintingInstalled;
    }

    return rc;
}


DWORD
NonRegWebShareManagement(
    PINISPOOLER pIniSpooler,
    DWORD       dwType,
    LPBYTE      pData,
    DWORD       cbData
)
{
    DWORD dwRet = ERROR_SUCCESS,
          dwWebShareOn;
    BOOL  bSharePrinters;

    //
    // Make sure the DataType & Size is correct
    //
    if ((dwType != REG_DWORD) &&
        (cbData != sizeof(DWORD)))
    {
        dwRet = ERROR_INVALID_PARAMETER;
    }

    dwWebShareOn = *((DWORD*)pData);

    bSharePrinters = (dwWebShareOn != 0);

    dwRet = WebShareManager( pIniSpooler, bSharePrinters );

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\prtproc.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    prtproc.c

Abstract:

    This module provides all the public exported APIs relating to the
    PrintProcessor based Spooler Apis for the Local Print Providor

    LocalAddPrintProcessor
    LocalEnumPrintProcessors
    LocalDeletePrintProcessor
    LocalGetPrintProcessorDirectory
    LocalEnumPrintProcessorDatatypes

    Support Functions in prtproc.c - (Warning! Do Not Add to this list!!)

    AddPrintProcessorIni
    DeletePrintProcessorIni
    CopyIniPrintProcToPrintProcInfo
    GetPrintProcessorInfoSize

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified registry functions to take pIniSpooler
    Added code to propagate print processors to the cluster disk

    Matthew A Felton ( MattFe ) 27 June 1994
    pIniSpooler

--*/
#define NOMINMAX

#include <precomp.h>
#include <offsets.h>
#include "clusspl.h"

//
// Support Function Prototypes
//
DWORD
GetPrintProcessorInfoSize(
    PINIPRINTPROC  pIniPrintProc,
    DWORD       Level,
    LPWSTR       pEnvironment
);

LPBYTE
CopyIniPrintProcToPrintProcInfo(
    LPWSTR   pEnvironment,
    PINIPRINTPROC pIniPrintProc,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    LPBYTE  pEnd
);

BOOL
AddPrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
);

BOOL
DeletePrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
);


BOOL
LocalAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplAddPrintProcessor( pName, pEnvironment, pPathName,
                                    pPrintProcessorName, pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}






BOOL
SplAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC   pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;
    DWORD   LastError=0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if(!pPrintProcessorName || wcslen( pPrintProcessorName ) >= MAX_PATH) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

   EnterSplSem();

    if ( ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                              SERVER_ACCESS_ADMINISTER,
                              NULL, NULL, pIniSpooler )) {

        if ((pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler)) &&
            (pIniEnvironment == FindEnvironment(szEnvironment, pIniSpooler))) {

            if (!FindPrintProc(pPrintProcessorName, pIniEnvironment)) {

                pIniPrintProc = LoadPrintProcessor(pIniEnvironment,
                                                   pPrintProcessorName,
                                                   pPathName,
                                                   pIniSpooler);

                if (!pIniPrintProc ||
                    !AddPrintProcessorIni(pIniPrintProc, pIniEnvironment, pIniSpooler))
                {
                    LastError = GetLastError();
                }
                else
                {
                    //
                    // For a cluster type spooler copy the print proc to the cluster disk
                    //
                    if (pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER)
                    {
                        WCHAR szDestDir[MAX_PATH]    = {0};
                        WCHAR szSourceFile[MAX_PATH] = {0};

                        if ((LastError = StrNCatBuff(szDestDir,
                                                     MAX_PATH,
                                                     pIniSpooler->pszClusResDriveLetter,
                                                     L"\\",
                                                     szClusterDriverRoot,
                                                     L"\\",
                                                     pIniEnvironment->pDirectory,
                                                     NULL)) == ERROR_SUCCESS &&
                            (LastError = StrNCatBuff(szSourceFile,
                                                     MAX_PATH,
                                                     pIniSpooler->pDir,
                                                     L"\\",
                                                     szPrintProcDir,
                                                     L"\\",
                                                     pIniEnvironment->pDirectory,
                                                     L"\\",
                                                     pPathName,
                                                     NULL)) == ERROR_SUCCESS)
                        {
                            //
                            // This function will take care to create the destination directory tree
                            //
                            LastError = CopyFileToDirectory(szSourceFile, szDestDir, NULL, NULL, NULL);

                            DBGMSG(DBG_CLUSTER, ("ClusterCopyProcessorToClusterDisks returns Win32 error %u\n", LastError));
                        }
                    }
                }

            } else
                LastError = ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED;

        } else
            LastError = ERROR_INVALID_ENVIRONMENT;

    } else
        LastError = GetLastError();

    if (!LastError)
        SetPrinterChange(NULL,
                         NULL,
                         NULL,
                         PRINTER_CHANGE_ADD_PRINT_PROCESSOR,
                         pIniSpooler);

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
LocalDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplDeletePrintProcessor( pName,
                                       pEnvironment,
                                       pPrintProcessorName,
                                       pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}





BOOL
SplDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName,
    PINISPOOLER pIniSpooler
)
{
    PINIENVIRONMENT pIniEnvironment;
    PINIPRINTPROC  pIniPrintProc;
    BOOL        Remote=FALSE;

    if (pName && *pName) {

        if (!MyName( pName, pIniSpooler )) {

            return FALSE;

        } else {

            Remote = TRUE;
        }
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

    //
    // Fail the call if we can't find a matching environment or
    // the environemnt doesn't match to the environemnt of the
    // local machine
    //
    if (!pIniEnvironment ||
        lstrcmpi(pIniEnvironment->pName, szEnvironment))
    {
        LeaveSplSem();
        SetLastError(ERROR_INVALID_ENVIRONMENT);
        return FALSE;
    }

    if (!(pIniPrintProc=(PINIPRINTPROC)FindIniKey(
                                        (PINIENTRY)pIniEnvironment->pIniPrintProc,
                                        pPrintProcessorName)))
    {
        SetLastError(ERROR_UNKNOWN_PRINTPROCESSOR);
        LeaveSplSem();
        return FALSE;
    }
    else if (pIniPrintProc->cRef)
    {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        LeaveSplSem();
        return FALSE;
    }

    RemoveFromList((PINIENTRY *)&pIniEnvironment->pIniPrintProc,
                   (PINIENTRY)pIniPrintProc);

    DeletePrintProcessorIni(pIniPrintProc, pIniEnvironment, pIniSpooler);

    if (!FreeLibrary(pIniPrintProc->hLibrary)) {
        DBGMSG(DBG_TRACE, ("DeletePrintProcessor: FreeLibrary failed\n"));
    }

    FreeSplMem(pIniPrintProc->pDatatypes);

    DeleteCriticalSection(&pIniPrintProc->CriticalSection);

    FreeSplMem(pIniPrintProc);

    SetPrinterChange(NULL,
                     NULL,
                     NULL,
                     PRINTER_CHANGE_DELETE_PRINT_PROCESSOR,
                     pIniSpooler);

   LeaveSplSem();

    return TRUE;
}

BOOL
LocalEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrintProcessors( pName,
                                      pEnvironment,
                                      Level,
                                      pPrintProcessorInfo,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC  pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;
    DWORD       cb, cbStruct;
    LPBYTE      pEnd;
    DWORD       LastError=0;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    //
    // Don't ignore the environment.  This was added in 3.1 as a hack instead
    // of fixing printman.  The problem was that from remote, different
    // environments, it would look for the wrong architecture.  Now the
    // NT 4.0 and 5.0 UI code does the right thing.
    //
    if( !pEnvironment ||
        !(pIniEnvironment = FindEnvironment( pEnvironment, pIniSpooler ))){

        LastError = ERROR_INVALID_ENVIRONMENT;
        goto Done;
    }

    switch (Level) {

    case 1:
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;
    default:

        LeaveSplSem();
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    *pcReturned=0;

    cb=0;

    pIniPrintProc=pIniEnvironment->pIniPrintProc;

    while (pIniPrintProc) {
        cb+=GetPrintProcessorInfoSize(pIniPrintProc, Level, pEnvironment);
        pIniPrintProc=pIniPrintProc->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pIniPrintProc=pIniEnvironment->pIniPrintProc;
        pEnd=pPrintProcessorInfo+cbBuf;

        while (pEnd && pIniPrintProc) {

            pEnd = CopyIniPrintProcToPrintProcInfo(pEnvironment,
                                                   pIniPrintProc,
                                                   Level,
                                                   pPrintProcessorInfo,
                                                   pEnd);
            pPrintProcessorInfo+=cbStruct;
            (*pcReturned)++;

            pIniPrintProc=pIniPrintProc->pNext;
        }

        if (!pEnd && cbBuf)
            LastError = ERROR_OUTOFMEMORY;

    } else

        LastError = ERROR_INSUFFICIENT_BUFFER;

Done:

   LeaveSplSem();
    SplOutSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
LocalGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplGetPrintProcessorDirectory( pName,
                                             pEnvironment,
                                             Level,
                                             pPrintProcessorInfo,
                                             cbBuf,
                                             pcbNeeded,
                                             pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}


BOOL
SplGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    PINISPOOLER pIniSpooler
)
{
    PINIENVIRONMENT pIniEnvironment;
    DWORD       cb;
    DWORD       dwError   = ERROR_INVALID_ENVIRONMENT;
    LPWSTR      pszString = NULL;
    BOOL        rc        = FALSE;

    if (MyName( pName, pIniSpooler) &&
        ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                             SERVER_ACCESS_ENUMERATE,
                             NULL,
                             NULL,
                             pIniSpooler))
    {
        EnterSplSem();

        pIniEnvironment = FindEnvironment(pEnvironment, pIniSpooler);

        if (pIniEnvironment)
        {
            dwError = GetProcessorDirectory(&pszString, pIniEnvironment->pDirectory, pIniSpooler);

            if (dwError == ERROR_SUCCESS)
            {
                *pcbNeeded = cb = wcslen(pszString) * sizeof(WCHAR) + sizeof(WCHAR);

                if (cbBuf >= cb)
                {
                    StringCbCopy((LPWSTR)pPrintProcessorInfo, cbBuf, pszString);

                    //
                    // Make sure the directory exists
                    //
                    CreatePrintProcDirectory(pIniEnvironment->pDirectory, pIniSpooler);

                    rc = TRUE;
                }
                else
                {
                    dwError = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }

        LeaveSplSem();
        SetLastError(dwError);
        FreeSplMem(pszString);
    }

    return rc;
}


BOOL
LocalEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PINISPOOLER pIniSpooler;
    BOOL bReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    bReturn = SplEnumPrintProcessorDatatypes( pName,
                                              pPrintProcessorName,
                                              Level,
                                              pDatatypes,
                                              cbBuf,
                                              pcbNeeded,
                                              pcReturned,
                                              pIniSpooler );

    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}



BOOL
SplEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    PINISPOOLER pIniSpooler
)
{
    PINIPRINTPROC   pIniPrintProc;
    PINIENVIRONMENT pIniEnvironment;

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ENUMERATE,
                               NULL, NULL, pIniSpooler )) {

        return FALSE;
    }

    EnterSplSem();

    pIniPrintProc = FindPrintProc(pPrintProcessorName, GetLocalArchEnv(pIniSpooler));

    LeaveSplSem();

    if (pIniPrintProc)
        return (*pIniPrintProc->EnumDatatypes)(pName, pPrintProcessorName,
                                               Level, pDatatypes, cbBuf,
                                               pcbNeeded, pcReturned);
    else {

        SetLastError(ERROR_UNKNOWN_PRINTPROCESSOR);
        return FALSE;
    }
}

DWORD
GetPrintProcessorInfoSize(
    PINIPRINTPROC  pIniPrintProc,
    DWORD       Level,
    LPWSTR       pEnvironment
)
{
    DWORD cb=0;

    switch (Level) {

    case 1:
        cb=sizeof(PRINTPROCESSOR_INFO_1) +
           wcslen(pIniPrintProc->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniPrintProcToPrintProcInfo(
    LPWSTR   pEnvironment,
    PINIPRINTPROC pIniPrintProc,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    PPRINTPROCESSOR_INFO_1 pDriver1 = (PPRINTPROCESSOR_INFO_1)pPrintProcessorInfo;
    DWORD j;
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = PrintProcessorInfo1Strings;
        break;

    default:
        return pEnd;
    }

    for (j=0; pOffsets[j] != -1; j++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(j * sizeof(LPWSTR));

    if (!pSourceStrings) {

        DBGMSG(DBG_WARNING, ("Could not allocate %d bytes for print proc source strings.\n",
                           (j * sizeof(LPWSTR))));
        return pEnd;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniPrintProc->pName;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrintProcessorInfo, pOffsets, pEnd);
        break;
    }

    FreeSplMem(SourceStrings);

    return pEnd;
}



BOOL
AddPrintProcessorIni(
    PINIPRINTPROC pIniPrintProc,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hPrintProcsKey, hPrintProcKey;
    HANDLE  hToken;
    BOOL    ReturnValue = FALSE;

    hToken = RevertToPrinterSelf();

    if (SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                        pIniSpooler->pszRegistryEnvironments,
                        0,
                        KEY_WRITE,
                        NULL,
                        &hEnvironmentsRootKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS)
    {
        if (SplRegOpenKey(hEnvironmentsRootKey,
                          pIniEnvironment->pName,
                          KEY_WRITE,
                          &hEnvironmentKey,
                          pIniSpooler) == ERROR_SUCCESS)
        {
            if (SplRegOpenKey(hEnvironmentKey,
                              szPrintProcKey,
                              KEY_WRITE,
                              &hPrintProcsKey,
                              pIniSpooler) == ERROR_SUCCESS)
            {
                if (SplRegCreateKey(hPrintProcsKey,
                                    pIniPrintProc->pName,
                                    0,
                                    KEY_WRITE,
                                    NULL,
                                    &hPrintProcKey,
                                    NULL,
                                    pIniSpooler) == ERROR_SUCCESS)
                 {

                    if (SplRegSetValue(hPrintProcKey,
                                       szDriverFile,
                                       REG_SZ,
                                       (LPBYTE)pIniPrintProc->pDLLName,
                                       (wcslen(pIniPrintProc->pDLLName) + 1)*sizeof(WCHAR),
                                       pIniSpooler) == ERROR_SUCCESS)
                    {
                        ReturnValue = TRUE;

                        DBGMSG(DBG_CLUSTER, ("AddPrintProcessorIni Success "TSTR" "TSTR"\n", pIniPrintProc->pName, pIniPrintProc->pDLLName));
                    }

                    SplRegCloseKey(hPrintProcKey, pIniSpooler);
                }

                SplRegCloseKey(hPrintProcsKey, pIniSpooler);
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient(hToken);

    return ReturnValue;
}



BOOL
DeletePrintProcessorIni(
    PINIPRINTPROC   pIniPrintProc,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
)
{
    HKEY    hEnvironmentsRootKey, hEnvironmentKey, hPrintProcsKey;
    HANDLE  hToken;

    hToken = RevertToPrinterSelf();

    if (SplRegCreateKey(pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ? pIniSpooler->hckRoot : HKEY_LOCAL_MACHINE,
                        pIniSpooler->pszRegistryEnvironments,
                        0,
                        KEY_WRITE,
                        NULL,
                        &hEnvironmentsRootKey,
                        NULL,
                        pIniSpooler) == ERROR_SUCCESS)
    {
        if (SplRegOpenKey(hEnvironmentsRootKey,
                          pIniEnvironment->pName,
                          KEY_WRITE,
                          &hEnvironmentKey,
                          pIniSpooler) == ERROR_SUCCESS)
        {
            if (SplRegOpenKey(hEnvironmentKey,
                              szPrintProcKey,
                              KEY_WRITE,
                              &hPrintProcsKey,
                              pIniSpooler) == ERROR_SUCCESS)
            {
                SplRegDeleteKey(hPrintProcsKey, pIniPrintProc->pName, pIniSpooler);

                SplRegCloseKey(hPrintProcsKey, pIniSpooler);

                DBGMSG(DBG_CLUSTER, ("DeletePrintProcessorIni Success "TSTR"\n", pIniPrintProc->pName));
            }

            SplRegCloseKey(hEnvironmentKey, pIniSpooler);
        }

        SplRegCloseKey(hEnvironmentsRootKey, pIniSpooler);
    }

    ImpersonatePrinterClient(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\printer.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    printer.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplAddPrinter
    LocalAddPrinter
    SplDeletePrinter
    SplResetPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Matthew A Felton (Mattfe) 27-June-1994
    Allow Multiple pIniSpoolers

    MattFe Jan5 Cleanup SplAddPrinter & UpdatePrinterIni
    Steve Wilson (NT) - Dec 1996 added DeleteThisKey

--*/

#include <precomp.h>

#pragma hdrstop

#include "clusspl.h"

#define     PRINTER_NO_CONTROL          0x00

extern WCHAR *szNull;

WCHAR *szKMPrintersAreBlocked   = L"KMPrintersAreBlocked";
WCHAR *szIniDevices = L"devices";
WCHAR *szIniPrinterPorts = L"PrinterPorts";
DWORD NetPrinterDecayPeriod = 1000*60*60;       // 1 hour
DWORD FirstAddNetPrinterTickCount = 0;


extern GENERIC_MAPPING GenericMapping[SPOOLER_OBJECT_COUNT];


VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode
    );

VOID
CheckAndUpdatePrinterRegAll(
    PINISPOOLER pIniSpooler,
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL   bDelete
    )
{
    //  Print Providers if they are simulating network connections
    //  will have the Win.INI setting taken care of by the router
    //  so don't do they update if they request it.

    if ( pIniSpooler->SpoolerFlags & SPL_UPDATE_WININI_DEVICES ) {

        UpdatePrinterRegAll( pszPrinterName, pszPort, bDelete );
    }
}

DWORD
ValidatePrinterAttributes(
    DWORD   SourceAttributes,
    DWORD   OriginalAttributes,
    LPWSTR  pDatatype,
    LPBOOL  pbValid,
    BOOL    bSettableOnly
    )

/*++
Function Description: Validates the printer attributes to weed out incompatible settings

Parameters: SourceAttributes    - new attributes
            OriginalAttributes  - old attributes
            pDatatype           - default datatype on the printer
            pbValid             - flag to indicate invalid combination of settings
            bSettableOnly       - flag for SplAddPrinter

Return Values: pbValid is set to TRUE if successful and new attributes are returned
               pbValid is set to FALSE otherwise and 0 is returned
--*/

{
    //
    // Let only settable attributes be set, as well as the other bits that are already set in the printer.
    //
    DWORD TargetAttributes = (SourceAttributes & PRINTER_ATTRIBUTE_SETTABLE) |
                             (OriginalAttributes & ~PRINTER_ATTRIBUTE_SETTABLE);

    if (pbValid) *pbValid = TRUE;

    //
    // If the printer is set to spool RAW only, the Default datatype should be a
    // ValidRawDatatype (RAW, RAW FF, ....)
    //
    if ((TargetAttributes & PRINTER_ATTRIBUTE_RAW_ONLY) &&
        (pDatatype != NULL) &&
        !ValidRawDatatype(pDatatype)) {

        if (pbValid) *pbValid = FALSE;
        SetLastError(ERROR_INVALID_DATATYPE);
        return 0;
    }

    // This is for use by SplAddPrinter() to let it set these attributes for a new printer if needed.
    if ( !bSettableOnly ) {

        if( SourceAttributes & PRINTER_ATTRIBUTE_LOCAL )
            TargetAttributes |= PRINTER_ATTRIBUTE_LOCAL;

        /* Don't accept PRINTER_ATTRIBUTE_NETWORK
         * unless the PRINTER_ATTRIBUTE_LOCAL bit is set also.
         * This is a special case of a local printer masquerading
         * as a network printer.
         * Otherwise PRINTER_ATTRIBUTE_NETWORK should be set only
         * by win32spl.
         */
        if( ( SourceAttributes & PRINTER_ATTRIBUTE_NETWORK )
          &&( SourceAttributes & PRINTER_ATTRIBUTE_LOCAL ) )
            TargetAttributes |= PRINTER_ATTRIBUTE_NETWORK;

        //
        // If it is a Fax Printer, set that bit.
        //
        if ( SourceAttributes & PRINTER_ATTRIBUTE_FAX )
            TargetAttributes |= PRINTER_ATTRIBUTE_FAX;
        if ( SourceAttributes & PRINTER_ATTRIBUTE_TS )
            TargetAttributes |= PRINTER_ATTRIBUTE_TS;
    }

    /* If both queued and direct, knock out direct:
     */
    if((TargetAttributes &
        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) ==
        (PRINTER_ATTRIBUTE_QUEUED | PRINTER_ATTRIBUTE_DIRECT)) {
        TargetAttributes &= ~PRINTER_ATTRIBUTE_DIRECT;
    }

    //
    // For direct printing the default data type must be RAW
    //
    if ((TargetAttributes & PRINTER_ATTRIBUTE_DIRECT) &&
        (pDatatype != NULL) &&
        !ValidRawDatatype(pDatatype)) {

        if (pbValid) *pbValid = FALSE;
        SetLastError(ERROR_INVALID_DATATYPE);
        return 0;
    }

    /* If both direct and keep-printed-jobs, knock out keep-printed-jobs
     */
    if((TargetAttributes &
        (PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS | PRINTER_ATTRIBUTE_DIRECT)) ==
        (PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS | PRINTER_ATTRIBUTE_DIRECT)) {
        TargetAttributes &= ~PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS;
    }

    return TargetAttributes;
}



BOOL
CreatePrinterEntry(
   LPPRINTER_INFO_2 pPrinter,
   PINIPRINTER      pIniPrinter,
   PBOOL            pAccessSystemSecurity
)
{
    BOOL bError = FALSE;

    if( !( pIniPrinter->pSecurityDescriptor =
           CreatePrinterSecurityDescriptor( pPrinter->pSecurityDescriptor ) )) {

        return FALSE;
    }

    *pAccessSystemSecurity = FALSE;

    pIniPrinter->signature = IP_SIGNATURE;

    pIniPrinter->pName = AllocSplStr(pPrinter->pPrinterName);

    if (!pIniPrinter->pName) {
        DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate PrinterName string\n" ));
        bError = TRUE;
    }

    if (pPrinter->pShareName) {

        pIniPrinter->pShareName = AllocSplStr(pPrinter->pShareName);
        if (!pIniPrinter->pShareName) {
            DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate ShareName string\n" ));
            bError = TRUE;


        }
    } else {

        pIniPrinter->pShareName = NULL;

    }

    if (pPrinter->pDatatype) {

        pIniPrinter->pDatatype = AllocSplStr(pPrinter->pDatatype);
        if (!pIniPrinter->pDatatype) {
            DBGMSG(DBG_WARNING, ("CreatePrinterEntry: Could not allocate Datatype string\n" ));
            bError = TRUE;
        }

    } else {

#if DBG
        //
        // Error: the datatype should never be NULL
        // point.
        //
        SplLogEvent( pIniPrinter->pIniSpooler,
                     LOG_ERROR,
                     MSG_SHARE_FAILED,
                     TRUE,
                     L"CreatePrinterEntry",
                     pIniPrinter->pName ?
                            pIniPrinter->pName :
                            L"(Nonep)",
                     pIniPrinter->pShareName ?
                            pIniPrinter->pShareName :
                            L"(Nones)",
                     L"NULL datatype",
                     NULL );
#endif

        pIniPrinter->pDatatype = NULL;
    }


    //
    // If we have failed somewhere, clean up and exit.
    //
    if (bError) {
        FreeSplStr(pIniPrinter->pName);
        FreeSplStr(pIniPrinter->pShareName);
        FreeSplStr(pIniPrinter->pDatatype);
        return FALSE;
    }

    pIniPrinter->Priority = pPrinter->Priority ? pPrinter->Priority
                                               : DEF_PRIORITY;

    pIniPrinter->Attributes = ValidatePrinterAttributes(pPrinter->Attributes,
                                                        pIniPrinter->Attributes,
                                                        NULL,
                                                        NULL,
                                                        FALSE);

    pIniPrinter->StartTime = pPrinter->StartTime;
    pIniPrinter->UntilTime = pPrinter->UntilTime;

    pIniPrinter->pParameters = AllocSplStr(pPrinter->pParameters);

    pIniPrinter->pSepFile = AllocSplStr(pPrinter->pSepFile);

    pIniPrinter->pComment = AllocSplStr(pPrinter->pComment);

    pIniPrinter->pLocation = AllocSplStr(pPrinter->pLocation);

    if (pPrinter->pDevMode) {

        pIniPrinter->cbDevMode = pPrinter->pDevMode->dmSize +
                                 pPrinter->pDevMode->dmDriverExtra;
        SPLASSERT(pIniPrinter->cbDevMode);

        if (pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode)) {

            //
            // This is OK because the pPrinter->pDevmode is validated to be
            // encapsulated in its Rpc buffer by the server.
            //
            memcpy(pIniPrinter->pDevMode,
                   pPrinter->pDevMode,
                   pIniPrinter->cbDevMode);

            FixDevModeDeviceName( pIniPrinter->pName,
                                  pIniPrinter->pDevMode,
                                  pIniPrinter->cbDevMode );
        }

    } else {

        pIniPrinter->cbDevMode = 0;
        pIniPrinter->pDevMode = NULL;
    }

    pIniPrinter->DefaultPriority = pPrinter->DefaultPriority;

    pIniPrinter->pIniFirstJob = pIniPrinter->pIniLastJob = NULL;

    pIniPrinter->cJobs = pIniPrinter->AveragePPM = 0;

    pIniPrinter->GenerateOnClose = 0;

    // At present no API can set this up, the user has to use the
    // registry.   LATER we should enhance the API to take this.

    pIniPrinter->pSpoolDir = NULL;

    // Initialize Status Information

    pIniPrinter->cTotalJobs = 0;
    pIniPrinter->cTotalBytes.LowPart = 0;
    pIniPrinter->cTotalBytes.HighPart = 0;
    GetSystemTime(&pIniPrinter->stUpTime);
    pIniPrinter->MaxcRef = 0;
    pIniPrinter->cTotalPagesPrinted = 0;
    pIniPrinter->cSpooling = 0;
    pIniPrinter->cMaxSpooling = 0;
    pIniPrinter->cErrorOutOfPaper = 0;
    pIniPrinter->cErrorNotReady = 0;
    pIniPrinter->cJobError = 0;
    pIniPrinter->DsKeyUpdate = 0;
    pIniPrinter->DsKeyUpdateForeground = 0;
    pIniPrinter->pszObjectGUID = NULL;
    pIniPrinter->pszCN = NULL;
    pIniPrinter->pszDN = NULL;

    //
    //  Start from a Semi Random Number
    //  That way if someone deletes and creates a printer of
    //  the same name it is unlikely to have the same unique ID

    pIniPrinter->cChangeID = GetTickCount();

    if (pIniPrinter->cChangeID == 0 )
        pIniPrinter->cChangeID++;


    //
    // Initialize the masq printer cache, we just start with optimistic values
    //
    pIniPrinter->MasqCache.cJobs = 0;
    pIniPrinter->MasqCache.dwError = ERROR_SUCCESS;
    pIniPrinter->MasqCache.Status = 0;
    pIniPrinter->MasqCache.bThreadRunning = FALSE;

    return TRUE;
}

BOOL
UpdateWinIni(
    PINIPRINTER pIniPrinter
    )
{
    PINIPORT    pIniPort;
    DWORD       i;
    BOOL        bGenerateNetId = FALSE;
    LPWSTR      pszPort;

    SplInSem();

    if( !( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_UPDATE_WININI_DEVICES )){
        return TRUE;
    }

    //
    // Update win.ini for Win16 compatibility
    //
    if ( pIniPrinter->Status & PRINTER_PENDING_DELETION ) {

        CheckAndUpdatePrinterRegAll( pIniPrinter->pIniSpooler,
                                     pIniPrinter->pName,
                                     NULL,
                                     UPDATE_REG_DELETE );

    } else {

        //
        // Initialize in case there are no ports that match this printer.
        //
        pszPort = szNullPort;

        for( pIniPort = pIniPrinter->pIniSpooler->pIniPort;
             pIniPort;
             pIniPort = pIniPort->pNext ){

            for ( i = 0; i < pIniPort->cPrinters; i++ ) {

                if ( pIniPort->ppIniPrinter[i] == pIniPrinter ) {

                    //
                    // UpdatePrinterRegAll will automatically
                    // convert "\\server\share" or ports with
                    // spaces to Nexx:
                    //
                    pszPort = pIniPort->pName;
                    break;
                }
            }
        }

        CheckAndUpdatePrinterRegAll( pIniPrinter->pIniSpooler,
                                     pIniPrinter->pName,
                                     pszPort,
                                     UPDATE_REG_CHANGE );
    }

    BroadcastChange( pIniPrinter->pIniSpooler,
                     WM_WININICHANGE,
                     PR_JOBSTATUS,
                     (LPARAM)szIniDevices);

    return TRUE;
}



BOOL
DeletePrinterIni(
    PINIPRINTER pIniPrinter
    )
{
    DWORD   Status;
    LPWSTR  pSubkey;
    DWORD   cbNeeded;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    HKEY hPrinterKey;

    //
    // Only update if the spooler requests it.
    //
    if ((pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_PRINTERINI) ||
        !pIniPrinter->pName) {
        return TRUE;
    }

    hToken = RevertToPrinterSelf();

    Status = hToken ? ERROR_SUCCESS : GetLastError();

    if (!(pKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        Status = GetLastError();
        goto error;
    }

    if ( Status == ERROR_SUCCESS ) {

        Status = SplRegOpenKey( pIniSpooler->hckPrinters,
                                pKeyName,
                                KEY_WRITE | KEY_READ | DELETE,
                                &hPrinterKey,
                                pIniSpooler );
    }

    if (Status == ERROR_SUCCESS) {

        // Delete hPrinterKey - on success this returns ERROR_SUCCESS
        Status = SplDeleteThisKey( pIniSpooler->hckPrinters,
                                   hPrinterKey,
                                   pKeyName,
                                   TRUE,
                                   pIniSpooler );

        if (Status != ERROR_SUCCESS) {
            DBGMSG(DBG_WARNING, ("DeletePrinterIni: DeleteThisKey returned %ld\n", Status ));
        }
    }

    //
    // If entries are in per h/w profile registries delete them.
    //
    DeletePrinterInAllConfigs(pIniPrinter);

error:

    FreeSplStr(pKeyName);

    if ( hToken ) {

        if ( !ImpersonatePrinterClient(hToken) && Status == ERROR_SUCCESS ) {
            Status = GetLastError();
        }
    }
 
    return (Status == ERROR_SUCCESS);
}


//
// DeleteThisKey - returns ERROR_SUCCESS on final successful return
//                 deletes a key from Registry
// SWilson Dec 96
//

DWORD
SplDeleteThisKey(
    HKEY hParentKey,       // handle to parent of key to delete
    HKEY hThisKey,         // handle of key to delete
    LPWSTR pThisKeyName,   // name of this key
    BOOL bDeleteNullKey,   // if TRUE, then if pThisKeyName is NULL it is deleted
    PINISPOOLER pIniSpooler
)
{
    DWORD   dwResult = ERROR_SUCCESS, rc;
    WCHAR   Name[MAX_PATH];
    DWORD   cchName;
    LPWSTR  pName;
    HKEY    hSubKey;

    //
    // If hThisKey is NULL , try to open it
    //
    if( hThisKey == NULL) {

        if((hParentKey != NULL) && ( pThisKeyName && *pThisKeyName ) ){

            dwResult = SplRegOpenKey( hParentKey,
                                      pThisKeyName,
                                      KEY_WRITE | KEY_READ | DELETE,
                                      &hThisKey,
                                      pIniSpooler );
        }
    }

    //
    // Exit if SplRegOpenKey failed or hParentKey or pThisKeyName are invalid
    //
    if( hThisKey == NULL ){

        return dwResult;
    }

    // Get This key's children & delete them, then delete this key

    while(dwResult == ERROR_SUCCESS) {

        pName = Name;
        cchName = COUNTOF( Name );
        dwResult = SplRegEnumKey( hThisKey,
                                  0,
                                  pName,
                                  &cchName,
                                  NULL,
                                  pIniSpooler );

        if (dwResult == ERROR_MORE_DATA) {

            SPLASSERT(cchName > MAX_PATH);

            if (!(pName = AllocSplMem(cchName * sizeof( *pName )))) {
                dwResult = GetLastError();
            } else {
                dwResult = SplRegEnumKey( hThisKey,
                                          0,
                                          pName,
                                          &cchName,
                                          NULL,
                                          pIniSpooler );
            }
        }

        if (dwResult == ERROR_SUCCESS) {                      // SubKey found
            dwResult = SplRegCreateKey( hThisKey,             // Open SubKey
                                        pName,
                                        0,
                                        KEY_WRITE | KEY_READ | DELETE,
                                        NULL,
                                        &hSubKey,
                                        NULL,
                                        pIniSpooler);

            if (dwResult == ERROR_SUCCESS) {
                // Delete This SubKey
                dwResult = SplDeleteThisKey( hThisKey,
                                             hSubKey,
                                             pName,
                                             bDeleteNullKey,
                                             pIniSpooler );
            }
        }

        if (pName != Name)
            FreeSplStr(pName);
    }

    rc = SplRegCloseKey(hThisKey, pIniSpooler);
    SPLASSERT(rc == ERROR_SUCCESS);

    if (dwResult == ERROR_NO_MORE_ITEMS) {   // This Key has no children so can be deleted
        if ( (*pThisKeyName || bDeleteNullKey) && hParentKey != NULL ) {

            dwResult = SplRegDeleteKey(hParentKey, pThisKeyName, pIniSpooler);
            if (dwResult != ERROR_SUCCESS) {
               DBGMSG(DBG_WARNING, ("DeletePrinter: RegDeleteKey failed: %ld\n", dwResult));
            }
        }
        else
        {
            dwResult = ERROR_SUCCESS;
        }
    }

    return dwResult;
}



BOOL
PrinterCreateKey(
    HKEY    hKey,
    LPWSTR  pSubKey,
    PHKEY   phkResult,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    DWORD   Status;

    Status = SplRegCreateKey( hKey,
                              pSubKey,
                              0,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              phkResult,
                              NULL,
                              pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ( "PrinterCreateKey: SplRegCreateKey %ws error %d\n", pSubKey, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}


BOOL
UpdatePrinterIni(
   PINIPRINTER pIniPrinter,
   DWORD    dwChangeID
   )
{

    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD   dwLastError = ERROR_SUCCESS;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    DWORD   dwTickCount;
    BOOL    bReturnValue;
    DWORD   cbData;
    DWORD   cbNeeded;
    LPWSTR  pszPorts;
    HANDLE  hPrinterKey = NULL;
    HANDLE  hBackUpPrinterKey = NULL;

    SplInSem();

    //
    // Only update if the spooler requests it.
    //
    if( pIniSpooler->SpoolerFlags & SPL_NO_UPDATE_PRINTERINI ){
        return TRUE;
    }

    try {

        hToken = RevertToPrinterSelf();

        if ( hToken == FALSE ) {

            DBGMSG( DBG_TRACE, ("UpdatePrinterIni failed RevertToPrinterSelf %x\n", GetLastError() ));
        }

        pKeyName = SubChar(pIniPrinter->pName, L'\\', L',');
        if (!pKeyName) {
            dwLastError = GetLastError();
            leave;
        }

        if ( !PrinterCreateKey( pIniSpooler->hckPrinters,
                                pKeyName,
                                &hPrinterKey,
                                &dwLastError,
                                pIniSpooler )) {

            leave;
        }

        if (dwChangeID == UPDATE_DS_ONLY) {

            RegSetDWord(hPrinterKey, szDsKeyUpdate, pIniPrinter->DsKeyUpdate, &dwLastError, pIniSpooler);

            RegSetDWord(hPrinterKey, szDsKeyUpdateForeground, pIniPrinter->DsKeyUpdateForeground, &dwLastError, pIniSpooler);

            leave;
        }

        if ( dwChangeID != KEEP_CHANGEID ) {

            //
            // WorkStation Caching requires a Unique ID so that they can quickly
            // tell if their Cache is up to date.
            //

            dwTickCount = GetTickCount();

            // Ensure Uniqueness

            if ( dwTickCount == 0 )
                dwTickCount++;

            if ( pIniPrinter->cChangeID == dwTickCount )
                dwTickCount++;

            pIniPrinter->cChangeID = dwTickCount;
            RegSetDWord( hPrinterKey, szTimeLastChange, pIniPrinter->cChangeID, &dwLastError, pIniSpooler );

        }

        if ( dwChangeID != CHANGEID_ONLY ) {

            RegSetDWord( hPrinterKey, szStatus, pIniPrinter->Status, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szName, pIniPrinter->pName, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szName, pIniPrinter->pName, &dwLastError, pIniSpooler );
            }

            RegSetString( hPrinterKey, szShare, pIniPrinter->pShareName, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szPrintProcessor, pIniPrinter->pIniPrintProc->pName, &dwLastError, pIniSpooler );

            if ( !( pIniPrinter->Status & PRINTER_PENDING_DELETION )) {

                SPLASSERT( pIniPrinter->pDatatype != NULL );
            }

            RegSetString( hPrinterKey, szDatatype, pIniPrinter->pDatatype, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szParameters, pIniPrinter->pParameters, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szAction, pIniPrinter->dwAction, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szObjectGUID, pIniPrinter->pszObjectGUID, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDsKeyUpdate, pIniPrinter->DsKeyUpdate, &dwLastError, pIniSpooler);

            RegSetDWord( hPrinterKey, szDsKeyUpdateForeground, pIniPrinter->DsKeyUpdateForeground, &dwLastError, pIniSpooler);

            RegSetString( hPrinterKey, szDescription, pIniPrinter->pComment, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szDriver, pIniPrinter->pIniDriver->pName, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szDriver, pIniPrinter->pIniDriver->pName, &dwLastError, pIniSpooler );
            }


            if (pIniPrinter->pDevMode) {

                cbData = pIniPrinter->cbDevMode;

            } else {

                cbData = 0;
            }

            RegSetBinaryData( hPrinterKey, szDevMode, (LPBYTE)pIniPrinter->pDevMode, cbData, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetBinaryData( hBackUpPrinterKey, szDevMode, (LPBYTE)pIniPrinter->pDevMode, cbData, &dwLastError, pIniSpooler );
            }

            RegSetDWord( hPrinterKey, szPriority, pIniPrinter->Priority, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDefaultPriority, pIniPrinter->DefaultPriority, &dwLastError, pIniSpooler );

            RegSetDWord(hPrinterKey, szStartTime, pIniPrinter->StartTime, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szUntilTime, pIniPrinter->UntilTime, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szSepFile, pIniPrinter->pSepFile, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szLocation, pIniPrinter->pLocation, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szAttributes, pIniPrinter->Attributes, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szTXTimeout, pIniPrinter->txTimeout, &dwLastError, pIniSpooler );

            RegSetDWord( hPrinterKey, szDNSTimeout, pIniPrinter->dnsTimeout, &dwLastError, pIniSpooler );

            if (pIniPrinter->pSecurityDescriptor) {

                cbData = GetSecurityDescriptorLength( pIniPrinter->pSecurityDescriptor );

            } else {

                cbData = 0;
            }

            RegSetBinaryData( hPrinterKey, szSecurity, pIniPrinter->pSecurityDescriptor, cbData, &dwLastError, pIniSpooler );

            RegSetString( hPrinterKey, szSpoolDir, pIniPrinter->pSpoolDir, &dwLastError, pIniSpooler );

            cbNeeded = 0;
            GetPrinterPorts( pIniPrinter, 0, &cbNeeded);

            if (!(pszPorts = AllocSplMem(cbNeeded))) {
                dwLastError = GetLastError();
                leave;
            }

            GetPrinterPorts(pIniPrinter, pszPorts, &cbNeeded);

            RegSetString( hPrinterKey, szPort, pszPorts, &dwLastError, pIniSpooler );

            if( hBackUpPrinterKey != NULL ){

                RegSetString( hBackUpPrinterKey, szPort, pszPorts, &dwLastError, pIniSpooler );
            }


            FreeSplMem(pszPorts);

            //
            //  A Provider might want to Write Extra Data from Registry
            //
            if ( pIniSpooler->pfnWriteRegistryExtra != NULL ) {

                if ( !(*pIniSpooler->pfnWriteRegistryExtra)(pIniPrinter->pName, hPrinterKey, pIniPrinter->pExtraData)) {
                    dwLastError = GetLastError();
                }
            }


            if ( ( pIniPrinter->Status & PRINTER_PENDING_CREATION )     &&
                 ( dwLastError == ERROR_SUCCESS ) ) {

                pIniPrinter->Status &= ~PRINTER_PENDING_CREATION;

                RegSetDWord( hPrinterKey, szStatus, pIniPrinter->Status, &dwLastError, pIniSpooler );
            }


        }

    } finally {

        if ( hPrinterKey )
            SplRegCloseKey( hPrinterKey, pIniSpooler);

        if ( hBackUpPrinterKey )
            SplRegCloseKey( hBackUpPrinterKey, pIniSpooler);

        if ( hToken )
            ImpersonatePrinterClient( hToken );
    }

    FreeSplStr(pKeyName);

    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;
}


VOID
RemoveOldNetPrinters(
    PPRINTER_INFO_1 pPrinterInfo1,
    PINISPOOLER pIniSpooler
    )
{
    PININETPRINT   *ppIniNetPrint = &pIniSpooler->pIniNetPrint;
    PININETPRINT    pIniNetPrint;
    DWORD   TickCount;


    TickCount = GetTickCount();

    //
    //  Browse Information only becomes valid after this print server has been
    //  up for the NetPrinterDecayPeriod.
    //

    if (( bNetInfoReady == FALSE ) &&
       (( TickCount - FirstAddNetPrinterTickCount ) > NetPrinterDecayPeriod )) {

        DBGMSG( DBG_TRACE, ("RemoveOldNetPrinters has a valid browse list\n" ));

        bNetInfoReady = TRUE;
    }


    while (*ppIniNetPrint) {


        //
        //  If either the Tickcount has expired OR we want to delete this specific NetPrinter
        //  ( because its no longer shared ).
        //
        if ( (( TickCount - (*ppIniNetPrint)->TickCount ) > NetPrinterDecayPeriod + TEN_MINUTES ) ||

             ( pPrinterInfo1 != NULL                             &&
               pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_NETWORK  &&
             !(pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_SHARED ) &&
               _wcsicmp( pPrinterInfo1->pName, (*ppIniNetPrint)->pName ) == STRINGS_ARE_EQUAL)) {

            pIniNetPrint = *ppIniNetPrint;

            DBGMSG( DBG_TRACE, ("RemoveOldNetPrinters removing %ws not heard for %d millisconds\n",
                                pIniNetPrint->pName, ( TickCount - (*ppIniNetPrint)->TickCount ) ));

            //
            // Remove this item, which also increments the pointer.
            //
            *ppIniNetPrint = pIniNetPrint->pNext;

            pIniSpooler->cNetPrinters--;

            FreeSplStr( pIniNetPrint->pName );
            FreeSplStr( pIniNetPrint->pDescription );
            FreeSplStr( pIniNetPrint->pComment );
            FreeSplMem( pIniNetPrint );

        } else {

            ppIniNetPrint = &(*ppIniNetPrint)->pNext;
        }
    }

}

HANDLE
AddNetPrinter(
    LPBYTE  pPrinterInfo,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Net Printers are created by remote machines calling AddPrinter( Level = 1, Printer_info_1 )
    ( see server.c ).   They are used for browsing, someone can call EnumPrinters and ask to get
    back our browse list - ie all our net printers.

    The printers in this list are decayed out after 1 hour ( default ).

    See return value comment.

    Note client\winspool.c AddPrinterW doesn't allow PRINTER_INFO_1 ( NET printers ), so this can
    only come from system components.

Arguments:

    pPrinterInfo - Point to a PRINTER_INFO_1 structure to add

Return Value:

    NULL - it doesn't return a printer handle.
    LastError = ERROR_SUCCESS, or error code ( like out of memory ).

    NOTE before NT 3.51 it returned a printer handle of type PRINTER_HANDLE_NET, but since the
    only use of this handle was to close it ( which burnt up cpu / net traffic and RPC binding
    handles, we return a NULL handle now to make it more efficient.   Apps ( Server.c ) if it
    cares could call GetLastError.

--*/

{
    PPRINTER_INFO_1 pPrinterInfo1 = (PPRINTER_INFO_1)pPrinterInfo;
    PININETPRINT    pIniNetPrint = NULL;
    PININETPRINT    *ppScan;

    SplInSem();

    //
    //  Validate PRINTER_INFO_1
    //  At minimum it must have a PrinterName. Each field in the pPrinterInfo1
    //  must be of an appropriate size. Description is PrinterName,DriverName,Location.
    //
    if ( pPrinterInfo1->pName == NULL || wcslen(pPrinterInfo1->pName) > MAX_UNC_PRINTER_NAME ||
         (pPrinterInfo1->pComment && wcslen(pPrinterInfo1->pComment) > MAX_PATH) ||
         (pPrinterInfo1->pDescription && wcslen(pPrinterInfo1->pDescription) > MAX_PATH + MAX_PATH + MAX_UNC_PRINTER_NAME + 2))
    {
        DBGMSG( DBG_WARN, ("AddNetPrinter invalid printer parameters failed\n"));
        SetLastError( ERROR_INVALID_NAME );
        return NULL;
    }

    if ( FirstAddNetPrinterTickCount == 0 )
    {
        FirstAddNetPrinterTickCount = GetTickCount();
    }

    //
    //  Decay out of the browse list any old printers
    //
    RemoveOldNetPrinters( pPrinterInfo1, pIniSpooler );


    //
    //  Do Not Add and printer which is no longer shared.
    //

    if (pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_NETWORK && !(pPrinterInfo1->Flags & PRINTER_ATTRIBUTE_SHARED))
    {
        SetLastError(ERROR_PRINTER_ALREADY_EXISTS);
        goto Done;
    }

    //
    //  See if we already have this printer
    //

    pIniNetPrint = pIniSpooler->pIniNetPrint;

    while ( pIniNetPrint &&
            pIniNetPrint->pName &&
            lstrcmpi( pPrinterInfo1->pName, pIniNetPrint->pName ))
    {
        pIniNetPrint = pIniNetPrint->pNext;
    }


    //
    //  If we didn't find this printer already Create one
    //
    if (pIniNetPrint == NULL)
    {
        //
        // If we haven't already reached our maximum number of printers, then
        // go ahead and add this one.
        //
        if (pIniSpooler->cNetPrinters < kMaximumNumberOfBrowsePrinters)
        {
           pIniNetPrint = AllocSplMem( sizeof(ININETPRINT));

            if (pIniNetPrint)
            {
                pIniNetPrint->signature    = IN_SIGNATURE;
                pIniNetPrint->pName        = AllocSplStr( pPrinterInfo1->pName );
                pIniNetPrint->pDescription = AllocSplStr( pPrinterInfo1->pDescription );
                pIniNetPrint->pComment     = AllocSplStr( pPrinterInfo1->pComment );

                // Did Any of the above allocations fail ?

                if ( pIniNetPrint->pName == NULL ||
                  ( pPrinterInfo1->pDescription != NULL && pIniNetPrint->pDescription == NULL ) ||
                  ( pPrinterInfo1->pComment != NULL && pIniNetPrint->pComment == NULL ) )
                {

                    // Failed - CleanUp

                    FreeSplStr( pIniNetPrint->pComment );
                    FreeSplStr( pIniNetPrint->pDescription );
                    FreeSplStr( pIniNetPrint->pName );
                    FreeSplMem( pIniNetPrint );
                    pIniNetPrint = NULL;

                }
                else
                {

                    DBGMSG( DBG_TRACE, ("AddNetPrinter(%ws) NEW\n", pPrinterInfo1->pName ));

                    ppScan = &pIniSpooler->pIniNetPrint;

                    // Scan through the current known printers, and insert the new one
                    // in alphabetical order

                    while( *ppScan && (lstrcmp((*ppScan)->pName, pIniNetPrint->pName) < 0))
                    {
                        ppScan = &(*ppScan)->pNext;
                    }

                    pIniNetPrint->pNext = *ppScan;
                    *ppScan = pIniNetPrint;

                    pIniSpooler->cNetPrinters++;
                }
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

    } else
    {
        DBGMSG( DBG_TRACE, ("AddNetPrinter(%ws) elapsed since last notified %d milliseconds\n", pIniNetPrint->pName, ( GetTickCount() - pIniNetPrint->TickCount ) ));
    }


    if ( pIniNetPrint )
    {
        // Tickle the TickCount so this printer sticks around in the browse list

        pIniNetPrint->TickCount = GetTickCount();

        // Have to set some error code or RPC thinks ERROR_SUCCESS is good.

        SetLastError( ERROR_PRINTER_ALREADY_EXISTS );

        pIniSpooler->cAddNetPrinters++;         // Status Only
    }

Done:

    SPLASSERT( GetLastError() != ERROR_SUCCESS);

    return NULL;
}

/*++

Routine Name:

    ValidatePortTokenList

Routine Description:

    This routine ensures that the given set of ports in pKeyData are valid
    ports in the spooler and returns the buffer with the pointers to strings
    replaced with pointers ref-counted pIniPorts.

    The way we do this needs to be rethought. The overloaded PKEYDATA is confusing
    and unnecessary, we should simply return a new array of PINIPORTS. (It also
    pollutes the PKEYDATA with an unnecessary bFixPortRef member), Also, this
    code is both invoked for initialization and for Validation, but the logic is
    quite different. For initialization, we want to assume that everything in the
    registry is valid and start up with placeholder ports until the monitor can
    enumerate them (this could be because a USB printer is unplugged). In the other
    cases where this is being used for validation we want to fail. This implies that
    we might want to separate this into two functions.


Arguments:

    pKeyData        -   The array of strings that gets turned into an array of
                        ref-counted ports.
    pIniSpooler     -   The ini-spooler on which this is being added.
    bInitialize     -   If TRUE, this code is being invoked for initialization and
                        not for validation.
    pbNoPorts       -   Optional, this will return TRUE if bInitialize is TRUE and
                        none of the ports in the port list can be found. We will
                        then set the printer- offline and log a message.

Return Value:

    TRUE    -   if the ports were all all successfully created or validated.
    FALSE   -   otherwise.

--*/
BOOL
ValidatePortTokenList(
    IN  OUT PKEYDATA        pKeyData,
    IN      PINISPOOLER     pIniSpooler,
    IN      BOOL            bInitialize,
        OUT BOOL            *pbNoPorts          OPTIONAL
    )
{
    PINIPORT    pIniPort    =   NULL;
    DWORD       i           =   0;
    DWORD       j           =   0;
    DWORD       dwPorts     =   0;
    DWORD       Status      =   ERROR_SUCCESS;

    SplInSem();

    Status = !pKeyData ? ERROR_UNKNOWN_PORT : ERROR_SUCCESS;

    //
    // The logic remains the same for ports with only one token as for when we
    // initialize the ports for the first time.
    //
    if (Status == ERROR_SUCCESS)
    {
        bInitialize = pKeyData->cTokens == 1 ? TRUE : bInitialize;
    }

    //
    //  We do not allow non-masc ports and masq ports to be combined. Moreover
    //  only one non-masc port can be used for a printer -- can't do printer
    //  pooling with masq printers
    //
    for ( i = 0 ; Status == ERROR_SUCCESS && i < pKeyData->cTokens ; i++ )
    {

        pIniPort = FindPort(pKeyData->pTokens[i], pIniSpooler);

        //
        // A port is valid if it is found and if it isn't in itself a
        // placeholder port.
        //
        if (pIniPort && !(pIniPort->Status & PP_PLACEHOLDER))
        {
            dwPorts++;
        }

        //
        // If we are initializing, or if there is only one port and if the
        // spooler allows it, then create a dummy port entry. This also
        // handles the masq port case.
        //
        if (bInitialize)
        {
            if (!pIniPort && pIniSpooler->SpoolerFlags & SPL_OPEN_CREATE_PORTS)
            {
                //
                // Note: there is a potential problem here, CreatePortEntry uses
                // a global initialization flag rather than the parameter that is
                // passed in to us.
                //
                pIniPort = CreatePortEntry(pKeyData->pTokens[i], NULL, pIniSpooler);
            }
        }

        //
        // If we don't have a port or if we are not initializing and there isn't
        // a monitor associated with the port. Then we have an error.
        //
        if (!pIniPort || (!(pIniPort->Status & PP_MONITOR) && !bInitialize))
        {
            Status = ERROR_UNKNOWN_PORT;
        }

        //
        // In case of duplicate portnames in pPortName field fail the call. This
        // can't happen if we went through the CreatePortEntry code path and it
        // succeeded
        //
        for ( j = 0 ; Status == ERROR_SUCCESS && j < i ; ++j )
        {
            if ( pIniPort == (PINIPORT)pKeyData->pTokens[j] )
            {
                Status = ERROR_UNKNOWN_PORT;
            }
        }

        //
        // Write the port in.
        //
        if (Status == ERROR_SUCCESS)
        {
            pKeyData->pTokens[i] = (LPWSTR)pIniPort;
        }
    }

    //
    // If everything is successful, addref all of the pIniPorts and set the flag
    // to indicate that this has happened for the cleanup code.
    //
    if (Status == ERROR_SUCCESS)
    {
        for ( i = 0 ; i < pKeyData->cTokens ; ++i ) {

            pIniPort = (PINIPORT)pKeyData->pTokens[i];
            INCPORTREF(pIniPort);
        }

        pKeyData->bFixPortRef = TRUE;
    }

    if (pbNoPorts)
    {
        *pbNoPorts = dwPorts == 0;
    }

    if (Status != ERROR_SUCCESS)
    {
        SetLastError(Status);
    }

    return Status == ERROR_SUCCESS;
}


DWORD
ValidatePrinterName(
    LPWSTR          pszNewName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter,
    LPWSTR          *ppszLocalName
    )

/*++

Routine Description:

    Validates a printer name. Printer and share names exist in the same
    namespace, so validation is done against printer, share names.

Arguments:

    pszNewName - printer name specified

    pIniSpooler - Spooler that owns printer

    pIniPrinter - could be null if the printer is getting created

    ppszLocalName - on success returns local name
                    (\\servername stripped off if necessary).

Return Value:

    DWORD error code.

--*/

{
    PINIPRINTER pIniTempPrinter, pIniNextPrinter;
    LPWSTR pszLocalNameTmp = NULL;
    WCHAR  string[MAX_UNC_PRINTER_NAME];
    LPWSTR p;
    LPWSTR pLastSpace = NULL;

    //
    // The function ValidatePrinterName does too many things in one single routine.
    // It checks for validity of the printer name, it isolates the printer name,
    // it eliminates trailing white spaces from the printe name and validates
    // that the printer name is unique.
    //
    // The function IsValidPrinterName ensures that the printer names contains
    // valid characters and valid sequences of characters.
    //
    if (!IsValidPrinterName(pszNewName, MAX_UNC_PRINTER_NAME - 1))
    {
        return ERROR_INVALID_PRINTER_NAME;
    }

    if (*pszNewName == L'\\' && *(pszNewName + 1) == L'\\') {

        p = wcschr(pszNewName + 2, L'\\');

        if (p) {
            //
            // \\Server\Printer -> \\Server
            //
            StringCchCopy(string,  (size_t) (p - pszNewName) + 1, pszNewName);

            if (MyName(string, pIniSpooler))
                pszLocalNameTmp = p + 1; // \\Server\Printer -> \Printer
        }
    }

    if (!pszLocalNameTmp)
        pszLocalNameTmp = pszNewName;


    //
    // Strip trailing spaces.
    //
    for( p = pszLocalNameTmp; *p; ++p ){

        if( *p == L' ' ){

            //
            // If we haven't seen a continuous space, remember this
            // position.
            //
            if( !pLastSpace ){
                pLastSpace = p;
            }
        } else {

            //
            // Non-whitespace.
            //
            pLastSpace = NULL;
        }
    }

    if( pLastSpace ){
        *pLastSpace = 0;
    }

    //
    // Limit PrinterNames to MAX_PATH length, also if the printer name is now
    // empty as a result of stripping out all of the spaces, then the printer
    // name is now invalid.
    //
    if ( wcslen( pszLocalNameTmp ) > MAX_PRINTER_NAME || !*pszLocalNameTmp ) {
        return ERROR_INVALID_PRINTER_NAME;
    }

    //
    // Now validate that printer names are unique. Printer names and
    // share names  reside in the same namespace (see net\dosprint\dosprtw.c).
    //
    for( pIniTempPrinter = pIniSpooler->pIniPrinter;
         pIniTempPrinter;
         pIniTempPrinter = pIniNextPrinter ){

        //
        // Get the next printer now in case we delete the current
        // one in DeletePrinterCheck.
        //
        pIniNextPrinter = pIniTempPrinter->pNext;

        //
        // Skip ourselves, if we are passed in.
        //
        if( pIniTempPrinter == pIniPrinter ){
            continue;
        }

        //
        // Disallow common Printer/Share names.
        //
        if( !lstrcmpi( pszLocalNameTmp, pIniTempPrinter->pName ) ||
            ( pIniTempPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED  &&
              !lstrcmpi( pszLocalNameTmp, pIniTempPrinter->pShareName ))){

            if( !DeletePrinterCheck( pIniTempPrinter )){

                return ERROR_PRINTER_ALREADY_EXISTS;
            }
        }
    }

    //
    // Success, now update ppszLocalName from pszLocalNameTmp.
    //
    *ppszLocalName = pszLocalNameTmp;

    return ERROR_SUCCESS;
}

DWORD
ValidatePrinterShareName(
    LPWSTR          pszNewShareName,
    PINISPOOLER     pIniSpooler,
    PINIPRINTER     pIniPrinter
    )

/*++

Routine Description:

    Validates the printer share name. Printer and share names exist in the
    same namespace, so validation is done against printer, share names.

Arguments:

    pszNewShareName - share name specified

    pIniSpooler - Spooler that owns printer

    pIniPrinter - could be null if the printer is getting created

Return Value:

    DWORD error code.

--*/

{
    PINIPRINTER pIniTempPrinter, pIniNextPrinter;

    if ( !pszNewShareName || !*pszNewShareName || wcslen(pszNewShareName) > PATHLEN-1) {

        return ERROR_INVALID_SHARENAME;
    }

    //
    // Now validate that share names are unique.  Share names and printer names
    // reside in the same namespace (see net\dosprint\dosprtw.c).
    //
    for( pIniTempPrinter = pIniSpooler->pIniPrinter;
         pIniTempPrinter;
         pIniTempPrinter = pIniNextPrinter ) {

        //
        // Get the next printer now in case we delete the current
        // one in DeletePrinterCheck.
        //
        pIniNextPrinter = pIniTempPrinter->pNext;

        //
        // Skip ourselves, if we are pssed in.
        //
        if( pIniTempPrinter == pIniPrinter ){
            continue;
        }

        //
        // Check our share name now.
        //
        if( !lstrcmpi(pszNewShareName, pIniTempPrinter->pName) ||
            ( pIniTempPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED  &&
              !lstrcmpi(pszNewShareName, pIniTempPrinter->pShareName)) ) {

            if( !DeletePrinterCheck( pIniTempPrinter )){

                return ERROR_INVALID_SHARENAME;
            }
        }
    }

    return ERROR_SUCCESS;
}

DWORD
ValidatePrinterInfo(
    IN  PPRINTER_INFO_2 pPrinter,
    IN  PINISPOOLER pIniSpooler,
    IN  PINIPRINTER pIniPrinter OPTIONAL,
    OUT LPWSTR* ppszLocalName   OPTIONAL
    )
/*++

Routine Description:

    Validates that printer names/share do not collide.  (Both printer and
    share names exist in the same namespace.)

    Note: Later, we should remove all this DeletePrinterCheck.  As people
    decrement ref counts, they should DeletePrinterCheck themselves (or
    have it built into the decrement).

Arguments:

    pPrinter - PrinterInfo2 structure to validate.

    pIniSpooler - Spooler that owns printer

    pIniPrinter - If printer already exists, don't check against itself.

    ppszLocalName - Returned pointer to string buffer in pPrinter;
        indicates local name (\\servername stripped off if necessary).

        Valid only on SUCCESS return code.

Return Value:

    DWORD error code.

--*/
{
    LPWSTR pszNewLocalName;
    DWORD  dwLastError;

    if( !CheckSepFile( pPrinter->pSepFile )) {
        return ERROR_INVALID_SEPARATOR_FILE;
    }

    if( pPrinter->Priority != NO_PRIORITY &&
        ( pPrinter->Priority > MAX_PRIORITY ||
          pPrinter->Priority < MIN_PRIORITY )){

        return ERROR_INVALID_PRIORITY;
    }

    if( pPrinter->StartTime >= ONEDAY || pPrinter->UntilTime >= ONEDAY){

        return  ERROR_INVALID_TIME;
    }

    if ( dwLastError = ValidatePrinterName(pPrinter->pPrinterName,
                                           pIniSpooler,
                                           pIniPrinter,
                                           &pszNewLocalName) ) {

        return dwLastError;
    }

    // Share name length validation
    if(pPrinter->pShareName && wcslen(pPrinter->pShareName) > PATHLEN-1){

        return ERROR_INVALID_SHARENAME;
    }

    if ( pPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ){

        if ( dwLastError = ValidatePrinterShareName(pPrinter->pShareName,
                                                    pIniSpooler,
                                                    pIniPrinter) ) {

            return dwLastError;
        }
    }

    // Server name length validation
    if ( pPrinter->pServerName && wcslen(pPrinter->pServerName) > MAX_PATH-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Comment length validation
    if ( pPrinter->pComment && wcslen(pPrinter->pComment) > PATHLEN-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Location length validation
    if ( pPrinter->pLocation && wcslen(pPrinter->pLocation) > MAX_PATH-1 ){
        return ERROR_INVALID_PARAMETER;
    }

    // Parameters length validation
    if ( pPrinter->pParameters && wcslen(pPrinter->pParameters) > MAX_PATH-1){
        return ERROR_INVALID_PARAMETER;
    }

    // Datatype length validation
    if ( pPrinter->pDatatype && wcslen(pPrinter->pDatatype) > MAX_PATH-1){
        return ERROR_INVALID_DATATYPE;
    }

    if( ppszLocalName ){

        *ppszLocalName = pszNewLocalName;
    }
    return ERROR_SUCCESS;
}




HANDLE
LocalAddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinterInfo
)
{
    PINISPOOLER pIniSpooler;
    HANDLE hReturn;

    pIniSpooler = FindSpoolerByNameIncRef( pName, NULL );

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    hReturn = SplAddPrinter( pName,
                             Level,
                             pPrinterInfo,
                             pIniSpooler,
                             NULL, NULL, 0);

    FindSpoolerByNameDecRef( pIniSpooler );
    return hReturn;
}


HANDLE
LocalAddPrinterEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    LPBYTE  pSplClientInfo,
    DWORD   dwSplClientLevel
)
{
    PINISPOOLER pIniSpooler;
    HANDLE hReturn;

    pIniSpooler = FindSpoolerByNameIncRef(pName, NULL);

    if( !pIniSpooler ){
        return ROUTER_UNKNOWN;
    }

    hReturn = SplAddPrinter( pName, Level, pPrinterInfo,
                             pIniSpooler, NULL, pSplClientInfo,
                             dwSplClientLevel);

    FindSpoolerByNameDecRef( pIniSpooler );
    return hReturn;
}

VOID
RemovePrinterFromPort(
    IN  PINIPRINTER pIniPrinter,
    IN  PINIPORT    pIniPort
    )
/*++

Routine Description:

    Remove a pIniPrinter structure from a pIniPort.

    Note: This code used to be inside RemovePrinterFromAllPorts. It searches the
    list of printers that uses the port for pIniPrinter. When it finds it,
    it adjusts the list of printers by moving the elements so that a failure of
    resizing the array won't affect the actual removing. RESIZEPORTPRINTERS
    will try to allocate a new buffer of given size. If succeeds the allocation,
    it will free the old buffer. If not, it will return NULL without freeing
    anything.

Arguments:

    pIniPrinter - must not be NULL
    pIniPort    - must not be NULL

Return Value:

    VOID

--*/
{
    DWORD           j, k;
    PINIPRINTER    *ppIniPrinter;
    SplInSem();

    if(pIniPort && pIniPrinter) {

        for ( j = 0 ; j < pIniPort->cPrinters ; ++j ) {

            if ( pIniPort->ppIniPrinter[j] != pIniPrinter )
                continue;

            //
            // Adjust the list of printers that use the port
            //
            for ( k = j + 1 ; k < pIniPort->cPrinters ; ++k )
                pIniPort->ppIniPrinter[k-1] = pIniPort->ppIniPrinter[k];

            ppIniPrinter = RESIZEPORTPRINTERS(pIniPort, -1);

            //
            // A memory allocation failure won't affect the actual removal
            //
            if ( ppIniPrinter != NULL )
                pIniPort->ppIniPrinter = ppIniPrinter;

            if ( !--pIniPort->cPrinters )
                RemoveDeviceName(pIniPort);

            break;

        }
    }

}

HANDLE
SplAddPrinter(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pPrinterInfo,
    PINISPOOLER pIniSpooler,
    LPBYTE      pExtraData,
    LPBYTE      pSplClientInfo,
    DWORD       dwSplClientInfoLevel
)
{
    PINIDRIVER      pIniDriver = NULL;
    PINIPRINTPROC   pIniPrintProc;
    PINIPRINTER     pIniPrinter = NULL;
    PINIPORT        pIniPort;
    PPRINTER_INFO_2 pPrinter=(PPRINTER_INFO_2)pPrinterInfo;
    DWORD           cbIniPrinter = sizeof(INIPRINTER);
    BOOL            bSucceeded = TRUE;
    PKEYDATA        pKeyData = NULL;
    DWORD           i;
    HANDLE          hPrinter = NULL;
    DWORD           TypeofHandle = PRINTER_HANDLE_PRINTER;
    PRINTER_DEFAULTS Defaults;
    PINIPORT        pIniNetPort = NULL;
    PINIVERSION     pIniVersion = NULL;
    HANDLE          hPort = NULL;
    BOOL            bAccessSystemSecurity = FALSE, bDriverEventCalled = FALSE;
    DWORD           AccessRequested = 0;
    DWORD           dwLastError = ERROR_SUCCESS;
    DWORD           dwPrnEvntError = ERROR_SUCCESS;
    PDEVMODE        pNewDevMode = NULL;
    PINIMONITOR     pIniLangMonitor;
    LPWSTR          pszDeviceInstanceId = NULL;


    // Quick Check Outside Critical Section
    // Since it is common for the ServerThread to call
    // AddPrinter Level 1, which we need to continue
    // to route to other Print Providers

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }


 try {

   EnterSplSem();

    // PRINTER_INFO_1 is only used by printer browsing to replicate
    // data between different print servers.
    // Thus we add a Net printer for level 1.

    if ( Level == 1 ) {

        //
        // All network printers reside in pLocalIniSpooler to avoid
        // duplicates.
        //
        hPrinter = AddNetPrinter(pPrinterInfo, pLocalIniSpooler);
        leave;
    }


    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {
        leave;
    }

    if ( dwLastError = ValidatePrinterInfo( pPrinter,
                                            pIniSpooler,
                                            NULL,
                                            NULL )){

        leave;
    }


    if (!(pKeyData = CreateTokenList(pPrinter->pPortName))) {

        dwLastError = ERROR_UNKNOWN_PORT;
        leave;
    }

    if ( pName && pName[0] ) {

        TypeofHandle |= PRINTER_HANDLE_REMOTE_DATA;
    }

    {
        HRESULT hRes = CheckLocalCall();

        if (hRes == S_FALSE)
        {
            TypeofHandle |= PRINTER_HANDLE_REMOTE_CALL;
        }
        else if (hRes != S_OK)
        {
            dwLastError = SCODE_CODE(hRes);
            leave;
        }
    }

    if (!ValidatePortTokenList(pKeyData, pIniSpooler, FALSE, NULL)) {

        //
        // ValidatePortTokenList sets the last error to ERROR_INVALID_PRINTER_NAME
        // when port name is invalid. This is correct only for masquerading printers.
        // Otherwise, it should be ERROR_UNKNOWN_PORT.
        // Masq. Printer: both PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL are set.
        //
        if (!(pPrinter->Attributes & (PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL))) {
            SetLastError(ERROR_UNKNOWN_PORT);
        }

        leave;
    }

    FindLocalDriverAndVersion(pIniSpooler, pPrinter->pDriverName, &pIniDriver, &pIniVersion);

    if (!pIniDriver) {

        dwLastError = ERROR_UNKNOWN_PRINTER_DRIVER;
        leave;
    }

    //
    // Check for blocked KM drivers
    //
    if (KMPrintersAreBlocked() &&
        IniDriverIsKMPD(pIniSpooler,
                        FindEnvironment(szEnvironment, pIniSpooler),
                        pIniVersion,
                        pIniDriver)) {

        SplLogEvent( pIniSpooler,
                     LOG_ERROR,
                     MSG_KM_PRINTERS_BLOCKED,
                     TRUE,
                     pPrinter->pPrinterName,
                     NULL );

        dwLastError = ERROR_KM_DRIVER_BLOCKED;
        leave;
    }

    if (!(pIniPrintProc = FindPrintProc(pPrinter->pPrintProcessor,
                                        FindEnvironment(szEnvironment, pIniSpooler)))) {

        dwLastError = ERROR_UNKNOWN_PRINTPROCESSOR;
        leave;
    }

    if ( pPrinter->pDatatype && *pPrinter->pDatatype &&
         !FindDatatype(pIniPrintProc, pPrinter->pDatatype) ) {

        dwLastError = ERROR_INVALID_DATATYPE;
        leave;
    }

    DBGMSG(DBG_TRACE, ("AddPrinter(%ws)\n", pPrinter->pPrinterName ?
                                            pPrinter->pPrinterName : L"NULL"));

    //
    // Set up defaults for CreatePrinterHandle.
    // If we create a printer we have Administer access to it:
    //
    Defaults.pDatatype     = NULL;
    Defaults.pDevMode      = NULL;
    Defaults.DesiredAccess = PRINTER_ALL_ACCESS;

    pIniPrinter = (PINIPRINTER)AllocSplMem( cbIniPrinter );

    if ( pIniPrinter == NULL ) {
        leave;
    }

    pIniPrinter->signature = IP_SIGNATURE;
    pIniPrinter->Status |= PRINTER_PENDING_CREATION;
    pIniPrinter->pExtraData = pExtraData;
    pIniPrinter->pIniSpooler = pIniSpooler;
    pIniPrinter->dwPrivateFlag = 0;

    // Give the printer a unique session ID to pass around in notifications
    pIniPrinter->dwUniqueSessionID = dwUniquePrinterSessionID++;

    //
    // Reference count the pIniSpooler.
    //
    INCSPOOLERREF( pIniSpooler );

    INCDRIVERREF(pIniDriver);
    pIniPrinter->pIniDriver = pIniDriver;

    pIniPrintProc->cRef++;
    pIniPrinter->pIniPrintProc = pIniPrintProc;

    pIniPrinter->dnsTimeout = DEFAULT_DNS_TIMEOUT;
    pIniPrinter->txTimeout  = DEFAULT_TX_TIMEOUT;


    INCPRINTERREF( pIniPrinter );

    if (!CreatePrinterEntry(pPrinter, pIniPrinter, &bAccessSystemSecurity)) {

        leave;
    }

    pIniPrinter->ppIniPorts = AllocSplMem(pKeyData->cTokens * sizeof(INIPORT));

    if ( !pIniPrinter->ppIniPorts ) {

        leave;
    }

    if (!pIniPrinter->pDatatype) {

        pIniPrinter->pDatatype = AllocSplStr(*((LPWSTR *)pIniPrinter->pIniPrintProc->pDatatypes));

        if ( pIniPrinter->pDatatype == NULL )
            leave;
    }

    // Add this printer to the global list for this machine

    SplInSem();
    pIniPrinter->pNext = pIniSpooler->pIniPrinter;
    pIniSpooler->pIniPrinter = pIniPrinter;


    //
    // When a printer is created we will enable bidi by default
    //
    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
    if ( pIniPrinter->pIniDriver->pIniLangMonitor ) {

        pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
    }


    for ( i = 0; i < pKeyData->cTokens; i++ ) {

        pIniPort = (PINIPORT)pKeyData->pTokens[i];

        if ( !AddIniPrinterToIniPort( pIniPort, pIniPrinter ) ) {
            leave;
        }

        pIniPrinter->ppIniPorts[i] = pIniPort;
        pIniPrinter->cPorts++;

        // If there isn't a monitor for this port,
        // it's a network printer.
        // Make sure we can get a handle for it.
        // This will attempt to open only the first one
        // it finds.  Any others will be ignored.

        if (!(pIniPort->Status & PP_MONITOR) && !hPort) {

            if(bSucceeded = OpenPrinterPortW(pIniPort->pName, &hPort, NULL)) {

                // Store the address of the INIPORT structure
                // that refers to the network share.
                // This should correspond to pIniPort in any
                // handles opened on this printer.
                // Only the first INIPORT in the linked list
                // is a valid network port.

                pIniNetPort = pIniPort;
                pIniPrinter->pIniNetPort = pIniNetPort;

                //
                // Clear the placeholder status from the pIniPort.
                //
                pIniPort->Status &= ~PP_PLACEHOLDER;

            } else {

                DBGMSG(DBG_WARNING,
                       ("SplAddPrinter OpenPrinterPort( %ws ) failed: Error %d\n",
                        pIniPort->pName,
                        GetLastError()));
                leave;
            }        
        } 
        else if (!pIniPort->hMonitorHandle) 
        {
            LPTSTR pszPrinter;
            TCHAR szFullPrinter[ MAX_UNC_PRINTER_NAME ];

            if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI )
                pIniLangMonitor = pIniPrinter->pIniDriver->pIniLangMonitor;
            else
                pIniLangMonitor = NULL;

            if( pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

                pszPrinter = szFullPrinter;
                if (!BoolFromHResult(StringCchPrintf(szFullPrinter, 
                                                     COUNTOF(szFullPrinter), 
                                                     L"%ws\\%ws", 
                                                     pIniSpooler->pMachineName, 
                                                     pIniPrinter->pName))){
                    leave;
                }

            } else {

                pszPrinter = pIniPrinter->pName;
            }

           OpenMonitorPort(pIniPort, pIniLangMonitor, pszPrinter); 
           ReleaseMonitorPort(pIniPort);
        }
    }

    if ( !UpdateWinIni( pIniPrinter ) ) {

        leave;
    }


    if (bAccessSystemSecurity) {

        Defaults.DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    AccessRequested = Defaults.DesiredAccess;

    SplInSem();

    hPrinter = CreatePrinterHandle( pIniPrinter->pName,
                                    pName ? pName : pIniSpooler->pMachineName,
                                    pIniPrinter,
                                    pIniPort,
                                    pIniNetPort,
                                    NULL,
                                    TypeofHandle,
                                    hPort,
                                    &Defaults,
                                    pIniSpooler,
                                    AccessRequested,
                                    pSplClientInfo,
                                    dwSplClientInfoLevel,
                                    INVALID_HANDLE_VALUE );

    if ( hPrinter == NULL ) {
        leave;
    }


    if ( !UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID )) {

        dwLastError = GetLastError();

        SplClosePrinter( hPrinter );
        hPrinter = NULL;
        leave;
    }


    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

        INC_PRINTER_ZOMBIE_REF(pIniPrinter);

        //
        // NOTE ShareThisPrinter will leave critical section and the
        // server will call the spooler back again to OpenPrinter this
        // printer.  So this printer MUST be fully created at the point
        // it is shared, so that Open can succeed.
        //
        bSucceeded = ShareThisPrinter(pIniPrinter,
                                      pIniPrinter->pShareName,
                                      TRUE
                                      );

        DEC_PRINTER_ZOMBIE_REF(pIniPrinter);

        if ( !bSucceeded ) {

            //
            // We do not want to delete the existing share in DeletePrinterIni
            //
            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            DBGMSG( DBG_WARNING, ("LocalAddPrinter: %ws share failed %ws error %d\n",
                    pIniPrinter->pName,
                    pIniPrinter->pShareName,
                    GetLastError() ));


            //
            //  With PRINTER_PENDING_CREATION turned on we will Delete this printer.
            //

            pIniPrinter->Status |= PRINTER_PENDING_CREATION;

            dwLastError = GetLastError();

            SPLASSERT( hPrinter );
            SplClosePrinter( hPrinter );
            hPrinter = NULL;
            leave;
        }
    }

    pIniPrinter->Status |= PRINTER_OK;
    SplInSem();

    // Call the DriverEvent with PRINTER_INITIALIZE while adding local printers

    LeaveSplSem();

    if (pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL) {

        if (bDriverEventCalled = PrinterDriverEvent(pIniPrinter,
                                                    PRINTER_EVENT_INITIALIZE,
                                                    (LPARAM)NULL,
                                                    &dwPrnEvntError) == FALSE) {

            dwLastError = dwPrnEvntError;

            if (dwLastError != ERROR_PROC_NOT_FOUND) {

                if (!dwLastError)
                    dwLastError = ERROR_CAN_NOT_COMPLETE;

                EnterSplSem();

                //
                //  With PRINTER_PENDING_CREATION turned on the printer will be deleted.
                //
                pIniPrinter->Status |= PRINTER_PENDING_CREATION;
                SplClosePrinter( hPrinter );
                hPrinter = NULL;

                leave;
             }
        }

    }

    EnterSplSem();

    //
    // If no devmode is given get driver default, if a devmode is given
    // convert it to current version
    //
    // Check if it's local (either pLocalIniSpooler or cluster).
    //
    if ( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ) {

        if (!(pNewDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                             pIniPrinter->pDevMode,
                                                             NULL,
                                                             NULL,
                                                             CURRENT_VERSION))) {

           dwLastError = GetLastError();
           if (!dwLastError) {
              dwLastError = ERROR_CAN_NOT_COMPLETE;
           }

           //
           //  With PRINTER_PENDING_CREATION turned on the printer will be deleted.
           //
           pIniPrinter->Status |= PRINTER_PENDING_CREATION;
           SplClosePrinter( hPrinter );
           hPrinter = NULL;

           leave;
        }

        //
        // If call is remote we must convert devmode before setting it
        //
        if ( pNewDevMode || (TypeofHandle & PRINTER_HANDLE_REMOTE_DATA) ) {

            FreeSplMem(pIniPrinter->pDevMode);
            pIniPrinter->pDevMode = pNewDevMode;
            if ( pNewDevMode ) {

                pIniPrinter->cbDevMode = pNewDevMode->dmSize
                                             + pNewDevMode->dmDriverExtra;
                SPLASSERT(pIniPrinter->cbDevMode);

            } else {

                pIniPrinter->cbDevMode = 0;
            }
            pNewDevMode = NULL;
        }
    }

    if ( pIniPrinter->pDevMode ) {

        //
        // Fix up the DEVMODE.dmDeviceName field.
        //
        FixDevModeDeviceName(pIniPrinter->pName,
                             pIniPrinter->pDevMode,
                             pIniPrinter->cbDevMode);
    }

    //
    // We need to write the new devmode to the registry
    //
    if (!UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID)) {

        DBGMSG(DBG_WARNING,
               ("SplAddPrinter: UpdatePrinterIni failed after devmode conversion\n"));
    }

    //
    // For Masq printers, give the provider a chance to update the printer registry, if desired.
    //
    if( pIniNetPort ) {
        static const WCHAR c_szHttp[]   = L"http://";
        static const WCHAR c_szHttps[]  = L"https://";

        if( !_wcsnicmp( pIniPort->pName, c_szHttp, lstrlen ( c_szHttp ) ) ||
            !_wcsnicmp( pIniPort->pName, c_szHttps, lstrlen ( c_szHttps ) ) ) {
            UpdatePrinterNetworkName(pIniPrinter, pIniPort->pName);
        }
    }

    //
    // DS: Create the DS keys
    //
    INCPRINTERREF(pIniPrinter);
    LeaveSplSem();

    RecreateDsKey(hPrinter, SPLDS_DRIVER_KEY);
    RecreateDsKey(hPrinter, SPLDS_SPOOLER_KEY);

    EnterSplSem();
    DECPRINTERREF(pIniPrinter);

    //
    //  From this point on we don't care if any of these fail
    //  we still keep the created printer.
    //
    SplLogEvent( pIniSpooler,
                 LOG_INFO,
                 MSG_PRINTER_CREATED,
                 TRUE,
                 pIniPrinter->pName,
                 NULL );

    SetPrinterChange(pIniPrinter,
                     NULL,
                     NVPrinterAll,
                     PRINTER_CHANGE_ADD_PRINTER,
                     pIniSpooler);


 } finally {

    SplInSem();

    if ( hPrinter == NULL ) {

        // FAILURE CLEAN-UP

        // If a subroutine we called failed
        // then we should save its error incase it is
        // altered during cleanup.

        if ( dwLastError == ERROR_SUCCESS ) {
            dwLastError = GetLastError();
        }

        if ( pIniPrinter == NULL ) {

            //  Allow a Print Provider to free its ExtraData
            //  associated with this printer.

            if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
                ( pExtraData != NULL )) {

                (*pIniSpooler->pfnFreePrinterExtra)( pExtraData );

            }

        } else if ( pIniPrinter->Status & PRINTER_PENDING_CREATION ) {

            if (bDriverEventCalled) {

               LeaveSplSem();

                // Call Driver Event to report that the printer has been deleted
               PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL, &dwPrnEvntError );

               EnterSplSem();
            }

            DECPRINTERREF( pIniPrinter );

            InternalDeletePrinter( pIniPrinter );

        }

    } else {

        // Success

        if ( pIniPrinter ) {

            DECPRINTERREF( pIniPrinter );
        }
    }

    FreePortTokenList(pKeyData);

    LeaveSplSem();
    SplOutSem();

    FreeSplMem(pNewDevMode);

    if ( hPrinter == NULL && Level != 1 ) {

        DBGMSG(DBG_WARNING, ("SplAddPrinter failed error %d\n", dwLastError ));
        SPLASSERT(dwLastError);
        SetLastError ( dwLastError );
    }

    DBGMSG( DBG_TRACE, ("SplAddPrinter returned handle %x\n", hPrinter ));
 }
    //
    // Make (HANDLE)-1 indicate ROUTER_STOP_ROUTING.
    //
    if( !hPrinter ){
        hPrinter = (HANDLE)-1;
    }

    return hPrinter;

}


VOID
RemovePrinterFromAllPorts(
    IN  PINIPRINTER pIniPrinter,
    IN  BOOL        bIsInitTime
    )
/*++

Routine Description:

    Remove a pIniPrinter structure from all pIniPort structures that it is
    associated with.

    Note: This code used to be inside RemovePrinterFromAllPorts. It searches
    the list of printers that uses the port for pIniPrinter. When it finds it,
    it adjust the list of printers by moving the elements so that a failure of
    resizing the array won't affect the actual removing.

    RESIZEPORTPRINTERS will try to allocate a new buffer of given size. If succeeds
    the allocation, it will free the old buffer. If not, it will return NULL without
    freeing anything.

Arguments:

    pIniPrinter - must not be NULL
    pIniPort    - must not be NULL

Return Value:

    VOID

--*/
{
    DWORD           i,j, k;
    PINIPORT        pIniPort;
    PINIPRINTER    *ppIniPrinter;
    SplInSem();

    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        RemovePrinterFromPort(pIniPrinter, pIniPort);

        //
        // Delete port if is initialization time , it doesn't have printers
        // attached and it has no Monitor;
        // This is a fix for the USBMON problem described below:
        // USBMON doesn't enumerate the ports which are not used by a printer.
        // Spooler doesn't enumerate printers which are in pending deletion state.
        // Scenario:  Spooler initializes , all printers that uses a
        // certain USB_X port are in pending deletion state,
        // the USB_X port doesn't get enumerated by USBMON,
        // but it is created as a fake port by spooler since is still used by
        // the printer in pending deletion state. Eventually the prinetr goes away,
        // but we end up with this fake port.
        //
        if( bIsInitTime && !pIniPort->cPrinters && !pIniPort->pIniMonitor )
            DeletePortEntry(pIniPort);
    }

}



VOID
CloseMonitorsRestartOrphanJobs(
    PINIPRINTER pIniPrinter
    )
{
    PINIPORT    pIniPort;
    DWORD       i;
    BOOL        bFound;

    SplInSem();

    for ( pIniPort = pIniPrinter->pIniSpooler->pIniPort;
          pIniPort != NULL;
          pIniPort = pIniPort->pNext ) {

        if ( pIniPort->pIniJob != NULL &&
             pIniPort->pIniJob->pIniPrinter == pIniPrinter ) {


            //
            // If this printer is no longer associated with this port
            // then restart that job.
            //
            for ( i = 0, bFound = FALSE;
                  i < pIniPort->cPrinters;
                  i++) {

                if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
                    bFound = TRUE;
                }
            }

            if ( !bFound ) {

                DBGMSG( DBG_WARNING, ("CloseMonitorsRestartOrphanJobs Restarting JobId %d\n", pIniPort->pIniJob->JobId ));
                RestartJob( pIniPort->pIniJob );
            }
        }

        if ( !pIniPort->cPrinters &&
             !(pIniPort->Status & PP_THREADRUNNING) ) {

            CloseMonitorPort(pIniPort);
        }
    }
}


//
// This really does delete the printer.
// It should be called only when the printer has no open handles
// and no jobs waiting to print
//
BOOL
DeletePrinterForReal(
    PINIPRINTER pIniPrinter,
    BOOL        bIsInitTime
    )
{
    PINIPRINTER *ppIniPrinter;
    DWORD       i,j;
    PINISPOOLER pIniSpooler;
    LPWSTR      pComma;
    DWORD       Status;

    SplInSem();
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    pIniSpooler = pIniPrinter->pIniSpooler;

    if ( pIniPrinter->pName != NULL ) {

        DBGMSG( DBG_TRACE, ("Deleting %ws for real\n", pIniPrinter->pName ));
    }

    CheckAndUpdatePrinterRegAll( pIniSpooler,
                                 pIniPrinter->pName,
                                 NULL,
                                 UPDATE_REG_DELETE );

    DeleteIniPrinterDevNode(pIniPrinter);

    DeletePrinterIni( pIniPrinter );

    //  Take this IniPrinter off the list of printers for
    //  this IniSpooler

    SplInSem();
    ppIniPrinter = &pIniSpooler->pIniPrinter;

    while (*ppIniPrinter && *ppIniPrinter != pIniPrinter) {
        ppIniPrinter = &(*ppIniPrinter)->pNext;
    }

    if (*ppIniPrinter)
        *ppIniPrinter = pIniPrinter->pNext;

    //
    //  Decrement useage counts for Print Processor & Driver
    //

    if ( pIniPrinter->pIniPrintProc )
        pIniPrinter->pIniPrintProc->cRef--;

    if ( pIniPrinter->pIniDriver )
        DECDRIVERREF(pIniPrinter->pIniDriver);

    RemovePrinterFromAllPorts(pIniPrinter, bIsInitTime);

    CloseMonitorsRestartOrphanJobs( pIniPrinter );

    DeletePrinterSecurity( pIniPrinter );

    //  When the printer is Zombied it gets a trailing comma
    //  Concatingated with the name ( see job.c deleteprintercheck ).
    //  Remove trailing , from printer name before we log it as deleted.

    if ( pIniPrinter->pName != NULL ) {

        pComma = wcsrchr( pIniPrinter->pName, *szComma );

        if ( pComma != NULL ) {

            *pComma = 0;
        }

        SplLogEvent( pIniSpooler,
                     LOG_WARNING,
                     MSG_PRINTER_DELETED,
                     TRUE,
                     pIniPrinter->pName,
                     NULL );
    }

    // Deleting the network port if it exists
    if (pIniPrinter->pIniNetPort && pIniPrinter->pIniNetPort->pName) {
        DeleteIniNetPort(pIniPrinter);
        SplInSem();
    }

    FreeStructurePointers((LPBYTE) pIniPrinter, NULL, IniPrinterOffsets);

    //
    // Allow a Print Provider to free its ExtraData
    // associated with this printer.
    //

    if (( pIniSpooler->pfnFreePrinterExtra != NULL ) &&
        ( pIniPrinter->pExtraData != NULL )) {

        (*pIniSpooler->pfnFreePrinterExtra)( pIniPrinter->pExtraData );
    }

    //
    // Reference count the pIniSpooler.
    //
    DECSPOOLERREF( pIniPrinter->pIniSpooler );

    FreeSplMem( pIniPrinter );

    return TRUE;
}

VOID
DeleteIniNetPort(
    PINIPRINTER pIniPrinter
    )
{
    LPWSTR             pszName        = NULL;
    LPWSTR             pszPortName    = NULL;
    HANDLE             hXcv           = NULL;
    PRINTER_DEFAULTS   Defaults       = { NULL, NULL, SERVER_ACCESS_ADMINISTER };
    static const TCHAR pszPrefix[]    = TEXT(",XcvPort ");
    BOOL               bUsingXcvData  = FALSE;
    DWORD              dwNeeded, dwStatus, dwSize;

    SplInSem();

    pszPortName = AllocSplStr(pIniPrinter->pIniNetPort->pName);

    if (pszPortName)
    {
        LeaveSplSem();
        SplOutSem();

        if (ERROR_SUCCESS == StrCatAlloc(&pszName, pszPrefix, pszPortName, NULL))
        {
            //
            // We try opening a transcieve handle to the port.
            //
            bUsingXcvData = OpenPrinterPortW(pszName, &hXcv, &Defaults);

            if (bUsingXcvData)
            {
                dwSize = (lstrlen(pszPortName) + 1)*sizeof(TCHAR);

                bUsingXcvData = XcvData(hXcv,
                                        TEXT("DeletePort"),
                                        (LPBYTE)pszPortName,
                                        dwSize,
                                        NULL,
                                        0,
                                        &dwNeeded,
                                        &dwStatus);
            }

            // If we fail to use XcvData to delete the port we try to do it using DeletePort.
            if (!bUsingXcvData)
            {
                DeletePort(NULL, NULL, pszName);
            }

            if (hXcv)
            {
                ClosePrinter(hXcv);
            }
        }

        FreeSplMem(pszName);
        FreeSplStr(pszPortName);

        EnterSplSem();
    }
}

VOID
InternalDeletePrinter(
    PINIPRINTER pIniPrinter
    )
{
    BOOL dwRet = FALSE;
    DWORD dwPrnEvntError = ERROR_SUCCESS;

    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    //
    //  This Might be a partially created printer that has no name
    //

    if ( pIniPrinter->pName != NULL ) {

        DBGMSG(DBG_TRACE, ("LocalDeletePrinter: %ws pending deletion: references = %d; jobs = %d\n",
                           pIniPrinter->pName, pIniPrinter->cRef, pIniPrinter->cJobs));

        INCPRINTERREF( pIniPrinter );

        SplLogEvent( pIniPrinter->pIniSpooler, LOG_WARNING, MSG_PRINTER_DELETION_PENDING,
                  TRUE, pIniPrinter->pName, NULL );

        DECPRINTERREF( pIniPrinter );
    }

    //
    // Mark the printer as "Don't accept any jobs" to make sure
    // that no more are accepted while we are outside CS.
    // Marking the printer in PRINTER_PENDING_DELETION also would
    // prevent adding any jobs, but then the OpenPrinter calls that the
    // driver does inside DrvDriverEvent will fail.
    //
    pIniPrinter->Status |= PRINTER_NO_MORE_JOBS;

    if (pIniPrinter->cJobs == 0)
    {
        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        PrinterDriverEvent( pIniPrinter, PRINTER_EVENT_DELETE, (LPARAM)NULL, &dwPrnEvntError );

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);
    }

    pIniPrinter->Status |= PRINTER_PENDING_DELETION;

    if (!(pIniPrinter->Status & PRINTER_PENDING_CREATION)) {

        SetPrinterChange(pIniPrinter,
                         NULL,
                         NVPrinterStatus,
                         PRINTER_CHANGE_DELETE_PRINTER,
                         pIniPrinter->pIniSpooler );
    }

    INC_PRINTER_ZOMBIE_REF( pIniPrinter );

    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) {

        dwRet = ShareThisPrinter(pIniPrinter, pIniPrinter->pShareName, FALSE);

        if (!dwRet) {

            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            pIniPrinter->Status |= PRINTER_WAS_SHARED;
            CreateServerThread();

        } else {

            DBGMSG(DBG_WARNING, ("LocalDeletePrinter: Unsharing this printer failed %ws\n", pIniPrinter->pName));
        }
    }

    DEC_PRINTER_ZOMBIE_REF( pIniPrinter );

    //
    // The printer doesn't get deleted until ClosePrinter is called
    // on the last remaining handle.
    //
    UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

    UpdateWinIni( pIniPrinter );

    DeletePrinterCheck( pIniPrinter );
}



BOOL
SplDeletePrinter(
    HANDLE  hPrinter
)
{
    PINIPRINTER pIniPrinter;
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    DWORD       LastError = ERROR_SUCCESS;
    PINISPOOLER pIniSpooler;

    EnterSplSem();

    pIniSpooler = pSpool->pIniSpooler;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    if ( ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER) ) {

        pIniPrinter = pSpool->pIniPrinter;

        DBGMSG( DBG_TRACE, ( "SplDeletePrinter: %s called\n", pIniPrinter->pName ));

        if ( !AccessGranted(SPOOLER_OBJECT_PRINTER,
                            DELETE, pSpool) ) {

            LastError = ERROR_ACCESS_DENIED;

        } else if (pIniPrinter->cJobs && (pIniPrinter->Status & PRINTER_PAUSED)) {

            // Don't allow a printer to be deleted that is paused and has
            // jobs waiting, otherwise it'll never get deleted:

            LastError = ERROR_PRINTER_HAS_JOBS_QUEUED;

        } else {

            if (!(pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE) &&
                (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {

                if (!pIniPrinter->bDsPendingDeletion) {
                    pIniPrinter->bDsPendingDeletion = TRUE;
                    INCPRINTERREF(pIniPrinter);     // DECPRINTERREF is done in UnpublishByGUID
                    SetPrinterDs(hPrinter, DSPRINT_UNPUBLISH, FALSE);
                }
            }

            InternalDeletePrinter( pIniPrinter );
            (VOID) ObjectDeleteAuditAlarm( szSpooler, pSpool, pSpool->GenerateOnClose );
        }

    } else
        LastError = ERROR_INVALID_HANDLE;

    LeaveSplSem();
    SplOutSem();

    if (LastError) {
        SetLastError(LastError);
        return FALSE;
    }

    return TRUE;
}

BOOL
PurgePrinter(
    PINIPRINTER pIniPrinter
    )
{
    PINIJOB pIniJob, pIniNextJob;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;

    SplInSem();

    pIniNextJob = pIniPrinter->pIniFirstJob;

    //
    // We go through the list of all the jobs for the printer and delete them.
    // The check for cRef == 0 or JOB_PENDING_DELETION is for optimization.
    // We keep a refcount on the next job so that it doesnt get deleted when
    // we leave the CS during DeleteJob. Any Jobs with status Spooling are just
    // ignored because the spooler does not support deleting a job which is
    // being spooled, as yet.
    //
    while (pIniNextJob)
    {
        pIniJob = pIniNextJob;
        pIniNextJob = pIniJob->pIniNextJob;

        if ( (pIniJob->cRef == 0) || !(pIniJob->Status & JOB_PENDING_DELETION))
        {
            // this job is going to be deleted
            DBGMSG(DBG_TRACE, ("Job Address 0x%.8x Job Status 0x%.8x\n", pIniJob, pIniJob->Status));

            InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_RESTART);

            if (pIniNextJob)
            {
                INCJOBREF(pIniNextJob);
            }

            DeleteJob(pIniJob,NO_BROADCAST);
            if (pIniNextJob)
            {
                DECJOBREF(pIniNextJob);
            }
        }
    }

    // When purging a printer we don't want to generate a spooler information
    // message for each job being deleted becuase a printer might have a very
    // large number of jobs being purged would lead to a large number of
    // of unnessary and time consuming messages being generated.
    // Since this is a information only message it shouldn't cause any problems
    // Also Win 3.1 didn't have purge printer functionality and the printman
    // generated this message on Win 3.1

    if (dwEnableBroadcastSpoolerStatus) {
        BroadcastChange( pIniSpooler,WM_SPOOLERSTATUS, PR_JOBSTATUS, (LPARAM)0);
    }

    return TRUE;
}


BOOL
SetPrinterPorts(
    PSPOOL      pSpool,         // Caller's printer handle.  May be NULL.
    PINIPRINTER pIniPrinter,
    PKEYDATA    pKeyData
)
{
    DWORD       i,j;
    PINIPORT    pIniNetPort = NULL, pIniPort;
    BOOL        bReturnValue = TRUE;
    PINIPRINTER *ppIniPrinter;


    SPLASSERT( pIniPrinter != NULL );
    SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT( pIniPrinter->pIniSpooler != NULL );
    SPLASSERT( pIniPrinter->pIniSpooler->signature == ISP_SIGNATURE );

    //
    // Can't change the port for a masq printer
    //
    if ( (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_LOCAL)  &&
         (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_NETWORK) ) {

        if ( pKeyData->cTokens == 1 &&
             pSpool->pIniNetPort == (PINIPORT)pKeyData->pTokens[0] )
            return TRUE;

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Can't change printer port to that of a masq printer
    //
    for ( i = 0 ; i < pKeyData->cTokens ; ++i )
        if ( !(((PINIPORT) pKeyData->pTokens[i])->Status & PP_MONITOR) ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    //
    // Remove the printer from all ports ; break the link from ports to printer
    //
    RemovePrinterFromAllPorts(pIniPrinter, NON_INIT_TIME);

    //
    // Remove all ports from printer; break the link from printer to ports
    //
    FreeSplMem(pIniPrinter->ppIniPorts);
    pIniPrinter->ppIniPorts = NULL;
    pIniPrinter->cPorts = 0;

    //
    // If we fail to add all the ports inside pKeyData, we'll leave the printer in this state
    // where it's initials ports are gone and only part or none of the ports are added.
    //

    // Go through all the ports that this printer is connected to,
    // and add build the bi-dir links between printer and ports.

    for (i = 0; i < pKeyData->cTokens; i++ ) {

        pIniPort = (PINIPORT)pKeyData->pTokens[i];

        //
        // Add pIniPrinter to pIniPort
        //
        if ( AddIniPrinterToIniPort( pIniPort, pIniPrinter ) ) {

            //
            // If we succeeded, add pIniPort to pIniPrinter
            //
            if ( !AddIniPortToIniPrinter( pIniPrinter, pIniPort ) ) {

                //
                // If fail, then remove pIniPrinter from pIniPort ;
                // If we don't do this, pIniPort will point to invalid memory when piniPrinter gets deleted
                //
                RemovePrinterFromPort(pIniPrinter, pIniPort);

                bReturnValue = FALSE;
                goto Cleanup;
            }

        } else {
            bReturnValue = FALSE;
            goto Cleanup;
        }

    }

    CloseMonitorsRestartOrphanJobs( pIniPrinter );

Cleanup:
    return bReturnValue;
}

/*++

Routine Name:

    AllocResetDevMode

Routine Description:

    This routine makes a copy of the passed in devmode that can be associated
    to the printer handle in the call to reset printer.  The passed in devmode
    can be null in this case the user does not want a devmode, this simplifies
    the caller.  This routine also takes care of a few special cases.  If
    pDevMode is -1 it returns the printers default devmode.  If the printers
    default devmode is null this function will succeed.

Arguments:

    pIniPrinter     - pointer to ini printer structure for the specified printer
    pDevMode,       - pointer to devmode to allocation, this is optional
    *ppDevMode      - pointer where to return new allocated devmode

Return Value:

    TRUE success, FALSE an error occurred.

Last Error:

    ERROR_INVALID_PARAMETER if any of the required parameters are invalid.

--*/
BOOL
AllocResetDevMode(
    IN      PINIPRINTER  pIniPrinter,
    IN      DWORD        TypeofHandle,
    IN      PDEVMODE     pDevMode,      OPTIONAL
       OUT  PDEVMODE     *ppDevMode
    )
{
    BOOL bRetval = FALSE;

    //
    // Validate the input parameters.
    //
    if (pIniPrinter && ppDevMode)
    {
        //
        // Initalize the out parameter
        //
        *ppDevMode = NULL;

        //
        // If pDevMode == -1 then we want to return the printers default devmode.
        // The -1 token is for internal use, and currently only used by the server
        // service, which does not run in the context of the user, hence we must
        // not use a per user devmode.
        //
        if (pDevMode == (PDEVMODE)-1)
        {
            //
            // If the handle is a 3.x we must convert the devmode.
            //
            if (TypeofHandle & PRINTER_HANDLE_3XCLIENT)
            {
                *ppDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                              pDevMode,
                                                              NULL,
                                                              NULL,
                                                              NT3X_VERSION);

                bRetval = !!*ppDevMode;
            }
            else
            {
                //
                // Get the printer's default devmode.
                //
                pDevMode = pIniPrinter->pDevMode;
            }
        }

        //
        // At this point the pDevMode may be either the passed in devmode
        // or the default devmode on the printer.  If the devmode on the printer
        // is null then this function will succeed but will not return a devmode.
        //
        if (pDevMode && pDevMode != (PDEVMODE)-1)
        {
            //
            // Make a copy of the passed in devmode, this is less efficient
            // however it simplfies the callers clean up code, less chance for
            // a mistake.
            //
            UINT cbSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

            *ppDevMode = AllocSplMem(cbSize);

            bRetval = !!*ppDevMode;

            if (bRetval)
            {
                //
                // This is OK, YResetPrinter validates that the devmode is of the
                // correct size.
                //
                memcpy(*ppDevMode, pDevMode, cbSize);
            }
        }
        else
        {
            DBGMSG(DBG_TRACE,("LocalResetPrinter: Not resetting the pDevMode field\n"));
            bRetval = TRUE;
        }
    }
    else
    {
        //
        // The function returns a bool, we must set the last error.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetval;
}

/*++

Routine Name:

    AllocResetDataType

Routine Description:

    This routine allocates a new datatype that will be associated with
    a printer handle in ResetPrinter.

Arguments:

    pIniPrinter     - pointer to ini printer structure for the specified printer
    pDatatype       - the new data type to validate and allocate
    ppDatatype      - where to return the new datatype
    ppIniPrintProc  - pointer where to return the associated print processor

Return Value:

    TRUE function succeeded, FALSE an error occurred, use GetLastError() for
    extended error information.

Last Error:

    ERROR_INVALID_PARAMETER if a required parameter is invalid.
    ERROR_INVALID_DATATYPE if the specified datatype is invalid.

--*/
BOOL
AllocResetDataType(
    IN      PINIPRINTER      pIniPrinter,
    IN      PCWSTR           pDatatype,
       OUT  PCWSTR           *ppDatatype,
       OUT  PINIPRINTPROC    *ppIniPrintProc
    )
{
    BOOL bRetval = FALSE;

    //
    // Validate the input parameters.
    //
    if (pIniPrinter && ppDatatype && ppIniPrintProc)
    {
        //
        // Initalize the out parameters
        //
        *ppDatatype     = NULL;
        *ppIniPrintProc = NULL;

        if (pDatatype)
        {
            //
            // If the datatype is -1 we are being requested to
            // return the default datatype for this printer.
            //
            if (pDatatype == (LPWSTR)-1 && pIniPrinter->pDatatype)
            {
                *ppIniPrintProc = FindDatatype(pIniPrinter->pIniPrintProc, pIniPrinter->pDatatype);
            }
            else
            {
                *ppIniPrintProc = FindDatatype(pIniPrinter->pIniPrintProc, (PWSTR)pDatatype);
            }

            //
            // If the print process was found, the datatype is valid,
            // allocate the new datatype.
            //
            if (*ppIniPrintProc)
            {
                *ppDatatype = AllocSplStr(pIniPrinter->pDatatype);
                bRetval = !!*ppDatatype;
            }
            else
            {
                SetLastError(ERROR_INVALID_DATATYPE);
            }
        }
        else
        {
            DBGMSG(DBG_TRACE,("LocalResetPrinter: Not resetting the pDatatype field\n"));
            bRetval = TRUE;
        }
    }
    else
    {
        //
        // The function returns a bool, we must set the last error.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetval;
}

/*++

Routine Name:

    SplResetPrinter

Routine Description:

    The ResetPrinter function lets an application specify the data type
    and device mode values that are used for printing documents submitted
    by the StartDocPrinter function. These values can be overridden by using
    the SetJob function once document printing has started.

    This routine basically has two jobs.  To reset the devmode of the
    printer handle and to reset the datatype of the printer handle.  Each
    or both operation could be ignored, if the devmode null the devmode
    will not change if the datatye is null the datatype should not change.  If
    both operations are requested and any one fails then both operations
    should fail.

Arguments:

    hPrinter    - Valid printer handle
    pDefault    - Pointer to a printer defaults structure that has a devmode
                  and data type.

Return Value:

    TRUE function succeeded, FALSE an error occurred, use GetLastError() for
    extended error information.

Last Error:

    ERROR_INVALID_PARAMETER if the pDefault is NULL,
    ERROR_INVALID_DATATYPE if the new datatype specified is unknown or invalid

--*/
BOOL
SplResetPrinter(
    IN HANDLE              hPrinter,
    IN LPPRINTER_DEFAULTS  pDefaults
    )
{
    PSPOOL          pSpool              = (PSPOOL)hPrinter;
    BOOL            bRetval             = FALSE;
    PINIPRINTPROC   pNewPrintProc       = NULL;
    LPWSTR          pNewDatatype        = NULL;
    PDEVMODE        pNewDevMode         = NULL;

    DBGMSG(DBG_TRACE, ("ResetPrinter( %08x )\n", hPrinter));

    //
    // Validate the printer handle.
    //
    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER))
    {
        //
        // Validate the pDefaults
        //
        if (pDefaults)
        {
            //
            // Enter the spooler semaphore.
            //
            EnterSplSem();

            //
            // Get the new devmode, a null input devmode indicatest the caller
            // was not interesting in changing the devmode.
            //
            bRetval = AllocResetDevMode(pSpool->pIniPrinter,
                                        pSpool->TypeofHandle,
                                        pDefaults->pDevMode,
                                        &pNewDevMode);

            if (bRetval)
            {
                //
                // Get the new datatype and printprocessor, a null input datatype
                // indicates the caller was not interested in changing the datatype.
                //
                bRetval = AllocResetDataType(pSpool->pIniPrinter,
                                             pDefaults->pDatatype,
                                             &pNewDatatype,
                                             &pNewPrintProc);
            }

            if (bRetval)
            {
                //
                // Release the previous devmode provided we have a new devmode to set
                // a new devmode may not be available in the case the caller did not
                // request a devmode change.
                //
                if (pNewDevMode)
                {
                    FreeSplMem(pSpool->pDevMode);
                    pSpool->pDevMode = pNewDevMode;
                    pNewDevMode = NULL;
                }

                //
                // Release the previous datatype provided we have a new datatype to set
                // a new datatype may not be available in the case the caller did not
                // request a devmode change.
                //
                if (pNewDatatype && pNewPrintProc)
                {
                    FreeSplStr(pSpool->pDatatype);
                    pSpool->pDatatype = pNewDatatype;
                    pNewDatatype = NULL;

                    //
                    // Release the previous print processor, and assign the new one.
                    //
                    pSpool->pIniPrintProc->cRef--;
                    pSpool->pIniPrintProc = pNewPrintProc;
                    pSpool->pIniPrintProc->cRef++;
                    pNewPrintProc = NULL;
                }
            }

            //
            // Exit the spooler semaphore.
            //
            LeaveSplSem();

            //
            // Always release any resources, the mem free routines will handle null pointers.
            //
            FreeSplMem(pNewDevMode);
            FreeSplMem(pNewDatatype);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return bRetval;
}

BOOL
CopyPrinterIni(
   PINIPRINTER pIniPrinter,
   LPWSTR pNewName
   )
{
    HKEY    hPrinterKey=NULL;
    DWORD   Status;
    PWSTR   pSourceKeyName = NULL;
    PWSTR   pDestKeyName = NULL;
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    BOOL    bReturnValue = TRUE;

    SPLASSERT( pIniSpooler != NULL);
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    hToken = RevertToPrinterSelf();

    if (!hToken) {
        bReturnValue = FALSE;
        goto error;
    }

    if (!(pSourceKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        bReturnValue = FALSE;
        goto error;
    }

    if (!(pDestKeyName = SubChar(pNewName, L'\\', L','))) {
        bReturnValue = FALSE;
        goto error;
    }

    if( !CopyRegistryKeys( pIniSpooler->hckPrinters,
                           pSourceKeyName,
                           pIniSpooler->hckPrinters,
                           pDestKeyName,
                           pIniSpooler )) {
        bReturnValue = FALSE;
        goto error;
    }

error:

    FreeSplStr(pSourceKeyName);
    FreeSplStr(pDestKeyName);

    if (hToken) {

        if (!ImpersonatePrinterClient(hToken) && bReturnValue)
        {
            bReturnValue = FALSE;
        }
    }

    return bReturnValue;
}

VOID
FixDevModeDeviceName(
    LPWSTR pPrinterName,
    PDEVMODE pDevMode,
    DWORD cbDevMode)

/*++

Routine Description:

    Fixes up the dmDeviceName field of the DevMode to be the same
    as the printer name.

Arguments:

    pPrinterName - Name of the printer (qualified with server for remote)

    pDevMode - DevMode to fix up

    cbDevMode - byte count of devmode.

Return Value:

--*/

{
    DWORD cbDeviceMax;
    DWORD cchDeviceStrLenMax;
    //
    // Compute the maximum length of the device name string
    // this is the min of the structure and allocated space.
    //
    SPLASSERT(cbDevMode && pDevMode);

    if(cbDevMode && pDevMode) {
        cbDeviceMax = ( cbDevMode < sizeof(pDevMode->dmDeviceName)) ?
                        cbDevMode :
                        sizeof(pDevMode->dmDeviceName);

        SPLASSERT(cbDeviceMax);

        cchDeviceStrLenMax = (cbDeviceMax / sizeof(pDevMode->dmDeviceName[0]));

        StringCchCopy(pDevMode->dmDeviceName, cchDeviceStrLenMax, pPrinterName);
    }
}


BOOL
CopyPrinterDevModeToIniPrinter(
    PINIPRINTER pIniPrinter,
    PDEVMODE   pDevMode)
{
    BOOL bReturn = TRUE;
    DWORD dwInSize = 0;
    DWORD dwCurSize = 0;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    WCHAR       PrinterName[ MAX_UNC_PRINTER_NAME ];

    if (pDevMode) {

        dwInSize = pDevMode->dmSize + pDevMode->dmDriverExtra;
        if (pIniPrinter->pDevMode) {

            //
            // Detect if the devmodes are identical
            // if they are, no need to copy or send devmode.
            // (Skip the device name though!)
            //
            dwCurSize = pIniPrinter->pDevMode->dmSize
                        + pIniPrinter->pDevMode->dmDriverExtra;

            if (dwInSize == dwCurSize) {

                if (dwInSize > sizeof(pDevMode->dmDeviceName)) {

                    if (!memcmp(&pDevMode->dmSpecVersion,
                                &pIniPrinter->pDevMode->dmSpecVersion,
                                dwCurSize - sizeof(pDevMode->dmDeviceName))) {

                        //
                        // No need to copy this devmode because its identical
                        // to what we already have.
                        //
                        DBGMSG(DBG_TRACE,("Identical DevModes, no update\n"));
                        bReturn = FALSE;

                        goto FixupName;
                    }
                }
            }

            //
            // Free the devmode which we already have.
            //
            FreeSplMem(pIniPrinter->pDevMode);
        }

        pIniPrinter->cbDevMode = pDevMode->dmSize +
                                 pDevMode->dmDriverExtra;
        SPLASSERT(pIniPrinter->cbDevMode);


        if (pIniPrinter->pDevMode = AllocSplMem(pIniPrinter->cbDevMode)) {

            //
            // OK. This assumes the pIniPrinter's devmode has already been validated.
            //
            memcpy(pIniPrinter->pDevMode, pDevMode, pIniPrinter->cbDevMode);

            //
            //  Prepend the machine name if this is not localspl
            //
            if ( pIniSpooler != pLocalIniSpooler ) {

                // For Non Local Printers prepend the Machine Name

                StringCchPrintf(PrinterName, COUNTOF(PrinterName), L"%ws\\%ws", pIniSpooler->pMachineName, pIniPrinter->pName);

            } else {

                StringCchPrintf(PrinterName, COUNTOF(PrinterName), L"%ws", pIniPrinter->pName);
            }

            BroadcastChange(pIniSpooler, WM_DEVMODECHANGE, 0, (LPARAM)PrinterName);
        }

    } else {

        //
        // No old, no new, so no change.
        //
        if (!pIniPrinter->pDevMode)
            return FALSE;
    }

FixupName:

    if (pIniPrinter->pDevMode) {

        //
        // Fix up the DEVMODE.dmDeviceName field.
        //
        FixDevModeDeviceName(pIniPrinter->pName,
                             pIniPrinter->pDevMode,
                             pIniPrinter->cbDevMode);
    }
    return bReturn;
}

BOOL
NameAndSecurityCheck(
    LPCWSTR   pServer
    )
{
   PINISPOOLER pIniSpooler;
   BOOL bReturn = TRUE;

   pIniSpooler = FindSpoolerByNameIncRef( (LPWSTR)pServer, NULL );

   if( !pIniSpooler ){
       return ROUTER_UNKNOWN;
   }
   // Check if the call is for the local machine.
   if ( pServer && *pServer ) {
       if ( !MyName((LPWSTR) pServer, pIniSpooler )) {
           bReturn = FALSE;
           goto CleanUp;
       }
   }

   // Check for admin priviledges.
   if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pIniSpooler )) {
      bReturn = FALSE;
   }

CleanUp:
   // The Local case is handled in the router.
    FindSpoolerByNameDecRef( pIniSpooler );
    return bReturn;
}

BOOL
LocalAddPerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName,
    LPCWSTR   pPrintServer,
    LPCWSTR   pProvider
    )
{
   return NameAndSecurityCheck(pServer);
}

BOOL
LocalDeletePerMachineConnection(
    LPCWSTR   pServer,
    LPCWSTR   pPrinterName
    )
{
   return NameAndSecurityCheck(pServer);
}

BOOL
LocalEnumPerMachineConnections(
    LPCWSTR   pServer,
    LPBYTE    pPrinterEnum,
    DWORD     cbBuf,
    LPDWORD   pcbNeeded,
    LPDWORD   pcReturned
    )
{
   SetLastError(ERROR_INVALID_NAME);







   return FALSE;
}


BOOL
UpdatePrinterNetworkName(
    PINIPRINTER pIniPrinter,
    LPWSTR pszPorts
    )
{
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD   dwLastError = ERROR_SUCCESS;
    LPWSTR  pKeyName = NULL;
    HANDLE  hToken;
    BOOL    bReturnValue;
    HANDLE  hPrinterKey = NULL;
    HANDLE  hPrinterHttpDataKey = NULL;


    SplInSem();

    hToken = RevertToPrinterSelf();

    if ( hToken == FALSE ) {

        DBGMSG( DBG_TRACE, ("UpdatePrinterIni failed RevertToPrinterSelf %x\n", GetLastError() ));
    }

    if (!(pKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        dwLastError = GetLastError();
        goto Cleanup;
    }

    if ( !PrinterCreateKey( pIniSpooler->hckPrinters,
                            pKeyName,
                            &hPrinterKey,
                            &dwLastError,
                            pIniSpooler )) {

        goto Cleanup;
    }

    if ( !PrinterCreateKey( hPrinterKey,
                            L"HttpData",
                            &hPrinterHttpDataKey,
                            &dwLastError,
                            pIniSpooler )) {

        goto Cleanup;
    }

    RegSetString( hPrinterHttpDataKey, L"UIRealNetworkName", pszPorts, &dwLastError, pIniSpooler );


Cleanup:

    FreeSplStr(pKeyName);

    if ( hPrinterHttpDataKey )
        SplRegCloseKey( hPrinterHttpDataKey, pIniSpooler);

    if ( hPrinterKey )
        SplRegCloseKey( hPrinterKey, pIniSpooler);

    if ( hToken )
        ImpersonatePrinterClient( hToken );


    if ( dwLastError != ERROR_SUCCESS ) {

        SetLastError( dwLastError );
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}

DWORD
KMPrintersAreBlocked(
)
{
    return GetSpoolerNumericPolicy(szKMPrintersAreBlocked,
                                   DefaultKMPrintersAreBlocked);
}

PINIPRINTER
FindPrinterAnywhere(
    LPTSTR pName,
    DWORD SpoolerType
    )

/*++

Routine Description:

    Search for a printer name in all pIniSpoolers.

Arguments:

    pName - Name of printer to search for.

    SpoolerType - Type of spooler the printer should reside in.

Return Value:

    PINIPRINTER - Found pIniPrinter
    NULL - Not found.

--*/

{
    LPCTSTR pszLocalName;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler = FindSpoolerByName( pName,
                                                 &pszLocalName );

    SplInSem();

    if( pIniSpooler &&
        (( pIniPrinter = FindPrinter( pszLocalName, pIniSpooler )) ||
         ( pIniPrinter = FindPrinterShare( pszLocalName, pIniSpooler )))){

        if( pIniPrinter->pIniSpooler->SpoolerFlags & SpoolerType ){
            return pIniPrinter;
        }
    }

    return NULL;
}

BOOL
LocalAddPrinterConnection(
    LPWSTR   pName
)
{
    //
    // Allow us to make clustered connections to local printers
    // (they appear to be remote).
    //
    BOOL bReturn = FALSE;

    EnterSplSem();

    if( FindPrinterAnywhere( pName, SPL_TYPE_CLUSTER )){
        bReturn = TRUE;
    }

    LeaveSplSem();

    SetLastError(ERROR_INVALID_NAME);
    return bReturn;
}

BOOL
LocalDeletePrinterConnection(
    LPWSTR  pName
)
{
    //
    // Allow us to remove clustered connections to local printers
    // (they appear to be remote).
    //
    BOOL bReturn = FALSE;

    EnterSplSem();

    if( FindPrinterAnywhere( pName, SPL_TYPE_CLUSTER )){
        bReturn = TRUE;
    }

    LeaveSplSem();

    SetLastError(ERROR_INVALID_NAME);
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\property.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    Adds properties to ds

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr;
    VARIANT varInputData;

    hr = PackString2Variant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&varInputData);

    return hr;
}


HRESULT
get_BSTR_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}


HRESULT
put_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    DWORD *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDWORD2Variant(
            *pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}

HRESULT
get_DWORD_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    PDWORD pdwDestProperty
)
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdwDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDWORDfromVariant(
            varOutputData,
            pdwDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;

}


HRESULT
put_Dispatch_Property(
    IADs  *pADsObject,
    BSTR   bstrPropertyName,
    IDispatch *pdwSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (!pdwSrcProperty)
        return S_OK;

    hr = PackDispatch2Variant(
            pdwSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    return hr;
}


HRESULT
get_Dispatch_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDispatchfromVariant(
            varOutputData,
            ppDispatch
            );
    BAIL_ON_FAILURE(hr);


error:
    return hr;
}




HRESULT
put_MULTISZ_Property(
    IADs    *pADsObject,
    BSTR    bstrPropertyName,
    BSTR    pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT var;
    VARIANT varInputData;
    BSTR    pStr;
    BSTR    *pStrArray;
    DWORD   i;
    BSTR    pMultiString;

    if (!pSrcStringProperty || !*pSrcStringProperty)
        pMultiString = L"";
    else
        pMultiString = pSrcStringProperty;

    VariantInit(&var);

    // Convert MULTI_SZ to string array (last element of array must be NULL)
    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        ;

    if (!(pStrArray = (BSTR *) AllocSplMem((i + 1)*sizeof(BSTR)))) {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, pStr = pMultiString ; *pStr ; ++i, pStr += wcslen(pStr) + 1)
        pStrArray[i] = pStr;
    pStrArray[i] = NULL;

    MakeVariantFromStringArray(pStrArray, &var);

    FreeSplMem(pStrArray);

    hr = PackVARIANTinVariant(
            var,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!pSrcStringProperty || !*pSrcStringProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:

    VariantClear(&var);
    VariantClear(&varInputData);

    return hr;
}

HRESULT
put_BOOL_Property(
    IADs *pADsObject,
    BSTR bstrPropertyName,
    BOOL *bSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BOOL    bVal;

    bVal = bSrcProperty ? *bSrcProperty : 0;

    hr = PackBOOL2Variant(
            bVal,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    if (!bSrcProperty) {
        hr = pADsObject->PutEx(
                ADS_PROPERTY_CLEAR,
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = pADsObject->Put(
                bstrPropertyName,
                varInputData
                );
        BAIL_ON_FAILURE(hr);
    }

error:
    return hr;
}


HRESULT
get_UI1Array_Property(
    IADs *pADsObject,
    BSTR  bstrPropertyName,
    IID  *pIID
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UI1Array2IID(
            varOutputData,
            pIID
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);

    return hr;
}

HRESULT
get_SID_Property(
    IADs    *pADsObject,
    BSTR    bstrPropertyName,
    LPWSTR  *ppszSID
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UI1Array2SID(
            varOutputData,
            ppszSID
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear(&varOutputData);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\security.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module interfaces with the security system

Author:

    Andrew Bell (andrewbe) June 1992

Revision History:

--*/

#include <precomp.h>

/******************************************************************************


    The printing security model
    ---------------------------

    In printing we define a hierarchy of three objects:


                                 SERVER

                                 /    \
                                /      \
                               /        ...
                              /

                         PRINTER

                          /   \
                         /     \
                        /       ...
                       /

                  DOCUMENT




    The following types of operation may be performed on each of these objects:


        SERVER:   Install/Deinstall Driver
                  Create Printer
                  Enumerate Printers

        PRINTER:  Pause/Resume
                  Delete
                  Connect to/Disconnect
                  Set
                  Enumerate Documents

        DOCUMENT: Pause/Resume
                  Delete
                  Set Attributes



    For product LanMan NT, five classes of user are defined, and,
    for Windows NT, four classes are defined.
    The following privileges are assigned to each class:



    Administrators

    Print Operators

    System Operators

    Power Users

    Owners

    Everyone (World)




******************************************************************************/

#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

#define TOKENLENGTH( Token ) ( *( ( (PDWORD)Token ) - 1 ) )



/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Came from \\orville\razzle\src\private\newsam\server\bldsam3.c

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/


GENERIC_MAPPING GenericMapping[SPOOLER_OBJECT_COUNT] =
{
    { SERVER_READ,   SERVER_WRITE,   SERVER_EXECUTE,  SERVER_ALL_ACCESS   },
    { PRINTER_READ,  PRINTER_WRITE,  PRINTER_EXECUTE, PRINTER_ALL_ACCESS  },
    { JOB_READ,      JOB_WRITE,      JOB_EXECUTE,     JOB_ALL_ACCESS      }
};

/* !!! Should these be translatable??? */

LPWSTR ObjectTypeName[SPOOLER_OBJECT_COUNT] =
{
    L"Server", L"Printer", L"Document"
};

WCHAR *szSpooler = L"Spooler";


LUID AuditValue;

PSECURITY_DESCRIPTOR pServerSecurityDescriptor;
LUID                 gLoadDriverPrivilegeLuid;
PSID                 pLocalSystemSid;
PSID                 pGuestsSid;
PSID                 pNetworkLogonSid;

BOOL ServerGenerateOnClose;  /* Do we need this for the server? */

#if DBG
#define DBG_ACCESS_TYPE_SERVER_ALL_ACCESS                   0
#define DBG_ACCESS_TYPE_SERVER_READ                         1
#define DBG_ACCESS_TYPE_SERVER_WRITE                        2
#define DBG_ACCESS_TYPE_SERVER_EXECUTE                      3
#define DBG_ACCESS_TYPE_PRINTER_ALL_ACCESS                  4
#define DBG_ACCESS_TYPE_PRINTER_READ                        5
#define DBG_ACCESS_TYPE_PRINTER_WRITE                       6
#define DBG_ACCESS_TYPE_PRINTER_EXECUTE                     7
#define DBG_ACCESS_TYPE_JOB_ALL_ACCESS                      8
#define DBG_ACCESS_TYPE_JOB_READ                            9
#define DBG_ACCESS_TYPE_JOB_WRITE                          10
#define DBG_ACCESS_TYPE_JOB_EXECUTE                        11
#define DBG_ACCESS_TYPE_PRINTER_ACCESS_USE                 12
#define DBG_ACCESS_TYPE_PRINTER_ACCESS_ADMINISTER          13
#define DBG_ACCESS_TYPE_SERVER_ACCESS_ENUMERATE            14
#define DBG_ACCESS_TYPE_SERVER_ACCESS_ADMINISTER           15
#define DBG_ACCESS_TYPE_JOB_ACCESS_ADMINISTER              16
#define DBG_ACCESS_TYPE_DELETE                             17
#define DBG_ACCESS_TYPE_WRITE_DAC                          18
#define DBG_ACCESS_TYPE_WRITE_OWNER                        19
#define DBG_ACCESS_TYPE_ACCESS_SYSTEM_SECURITY             20
// These two should come last:
#define DBG_ACCESS_TYPE_UNKNOWN                            21
#define DBG_ACCESS_TYPE_COUNT                              22

typedef struct _DBG_ACCESS_TYPE_MAPPING
{
    DWORD  Type;
    LPWSTR Name;
}
DBG_ACCESS_TYPE_MAPPING, *PDBG_ACCESS_TYPE_MAPPING;

DBG_ACCESS_TYPE_MAPPING DbgAccessTypeMapping[DBG_ACCESS_TYPE_COUNT] =
{
    {   SERVER_ALL_ACCESS,          L"SERVER_ALL_ACCESS"            },
    {   SERVER_READ,                L"SERVER_READ"                  },
    {   SERVER_WRITE,               L"SERVER_WRITE"                 },
    {   SERVER_EXECUTE,             L"SERVER_EXECUTE"               },
    {   PRINTER_ALL_ACCESS,         L"PRINTER_ALL_ACCESS"           },
    {   PRINTER_READ,               L"PRINTER_READ"                 },
    {   PRINTER_WRITE,              L"PRINTER_WRITE"                },
    {   PRINTER_EXECUTE,            L"PRINTER_EXECUTE"              },
    {   JOB_ALL_ACCESS,             L"JOB_ALL_ACCESS"               },
    {   JOB_READ,                   L"JOB_READ"                     },
    {   JOB_WRITE,                  L"JOB_WRITE"                    },
    {   JOB_EXECUTE,                L"JOB_EXECUTE"                  },
    {   PRINTER_ACCESS_USE,         L"PRINTER_ACCESS_USE"           },
    {   PRINTER_ACCESS_ADMINISTER,  L"PRINTER_ACCESS_ADMINISTER"    },
    {   SERVER_ACCESS_ENUMERATE,    L"SERVER_ACCESS_ENUMERATE"      },
    {   SERVER_ACCESS_ADMINISTER,   L"SERVER_ACCESS_ADMINISTER"     },
    {   JOB_ACCESS_ADMINISTER,      L"JOB_ACCESS_ADMINISTER"        },
    {   DELETE,                     L"DELETE"                       },
    {   WRITE_DAC,                  L"WRITE_DAC"                    },
    {   WRITE_OWNER,                L"WRITE_OWNER"                  },
    {   ACCESS_SYSTEM_SECURITY,     L"ACCESS_SYSTEM_SECURITY"       },
    {   0,                          L"UNKNOWN"                      }
};


LPWSTR DbgGetAccessTypeName( DWORD AccessType )
{
    PDBG_ACCESS_TYPE_MAPPING pMapping;
    DWORD                   i;

    pMapping = DbgAccessTypeMapping;
    i = 0;

    while( ( i < ( DBG_ACCESS_TYPE_COUNT - 1 ) ) && ( pMapping[i].Type != AccessType ) )
        i++;

    return pMapping[i].Name;
}

#endif /* DBG */


BOOL
BuildJobOwnerSecurityDescriptor(
    IN  HANDLE                hToken,
    OUT PSECURITY_DESCRIPTOR *ppSD
    );

VOID
DestroyJobOwnerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    );

BOOL
SetRequiredPrivileges(
    IN  HANDLE            TokenHandle,
    OUT PTOKEN_PRIVILEGES *ppPreviousTokenPrivileges,
    OUT PDWORD            pPreviousTokenPrivilegesLength
    );

BOOL
ResetRequiredPrivileges(
    IN HANDLE            TokenHandle,
    IN PTOKEN_PRIVILEGES pPreviousTokenPrivileges,
    IN DWORD             PreviousTokenPrivilegesLength
    );



PSECURITY_DESCRIPTOR
AllocateLocalSD(
    PSECURITY_DESCRIPTOR pSystemAllocatedSD
    );

DWORD
GetHackOutAce(
    PACL pDacl
    );

#define MAX_ACE 20


#if DBG

typedef struct _STANDARD_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    PSID Sid;
} STANDARD_ACE;
typedef STANDARD_ACE *PSTANDARD_ACE;

//
//  The following macros used by DumpAcl(), these macros and DumpAcl() are
//  stolen from private\ntos\se\ctaccess.c (written by robertre) for
//  debugging purposes.
//

//
//  Returns a pointer to the first Ace in an Acl (even if the Acl is empty).
//

#define FirstAce(Acl) ((PVOID)((LPBYTE)(Acl) + sizeof(ACL)))

//
//  Returns a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//

#define NextAce(Ace) ((PVOID)((LPBYTE)(Ace) + ((PACE_HEADER)(Ace))->AceSize))


VOID
DumpAcl(
    IN PACL Acl
    );

#endif //if DBG


/* Dummy access mask which will never be checked, but required
 * by the ACL editor, so that Document Properties is not undefined
 * for containers (i.e. printers).
 * This mask alone must not be used for any other ACE, since it
 * will be used to find the no-inherit ACE which propagates
 * onto printers.
 */
#define DUMMY_ACE_ACCESS_MASK   READ_CONTROL


/* CreateServerSecurityDescriptor
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
)
{
    DWORD ObjectType = SPOOLER_OBJECT_SERVER;
    NT_PRODUCT_TYPE NtProductType;
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    ACCESS_MASK AceMask[MAX_ACE];  // Access masks corresponding to Sids
    BYTE InheritFlags[MAX_ACE];  //
    UCHAR AceType[MAX_ACE];
    DWORD AceCount;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID WorldSid = NULL;
    PSID AdminsAliasSid = NULL;
    PSID PrintOpsAliasSid = NULL;
    PSID SystemOpsAliasSid = NULL;
    PSID PowerUsersAliasSid = NULL;
    PSID CreatorOwnerSid = NULL;
    PSECURITY_DESCRIPTOR ServerSD = NULL;
    BOOL OK;


    //
    // Printer SD
    //

    AceCount = 0;

    /* Creator-Owner SID: */

    OK = AllocateAndInitializeSid( &CreatorSidAuthority, 1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &CreatorOwnerSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }


    /* The following is a dummy ACE needed for the ACL editor.
     * Note this is a gross hack, and will result in two ACEs
     * being propagated onto printers when they are created,
     * one of which must be deleted.
     */
    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = CreatorOwnerSid;
    AceMask[AceCount]          = DUMMY_ACE_ACCESS_MASK;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = CreatorOwnerSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;


    /* World SID */

    OK = AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &WorldSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = SERVER_EXECUTE;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = GENERIC_EXECUTE;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
    AceCount++;


    /* Admins alias SID */

    OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &AdminsAliasSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = SERVER_ALL_ACCESS;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    AceCount++;

    OK = RtlGetNtProductType( &NtProductType );
    DBGCHK( !OK, ( "Couldn't get product type" ) );

    if ( !OK ) {
        goto CleanUp;
    }

    switch (NtProductType) {
    case NtProductLanManNt:
//    case NtProductMember:

        /* Print Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_PRINT_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &PrintOpsAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = SERVER_ALL_ACCESS;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        AceCount++;

        /* System Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &SystemOpsAliasSid );
        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = SERVER_ALL_ACCESS;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        AceCount++;

        break;

    case NtProductWinNt:
    default:

        {
            OSVERSIONINFOEX OsVersion = {0};

            OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);

            //
            // Whistler Personal does not have the Power Users group.
            //
            if (GetVersionEx((LPOSVERSIONINFO)&OsVersion) &&
                !(OsVersion.wProductType==VER_NT_WORKSTATION && OsVersion.wSuiteMask & VER_SUITE_PERSONAL)) {

                OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                               SECURITY_BUILTIN_DOMAIN_RID,
                                               DOMAIN_ALIAS_RID_POWER_USERS,
                                               0, 0, 0, 0, 0, 0,
                                               &PowerUsersAliasSid );


                DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );

                if ( !OK ) {
                    goto CleanUp;
                }

                AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
                AceSid[AceCount]           = PowerUsersAliasSid;
                AceMask[AceCount]          = SERVER_ALL_ACCESS;
                InheritFlags[AceCount]     = 0;
                AceCount++;

                AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
                AceSid[AceCount]           = PowerUsersAliasSid;
                AceMask[AceCount]          = GENERIC_ALL;
                InheritFlags[AceCount]     = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
                AceCount++;
            }
        }

        break;
    }

    DBGCHK( ( AceCount > MAX_ACE ), ( "ACE count exceeded" ) );

    if ( AceCount > MAX_ACE ) {
        goto CleanUp;
    }

    OK = BuildPrintObjectProtection( AceType,
                                     AceCount,
                                     AceSid,
                                     AceMask,
                                     InheritFlags,
                                     AdminsAliasSid,
                                     AdminsAliasSid,
                                     &GenericMapping[ObjectType],
                                     &ServerSD );

    DBGCHK( !OK, ( "BuildPrintObjectProtection failed" ) );

CleanUp:

    if (WorldSid) {
        FreeSid( WorldSid );
    }
    if (AdminsAliasSid) {
        FreeSid( AdminsAliasSid );
    }
    if (CreatorOwnerSid) {
        FreeSid( CreatorOwnerSid );
    }
    if (PrintOpsAliasSid) {
        FreeSid( PrintOpsAliasSid );
    }
    if (SystemOpsAliasSid) {
        FreeSid( SystemOpsAliasSid );
    }
    if (PowerUsersAliasSid) {
        FreeSid( PowerUsersAliasSid );
    }

    pServerSecurityDescriptor = ServerSD;

    return ServerSD;
}


/* CreatePrinterSecurityDescriptor
 *
 * Creates a default security descriptor for a printer by inheritance
 * of the access flags in the local spooler's security descriptor.
 * The resulting descriptor is allocated from the process' heap
 * and should be freed by DeletePrinterSecurityDescriptor.
 *
 * Argument: pCreatorSecurityDescriptor - if the creator supplies
 *     a security descriptor, this should point to it.  Otherwise
 *     it should be NULL.
 *
 * Return: The printer's security descriptor
 *
 */
PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
)
{
    HANDLE               ClientToken;
    PSECURITY_DESCRIPTOR pPrivateObjectSecurity;
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor;
    DWORD                ObjectType = SPOOLER_OBJECT_PRINTER;
    BOOL                 OK;
    HANDLE               hToken;
    BOOL                 DaclPresent;
    PACL                 pDacl;
    BOOL                 DaclDefaulted = FALSE;
    DWORD                HackOutAce;


    if( GetTokenHandle( &ClientToken ) )
    {
        hToken = RevertToPrinterSelf( );

        OK = CreatePrivateObjectSecurity( pServerSecurityDescriptor,
                                          pCreatorSecurityDescriptor,
                                          &pPrivateObjectSecurity,
                                          TRUE,     // This is a container
                                          ClientToken,
                                          &GenericMapping[ObjectType] );

        ImpersonatePrinterClient(hToken);

        CloseHandle(ClientToken);

        DBGCHK( !OK, ( "CreatePrivateObjectSecurity failed: Error %d", GetLastError() ) );

        if( !OK )
            return NULL;

        pPrinterSecurityDescriptor = pPrivateObjectSecurity;

        if( !pCreatorSecurityDescriptor )
        {
            GetSecurityDescriptorDacl( pPrinterSecurityDescriptor,
                                       &DaclPresent,
                                       &pDacl,
                                       &DaclDefaulted );



            /* HACK HACK HACK HACK HACK
             *
             * We defined an extra ACE for the benefit of the ACL editor.
             * This is container-inherit,
             * and we want it to propagate onto documents.
             * However, this means it will also propagate onto printers,
             * which we definitely don't want.
             */
            HackOutAce = GetHackOutAce( pDacl );

            if( HackOutAce != (DWORD)-1 )
                DeleteAce( pDacl, HackOutAce );


#if DBG
            if( MODULE_DEBUG & DBG_SECURITY ){
                DBGMSG( DBG_SECURITY, ( "Printer security descriptor DACL:\n" ));
                DumpAcl( pDacl );
            }
#endif /* DBG */
        }

    }
    else
    {
        OK = FALSE;
    }


    return ( OK ? pPrinterSecurityDescriptor : NULL );
}


/*
 *
 */
DWORD GetHackOutAce( PACL pDacl )
{
    DWORD               i;
    PACCESS_ALLOWED_ACE pAce;
    BOOL                OK = TRUE;

    i = 0;

    while( OK )
    {
        OK = GetAce( pDacl, i, (LPVOID *)&pAce );

        DBGCHK( !OK, ( "Failed to get ACE.  Error %d", GetLastError() ) );

        /* Find the dummy ace that isn't inherit-only:
         */
        if( OK && ( pAce->Mask == DUMMY_ACE_ACCESS_MASK )
          &&( !( pAce->Header.AceFlags & INHERIT_ONLY_ACE ) ) )
            return i;
    }

    return (DWORD)-1;
}


/* SetPrinterSecurityDescriptor
 *
 * Arguments:
 *
 *     SecurityInformation - Type of security information to be applied,
 *         typically DACL_SECURITY_INFORMATION.  (This is a 32-bit array.)
 *
 *     pModificationDescriptor - A pointer to a pointer to a security
 *         descriptor to be applied to the previous descriptor.
 *
 *     pObjectSecurityDescriptor - The previous descriptor which is to be
 *         modified.
 *
 *
 * Return:
 *
 *     Boolean indicating success or otherwise.
 *
 */
BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
)
{
    HANDLE  ClientToken;
    DWORD   ObjectType = SPOOLER_OBJECT_PRINTER;
    BOOL    OK = FALSE;
    HANDLE  hToken;

    if( GetTokenHandle( &ClientToken ) )
    {
        /* SetPrivateObjectSecurity should not be called when we are
        * impersonating a client, since it may need to allocate memory:
        */
        hToken = RevertToPrinterSelf( );

        OK = SetPrivateObjectSecurity( SecurityInformation,
                                       pModificationDescriptor,
                                       ppObjectsSecurityDescriptor,
                                       &GenericMapping[ObjectType],
                                       ClientToken );

        ImpersonatePrinterClient(hToken);

        DBGCHK( !OK, ( "SetPrivateObjectSecurity failed: Error %d", GetLastError() ) );

        CloseHandle(ClientToken);
    }

    return OK;
}


/* CreateDocumentSecurityDescriptor
 *
 * Creates a default security descriptor for a document by inheritance
 * of the access flags in the supplied printer security descriptor.
 * The resulting descriptor is allocated from the process' heap
 * and should be freed by DeleteDocumentSecurityDescriptor.
 *
 * Argument: The printer's security descriptor
 *
 * Return: The document's security descriptor
 *
 */
PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
)
{
    HANDLE               ClientToken;
    PSECURITY_DESCRIPTOR pPrivateObjectSecurity;
    PSECURITY_DESCRIPTOR pDocumentSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD                ObjectType = SPOOLER_OBJECT_DOCUMENT;
    BOOL                 OK = FALSE;
    HANDLE               hToken;

    if( GetTokenHandle( &ClientToken ) )
    {
        hToken = RevertToPrinterSelf( );

        //
        // The function CreateDocumentSecurityDescriptor does not preserve
        // the last error correctly. If CreatePrivateObjectSecurityEx fails,
        // it sets the last error. But after that,
        //
        OK = BuildJobOwnerSecurityDescriptor(ClientToken, &pSD) &&
             CreatePrivateObjectSecurityEx(pPrinterSecurityDescriptor,
                                           pSD,
                                           &pPrivateObjectSecurity,
                                           NULL,
                                           FALSE,    // This is not a container
                                           SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT,
                                           ClientToken,
                                           &GenericMapping[ObjectType] );

        DestroyJobOwnerSecurityDescriptor(pSD);

        ImpersonatePrinterClient(hToken);

        CloseHandle(ClientToken);

        DBGCHK( !OK, ( "CreatePrivateObjectSecurity failed: Error %d", GetLastError() ) );

        if( !OK )
            return NULL;

        pDocumentSecurityDescriptor = pPrivateObjectSecurity;

#if DBG
        if( MODULE_DEBUG & DBG_SECURITY )
        {
            BOOL DaclPresent;
            PACL pDacl;
            BOOL DaclDefaulted = FALSE;

            GetSecurityDescriptorDacl( pDocumentSecurityDescriptor,
                                       &DaclPresent,
                                       &pDacl,
                                       &DaclDefaulted );

            DBGMSG( DBG_SECURITY, ( "Document security descriptor DACL:\n" ));

            DumpAcl( pDacl );
        }
#endif /* DBG */

    }
    else
    {
        OK = FALSE;
    }

    return ( OK ? pDocumentSecurityDescriptor : NULL );
}


/*
 *
 */
BOOL DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
)
{
    BOOL OK;

    OK = DestroyPrivateObjectSecurity( &pIniPrinter->pSecurityDescriptor );
    pIniPrinter->pSecurityDescriptor = NULL;

    DBGCHK( !OK, ( "DestroyPrivateObjectSecurity failed.  Error %d", GetLastError() ) );

    return OK;
}


/*
 *
 */
BOOL DeleteDocumentSecurity(
    PINIJOB pIniJob
)
{
    BOOL OK;

    OK = DestroyPrivateObjectSecurity( &pIniJob->pSecurityDescriptor );

    DBGCHK( !OK, ( "DestroyPrivateObjectSecurity failed.  Error %d", GetLastError() ) );

    OK = ObjectCloseAuditAlarm( szSpooler, pIniJob,
                                pIniJob->GenerateOnClose );

    DBGCHK( !OK, ( "ObjectCloseAuditAlarm failed.  Error %d", GetLastError() ) );

    return OK;
}





#ifdef OLDSTUFF

/* AllocateLocalSD
 *
 * Makes a copy of a security descriptor, allocating it out of the local heap.
 * The source descriptor MUST be in self-relative format.
 *
 * Argument
 *
 *   pSourceSD - Pointer to a self-relative security descriptor
 *
 *
 * Returns
 *
 *   A pointer to a locally allocated security descriptor.
 *
 *   If the function fails to allocate the memory, NULL is returned.
 *
 * Note, if an invalid security descriptor is passed to
 * GetSecurityDescriptorLength, the return value is undefined,
 * therefore the caller should ensure that the source is valid.
 */
PSECURITY_DESCRIPTOR AllocateLocalSD( PSECURITY_DESCRIPTOR pSourceSD )
{
    DWORD                Length;
    PSECURITY_DESCRIPTOR pLocalSD;

    Length = GetSecurityDescriptorLength( pSourceSD );

    pLocalSD = AllocSplMem( Length );

    if( pLocalSD )
    {
        memcpy( pLocalSD, pSourceSD, Length );
    }

    return pLocalSD;
}

#endif /* OLDSTUFF */


//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



BOOL
BuildPrintObjectProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the print manager objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity)



Arguments:

    AceType - Array of AceTypes.
              Must be ACCESS_ALLOWED_ACE_TYPE or ACCESS_DENIED_ACE_TYPE.

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    InheritFlags - Pointer to an array of inherit flags.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.

    OwnerSid - The SID of the owner to be assigned to the descriptor.

    GroupSid - The SID of the group to be assigned to the descriptor.

    GenericMap - Points to a generic mapping for the target object type.

    ppSecurityDescriptor - Receives a pointer to the security descriptor.
        This will be allcated from the process' heap, not the spooler's,
        and should therefore be freed with LocalFree().


    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor

Return Value:

    TBS.

--*/
{



    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative = NULL;
    PACL                    TmpAcl= NULL;
    PACCESS_ALLOWED_ACE     TmpAce;
    DWORD                   SDLength;
    DWORD                   DaclLength;
    DWORD                   i;
    BOOL                    bReturn = FALSE;

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //

    if (InitializeSecurityDescriptor( &Absolute,
                                      SECURITY_DESCRIPTOR_REVISION1 ) &&

        SetSecurityDescriptorOwner( &Absolute, OwnerSid, FALSE ) &&

        SetSecurityDescriptorGroup( &Absolute, GroupSid, FALSE ) ) {

        //
        // Discretionary ACL
        //
        //      Calculate its length,
        //      Allocate it,
        //      Initialize it,
        //      Add each ACE
        //      Set ACE as InheritOnly if necessary
        //      Add it to the security descriptor
        //

        DaclLength = (DWORD)sizeof(ACL);
        for (i=0; i<AceCount; i++) {

            DaclLength += GetLengthSid( AceSid[i] ) +
                          (DWORD)sizeof(ACCESS_ALLOWED_ACE) -
                          (DWORD)sizeof(DWORD);  //Subtract out SidStart field length
        }

        TmpAcl = AllocSplMem( DaclLength );

        if (TmpAcl &&  InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 )) {

            BOOL bLoop = TRUE;
            for (i=0; bLoop && i < AceCount; i++)
            {
                if( AceType[i] == ACCESS_ALLOWED_ACE_TYPE ) {
                    bLoop = AddAccessAllowedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );
                } else {
                    bLoop = AddAccessDeniedAce ( TmpAcl, ACL_REVISION2, AceMask[i], AceSid[i] );
                }

                if (bLoop) {
                    if (InheritFlags[i] != 0)
                    {
                        if ( bLoop = GetAce( TmpAcl, i, (LPVOID *)&TmpAce )) {
                            TmpAce->Header.AceFlags = InheritFlags[i];
                        }
                    }
                }
            }

            if (bLoop) {
                #if DBG
                    DBGMSG( DBG_SECURITY, ( "Server security descriptor DACL:\n" ) );

                    DumpAcl(TmpAcl);
                #endif /* DBG */

                if (SetSecurityDescriptorDacl (&Absolute, TRUE, TmpAcl, FALSE )) {

                    //
                    // Convert the Security Descriptor to Self-Relative
                    //
                    //      Get the length needed
                    //      Allocate that much memory
                    //      Copy it
                    //      Free the generated absolute ACLs
                    //

                    SDLength = GetSecurityDescriptorLength( &Absolute );

                    Relative = LocalAlloc( 0, SDLength );

                    if (Relative) {
                        bReturn = MakeSelfRelativeSD(&Absolute, Relative, &SDLength );
                    }
                }
            }
        }
    }

    if (bReturn) {
        *ppSecurityDescriptor = Relative;
    } else {

        *ppSecurityDescriptor = NULL;
        if (Relative) {
            LocalFree(Relative);
        }
    }

    if (TmpAcl){
        FreeSplMem(TmpAcl);
    }

    return(bReturn);

}

/*++

Routine Name:

    ValidateObjectAccess

Routine Description:

    Validates whether the currently impersonated user has access to the given
    printer object or not.

Arguments:

    ObjectType      - SPOOLER_OBJECT_* value, which is an index into the global
                      mapping for spooler objects.
    DesiredAccess   - The type of access requested.
    ObjectHandle    - If ObjectType == SPOOLER_OBJECT_PRINTER, this must be a printer
                      handle, if SPOOLER_OBJECT_DOCUMENT, a pointer to a INIJOB
                      structure.  For SPOOLER_OBJECT_SERVER this is ignored.
    pGrantedAccess  - The access that we granted to the client.
    pIniSpooler     - The inispooler on which the obhect is located.

Return Value:

    TRUE if requested access is granted.


--*/
BOOL
ValidateObjectAccess(
    IN      DWORD               ObjectType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      LPVOID              ObjectHandle,
        OUT PACCESS_MASK        pGrantedAccess,
    IN      PINISPOOLER         pIniSpooler
    )
{
    BOOL    bRet            = FALSE;
    HANDLE  hClientToken    = NULL;

    bRet = GetTokenHandle(&hClientToken);

    if (bRet)
    {
        bRet = ValidateObjectAccessWithToken(hClientToken, ObjectType, DesiredAccess, ObjectHandle, pGrantedAccess, pIniSpooler);
    }
    else if (pGrantedAccess)
    {
        *pGrantedAccess = 0;
    }

    if (hClientToken)
    {
        CloseHandle(hClientToken);
    }

    return bRet;
}

BOOL
ValidateObjectAccessWithToken(
    IN      HANDLE              hClientToken,
    IN      DWORD               ObjectType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      LPVOID              ObjectHandle,
        OUT PACCESS_MASK        pGrantedAccess,
    IN      PINISPOOLER         pIniSpooler
    )
{
    LPWSTR               pObjectName;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PSPOOL               pSpool = NULL;
    PINIPRINTER          pIniPrinter;
    PINIJOB              pIniJob;
    BOOL                 AccessCheckOK;
    BOOL                 OK;
    BOOL                 AccessStatus = TRUE;
    ACCESS_MASK          MappedDesiredAccess;
    DWORD                GrantedAccess = 0;
    PBOOL                pGenerateOnClose;
    BYTE                 PrivilegeSetBuffer[256];
    DWORD                PrivilegeSetBufferLength = 256;
    PPRIVILEGE_SET       pPrivilegeSet;
    BOOL                 HackForNoImpersonationToken = FALSE;
    DWORD                dwRetCode;

    PTOKEN_PRIVILEGES pPreviousTokenPrivileges;
    DWORD PreviousTokenPrivilegesLength;

    //
    //  Some Print Providers may not require Security
    //

    if ( (pIniSpooler->SpoolerFlags & SPL_SECURITY_CHECK) == FALSE ) return TRUE;


    switch( ObjectType )
    {
    case SPOOLER_OBJECT_SERVER:
    case SPOOLER_OBJECT_XCV:
        if( ObjectHandle )
            pSpool = ObjectHandle;
        ObjectHandle = pIniSpooler;
        pObjectName = pIniSpooler->pMachineName;
        pSecurityDescriptor = pServerSecurityDescriptor;
        pGenerateOnClose = &ServerGenerateOnClose;
        break;

    case SPOOLER_OBJECT_PRINTER:
        pSpool = ObjectHandle;
        pIniPrinter = pSpool->pIniPrinter;
        pObjectName = pIniPrinter->pName;
        pSecurityDescriptor = pIniPrinter->pSecurityDescriptor;
        pGenerateOnClose = &pSpool->GenerateOnClose;
        break;

    case SPOOLER_OBJECT_DOCUMENT:
        pIniJob = (PINIJOB)ObjectHandle;
        pObjectName = pIniJob->pDocument;
        pSecurityDescriptor = pIniJob->pSecurityDescriptor;
        pGenerateOnClose = &pIniJob->GenerateOnClose;
        break;
    }

    MapGenericToSpecificAccess( ObjectType, DesiredAccess, &MappedDesiredAccess );

    if (MappedDesiredAccess & ACCESS_SYSTEM_SECURITY) {
        if (!SetRequiredPrivileges( hClientToken,
                                    &pPreviousTokenPrivileges,
                                    &PreviousTokenPrivilegesLength
                                    )) {

            if (pGrantedAccess) {
                *pGrantedAccess = 0;
            }

            return FALSE;
        }
    }

    pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;


    /* Call AccessCheck followed by ObjectOpenAuditAlarm rather than
     * AccessCheckAndAuditAlarm, because we may need to enable
     * SeSecurityPrivilege in order to check for ACCESS_SYSTEM_SECURITY
     * privilege.  We must ensure that the security access-checking
     * API has the actual token whose security privilege we have enabled.
     * AccessCheckAndAuditAlarm is no good for this, because it opens
     * the client's token again, which may not have the privilege enabled.
     */
    AccessCheckOK = AccessCheck( pSecurityDescriptor,
                                 hClientToken,
                                 MappedDesiredAccess,
                                 &GenericMapping[ObjectType],
                                 pPrivilegeSet,
                                 &PrivilegeSetBufferLength,
                                 &GrantedAccess,
                                 &AccessStatus );

    if (!AccessCheckOK) {

        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            DBGMSG(DBG_TRACE, ("No impersonation token.  Access will be granted.\n"));
            HackForNoImpersonationToken = TRUE;
            dwRetCode = ERROR_SUCCESS;
            GrantedAccess = MappedDesiredAccess;
        } else {
            dwRetCode = GetLastError();

        }
        pPrivilegeSet = NULL;
    } else {

        if (!AccessStatus) {

            dwRetCode = GetLastError();
        }
    }

    OK = ObjectOpenAuditAlarm( szSpooler,
                               ObjectHandle,
                               ObjectTypeName[ObjectType],
                               pObjectName,
                               pSecurityDescriptor,
                               hClientToken,
                               MappedDesiredAccess,
                               GrantedAccess,
                               pPrivilegeSet,
                               FALSE,  /* No new object creation */
                               AccessStatus,
                               pGenerateOnClose );


    if( MappedDesiredAccess & ACCESS_SYSTEM_SECURITY )
        ResetRequiredPrivileges( hClientToken,
                                 pPreviousTokenPrivileges,
                                 PreviousTokenPrivilegesLength );

    if( !pSpool )
        ObjectCloseAuditAlarm( szSpooler, ObjectHandle, *pGenerateOnClose );


    //
    // Allowing power users to install printer drivers or other dlls into the
    // trusted component base is a security hole. We now require that administrators
    // and power users have the load driver privilege present in the token in order
    // to be able to preform administrative tasks on the spooler. See bug 352856
    // for more details.
    //
    if (AccessCheckOK &&
        AccessStatus  &&
        ObjectType == SPOOLER_OBJECT_SERVER &&
        GrantedAccess & SERVER_ACCESS_ADMINISTER)
    {
        BOOL  bPrivPresent;
        DWORD Attributes;

        dwRetCode = CheckPrivilegePresent(hClientToken,
                                          &gLoadDriverPrivilegeLuid,
                                          &bPrivPresent,
                                          &Attributes);

        if (dwRetCode == ERROR_SUCCESS)
        {
            //
            // The reason why we check if the load driver privilege is present and
            // not present AND enabled is the following. Let's assume you have been
            // granted the privilege to load drivers.
            // When you logon on interactively SeLoadDriverPrivilege is enabled.
            // When you logon on via the secondary logon (runas which calls
            // CreateProcessWithLogonW) then the privilege is disabled. We do not want
            // to have inconsistent behavior regarding administering the spooler server.
            //
            if (!bPrivPresent)
            {
                //
                // The caller has been granted SERVER_ACCESS_ADMINISTER permission but
                // the caller doesn't have the privilege to load drivers. We do not
                // grant the desired access in this case.
                //
                GrantedAccess = 0;
                AccessStatus  = FALSE;
                dwRetCode     = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            //
            // We cannot determine if the privilege is held, so we need to fail
            // the AccessCheck function.
            //
            GrantedAccess = 0;
            AccessCheckOK = FALSE;
            dwRetCode     = GetLastError();
        }
    }

    if( pGrantedAccess )
        *pGrantedAccess = GrantedAccess;

    //
    // we do the setlasterror here because we may have failed the AccessCheck
    // or we succeeded but are denied access but the ObjectOpenAuditAlarm went
    // thru smoothly and now there is no error code to return on the function
    // so we specify the dwRetCode if we did fail.
    //

    if (!AccessCheckOK || !AccessStatus) {
        SetLastError(dwRetCode);
    }

    return ( ( OK && AccessCheckOK && AccessStatus ) || HackForNoImpersonationToken );
}


/* AccessGranted
 *
 * Checks whether the desired access is granted, by comparing the GrantedAccess
 * mask pointed to by pSpool.
 *
 * Parameters
 *
 *     ObjectType - SPOOLER_OBJECT_* value, which is an index into the global
 *         mapping for spooler objects.  This will not be SPOOLER_OBJECT_DOCUMENT,
 *         since we don't have document handles.  It could potentially be
 *         SPOOLER_OBJECT_SERVER.
 *
 *      DesiredAccess - The type of access requested.
 *
 *      pSpool - A pointer to the SPOOL structure
 *
 * Returns
 *
 *      TRUE - Access is granted
 *      FALSE - Access is not granted
 */
BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
)
{

    if ( (pSpool->pIniSpooler->SpoolerFlags & SPL_SECURITY_CHECK) == FALSE ) return TRUE;

    MapGenericMask( &DesiredAccess,
                    &GenericMapping[ObjectType] );

    return AreAllAccessesGranted( pSpool->GrantedAccess, DesiredAccess );
}


// Stolen from windows\base\username.c
// !!! Must close the handle that is returned
BOOL
GetTokenHandle(
    PHANDLE pTokenHandle
    )
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            // This means we are not impersonating anybody.
            // Instead, lets get the token out of the process.

            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                  pTokenHandle)) {

                return FALSE;
            }

        } else

            return FALSE;
    }

    return TRUE;
}



VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
    )
{
    *pSpecificAccess = GenericAccess;

    MapGenericMask( pSpecificAccess,
                    &GenericMapping[ObjectType] );
}


/* GetSecurityInformation
 *
 * Fills in the security information with a mask specifying the contents
 * of the security descriptor.
 *
 * Parameters
 *
 *     pSecurityDescriptor - A pointer to a security descriptor
 *         that the caller wishes to set.  This may be NULL.
 *
 *     pSecurityInformation - A pointer to a buffer to receive
 *         the security information flags.
 *
 *
 * Warning: This is an egregious hack.
 * We need to find out what is being set so we can verify the caller
 * has the required privileges.
 * There's no way an app like Print Manager can tell us what bits
 * of the security descriptor it wants to set.
 *
 * The following flags may be set:
 *
 *     OWNER_SECURITY_INFORMATION
 *     GROUP_SECURITY_INFORMATION
 *     DACL_SECURITY_INFORMATION
 *     SACL_SECURITY_INFORMATION
 *
 * Returns
 *
 *     TRUE - No errors occurred
 *     FALSE - An error occurred
 *
 */
BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
)
{
    SECURITY_INFORMATION SecurityInformation = 0;
    BOOL                 Defaulted;
    PSID                 pSidOwner;
    PSID                 pSidGroup;
    BOOL                 DaclPresent;
    PACL                 pDacl;
    BOOL                 SaclPresent;
    PACL                 pSacl;
    BOOL                 rc = TRUE;


    if( pSecurityDescriptor
      && IsValidSecurityDescriptor( pSecurityDescriptor ) )
    {
        if( GetSecurityDescriptorOwner( pSecurityDescriptor, &pSidOwner, &Defaulted )
         && GetSecurityDescriptorGroup( pSecurityDescriptor, &pSidGroup, &Defaulted )
         && GetSecurityDescriptorDacl( pSecurityDescriptor, &DaclPresent, &pDacl, &Defaulted )
         && GetSecurityDescriptorSacl( pSecurityDescriptor, &SaclPresent, &pSacl, &Defaulted ) )
        {
            if( pSidOwner )
                SecurityInformation |= OWNER_SECURITY_INFORMATION;
            if( pSidGroup )
                SecurityInformation |= GROUP_SECURITY_INFORMATION;
            if( DaclPresent )
                SecurityInformation |= DACL_SECURITY_INFORMATION;
            if( SaclPresent )
                SecurityInformation |= SACL_SECURITY_INFORMATION;
        }

        else
            rc = FALSE;
    }else {
        DBGMSG(DBG_TRACE, ("Either NULL  pSecurityDescriptor or !IsValidSecurityDescriptor %.8x\n", pSecurityDescriptor));
        rc = FALSE;
    }
    DBGMSG( DBG_TRACE, ("GetSecurityInformation returns %d with  SecurityInformation = %08x\n", rc, SecurityInformation) );

    *pSecurityInformation = SecurityInformation;

    return rc;
}


/* GetPrivilegeRequired
 *
 * Returns a mask containing the privileges required to set the specified
 * security information.
 *
 * Parameter
 *
 *     SecurityInformation - Flags specifying the security information
 *         that the caller wishes to set.  This may be 0.
 *
 * Returns
 *
 *     An access mask specifying the privileges required.
 *
 */
ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
)
{
    ACCESS_MASK PrivilegeRequired = 0;

    if( SecurityInformation & OWNER_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_OWNER;
    if( SecurityInformation & GROUP_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_OWNER;
    if( SecurityInformation & DACL_SECURITY_INFORMATION )
        PrivilegeRequired |= WRITE_DAC;
    if( SecurityInformation & SACL_SECURITY_INFORMATION )
        PrivilegeRequired |= ACCESS_SYSTEM_SECURITY;

    return PrivilegeRequired;
}


/* BuildPartialSecurityDescriptor
 *
 * Creates a copy of the source security descriptor, omitting those
 * parts of the descriptor which the AccessGranted mask doesn't give
 * read access to.
 *
 * Parameters
 *
 *     AccessMask - Defines the permissions held by the client.
 *         This may include READ_CONTROL or ACCESS_SYSTEM_SECURITY.
 *
 *     pSourceSecurityDescriptor - A pointer to the security descriptor
 *         upon which the partial security descriptor will be based.
 *         Its Owner, Group, DACL and SACL will be copied appropriately,
 *
 *     ppPartialSecurityDescriptor - A pointer to a variable which
 *         will receive the address of the newly created descriptor.
 *         If the AccessMask parameter contains neither READ_CONTROL
 *         nor ACCESS_SYSTEM_SECURITY, the descriptor will be empty.
 *         The descriptor will be in  self-relative format, and must
 *         be freed by the caller using FreeSplMem().
 *
 *     pPartialSecurityDescriptorLength - A pointer to a variable
 *         to receive the length of the security descriptor.
 *         This should be passed as the second parameter to FreeSplMem()
 *         when the descriptor is freed.
 *
 * Returns
 *
 *     TRUE - No error was detected
 *     FALSE - An error was detected
 *
 */
BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
)
{
    SECURITY_DESCRIPTOR AbsolutePartialSecurityDescriptor;
    BOOL Defaulted = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    BOOL DaclPresent = FALSE;
    PACL pDacl = NULL;
    BOOL SaclPresent = FALSE;
    PACL pSacl = NULL;
    BOOL ErrorOccurred = FALSE;
    DWORD Length = 0;
    PSECURITY_DESCRIPTOR pSelfRelativePartialSecurityDescriptor = NULL;

    /* When we've initialized the security descriptor,
     * it will have no owner, no primary group, no DACL and no SACL:
     */
    if( InitializeSecurityDescriptor( &AbsolutePartialSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION1 ) )
    {
        /* If the caller has READ_CONTROL permission,
         * set the Owner, Group and DACL:
         */
        if( AreAllAccessesGranted( AccessGranted, READ_CONTROL ) )
        {
            if( GetSecurityDescriptorOwner( pSourceSecurityDescriptor,
                                            &pOwnerSid, &Defaulted ) )
                SetSecurityDescriptorOwner( &AbsolutePartialSecurityDescriptor,
                                            pOwnerSid, Defaulted );
            else
                ErrorOccurred = TRUE;

            if( GetSecurityDescriptorGroup( pSourceSecurityDescriptor,
                                            &pGroupSid, &Defaulted ) )
                SetSecurityDescriptorGroup( &AbsolutePartialSecurityDescriptor,
                                            pGroupSid, Defaulted );
            else
                ErrorOccurred = TRUE;

            if( GetSecurityDescriptorDacl( pSourceSecurityDescriptor,
                                           &DaclPresent, &pDacl, &Defaulted ) )
                SetSecurityDescriptorDacl( &AbsolutePartialSecurityDescriptor,
                                           DaclPresent, pDacl, Defaulted );
            else
                ErrorOccurred = TRUE;
        }

        /* If the caller has ACCESS_SYSTEM_SECURITY permission,
         * set the SACL:
         */
        if( AreAllAccessesGranted( AccessGranted, ACCESS_SYSTEM_SECURITY ) )
        {
            if( GetSecurityDescriptorSacl( pSourceSecurityDescriptor,
                                           &SaclPresent, &pSacl, &Defaulted ) )
                SetSecurityDescriptorSacl( &AbsolutePartialSecurityDescriptor,
                                           SaclPresent, pSacl, Defaulted );
            else
                ErrorOccurred = TRUE;
        }

        if( !ErrorOccurred )
        {
            Length = 0;

            if( !MakeSelfRelativeSD( &AbsolutePartialSecurityDescriptor,
                                     pSelfRelativePartialSecurityDescriptor,
                                     &Length ) )
            {
                if( GetLastError( ) == ERROR_INSUFFICIENT_BUFFER )
                {
                    pSelfRelativePartialSecurityDescriptor = AllocSplMem( Length );

                    if( !pSelfRelativePartialSecurityDescriptor
                     || !MakeSelfRelativeSD( &AbsolutePartialSecurityDescriptor,
                                             pSelfRelativePartialSecurityDescriptor,
                                             &Length ) )
                    {
                        ErrorOccurred = TRUE;
                    }
                }

                else
                {
                    ErrorOccurred = TRUE;

                    DBGMSG(DBG_WARNING, ("MakeSelfRelativeSD failed: Error %d\n",
                                         GetLastError()));
                }
            }
            else
            {
                DBGMSG(DBG_WARNING, ("Expected MakeSelfRelativeSD to fail!\n"));
            }
        }
    }

    else
        ErrorOccurred = TRUE;


    if( !ErrorOccurred )
    {
        *ppPartialSecurityDescriptor = pSelfRelativePartialSecurityDescriptor;
        *pPartialSecurityDescriptorLength = Length;
    }

    return !ErrorOccurred;
}






BOOL
SetRequiredPrivileges(
    IN  HANDLE            TokenHandle,
    OUT PTOKEN_PRIVILEGES *ppPreviousTokenPrivileges,
    OUT PDWORD            pPreviousTokenPrivilegesLength
    )
/*++


Routine Description:

Arguments:

    TokenHandle - A token associated with the current thread or process

    ppPreviousTokenPrivileges - This will be filled with the address of the
        buffer allocated to hold the previously existing privileges for this
        process or thread.

    pPreviousTokenPrivilegesLength - This will be filled with the length of the
        buffer allocated.

Return Value:

    TRUE if successful.


--*/
{
    /* Make enough room for TOKEN_PRIVILEGES with an array of 2 Privileges
     * (there's 1 by default):
     */
#define PRIV_SECURITY   0
#define PRIV_COUNT      1

    LUID              SecurityValue;

    BYTE              TokenPrivilegesBuffer[ sizeof( TOKEN_PRIVILEGES ) +
                                             ( ( PRIV_COUNT - 1 ) *
                                               sizeof( LUID_AND_ATTRIBUTES ) ) ];
    PTOKEN_PRIVILEGES pTokenPrivileges;
    DWORD             FirstTryBufferLength = 256;
    DWORD             BytesNeeded;

    //
    // First, assert Audit privilege
    //

    memset( &SecurityValue, 0, sizeof SecurityValue );

    if( !LookupPrivilegeValue( NULL, SE_SECURITY_NAME, &SecurityValue ) )
    {
        DBGMSG( DBG_WARNING,
                ( "LookupPrivilegeValue failed: Error %d\n", GetLastError( ) ) );
        return FALSE;
    }

    /* Allocate a buffer of a reasonable length to hold the current privileges,
     * so we can restore them later:
     */
    *pPreviousTokenPrivilegesLength = FirstTryBufferLength;
    if( !( *ppPreviousTokenPrivileges = AllocSplMem( FirstTryBufferLength ) ) )
        return FALSE;

    memset( &TokenPrivilegesBuffer, 0, sizeof TokenPrivilegesBuffer );
    pTokenPrivileges = (PTOKEN_PRIVILEGES)&TokenPrivilegesBuffer;

    /*
     * Set up the privilege set we will need
     */
    pTokenPrivileges->PrivilegeCount = PRIV_COUNT;
    pTokenPrivileges->Privileges[PRIV_SECURITY].Luid = SecurityValue;
    pTokenPrivileges->Privileges[PRIV_SECURITY].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                pTokenPrivileges,
                                *pPreviousTokenPrivilegesLength,
                                *ppPreviousTokenPrivileges,
                                &BytesNeeded )) {

        if( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            *pPreviousTokenPrivilegesLength = BytesNeeded;
            *ppPreviousTokenPrivileges = ReallocSplMem(
                                             *ppPreviousTokenPrivileges,
                                             0,
                                             *pPreviousTokenPrivilegesLength );

            if( *ppPreviousTokenPrivileges )
            {
                if (!AdjustTokenPrivileges( TokenHandle,
                                            FALSE,
                                            pTokenPrivileges,
                                            *pPreviousTokenPrivilegesLength,
                                            *ppPreviousTokenPrivileges,
                                            &BytesNeeded )) {

                    DBGMSG( DBG_WARNING, ("AdjustTokenPrivileges failed: Error %d\n", GetLastError()));
                    goto Fail;
                }
            }
            else
            {
                *pPreviousTokenPrivilegesLength = 0;
                goto Fail;
            }

        }
        else
        {
            DBGMSG( DBG_WARNING, ("AdjustTokenPrivileges failed: Error %d\n", GetLastError()));
            goto Fail;
        }
    }

    return TRUE;

Fail:
    if (*ppPreviousTokenPrivileges) {

        FreeSplMem(*ppPreviousTokenPrivileges);
    }
    return FALSE;
}


BOOL
ResetRequiredPrivileges(
    IN HANDLE            TokenHandle,
    IN PTOKEN_PRIVILEGES pPreviousTokenPrivileges,
    IN DWORD             PreviousTokenPrivilegesLength
    )
/*++


Routine Description:

Arguments:

    TokenHandle - A token associated with the current thread or process

    pPreviousTokenPrivileges - The address of the buffer holding the previous
        privileges to be reinstated.

    PreviousTokenPrivilegesLength - Length of the buffer for deallocation.

Return Value:

    TRUE if successful.


--*/
{
    BOOL OK;

    OK = AdjustTokenPrivileges ( TokenHandle,
                                 FALSE,
                                 pPreviousTokenPrivileges,
                                 0,
                                 NULL,
                                 NULL );

    FreeSplMem( pPreviousTokenPrivileges );

    return OK;
}



/* CreateEverybodySecurityDescriptor
 *
 * Creates a security descriptor giving everyone access
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
#undef  MAX_ACE
#define MAX_ACE 5
#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
)
{
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    DWORD AceCount;
    //
    // For Code optimization we replace 5 individaul
    // SID_IDENTIFIER_AUTHORITY with an array of
    // SID_IDENTIFIER_AUTHORITYs
    // where
    // SidAuthority[0] = UserSidAuthority
    // SidAuthority[1] = PowerSidAuthority
    // SidAuthority[2] = CreatorSidAuthority
    // SidAuthority[3] = SystemSidAuthority
    // SidAuthority[4] = AdminSidAuthority
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority[MAX_ACE] = {
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_CREATOR_SID_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY,
                                                      SECURITY_NT_AUTHORITY
                                                     };
    //
    // For code optimization we replace 5 individual Sids with
    // an array of Sids
    // where
    // Sid[0] = UserSid
    // Sid[1] = PowerSid
    // Sid[2] = CreatorSid
    // Sid[3] = SystemSid
    // Sid[4] = AdminSid
    //
    PSID Sids[MAX_ACE] = {NULL,NULL,NULL,NULL,NULL};
    //
    // Access masks corresponding to Sids
    //
    ACCESS_MASK AceMask[MAX_ACE] = {
                                     (FILE_GENERIC_EXECUTE | SYNCHRONIZE | FILE_GENERIC_WRITE | FILE_GENERIC_READ) &
                                     ~READ_CONTROL & ~FILE_WRITE_ATTRIBUTES &
                                     ~FILE_WRITE_EA&~FILE_READ_DATA&~FILE_LIST_DIRECTORY ,
                                     (FILE_GENERIC_EXECUTE | SYNCHRONIZE | FILE_GENERIC_WRITE | FILE_GENERIC_READ) &
                                     ~READ_CONTROL & ~FILE_WRITE_ATTRIBUTES &
                                     ~FILE_WRITE_EA&~FILE_READ_DATA&~FILE_LIST_DIRECTORY ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE |
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE |
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                     STANDARD_RIGHTS_ALL | FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE |
                                     FILE_GENERIC_READ | FILE_ALL_ACCESS ,
                                   };
    //
    // SubAuthorities leading to the proper Group
    //
    DWORD SubAuthorities[3*MAX_ACE] = {
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_USERS ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_POWER_USERS ,
                                       1 , SECURITY_CREATOR_OWNER_RID  , 0 ,
                                       1 , SECURITY_LOCAL_SYSTEM_RID   , 0 ,
                                       2 , SECURITY_BUILTIN_DOMAIN_RID , DOMAIN_ALIAS_RID_ADMINS
                                      };

    //
    // CONTAINER_INHERIT_ACE -> This folder and subfolders
    // OBJECT_INHERIT_ACE -> Files
    //
    BYTE InheritFlags[MAX_ACE] = {
                                   CONTAINER_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                   CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
                                 };


    PSECURITY_DESCRIPTOR ServerSD = NULL;

    //
    // Printer SD
    //


    for(AceCount = 0;
        ( (AceCount < MAX_ACE) &&
          AllocateAndInitializeSid(&SidAuthority[AceCount],
                                   (BYTE)SubAuthorities[AceCount*3],
                                   SubAuthorities[AceCount*3+1],
                                   SubAuthorities[AceCount*3+2],
                                   0, 0, 0, 0, 0, 0,
                                   &Sids[AceCount]));
        AceCount++)
    {
        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = Sids[AceCount];
    }

    if(AceCount == MAX_ACE)
    {
        if(!BuildPrintObjectProtection( AceType,
                                        AceCount,
                                        AceSid,
                                        AceMask,
                                        InheritFlags,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ServerSD ) )
        {
            DBGMSG( DBG_WARNING,( "Couldn't buidl Print Object protection" ) );
            ServerSD = NULL;
        }
    }
    else
    {
        DBGMSG( DBG_WARNING,( "Couldn't Allocate and initialize SIDs" ) );
    }

    for(AceCount=0;AceCount<MAX_ACE;AceCount++)
    {
        if(Sids[AceCount])
            FreeSid( Sids[AceCount] );
    }
    return ServerSD;
}



/* CreateDriversShareSecurityDescriptor
 *
 * Creates a security descriptor for the drivers$ share.
 * This reflects the security descriptor applied to the print server,
 * in that Everyone is given GENERIC_READ | GENERIC_EXECUTE,
 * and everyone with SERVER_ACCESS_ADMINISTER (Administrators,
 * Power Users etc.) is given GENERIC_ALL access to the share,
 *
 * If in future releases we support changes to the print server
 * security descriptor (e.g. allowing the ability to deny
 * SERVER_ACCESS_ENUMERATE), this routine will have to become more
 * sophisticated, as the access to the share will probably need
 * to be modified accordingly.
 *
 * Arguments: None
 *
 * Return: The security descriptor returned by BuildPrintObjectProtection.
 *
 */
#undef  MAX_ACE
#define MAX_ACE 20
#define DBGCHK( Condition, ErrorInfo ) \
    if( Condition ) DBGMSG( DBG_WARNING, ErrorInfo )

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
)
{
    DWORD ObjectType = SPOOLER_OBJECT_SERVER;
    NT_PRODUCT_TYPE NtProductType;
    PSID AceSid[MAX_ACE];          // Don't expect more than MAX_ACE ACEs in any of these.
    ACCESS_MASK AceMask[MAX_ACE];  // Access masks corresponding to Sids
    BYTE InheritFlags[MAX_ACE];  //
    UCHAR AceType[MAX_ACE];
    DWORD AceCount;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID WorldSid = NULL;
    PSID AdminsAliasSid = NULL;
    PSID PrintOpsAliasSid = NULL;
    PSID SystemOpsAliasSid = NULL;
    PSID PowerUsersAliasSid = NULL;
    PSID CreatorOwnerSid = NULL;
    PSECURITY_DESCRIPTOR pDriversShareSD = NULL;
    BOOL OK;


    //
    // Printer SD
    //

    AceCount = 0;

    /* Creator-Owner SID: */

    OK = AllocateAndInitializeSid( &CreatorSidAuthority, 1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &CreatorOwnerSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }

    /* World SID */

    OK = AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &WorldSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }


    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = WorldSid;
    AceMask[AceCount]          = GENERIC_READ | GENERIC_EXECUTE;
    InheritFlags[AceCount]     = 0;
    AceCount++;

    /* Admins alias SID */

    OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &AdminsAliasSid );

    DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
    if ( !OK ) {
        goto CleanUp;
    }


    AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[AceCount]           = AdminsAliasSid;
    AceMask[AceCount]          = GENERIC_ALL;
    InheritFlags[AceCount]     = 0;
    AceCount++;


    OK = RtlGetNtProductType( &NtProductType );
    DBGCHK( !OK, ( "Couldn't get product type" ) );

    if (NtProductType == NtProductLanManNt) {

        /* Print Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_PRINT_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &PrintOpsAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PrintOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

        /* System Ops alias SID */

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                       0, 0, 0, 0, 0, 0,
                                       &SystemOpsAliasSid );
        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = SystemOpsAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

    } else {

        //
        // LanManNT product
        //

        OK = AllocateAndInitializeSid( &NtAuthority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_POWER_USERS,
                                       0, 0, 0, 0, 0, 0,
                                       &PowerUsersAliasSid );

        DBGCHK( !OK, ( "Couldn't Allocate and initialize SID" ) );
        if ( !OK ) {
            goto CleanUp;
        }

        AceType[AceCount]          = ACCESS_ALLOWED_ACE_TYPE;
        AceSid[AceCount]           = PowerUsersAliasSid;
        AceMask[AceCount]          = GENERIC_ALL;
        InheritFlags[AceCount]     = 0;
        AceCount++;

    }


    DBGCHK( ( AceCount > MAX_ACE ), ( "ACE count exceeded" ) );


    OK = BuildPrintObjectProtection( AceType,
                                     AceCount,
                                     AceSid,
                                     AceMask,
                                     InheritFlags,
                                     AdminsAliasSid,
                                     AdminsAliasSid,
                                     &GenericMapping[ObjectType],
                                     &pDriversShareSD );

CleanUp:

    if (WorldSid) {
        FreeSid( WorldSid );
    }
    if (AdminsAliasSid) {
        FreeSid( AdminsAliasSid );
    }
    if (CreatorOwnerSid) {
        FreeSid( CreatorOwnerSid );
    }
    if (PrintOpsAliasSid) {
        FreeSid( PrintOpsAliasSid );
    }
    if (SystemOpsAliasSid) {
        FreeSid( SystemOpsAliasSid );
    }
    if (PowerUsersAliasSid) {
        FreeSid( PowerUsersAliasSid );
    }

    return pDriversShareSD;
}



#if DBG

VOID
DumpAcl(
    IN PACL Acl
    )
/*++

Routine Description:

    This routine dumps via (NetpDbgPrint) an Acl for debug purposes.  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/
{
    DWORD i;
    PSTANDARD_ACE Ace;

    if( MODULE_DEBUG & DBG_SECURITY ) {

        DBGMSG( DBG_SECURITY, ( " DumpAcl @%08lx\n", Acl ));

        //
        //  Check if the Acl is null
        //

        if (Acl == NULL) {
            return;
        }

        //
        //  Dump the Acl header
        //

        DBGMSG( DBG_SECURITY,
                ( " Revision: %02x, Size: %04x, AceCount: %04x\n",
                  Acl->AclRevision, Acl->AclSize, Acl->AceCount ));

        //
        //  Now for each Ace we want do dump it
        //

        for (i = 0, Ace = FirstAce(Acl);
             i < Acl->AceCount;
             i++, Ace = NextAce(Ace) ) {

            //
            //  print out the ace header
            //

            DBGMSG( DBG_SECURITY, ( " AceHeader: %08lx\n", *(PDWORD)Ace ));

            //
            //  special case on the standard ace types
            //

            if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

                //
                //  The following array is indexed by ace types and must
                //  follow the allowed, denied, audit, alarm seqeuence
                //

                static LPSTR AceTypes[] = { "Access Allowed",
                                            "Access Denied ",
                                            "System Audit  ",
                                            "System Alarm  "
                                           };

                DBGMSG( DBG_SECURITY,
                        ( " %s Access Mask: %08lx\n",
                          AceTypes[Ace->Header.AceType], Ace->Mask ));

            } else {

                DBGMSG( DBG_SECURITY, (" Unknown Ace Type\n" ));

            }

            DBGMSG( DBG_SECURITY,
                    ( " AceSize = %d\n AceFlags = ", Ace->Header.AceSize ));

            if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " OBJECT_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }
            if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " CONTAINER_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
                DBGMSG( DBG_SECURITY, ( " NO_PROPAGATE_INHERIT_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
                DBGMSG( DBG_SECURITY, ( " INHERIT_ONLY_ACE\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
                DBGMSG( DBG_SECURITY, ( " SUCCESSFUL_ACCESS_ACE_FLAG\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
                DBGMSG( DBG_SECURITY, ( " FAILED_ACCESS_ACE_FLAG\n" ));
                DBGMSG( DBG_SECURITY, ( "            " ));
            }

            DBGMSG( DBG_SECURITY, ( "\n" ));

        }
    }

}

#endif // if DBG


/*++

Routine Name

    BuildJobOwnerSecurityDescriptor

Routine Description:

    This routine builds a SD that will be passed as CreatorDescriptor argument to
    CreatePrivateObjectSecurityEx. The SD on any new job will be created using
    the SD returned by this function and will inherit from the SD from the print
    queue.

    BuildJobOwnerSecurityDescriptor --> SD      Print queue SD
                                         \     /
                                          \   / Inheritance
                                           \ /
                                          Job SD

    The SD created in this function will have as owner the user from the
    hToken argument. (The user impersonated by the thread from where we have the
    hToken). The ACL grants full access on the job to the local system.

    The reason why we need this special SD is the following. If you remove the
    creatorowner from the print queue SD and no user has manage docs permissions
    CreatePrivateObjectSecurity won't find any inheritable ACEs in the parent.
    Thus it grants full permissions to the owner and to the local system. This
    leads to a random behavior where according to the UI the user should not be
    able to manage his docs, but the SD on the job will grant manage docs rights.

    We don't want that. We want the local system to have full privileges on the job
    and the user who submitted the job should be granted permissions only if:
    - the user has manage doc rights
    - creator owner is present in the print queue SD

Arguments:

    hToken - impersonation token of the user who creates a new job
    ppSD   - pointer to recieve SD

Return Value:

    Win32 error code

--*/
BOOL
BuildJobOwnerSecurityDescriptor(
    IN  HANDLE                hToken,
    OUT PSECURITY_DESCRIPTOR *ppSD
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (hToken && ppSD)
    {
        PVOID  pUserInfo  = NULL;
        DWORD  cbUserInfo = 0;

        //
        // Get the owner from the thread token
        //
        Error = GetTokenInformation(hToken,
                                    TokenUser,
                                    NULL,
                                    0,
                                    &cbUserInfo) ? ERROR_SUCCESS : GetLastError();

        //
        // Allocate buffer and try getting the owner again
        //
        if (Error == ERROR_INSUFFICIENT_BUFFER)
        {
            if (pUserInfo = AllocSplMem(cbUserInfo))
            {
                Error = GetTokenInformation(hToken,
                                            TokenUser,
                                            pUserInfo,
                                            cbUserInfo,
                                            &cbUserInfo) ? ERROR_SUCCESS : GetLastError();

                //
                // Build the SD. We grant read control to the owner of the job
                //
                if (Error == ERROR_SUCCESS)
                {
                    DWORD       ObjectType = SPOOLER_OBJECT_DOCUMENT;
                    PSID        AceSid[2];
                    ACCESS_MASK AceMask[2];
                    BYTE        InheritFlags[2];
                    UCHAR       AceType[2];
                    DWORD       AceCount = 0;
                    PSID        pUserSid;

                    pUserSid               = ((((TOKEN_USER *)pUserInfo)->User)).Sid;

                    AceType[AceCount]      = ACCESS_ALLOWED_ACE_TYPE;
                    AceSid[AceCount]       = ((((TOKEN_USER *)pUserInfo)->User)).Sid;
                    AceMask[AceCount]      = JOB_READ;
                    InheritFlags[AceCount] = 0;
                    AceCount++;

                    AceType[AceCount]      = ACCESS_ALLOWED_ACE_TYPE;
                    AceSid[AceCount]       = pLocalSystemSid;
                    AceMask[AceCount]      = JOB_ALL_ACCESS;
                    InheritFlags[AceCount] = 0;
                    AceCount++;

                    Error = BuildPrintObjectProtection(AceType,
                                                       AceCount,
                                                       AceSid,
                                                       AceMask,
                                                       InheritFlags,
                                                       pUserSid,
                                                       NULL,
                                                       &GenericMapping[ObjectType],
                                                       ppSD) ? ERROR_SUCCESS : GetLastError();

                }

                FreeSplMem(pUserInfo);
            }
            else
            {
                Error = GetLastError();
            }
        }
    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}
/*++

Routine Name

    DestroyJobOwnerSecurityDescriptor

Routine Description:

    This routine frees a SD allocated by CreatejobOwnerSecurityDescriptor

Arguments:

    pSD   - pointer to SD

Return Value:

    None

--*/
VOID
DestroyJobOwnerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    if (pSD)
    {
        LocalFree(pSD);
    }
}

/*++

Routine Name

    InitializeSecurityStructures

Routine Description:

    This routine initializes security structures.

Arguments:

    None

Return Value:

    TRUE  - function succeeded
    FALSE - function failed, GetLastError() returns the reason

--*/
BOOL
InitializeSecurityStructures(
    VOID
    )
{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    return !!CreateServerSecurityDescriptor() &&
           LookupPrivilegeValue(NULL,
                                SE_LOAD_DRIVER_NAME,
                                &gLoadDriverPrivilegeLuid) &&
           AllocateAndInitializeSid(&NtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pLocalSystemSid) &&
           AllocateAndInitializeSid(&NtAuthority,
                                    1,
                                    SECURITY_NETWORK_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pNetworkLogonSid) &&
           AllocateAndInitializeSid(&NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_GUESTS,
                                    0, 0, 0, 0, 0, 0,
                                    &pGuestsSid);
}

/*++

Routine Name

    PrincipalIsRemoteGuest

Routine Description:

    This routine checks whether remote guest is present in a token.
    Remote guest = network + guest

Arguments:

    hToken - handle to token, NULL is ok (see CheckTokenMemberShip)
    pbRemoteGuest - pointer to receive BOOL. true means remote guest

Return Value:

    ERROR_SUCCESS - pbRemoteGuest is reliable
    other win32 error code, do not use pbRemoteGuest

--*/
DWORD
PrincipalIsRemoteGuest(
    IN  HANDLE  hToken,
    OUT BOOL   *pbRemoteGuest
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pbRemoteGuest)
    {
        BOOL bNetwork = FALSE;
        BOOL bGuests  = FALSE;

        if (CheckTokenMembership(hToken, pNetworkLogonSid, &bNetwork) &&
            CheckTokenMembership(hToken, pGuestsSid,       &bGuests))
        {
            *pbRemoteGuest = bNetwork && bGuests;

            Error = ERROR_SUCCESS;
        }
        else
        {
            *pbRemoteGuest = FALSE;

            Error = GetLastError();
        }
    }

    return Error;
}

/*++

Routine Name

    CheckPrivilegePresent

Routine Description:

    This routine checks if a certain privilege is present in a token

Arguments:

    hToken      - thread or process token
    pLuid       - pointer to luid for the privilege to be searched for
    pbPresent   - will be set to true is the privilege is present in the token
    pAttributes - will be set to the attributes of the privilege. It is a mask
                  indicating if the privilege is disabled, enabled, enabled by
                  default.

Return Value:

    ERROR_SUCCESS - the function executed successfully and the caller can use
                    pbPresent and pAttributes
    other Win32 error

--*/
DWORD
CheckPrivilegePresent(
    IN HANDLE   hToken,
    IN PLUID    pLuid,
    IN LPBOOL   pbPresent,
    IN LPDWORD  pAttributes OPTIONAL
    )
{
    DWORD  Error      = ERROR_INVALID_PARAMETER;
    PVOID  pPrivInfo  = NULL;
    DWORD  cbPrivInfo = kGuessTokenPrivileges;

    if (pLuid && pbPresent)
    {
        *pbPresent = FALSE;

        pPrivInfo = AllocSplMem(cbPrivInfo);

        Error = pPrivInfo ? ERROR_SUCCESS : GetLastError();

        if (Error == ERROR_SUCCESS)
        {
            Error = GetTokenInformation(hToken,
                                        TokenPrivileges,
                                        pPrivInfo,
                                        cbPrivInfo,
                                        &cbPrivInfo) ? ERROR_SUCCESS : GetLastError();
        }

        //
        // Reallocate buffer and try getting the privileges
        //
        if (Error == ERROR_INSUFFICIENT_BUFFER)
        {
            FreeSplMem(pPrivInfo);

            pPrivInfo = AllocSplMem(cbPrivInfo);

            Error = pPrivInfo ? ERROR_SUCCESS : GetLastError();

            if (Error == ERROR_SUCCESS)
            {
                Error = GetTokenInformation(hToken,
                                            TokenPrivileges,
                                            pPrivInfo,
                                            cbPrivInfo,
                                            &cbPrivInfo) ? ERROR_SUCCESS : GetLastError();
            }
        }

        if (Error == ERROR_SUCCESS)
        {
            TOKEN_PRIVILEGES *pTokenPrivileges = (TOKEN_PRIVILEGES *)pPrivInfo;
            DWORD             uCount;

            //
            // Search the privilege in the list of privileges present in the token
            //
            for (uCount = 0; uCount < pTokenPrivileges->PrivilegeCount; uCount++)
            {
                if (pTokenPrivileges->Privileges[uCount].Luid.HighPart == pLuid->HighPart &&
                    pTokenPrivileges->Privileges[uCount].Luid.LowPart  == pLuid->LowPart)
                {
                    //
                    // We found the privilege
                    //
                    *pbPresent = TRUE;

                    if (pAttributes)
                    {
                        *pAttributes = pTokenPrivileges->Privileges[uCount].Attributes;
                    }

                    break;
                }
            }
        }

        FreeSplMem(pPrivInfo);
    }

    return Error;
}

/*++

Routine Name

    CreateSelfRelativeSD

Routine Description:

    Creates a self relative SD. The function does not modifiy *pAbsoluteSD

Arguments:

    pAbsoluteSD  - pointer to SD in absolute form
    ppRelativeSD - pointer where to receive a pointer to the SD in self relative form.
                   The caller needs to free the returned memory using LocalFree

Return Value:

    ERROR_SUCCESS - *ppRelativeSD points to the SD in relative form. Must be freed with LocalFree
    other Win32 error

--*/
DWORD
CreateSelfRelativeSD(
    IN  PSECURITY_DESCRIPTOR  pAbsoluteSD,
    OUT PSECURITY_DESCRIPTOR *ppRelativeSD
    )
{
    DWORD cbNeeded = 0;
    DWORD Error    = ERROR_SUCCESS;

    *ppRelativeSD = NULL;

    if (!MakeSelfRelativeSD(pAbsoluteSD, NULL, &cbNeeded) && (Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
    {
        PSECURITY_DESCRIPTOR pSelfRelativeSD = LocalAlloc(LMEM_FIXED, cbNeeded);

        if (pSelfRelativeSD)
        {
            if (MakeSelfRelativeSD(pAbsoluteSD, pSelfRelativeSD, &cbNeeded))
            {
                *ppRelativeSD = pSelfRelativeSD;

                pSelfRelativeSD = NULL;

                Error = ERROR_SUCCESS;
            }
            else
            {
                Error = GetLastError();
            }

            LocalFree(pSelfRelativeSD);
        }
        else
        {
            Error = GetLastError();
        }
    }

    return Error;
}

/*++

Routine Name

    AddEntriesToSecurityDescriptor

Routine Description:

    Adds ACEs to an existing SD. *ppSecurityDescriptor is assumed to be not null and valid.

Arguments:

    cCountOfExplicitEntries - number of entries in array
    pListOfExplicitEntries  - array of EXPLICIT_ACCESS
    ppSecurityDescriptor    - on input, pointer to SD in self relative form, allocated with LocalAlloc
                              on output, pointer to SD in self relative form with added ACEs

Return Value:

    ERROR_SUCCESS - the function freed the original *ppSecurityDescriptor and stored a pointer to
                    a SD equivalent to the original + added ACEs. Caller must free it with LocalFree
    other Win32 error - *ppSecurityDescriptor is not modified

--*/
DWORD
AddEntriesToSecurityDescriptor(
    IN     ULONG                  cCountOfExplicitEntries,
    IN     PEXPLICIT_ACCESS       pListOfExplicitEntries,
    IN OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor
    )
{
    DWORD               Error          = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR AbsoluteSD     = {0};
    DWORD               AbsoluteSDSize = sizeof(SECURITY_DESCRIPTOR);
    PACL                pDacl          = NULL;
    DWORD               DaclSize       = 0;
    PACL                pSacl          = NULL;
    DWORD               SaclSize       = 0;
    PSID                pOwner         = NULL;
    DWORD               OwnerSize      = 0;
    PSID                pGroup         = NULL;
    DWORD               GroupSize      = 0;

    if (!MakeAbsoluteSD(*ppSecurityDescriptor,
                        &AbsoluteSD,
                        &AbsoluteSDSize,
                        pDacl,
                        &DaclSize,
                        pSacl,
                        &SaclSize,
                        pOwner,
                        &OwnerSize,
                        pGroup,
                        &GroupSize) && (Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
    {
        if (DaclSize == 0)
        {
            //
            // Nothing to do, return the same SD back to the caller
            //
            Error = ERROR_SUCCESS;
        }
        else
        {
            if (!(pDacl = LocalAlloc(LMEM_FIXED, DaclSize)) ||
                SaclSize  > 0 && !(pSacl  = LocalAlloc(LMEM_FIXED, SaclSize))  ||
                OwnerSize > 0 && !(pOwner = LocalAlloc(LMEM_FIXED, OwnerSize)) ||
                GroupSize > 0 && !(pGroup = LocalAlloc(LMEM_FIXED, GroupSize)))
            {
                Error = GetLastError();
            }
            else
            {
                if (MakeAbsoluteSD(*ppSecurityDescriptor,
                                   &AbsoluteSD,
                                   &AbsoluteSDSize,
                                   pDacl,
                                   &DaclSize,
                                   pSacl,
                                   &SaclSize,
                                   pOwner,
                                   &OwnerSize,
                                   pGroup,
                                   &GroupSize))
                {
                    PACL pNewDacl = NULL;

                    if ((Error = SetEntriesInAcl(cCountOfExplicitEntries,
                                                 pListOfExplicitEntries,
                                                 pDacl,
                                                 &pNewDacl)) == ERROR_SUCCESS)
                    {
                        if (SetSecurityDescriptorDacl(&AbsoluteSD,
                                                      TRUE,
                                                      pNewDacl,
                                                      TRUE))
                        {
                            PSECURITY_DESCRIPTOR pTempSD = NULL;

                            if ((Error = CreateSelfRelativeSD(&AbsoluteSD, &pTempSD)) == ERROR_SUCCESS)
                            {
                                LocalFree(*ppSecurityDescriptor);

                                *ppSecurityDescriptor = pTempSD;
                            }
                        }
                        else
                        {
                            Error = GetLastError();
                        }

                        LocalFree(pNewDacl);
                    }
                }
                else
                {
                    Error = GetLastError();
                }
            }

            LocalFree(pDacl);
            LocalFree(pSacl);
            LocalFree(pOwner);
            LocalFree(pGroup);
        }
    }

    return Error;
}

/*++

Routine Name

    GrantJobReadPermissionToLocalSystem

Routine Description:

    Adds an ACE that grants job_read permission to local system on an existing SD

Arguments:

    ppSecurityDescriptor  - on input, pointer to SD in self relative form, allocated with LocalAlloc
                            on output, pointer to SD in self relative form with added ACE for local system

Return Value:

    TRUE - the function freed the original *ppSecurityDescriptor and stored a pointer to
           a SD equivalent to the original + added ACE. Caller must free it with LocalFree
    FALSE - *ppSecurityDescriptor is not modified, use GetLastError

--*/
BOOL
GrantJobReadPermissionToLocalSystem(
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )
{
    DWORD           Error;
    EXPLICIT_ACCESS ExplicitAccess[1];

    ExplicitAccess[0].grfAccessMode                    = GRANT_ACCESS;
    ExplicitAccess[0].grfAccessPermissions             = JOB_READ;
    ExplicitAccess[0].grfInheritance                   = NO_INHERITANCE;
    ExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
    ExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.ptstrName                = pLocalSystemSid;

    Error = AddEntriesToSecurityDescriptor(1, ExplicitAccess, ppSecurityDescriptor);

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\schedule.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    schedule.c

Abstract:

    This module provides all the scheduling services for the Local Spooler

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Krishna Ganugapati (KrishnaG) 07-Dec-1993  - rewrote the scheduler thread to
    gracefully kill off port threads if there are no jobs assigned to ports and
    to recreate the port thread if the port receives a job and is without a thread.

    Matthew A Felton (MattFe) June 1994 RapidPrint implemented

    MattFe April 96 Chained Jobs


--*/

#include <precomp.h>

#include "filepool.hxx"

#define MIDNIGHT                    (60 * 60 * 24)

//
// Ten minutes, seconds are multiplied in by the Scheduler code.
//
#define FPTIMEOUT                   (60 * 10)


#if DBG
/* For the debug message:
 */
#define HOUR_FROM_SECONDS(Time)     (((Time) / 60) / 60)
#define MINUTE_FROM_SECONDS(Time)   (((Time) / 60) % 60)
#define SECOND_FROM_SECONDS(Time)   (((Time) % 60) % 60)

/* Format for %02d:%02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN_SEC(Time)   HOUR_FROM_SECONDS(Time),    \
                                    MINUTE_FROM_SECONDS(Time),  \
                                    SECOND_FROM_SECONDS(Time)

/* Format for %02d:%02d replaceable string:
 */
#define FORMAT_HOUR_MIN(Time)       HOUR_FROM_SECONDS(Time),    \
                                    MINUTE_FROM_SECONDS(Time)
#endif


HANDLE SchedulerSignal = NULL;
HANDLE PowerManagementSignal = NULL;


VOID
DbgPrintTime(
);

DWORD
GetTimeToWait(
    DWORD       CurrentTime,
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
    );

DWORD
GetCurrentTimeInSeconds(
    VOID
    );

VOID
InitializeSchedulingGlobals(
    );

VOID
CheckMemoryAvailable(
    PINIJOB  *ppIniJob,
    BOOL     bFixedJob
    );

VOID
UpdateJobList(
    );

BOOL
AddToJobList(
    PINIJOB    pIniJob,
    SIZE_T     Required,
    DWORD      dwJobList
    );

BOOL
SchedulerCheckPort(
    PINISPOOLER pIniSpooler,
    PINIPORT    pIniPort,
    PINIJOB     pFixedIniJob,
    PDWORD      pdwSchedulerTimeout
    );

BOOL
SchedulerCheckSpooler(
    PINISPOOLER pIniSpooler,
    PDWORD pdwSchedulerTimeout
    );

BOOL
GetJobFromWaitingList(
    PINIPORT   *ppIniPort,
    PINIJOB    *ppIniJob,
    DWORD      dwPriority
    );

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif

DWORD
SchedulerThread(
    PINISPOOLER pIniSpooler
    )
{
    DWORD SchedulerTimeout = INFINITE;    // In seconds
    PINISPOOLER pIniSpoolerNext;
    BOOL    bJobScheduled = FALSE;
    HANDLE  hTempFP = INVALID_HANDLE_VALUE;

    //
    // Initialize the EMF scheduling parameters
    //
    InitializeSchedulingGlobals();

    for( ; ; ) {


        if (SchedulerTimeout == INFINITE) {

            DBGMSG(DBG_TRACE, ("Scheduler thread waiting indefinitely\n"));

        } else {

            DBGMSG(DBG_TRACE, ("Scheduler thread waiting for %02d:%02d:%02d\n",
                                FORMAT_HOUR_MIN_SEC(SchedulerTimeout)));

            //
            // The SchedulerTimeout is in seconds, so we need to multiply
            // by 1000.
            //
            SchedulerTimeout *= 1000;
        }

        if (WaitForSingleObject(SchedulerSignal, SchedulerTimeout) == WAIT_FAILED) {

            DBGMSG(DBG_WARNING, ("SchedulerThread:WaitforSingleObject failed: Error %d\n",
                                 GetLastError()));
        }

        if (WaitForSingleObject(PowerManagementSignal, INFINITE) == WAIT_FAILED)
        {
            DBGMSG(DBG_WARNING, ("SchedulerThread:WaitforSingleObject failed on ACPI event: Error %d\n",
                                 GetLastError()));
        }

        /* The timeout will be reset if there are jobs to be printed
         * at a later time.  This will result in WaitForSingleObject
         * timing out when the first one is due to be printed.
         */

        SchedulerTimeout = INFINITE;
        bJobScheduled = FALSE;

        EnterSplSem();

        INCSPOOLERREF( pLocalIniSpooler );

        for(pIniSpooler = pLocalIniSpooler;
            pIniSpooler;
            pIniSpooler = pIniSpoolerNext ){

            //
            // Only schedule check spoolers that are local.
            //
            if( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ){
                bJobScheduled = (SchedulerCheckSpooler( pIniSpooler, &SchedulerTimeout )
                                 || bJobScheduled);

                //
                // FP Change
                // Trim the filepool.
                //
                if (pIniSpooler &&
                    (hTempFP = pIniSpooler->hFilePool) != INVALID_HANDLE_VALUE &&
                    !bJobScheduled )
                {
                    //
                    // We've incremented the spooler Refcount, so we can
                    // safely leave the splsem.
                    //
                    LeaveSplSem();
                    if (TrimPool(hTempFP))
                    {
                        if (SchedulerTimeout == INFINITE)
                        {
                            SchedulerTimeout = FPTIMEOUT;
                        }
                    }
                    EnterSplSem();
                }
            }

            pIniSpoolerNext = pIniSpooler->pIniNextSpooler;
            if( pIniSpoolerNext ){
                INCSPOOLERREF( pIniSpoolerNext );
            }

            DECSPOOLERREF( pIniSpooler );
        }

        LeaveSplSem();

    }
    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

BOOL
SchedulerCheckPort(
    PINISPOOLER pIniSpooler,
    PINIPORT    pIniPort,
    PINIJOB     pFixedIniJob,
    PDWORD      pdwSchedulerTimeout)

/*++
Function Description: Checks if pIniJob can be assigned to pIniPort. If pInijob is NULL we
                      search for another job that can print on pIniPort. The job (if any) is
                      scheduled and the dwSchedulerTimeout is adjusted for the next waiting
                      job

Parameters: pIniSpooler   -- pointer to INISPOOLER struct
            pIniPort      -- Port to a assign a job to
            pFixedIniJob  -- Assign this job, if possible. If NULL search for other jobs
            pdwSchedulerTimeOut -- How much time will the scheduler thread sleep

Return Values: TRUE if a job gets assigned to pIniPort
               FALSE otherwise
--*/

{
    BOOL      bFixedJob, bReturn = FALSE;
    PINIJOB   pIniJob = NULL;
    DWORD     ThisPortTimeToWait;             // In seconds
    DWORD     CurrentTickCount;

    // Check of there is a pre assigned job
    bFixedJob = pFixedIniJob ? TRUE : FALSE;

    DBGMSG(DBG_TRACE, ("Now Processing Port %ws\n", pIniPort->pName));

    SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

    // Check conditions based on which we can assign this
    // port a job.

    // Rule 1 - if there is a job being processed by this
    // port, then  leave this port alone.

    if ( (pIniPort->pIniJob) &&
        !(pIniPort->Status & PP_WAITING )){

        SPLASSERT( pIniPort->pIniJob->signature == IJ_SIGNATURE );

        //
        //  If this port has a job which has timed out AND
        //  there is another job waiting on this port then
        //  push the timed out job out by setting JOB_ABANDON
        //  see spooler.c LocalReadPrinter
        //
        pIniJob = pIniPort->pIniJob;

        if (( pIniJob->Status & JOB_TIMEOUT ) &&
            ( pIniJob->WaitForWrite != NULL ) &&
            ( NULL != AssignFreeJobToFreePort( pIniPort, &ThisPortTimeToWait ) )) {

            INCPORTREF( pIniPort );
            INCJOBREF( pIniJob );

            InterlockedOr((LONG*)&(pIniJob->Status), JOB_ABANDON);
            ReallocSplStr(&pIniJob->pStatus, szFastPrintTimeout);

            LogJobInfo( pIniSpooler,
                        MSG_DOCUMENT_TIMEOUT,
                        pIniJob->JobId,
                        pIniJob->pDocument,
                        pIniJob->pUser,
                        pIniJob->pIniPrinter->pName,
                        dwFastPrintWaitTimeout );

            SetEvent( pIniJob->WaitForWrite );

            SetPrinterChange(pIniJob->pIniPrinter,
                             pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pIniJob->pIniPrinter->pIniSpooler);

            DECJOBREF( pIniJob );

            DECPORTREF( pIniPort );
        }

        return bReturn;
    }

    if (bFixedJob) {
        // Use a pre-assigned job
        pIniJob = pFixedIniJob;
    } else {
        // Is there any job that can be scheduled to this port ?
        pIniJob = AssignFreeJobToFreePort(pIniPort, &ThisPortTimeToWait);
        *pdwSchedulerTimeout = min(ThisPortTimeToWait, *pdwSchedulerTimeout);
    }

    if (pIniPort->Status & PP_THREADRUNNING ) {
        if (pIniPort->Status & PP_WAITING) {

            //
            // If we are working on a Chained Job then the job
            // has already been assigned by the port thread from
            // the last job on this port so ignore any other job
            // found for us.
            //
            if (pIniPort->pIniJob) {

                if (bFixedJob && (pIniJob != pIniPort->pIniJob)) {
                    //
                    // The fixed job could not assigned because chained jobs
                    // must be printed sequentially
                    //
                    pIniJob = NULL;
                } else {
                    pIniJob = pIniPort->pIniJob;
                    DBGMSG( DBG_TRACE, ("ScheduleThread NextJob pIniPort %x JoId %d pIniJob %x\n",
                       pIniPort, pIniJob->JobId, pIniJob ));
                }
            }

            //
            // If the delay in scheduling has been requested by FlushPrinter wait until
            // IdleTime elapses
            //
            // We're using a local here to avoid multiple calls to GetTickCount().
            //
            CurrentTickCount = GetTickCount();

            if (pIniPort->bIdleTimeValid && (int)(pIniPort->IdleTime - CurrentTickCount) > 0) {
                //
                // Our port is not ready to accept a job just yet, we need to
                // remind the Scheduler to wake up in a little while to reassign
                // the job to the port.
                //
                // The difference is in milliseconds, so we divide by 1000 to get to
                // seconds, and add 1 to make sure we return after the timeout has
                // expired.
                //
                *pdwSchedulerTimeout =
                    min( ((pIniPort->IdleTime - CurrentTickCount)/1000) + 1,
                         *pdwSchedulerTimeout);

                //
                // Null out the job so we don't assign it to the port.
                //
                pIniJob = NULL;
            }
            else {
                pIniPort->bIdleTimeValid = FALSE;
            }

            if ( pIniJob ) {
                CheckMemoryAvailable( &pIniJob, bFixedJob );
            }

            if ( pIniJob ) {

                DBGMSG(DBG_TRACE, ("ScheduleThread pIniJob %x Size %d pDocument %ws\n",
                        pIniJob, pIniJob->Size, DBGSTR( pIniJob->pDocument)));


                if (pIniPort != pIniJob->pIniPort) {

                    ++pIniPort->cJobs;
                    pIniJob->pIniPort = pIniPort;
                }

                pIniPort->pIniJob = pIniJob;

                //
                // We have a new job on this port, make sure the Critical Section mask is
                // cleared.
                //
                pIniPort->InCriticalSection = 0;

                if( !pIniJob->pCurrentIniJob ){

                    //
                    // If pCurrentIniJob is NULL, then this is
                    // beginning of a new job (single or linked).
                    //
                    // Clustered spoolers are interested in the
                    // number of jobs that are actually printing.
                    // We need to know when all printing jobs are
                    // done so we can shutdown.
                    //
                    ++pIniJob->pIniPrinter->pIniSpooler->cFullPrintingJobs;

                    if( pIniJob->NextJobId ){

                        //
                        // Chained Jobs
                        // Point the Master Jobs Current Pointer to
                        // the first in the chain.
                        //
                        pIniJob->pCurrentIniJob = pIniJob;
                    }
                }


                pIniPort->Status &=  ~PP_WAITING;

                //
                // If the job is still spooling then we will need
                // to create an event to synchronize the port thread
                //
                if ( !( pIniJob->Status & JOB_DIRECT ) ) {

                    pIniJob->WaitForWrite = NULL;

                    if ( pIniJob->Status & JOB_SPOOLING ) {

                        pIniJob->WaitForWrite = CreateEvent(NULL,
                                                            EVENT_RESET_MANUAL,
                                                            EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                            NULL);

                    }
                }

                //
                // Update cRef so that nobody can delete this job
                // before the Port Thread Starts up
                //
                SplInSem();
                INCJOBREF(pIniJob);

                SetEvent(pIniPort->Semaphore);
                InterlockedOr((LONG*)&(pIniJob->Status), JOB_DESPOOLING);

                bReturn = TRUE;

            } else {

                //
                // If the port thread is running and it is waiting
                // for a job and there is no job to assign, then
                // kill the port thread
                //
                DBGMSG(DBG_TRACE, ("Now destroying the new port thread %.8x\n", pIniPort));
                DestroyPortThread(pIniPort, FALSE);

                pIniPort->Status &= ~PP_WAITING;

                if (pIniPort->Status & PP_FILE) {
                    //
                    // We should destroy the Pseudo-File Port at this
                    // point. There are no jobs assigned to this Port
                    // and we are in Critical Section
                    //

                    //
                    // Now deleting the pIniPort entry for the Pseudo-Port
                    //

                    DBGMSG(DBG_TRACE, ("Now deleting the Pseudo-Port %ws\n", pIniPort->pName));

                    if ( !pIniPort->cJobs )
                        DeletePortEntry(pIniPort);

                    return bReturn;
                }
            }
        }
    } else if (!(pIniPort->Status & PP_THREADRUNNING) && pIniJob) {

        //
        // If the port thread is not running, and there is a job to
        // assign, then create a port thread. REMEMBER do not assign
        // the job to the port because we are in a Spooler Section and
        // if we release the Spooler Section, the first thing the port
        // thread does is  reinitialize its pIniPort->pIniJob to NULL
        // Wait the next time around we execute the for loop to assign
        // the job to this port. Should we set *pdwSchedulerTimeOut to zero??
        //
        DBGMSG( DBG_TRACE, ("ScheduleThread Now creating the new port thread pIniPort %x\n", pIniPort));

        CreatePortThread( pIniPort );
        bReturn = TRUE;
    }

    return bReturn;
}

BOOL
SchedulerCheckSpooler(
    PINISPOOLER pIniSpooler,
    PDWORD      pdwSchedulerTimeout)

/*++
Function Description: This function assigns a waiting job to a port after every minute.
                      If memory is available it schedules as many jobs from the waiting
                      list as possible.
                      It then loops thru the ports in a round-robin fashion scheduling jobs
                      or adding them to the waiting list.

Parameters:  pIniSpooler         -- pointer to the INISPOOLER struct
             pdwSchedulerTimeout -- duration of time for which the scheduler
                                    thread will sleep

Return Values: NONE
--*/

{
    DWORD       ThisPortTimeToWait = INFINITE;             // In seconds
    DWORD       dwTickCount;
    PINIPORT    pIniPort;
    PINIJOB     pIniJob;
    PINIPORT    pIniNextPort = NULL;
    BOOL        bJobScheduled = FALSE;

    UpdateJobList();

    //
    // If Jobs have been waiting for 1 minute and nothing has been scheduled in
    // that time, schedule one of the waiting jobs.
    //
    dwTickCount = GetTickCount();

    if (pWaitingList &&
        ((dwTickCount - pWaitingList->dwWaitTime) > ONE_MINUTE) &&
        ((dwTickCount - dwLastScheduleTime) > ONE_MINUTE)) {

        if (GetJobFromWaitingList(&pIniPort, &pIniJob, SPL_FIRST_JOB)) {

            bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, pIniJob, &ThisPortTimeToWait)
                             || bJobScheduled);
            *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);
        }
    }

    //
    // Use the available memory to schedule waiting jobs
    //
    while (GetJobFromWaitingList(&pIniPort, &pIniJob, SPL_USE_MEMORY)) {

       bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, pIniJob, &ThisPortTimeToWait)
                        || bJobScheduled);
       *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);
    }

    //
    // Loop thru the ports and get the list of jobs that can be scheduled
    //
    for (pIniPort = pIniSpooler->pIniPort;
         pIniPort;
         pIniPort = pIniNextPort) {

       pIniNextPort = pIniPort->pNext;

       //
       // SchedulerCheckPort can leave the critical section and the iniPort can
       // be removed from the list in the meanwhile. So, maintain the Ref on it.
       //
       if (pIniNextPort) {

           INCPORTREF(pIniNextPort);
       }

       bJobScheduled = (SchedulerCheckPort(pIniSpooler, pIniPort, NULL, &ThisPortTimeToWait)
                        || bJobScheduled);
       *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, ThisPortTimeToWait);

       if (pIniNextPort) {

           DECPORTREF(pIniNextPort);
       }
    }

    // If there any jobs left try to reschedule latest after one minute.
    if (pWaitingList) {
        *pdwSchedulerTimeout = min(*pdwSchedulerTimeout, 60);
    }

    return bJobScheduled;
}

VOID
InitializeSchedulingGlobals(
)
/*++
Function Description: Initializes globals used for EMF scheduling

Parameters: NONE

Return Values: NONE
--*/
{
    MEMORYSTATUS   msBuffer;
    HKEY           hPrintRegKey = NULL;
    DWORD          dwType, dwData, dwcbData;

    bUseEMFScheduling = TRUE; // default value

    dwcbData = sizeof(DWORD);

    // Check the registry for the flag for turning off EMF scheduling. If the
    // key is not present/Reg Apis fail default to using the scheduling.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szRegistryRoot,
                     0,
                     KEY_READ,
                     &hPrintRegKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hPrintRegKey,
                            szEMFThrottle,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwData,
                            &dwcbData) == ERROR_SUCCESS) {

            if (dwData == 0) {
                // Scheduling has been turned off
                bUseEMFScheduling = FALSE;
            }
        }
    }

    // Get the memory status
    GlobalMemoryStatus(&msBuffer);

    // Use half the physical memory in megabytes
    TotalMemoryForRendering = msBuffer.dwTotalPhys / ( 2048 * 1024);
    AvailMemoryForRendering = TotalMemoryForRendering;

    dwNumberOfEMFJobsRendering = 0;
    pWaitingList = NULL;
    pScheduleList = NULL;
    dwLastScheduleTime = GetTickCount();

    if (hPrintRegKey) {
        RegCloseKey(hPrintRegKey);
    }

    return;
}

DWORD
GetMemoryEstimate(
    LPDEVMODE pDevMode
)
/*++
Function Description: Computes a rough estimate of the memory required for rendering a
                      single page based on the DPI and color settings

Parameters: pDevMode -- pointer to the devmode of the job

Return Values: Memory estimate
--*/
{
    DWORD      dwRequired, dwXRes, dwYRes, dwMaxRes;
    DWORD      dwXIndex, dwYIndex;
    DWORD      MemHeuristic[3][2] = {{8 , 4},
                                     {12, 6},
                                     {16, 8}};

    //
    // Get the max resolution on either axis
    //
    dwXRes = dwYRes = 300;

    if (pDevMode) {
        if (pDevMode->dmFields & DM_PRINTQUALITY) {
             switch (pDevMode->dmPrintQuality) {
             case DMRES_DRAFT:
             case DMRES_LOW:
             case DMRES_MEDIUM:
                    dwXRes = dwYRes = 300;
                    break;
             case DMRES_HIGH:
                    dwXRes = dwYRes = 600;
                    break;
             default:
                    dwXRes = dwYRes = (DWORD) pDevMode->dmPrintQuality;
                    break;

             }
        }
        if (pDevMode->dmFields & DM_YRESOLUTION) {
             dwYRes = (DWORD)pDevMode->dmYResolution;
        }
    }

    dwMaxRes = (dwXRes >= dwYRes) ? dwXRes : dwYRes;

    if (dwMaxRes <= 300) {
        dwXIndex = 0;
    } else if (dwMaxRes <= 600) {
        dwXIndex = 1;
    } else {
        dwXIndex = 2;
    }

    // Get the color setting
    dwYIndex = 1;
    if (pDevMode) {
        if ((pDevMode->dmFields & DM_COLOR) &&
            (pDevMode->dmColor == DMCOLOR_COLOR)) {

             dwYIndex = 0;
        }
    }

    dwRequired = MemHeuristic[dwXIndex][dwYIndex];

    return dwRequired;
}

VOID
CheckMemoryAvailable(
    PINIJOB  *ppIniJob,
    BOOL     bFixedJob
    )
/*++
Function Description: Checks for availability of memory required for rendering the
                      job. Performs some scheduling based on resource requirements.

Parameters: ppIniJob  - pointer to the PINIJOB to be scheduled
            bFixedJob - flag to disable memory requirement checks

Return Values: NONE
--*/
{
    PINIJOB    pIniJob;
    SIZE_T     Required;

    SplInSem();

    if (ppIniJob) {
        pIniJob = *ppIniJob;
    } else {
        //
        // should not happen
        //
        return;
    }

    //
    // Dont use scheduling algorithm if it has been explicitly turned off
    //
    if (!bUseEMFScheduling) {
        return;
    }

    //
    // Don't use scheduling algorithm for non EMF jobs
    //
    if (!pIniJob->pDatatype ||
        (wstrcmpEx(pIniJob->pDatatype, gszNT4EMF, FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, L"NT EMF 1.006", FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, L"NT EMF 1.007", FALSE) &&
         wstrcmpEx(pIniJob->pDatatype, gszNT5EMF, FALSE)) )  {

        return;
    }

    Required = GetMemoryEstimate(pIniJob->pDevMode);

    if (bFixedJob) {
        // This job has to be assigned without memory availability checks
        RemoveFromJobList(pIniJob, JOB_WAITING_LIST);

        AddToJobList(pIniJob, Required, JOB_SCHEDULE_LIST);

        return;
    }

    // Check if the job has to wait, based on
    // 1.  Some jobs are already waiting OR
    // 2.  There is insufficient memory available due to currently rendering jobs

    if ((pWaitingList != NULL) ||
        ((AvailMemoryForRendering < Required) &&
         (dwNumberOfEMFJobsRendering > 0))) {

         AddToJobList(pIniJob, Required, JOB_WAITING_LIST);
         *ppIniJob = NULL;

         return;
    }

    // The job can be scheduled right away
    AddToJobList(pIniJob, Required, JOB_SCHEDULE_LIST);

    return;
}

PINIJOB
AssignFreeJobToFreePort(
    PINIPORT pIniPort,
    DWORD   *pSecsToWait
    )

/*++
    Note: You must ensure that the port is free. This function will not
    assign a job to this port, but if there exists one, it will return a
    pointer to the INIJOB. Irrespective of whether it finds a job or not,
    it will return the minimum timeout value that the scheduler thread
    should sleep for.
--*/

{
    DWORD           CurrentTime;        // Time in seconds
    DWORD           Timeout = INFINITE; // Time in seconds
    DWORD           SecsToWait; // Time in seconds
    PINIPRINTER     pTopIniPrinter,  pIniPrinter;
    PINIJOB         pTopIniJob, pIniJob;
    PINIJOB         pTopIniJobOnThisPrinter, pTopIniJobSpooling;
    DWORD           i;

    SplInSem();

    if( pIniPort->Status & PP_ERROR ){

        *pSecsToWait = INFINITE;
        return NULL;
    }

    pTopIniPrinter = NULL;
    pTopIniJob = NULL;

    for (i = 0; i < pIniPort->cPrinters ; i++) {
        pIniPrinter = pIniPort->ppIniPrinter[i];

        //
        // if this printer is in a state not to print skip it
        //

        if ( PrinterStatusBad(pIniPrinter->Status) ||
             (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) {

            continue;
        }


        //
        // if we haven't found a top-priority printer yet,
        // or this printer is higher priority than the top-priority
        // printer, see if it has jobs to go. If we  find any, the
        // highest priority one will become the top priority job and
        // this printer will become the top-priority printer.
        //

        if (!pTopIniPrinter ||
            (pIniPrinter->Priority > pTopIniPrinter->Priority)) {

                pTopIniJobOnThisPrinter = NULL;
                pTopIniJobSpooling = NULL;
                pIniJob = pIniPrinter->pIniFirstJob;
                while (pIniJob) {

                    if (!(pIniPort->Status & PP_FILE) &&
                            (pIniJob->Status & JOB_PRINT_TO_FILE)) {
                                pIniJob = pIniJob->pIniNextJob;
                                continue;
                    }

                    if ((pIniPort->Status & PP_FILE) &&
                            !(pIniJob->Status & JOB_PRINT_TO_FILE)) {
                                pIniJob = pIniJob->pIniNextJob;
                                continue;
                    }

                    //
                    // Make sure the spooler isn't offline.
                    // Find a job which is not PAUSED, PRINTING etc.
                    // Let jobs that are DIRECT & CANCELLED through
                    // For RapidPrint also allow SPOOLING jobs to print
                    //
                    if (!(pIniJob->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE) &&
                        (!(pIniJob->Status & JOB_PENDING_DELETION) || (pIniJob->pIniPrinter->Attributes&PRINTER_ATTRIBUTE_DIRECT)) &&

                        !(pIniJob->Status & ( JOB_PAUSED       | JOB_PRINTING | JOB_COMPLETE |
                                              JOB_PRINTED      | JOB_TIMEOUT  |
                                              JOB_DESPOOLING   | JOB_BLOCKED_DEVQ | JOB_COMPOUND )) &&

                        ((!(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) &&
                          !(pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_QUEUED)) ||
                         !(pIniJob->Status & JOB_SPOOLING))) {

                        //
                        // if we find such a job, then determine how much
                        // time, we need to wait before this job can actually
                        // print.
                        //

                        CurrentTime = GetCurrentTimeInSeconds();
                        #if DBG
                                if (MODULE_DEBUG & DBG_TIME)
                                    DbgPrintTime();
                        #endif
                        SecsToWait = GetTimeToWait(CurrentTime, pIniPrinter, pIniJob);

                        if (SecsToWait == 0) {

                            //
                            // if we needn't wait at all, then we make this job the
                            // TopIniJob if either there is no TopIniJob or this job
                            // has a higher priority than an existing TopIniJob on this
                            // printer.
                            //
                            // Keep both the Highest Priority Spooling and Non
                            // spooling job in case we want to favour non spooling
                            // jobs over spooling jobs
                            //
                            if ( pIniJob->Status & JOB_SPOOLING ) {

                                if ( pTopIniJobSpooling == NULL ) {

                                    pTopIniJobSpooling = pIniJob;

                                } else if ( pIniJob->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST ) {

                                    //
                                    // For DO_COMPLETE_FIRST we'll take larger jobs
                                    // first over pure priority based
                                    //
                                    if (( pIniJob->dwValidSize > pTopIniJobSpooling->dwValidSize ) ||

                                       (( pIniJob->dwValidSize == pTopIniJobSpooling->dwValidSize ) &&
                                        ( pIniJob->Priority > pTopIniJobSpooling->Priority ))) {

                                        pTopIniJobSpooling = pIniJob;

                                    }

                                //
                                //  For Priority Based, pick a higher priority job if it has some
                                //  at least our minimum requirement
                                //
                                } else if (( pIniJob->Priority > pTopIniJobSpooling->Priority ) &&
                                           ( pIniJob->dwValidSize >= dwFastPrintSlowDownThreshold )) {

                                    pTopIniJobSpooling = pIniJob;
                                }

                            } else {

                                if (!pTopIniJobOnThisPrinter ||
                                     (pIniJob->Status & JOB_PENDING_DELETION) ||
                                     (pIniJob->Priority > pTopIniJobOnThisPrinter->Priority)) {

                                    pTopIniJobOnThisPrinter = pIniJob;

                                }
                            }

                        } else {

                            //
                            // if we have to wait then keep track of how long we
                            // can doze off before the next job that is to be
                            // scheduled later.
                            //

                            Timeout = min(Timeout, SecsToWait);
                        }
                    }
                    //
                    // loop thru all jobs on this printer.
                    //

                    pIniJob = pIniJob->pIniNextJob;
                }

                //
                // We've already  established that this printer has a
                // higher priority than any previous TopIniPrinter or
                // that there is no TopIniPrinter yet.

                // if we did find a TopIniJobOnThisPrinter for this pIniPrinter
                // update the TopIniPrinter and TopIniJob pointers
                //

                // We don't want to schedule Spooling Jobs whose size doesn't meet
                // our minimum size requirement

                if (( pTopIniJobSpooling != NULL ) &&
                    ( dwFastPrintSlowDownThreshold > pTopIniJobSpooling->Size )) {

                        pTopIniJobSpooling = NULL ;
                }

                if ( pTopIniJobOnThisPrinter == NULL ) {

                    pTopIniJobOnThisPrinter = pTopIniJobSpooling;

                } else {

                    // For FastPrint we can choose to favour Completed jobs over
                    // Spooling jobs

                    if ( !( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST )  &&
                        ( pTopIniJobSpooling ) &&
                        ( pTopIniJobSpooling->Priority >= pTopIniJobOnThisPrinter->Priority )) {

                        pTopIniJobOnThisPrinter = pTopIniJobSpooling;

                     }
                }

                if (pTopIniJobOnThisPrinter) {
                    pTopIniPrinter = pIniPrinter;
                    pTopIniJob = pTopIniJobOnThisPrinter;
                }

        }
        //
        // This ends the if clause for finding a printer with higher priority
        // than the current TopIniPrinter. Loop back and process all printers
    }
    //
    // End of For Loop for all Printers
    //

    //
    // if we have a TopIniJob at this stage, it means we have a job that can be
    // assigned to the IniPort. We will return a pointer to this job back

    // We will also copy the Timeout value that has been computed for this
    // IniPort back to the SchedulerThread.

    *pSecsToWait = Timeout;

    return(pTopIniJob);

}

DWORD
GetCurrentTimeInSeconds(
)
/*++

    Note: This function returns a value representing the time in seconds


--*/
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    return ((((st.wHour * 60) + st.wMinute) * 60) + st.wSecond);
}

/* GetTimeToWait
 *
 * Determines how long it is in seconds from the current time
 * before the specified job should be printed on the specified printer.
 *
 * Parameters:
 *
 *     CurrentTime - Current system time in seconds
 *
 *     pIniPrinter - Pointer to INIPRINTER structure for the printer.
 *         This contains the StartTime and UntilTime fields.
 *
 *     pIniJob - Pointer to INIJOB structure for the job.
 *         This contains the StartTime and UntilTime fields.
 *
 * Return value:
 *
 *     The number of seconds till the job should be printed.
 *     If the job can be printed immediately, this will be 0.
 *     We don't support specifying the day the job should be printed,
 *     so the return value should always be in the following range:
 *
 *         0 <= return value < 86400 (60 * 60 * 24)
 *
 * Remarks:
 *
 *     The user can specify hours on both the printer and the job.
 *     Thus a printer may be configured to print only at night,
 *     say between the hours 20:00 and 06:00.
 *     Any job submitted to the printer outside those hours
 *     will not print until 20:00.
 *     If, in addition, the user specifies the hours when the job
 *     may print (e.g. through Printer Properties -> Details
 *     in Print Manager), the job will print when the two periods
 *     overlap.
 *
 *     This routine finds the two wait periods determined by the
 *     printer hours and the job hours respectively.
 *     The actual time to wait is the longer of the two.
 *     It therefore assumes that the two periods overlap.
 *     This doesn't matter if the routine is called again
 *     when the scheduler thread wakes up again.
 *
 *     CHANGED: 14 June 1993
 *
 *     The printer times are now ignored.
 *     When a job is submitted it inherits the printer's hours.
 *     These are all we need to check.  Now if the printer's hours
 *     are changed, any already existing jobs on that printer
 *     will still print within the originally assigned times.
 *
 *
 */
DWORD
GetTimeToWait(
    DWORD       CurrentTime,
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
)
{
    /* Printer and job start and until times are in minutes.
     * Convert them to seconds, so that we can start printing
     * bang on the minute.
     */
    DWORD PrinterStartTime = (pIniPrinter->StartTime * 60);
    DWORD PrinterUntilTime = (pIniPrinter->UntilTime * 60);
    DWORD JobStartTime = (pIniJob->StartTime * 60);
    DWORD JobUntilTime = (pIniJob->UntilTime * 60);
    DWORD PrinterTimeToWait = 0;
    DWORD JobTimeToWait = 0;
    DWORD TimeToWait = 0;

    /* Do the same for the job time constraints:
     */
    if (JobStartTime > JobUntilTime) {

        if ((CurrentTime < JobStartTime)
          &&(CurrentTime >= JobUntilTime)) {

            JobTimeToWait = (JobStartTime - CurrentTime);
        }

    } else if (JobStartTime < JobUntilTime) {

        if (CurrentTime < JobStartTime) {

            JobTimeToWait = (JobStartTime - CurrentTime);

        } else if (CurrentTime >= JobUntilTime) {

            JobTimeToWait = ((MIDNIGHT - CurrentTime) + JobStartTime);
        }
    }


    TimeToWait = max(PrinterTimeToWait, JobTimeToWait);

    DBGMSG(DBG_TRACE, ("Checking time to print %ws\n"
                       "\tCurrent time:  %02d:%02d:%02d\n"
                       "\tPrinter hours: %02d:%02d to %02d:%02d\n"
                       "\tJob hours:     %02d:%02d to %02d:%02d\n"
                       "\tTime to wait:  %02d:%02d:%02d\n\n",
                       pIniJob->pDocument ?
                           pIniJob->pDocument :
                           L"(NULL)",
                       FORMAT_HOUR_MIN_SEC(CurrentTime),
                       FORMAT_HOUR_MIN(PrinterStartTime),
                       FORMAT_HOUR_MIN(PrinterUntilTime),
                       FORMAT_HOUR_MIN(JobStartTime),
                       FORMAT_HOUR_MIN(JobUntilTime),
                       FORMAT_HOUR_MIN_SEC(TimeToWait)));

    return TimeToWait;
}


#if DBG
VOID DbgPrintTime(
)
{
    SYSTEMTIME st;

    GetLocalTime(&st);

    DBGMSG( DBG_TIME,
            ( "Time: %02d:%02d:%02d\n", st.wHour, st.wMinute, st.wSecond ));
}
#endif


VOID UpdateJobList()

/*++
Function Description: Remove Jobs from the scheduled list which take more than 7 minutes.
                      This figure can be tuned up based in performance. There might be
                      some minor wrapping up discrepencies after 49.7 days which can be
                      safely ignored.
                      It also removes deleted, printed and abandoned jobs from the waiting
                      list.

                      This function should be called inside SplSem.
Parameters: NONE

Return Values: NONE
--*/

{
    PJOBDATA  *pJobList, pJobData;
    DWORD     dwTickCount;

    SplInSem();

    dwTickCount = GetTickCount();
    pJobList = &pScheduleList;

    while (pJobData = *pJobList) {

       if ((dwTickCount - pJobData->dwScheduleTime) >= SEVEN_MINUTES) {
           // Dont hold up resources for this job any more.
           RemoveFromJobList(pJobData->pIniJob, JOB_SCHEDULE_LIST);
           continue;
       }

       pJobList = &(pJobData->pNext);
    }

    pJobList = &pWaitingList;

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob->Status & (JOB_PRINTING | JOB_PRINTED | JOB_COMPLETE |
                                        JOB_ABANDON  | JOB_PENDING_DELETION)) {

           RemoveFromJobList(pJobData->pIniJob, JOB_WAITING_LIST);
           continue;
       }

       pJobList = &(pJobData->pNext);
    }

    return;
}


BOOL AddToJobList(
    PINIJOB    pIniJob,
    SIZE_T     Required,
    DWORD      dwJobList)

/*++
Function Description: This function adds pIniJob to the list specified by dwJobList. It also
                      updates the number of rendering EMF jobs and memory available
                      for rendering.
                      This function should be called in SplSem.

Parameters:  pIniJob      -- Job to be removed
             dwRequired   -- Estimate of the memory required to render the job
             dwJobList    -- List to add to (Waiting List or Schedule List)

Return Values: TRUE if the node was added or already present
               FALSE otherwise
--*/

{
    PJOBDATA   *pJobList, pJobData;
    SIZE_T     MemoryUse;
    DWORD      dwTickCount;
    BOOL       bReturn = TRUE;

    SplInSem();

    if (!pIniJob) {
        return bReturn;
    }

    if (dwJobList == JOB_SCHEDULE_LIST) {
        pJobList = &pScheduleList;
    } else { // JOB_WAITING_LIST
        pJobList = &pWaitingList;
    }

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob == pIniJob) {
           // The job is already on the list. Dont add duplicates
           break;
       }
       pJobList = &(pJobData->pNext);
    }

    if (!pJobData) {

        // Append a new node to the list
        if (pJobData = AllocSplMem(sizeof(JOBDATA))) {

            pJobData->pIniJob = pIniJob;
            pJobData->MemoryUse = Required;
            pJobData->dwNumberOfTries = 0;
            dwTickCount = GetTickCount();

            if (dwJobList == JOB_SCHEDULE_LIST) {
                pJobData->dwScheduleTime = dwTickCount;
                pJobData->dwWaitTime = 0;
            } else { // JOB_WAIT_TIME
                pJobData->dwWaitTime = dwTickCount;
                pJobData->dwScheduleTime = 0;
            }

            pJobData->pNext = *pJobList;
            *pJobList = pJobData;

            INCJOBREF(pIniJob);

            if (dwJobList == JOB_SCHEDULE_LIST) {
                // Update the scheduling globals
                ++dwNumberOfEMFJobsRendering;

                if (AvailMemoryForRendering > Required) {
                    AvailMemoryForRendering -= Required;
                } else {
                    AvailMemoryForRendering = 0;
                }

                dwLastScheduleTime = dwTickCount;
            }

        } else {

            bReturn = FALSE;
        }
    }

    return bReturn;
}

VOID RemoveFromJobList(
    PINIJOB    pIniJob,
    DWORD      dwJobList)

/*++
Function Description: This function removes pIniJob from the list specified by dwJobList
                      It also updates the number of rendering EMF jobs and memory available
                      for rendering. The scheduler is awakened if necessary.
                      This function should be called inside SplSem.

Parameters:  pIniJob      -- Job to be removed
             dwJobList    -- List to remove from (Waiting List or Schedule List)

Return Values: NONE
--*/

{
    PJOBDATA   *pJobList, pJobData;
    SIZE_T      Memory;

    SplInSem();

    if (!pIniJob) {
        return;
    }

    if (dwJobList == JOB_SCHEDULE_LIST) {
        pJobList = &pScheduleList;
    } else { // JOB_WAITING_LIST
        pJobList = &pWaitingList;
    }

    while (pJobData = *pJobList) {

       if (pJobData->pIniJob == pIniJob) {
           // Remove from the list
           *pJobList = pJobData->pNext;

           DECJOBREF(pIniJob);
           if (dwJobList == JOB_SCHEDULE_LIST) {
               // Update available memory and number of rendering jobs
               Memory = AvailMemoryForRendering + pJobData->MemoryUse;
               AvailMemoryForRendering = min(Memory, TotalMemoryForRendering);
               --dwNumberOfEMFJobsRendering;

               // Awaken the scheduler since more memory if available
               CHECK_SCHEDULER();
           }

           FreeSplMem(pJobData);

           // Break since there are no duplicates in the list
           break;
       }

       pJobList = &(pJobData->pNext);
    }

    return;
}

BOOL GetJobFromWaitingList(
    PINIPORT   *ppIniPort,
    PINIJOB    *ppIniJob,
    DWORD      dwPriority)

/*++
Function Description: This function picks up the first job in the Waiting List that can
                      be assigned to some free port. It should be called from within the
                      SplSem.

Parameters: ppIniPort    -  pointer to pIniPort where the job can be scheduled
            ppIniJob     -  pointer to pIniJob which can be scheduled
            dwPriority   -  flag to use memory availability check

Return Values: TRUE if a job can be scheduled
               FALSE otherwise
--*/

{
    BOOL        bReturn = FALSE;
    DWORD       dwIndex, CurrentTime, SecsToWait;
    PINIPORT    pIniPort = NULL;
    PINIJOB     pIniJob = NULL;
    PINIPRINTER pIniPrinter = NULL;
    PJOBDATA    pJobData;

    SplInSem();

    // Initialize the port and job pointers;
    *ppIniPort = NULL;
    *ppIniJob  = NULL;

    for (pJobData = pWaitingList;
         pJobData;
         pJobData = pJobData->pNext) {

        pIniJob = pJobData->pIniJob;
        pIniPrinter = pIniJob->pIniPrinter;

        // Check for memory availability
        if (dwPriority == SPL_USE_MEMORY) {
            if ((pJobData->MemoryUse > AvailMemoryForRendering) &&
                (dwNumberOfEMFJobsRendering != 0)) {
                // Insufficient memory
                continue;
            }
        } else { // SPL_FIRST_JOB
            if (pJobData->dwNumberOfTries > 2) {
                continue;
            }
        }

        // If this job can't be printed, go to the next one
        if (pIniJob->Status & ( JOB_PAUSED       | JOB_PRINTING |
                                JOB_PRINTED      | JOB_TIMEOUT  |
                                JOB_DESPOOLING   | JOB_PENDING_DELETION |
                                JOB_BLOCKED_DEVQ | JOB_COMPOUND | JOB_COMPLETE)) {
            continue;
        }

        // If we cant print to this printer, skip the job
        if (!pIniPrinter ||
            PrinterStatusBad(pIniPrinter->Status) ||
            (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ||
            (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_OFFLINE)) {

            continue;
        }

        // For direct printing dont consider spooling jobs
        if (( (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_QUEUED) ||
              (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT)  ) &&
            (pIniJob->Status & JOB_SPOOLING)) {

            continue;
        }

        // Check if the job can print immediately
        CurrentTime = GetCurrentTimeInSeconds();
        SecsToWait = GetTimeToWait(CurrentTime, pIniPrinter, pIniJob);
        if (SecsToWait != 0) {
            continue;
        }

        // Check if any port attached to this printer can print this job
        for (dwIndex = 0;
             dwIndex < pIniPrinter->cPorts;
             ++dwIndex) {

           pIniPort = pIniPrinter->ppIniPorts[dwIndex];

           if (!pIniPort || (pIniPort->Status & PP_ERROR)) {
               continue;
           }

           if (!(pIniPort->Status & PP_FILE) &&
               (pIniJob->Status & JOB_PRINT_TO_FILE)) {
               continue;
           }

           if ((pIniPort->Status & PP_FILE) &&
               !(pIniJob->Status & JOB_PRINT_TO_FILE)) {
               continue;
           }

           // Check if the port is already processing some job
           if ( (pIniPort->pIniJob) &&
               !(pIniPort->Status & PP_WAITING )){
               continue;
           }

           // Check if the port has some chained jobs other than the current one
           if ((pIniPort->Status & PP_THREADRUNNING) &&
               (pIniPort->Status & PP_WAITING)) {

               if ((pIniPort->pIniJob != NULL) &&
                   (pIniPort->pIniJob != pIniJob)) {
                   continue;
               } else {
                   // We have found a port and a job to schedule
                   break;
               }
           }
        }

        if (dwIndex < pIniPrinter->cPorts) {
            // We have a port and job
            bReturn = TRUE;
            pJobData->dwNumberOfTries += 1;
            *ppIniJob = pIniJob;
            *ppIniPort = pIniPort;
            break;
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\separate.c ===
/********************************************************************/
/**                Microsoft NT printing - separator pages         **/
/********************************************************************/

#include <precomp.h>
#pragma hdrstop

#define _CTYPE_DISABLE_MACROS
#include <wingdip.h>
#include <winbasep.h>


/* this is max. no. of chars to be printed on a line */
/* these numbers must be taken from somewhere else */
#define MAXLINE      256
#define DEFAULT_LINE_WIDTH 80

#define BLOCK_CHAR_HEIGHT 16
#define BLOCK_CHAR_WIDTH  8
#define BLOCK_CHAR_DWIDTH 16

#define NORMAL_MODE  'U'
#define BLOCK_START  'B'
#define SINGLE_WIDTH 'S'
#define DOUBLE_WIDTH 'M'
#define TEXT_MODE    'L'
#define WIDTH_CHANGE 'W'
#define END_PAGE     'E'
#define FILE_INSERT  'F'
#define USER_NAME    'N'
#define JOB_ID       'I'
#define DATE_INSERT  'D'
#define TIME_INSERT  'T'
#define HEX_CODE     'H'

/* global structure (instance data) */
typedef struct {
   PSPOOL   pSpool;
   HANDLE   hFile;
   HANDLE   hFileMapping;
   DWORD    dwFileCount;
   DWORD    dwFileSizeLo;
   DWORD    cbOutBufLength;
   DWORD    cbLineLength;
   DWORD    linewidth;
   char     *OutBuf;
   char     *pOutBufPos;
   char     *pNextFileChar;
   char     *pFileStart;
   char     mode;
   char     cEsc;
   char     cLastChar; // Used to store DBCS lead byte.
   HDC      hDCMem;    // Used to create Kanji banner char.
   HFONT    hFont;     // Used to create Kanji banner char.
   HBITMAP  hBitmap;   // Used to create Kanji banner char.
   PVOID    pvBits;    // Used to create Kanji nanner char.
} GLOBAL_SEP_DATA;

/* static variables */
static char *szDefaultSep = "@@B@S@N@4 @B@S@I@4  @U@L   @D@1 @E";
static char *sznewline = "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n";
static LPWSTR szDefaultSepName = L"DEFAULT.SEP";

/* Forward declarations */
int OpenSepFile(GLOBAL_SEP_DATA *, LPWSTR);
int CloseSepFile(GLOBAL_SEP_DATA *);
int ReadSepChar(GLOBAL_SEP_DATA *);
void UngetSepChar(GLOBAL_SEP_DATA *, int);
int WriteSepBuf(GLOBAL_SEP_DATA *, char *, DWORD);
int DoSeparatorPage(GLOBAL_SEP_DATA *);
int AddNormalChar(GLOBAL_SEP_DATA *, int);
int AddBlockChar(GLOBAL_SEP_DATA *, int);
int FlushOutBuf(GLOBAL_SEP_DATA *);
int FlushNewLine(GLOBAL_SEP_DATA *);
void ReadFileName(GLOBAL_SEP_DATA *, char *, DWORD);
int ConvertAtoH(int);
void ConvertTimetoChar(LPSYSTEMTIME,char *);
void ConvertDatetoChar(LPSYSTEMTIME,char *);

/**************************************************************\
** DoSeparator(pSpool)
**   This function is called by the spooler.  It is the
**   entry point for the separator page code.  It opens the
**   separator page file, processes it, sends the output
**   directly to the printer, and then returns control
**   to the spooler.
**
**   RETURN VALUE: 1 = OK, 0 = error
\**************************************************************/
int DoSeparator(
   PSPOOL pSpool
   )

{
   GLOBAL_SEP_DATA g = {0};
   int status;

   g.pSpool = pSpool;

   if (!OpenSepFile(&g, pSpool->pIniJob->pIniPrinter->pSepFile)) {
      return(0);
   }
   //
   // We used to call OpenProfileUserMapping() and CloseProfileUserMapping()
   // before and after DoSeparatorPage. But they are not multi thread safe
   // and are not needed now that we use SystemTimeToTzSpecificLocalTime
   // instead of GetProfileInt etc..
   //
   status = DoSeparatorPage(&g);
   CloseSepFile(&g);

   if (!status) {
      return(0);
   }
   return(1);
}


/**************************************************************\
** OpenSepFile(pg, szFileName)
**   open file for input.
**   at the moment, this does nothing--stdin and stdout are used
\**************************************************************/
int OpenSepFile(
   GLOBAL_SEP_DATA *pg,
   LPWSTR szFileName
   )
{
   if (!lstrcmpi(szFileName, szDefaultSepName)) {
      /* if szFileName is empty, just use default separator page string */
      pg->hFile = NULL;
      pg->hFileMapping = NULL;
      pg->pFileStart = pg->pNextFileChar = szDefaultSep;
      pg->dwFileSizeLo = strlen(szDefaultSep);
   }
   else {
      HANDLE hImpersonationToken = RevertToPrinterSelf();

      /* otherwise, open the file */
      pg->hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
                             NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

      ImpersonatePrinterClient(hImpersonationToken);

      if (pg->hFile==INVALID_HANDLE_VALUE) {
         return(0);
      }
      pg->dwFileSizeLo = GetFileSize(pg->hFile, NULL); /* assume < 4 GB! */
      pg->hFileMapping = CreateFileMapping(pg->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
      if (!pg->hFileMapping || pg->dwFileSizeLo==-1) {
         CloseSepFile(pg);
         return(0);
      }
      pg->pFileStart =
      pg->pNextFileChar = (char *)
              MapViewOfFile(pg->hFileMapping, FILE_MAP_READ, 0, 0, pg->dwFileSizeLo);
      if (!pg->pFileStart) {
         CloseSepFile(pg);
         return(0);
      }
   } /* end of else (szFileName non-NULL) */

   pg->dwFileCount = 0;

   /* now, allocate local buffer for output */
   pg->OutBuf = (char *)AllocSplMem( BLOCK_CHAR_HEIGHT*(MAXLINE+2) );
   if (!pg->OutBuf) {
      CloseSepFile(pg);
      return(0);
   }
   return(1);
}


/**************************************************************\
** CloseSepFile(pg)
**   close files.
\**************************************************************/
int CloseSepFile(GLOBAL_SEP_DATA *pg)
{
   if (pg->OutBuf) {
      FreeSplMem(pg->OutBuf);
   }
   if (pg->hFileMapping) {
      if (pg->pFileStart) {
         UnmapViewOfFile(pg->pFileStart);
      }
      CloseHandle(pg->hFileMapping);
   }
   if (pg->hFile) {
      CloseHandle(pg->hFile);
   }
   return(1);
}


/**************************************************************\
** ReadSepChar(pg)
**   reads a character from the separator file and returns it
\**************************************************************/
int ReadSepChar(GLOBAL_SEP_DATA *pg)
{
   if (pg->dwFileCount >= pg->dwFileSizeLo) {
      return(EOF);
   }
   pg->dwFileCount++;
   return(*pg->pNextFileChar++);
}


/**************************************************************\
** UngetSepChar(pg, c)
**   ungets a character to the separator file
\**************************************************************/
void UngetSepChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   if (c != EOF && pg->dwFileCount) {
      pg->dwFileCount--;
      pg->pNextFileChar--;
   }
}

/**************************************************************\
** WriteSepBuf(pg, str, cb)
**   write cb bytes of a string to the printer
\**************************************************************/
int WriteSepBuf(
   GLOBAL_SEP_DATA *pg,
   char *str,
   DWORD cb
   )
{
   DWORD cbWritten;

   return(LocalWritePrinter(pg->pSpool, str, cb, &cbWritten)
          && (cbWritten==cb)
         );
}


/**************************************************************\
** FlushOutBuf(pg)
**   flush the output buffer (block or line mode)
**   WHAT'S TRICKY HERE IS THAT IF WE'RE IN LINE MODE, WE SIMPLY
**   WRITE THE STUFF TO THE FILE, WHEREAS IF WE'RE IN BLOCK
**   CHARACTER MODE, WE FORCE CARRIAGE-RETURN / LINEFEEDS ON
**   EACH OF THE EIGHT BUFFERED LINES THAT MAKE UP THE BLOCK
**   CHARACTERS; i.e., FlushOutBuf() SERVES AS AN EOL IN BLOCK
**   MODE, BUT NOT IN LINE MODE.
**
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int FlushOutBuf(GLOBAL_SEP_DATA *pg)
{
   int i,status = TRUE;
   char *pBlkLine;

   if (!pg->cbOutBufLength) {
      return(TRUE);
   }
   if (pg->mode == NORMAL_MODE) {
      /* write out entire buffer at once */
      status = WriteSepBuf(pg, pg->OutBuf, pg->cbOutBufLength);
   }
   else {
      /* BLOCK MODE:
       * force carriage-return and linefeed on all eight lines
       */
      pBlkLine = pg->OutBuf;
      for (i=0; (i < BLOCK_CHAR_HEIGHT) && status; i++) {
         *pg->pOutBufPos     = '\r';
         *(pg->pOutBufPos+1) = '\n';
         status = WriteSepBuf(pg, pBlkLine, pg->cbLineLength+2);
         pg->pOutBufPos += MAXLINE+2;
         pBlkLine   += MAXLINE+2;
      }
      pg->cbLineLength = 0;
   }

   pg->pOutBufPos = pg->OutBuf;
   pg->cbOutBufLength = 0;
   return(status);
}


/**************************************************************\
** FlushNewLine(pg)
**   Starts a new line: if BLOCK MODE, just do FlushOutBuf();
**   if not, send a '\r' '\n' combination, then flush.
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int FlushNewLine(GLOBAL_SEP_DATA *pg)
{
   if (pg->mode==NORMAL_MODE && pg->cbLineLength) {
      if (!AddNormalChar(pg,'\r')) return(FALSE);
      if (!AddNormalChar(pg,'\n')) return(FALSE);
   }
   return(FlushOutBuf(pg));
}


/**************************************************************\
** AddNormalChar(pg, c)
**   add a character to the output buffer (not block mode)
**   - return TRUE means ok
**   - return FALSE means problem
\**************************************************************/
int AddNormalChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   if (c=='\n') {
      /* reset line length count */
      pg->cbLineLength = 0;
   }
   else {
      if (isprint(c) && (++(pg->cbLineLength) > pg->linewidth)) {
         return(TRUE);
      }
   }

   *pg->pOutBufPos++ = (CHAR) c;
   if (++(pg->cbOutBufLength) == BLOCK_CHAR_HEIGHT*(MAXLINE+2)) {
      return(FlushOutBuf(pg));
   }

   return(TRUE);

} /* end of AddNormalChar() */


/**************************************************************\
** AddBlockChar(pg, c)
**   add a character to the output buffer (block mode)
**   return TRUE means ok
**   return FALSE means problem
\**************************************************************/
int AddBlockChar(
   GLOBAL_SEP_DATA *pg,
   int c
   )
{
   int w;
   register int i,k;
   register char *p;
   unsigned char cBits, *pcBits;
   char cBlkFill;
   register int j;
   unsigned char *pcBitsLine;
   HBITMAP hBitmapOld;
   HFONT   hFontOld;
   CHAR    aTextBuf[2];
   SHORT   sTextIndex = 0;
   ULONG   cjBitmap;
   ULONG   cjWidth = BLOCK_CHAR_WIDTH;

#define CJ_DIB16_SCAN(cx) ((((cx) + 15) & ~15) >> 3)
#define CJ_DIB16( cx, cy ) (CJ_DIB16_SCAN(cx) * (cy))

   if( pg->cLastChar == (CHAR)NULL && IsDBCSLeadByte((CHAR)c) ) {
       pg->cLastChar = (CHAR) c;
       return(TRUE);
   }

   if(pg->hDCMem == NULL) {
       pg->hDCMem = CreateCompatibleDC(NULL);
       if (pg->hDCMem == NULL)
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->hBitmap == NULL) {
       pg->hBitmap = CreateCompatibleBitmap(pg->hDCMem,BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT);
       if ( pg->hBitmap == NULL )
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->pvBits == NULL) {
       pg->pvBits = AllocSplMem(CJ_DIB16(BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT));
       if ( pg->pvBits == NULL )
       {
           //
           // Only happens when memory is exhausted. Functionality may suffer
           // but we won't AV.
           //
           return FALSE;
       }
   }

   if(pg->hFont == NULL) {
       LOGFONT lf;

       ZeroMemory(&lf, sizeof(lf));

       lf.lfHeight = BLOCK_CHAR_HEIGHT;
       lf.lfWidth  = ( pg->mode == DOUBLE_WIDTH ) ?
                          BLOCK_CHAR_DWIDTH :
                          BLOCK_CHAR_WIDTH;

       lf.lfWeight = FW_NORMAL;
       lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
       lf.lfCharSet = DEFAULT_CHARSET;

       pg->hFont = CreateFontIndirect(&lf);
   }

   hBitmapOld = SelectObject(pg->hDCMem,pg->hBitmap);
   hFontOld   = SelectObject(pg->hDCMem,pg->hFont);

   if( pg->cLastChar != (CHAR) NULL ) {
       aTextBuf[sTextIndex] = pg->cLastChar;
       sTextIndex ++;
       cjWidth = BLOCK_CHAR_DWIDTH;
   }

   aTextBuf[sTextIndex] = (CHAR) c;

   PatBlt(pg->hDCMem,0,0,BLOCK_CHAR_DWIDTH,BLOCK_CHAR_HEIGHT,WHITENESS);
   TextOutA(pg->hDCMem,0,0,aTextBuf,sTextIndex+1);

   GetBitmapBits(pg->hBitmap,CJ_DIB16(cjWidth,BLOCK_CHAR_HEIGHT),pg->pvBits);

   SelectObject(pg->hDCMem,hBitmapOld);
   SelectObject(pg->hDCMem,hFontOld);

   w = (pg->mode==DOUBLE_WIDTH)? cjWidth * 2 : cjWidth;
   if (pg->cbLineLength+w > pg->linewidth) {
      return(TRUE);
   }

   cBlkFill = '#';

   pcBitsLine = (unsigned char *) pg->pvBits;
   for (i = 0 ;
        i < BLOCK_CHAR_HEIGHT;
        i++, pcBitsLine += CJ_DIB16_SCAN(BLOCK_CHAR_DWIDTH)) {

      /* put block character into buffer line by line, top first */

      pcBits = pcBitsLine;

      p = pg->pOutBufPos + i * (MAXLINE+2);

      cBits = *pcBits;
      j = 0;
      for (k = cjWidth; k--; ) {
         if (pg->mode==DOUBLE_WIDTH) {
             *p = *(p+1) = (cBits & 0x80)? ' ' : cBlkFill;
             p += 2;
         } else {
             *p++ = (cBits & 0x80)? ' ' : cBlkFill;
         }
         cBits <<= 1;
         j++;
         if( j==8 ) {
             pcBits++; cBits = *pcBits; j = 0;
         }
      }

   } /* end of loop through lines of block char */

   pg->cLastChar = (CHAR) NULL;
   pg->pOutBufPos += w;
   pg->cbLineLength += w;
   pg->cbOutBufLength += w;
   return(TRUE);

} /* end of AddBlockChar() */


/**************************************************************\
** DoSeparatorPage(pg)
**   this is the actual processing
\**************************************************************/
int DoSeparatorPage(GLOBAL_SEP_DATA *pg)
{
   int status = TRUE;
   int c;
   char *pchar;
   WCHAR *pwchar;
   char tempbuf[MAX_PATH]; /* assume length of date, time, or job_id < MAXPATH */
   int (*AddCharFxn)() = AddNormalChar;

   if ((c = ReadSepChar(pg))==EOF) {
      return(TRUE);
   }
   pg->linewidth = DEFAULT_LINE_WIDTH;
   pg->cEsc = (CHAR) c;
   pg->pOutBufPos = pg->OutBuf;
   pg->cbOutBufLength = 0;
   pg->cbLineLength = 0;
   pg->mode = NORMAL_MODE;
   pg->hDCMem = (HDC) NULL;
   pg->hFont = (HFONT) NULL;
   pg->hBitmap = (HBITMAP) NULL;
   pg->cLastChar = (CHAR) NULL;
   pg->pvBits = (PVOID) NULL;

   while (status && ((c=ReadSepChar(pg))!=EOF) ) {

      /* find the next escape sequence */
      if (c != pg->cEsc) continue;

      /* found an escape character: now, check the next character */
      if ((c=ReadSepChar(pg))==EOF) {
         break;
      }

      switch (c) {
      case TEXT_MODE:
         if (pg->mode==NORMAL_MODE) {
            while (status && ((c=ReadSepChar(pg)) != EOF)) {
               if (c!=pg->cEsc) {
                  status = AddNormalChar(pg, c);
               }
               else {
                  /* This is to treat <esc><esc> as a normal char */
                  c = ReadSepChar(pg);
                  if (c==pg->cEsc) {
                     status = AddNormalChar(pg, c);
                  }
                  else {
                     UngetSepChar(pg, c);
                     UngetSepChar(pg, pg->cEsc);
                     break; /* breaks from the while, returns to main loop */
                  }
               }
            }
         } /* end of NORMAL_MODE processing */

         else {
            while (status && ((c=ReadSepChar(pg))!=EOF)) {
               if (c=='\n') {
                  status = FlushOutBuf(pg);
               }
               else if (c=='\r') {
                  /* if followed by '\n', ignore.
                   * Otherwise, AddBlockChar() the '\r'.
                   */
                  c = ReadSepChar(pg);
                  if (c!='\n') {
                     status = AddBlockChar(pg, '\r');
                  }
                  UngetSepChar(pg, c);
               }
               else {
                  if (c==pg->cEsc) {
                     /* This is to treat <esc><esc> as a normal char */
                     c = ReadSepChar(pg);
                     if (c==pg->cEsc) {
                        status = AddBlockChar(pg, c);
                     }
                     else {
                        UngetSepChar(pg, c);
                        UngetSepChar(pg, pg->cEsc);
                        break; /* breaks from the while, returns to main loop */
                     }
                  }
                  else {
                     status = AddBlockChar(pg, c);
                  }
               }
            }
         } /* end of BLOCK mode processing */

         break;

      case BLOCK_START:
      case SINGLE_WIDTH:
      case DOUBLE_WIDTH:
      case NORMAL_MODE:
         status = FlushNewLine(pg);
         pg->mode = (CHAR) c;
         AddCharFxn = (pg->mode==NORMAL_MODE)? AddNormalChar : AddBlockChar;
         break;

      case USER_NAME:
         pwchar = pg->pSpool->pIniJob->pUser;

         if (pwchar) {
             char *pchar;
             UNICODE_STRING UnicodeString;
             ANSI_STRING    AnsiString;

             RtlInitUnicodeString(&UnicodeString, pwchar);
             RtlUnicodeStringToAnsiString(&AnsiString ,&UnicodeString, TRUE);

             pchar = AnsiString.Buffer;

             if ( pchar )
             {
                 while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
             }

             RtlFreeAnsiString(&AnsiString);
         }
         break;

      case DATE_INSERT:
         ConvertDatetoChar(&pg->pSpool->pIniJob->Submitted, tempbuf);
         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case TIME_INSERT:
         ConvertTimetoChar(&pg->pSpool->pIniJob->Submitted, tempbuf);
         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case JOB_ID:

         StringCchPrintfA(tempbuf, COUNTOF(tempbuf), "%d", pg->pSpool->pIniJob->JobId);

         pchar = tempbuf;
         while (*pchar && status) status = (*AddCharFxn)(pg, *pchar++);
         break;

      case HEX_CODE:
         /* print a control character--read the hexadecimal code */

         c = ReadSepChar(pg);
         if (isxdigit(c)) {
            int c2 = ReadSepChar(pg);
            if (isxdigit(c2)) {
               c = (char)((ConvertAtoH(c) << 4) + ConvertAtoH(c2));
               status = (*AddCharFxn)(pg, c);
            }
            else {
               UngetSepChar(pg, c2);
               /* perhaps shouldn't do this? If they say @Hxx,
                * implying xx is a hexadecimal code, and the second
                * x is not a hex digit, should we leave that char
                * on the input line to be interpreted next, or should
                * we skip it?  This only matters if it was an escape char,
                * i.e. @Hx@....  Right now, the second @ is considered
                * the start of a new command, and the @Hx is ignored
                * entirely.  The same applies for the UngetSepChar() below.
                */
            }
         }
         else {
            UngetSepChar(pg, c);
         }
         break;

      case WIDTH_CHANGE:
         {
         /* read the decimal number; change line width if reasonable */
         int new_width = 0;

         for (c = ReadSepChar(pg); isdigit(c); c = ReadSepChar(pg)) {
            new_width = 10 * new_width + c - '0';
         }
         UngetSepChar(pg, c);

         if (new_width <= MAXLINE) {
            pg->linewidth = new_width;
         }
         else {
            pg->linewidth = MAXLINE;
         }

         break;
         }

      case '9':
      case '8':
      case '7':
      case '6':
      case '5':
      case '4':
      case '3':
      case '2':
      case '1':
      case '0':
         if (pg->mode==NORMAL_MODE) {
            status = AddNormalChar(pg,'\n');
         }
         if (status) status = FlushOutBuf(pg);
         if (status) status = WriteSepBuf(pg, sznewline, 2*(c-'0'));
         break;

      case END_PAGE:
         /* this just outputs a formfeed character */
         status = FlushNewLine(pg);
         if (status) status = WriteSepBuf(pg, "\f",1);
         break;

      case FILE_INSERT:
         {
         HANDLE hFile2, hMapping2;
         DWORD dwSizeLo2;
         char *pFirstChar;
         HANDLE hImpersonationToken;

         if (!(status = FlushNewLine(pg))) {
            break;
         }
         ReadFileName(pg, tempbuf, sizeof(tempbuf));

         hImpersonationToken = RevertToPrinterSelf();

         hFile2 = CreateFileA(tempbuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

         ImpersonatePrinterClient(hImpersonationToken);

         if (hFile2 != INVALID_HANDLE_VALUE) {
            dwSizeLo2 = GetFileSize(hFile2, NULL); /* assume < 4 gigabytes! */
            hMapping2 = CreateFileMapping(hFile2,NULL,PAGE_READONLY,0,0,NULL);
            if (hMapping2 && (dwSizeLo2 > 0)) {
               pFirstChar = (char *)
                     MapViewOfFile(hMapping2, FILE_MAP_READ, 0, 0, dwSizeLo2);
               if (pFirstChar) {
                  status = WriteSepBuf(pg, pFirstChar, dwSizeLo2);
                  UnmapViewOfFile(pFirstChar);
               }
               CloseHandle(hMapping2);
            }
            CloseHandle(hFile2);
         }

         /* NOTE: if couldn't open file, or error while reading file,
          * status is NOT set to false.  We will simply stop the file
          * insert operation, and continue processing the rest of the
          * the separator page as before.
          */
         else {
            DBGMSG(DBG_WARNING, ("SEPARATOR PAGE: Could not open file %s \n",tempbuf));
         }

         break;
         }


      default:
         break;

      }

   } /* end of main while loop...find next escape sequence, process */

   if (status) status = FlushOutBuf(pg);

   if (pg->hDCMem != (HDC) NULL) DeleteDC(pg->hDCMem);
   if (pg->hFont != (HFONT) NULL) DeleteObject(pg->hFont);
   if (pg->hBitmap != (HBITMAP) NULL) DeleteObject(pg->hBitmap);
   if (pg->pvBits != (PVOID) NULL) FreeSplMem(pg->pvBits);

   return(status);

} /* end of DoSeparatorPage() */


/**************************************************************\
** ConvertAtoH(c)
**   Converts an ASCII character to hexadecimal.
\**************************************************************/
int ConvertAtoH(int c)
{
   return( c - (isdigit(c)? '0' :
                ((isupper(c)? 'A':'a') - 10)));
}


/**************************************************************\
** ConvertTimetoChar()
**   converts system time to a string  (internationalized).
\**************************************************************/
void  ConvertTimetoChar(
   SYSTEMTIME *pSystemTime,
   char *string
   )
{
SYSTEMTIME LocalTime;
LCID lcid;
    // Convert to local time
    SystemTimeToTzSpecificLocalTime(NULL, pSystemTime, &LocalTime);
    // Get lcid of local machine
    lcid=GetSystemDefaultLCID();
    // Convert to string, , using default format for that locale

    GetTimeFormatA(lcid, 0, &LocalTime, NULL, string, MAX_PATH-1);
}

/**************************************************************\
** ConvertDatetoChar()
**   converts system date to a string  (internationalized).
\**************************************************************/
void  ConvertDatetoChar(
   SYSTEMTIME *pSystemTime,
   char *string
   )
{
SYSTEMTIME LocalTime;
LCID lcid;
    // Convert to local time
    SystemTimeToTzSpecificLocalTime(NULL, pSystemTime, &LocalTime);
    // Get lcid of local machine
    lcid = GetSystemDefaultLCID();
    // Convert to string, using default format for that locale
    GetDateFormatA(lcid, 0, &LocalTime, NULL, string, MAX_PATH-1);
}

/**************************************************************\
** ReadFileName(pg, szfilename, dwbufsize)
**   parses a filename from the separator file (following <esc>F).
**   the following scheme is used:
**
**   - read until a single escape, EOF, newline, or carriage return
**     is encountered.  Put this string into a temporary buffer,
**     passed by the calling function.
**
**   - if string begins with a double quote, skip this double quote,
**     and consider the double quote character as an end of string
**     marker, just like the newline.  Thus, @F"myfile
**     will be read as @Fmyfile
**
\**************************************************************/
void ReadFileName(
   GLOBAL_SEP_DATA *pg,
   char *szfilename,
   DWORD dwbufsize
   )
{
   char *pchar = szfilename;
   char c;
   DWORD dwcount = 0;
   BOOL bNotQuote = TRUE;

   if ((pg->dwFileCount < pg->dwFileSizeLo) && (*pg->pNextFileChar=='\"')) {
      pg->dwFileCount++;
      pg->pNextFileChar++;
      bNotQuote = FALSE;
   }
   while ((dwcount < dwbufsize - 1) && (pg->dwFileCount < pg->dwFileSizeLo) && (c=*pg->pNextFileChar)!='\n'
          && c!='\r' && (bNotQuote || c!='\"')) {
      if (c!=pg->cEsc) {
         *pchar++ = c;
         dwcount++;
         pg->pNextFileChar++;
         pg->dwFileCount++;
      }
      else {
         if ((pg->dwFileCount+1) < pg->dwFileSizeLo
               && *(pg->pNextFileChar+1)==pg->cEsc) {
            *pchar++ = pg->cEsc;
            dwcount++;
            pg->pNextFileChar+=2;
            pg->dwFileCount+=2;
         }
         else {
            break;
         }
      }
   } /* end of loop to read characters */

   *pchar = '\0';

} /* end of ReadFileName() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\splmrg.h ===
BOOL LocalMonInit(
    HANDLE hModule
);

LPMONITOR2 LocalMonInitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\setprn.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    setprn.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    management for the Local Print Providor

    SplSetPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991


Revision History:

    Muhunthan Sivapragasam (MuhuntS) 25-Aug-95
        -- support for level 4, and PRINTER_CONTROL_SET_STATUS.
        -- eliminate duplicate code
    Muhunthan Sivapragasam (MuhuntS) 18-Jun-1995 -- PeinterInfo5 changes
    Krishna Ganugapati (KrishnaG) 1-Jun-1994 -- rewrote these functions.
    SWilson - Added SetPrinter Level 7

--*/
#define NOMINMAX
#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

#define     PRINTER_NO_CONTROL          0x00

typedef enum {
    SECURITY_SUCCESS = 0,
    SECURITY_NOCHANGE = 1,
    SECURITY_FAIL = 2
} PRINTER_SECURITY_STATUS;

PRINTER_SECURITY_STATUS
SetPrinterSecurity(
    SECURITY_INFORMATION SecurityInformation,
    PINIPRINTER          pIniPrinter,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

VOID
RegClearKey(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    );

DWORD
ValidatePrinterAttributes(
    DWORD   SourceAttributes,
    DWORD   OriginalAttributes,
    LPWSTR  pDatatype,
    LPBOOL  pbValid,
    BOOL    bSettableOnly
    );

BOOL
ChangePrinterAttributes(
    DWORD       dNewAttributes,
    DWORD       dOldAttributes,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPWSTR      pszNewShareName,
    BOOL        bShareRecreate,
    BOOL        bShareUpdate
    );

BOOL
NewPort(
    PKEYDATA    pKeyData,
    PINIPRINTER pIniPrinter
);

BOOL
SplSetPrinterExtraEx(
    HANDLE  hPrinter,
    DWORD   dwPrivateFlag
)
{
    BOOL    ReturnValue = FALSE;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        pSpool->pIniPrinter->dwPrivateFlag = dwPrivateFlag;
        ReturnValue = TRUE;
    }

    LeaveSplSem();

    return  ReturnValue;
}

BOOL
SplGetPrinterExtraEx(
    HANDLE  hPrinter,
    LPDWORD pdwPrivateFlag
)
{
    BOOL   ReturnValue = FALSE;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    if ((pSpool != NULL) &&
        (pSpool != INVALID_HANDLE_VALUE) &&
        ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER) &&
        pdwPrivateFlag) {

        *pdwPrivateFlag = pSpool->pIniPrinter->dwPrivateFlag;
        ReturnValue = TRUE;
    }

    LeaveSplSem();

    return  ReturnValue;
}


BOOL
SplSetPrinterExtra(
    HANDLE  hPrinter,
    LPBYTE  pExtraData
)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

   EnterSplSem();

   if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        pSpool->pIniPrinter->pExtraData = pExtraData;
        UpdatePrinterIni( pSpool->pIniPrinter , UPDATE_CHANGEID );
        ReturnValue = TRUE;

    } else {

        ReturnValue = FALSE;

    }

   LeaveSplSem();

    return  ReturnValue;
}



BOOL
SplGetPrinterExtra(
    HANDLE  hPrinter,
    PBYTE   *ppExtraData
)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL   ReturnValue;

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

        *ppExtraData = pSpool->pIniPrinter->pExtraData;
        ReturnValue = TRUE;

    } else {

        ReturnValue = FALSE;

    }

    return  ReturnValue;
}

BOOL
ValidateLevelAndSecurityAccesses(
    PSPOOL pSpool,
    DWORD  Level,
    LPBYTE pPrinterInfo,
    DWORD  Command,
    PDWORD pdwAccessRequired,
    PDWORD pSecurityInformation
    )
{
    DWORD   AccessRequired = 0;
    DWORD   SecurityInformation= 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    //
    // Set pdwAccessRequired = 0 and
    // Set pSecurityInformation = 0;

    *pdwAccessRequired = 0;
    *pSecurityInformation = 0;

    switch (Level) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
        AccessRequired = PRINTER_ACCESS_ADMINISTER;
        break;

    case 2:
        pSecurityDescriptor =
            ((PPRINTER_INFO_2)pPrinterInfo)->pSecurityDescriptor;

        AccessRequired = PRINTER_ACCESS_ADMINISTER;
        if (GetSecurityInformation(pSecurityDescriptor,
                                   &SecurityInformation)) {
            AccessRequired |= GetPrivilegeRequired( SecurityInformation );
        } else {
            //
            // Bug 54918 - We should be returning the false on GetSecurityInformation
            // failing. The reason we're not doing it is because this will break
            // Printman. Printman should pass in Valid security descriptors for Level 2
            // Fix in Printman.
            //
        }
        break;

    case 3:

        pSecurityDescriptor =
            ((PPRINTER_INFO_3)pPrinterInfo)->pSecurityDescriptor;

        if (!pSecurityDescriptor) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if (GetSecurityInformation(pSecurityDescriptor,
                                   &SecurityInformation)) {
            AccessRequired |= GetPrivilegeRequired( SecurityInformation );
        } else {
            // LastError = GetLastError();
            return FALSE;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!AccessGranted(SPOOLER_OBJECT_PRINTER,
                             AccessRequired,
                             pSpool) ) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    *pdwAccessRequired = AccessRequired;
    *pSecurityInformation = SecurityInformation;
    return TRUE;
}

PKEYDATA
CreateAndValidatePortTokenList(
    LPWSTR      pPortName,
    PINISPOOLER pIniSpooler
)
{
    PKEYDATA    pKeyData = CreateTokenList(pPortName);

    if ( pKeyData ) {
        if ( !ValidatePortTokenList(pKeyData, pIniSpooler, FALSE, NULL) ) {

            FreePortTokenList(pKeyData);
            SetLastError(ERROR_UNKNOWN_PORT);
            pKeyData = NULL;
        }
    }

    return pKeyData;
}


BOOL
NewPort(
    PKEYDATA    pKeyData,
    PINIPRINTER pIniPrinter
)
{
    DWORD       i, j;
    BOOL        rc=TRUE;

    if (!pKeyData) {
        SetLastError(ERROR_UNKNOWN_PORT);
        return FALSE;
    }

    // Check if # of requested vs. existing ports differs
    if (pIniPrinter->cPorts != pKeyData->cTokens)
        return TRUE;

    // for each requested port see if printer already has it
    for (i = 0 ; i < pKeyData->cTokens ; ++i) {

        // see if requested port is already assigned to printer
        for (j = 0 ; j < pIniPrinter->cPorts &&
            wcscmp(pIniPrinter->ppIniPorts[j]->pName, ((PINIPORT)pKeyData->pTokens[i])->pName)
            ; ++j) {

            DBGMSG(DBG_TRACE,("NewPort (Existing vs. Requested): \"%ws\" ?= \"%ws\"\n",
            pIniPrinter->ppIniPorts[j]->pName, ((PINIPORT)pKeyData->pTokens[i])->pName));
        }

        if (j == pIniPrinter->cPorts) { // found new port, so return
            DBGMSG(DBG_TRACE,("NewPort FOUND: \"%ws\"\n", ((PINIPORT)pKeyData->pTokens[i])->pName));
            return TRUE;
        }
    }

    return FALSE;
}



VOID
ChangePrinterName(
    LPWSTR      pszNewName,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPDWORD     pdwPrinterVector
    )

/*++

Routine Description:

    Changes printer name

Arguments:

    pszNewName - New printer name allocated using AllocSplStr

    pIniPrinter - for the printer we changing name

    pIniSpooler - Spooler that owns printer

    pdwPrinterVector - pointer to notification vector

Return Value:

    nothing

--*/

{
    LPWSTR pNewName, pOldName;

    //
    // Before deleting the printer entry make sure you copy
    // all information with respect to the printer to the registry
    // There could be several levels of keys.
    //

    CopyPrinterIni(pIniPrinter, pszNewName);
    DeletePrinterIni(pIniPrinter);

    pOldName = pIniPrinter->pName;
    pIniPrinter->pName = pszNewName;

    *pdwPrinterVector |= BIT(I_PRINTER_PRINTER_NAME);

    //
    // Delete the old entries in WIN.INI:
    //
    CheckAndUpdatePrinterRegAll(pIniSpooler,
                                pOldName,
                                NULL,
                                UPDATE_REG_DELETE );

    FreeSplStr(pOldName);

    //
    // If printer is offline we need to write that info back with new name
    //
    if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
        WritePrinterOnlineStatusInCurrentConfig(pIniPrinter);
}

BOOL
SetLocalPrinterSTRESS(
    PINIPRINTER             pIniPrinter,
    PPRINTER_INFO_STRESS    pPrinterSTRESS
)
{

    if ( !pPrinterSTRESS ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Allow the caller to update the counters.
    //
    pIniPrinter->cTotalJobs           = pPrinterSTRESS->cTotalJobs;
    pIniPrinter->cTotalBytes.LowPart  = pPrinterSTRESS->cTotalBytes;
    pIniPrinter->cTotalBytes.HighPart = pPrinterSTRESS->dwHighPartTotalBytes;
    pIniPrinter->MaxcRef              = pPrinterSTRESS->MaxcRef;
    pIniPrinter->cTotalPagesPrinted   = pPrinterSTRESS->cTotalPagesPrinted;
    pIniPrinter->cMaxSpooling         = pPrinterSTRESS->cMaxSpooling;
    pIniPrinter->cErrorOutOfPaper     = pPrinterSTRESS->cErrorOutOfPaper;
    pIniPrinter->cErrorNotReady       = pPrinterSTRESS->cErrorNotReady;
    pIniPrinter->cJobError            = pPrinterSTRESS->cJobError;
    pIniPrinter->dwLastError          = pPrinterSTRESS->dwLastError;
    pIniPrinter->stUpTime             = pPrinterSTRESS->stUpTime;

    pIniPrinter->pIniSpooler->cEnumerateNetworkPrinters =
                pPrinterSTRESS->cEnumerateNetworkPrinters;
    pIniPrinter->pIniSpooler->cAddNetPrinters =
                pPrinterSTRESS->cAddNetPrinters;

    UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );
    return TRUE;

}

BOOL
SetPrinterStatus(
    PINIPRINTER     pIniPrinter,
    DWORD           Status
    )
{
    DWORD   OldStatus = pIniPrinter->Status;

    pIniPrinter->Status &= PRINTER_STATUS_PRIVATE;

    pIniPrinter->Status |= MapPrinterStatus(MAP_SETTABLE, Status);

    if ( PrinterStatusBad(OldStatus)    &&
         !PrinterStatusBad(pIniPrinter->Status) ) {

        CHECK_SCHEDULER();
    }

    SetPrinterChange(pIniPrinter,
                     NULL,
                     NVPrinterStatus,
                     PRINTER_CHANGE_SET_PRINTER,
                     pIniPrinter->pIniSpooler);

    return TRUE;
}

BOOL
SetLocalPrinter0(
    PINIPRINTER     pIniPrinter,
    DWORD           Command
)
{
    DWORD       Change = PRINTER_CHANGE_SET_PRINTER;
    BOOL        bReturn = TRUE;

    INCPRINTERREF( pIniPrinter );

    switch (Command) {

        case PRINTER_CONTROL_PURGE:

            //
            // PurgePrinter always returns TRUE now, still ..
            //
            if ( PurgePrinter(pIniPrinter) )  {

                SplLogEvent(pIniPrinter->pIniSpooler,
                            LOG_WARNING,
                            MSG_PRINTER_PURGED,
                            TRUE,
                            pIniPrinter->pName,
                            NULL );

                Change |= PRINTER_CHANGE_DELETE_JOB;

            } else {

                bReturn = FALSE;
            }
            break;

        case PRINTER_CONTROL_RESUME:

            pIniPrinter->Status &= ~PRINTER_PAUSED;

            CHECK_SCHEDULER();

            UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );

            SplLogEvent(pIniPrinter->pIniSpooler,
                        LOG_WARNING,
                        MSG_PRINTER_UNPAUSED,
                        TRUE,
                        pIniPrinter->pName,
                        NULL );
            //
            // WMI Trace Events.
            //
            {
                //
                // Wmi only knows about jobs, so each job needs to be resumed
                // separately.
                //
                PINIJOB pIniJob = pIniPrinter->pIniFirstJob;
                while (pIniJob)
                {
                    if ( !((pIniJob->Status & JOB_DESPOOLING) ||
                           (pIniJob->Status & JOB_PRINTING)   ||
                           (pIniJob->Status & JOB_PRINTED)    ||
                           (pIniJob->Status & JOB_ABANDON)) )
                    {
                        LogWmiTraceEvent(pIniJob->JobId,
                                         EVENT_TRACE_TYPE_SPL_RESUME, NULL);
                    }
                    pIniJob = pIniJob->pIniNextJob;
                }
            }
            break;

        case PRINTER_CONTROL_PAUSE:

            //
            // You can't pause a fax printer. This locks up the fax server. The
            // fax service also has its own concept of paused.
            //
            if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_FAX)) {

                pIniPrinter->Status |= PRINTER_PAUSED;

                UpdatePrinterIni( pIniPrinter, KEEP_CHANGEID );

                SplLogEvent(pIniPrinter->pIniSpooler,
                            LOG_WARNING,
                            MSG_PRINTER_PAUSED,
                            TRUE,
                            pIniPrinter->pName,
                            NULL);
                //
                // WMI Trace Events
                //
                {
                    //
                    // Wmi only knows about jobs, so each job needs to be paused
                    // separately.
                    //
                    PINIJOB pIniJob = pIniPrinter->pIniFirstJob;
                    while (pIniJob)
                    {
                        //
                        // HANDLE PRINTING DIRECT ???
                        // I don't believe pausing a printer can stop a job already
                        // being sent to the printer.
                        //
                        if ( !((pIniJob->Status & JOB_DESPOOLING) ||
                               (pIniJob->Status & JOB_PRINTING)   ||
                               (pIniJob->Status & JOB_PRINTED)    ||
                               (pIniJob->Status & JOB_ABANDON)) )
                        {
                            LogWmiTraceEvent(pIniJob->JobId,
                                             EVENT_TRACE_TYPE_SPL_PAUSE,
                                             NULL);
                        }
                        pIniJob = pIniJob->pIniNextJob;
                    }
                }
            }
            else {

                bReturn = FALSE;
                SetLastError(ERROR_INVALID_PARAMETER);
            }

            break;

        default:

            SetLastError(ERROR_INVALID_PRINTER_COMMAND);
            bReturn = FALSE;
            break;
    }

    DECPRINTERREF( pIniPrinter );

    if (bReturn) {

        SetPrinterChange(pIniPrinter,
                         NULL,
                         (Command == PRINTER_CONTROL_PURGE) ? NVPurge
                                                            : NVPrinterStatus,
                         Change,
                         pIniPrinter->pIniSpooler);
    }

    return bReturn;
}


BOOL
ValidateSetPrinter2(
    PINIPRINTER     pIniPrinter,
    PINIPRINTER     pTempIniPrinter,
    PPRINTER_INFO_2  pPrinterInfo2
)
/*++

Routine Description:

    Validates and builds request info about a SetPrinter info call for
    Printer information that could be changed only for level2.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is used to gather info about all
                      parameters being changed

    pPrinterInfo2 - the PrinterInfo2 structure being passed in

Return Value:
    TRUE:   If all the validation is succesful
    FALSE:  If validation of one or more request fails

    On succesful return fields which need to be changed will be set in
    pTempIniPrinter. Cleanup of this structure will be done later.

--*/
{
    BOOL            bFail           = FALSE;
    DWORD           LastError       = ERROR_SUCCESS;
    PINIVERSION     pIniVersion     = NULL;
    PINIENVIRONMENT pIniEnvironment = NULL;
    BOOL            bSuccess        = FALSE;

    // Servername can't change
    // Printername handled for level 2, 4, 5

    // Sharenname length validation
    if ( pPrinterInfo2->pShareName && wcslen(pPrinterInfo2->pShareName) > PATHLEN-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Share Name (validation later if required)
    AllocOrUpdateString(&pTempIniPrinter->pShareName,
                        pPrinterInfo2->pShareName,
                        pIniPrinter->pShareName,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    // Port Name for level 2, 5

    // DriverName
    bSuccess = FindLocalDriverAndVersion(pIniPrinter->pIniSpooler,
                                         pPrinterInfo2->pDriverName,
                                         &pTempIniPrinter->pIniDriver,
                                         &pIniVersion);

    if ( !bSuccess ) {

       LastError = ERROR_UNKNOWN_PRINTER_DRIVER;
       goto Cleanup;
    }

    pIniEnvironment = GetLocalArchEnv(pIniPrinter->pIniSpooler);

    //
    // If we have a queue with a KMPD, then we need to let the user manage it,
    // even if the policy for blocking KMPD is enabled. However, if the caller
    // wants to change the printer driver to a KMPD, then we do not allow that
    //
    if (pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver)
    {
        INCDRIVERREF(pTempIniPrinter->pIniDriver);

        if (KMPrintersAreBlocked() &&
            IniDriverIsKMPD(pIniPrinter->pIniSpooler,
                            pIniEnvironment,
                            pIniVersion,
                            pTempIniPrinter->pIniDriver)) {

            SplLogEvent( pIniPrinter->pIniSpooler,
                         LOG_ERROR,
                         MSG_KM_PRINTERS_BLOCKED,
                         TRUE,
                         pIniPrinter->pName,
                         NULL );

            LastError = ERROR_KM_DRIVER_BLOCKED;
            goto Cleanup;
        }
    }

    // Comment length validation
    if ( pPrinterInfo2->pComment && wcslen(pPrinterInfo2->pComment) > PATHLEN-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Comment
    AllocOrUpdateString(&pTempIniPrinter->pComment,
                        pPrinterInfo2->pComment,
                        pIniPrinter->pComment,
                        TRUE,
                        &bFail);

    // Location length validation
    if ( pPrinterInfo2->pLocation && wcslen(pPrinterInfo2->pLocation) > MAX_PATH-1 ){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Location
    AllocOrUpdateString(&pTempIniPrinter->pLocation,
                        pPrinterInfo2->pLocation,
                        pIniPrinter->pLocation,
                        TRUE,
                        &bFail);

    // DevMode at the end

    // SepFile length validation
    if( !CheckSepFile( pPrinterInfo2->pSepFile )) {
        bFail = TRUE;
        LastError = ERROR_INVALID_SEPARATOR_FILE;
    }

    // SepFile
    AllocOrUpdateString(&pTempIniPrinter->pSepFile,
                        pPrinterInfo2->pSepFile,
                        pIniPrinter->pSepFile,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    if ( pIniPrinter->pSepFile != pTempIniPrinter->pSepFile &&
         !CheckSepFile(pPrinterInfo2->pSepFile) ) {

        LastError = ERROR_INVALID_SEPARATOR_FILE;
        goto Cleanup;
    }

    // Print Processor
    pTempIniPrinter->pIniPrintProc = FindPrintProc(
                                         pPrinterInfo2->pPrintProcessor,
                                         pIniEnvironment );

    if ( !pTempIniPrinter->pIniPrintProc ) {

        LastError = ERROR_UNKNOWN_PRINTPROCESSOR;
        goto Cleanup;
    }

    if ( pTempIniPrinter->pIniPrintProc != pIniPrinter->pIniPrintProc )
        pTempIniPrinter->pIniPrintProc->cRef++;

    // Datatype
    if ( !pPrinterInfo2->pDatatype || wcslen(pPrinterInfo2->pDatatype) > MAX_PATH-1) {

        LastError = ERROR_INVALID_DATATYPE;
        goto Cleanup; // Ok to fail ???
    } else {

        AllocOrUpdateString(&pTempIniPrinter->pDatatype,
                            pPrinterInfo2->pDatatype,
                            pIniPrinter->pDatatype,
                            TRUE,
                            &bFail);
    }

    // Parameters length validation
    if (pPrinterInfo2->pParameters && wcslen(pPrinterInfo2->pParameters) > MAX_PATH-1){
        bFail = TRUE;
        LastError = ERROR_INVALID_PARAMETER;
    }

    // Parameters
    AllocOrUpdateString(&pTempIniPrinter->pParameters,
                        pPrinterInfo2->pParameters,
                        pIniPrinter->pParameters,
                        TRUE,
                        &bFail);

    if ( bFail )
        goto Cleanup;

    // SecurityDescriptor for level 2, 3
    // Attributes for level 2, 4, 5

    // Priority
    pTempIniPrinter->Priority = pPrinterInfo2->Priority;
    if ( pTempIniPrinter->Priority != pIniPrinter->Priority &&
         pTempIniPrinter->Priority != NO_PRIORITY &&
         ( pTempIniPrinter->Priority > MAX_PRIORITY ||
           pTempIniPrinter->Priority < MIN_PRIORITY ) ) {

            LastError = ERROR_INVALID_PRIORITY;
            goto Cleanup;
    }
    // Default Priority
    pTempIniPrinter->DefaultPriority = pPrinterInfo2->DefaultPriority;
    if ( pTempIniPrinter->DefaultPriority != pIniPrinter->DefaultPriority &&
         pTempIniPrinter->DefaultPriority != NO_PRIORITY &&
         ( pTempIniPrinter->DefaultPriority > MAX_PRIORITY ||
           pTempIniPrinter->DefaultPriority < MIN_PRIORITY ) ) {

            LastError = ERROR_INVALID_PRIORITY;
            goto Cleanup;
    }

    // Start time
    pTempIniPrinter->StartTime = pPrinterInfo2->StartTime;
    if ( pTempIniPrinter->StartTime != pIniPrinter->StartTime &&
         pTempIniPrinter->StartTime >= ONEDAY ) {

        LastError = ERROR_INVALID_TIME;
        goto Cleanup;
    }

    // Until time
    pTempIniPrinter->UntilTime = pPrinterInfo2->UntilTime;
    if ( pTempIniPrinter->UntilTime != pIniPrinter->UntilTime &&
         pTempIniPrinter->StartTime >= ONEDAY ) {

        LastError = ERROR_INVALID_TIME;
        goto Cleanup;
    }

    // Status for level 0, 2
    // Status can't chg
    // AveragePPM can't chg

Cleanup:
    if ( LastError ) {

        SetLastError(LastError);
        return FALSE;
    }

    if ( bFail )
        return FALSE;

    return TRUE;

}

VOID
ProcessSetPrinter2(
    PINIPRINTER     pIniPrinter,
    PINIPRINTER     pTempIniPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    LPDWORD         pdwPrinterVector,
    PDEVMODE        pDevMode
)
/*++

Routine Description:

    Process SetPrinter for level 2. Only fields which can be changed ONLY
    by level 2 will be processed here. That is: All the fields built by
    ValidateSetPrinter2.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is has all the fields which needs to
                      be set. Other fields will be the same as the previous

    pPrinterInfo2 - the PrinterInfo2 structure being passed in

    pdwPrinterVector - Notification Info

    pDevMode        - New dev mode to be set

Return Value:
    nothing

--*/
{
    HANDLE  hToken;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;
    HKEY    hKey = NULL;
    DWORD   dwResult;

    // Sharename
    if ( pTempIniPrinter->pShareName != pIniPrinter->pShareName ) {

        FreeSplStr(pIniPrinter->pShareName);
        pIniPrinter->pShareName = pTempIniPrinter->pShareName;
        *pdwPrinterVector |= BIT(I_PRINTER_SHARE_NAME);
    }

    // Driver
    if ( pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver) {

        DECDRIVERREF(pIniPrinter->pIniDriver);

        if (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_PRINTER_DRIVER_EVENT)
        {

            hToken = RevertToPrinterSelf();

            dwResult = OpenPrinterKey(pIniPrinter, KEY_READ | KEY_WRITE, &hKey, szPrinterData, TRUE);

            if (dwResult == ERROR_SUCCESS) {

                DeleteSubkeys( hKey, pIniSpooler );
                RegClearKey( hKey, pIniSpooler );
                SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);
            }

            if (hToken)
                ImpersonatePrinterClient(hToken);
        }

        pIniPrinter->pIniDriver = pTempIniPrinter->pIniDriver;
        *pdwPrinterVector |= BIT(I_PRINTER_DRIVER_NAME);
    }

    // Comment
    if ( pTempIniPrinter->pComment != pIniPrinter->pComment ) {

        FreeSplStr(pIniPrinter->pComment);
        pIniPrinter->pComment = pTempIniPrinter->pComment;
        *pdwPrinterVector |= BIT(I_PRINTER_COMMENT);
    }

    // Location
    if ( pTempIniPrinter->pLocation != pIniPrinter->pLocation ) {

        FreeSplStr(pIniPrinter->pLocation);
        pIniPrinter->pLocation = pTempIniPrinter->pLocation;
        *pdwPrinterVector |= BIT(I_PRINTER_LOCATION);
    }

    // DevMode at the end
    if ( CopyPrinterDevModeToIniPrinter(pIniPrinter,
                                        pDevMode) ) {

        *pdwPrinterVector |= BIT(I_PRINTER_DEVMODE);
    }

    // SepFile
    if ( pTempIniPrinter->pSepFile != pIniPrinter->pSepFile ) {

        FreeSplStr(pIniPrinter->pSepFile);
        pIniPrinter->pSepFile = pTempIniPrinter->pSepFile;
        *pdwPrinterVector |= BIT(I_PRINTER_SEPFILE);
    }

    // PrintProcessor
    if ( pIniPrinter->pIniPrintProc != pTempIniPrinter->pIniPrintProc) {

        pIniPrinter->pIniPrintProc->cRef--;

        pIniPrinter->pIniPrintProc = pTempIniPrinter->pIniPrintProc;
        *pdwPrinterVector |= BIT(I_PRINTER_PRINT_PROCESSOR);
    }

    // Datatype
    if ( pIniPrinter->pDatatype != pTempIniPrinter->pDatatype ) {

         FreeSplStr(pIniPrinter->pDatatype);
         pIniPrinter->pDatatype  =   pTempIniPrinter->pDatatype;
         *pdwPrinterVector |= BIT(I_PRINTER_DATATYPE);
    }

    // Parameters
    if ( pIniPrinter->pParameters != pTempIniPrinter->pParameters ) {

        FreeSplStr(pIniPrinter->pParameters);
        pIniPrinter->pParameters  =   pTempIniPrinter->pParameters;
        *pdwPrinterVector |= BIT(I_PRINTER_PARAMETERS);
    }

    // Priority
    if ( pTempIniPrinter->Priority != pIniPrinter->Priority ) {

        pIniPrinter->Priority = pTempIniPrinter->Priority;
        *pdwPrinterVector |= BIT(I_PRINTER_PRIORITY);
    }

    // Default Priority
    if ( pTempIniPrinter->DefaultPriority != pIniPrinter->DefaultPriority ) {

        pIniPrinter->DefaultPriority = pTempIniPrinter->DefaultPriority;
        *pdwPrinterVector |= BIT(I_PRINTER_DEFAULT_PRIORITY);
    }

    // Start time
    if ( pTempIniPrinter->StartTime != pIniPrinter->StartTime ) {

        pIniPrinter->StartTime = pTempIniPrinter->StartTime;
        *pdwPrinterVector |= BIT(I_PRINTER_START_TIME);
    }

    // Until time
    if ( pTempIniPrinter->UntilTime != pIniPrinter->UntilTime ) {

        pIniPrinter->UntilTime = pTempIniPrinter->UntilTime;
        *pdwPrinterVector |= BIT(I_PRINTER_UNTIL_TIME);
    }

}

VOID
CleanupSetPrinter(
    PINIPRINTER pIniPrinter,
    PINIPRINTER pTempIniPrinter,
    PKEYDATA    pKeyData,
    DWORD       Level,
    BOOL        bReturnValue
)
/*++

Routine Description:

    This routine is called at the end of SplSetPrinter call to free up all
    the allocations done to process it which are not needed.

    At the beginning of a SetPrinter we make an identical copy of the
    pIniPrinter in pTempIniPrinter and collect all arguments in there.
    Now if the call is failing each of the arguments collected in there
    need to be freed.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure is has all the fields which needs to
                      be freed. Any field different than pIniPrinter was
                      built part of processing the call and needs to be freed.

    pPrinterInfo2 - built for port info

    bReturnValue - return value of SetPrinter

Return Value:
    nothing

--*/
{

    //
    // We adjust INIPORT, INIDRIVER refcounts. So should be inside the spl sem
    //
    SplInSem();

    FreePortTokenList(pKeyData);

    if ( pTempIniPrinter ) {

        if ( !bReturnValue  && Level == 2 ) {

            if ( pTempIniPrinter->pShareName != pIniPrinter->pShareName )
                FreeSplStr(pTempIniPrinter->pShareName);

            if ( pTempIniPrinter->pComment != pIniPrinter->pComment )
                FreeSplStr(pTempIniPrinter->pComment);

            if ( pTempIniPrinter->pLocation != pIniPrinter->pLocation )
                FreeSplStr(pTempIniPrinter->pLocation);

            if ( pTempIniPrinter->pSepFile != pIniPrinter->pSepFile )
                FreeSplStr(pTempIniPrinter->pSepFile);

            if ( pTempIniPrinter->pDatatype != pIniPrinter->pDatatype )
                FreeSplStr(pTempIniPrinter->pDatatype);

            if ( pTempIniPrinter->pParameters != pIniPrinter->pParameters )
                FreeSplStr(pTempIniPrinter->pParameters);

            if ( ( pTempIniPrinter->pIniDriver != NULL ) &&
                 ( pTempIniPrinter->pIniDriver != pIniPrinter->pIniDriver )) {

                DECDRIVERREF(pTempIniPrinter->pIniDriver);
            }

            if ( ( pTempIniPrinter->pIniPrintProc != NULL ) &&
                 ( pTempIniPrinter->pIniPrintProc != pIniPrinter->pIniPrintProc )) {

                pTempIniPrinter->pIniPrintProc->cRef--;
            }
        }

        FreeSplMem(pTempIniPrinter);
    }

}


BOOL
ValidateAndBuildSetPrinterRequest(
    PINIPRINTER             pIniPrinter,
    PINIPRINTER             pTempIniPrinter,
    LPBYTE                  pPrinterInfo,
    DWORD                   Level,
    SECURITY_INFORMATION    SecurityInformation,
    LPBOOL                  pbSecurityChg,
    LPBOOL                  pbNameChg,
    LPBOOL                  pbAttributeChg,
    LPWSTR                 *ppszNewPrinterName,
    PKEYDATA               *ppKeyData
)
/*++

Routine Description:

    This routine is called to validate a SetPrinter request. We try to as
    much vaidation as possible at the beginning to see the changes are
    possible. The routine will collect all changes requested in the
    pTempIniPrinter structure.

Arguments:

    pIniPrinter -   PINIPRINTER of the printer handle passed in

    pTempIniPrinter - this structure will be used to collect all the
                      changes requested

    pPrinterInfo - PrinterInfo_N structure passed in

    Level - Level of PrinterInfo_N

    SecurityInformation - security information

    pbSecurityChg - this will be set if a security change is requested

    pbNameChg - this will be set if a name change is requested

    pbAttributeChg - this will be set if a attribute change is requested

    ppszNewPrinterName - *ppszNewPrinterName will give the new printer name
                         to be set on a name change
    ppKeyData - *ppKeyData will give the Port token info for a level 2 or 5
                call

Return Value:
    TRUE - if all the validations succeed
    FALSE - a validation fails

--*/
{
    PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_3 pPrinterInfo3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_4 pPrinterInfo4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinterInfo5 = (PPRINTER_INFO_5)pPrinterInfo;
    LPWSTR          pPortName;
    DWORD           dwLastError;
    BOOL            bValid = TRUE;

    switch (Level) {

    case 2:
        pTempIniPrinter->pSecurityDescriptor =
                        pPrinterInfo2->pSecurityDescriptor;

        if ( !ValidateSetPrinter2(pIniPrinter, pTempIniPrinter, pPrinterInfo2) )
            return FALSE;

        pTempIniPrinter->pName = pPrinterInfo2->pPrinterName;

        pPortName   = pPrinterInfo2->pPortName;

        if ( !pTempIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        if ( pIniPrinter->pIniDriver != pTempIniPrinter->pIniDriver ) {

            pPrinterInfo2->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
            if ( pTempIniPrinter->pIniDriver->pIniLangMonitor )
                pPrinterInfo2->Attributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
        }

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo2->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pPrinterInfo2->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;
        break;

    case 3:
        pTempIniPrinter->pSecurityDescriptor = pPrinterInfo3->pSecurityDescriptor;
        if ( !SecurityInformation || !pTempIniPrinter->pSecurityDescriptor ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        break;

    case 4:
        pTempIniPrinter->pName = pPrinterInfo4->pPrinterName;

        if ( !pIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo4->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo4->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pIniPrinter->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;
        break;

    case 5:
        pTempIniPrinter->pName = pPrinterInfo5->pPrinterName;

        pPortName   = pPrinterInfo5->pPortName;

        if ( !pIniPrinter->pIniDriver->pIniLangMonitor )
            pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;

        pTempIniPrinter->Attributes =
                        ValidatePrinterAttributes(pPrinterInfo5->Attributes,
                                                  pIniPrinter->Attributes,
                                                  pIniPrinter->pDatatype,
                                                  &bValid,
                                                  TRUE);

        if (!bValid) {
            return FALSE;
        }

        *pbAttributeChg = pTempIniPrinter->Attributes != pIniPrinter->Attributes;


        //
        // Validate timeout?
        //
        pTempIniPrinter->dnsTimeout = pPrinterInfo5->DeviceNotSelectedTimeout;
        pTempIniPrinter->txTimeout = pPrinterInfo5->TransmissionRetryTimeout;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Validate share name if the shared bit is getting set or share name
    // is being changed
    //
    if ( (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
         ( !(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) ||
           pTempIniPrinter->pShareName != pIniPrinter->pShareName) ) {

        if (gRemoteRPCEndPointPolicy == RpcEndPointPolicyDisabled)
        {
            SetLastError(ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED);
            return FALSE;
        }

        dwLastError = ValidatePrinterShareName(pTempIniPrinter->pShareName,
                                               pIniPrinter->pIniSpooler,
                                               pIniPrinter);
        if ( dwLastError != ERROR_SUCCESS ) {

            SetLastError(dwLastError);
            return FALSE;
        }
    }

    //
    // Is there a security change?
    //
    if ( SecurityInformation && (Level == 2 || Level == 3) ) {

        DWORD   dwSize;
        dwSize = GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);

        if ( dwSize !=
               GetSecurityDescriptorLength(pTempIniPrinter->pSecurityDescriptor) ||
             memcmp(pTempIniPrinter->pSecurityDescriptor,
                     pIniPrinter->pSecurityDescriptor,
                     dwSize) ) {

            *pbSecurityChg = TRUE;
        }
    }

    //
    // Is there a name change?
    //
    if ( Level == 2 || Level == 4 || Level == 5 ) {

        DWORD   LastError;

        if ( !pTempIniPrinter->pName || !*pTempIniPrinter->pName ) {

           SetLastError(ERROR_INVALID_PARAMETER);
           return FALSE;
        }


        //
        // Validate name if a change is requested
        //
        if ( lstrcmpi(pTempIniPrinter->pName, pIniPrinter->pName) ) {

            LastError = ValidatePrinterName(pTempIniPrinter->pName,
                                            pIniPrinter->pIniSpooler,
                                            pIniPrinter,
                                            ppszNewPrinterName);
            if ( LastError != ERROR_SUCCESS ) {

                *ppszNewPrinterName = NULL;
                SetLastError(LastError);
                return FALSE;
            }

            //
            // Check if printer name really changed for remote calls
            //
            if ( lstrcmpi(*ppszNewPrinterName, pIniPrinter->pName) ) {

                *ppszNewPrinterName = AllocSplStr(*ppszNewPrinterName);
                if ( !*ppszNewPrinterName )
                    return FALSE;
                *pbNameChg  = TRUE;
            } else {

                *ppszNewPrinterName = NULL;
            }
        }

        //
        // Validate attributes if a change is requested
        // Don't allow a change from queued to direct or vice versa
        // if there are already jobs on the printer.
        //
        if ( pIniPrinter->cJobs > 0 ) {

            if ( (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) !=
                    (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) ) {

                SetLastError(ERROR_PRINTER_HAS_JOBS_QUEUED);
                return FALSE;
            }
        }
    }

    if ( Level == 2 || Level == 5 ) {

        if ( !pPortName || !*pPortName ) {

           SetLastError(ERROR_UNKNOWN_PORT);
           return FALSE;
        }

        *ppKeyData = CreateAndValidatePortTokenList(pPortName,
                                                   pIniPrinter->pIniSpooler);
        if ( !*ppKeyData )
            return FALSE;
    }

    return TRUE;
}

BOOL
SplSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    DWORD   Command
)
{
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    DWORD           i, LastError = ERROR_SUCCESS;
    DWORD           AccessRequired = 0;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter, pTempIniPrinter = NULL;
    PINISPOOLER     pIniSpooler;
    BOOL            bReturn = TRUE;
    DWORD           dwResult;
    BOOL            bShareUpdate;
    BOOL            bShareRecreate;
    DWORD           dwPrinterVector = 0;
    NOTIFYVECTOR    NotifyVector;
    BOOL            bUpdateDsSpoolerKey = FALSE;
    BOOL            bNewPort;
    BOOL            bDataChanged  = FALSE;
    DWORD           OldAttributes = 0;

    DWORD           dwPrnEvntError = ERROR_SUCCESS;

    PPRINTER_INFO_2 pPrinterInfo2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_3 pPrinterInfo3 = (PPRINTER_INFO_3)pPrinterInfo;
    PPRINTER_INFO_4 pPrinterInfo4 = (PPRINTER_INFO_4)pPrinterInfo;
    PPRINTER_INFO_5 pPrinterInfo5 = (PPRINTER_INFO_5)pPrinterInfo;
    PPRINTER_INFO_7 pPrinterInfo7 = (PPRINTER_INFO_7)pPrinterInfo;
    PRINTER_INFO_7  PrinterInfo7;

    BOOL                    bSecurityChg, bNameChg, bAttributeChg;
    LPWSTR                  pszNewPrinterName = NULL, pszOldPrinterName = NULL;
    PINIJOB                 pIniJob;
    PKEYDATA                pKeyData = NULL;
    PDEVMODE                pDevMode = NULL;
    PINIDRIVER              pIniDriver;
    PINIPRINTPROC           pIniPrintProc;
    SECURITY_INFORMATION    SecurityInformation;

    ZERONV(NotifyVector);

    bSecurityChg = bNameChg = bAttributeChg = FALSE;
    bShareUpdate = bShareRecreate = FALSE;

    //
    // If level != 0 info struct should be non-null, and command 0
    //
    if ( Level && Command ) {

        SetLastError(ERROR_INVALID_PRINTER_COMMAND);
        return FALSE;
    }

    if ( Level && !pPrinterInfo ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    EnterSplSem();
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {

        bReturn = FALSE;
        goto Cleanup;
    }

    //
    // If it is a remote call get default devmode from driver and then update it
    //
    if ( Level == 2 ) {

        pDevMode = pPrinterInfo2->pDevMode;
        if ( pDevMode && (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_DATA) ) {

            //
            // If the driver can't convert devmode user's can't set devmode from remote m/c
            //
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pDevMode,
                                                        NULL,
                                                        NULL,
                                                        CURRENT_VERSION);
        }

    }

    SplInSem();

    pIniSpooler = pIniPrinter->pIniSpooler;

    SPLASSERT(pIniPrinter->signature == IP_SIGNATURE );
    SPLASSERT(pIniSpooler->signature == ISP_SIGNATURE );

    if (pSpool->pIniPrinter->Status & PRINTER_ZOMBIE_OBJECT) {

        LastError = ERROR_PRINTER_DELETED;
        goto Cleanup;
    }

   if ( !ValidateLevelAndSecurityAccesses(pSpool,
                                          Level,
                                          pPrinterInfo,
                                          Command,
                                          &AccessRequired,
                                          &SecurityInformation) ){

        bReturn = FALSE;
        goto Cleanup;
    }


    //
    // Level 7 & publishing levels
    //
    if (Level == 7) {

        if ( !(pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE)) {

            if (pPrinterInfo7->dwAction != DSPRINT_PUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_REPUBLISH &&
                pPrinterInfo7->dwAction != DSPRINT_UPDATE) {
                LastError = ERROR_INVALID_PARAMETER;
                bReturn = FALSE;
                goto Cleanup;
            }

            DBGMSG(DBG_EXEC, ("SplSetPrinter: DS Action %d: %ws %ws",
                              pPrinterInfo7->dwAction,
                              pIniPrinter->pName,
                              pIniPrinter->pszObjectGUID ?
                                  pIniPrinter->pszObjectGUID : L"<NULL>"));

            bUpdateDsSpoolerKey = TRUE;

        } else {

            //
            // For connections, we rely directly on pPrinterInfo7->dwAction because
            // then we cannot determine a pending publishing state based on attributes and GUID.
            // If the remote printer is in Pending publishing, we need to save this in dwAction.
            //
            if (!pIniPrinter->pszObjectGUID || !pPrinterInfo7->pszObjectGUID) {

                FreeSplStr(pIniPrinter->pszObjectGUID);
                pIniPrinter->pszObjectGUID = NULL;
                dwPrinterVector |= BIT(I_PRINTER_OBJECT_GUID);

            } else if (wcscmp(pIniPrinter->pszObjectGUID, pPrinterInfo7->pszObjectGUID)) {

                FreeSplStr(pIniPrinter->pszObjectGUID);
            }

            if ( pPrinterInfo7->pszObjectGUID ) {

                if (!(pIniPrinter->pszObjectGUID = AllocSplStr(pPrinterInfo7->pszObjectGUID))) {
                    bReturn = FALSE;
                    goto Cleanup;
                }
            }

            pIniPrinter->dwAction = pPrinterInfo7->dwAction;
            dwPrinterVector |= BIT(I_PRINTER_OBJECT_GUID);

        }
        goto Finish;

    } else if (Level != 3 && Level != 0) {
        bUpdateDsSpoolerKey = TRUE;
    }



    //
    // We need to do this for Level 0, 2, 3, 4, 5
    // (except for level 3 which is security case)
    //
    if ( Level != 3 && pSpool->hPort ) {

        if ( pSpool->hPort == INVALID_PORT_HANDLE ) {

            //
            // If this value is 0, then when we return GetLastError,
            // the client will think we succeeded.
            //
            SPLASSERT( pSpool->OpenPortError );

            LastError = pSpool->OpenPortError;
            goto Cleanup;

        } else {

            bReturn = SetPrinter(pSpool->hPort,
                                 Level,
                                 pPrinterInfo,
                                 Command);

            if ( !Level )
                goto Cleanup;
        }
    }

    if ( Level != 6 && Level != 0 ) {

        pTempIniPrinter = (PINIPRINTER) AllocSplMem(sizeof(INIPRINTER));
        if ( !pTempIniPrinter )
            goto Cleanup;

        CopyMemory(pTempIniPrinter, pIniPrinter, sizeof(INIPRINTER));
    }

    //
    // The actual processing begins here
    //
    if ( !Level && !Command ) {

        bReturn = SetLocalPrinterSTRESS(pIniPrinter,
                                        (PPRINTER_INFO_STRESS)pPrinterInfo);
        goto Cleanup;
    } else if ( !Level ) {

        bReturn = SetLocalPrinter0(pIniPrinter, Command);
        goto Cleanup;
    } else if ( Level == 6 ) {

        bReturn = SetPrinterStatus(pIniPrinter,
                                   ((LPPRINTER_INFO_6)pPrinterInfo)->dwStatus);
        goto Cleanup;
    } else {

        if ( !ValidateAndBuildSetPrinterRequest(pIniPrinter,
                                                pTempIniPrinter,
                                                pPrinterInfo,
                                                Level,
                                                SecurityInformation,
                                                &bSecurityChg,
                                                &bNameChg,
                                                &bAttributeChg,
                                                &pszNewPrinterName,
                                                &pKeyData) ) {

            bReturn = FALSE;
            goto Cleanup;

        } // else we follow thru rest of code since all valiations succeded

        // Just a flag stating whether we have a new port
        bNewPort = NewPort(pKeyData, pIniPrinter);
        if (bNewPort) {
            dwPrinterVector |= BIT(I_PRINTER_PORT_NAME);
        }
    }

    //
    // --------------------All validation done---------------------------
    //

    //
    // Now set security information; Remember we have
    // a valid SecurityDescriptor and "SecurityInformation
    // is non-zero at this point. We have validated this
    // information
    //
    if ( bSecurityChg ) {

        if ( SetPrinterSecurityDescriptor(SecurityInformation,
                                          pTempIniPrinter->pSecurityDescriptor,
                                          &pIniPrinter->pSecurityDescriptor) ) {

            dwPrinterVector |= BIT(I_PRINTER_SECURITY_DESCRIPTOR);
            bShareUpdate = TRUE;
        } else {

            bReturn = FALSE;
            goto Cleanup;
        }

    }


    // Can we avoid doing this if bNewPort == NULL?
    if ( Level == 2 || Level == 5 ) {

        //
        // bi-dir associate pIniPrinter with ports inside pKeyData.
        //
        bReturn = SetPrinterPorts(pSpool, pIniPrinter, pKeyData);

        if ( !bReturn )
            goto Cleanup;
    }

    if ( bAttributeChg ) {

        if ( !(pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_DEVQ) &&
             pIniPrinter->cJobs) {

            pIniJob = pIniPrinter->pIniFirstJob;

            while (pIniJob) {
                if (pIniJob->Status & JOB_BLOCKED_DEVQ) {

                    PNOTIFYVECTOR pNotifyVector = &NVJobStatus;
                    InterlockedAnd((LONG*)&(pIniJob->Status), ~JOB_BLOCKED_DEVQ);

                    if( pIniJob->pStatus ){

                        FreeSplStr(pIniJob->pStatus);
                        pIniJob->pStatus = NULL;
                        pNotifyVector = &NVJobStatusAndString;
                    }

                    SetPrinterChange(pIniJob->pIniPrinter,
                                     pIniJob,
                                     *pNotifyVector,
                                     PRINTER_CHANGE_SET_JOB,
                                     pIniJob->pIniPrinter->pIniSpooler);

                }
                pIniJob = pIniJob->pIniNextJob;
            }
        }
    }

    //
    // The comment must be changed here since ShareThisPrinter
    // will look at pComment when the printer is reshared.
    //
    if ( Level == 2 &&
         pIniPrinter->pComment != pTempIniPrinter->pComment ) {

        FreeSplStr(pIniPrinter->pComment);

        pIniPrinter->pComment = pTempIniPrinter->pComment;

        dwPrinterVector |= BIT(I_PRINTER_COMMENT);

        if (pTempIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) {

            bShareUpdate = TRUE;
        }
    }

    //
    // Change printer name if different
    //
    if ( bNameChg ) {

        pszOldPrinterName = AllocSplStr(pIniPrinter->pName);

        if (!pszOldPrinterName && pIniPrinter->pName) {
             bReturn = FALSE;
             goto Cleanup;
        }

        ChangePrinterName(pszNewPrinterName, pIniPrinter, pIniSpooler,
                          &dwPrinterVector);

        pszNewPrinterName = NULL;

        //
        // The print share must be recreated since there's no way
        // to change the path without deleting and creating a new one.
        //
        bShareRecreate = TRUE;
    }

    //
    // If Share name changed force update
    //
    if ( pIniPrinter->pShareName != pTempIniPrinter->pShareName ) {

        bShareRecreate = TRUE;
    }

    if ( bAttributeChg || bShareUpdate || bShareRecreate ) {

        OldAttributes = pIniPrinter->Attributes;
        pIniPrinter->Attributes = pTempIniPrinter->Attributes;

        bReturn = ChangePrinterAttributes(pIniPrinter->Attributes,
                                          OldAttributes,
                                          pIniPrinter,
                                          pIniSpooler,
                                          pTempIniPrinter->pShareName,
                                          bShareRecreate,
                                          bShareUpdate);

        if (!bReturn) {
            LastError = GetLastError();
        }

        if (pIniPrinter->Attributes != OldAttributes) {
            dwPrinterVector |= BIT(I_PRINTER_ATTRIBUTES);
        }
    }


    if ( Level == 2 ) {

        ProcessSetPrinter2(pIniPrinter,
                           pTempIniPrinter,
                           pPrinterInfo2,
                           &dwPrinterVector,
                           pDevMode);
    }

Finish:

    // Sometimes SetPrinter can fail certain calls after it has modified some parameters.
    // For instance, we may have failed to update some sharing fields.  If we get to this
    // point (or anywhere after the last goto Cleanup), then we need to update the ds keys.
    // We should really clean up SetPrinter so it undoes everything, but we don't have enough time
    // to fix it properly before NT6.
    bDataChanged = TRUE;

    CHECK_SCHEDULER();

    // Can we avoid doing this if dwPrinterVector == NULL?
    UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

    // Can we avoid doing this if dwPrinterVector == NULL?
    UpdateWinIni( pIniPrinter );  // So the port on the device is correct

    //
    // Log event that the SetPrinter was done.
    //

    INCPRINTERREF(pIniPrinter);
    SplLogEvent(pIniSpooler, LOG_INFO, MSG_PRINTER_SET, TRUE, pIniPrinter->pName, NULL);
    DECPRINTERREF(pIniPrinter);

    NotifyVector[PRINTER_NOTIFY_TYPE] |= dwPrinterVector;
    //
    // Indicate that a change has occurred.
    //
    SetPrinterChange(pIniPrinter,
                     NULL,
                     NotifyVector,
                     PRINTER_CHANGE_SET_PRINTER,
                     pIniSpooler);

Cleanup:

    SplInSem();

    if ( LastError != ERROR_SUCCESS ) {

        SetLastError(LastError);
        bReturn = FALSE;
    }

    CleanupSetPrinter(pIniPrinter, pTempIniPrinter, pKeyData,
                      Level, bReturn);

    if (bDataChanged) {
        INCPRINTERREF(pIniPrinter);
        LeaveSplSem();
        SplOutSem();

        //
        // If the printer driver changed
        // Call the printer driver to initialize itself
        //
        if (dwPrinterVector & BIT(I_PRINTER_DRIVER_NAME)) {

            PDEVMODE pDevMode = NULL;

            PrinterDriverEvent(pIniPrinter, PRINTER_EVENT_INITIALIZE, (LPARAM)NULL, &dwPrnEvntError);

            //
            // If the driver name changed then convert the devmode to the new driver's
            // devmode. Note this must be done after the printer event initialize
            // because the driver is not able to handle a convert devmode call before
            // being initialized.  Also if the conversion fails we potentially end up
            // having the old devmode in the registry.  We could null out the devmode
            // but is it better to have a bad old devmode in the registry rather than a null
            // devmode.  A null devmode is more dangerous because an application may
            // get really confused with a null devmode rather than a bad devmode
            // which the driver will eventually fix, because they have to handle foreign
            // devmodes any way.
            //

            EnterSplSem();

            //
            // Now convert the devmode to the driver specific devmode.
            //
            pDevMode = ConvertDevModeToSpecifiedVersion(pIniPrinter,
                                                        pIniPrinter->pDevMode,
                                                        NULL,
                                                        NULL,
                                                        CURRENT_VERSION);

            //
            // If a new devmode was returned then release the current printer's
            // devmode and save the new devmode.
            //
            if (pDevMode) {

                FreeSplMem(pIniPrinter->pDevMode);
                pIniPrinter->pDevMode = pDevMode;
                pIniPrinter->cbDevMode = pDevMode->dmSize + pDevMode->dmDriverExtra;
            }

            //
            // Write the newly converted devmode to the registry again.
            //
            UpdatePrinterIni( pIniPrinter, UPDATE_CHANGEID );

            LeaveSplSem();
        }

        //
        // If the printer attributes changed, call the driver with the two
        // different sets of attributes, this is to allow the fax driver to
        // start up the fax service when a printer gets shared out.
        //
        if (dwPrinterVector & BIT(I_PRINTER_ATTRIBUTES)) {

            PRINTER_EVENT_ATTRIBUTES_INFO   AttributesInfo = {
                sizeof(PRINTER_EVENT_ATTRIBUTES_INFO),
                OldAttributes,
                pIniPrinter->Attributes
            };

            PrinterDriverEvent(pIniPrinter, PRINTER_EVENT_ATTRIBUTES_CHANGED, (LPARAM)&AttributesInfo, &dwPrnEvntError);
        }

        EnterSplSem();
        SplInSem();
        DECPRINTERREF(pIniPrinter);
    }


    // Don't update if this is from cache
    if (!bDataChanged || ((Level == 2 || Level == 5) && !dwPrinterVector) ||
        (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CACHE)) {

        bUpdateDsSpoolerKey = FALSE;

    } else if (bUpdateDsSpoolerKey) {

        if (Level != 7)
        {
            //
            // Update unly values that changed.
            //
            UpdateDsSpoolerKey(hPrinter, dwPrinterVector);

        } else if (pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH)
        {
            //
            // Update the all values in Registry for level 7.
            //
            UpdateDsSpoolerKey(hPrinter, 0xffffffff);
        }

        //
        // Reset Driver DS Properties if driver changed
        //
        if (dwPrinterVector & BIT(I_PRINTER_DRIVER_NAME)) {

            INCPRINTERREF(pIniPrinter);
            LeaveSplSem();

            //
            // This calls SetPrinterDs with DSPRINT_UPDATE anyway.
            //
            RecreateDsKey(hPrinter, SPLDS_DRIVER_KEY);

            EnterSplSem();
            DECPRINTERREF(pIniPrinter);

        } else if (Level != 7 || pPrinterInfo7->dwAction != DSPRINT_UNPUBLISH) {

            //
            // If the driver didn't change, query the driver again for capabilities.
            //
            UpdateDsDriverKey(hPrinter);
        }
    }

    if (bUpdateDsSpoolerKey) {
        if (pIniPrinter->DsKeyUpdateForeground || (Level == 7 && pPrinterInfo7->dwAction == DSPRINT_UNPUBLISH)) {
            if (Level == 7) {
                if ((dwResult = SetPrinterDs(hPrinter, pPrinterInfo7->dwAction, FALSE)) != ERROR_SUCCESS) {
                    SetLastError(dwResult);
                    bReturn = FALSE;
                }
            } else {
                //
                // Update only, in the background thread.
                //
                SetPrinterDs(hPrinter, DSPRINT_UPDATE, FALSE);
            }
        }
    }

    LeaveSplSem();
    SplOutSem();


    if ( pDevMode && pDevMode != pPrinterInfo2->pDevMode )
        FreeSplMem(pDevMode);

    if ( pszOldPrinterName ) {
        FreeSplStr(pszOldPrinterName);
    }

    FreeSplStr(pszNewPrinterName);

    return bReturn;
}



PRINTER_SECURITY_STATUS
SetPrinterSecurity(
    SECURITY_INFORMATION SecurityInformation,
    PINIPRINTER          pIniPrinter,
    PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSize;

    if (!pSecurityDescriptor)
        return SECURITY_FAIL;

    if (pIniPrinter->pSecurityDescriptor) {

        dwSize = GetSecurityDescriptorLength(pIniPrinter->pSecurityDescriptor);

        if (dwSize == GetSecurityDescriptorLength(pSecurityDescriptor)) {

            if (!memcmp(pSecurityDescriptor,
                        pIniPrinter->pSecurityDescriptor,
                        dwSize)) {

                return SECURITY_NOCHANGE;
            }
        }
    }

    if( !SetPrinterSecurityDescriptor( SecurityInformation,
                                       pSecurityDescriptor,
                                       &pIniPrinter->pSecurityDescriptor ) ) {

        DBGMSG(DBG_WARNING, ("SetPrinterSecurityDescriptor failed. Error = %d\n",
                              GetLastError()));
        return SECURITY_FAIL;
    }

    UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID);

    return SECURITY_SUCCESS;
}

VOID
RegClearKey(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    )
{
    DWORD dwError;
    WCHAR szValue[4*MAX_PATH];

    DWORD cchValue;

    while (TRUE) {

        cchValue = COUNTOF(szValue);
        dwError = SplRegEnumValue( hKey,
                                   0,
                                   szValue,
                                   &cchValue,
                                   NULL,
                                   NULL,
                                   NULL,
                                   pIniSpooler );

        if( dwError != ERROR_SUCCESS ){

            if( dwError != ERROR_NO_MORE_ITEMS ){
                DBGMSG( DBG_ERROR, ( "RegClearKey: Failed %d\n", dwError ));
            }
            break;
        }

        dwError = SplRegDeleteValue( hKey, szValue, pIniSpooler );

        if( dwError != ERROR_SUCCESS ){
            DBGMSG( DBG_ERROR, ( "RegDeleteValue: %s Failed %d\n",
                                 szValue, dwError ));
            break;
        }
    }
}

BOOL
ChangePrinterAttributes(
    DWORD       dNewAttributes,
    DWORD       dOldAttributes,
    PINIPRINTER pIniPrinter,
    PINISPOOLER pIniSpooler,
    LPWSTR      pszNewShareName,
    BOOL        bShareRecreate,
    BOOL        bShareUpdate
    )
/*++

Routine Description:

    Changes printer attributes by validating sharing information.
    Already the validated attributes are set, we want to validate
    by changing the share information

Arguments:

    dNewAttributes - New attributes specified on SetPrinter call

    dOldAttributes - pIniPrinter->Attributes before the call

    pIniPrinter - of the printer we are changing attributes

    pIniSpooler - Spooler that owns printer

    pszNewShareName - the share name that will be set if SetPrinter succeeds

    bShareRecreate - Share must be recreated because the printer or share
        name changed.

    bShareUpdate - Share just needs to be updated, since comment / SD changed.

Return Value:

    DWORD TRUE on success, FALSE else.

--*/

{
    BOOL        Shared, bReturn = TRUE;

    //
    // We are going to have to be able to restore the attributes if the share
    // modification fails. We need to set the current attributes now because
    // the NetSharexxx is going to call OpenPrinter, and possibly an AddJob
    // which needs the correct Attributes.
    //
    if (dNewAttributes & PRINTER_ATTRIBUTE_SHARED) {

        if (!(dOldAttributes & PRINTER_ATTRIBUTE_SHARED)) {

            pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_SHARED;

            Shared = ShareThisPrinter( pIniPrinter, pszNewShareName, TRUE );

            if ( !Shared ) {

                pIniPrinter->Attributes = dOldAttributes;
                bReturn = FALSE;
            }

        } else {

            //
            // We are shared, and so is the old one.  If share name changed
            // we have to remove old share and reshare.
            //
            if ( bShareRecreate ) {

                if (ShareThisPrinter(pIniPrinter,
                                     pIniPrinter->pShareName,
                                     FALSE)) {

#if DBG
                    WCHAR szError[256];

                    StringCchPrintf(szError, COUNTOF(szError), L"Error %d, removing share", GetLastError());

                    //
                    // Error: the printer shouldn't be shared at this
                    // point.
                    //

                    INCPRINTERREF(pIniPrinter);

                    SplLogEvent(pIniSpooler,
                                LOG_ERROR,
                                MSG_SHARE_FAILED,
                                TRUE,
                                L"SetLocalPrinter ShareThisPrinter FALSE",
                                pIniPrinter->pName,
                                pIniPrinter->pShareName,
                                szError,
                                NULL);

                    DECPRINTERREF(pIniPrinter);
#endif

                    bReturn = FALSE;

                } else if (!ShareThisPrinter(pIniPrinter,
                                             pszNewShareName,
                                             TRUE)) {
#if DBG
                    WCHAR szError[256];

                    StringCchPrintf(szError, COUNTOF(szError),  L"Error %d, adding share", GetLastError());

                    //
                    // Error: the printer shouldn't be shared at this
                    // point.
                    //

                    INCPRINTERREF(pIniPrinter);

                    SplLogEvent(pIniSpooler,
                                LOG_ERROR,
                                MSG_SHARE_FAILED,
                                TRUE,
                                L"SetLocalPrinter ShareThisPrinter TRUE",
                                pIniPrinter->pName,
                                pIniPrinter->pShareName,
                                szError,
                                NULL);

                    DECPRINTERREF(pIniPrinter);
#endif

                    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
                    pIniPrinter->Status |= PRINTER_WAS_SHARED;
                    bReturn = FALSE;
                }
            } else if ( bShareUpdate ) {
                //
                // If comment/description changed then we just do a NetShareSet
                //
                bReturn = SetPrinterShareInfo(pIniPrinter);

            }
        }

    } else if (dOldAttributes & PRINTER_ATTRIBUTE_SHARED) {

        Shared = ShareThisPrinter(pIniPrinter, pIniPrinter->pShareName, FALSE);

        if (!Shared) {

            pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
            pIniPrinter->Status |= PRINTER_WAS_SHARED;
            CreateServerThread();


        } else {
            pIniPrinter->Attributes = dOldAttributes;
            bReturn = FALSE;
        }
    }

    if (((dOldAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) &&
        !(dNewAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) ||
        (!(dOldAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) &&
        (dNewAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) ) ) {

        WritePrinterOnlineStatusInCurrentConfig(pIniPrinter);
    }


    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\sizethrd.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    sizethrd.c

Abstract:

    The NT server share for downlevel jobs does not set the size whilst
    spooling.   The SizeDetectionThread periodically wakes walks all the
    actively spooling jobs and if necessary updates the size.

Author:

    Matthew Felton (mattfe) May 1994

Revision History:

--*/

#include <precomp.h>

#include "filepool.hxx"

#define SIZE_THREAD_WAIT_PERIOD 2.5*1000      // period size thread sleeps
                                              // for polling file sizes

BOOL gbSizeDetectionRunning = FALSE;
BOOL gbRequestSizeDetection = FALSE;

VOID
SizeDetectionThread(
    PVOID pv
    );

VOID
SizeDetectionOnSpooler(
    PINISPOOLER pIniSpooler
    );


VOID
CheckSizeDetectionThread(
    VOID
    )

/*++

Routine Description:

    Check if the size detection thread is running.  If it isn't, then
    start a new one up.

    Note: there is exactly one size detection thread in the system that
    runs through all spoolers.

Arguments:

Return Value:

--*/

{
    DWORD ThreadId;
    HANDLE hThread;

    SplInSem();

    gbRequestSizeDetection = TRUE;

    //
    // If the thread isn't running, start it.  Otherwise request
    // that it starts.
    //
    if( !gbSizeDetectionRunning ){

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SizeDetectionThread,
                                pLocalIniSpooler,
                                0,
                                &ThreadId );

        if( hThread ){
            gbSizeDetectionRunning = TRUE;
            CloseHandle( hThread );
        }
    }
}

VOID
SizeDetectionThread(
    PVOID pv
    )

/*++

Routine Description:

    Walk through all spoolers and printers to see if there are any
    jobs that have been added via AddJob.  Then see if their size
    has changed.

Arguments:

    PVOID - unused.

Return Value:

--*/

{
    PINISPOOLER pIniSpooler;
    PINISPOOLER pIniNextSpooler;

    EnterSplSem();

    while( gbRequestSizeDetection ){

        //
        // Turn it off since we are at the very beginning of the
        // loop and we check all pIniSpoolers.
        //
        gbRequestSizeDetection = FALSE;

        if( pLocalIniSpooler ){
            INCSPOOLERREF( pLocalIniSpooler );
        }

        //
        // Walk through all spoolers.
        //
        for( pIniSpooler = pLocalIniSpooler;
             pIniSpooler;
             pIniSpooler = pIniNextSpooler ){

            //
            // If this spooler prints, check it.
            //
            if( pIniSpooler->SpoolerFlags & SPL_PRINT ){

                //
                // This will leave the critical section.
                // gbRequestSizeDetection will be turned on if this printer
                // has a spooling job.
                //
                SizeDetectionOnSpooler( pIniSpooler );
            }

            //
            // Save the next spooler then decrement the refcount
            // on the current one.  We must do it in this order because
            // as soon as we release the refcount, it may disappear.
            //
            // We must protect the next spooler immediately since
            // during the DecSpoolerRef( pIniSpooler ), it might
            // get deleted.
            //
            pIniNextSpooler = pIniSpooler->pIniNextSpooler;

            if( pIniNextSpooler ){
                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pIniSpooler );
        }

        LeaveSplSem();
        Sleep( (DWORD)SIZE_THREAD_WAIT_PERIOD );
        EnterSplSem();
    }

    gbSizeDetectionRunning = FALSE;

    LeaveSplSem();

    ExitThread( 0 );
}

VOID
SizeDetectionOnSpooler(
    IN     PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Detect if a spooler has a printing job.

Arguments:

    pIniSpooler - Spooler to check.

Return Value:

--*/

{
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniNextPrinter;
    PINIJOB     pIniJob, pIniNextJob, pChainedJob;
    DWORD       dwPosition, dwChainedJobSize;

    //
    // Loop through all printers on this spooler.
    //
    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniNextPrinter ){

        INCPRINTERREF(pIniPrinter);

        //
        // Loop through all jobs on this printer.
        //
        for( pIniJob = pIniPrinter->pIniFirstJob;
             pIniJob;
             pIniJob = pIniNextJob ){

            SPLASSERT( pIniJob->signature == IJ_SIGNATURE );
            SPLASSERT( pIniPrinter->signature == IP_SIGNATURE );

            INCJOBREF(pIniJob);

            SplInSem();

            if ( (pIniJob->Status & JOB_SPOOLING)       &&
                 (pIniJob->Status & JOB_TYPE_ADDJOB) ) {

                WCHAR   szFileName[MAX_PATH];
                HANDLE  hFile = INVALID_HANDLE_VALUE;
                DWORD   dwFileSize = 0;
                BOOL    DoClose = TRUE;

                gbRequestSizeDetection = TRUE;

                if ( pIniJob->hFileItem != INVALID_HANDLE_VALUE )
                {
                    hFile = GetCurrentWriter(pIniJob->hFileItem, TRUE);

                    if ( hFile == INVALID_HANDLE_VALUE )
                    {
                        StringCchCopy(szFileName, COUNTOF(szFileName), pIniJob->pszSplFileName);
                    }
                    else
                    {
                        DoClose = FALSE;
                    }
                }
                else
                {
                    GetFullNameFromId (pIniPrinter,
                                       pIniJob->JobId,
                                       TRUE,
                                       szFileName,
                                       COUNTOF(szFileName),
                                       FALSE);
                }

                LeaveSplSem();
                SplOutSem();
                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    hFile = CreateFile(szFileName,
                                       0,
                                       FILE_SHARE_WRITE, NULL,
                                       OPEN_EXISTING,
                                       FILE_FLAG_SEQUENTIAL_SCAN,
                                       0);
                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    SeekPrinterSetEvent(pIniJob, hFile, FALSE);
                    dwFileSize = GetFileSize( hFile, 0 );

                    if ( DoClose )
                    {
                        CloseHandle( hFile );
                    }
                }

                EnterSplSem();
                SplInSem();

                SPLASSERT( pIniJob->signature == IJ_SIGNATURE );

                //
                // Chained job size include all the jobs in the chain
                // But since the next jobs size field will have the size
                // of all subsequent jobs we do not need to walk thru the
                // whole chain
                //
                dwChainedJobSize    = 0;
                if ( pIniJob->NextJobId ) {

                    if ( pChainedJob = FindJob(pIniPrinter,
                                               pIniJob->NextJobId,
                                               &dwPosition) )
                        dwChainedJobSize = pChainedJob->Size;
                    else
                        SPLASSERT(pChainedJob != NULL);
                }


                if ( pIniJob->Size < dwFileSize + dwChainedJobSize ) {

                    DWORD dwOldSize = pIniJob->Size;
                    DWORD dwOldValidSize = pIniJob->dwValidSize;

                    //
                    // Fix for print while spooling (AddJob/ScheduleJob)
                    //
                    // The file size has changed.  At this time we only
                    // know that the file is extended, not that the extended
                    // range has valid data (there's a small window where the
                    // extended window has not been filled with data).
                    //
                    // This does guarantee that the _previous_ extension
                    // has been written, however.
                    //
                    pIniJob->dwValidSize = dwOldSize;
                    pIniJob->Size = dwFileSize + dwChainedJobSize;

                    //
                    //  Wait until Jobs reach our size threshold before
                    //  we schedule them.
                    //

                    if (( dwOldValidSize < dwFastPrintSlowDownThreshold ) &&
                        ( dwOldSize >= dwFastPrintSlowDownThreshold ) &&
                        ( pIniJob->WaitForWrite == NULL )) {

                        CHECK_SCHEDULER();
                    }

                    SetPrinterChange(pIniPrinter,
                                     pIniJob,
                                     NVSpoolJob,
                                     PRINTER_CHANGE_WRITE_JOB,
                                     pIniPrinter->pIniSpooler);

                    // Support for despooling whilst spooling
                    // for Down Level jobs

                    if (pIniJob->WaitForWrite != NULL)
                        SetEvent( pIniJob->WaitForWrite );

                }
            }

            pIniNextJob = pIniJob->pIniNextJob;

            //
            // We must protect pIniNextJob immediately,
            // since we will may leave critical section in
            // DeleteJobCheck (it may call DeleteJob).  While out
            // of critical section, pIniNextJob may be deleted,
            // causing it's next pointer to be bogus.  We'll AV
            // after we try and process it.
            //
            if (pIniNextJob) {
                INCJOBREF(pIniNextJob);
            }

            DECJOBREF(pIniJob);
            DeleteJobCheck(pIniJob);

            if (pIniNextJob) {
                DECJOBREF(pIniNextJob);
            }
        }

        pIniNextPrinter = pIniPrinter->pNext;

        if( pIniNextPrinter ){
            INCPRINTERREF( pIniNextPrinter );
        }

        DECPRINTERREF(pIniPrinter);

        if( pIniNextPrinter ){
            DECPRINTERREF( pIniNextPrinter );
        }
    }

    SplInSem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\spltypes.h ===
/*++

Copyright ( c) 1990 - 1996  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:
    Muhunthan Sivapragasam <MuhuntS> 30 May 1995
    Support for level 3 <SUR>

--*/


#ifndef MODULE
#define MODULE "LSPL:"
#define MODULE_DEBUG LocalsplDebug
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <ntfytab.h>

typedef HANDLE SEM;

typedef struct _KEYDATA {
    BOOL    bFixPortRef;    // Tells if INIPORT list is build and cRef incremented
    DWORD   cTokens;
    LPWSTR  pTokens[1];     // This should remain the last field
} KEYDATA, *PKEYDATA;

typedef struct _INIENTRY {
    DWORD       signature;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;

//
// Prototypes used by PINIPRINTPROC
//
typedef HANDLE    (WINAPI *pfnOpenPrintProcessor)(LPWSTR, PPRINTPROCESSOROPENDATA);

typedef BOOL      (WINAPI *pfnInstallPrintProcessor)(HWND);

typedef BOOL      (WINAPI *pfnEnumDatatypes)(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD);

typedef BOOL      (WINAPI *pfnPrintDocOnPrintProcessor)(HANDLE, LPWSTR);

typedef BOOL      (WINAPI *pfnClosePrintProcessor)(HANDLE);

typedef BOOL      (WINAPI *pfnControlPrintProcessor)(HANDLE, DWORD);

typedef DWORD     (WINAPI *pfnGetPrintProcCaps)(LPTSTR, DWORD, LPBYTE ,DWORD, LPDWORD);

typedef struct _INIPRINTPROC {             /* iqp */
    DWORD       signature;
    struct _INIPRINTPROC *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pDLLName;
    DWORD       cbDatatypes;
    DWORD       cDatatypes;
    LPWSTR      pDatatypes;
    HANDLE      hLibrary;
    pfnInstallPrintProcessor    Install;
    pfnEnumDatatypes            EnumDatatypes;
    pfnOpenPrintProcessor       Open;
    pfnPrintDocOnPrintProcessor Print;
    pfnClosePrintProcessor      Close;
    pfnControlPrintProcessor    Control;
    pfnGetPrintProcCaps         GetPrintProcCaps;
    CRITICAL_SECTION            CriticalSection;
    DWORD                       FileMinorVersion;
    DWORD                       FileMajorVersion;
} INIPRINTPROC, *PINIPRINTPROC;


// Print Processor critical section tags
#define PRINTPROC_CANCEL    0x00000001
#define PRINTPROC_PAUSE     0x00000002
#define PRINTPROC_RESUME    0x00000004
#define PRINTPROC_CLOSE     0x00000008

//
// If we have cancelled a job, we do not want to be able to pause or resume it again,
// so we set both those flags. That will cause the pause and resume codepaths to bail out.
// The flags are reset when we get a new job for the port or restart the job.
//
#define PRINTPROC_CANCELLED  PRINTPROC_PAUSE|PRINTPROC_RESUME


#define IPP_SIGNATURE    0x5050 /* 'PP' is the signature value */

typedef struct _INIDRIVER {            /* id */
    DWORD       signature;
    struct _INIDRIVER *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pDriverFile;
    LPWSTR      pConfigFile;
    LPWSTR      pDataFile;
    LPWSTR      pHelpFile;
    DWORD       cchDependentFiles; //length including \0\0
    LPWSTR      pDependentFiles;
    LPWSTR      pMonitorName;
    LPWSTR      pDefaultDataType;
    DWORD       cchPreviousNames;
    LPWSTR      pszzPreviousNames;
    FILETIME    ftDriverDate;
    DWORDLONG   dwlDriverVersion;
    LPTSTR      pszMfgName;
    LPTSTR      pszOEMUrl;
    LPTSTR      pszHardwareID;
    LPTSTR      pszProvider;
    DWORD       dwDriverAttributes;
    DWORD       cVersion;
    DWORD       dwTempDir;
    struct _INIMONITOR *pIniLangMonitor;
    DWORD       dwDriverFlags;
} INIDRIVER, *PINIDRIVER;

//
// Printer Driver Flags:
//
#define PRINTER_DRIVER_PENDING_DELETION     0x0001

#define ID_SIGNATURE    0x4444  /* 'DD' is the signature value */

 // struct for holding the reference counts for driver related files.
 typedef struct _DRVREFCNT {
     struct _DRVREFCNT *pNext;
     LPWSTR  szDrvFileName;
     DWORD   refcount;
     DWORD   dwVersion;
     DWORD   dwFileMinorVersion;
     DWORD   dwFileMajorVersion;
     BOOL    bInitialized;
 } DRVREFCNT, *PDRVREFCNT;

typedef struct _INIVERSION {
    DWORD       signature;
    struct _INIVERSION *pNext;
    LPWSTR      pName;
    LPWSTR      szDirectory;
    DWORD       cMajorVersion;
    DWORD       cMinorVersion;
    PDRVREFCNT  pDrvRefCnt;
    PINIDRIVER  pIniDriver;
} INIVERSION, *PINIVERSION;

typedef struct _DRVREFNODE {
    struct _DRVREFNODE *pNext;
    PDRVREFCNT  pdrc;
} DRVREFNODE, *PDRVREFNODE;

#define IV_SIGNATURE   'IV'     // 4956H


typedef struct _INIENVIRONMENT {            /* id */
    DWORD         signature;
    struct _INIENVIRONMENT *pNext;
    DWORD         cRef;
    LPWSTR        pName;
    LPWSTR        pDirectory;
    PINIVERSION   pIniVersion;
    PINIPRINTPROC pIniPrintProc;
    struct _INISPOOLER *pIniSpooler; // Points to owning IniSpooler
} INIENVIRONMENT, *PINIENVIRONMENT;

#define IE_SIGNATURE    0x4545  /* 'EE' is the signature value */

typedef struct
{
    DWORD           Status;
    DWORD           cJobs;
    DWORD           dwError;
    BOOL            bThreadRunning;

} MasqPrinterCache;

typedef struct _INIPRINTER {    /* ip */
    DWORD       signature;
    struct _INIPRINTER *pNext;
    DWORD       cRef;
    LPWSTR      pName;
    LPWSTR      pShareName;
    PINIPRINTPROC pIniPrintProc;
    LPWSTR      pDatatype;
    LPWSTR      pParameters;
    LPWSTR      pComment;
    PINIDRIVER  pIniDriver;
    DWORD       cbDevMode;
    LPDEVMODE   pDevMode;
    DWORD       Priority;           // queue priority (lowest:1 - highest:9)
    DWORD       DefaultPriority;
    DWORD       StartTime;          // print daily after time: from 00:00 in min
    DWORD       UntilTime;          // print daily until time: from 00:00 in min
    LPWSTR      pSepFile;           // full path to separator file, null = def
    DWORD       Status;             // QMPAUSE/ERROR/PENDING
    LPWSTR      pLocation;
    DWORD       Attributes;
    DWORD       cJobs;
    DWORD       AveragePPM;         // BOGUS, nothing updates it
    BOOL        GenerateOnClose;    // Passed to security auditing APIs
    struct _INIPORT *pIniNetPort;   // Non-NULL if there's a network port
    struct _INIJOB *pIniFirstJob;
    struct _INIJOB *pIniLastJob;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    struct _SPOOL  *pSpool;         // Linked list of handles for this printer
    LPWSTR      pSpoolDir;          // Location to write / read spool files
                                    // Only Used for Stress Test Data
    DWORD       cTotalJobs;         // Total Number of Jobs (since boot)
    LARGE_INTEGER cTotalBytes;      // Total Number of Bytes (since boot)
    SYSTEMTIME  stUpTime;           // Time when IniPrinter structure created
    DWORD       MaxcRef;            // Max number open printer handles
    DWORD       cTotalPagesPrinted; // Total Number of Pages Printer on this printer
    DWORD       cSpooling;          // # of Jobs concurrently spooling
    DWORD       cMaxSpooling;       // Max Number of concurrent spooling jobs
    DWORD       cErrorOutOfPaper;   // Count Out Out Of Paper Errors
    DWORD       cErrorNotReady;     // Count Not Ready Errors
    DWORD       cJobError;          // Count Job Errors
    struct _INISPOOLER *pIniSpooler; // Points to owning IniSpooler
    DWORD       cZombieRef;
    DWORD       dwLastError;        // Last Printer Error
    LPBYTE      pExtraData;         //  For extranal Print Providers SplSetPrinterExtra
    DWORD       cChangeID;          // Time Stamp when printer is changed
    DWORD       cPorts;             // Number of ports printer is attached to
    struct _INIPORT **ppIniPorts;         // Ports this printer is going to
    DWORD       PortStatus;         // Error set against IniPorts
    DWORD       dnsTimeout;         // Device not selected timeout in milliseconds
    DWORD       txTimeout;          // Transmission retry timeout in milliseconds
    PWSTR       pszObjectGUID;      // printQueue ObjectGUID
    DWORD       DsKeyUpdate;        // Keeps track of which DS Key update state
    PWSTR       pszDN;              // Distinguished Name
    PWSTR       pszCN;              // Common Name
    DWORD       cRefIC;             // Refcount on CreateICHandle--info only
    DWORD       dwAction;           // DS action
    BOOL        bDsPendingDeletion; // if TRUE, published printer is being deleted
    DWORD       dwUniqueSessionID;  // Unique Session ID for the printers
    DWORD       dwPrivateFlag;
    DWORD       DsKeyUpdateForeground;  // Keeps track of which DS Key changed while publishing
#if DBG
    PVOID       pvRef;
#endif

    MasqPrinterCache  MasqCache;

} INIPRINTER, *PINIPRINTER;

#define IP_SIGNATURE    0x4951  /* 'IQ' is the signature value */

#define FASTPRINT_WAIT_TIMEOUT          (4*60*1000)   // 4 Minutes
#define FASTPRINT_THROTTLE_TIMEOUT      (2*1000)      // 2 seconds
#define FASTPRINT_SLOWDOWN_THRESHOLD    ( FASTPRINT_WAIT_TIMEOUT / FASTPRINT_THROTTLE_TIMEOUT )

#define WRITE_PRINTER_SLEEP_TIME        0   // disabled by default

// pIniPrinter->Attributes are defined in winspool.h PRINTER_ATTRIBUTE_*
// Below are pIniPrinter->Status flags !!!
// See INIT.C some of these are removed at reboot

#define PRINTER_PAUSED                  0x00000001
#define PRINTER_ERROR                   0x00000002
#define PRINTER_OFFLINE                 0x00000004
#define PRINTER_PAPEROUT                0x00000008
#define PRINTER_PENDING_DELETION        0x00000010
#define PRINTER_ZOMBIE_OBJECT           0x00000020
#define PRINTER_PENDING_CREATION        0x00000040
#define PRINTER_OK                      0x00000080
#define PRINTER_FROM_REG                0x00000100
#define PRINTER_WAS_SHARED              0x00000200
#define PRINTER_PAPER_JAM               0x00000400
#define PRINTER_MANUAL_FEED             0x00000800
#define PRINTER_PAPER_PROBLEM           0x00001000
#define PRINTER_IO_ACTIVE               0x00002000
#define PRINTER_BUSY                    0x00004000
#define PRINTER_PRINTING                0x00008000
#define PRINTER_OUTPUT_BIN_FULL         0x00010000
#define PRINTER_NOT_AVAILABLE           0x00020000
#define PRINTER_WAITING                 0x00040000
#define PRINTER_PROCESSING              0x00080000
#define PRINTER_INITIALIZING            0x00100000
#define PRINTER_WARMING_UP              0x00200000
#define PRINTER_TONER_LOW               0x00400000
#define PRINTER_NO_TONER                0x00800000
#define PRINTER_PAGE_PUNT               0x01000000
#define PRINTER_USER_INTERVENTION       0x02000000
#define PRINTER_OUT_OF_MEMORY           0x04000000
#define PRINTER_DOOR_OPEN               0x08000000
#define PRINTER_SERVER_UNKNOWN          0x10000000
#define PRINTER_POWER_SAVE              0x20000000
#define PRINTER_NO_MORE_JOBS            0x40000000


#define PRINTER_STATUS_PRIVATE      ( PRINTER_PAUSED | \
                                      PRINTER_ERROR | \
                                      PRINTER_PENDING_DELETION | \
                                      PRINTER_ZOMBIE_OBJECT | \
                                      PRINTER_PENDING_CREATION | \
                                      PRINTER_OK | \
                                      PRINTER_FROM_REG | \
                                      PRINTER_WAS_SHARED )
#define PrinterStatusBad(dwStatus)  ( (dwStatus & PRINTER_OFFLINE)  || \
                                      (dwStatus & PRINTER_PAUSED) )

#define PRINTER_CHANGE_VALID                    0x75770F0F
#define PRINTER_CHANGE_CLOSE_PRINTER            0xDEADDEAD


// DS publishing state
#define DS_KEY_SPOOLER          0x00000001
#define DS_KEY_DRIVER           0x00000002
#define DS_KEY_USER             0x00000004
#define DS_KEY_REPUBLISH        0x80000000
#define DS_KEY_PUBLISH          0x40000000
#define DS_KEY_UNPUBLISH        0x20000000
#define DS_KEY_UPDATE_DRIVER    0x10000000

#define DN_SPECIAL_CHARS    L",=\r\n+<>#;\"\\"
#define ADSI_SPECIAL_CHARS  L"/"

//
// These are attribute bits that are permitted to be set by SetPrinter().
//
// Note: I have removed PRINTER_ATTRIBUTE_DEFAULT, since it is
// per-user, and not per-printer.
//
#define PRINTER_ATTRIBUTE_SETTABLE ( PRINTER_ATTRIBUTE_ENABLE_BIDI        | \
                                     PRINTER_ATTRIBUTE_QUEUED             | \
                                     PRINTER_ATTRIBUTE_DIRECT             | \
                                     PRINTER_ATTRIBUTE_SHARED             | \
                                     PRINTER_ATTRIBUTE_HIDDEN             | \
                                     PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS    | \
                                     PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST  | \
                                     PRINTER_ATTRIBUTE_ENABLE_DEVQ        | \
                                     PRINTER_ATTRIBUTE_RAW_ONLY           | \
                                     PRINTER_ATTRIBUTE_WORK_OFFLINE)

// Define some constants to make parameters to CreateEvent a tad less obscure:

#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE

typedef struct _ININETPRINT {    /* in */
    DWORD       signature;
    struct _ININETPRINT *pNext;
    DWORD       TickCount;
    LPWSTR      pDescription;
    LPWSTR      pName;
    LPWSTR      pComment;
} ININETPRINT, *PININETPRINT;

#define IN_SIGNATURE    0x494F  /* 'IO' is the signature value */

typedef struct _INIMONITOR {       /* imo */
    DWORD   signature;
    struct  _INIMONITOR *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    LPWSTR  pMonitorDll;
    HANDLE  hModule;
    HANDLE  hMonitor;
    BOOL    bUplevel;
    struct _INISPOOLER *pIniSpooler;
    PMONITORINIT pMonitorInit;
    MONITOR2 Monitor2;  // Uplevel monitor vector.
    MONITOR  Monitor;   // Downlevel vector.
} INIMONITOR, *PINIMONITOR;

#define IMO_SIGNATURE   0x4C50  /* 'LP' is the signature value */


// Enumerate all Xcv handle types here
enum {
    XCVPORT,
    XCVMONITOR
};

typedef BOOL (*PFNXCVDATA)( HANDLE  hXcv,
                            PCWSTR  pszDataName,
                            PBYTE   pInputData,
                            DWORD   cbInputData,
                            PBYTE   pOutputData,
                            DWORD   cbOutputData,
                            PDWORD  pcbOutputNeeded,
                            PDWORD  pdwStatus
                            );

typedef BOOL (*PFNXCVCLOSE)(HANDLE  hXcv);


typedef struct _INIXCV {       /* xp */
    DWORD              signature;
    struct             _INIXCV *pNext;
    DWORD              cRef;
    PWSTR              pszMachineName;
    PWSTR              pszName;
    struct _INISPOOLER *pIniSpooler;
    PINIMONITOR        pIniMonitor;
    HANDLE             hXcv;
} INIXCV, *PINIXCV;

#define XCV_SIGNATURE   0x5850  /* 'XP' is the signature value */

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hProc;          /* Handle to Queue Processor */
    DWORD   Status;              // see PORT_ manifests
    DWORD   PrinterStatus;       // Status values set by language monitor
    LPWSTR  pszStatus;
    HANDLE  Semaphore;           // Port Thread will sleep on this
    struct  _INIJOB *pIniJob;     // Master Job
    DWORD   cJobs;
    DWORD   cPrinters;
    PINIPRINTER *ppIniPrinter; /* -> printer connected to this port */
                               /* no reference count! */
    PINIMONITOR pIniMonitor;
    PINIMONITOR pIniLangMonitor;
    HANDLE      hEvent;
    HANDLE      hMonitorHandle;
    CRITICAL_SECTION	MonitorCS;
    HANDLE  Ready;
    HANDLE  hPortThread;        // Port Thread Handle
    DWORD   IdleTime;
    DWORD   ErrorTime;
    HANDLE  hErrorEvent;
    struct _INISPOOLER *pIniSpooler;    // Spooler whilch owns this port.
    DWORD   InCriticalSection;          // PrintProc Critsec mask. Should be per port instead
                                        // of per printproc.
    HANDLE  hPortThreadRunning;
    BOOL    bIdleTimeValid;
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x4F50  /* 'OP' is the signature value */

//
//  Also add to debugger extentions
//

#define PP_PAUSED         0x000001
#define PP_WAITING        0x000002
#define PP_RUNTHREAD      0x000004  // port thread should be running
#define PP_THREADRUNNING  0x000008  // port thread are running
#define PP_RESTART        0x000010
#define PP_CHECKMON       0x000020  // monitor might get started/stopped
#define PP_STOPMON        0x000040  // stop monitoring this port
#define PP_QPROCCHECK     0x000100  // queue processor needs to be called
#define PP_QPROCPAUSE     0x000200  // pause (otherwise continue) printing job
#define PP_QPROCABORT     0x000400  // abort printing job
#define PP_QPROCCLOSE     0x000800  // close printing job
#define PP_PAUSEAFTER     0x001000  // hold destination
#define PP_MONITORRUNNING 0x002000  // Monitor is running
#define PP_RUNMONITOR     0x004000  // The Monitor should be running
#define PP_MONITOR        0x008000  // There is a Monitor handling this
#define PP_FILE           0x010000  // We are going to a file
#define PP_ERROR          0x020000  // Error status has been set
#define PP_WARNING        0x040000  // Warning status has been set
#define PP_INFORMATIONAL  0x080000  // Informational status been set
#define PP_DELETING       0x100000  // Port is being deleted
#define PP_STARTDOC       0x200000  // Port called with StartDoc active
#define PP_PLACEHOLDER    0x400000  // The port is a placeholder port.

typedef struct _INIFORM {       /* ifo */
    DWORD   signature;
    struct  _INIFORM *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    SIZEL   Size;
    RECTL   ImageableArea;
    DWORD   Type;           // Built-in or user-defined
    DWORD   cFormOrder;
} INIFORM, *PINIFORM;

#define IFO_SIGNATURE   0x4650  /* 'FP' is the signature value */

#define FORM_USERDEFINED  0x0000


typedef struct _SHARED {
    PINIFORM pIniForm;
} SHARED, *PSHARED;

typedef struct _INISPOOLER {
    DWORD         signature;
    struct _INISPOOLER *pIniNextSpooler;
    DWORD         cRef;
    LPWSTR        pMachineName;
    LPWSTR        pDir;
    PINIPRINTER   pIniPrinter;
    PINIENVIRONMENT pIniEnvironment;
    PINIMONITOR   pIniMonitor;
    PINIPORT      pIniPort;
    PSHARED       pShared;
    PININETPRINT  pIniNetPrint;
    struct _SPOOL *pSpool;     /* Linked list of handles for this server */
    LPWSTR        pDefaultSpoolDir;
    LPWSTR        pszRegistryMonitors;
    LPWSTR        pszRegistryEnvironments;
    LPWSTR        pszRegistryEventLog;
    LPWSTR        pszRegistryProviders;
    LPWSTR        pszEventLogMsgFile;
    PVOID         pDriversShareInfo;
    LPWSTR        pszDriversShare;
    LPWSTR        pszRegistryForms;
    DWORD         SpoolerFlags;
    FARPROC       pfnReadRegistryExtra;
    FARPROC       pfnWriteRegistryExtra;
    FARPROC       pfnFreePrinterExtra;
    DWORD         cEnumerateNetworkPrinters;
    DWORD         cAddNetPrinters;
    DWORD         cFormOrderMax;
    LPWSTR        pNoRemotePrintDrivers;
    DWORD         cchNoRemotePrintDrivers;
    HKEY          hckRoot;
    HKEY          hckPrinters;
    DWORD         cFullPrintingJobs;
    HANDLE        hEventNoPrintingJobs;
    HANDLE        hJobIdMap;
    DWORD         dwEventLogging;
    BOOL          bEnableNetPopups;
    DWORD         dwJobCompletionTimeout;
    DWORD         dwBeepEnabled;
    BOOL          bEnableNetPopupToComputer;
    BOOL          bEnableRetryPopups;
    PWSTR         pszClusterSID;
    HANDLE        hClusterToken;
    DWORD         dwRestartJobOnPoolTimeout;
    BOOL          bRestartJobOnPoolEnabled;
    BOOL          bImmortal;
    PWSTR         pszFullMachineName;
    HANDLE        hFilePool;
    LPWSTR        pszClusResDriveLetter;
    LPWSTR        pszClusResID;
    DWORD         dwClusNodeUpgraded;
    HANDLE        hClusSplReady;
    DWORD         cNetPrinters;
    DWORD         dwSpoolerSettings;
} INISPOOLER, *PINISPOOLER;

#define SPOOLER_DISCARDTSJOBS                0x00000001
#define SPOOLER_NOFILEPOOLING                0x00000002
#define SPOOLER_CACHEMASQPRINTERS            0x00000004

#define ISP_SIGNATURE   'ISPL'

typedef struct _INIJOB {   /* ij */
    DWORD           signature;
    struct _INIJOB *pIniNextJob;
    struct _INIJOB *pIniPrevJob;
    DWORD           cRef;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pMachineName;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    PINIPRINTER     pIniPrinter;
    PINIDRIVER      pIniDriver;
    LPDEVMODE       pDevMode;
    PINIPRINTPROC   pIniPrintProc;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           Time;
    DWORD           StartTime;      /* print daily after time: from 00:00 in min */
    DWORD           UntilTime;      /* print daily until time: from 00:00 in min */
    DWORD           Size;
    HANDLE          hWriteFile;
    LPWSTR          pStatus;
    PVOID           pBuffer;
    DWORD           cbBuffer;
    HANDLE          WaitForRead;
    HANDLE          WaitForWrite;
    HANDLE          StartDocComplete;
    DWORD           StartDocError;
    PINIPORT        pIniPort;
    HANDLE          hToken;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           cPagesPrinted;
    DWORD           cPages;
    BOOL            GenerateOnClose; /* Passed to security auditing APIs */
    DWORD           cbPrinted;
    DWORD           NextJobId;           // Job to be printed Next
    struct  _INIJOB *pCurrentIniJob;     // Current Job
    DWORD           dwJobControlsPending;
    DWORD           dwReboots;
    DWORD           dwValidSize;
    LARGE_INTEGER   liFileSeekPosn;
    BOOL            bWaitForEnd;
    HANDLE          WaitForSeek;
    BOOL            bWaitForSeek;
    DWORD           dwJobNumberOfPagesPerSide;
    DWORD           dwDrvNumberOfPagesPerSide;
    DWORD           cLogicalPages;        // number of pages in currently spooling page
    DWORD           cLogicalPagesPrinted; // number of pages in currently printing page
    DWORD           dwAlert;
    LPWSTR          pszSplFileName;
    HANDLE          hFileItem;
    DWORD           AddJobLevel;
    ULONG           SessionId;        // Current jobs initial SessionId
} INIJOB, *PINIJOB;


typedef struct _BUILTIN_FORM {
    DWORD          Flags;
    DWORD          NameId;
    SIZEL          Size;
    RECTL          ImageableArea;
} BUILTIN_FORM, *PBUILTIN_FORM;


#define IJ_SIGNATURE    0x494A  /* 'IJ' is the signature value */

//  WARNING
//  If you add a new JOB_ status field and it is INTERNAL to the spooler
//  Be sure to also to add it to JOB_STATUS_PRIVATE below (see LocalSetJob)
//  AND to the debug extensions ( dbgspl.c )

#define JOB_PRINTING            0x00000001
#define JOB_PAUSED              0x00000002
#define JOB_ERROR               0x00000004
#define JOB_OFFLINE             0x00000008
#define JOB_PAPEROUT            0x00000010
#define JOB_PENDING_DELETION    0x00000020
#define JOB_SPOOLING            0x00000040
#define JOB_DESPOOLING          0x00000080
#define JOB_DIRECT              0x00000100
#define JOB_COMPLETE            0x00000200
#define JOB_PRINTED             0x00000400
#define JOB_RESTART             0x00000800
#define JOB_REMOTE              0x00001000
#define JOB_NOTIFICATION_SENT   0x00002000
#define JOB_TS                  0x00008000 //Job is assigned to a TS queue
#define JOB_PRINT_TO_FILE       0x00040000
#define JOB_TYPE_ADDJOB         0x00080000
#define JOB_BLOCKED_DEVQ        0x00100000
#define JOB_SCHEDULE_JOB        0x00200000
#define JOB_TIMEOUT             0x00400000
#define JOB_ABANDON             0x00800000
#define JOB_DELETED             0x01000000
#define JOB_TRUE_EOJ            0x02000000
#define JOB_COMPOUND            0x04000000
#define JOB_TYPE_OPTIMIZE       0x08000000
#define JOB_PP_CLOSE            0x10000000
#define JOB_DOWNLEVEL           0x20000000
#define JOB_SHADOW_DELETED      0x40000000
#define JOB_INTERRUPTED         0x80000000
#define JOB_HIDDEN              JOB_COMPOUND

//
// These flags should be saved when we are updating job
// status.  (They are not settable.)

#define JOB_STATUS_PRIVATE (JOB_DESPOOLING | JOB_DIRECT | JOB_COMPLETE | \
                            JOB_RESTART | JOB_PRINTING | JOB_REMOTE | \
                            JOB_SPOOLING | JOB_PRINTED | JOB_PENDING_DELETION |\
                            JOB_ABANDON | JOB_TIMEOUT | JOB_SCHEDULE_JOB | \
                            JOB_BLOCKED_DEVQ | JOB_TYPE_ADDJOB | JOB_PRINT_TO_FILE |\
                            JOB_NOTIFICATION_SENT | JOB_DELETED | JOB_TRUE_EOJ | JOB_COMPOUND |\
                            JOB_TYPE_OPTIMIZE | JOB_PP_CLOSE | JOB_DOWNLEVEL | JOB_INTERRUPTED |\
                            JOB_TS )

#define JOB_NO_ALERT            0x00000001
#define JOB_ENDDOC_CALL         0x00000002

typedef enum _ESTATUS {
    STATUS_NULL             = 0x00000000,
    STATUS_FAIL             = 0x00000000,
    STATUS_PORT             = 0x00000001,
    STATUS_INFO             = 0x00000002,
    STATUS_VALID            = 0x00000004,
    STATUS_PENDING_DELETION = 0x00000008,
    STATUS_CLOSING          = 0x00000010,

} ESTATUS;

typedef struct _SPLMAPVIEW {
    struct _SPLMAPVIEW *pNext;
    HANDLE              hMapSpoolFile;
    LPBYTE              pStartMapView;
    DWORD               dwMapSize;
} SPLMAPVIEW, *PSPLMAPVIEW;


typedef enum
{
    kMappedJobSpoolFileObtained     =   0x01,
    kMappedJobAddJob                =   0x02

} EJobMappingStatus;

typedef struct _MAPPED_JOB {

    struct _MAPPED_JOB *pNext;
    LPWSTR              pszSpoolFile;
    DWORD               JobId;
    DWORD               fStatus;

} MAPPED_JOB, *PMAPPED_JOB;

typedef struct _SPOOL {
    DWORD           signature;
    struct _SPOOL  *pNext;
    DWORD           cRef;
    LPWSTR          pName;
    LPWSTR          pFullMachineName;
    LPWSTR          pDatatype;
    PINIPRINTPROC   pIniPrintProc;
    LPDEVMODE       pDevMode;
    PINIPRINTER     pIniPrinter;
    PINIPORT        pIniPort;
    PINIJOB         pIniJob;
    DWORD           TypeofHandle;
    PINIPORT        pIniNetPort;    /* Non-NULL if there's a network port */
    HANDLE          hPort;
    DWORD           Status;
    ACCESS_MASK     GrantedAccess;
    DWORD           ChangeFlags;
    DWORD           WaitFlags;
    PDWORD          pChangeFlags;
    HANDLE          ChangeEvent;
    DWORD           OpenPortError;
    HANDLE          hNotify;
    ESTATUS         eStatus;
    PINISPOOLER     pIniSpooler;
    PINIXCV         pIniXcv;
    BOOL            GenerateOnClose;
    HANDLE          hFile;
    DWORD           adwNotifyVectors[NOTIFY_TYPE_MAX];
    HANDLE          hReadFile;        // allow multiple readers of a single job
    SPLCLIENT_INFO_1 SplClientInfo1;
    PSPLMAPVIEW     pSplMapView;
    PMAPPED_JOB     pMappedJob;
    ULONG           SessionId;
    HANDLE          hClientToken;
} SPOOL;

typedef SPOOL *PSPOOL;
#define SPOOL_SIZE  sizeof( SPOOL )

#define SJ_SIGNATURE    0x464D  /* 'FM' is the signature value */

#define MAX_SPL_MAPVIEW_SIZE     0x00050000   // Max view size if 5x64K. It should be a multiple
                                              // of the allocation granularity (64K)

typedef struct _SPOOLIC {
    DWORD signature;
    PINIPRINTER pIniPrinter;
} SPOOLIC, *PSPOOLIC;

#define IC_SIGNATURE 0x4349 /* 'CI' is the signature value */

#define SPOOL_STATUS_STARTDOC       0x00000001
#define SPOOL_STATUS_BEGINPAGE      0x00000002
#define SPOOL_STATUS_CANCELLED      0x00000004
#define SPOOL_STATUS_PRINTING       0x00000008
#define SPOOL_STATUS_ADDJOB         0x00000010
#define SPOOL_STATUS_PRINT_FILE     0x00000020
#define SPOOL_STATUS_NOTIFY         0x00000040
#define SPOOL_STATUS_ZOMBIE         0x00000080
#define SPOOL_STATUS_FLUSH_PRINTER  0x00000100

#define PRINTER_HANDLE_PRINTER      0x00000001
#define PRINTER_HANDLE_JOB          0x00000002
#define PRINTER_HANDLE_PORT         0x00000004
#define PRINTER_HANDLE_DIRECT       0x00000008
#define PRINTER_HANDLE_SERVER       0x00000010
#define PRINTER_HANDLE_3XCLIENT     0x00000020
#define PRINTER_HANDLE_REMOTE_CALL  0x00000040 // Client is remote
#define PRINTER_HANDLE_REMOTE_DATA  0x00000080 // Data should appear remote
#define PRINTER_HANDLE_XCV_PORT     0x00000100
#define PRINTER_HANDLE_REMOTE_ADMIN 0x00000200 // User is remote admin (may not have requested admin privileges)

//
// We need to distinguish between remote users and remote data since
// the server service Opens with \\server\printer (for clustering) yet
// this is a remote call.  AddJob should succeed, but the data from
// GetPrinterDriver should appear remote.
//

#define INVALID_PORT_HANDLE     NULL    /* winspool tests for NULL handles */

typedef struct _SHADOWFILE {   /* sf */
    DWORD           signature;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
} SHADOWFILE, *PSHADOWFILE;

#define SF_SIGNATURE    0x494B  /* 'IK' is the signature value */


typedef struct _SHADOWFILE_2 {   /* Sf */
    DWORD           signature;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
    DWORD           Version;
    DWORD           dwReboots;      // If read at ReadShadowJob, this is number of reboots
                                    // done while printing this job
} SHADOWFILE_2, *PSHADOWFILE_2;

#define SF_SIGNATURE_2    0x4966  /* 'If' is the signature value */

typedef struct _SHADOWFILE_3 {   /* Sg */
    DWORD           signature;
    DWORD           cbSize;
    DWORD           Status;
    DWORD           JobId;
    DWORD           Priority;
    LPWSTR          pNotify;
    LPWSTR          pUser;
    LPWSTR          pDocument;
    LPWSTR          pOutputFile;
    LPWSTR          pPrinterName;
    LPWSTR          pDriverName;
    LPDEVMODE       pDevMode;
    LPWSTR          pPrintProcName;
    LPWSTR          pDatatype;
    LPWSTR          pParameters;
    SYSTEMTIME      Submitted;
    DWORD           StartTime;
    DWORD           UntilTime;
    DWORD           Size;
    DWORD           cPages;
    DWORD           cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD           NextJobId;
    DWORD           Version;
    DWORD           dwReboots;      // If read at ReadShadowJob, this is number of reboots
                                    // done while printing this job
    LPWSTR          pMachineName;
    DWORD           dwValidSize;
} SHADOWFILE_3, *PSHADOWFILE_3;

#define SF_SIGNATURE_3           0x4967  /* 'Ig' is the signature value */
#define SF_SIGNATURE_3_DOTNET    0x4968
#define SF_VERSION_3             3

typedef struct
{
    HANDLE          hUserToken;
    PINIPRINTER     pIniPrinter;

} MasqUpdateThreadData;

#define FindEnvironment( psz, pIniSpooler )                                 \
    (PINIENVIRONMENT)FindIniKey( (PINIENTRY)pIniSpooler->pIniEnvironment,   \
                                 (LPWSTR)(psz) )

#define FindPort( psz, pIniSpooler )                                        \
    (PINIPORT)FindIniKey( (PINIENTRY)pIniSpooler->pIniPort,                 \
                          (LPWSTR)(psz))

#define FindPrinter( psz,pIniSpooler )                                      \
    (PINIPRINTER)FindIniKey( (PINIENTRY)pIniSpooler->pIniPrinter,           \
                             (LPWSTR)(psz) )

#define FindPrintProc( psz, pEnv )                                          \
    (PINIPRINTPROC)FindIniKey( (PINIENTRY)(pEnv)->pIniPrintProc,            \
                               (LPWSTR)(psz) )

#define FindForm( psz, pIniSpooler )                                        \
    (PINIFORM)FindIniKey( (PINIENTRY)pIniSpooler->pShared->pIniForm,        \
                          (LPWSTR)(psz) )

#define FindMonitor( psz, pIniSpooler )                                     \
    (PINIMONITOR)FindIniKey( (PINIENTRY)pIniSpooler->pIniMonitor,           \
                             (LPWSTR)(psz) )

PINISPOOLER
FindSpooler(
    LPCTSTR pszMachine,
    DWORD SpoolerFlags
    );

#define RESIZEPORTPRINTERS(a, c)   ReallocSplMem((a)->ppIniPrinter, \
                                     (a)->cPrinters * sizeof((a)->ppIniPrinter), \
                                   ( (a)->cPrinters + (c) ) * sizeof( (a)->ppIniPrinter ) )

#define RESIZEPRINTERPORTS(a, c)   ReallocSplMem((a)->ppIniPorts, \
                                     (a)->cPorts * sizeof((a)->ppIniPorts), \
                                   ( (a)->cPorts + (c) ) * sizeof( (a)->ppIniPorts ) )

#define BIT(index) (1<<index)
#define BIT_ALL ((DWORD)~0)
#define BIT_NONE 0


//
// Enumerations for index tables.
//
enum {
#define DEFINE(field, x, y, table, offset) I_PRINTER_##field,
#include <ntfyprn.h>
#undef DEFINE
    I_PRINTER_END
};

enum {
#define DEFINE(field, x, y, table, offset) I_JOB_##field,
#include <ntfyjob.h>
#undef DEFINE
    I_JOB_END
};


#define INCJOBREF(pIniJob) pIniJob->cRef++
#define DECJOBREF(pIniJob) pIniJob->cRef--

#define INITJOBREFONE(pIniJob) (pIniJob->cRef = 1)

#define INCPRINTERREF(pIniPrinter) { SPLASSERT( pIniPrinter->signature == IP_SIGNATURE ); \
                                     pIniPrinter->cRef++;                                 \
                                     if ( pIniPrinter->cRef > pIniPrinter->MaxcRef) {     \
                                        pIniPrinter->MaxcRef = pIniPrinter->cRef;         \
                                     }                                                    \
                                   }
#define DECPRINTERREF(pIniPrinter) { SPLASSERT( pIniPrinter->signature == IP_SIGNATURE ); \
                                     SPLASSERT( pIniPrinter->cRef != 0 );                 \
                                     pIniPrinter->cRef--;                                 \
                                   }

#define INC_PRINTER_ZOMBIE_REF(pIniPrinter) pIniPrinter->cZombieRef++
#define DEC_PRINTER_ZOMBIE_REF(pIniPrinter) pIniPrinter->cZombieRef--


#if DBG

#define INCSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    if( gpDbgPointers ) {                                           \
        gpDbgPointers->pfnCaptureBackTrace( ghbtClusterRef,         \
                                            (ULONG_PTR)pIniSpooler,  \
                                            pIniSpooler->cRef,      \
                                            pIniSpooler->cRef + 1 );\
    }                                                               \
    pIniSpooler->cRef++;                                            \
}

#define DECSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    SPLASSERT( pIniSpooler->cRef != 0 );                            \
    if( gpDbgPointers ) {                                           \
        gpDbgPointers->pfnCaptureBackTrace( ghbtClusterRef,         \
                                            (ULONG_PTR)pIniSpooler,  \
                                            pIniSpooler->cRef,      \
                                            pIniSpooler->cRef - 1 );\
    }                                                               \
    --pIniSpooler->cRef;                                            \
    DeleteSpoolerCheck( pIniSpooler );                              \
}

#else

#define INCSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    pIniSpooler->cRef++;                                            \
}

#define DECSPOOLERREF(pIniSpooler)                                  \
{                                                                   \
    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );           \
    SPLASSERT( pIniSpooler->cRef != 0 );                            \
    --pIniSpooler->cRef;                                            \
    DeleteSpoolerCheck( pIniSpooler );                              \
}

#endif


#define INCPORTREF(pIniPort) { SPLASSERT( pIniPort->signature == IPO_SIGNATURE ); \
                                     ++pIniPort->cRef;  \
                                    }

#define DECPORTREF(pIniPort) { SPLASSERT( pIniPort->signature == IPO_SIGNATURE ); \
                               SPLASSERT( pIniPort->cRef != 0 ); \
                                     --pIniPort->cRef;  \
                                    }

#define INCMONITORREF(pIniMonitor) { SPLASSERT( pIniMonitor->signature == IMO_SIGNATURE ); \
                                     ++pIniMonitor->cRef;  \
                                   }

#define DECMONITORREF(pIniMonitor) { SPLASSERT( pIniMonitor->signature == IMO_SIGNATURE ); \
                                     SPLASSERT( pIniMonitor->cRef != 0 ); \
                                     --pIniMonitor->cRef;  \
                                   }

extern DWORD    IniDriverOffsets[];
extern DWORD    IniPrinterOffsets[];
extern DWORD    IniSpoolerOffsets[];
extern DWORD    IniEnvironmentOffsets[];
extern DWORD    IniPrintProcOffsets[];

#define INCDRIVERREF( pIniDriver ) { SPLASSERT( pIniDriver->signature == ID_SIGNATURE ); \
                                     pIniDriver->cRef++;                                 \
                                   }

#define DECDRIVERREF( pIniDriver ) { SPLASSERT( pIniDriver->signature == ID_SIGNATURE ); \
                                     SPLASSERT( pIniDriver->cRef != 0 );                 \
                                     pIniDriver->cRef--;                                 \
                                   }

#define DEFAULT_SERVER_THREAD_PRIORITY          THREAD_PRIORITY_NORMAL
#define DEFAULT_SPOOLER_PRIORITY                THREAD_PRIORITY_NORMAL
#define DEFAULT_PORT_THREAD_PRIORITY            THREAD_PRIORITY_NORMAL
#define DEFAULT_SCHEDULER_THREAD_PRIORITY       THREAD_PRIORITY_NORMAL
#define DEFAULT_JOB_COMPLETION_TIMEOUT          160000
#define DEFAULT_JOB_RESTART_TIMEOUT_ON_POOL_ERROR          600 // 10 minutes

#define PortToPrinterStatus(dwPortStatus) (PortToPrinterStatusMappings[dwPortStatus])

extern PWCHAR ipszRegistryPrinters;
extern PWCHAR ipszRegistryMonitors;
extern PWCHAR ipszRegistryProviders;
extern PWCHAR ipszRegistryEnvironments;
extern PWCHAR ipszClusterDatabaseEnvironments;
extern PWCHAR ipszRegistryForms;
extern PWCHAR ipszEventLogMsgFile;
extern PWCHAR ipszDriversShareName;
extern PWCHAR ipszRegistryEventLog;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\spooler.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    spooler.c

Abstract:

    This module provides all the public exported APIs relating to spooling
    and printing for the Local Print Providor. They include

    LocalStartDocPrinter
    LocalWritePrinter
    LocalReadPrinter
    LocalEndDocPrinter
    LocalAbortPrinter

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "jobid.h"
#include "filepool.hxx"

//extern HANDLE hFilePool;

BOOL
SpoolThisJob(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
PrintingDirectlyToPort(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo,
    LPDWORD pJobId
);

BOOL
PrintingDirect(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
);

DWORD
ReadFromPrinter(
    PSPOOL  pSpool,
    LPBYTE  pBuf,
    DWORD   cbBuf
);

BOOL
InternalReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPBYTE   *pMapBuffer,
   LPDWORD  pNoBytesRead,
   BOOL     bReadMappedView
);

BOOL SetMappingPointer(
    PSPOOL pSpool,
    LPBYTE *pMappedBuffer,
    DWORD  cbReadSize
);

DWORD
WriteToPrinter(
    PSPOOL  pSpool,
    LPBYTE  pByte,
    DWORD   cbBuf
);

BOOL
IsGoingToFile(
    LPWSTR pOutputFile,
    PINISPOOLER pIniSpooler
    );

VOID
MyPostThreadMessage(
    IN HANDLE   hThread,
    IN DWORD    idThread,
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    SplOutSem();

    //
    // PostThreadMessage will fail under the following cases:
    //      a. Too early -- MessageBox has not been created yet
    //      b. Too late -- User has cancelled the dialog
    //
    // In case a. if we wait for few seconds and retry Post will succeed
    // In case b. WaitForSingleObject on thread handle will return WAIT_OBJECT_O
    //
    while ( !PostThreadMessage(idThread, Msg, wParam, lParam) ) {

        DBGMSG(DBG_WARNING, ("PostThreadMessage FAILED %d\n", GetLastError()));

        //
        // As far as thread is alive after 1 second retry the post
        //
        if ( WaitForSingleObject(hThread, 1000) != WAIT_TIMEOUT )
            break;
    }
}


VOID
SeekPrinterSetEvent(
    PINIJOB  pIniJob,
    HANDLE   hFile,
    BOOL     bEndDoc
    )
{
    DWORD    dwFileSizeHigh,dwFileSizeLow;

    if (!hFile) {
       hFile = pIniJob->hWriteFile;
    }

    if (pIniJob->bWaitForSeek && pIniJob->WaitForSeek != NULL ){

       if (!bEndDoc) {

          // Compare the sizes.
          if (pIniJob->Status & JOB_TYPE_OPTIMIZE) {
              dwFileSizeHigh = 0;
              dwFileSizeLow = pIniJob->dwValidSize;
          } else {
              dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
              if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
                  return;
              }
          }

          if ((pIniJob->liFileSeekPosn.u.HighPart > (LONG)dwFileSizeHigh) ||
              ((pIniJob->liFileSeekPosn.u.HighPart == (LONG)dwFileSizeHigh) &&
               (pIniJob->liFileSeekPosn.u.LowPart > dwFileSizeLow))) {
             return;
          }

       }

       SetEvent(pIniJob->WaitForSeek);
    }

    return;
}


DWORD
LocalStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    PINIPRINTER pIniPrinter;
    PINIPORT    pIniPort;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       LastError=0, JobId=0;
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    BOOL        bPrintingDirect;

    SPLASSERT(Level == 1);

    if (ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ) &&
       !(pSpool->Status & SPOOL_STATUS_STARTDOC) &&
       !(pSpool->Status & SPOOL_STATUS_ADDJOB)) {

        if ((pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
             (pIniPort = pSpool->pIniPort) &&
             (pIniPort->signature == IPO_SIGNATURE)) {

            if (!(PrintingDirectlyToPort(pSpool, Level, pDocInfo, &JobId))) {
                return FALSE;
            }

        } else if ((pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) &&
                   (pIniPrinter = pSpool->pIniPrinter)) {

            bPrintingDirect = FALSE;

            if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {

                bPrintingDirect = TRUE;

            } else {

                EnterSplSem();
                bPrintingDirect = IsGoingToFile(pDocInfo1->pOutputFile,
                                                pSpool->pIniSpooler);

                LeaveSplSem();
            }

            if (bPrintingDirect) {

                if (!PrintingDirect(pSpool, Level, pDocInfo))
                    return FALSE;

            } else {

                if (!SpoolThisJob(pSpool, Level, pDocInfo))
                    return FALSE;
            }

        } else

            LastError = ERROR_INVALID_PARAMETER;

        if (!LastError) {
            pSpool->Status |= SPOOL_STATUS_STARTDOC;
            pSpool->Status &= ~SPOOL_STATUS_CANCELLED;
        }

    } else

        LastError = ERROR_INVALID_HANDLE;


    if (LastError) {
       DBGMSG(DBG_WARNING, ("StartDoc FAILED %d\n", LastError));
        SetLastError(LastError);
        return FALSE;
    }

    if (JobId)
        return JobId;
    else
        return pSpool->pIniJob->JobId;
}

BOOL
LocalStartPagePrinter(
    HANDLE  hPrinter
    )
/*++

    Bug-Bug:  StartPagePrinter and EndPagePrinter calls should be
    supported only for SPOOL_STATUS_STARTDOC handles only. However
    because of our fixes for the engine, we cannot fail StartPagePrinter
    and EndPagePrinter for SPOOL_STATUS_ADDJOB as well.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return(FALSE);
    }
    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if(!(pSpool->Status & SPOOL_STATUS_STARTDOC) &&
       !(pSpool->Status & SPOOL_STATUS_ADDJOB))
    {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        return FALSE;
    }

    if (pSpool->pIniJob != NULL) {

        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
            ((pSpool->pIniJob->Status & JOB_PRINTING) ||
             (pSpool->pIniJob->Status & JOB_DESPOOLING))) {

        //
        //  Account for Pages Printed in LocalEndPagePrinter
        //


        } else {

            // We Are Spooling
            UpdateJobAttributes(pSpool->pIniJob);

            pSpool->pIniJob->cLogicalPages++;
            if (pSpool->pIniJob->cLogicalPages >=
                   pSpool->pIniJob->dwJobNumberOfPagesPerSide)
            {
                pSpool->pIniJob->cLogicalPages = 0;
                pSpool->pIniJob->cPages++;
            }

            if ( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ) {

                // If the Job is being written on the client side
                // the size is not getting updated so do it now on
                // the start page

                if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

                    hFile = pSpool->hReadFile;

                } else {

                    hFile = pSpool->pIniJob->hWriteFile;

                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    dwFileSize = GetFileSize( hFile, 0 );

                    if ( pSpool->pIniJob->Size < dwFileSize ) {

                         DBGMSG( DBG_TRACE, ("StartPagePrinter adjusting size old %d new %d\n",
                            pSpool->pIniJob->Size, dwFileSize));

                         pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                         pSpool->pIniJob->Size = dwFileSize;

                         // Support for despooling whilst spooling
                         // for Down Level jobs

                         if (pSpool->pIniJob->WaitForWrite != NULL)
                            SetEvent( pSpool->pIniJob->WaitForWrite );
                    }

                }
            }

        }

    } else {
        DBGMSG(DBG_TRACE, ("StartPagePrinter issued with no Job\n"));
    }



    return TRUE;
}

PINIPORT
FindFilePort(
    LPWSTR pFileName,
    PINISPOOLER pIniSpooler)
{
    PINIPORT pIniPort;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniSpooler->pIniPort;
    while (pIniPort) {
        if (!wcscmp(pIniPort->pName, pFileName)
                && (pIniPort->Status & PP_FILE)){
                    return (pIniPort);
        }
        pIniPort = pIniPort->pNext;
    }
    return NULL;
}

PINIMONITOR
FindFilePortMonitor(
    PINISPOOLER pIniSpooler
)
{
    PINIPORT pIniPort;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    pIniPort = pIniSpooler->pIniPort;
    while (pIniPort) {
        if (!wcscmp(pIniPort->pName, L"FILE:")) {
            return pIniPort->pIniMonitor;
        }
        pIniPort = pIniPort->pNext;
    }
    return NULL;
}

BOOL
AddIniPrinterToIniPort(
    PINIPORT pIniPort,
    PINIPRINTER pIniPrinter
    )
{
    DWORD i;
    PINIPRINTER *ppIniPrinter;

    //
    // If Printer already attatched to Port
    //

    for (i = 0; i < pIniPort->cPrinters; i++) {
        if (pIniPort->ppIniPrinter[i] == pIniPrinter) {
            return TRUE;
        }
    }

    ppIniPrinter = RESIZEPORTPRINTERS(pIniPort, 1);

    if ( ppIniPrinter != NULL ) {

        pIniPort->ppIniPrinter = ppIniPrinter;
        if ( !pIniPort->cPrinters )
            CreateRedirectionThread(pIniPort);
        pIniPort->ppIniPrinter[pIniPort->cPrinters++] = pIniPrinter;

        DBGMSG( DBG_TRACE, ("AddIniPrinterToIniPort pIniPrinter %x %ws pIniPort %x %ws\n",
                             pIniPrinter, pIniPrinter->pName,
                             pIniPort, pIniPort->pName ));
        return TRUE;

    } else {
        DBGMSG( DBG_WARNING, ("AddIniPrintertoIniPort failed pIniPort %x pIniPrinter %x error %d\n",
                               pIniPort, pIniPrinter, GetLastError() ));
        return FALSE;
    }
}

BOOL
AddIniPortToIniPrinter(
    IN  PINIPRINTER pIniPrinter,
    IN  PINIPORT pIniPort
)
/*++

Routine Description:
    Adds a IniPort structure to a IniPrinter.
    A link between a printer and a port must be bi-directional.
    It is mandatory to call AddIniPrinterToIniPort in pair with this function or to handle the bi-dir link.

Arguments:

    pIniPrinter - printer that is going to use the port

    pIniPort    - port to be assigned to printer

Return Value:

    BOOL    - TRUE if the port succesfully assigned to printer or if the printer is already assigned to port

--*/
{
    DWORD i;
    PINIPORT *ppIniPorts;

    //
    // Search if Port is already attached to Printer and return TRUE if it does
    //
    for (i = 0; i < pIniPrinter->cPorts; i++) {
        if (pIniPrinter->ppIniPorts[i] == pIniPort) {
            return TRUE;
        }
    }

    ppIniPorts = RESIZEPRINTERPORTS(pIniPrinter, 1);

    if ( ppIniPorts != NULL ) {

        pIniPrinter->ppIniPorts = ppIniPorts;

        pIniPrinter->ppIniPorts[pIniPrinter->cPorts++] = pIniPort;

        DBGMSG( DBG_TRACE, ("AddIniPortToIniPrinter pIniPort %x %ws pIniPrinter %x %ws\n",
                             pIniPort, pIniPort->pName,
                             pIniPrinter, pIniPrinter->pName ));
        return TRUE;

    } else {
        DBGMSG( DBG_WARNING, ("AddIniPrintertoIniPort failed pIniPort %x pIniPrinter %x error %d\n",
                               pIniPort, pIniPrinter, GetLastError() ));
        return FALSE;
    }
}

VOID
AddJobEntry(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
)
{
   DWORD    Position;
   SplInSem();

    // DO NOT Add the Same Job more than once

    SPLASSERT(pIniJob != FindJob(pIniPrinter, pIniJob->JobId, &Position));

    pIniJob->pIniPrevJob = pIniPrinter->pIniLastJob;

    if (pIniJob->pIniPrevJob)
        pIniJob->pIniPrevJob->pIniNextJob = pIniJob;

    pIniPrinter->pIniLastJob = pIniJob;

    if (!pIniPrinter->pIniFirstJob)
        pIniPrinter->pIniFirstJob=pIniJob;
}

BOOL
CheckDataTypes(
    PINIPRINTPROC pIniPrintProc,
    LPWSTR  pDatatype
)
{
    PDATATYPES_INFO_1 pDatatypeInfo;
    DWORD   i;

    pDatatypeInfo = (PDATATYPES_INFO_1)pIniPrintProc->pDatatypes;

    for (i=0; i<pIniPrintProc->cDatatypes; i++)
        if (!lstrcmpi(pDatatypeInfo[i].pName, pDatatype))
            return TRUE;

    return FALSE;
}

PINIPRINTPROC
FindDatatype(
    PINIPRINTPROC pDefaultPrintProc,
    LPWSTR  pDatatype
)
{
    PINIPRINTPROC pIniPrintProc;

    if ( pDatatype == NULL ) {
        return NULL;
    }

    //
    // !! HACK !!
    //
    // Our method of exposing NT EMF 1.00x is broken.  EMF jobs are created
    // by GDI using NT EMF 1.003 on NT4 and 1.008 on Win2000.  Therefore,
    // a print processor written for NT4 will not work on Win2000 because
    // they didn't know about the new datatype.  Usually the print processor
    // doesn't parse the EMF.  If they do, they are really broken.
    //
    // This hack is to call the IHV print processor with 1.008 EMF.
    //

    if (pDefaultPrintProc)
    {
        //
        // If the datatype is supported by the print processor OR
        // the datatype is NT EMF 1.008 (Win2000) and the print processor
        // supports NT EMF 1.003, then return this print processor.
        //
        if (CheckDataTypes(pDefaultPrintProc, pDatatype) ||
            (!_wcsicmp(pDatatype, gszNT5EMF) &&
             CheckDataTypes(pDefaultPrintProc, gszNT4EMF))) {

            return pDefaultPrintProc;
        }
    }

    pIniPrintProc = pThisEnvironment->pIniPrintProc;

    while ( pIniPrintProc ) {

        if ( CheckDataTypes( pIniPrintProc, pDatatype )) {
           return pIniPrintProc;
        }

        pIniPrintProc = pIniPrintProc->pNext;
    }

    DBGMSG( DBG_WARNING, ( "FindDatatype: Could not find Datatype\n") );

    return FALSE;
}


BOOL
IsGoingToFile(
    LPWSTR pOutputFile,
    PINISPOOLER pIniSpooler)
{
    PINIPORT        pIniPort;
    LPWSTR          pszShare;

    SplInSem();

    SPLASSERT(pIniSpooler->signature == ISP_SIGNATURE);

    //
    // Validate the contents of the pIniJob->pOutputFile
    // if it is a valid file, then return true
    // if it is a port name or any other kind of name then ignore
    //
    if (pOutputFile && *pOutputFile) {

        //
        // we have a non-null pOutputFile
        // match this with all available ports
        //

        pIniPort = pIniSpooler->pIniPort;

        while ( pIniPort ) {

            SPLASSERT( pIniPort->signature == IPO_SIGNATURE );

            if (!_wcsicmp( pIniPort->pName, pOutputFile )) {

                //
                // We have matched the pOutputFile field with a
                // valid port and the port is not a file port
                //
                if (pIniPort->Status & PP_FILE) {
                    pIniPort = pIniPort->pNext;
                    continue;
                }

                return FALSE;
            }

            pIniPort = pIniPort->pNext;
        }

        //
        // We have no port that matches exactly
        // so let's assume its a file.
        //
        // ugly hack -- check for Net: as the name
        //
        // This would normally match files like "NewFile" or "Nextbox,"
        // but since we always fully qualify filenames, we don't encounter
        // any problems.
        //
        if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {
            return FALSE;
        }

        //
        // We have the problem LAN man ports coming as UNC path and being
        // treated as files. This is a HACK for that
        //
        if ( pOutputFile                    &&
             pOutputFile[0] == L'\\'        &&
             pOutputFile[1] == L'\\'        &&
             (pszShare = wcschr(pOutputFile+2, L'\\')) ) {

            pszShare++;
            if ( FindPrinter(pszShare, pIniSpooler) ||
                 FindPrinterShare(pszShare, pIniSpooler) )
                return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
SpoolThisJob(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    WCHAR       szFileName[MAX_PATH];
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    HANDLE      hImpersonationToken;
    DWORD       dwId = 0;
    HANDLE      hWriteFile = INVALID_HANDLE_VALUE;
    LPWSTR      pszDatatype = NULL;
    HANDLE      pSplFilePoolItem = NULL;
    HRESULT     RetVal = S_OK;
    LPWSTR      pszName = NULL;
    BOOL        bRemote;

    DBGMSG(DBG_TRACE, ("Spooling document %ws\n",
                       pDocInfo1->pDocName ? pDocInfo1->pDocName : L""));

    if( pDocInfo1 && pDocInfo1->pDatatype ){

        pszDatatype = pDocInfo1->pDatatype;

        //
        // !! HACK !!
        //
        // We will do not support sending NT4 EMF to NT5 servers (NT EMF 1.003).
        // However, the HP LJ 1100 monolith installation program requires
        // that this datatype is available.  So we added this back to winprint,
        // but we don't want people to use it.  Therefore we will reject
        // the datatype here.  Big hack.
        //
        if( !FindDatatype( NULL, pszDatatype ) ||
            !_wcsicmp(pszDatatype, gszNT4EMF)){

            DBGMSG(DBG_WARNING, ("Datatype %ws is invalid\n", pDocInfo1->pDatatype));

            SetLastError(ERROR_INVALID_DATATYPE);
            return FALSE;
        }
    }

   EnterSplSem();

    //
    // Check if we need to disallow EMF printing.
    //
    if( pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ){

        if( !pszDatatype ){
            pszDatatype = pSpool->pDatatype ?
                              pSpool->pDatatype :
                              pSpool->pIniPrinter->pDatatype;
        }

        if( !ValidRawDatatype( pszDatatype )){
            LeaveSplSem();

            DBGMSG(DBG_WARNING, ("Datatype %ws is not RAW to a RAW printer\n", pDocInfo1->pDatatype));

            SetLastError(ERROR_INVALID_DATATYPE);
            return FALSE;
        }
    }

    dwId = GetNextId( pSpool->pIniPrinter->pIniSpooler->hJobIdMap );

    //
    // If we are using keep printed jobs, or an independent spool directory
    // exists for this printer, then we don't want to use the file pool.
    //
    if ( pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ||
         pSpool->pIniPrinter->pSpoolDir ||
         pSpool->pIniPrinter->pIniSpooler->dwSpoolerSettings & SPOOLER_NOFILEPOOLING)
    {
        GetFullNameFromId(pSpool->pIniPrinter, dwId, TRUE, szFileName, COUNTOF(szFileName), FALSE);
    }

    LeaveSplSem();
    SplOutSem();

    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(dwId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);

    if (!(hImpersonationToken = RevertToPrinterSelf())) {
        DBGMSG(DBG_WARNING, ("SpoolThisJob RevertToPrinterSelf failed: %d\n", GetLastError()));
        SplOutSem();
        return FALSE;
    }

    //
    // If keep printed jobs is enabled for this printer, or if the printer has
    // a spool directory, or if the filepooling for the spooler have been
    // turned off, then we don't use the file pool.
    //
    if (pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS ||
        pSpool->pIniPrinter->pSpoolDir ||
        pSpool->pIniPrinter->pIniSpooler->dwSpoolerSettings & SPOOLER_NOFILEPOOLING)
    {
        hWriteFile = CreateFile(szFileName,
                                GENERIC_WRITE | GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL |
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

    }
    else
    {
        //
        // We're not keeping Printed Jobs, use the Pool.
        //
        //
        // This sets up the Spool and Shadow Files at the same time.
        //
        RetVal = GetFileItemHandle(pSpool->pIniPrinter->pIniSpooler->hFilePool, &pSplFilePoolItem, NULL);

        if (SUCCEEDED(RetVal))
        {
            RetVal = GetWriterFromHandle(pSplFilePoolItem, &hWriteFile, TRUE);

            if (FAILED(RetVal))
            {
                hWriteFile = INVALID_HANDLE_VALUE;
            }

            RetVal = GetNameFromHandle(pSplFilePoolItem, &pszName, TRUE);

            if (SUCCEEDED(RetVal))
            {
                RetVal = StringCchCopy(szFileName, COUNTOF(szFileName), pszName);
            }
            else
            {
                szFileName[0] = '\0';
            }
        }
        else
        {
            hWriteFile = INVALID_HANDLE_VALUE;
        }
    }

    if (!ImpersonatePrinterClient(hImpersonationToken)) {
        DBGMSG(DBG_WARNING, ("SpoolThisJob ImpersonatePrinterClient failed: %d\n", GetLastError()));
        SplOutSem();
        return FALSE;
    }

    if ( hWriteFile == INVALID_HANDLE_VALUE ) {

        DBGMSG(DBG_WARNING, ("SpoolThisJob CreateFile( %ws ) GENERIC_WRITE failed: Error %d\n",
                             szFileName, GetLastError()));

        SplOutSem();
        return FALSE;

    } else {

        DBGMSG(DBG_TRACE, ("SpoolThisJob CreateFile( %ws) GENERIC_WRITE Success:hWriteFile %x\n",szFileName, hWriteFile));

    }

    RetVal = CheckLocalCall();

    if (RetVal == S_OK)
    {
        bRemote = FALSE;
    }
    else if (RetVal == S_FALSE)
    {
        bRemote = TRUE;
    }
    else
    {
        SetLastError(SCODE_CODE(RetVal));
        return FALSE;
    }


    EnterSplSem();

    if( !(pSpool->pIniJob = CreateJobEntry(pSpool,
                                           Level,
                                           pDocInfo,
                                           dwId,
                                           bRemote,
                                           0,
                                           NULL)))
    {
        LeaveSplSem();

        if ( pSplFilePoolItem )
        {
            FinishedWriting(pSplFilePoolItem, TRUE);
            ReleasePoolHandle(&pSplFilePoolItem);
        }
        else
        {
            CloseHandle( hWriteFile );
            DeleteFile( szFileName );
        }

        SplOutSem();
        return FALSE;
    }

    if ( pSplFilePoolItem )
    {
        pSpool->pIniJob->hFileItem = pSplFilePoolItem;
        if ( pszName )
        {
            pSpool->pIniJob->pszSplFileName = pszName;
        }
    }


    SPLASSERT(!IsGoingToFile(pSpool->pIniJob->pOutputFile,
                             pSpool->pIniSpooler));

    InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_SPOOLING);

    //
    // Gather Stress Information for Max Number of concurrent spooling jobs
    //
    pSpool->pIniPrinter->cSpooling++;
    if (pSpool->pIniPrinter->cSpooling > pSpool->pIniPrinter->cMaxSpooling)
        pSpool->pIniPrinter->cMaxSpooling = pSpool->pIniPrinter->cSpooling;

    pSpool->pIniJob->hWriteFile = hWriteFile;

    //
    // !! NOTE !!
    //
    // Removed WriteShadowJob call here.
    //
    // We shouldn't need it because if the job is spooling and we
    // restart the spooler, we won't accept the shadow file because it's
    // not yet completely spooled.  Once it has spooled, the EndDocPrinter
    // will call WriteShadowJob, so we should be fine.
    //
    AddJobEntry(pSpool->pIniPrinter, pSpool->pIniJob);

    //
    // This bit can be set in the print to file case.  Clear it for
    // a following spool job.  Bit should really be in the job.
    //
    pSpool->TypeofHandle &= ~PRINTER_HANDLE_DIRECT;

    SetPrinterChange(pSpool->pIniPrinter,
                     pSpool->pIniJob,
                     NVAddJob,
                     PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                     pSpool->pIniSpooler);

    //
    //  RapidPrint might start despooling right away
    //

    CHECK_SCHEDULER();

    LeaveSplSem();
    SplOutSem();

   return TRUE;
}

BOOL
PrintingDirect(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    HRESULT     hRes;
    BOOL        bRemote;
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    PINIPORT    pIniPort = NULL;
    BOOL        bGoingToFile = FALSE;
    DWORD       dwId = 0;    // WMI Var

    DBGMSG(DBG_TRACE, ("Printing document %ws direct\n",
                       pDocInfo1->pDocName ? pDocInfo1->pDocName : L"(Null)"));

    if (pDocInfo1 &&
        pDocInfo1->pDatatype &&
        !ValidRawDatatype(pDocInfo1->pDatatype)) {

        DBGMSG(DBG_WARNING, ("Datatype is not RAW\n"));

        SetLastError(ERROR_INVALID_DATATYPE);
        return FALSE;
    }

   EnterSplSem();

   if (pDocInfo1 && pDocInfo1->pOutputFile
         && IsGoingToFile(pDocInfo1->pOutputFile, pSpool->pIniSpooler)) {
             bGoingToFile = TRUE;
   }

   if (bGoingToFile) {

       //
       // If we already have a thread/process printing to this filename
       // fail. Do not allow multiple processes/threads to write to the
       // same output file.
       //

       if (FindFilePort(pDocInfo1->pOutputFile, pSpool->pIniSpooler)) {
           LeaveSplSem();
           SetLastError(ERROR_SHARING_VIOLATION);
           return(FALSE);
       }
   }

   //
   // WMI Trace Events
   //
   dwId = GetNextId( pSpool->pIniPrinter->pIniSpooler->hJobIdMap );

   LeaveSplSem();
   LogWmiTraceEvent(dwId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);

   hRes = CheckLocalCall();

   if (hRes == S_OK)
   {
       bRemote = FALSE;
   }
   else if (hRes == S_FALSE)
   {
       bRemote = TRUE;
   }
   else
   {
       SetLastError(SCODE_CODE(hRes));
       return FALSE;
   }

   EnterSplSem();

    pSpool->pIniJob = CreateJobEntry(
                          pSpool,
                          Level,
                          pDocInfo,
                          dwId,
                          bRemote,
                          JOB_DIRECT,
                          NULL);

    if (!pSpool->pIniJob) {

        LeaveSplSem();
        return FALSE;
    }

    pSpool->pIniJob->StartDocComplete = CreateEvent( NULL,
                                                     EVENT_RESET_AUTOMATIC,
                                                     EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                     NULL );

    pSpool->pIniJob->WaitForWrite = CreateEvent( NULL,
                                                 EVENT_RESET_AUTOMATIC,
                                                 EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                 NULL );

    pSpool->pIniJob->WaitForRead  = CreateEvent( NULL,
                                                 EVENT_RESET_AUTOMATIC,
                                                 EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                 NULL );


    AddJobEntry(pSpool->pIniPrinter, pSpool->pIniJob);

    pSpool->TypeofHandle |= PRINTER_HANDLE_DIRECT;

    if (bGoingToFile) {
        PINIMONITOR pIniMonitor;

        InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_PRINT_TO_FILE);
        pIniMonitor = FindFilePortMonitor( pSpool->pIniSpooler );
        pIniPort = CreatePortEntry( pSpool->pIniJob->pOutputFile,
                                        pIniMonitor, pSpool->pIniSpooler);
        if (!pIniPort) {
            DECJOBREF(pSpool->pIniJob);
            DeleteJob(pSpool->pIniJob, NO_BROADCAST);
            LeaveSplSem();
            return FALSE;
        }

        pIniPort->Status |= PP_FILE;
        AddIniPrinterToIniPort(pIniPort, pSpool->pIniPrinter);
    }

    CHECK_SCHEDULER();

    if (pSpool->pIniJob->pIniPort) {
        SplInSem();
        InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_PRINTING);
    }

    SetPrinterChange(pSpool->pIniPrinter,
                     pSpool->pIniJob,
                     NVAddJob,
                     PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                     pSpool->pIniSpooler);

   LeaveSplSem();
   SplOutSem();

    //
    // Wait until the port thread calls StartDocPrinter through
    // the print processor:
    //
    DBGMSG(DBG_PORT, ("PrintingDirect: Calling WaitForSingleObject( %x )\n",
                      pSpool->pIniJob->StartDocComplete));

    WaitForSingleObject( pSpool->pIniJob->StartDocComplete, INFINITE );

    EnterSplSem();

    //
    // Close the event and set its value to NULL.
    // If anything goes wrong, or if the job gets cancelled,
    // the port thread will check this event, and if it's non-NULL,
    // it will set it to allow this thread to wake up.
    //
    DBGMSG(DBG_PORT, ("PrintingDirect: Calling CloseHandle( %x )\n",
                      pSpool->pIniJob->StartDocComplete));

    CloseHandle(pSpool->pIniJob->StartDocComplete);
    pSpool->pIniJob->StartDocComplete = NULL;

    //
    // If an error occurred, set the error on this thread:
    //
    if (pSpool->pIniJob->StartDocError) {

        SetLastError(pSpool->pIniJob->StartDocError);

        // We have to decrement by 2 because we've just created this job
        // in CreateJobEntry setting it to 1 and the other thread who
        // actually failed the StartDoc above (PortThread) did
        // not know to blow away the job. He just failed the StartDocPort.

        // No, we don't have to decrement by 2 because the PortThread
        // decrement does go through, am restoring to decrement by 1

        SPLASSERT(pSpool->pIniJob->cRef != 0);
        DECJOBREF(pSpool->pIniJob);
        DeleteJobCheck(pSpool->pIniJob);

        DBGMSG(DBG_TRACE, ("PrintingDirect:cRef %d\n", pSpool->pIniJob->cRef));

        LeaveSplSem();

        return FALSE;
    }

    LeaveSplSem();

    return TRUE;
}

VOID
ClearJobError(
    PINIJOB pIniJob
    )
/*++

Routine Description:

    Clears the error status bits of a job.

    This routine should be called when port monitor successfully
    sends bytes to the printer.

Arguments:

    pIniJob - Job in error state that should be cleared.

Return Value:

--*/

{
    SplInSem();

    InterlockedAnd((LONG*)&(pIniJob->Status), ~(JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR));

    SetPrinterChange( pIniJob->pIniPrinter,
                      pIniJob,
                      NVJobStatus,
                      PRINTER_CHANGE_SET_JOB,
                      pIniJob->pIniPrinter->pIniSpooler );
}

BOOL
LocalCloseSpoolFileHandle(
    HANDLE  hPrinter)

/*++
Function Description: Sets the end of file pointer for the spool file. In memory mapped writes
                      the spool size grows in 64K chunks and it needs to be truncated after the
                      writes are completed.

Parameters: hPrinter   -- printer handle

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL    bReturn = TRUE;
    DWORD   LastError = ERROR_SUCCESS;
    PSPOOL  pSpool = (PSPOOL) hPrinter;

    EnterSplSem();

    //
    // Check handle validity
    //
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
               (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

         LastError = ERROR_SPL_NO_STARTDOC;

    } else if (!pSpool->pIniJob ||
               (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
               (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                        PRINTER_HANDLE_DIRECT)) ||
               !(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) &&
               (pSpool->pIniJob->Status & (JOB_PENDING_DELETION))) {

         LastError = ERROR_PRINT_CANCELLED;
    }

    if (LastError) {
        SetLastError(LastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    if (!(pSpool->pIniJob->Status & JOB_DESPOOLING)) {

        //
        // Needed so that SetFilePointer treats the second arg as unsigned value 
        //
        LONG FileSizeHigh = 0;
        
        //
        // Move the file pointer to the number of bytes committed and set the end of file.
        //
        if (SetFilePointer(pSpool->pIniJob->hWriteFile, pSpool->pIniJob->dwValidSize, &FileSizeHigh, FILE_BEGIN) != 0xffffffff) {
            SetEndOfFile(pSpool->pIniJob->hWriteFile);
        }
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

BOOL
LocalCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   cbCommit)

/*++
Function Description: This function updates the Valid data size in the spool file.
                      The application writes directly into the spool file and commits the
                      data written using CommitSpoolData.

Parameters:   hPrinter    -- printer handle
              cbCommit    -- number of bytes to be committed

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL     bReturn = TRUE;
    DWORD    LastError = ERROR_SUCCESS, dwPosition;

    PSPOOL   pSpool = (PSPOOL) hPrinter;
    PINIJOB  pIniJob = NULL, pChainedJob;

    if (!cbCommit) {
        return bReturn;
    }

    EnterSplSem();

    //
    // Check handle validity
    //
    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
               (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

         LastError = ERROR_SPL_NO_STARTDOC;

    } else if (!pSpool->pIniJob ||
               (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
               (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT|
                                        PRINTER_HANDLE_DIRECT)) ||
               !(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

         LastError = ERROR_INVALID_HANDLE;

    } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) ||
               (pSpool->pIniJob->Status & (JOB_PENDING_DELETION))) {

         LastError = ERROR_PRINT_CANCELLED;
    }

    pIniJob = pSpool->pIniJob;

    if (pIniJob->dwValidSize > pIniJob->dwValidSize + cbCommit && !ValidRawDatatype(pIniJob->pDatatype)) {
        LastError = ERROR_ARITHMETIC_OVERFLOW;
    }

    if (LastError) {
        SetLastError(LastError);
        bReturn = FALSE;
        goto CleanUp;
    }

    pIniJob->dwValidSize += cbCommit;
    pIniJob->Size += cbCommit;
    SetFilePointer(pIniJob->hWriteFile, cbCommit, NULL, FILE_CURRENT);

    // Chained job size include all the jobs in the chain
    // But since the next jobs size field will have the size
    // of all subsequent jobs we do not need to walk thru the
    // whole chain
    if (pIniJob->NextJobId) {

        if (pChainedJob = FindJob(pSpool->pIniPrinter,
                                  pIniJob->NextJobId,
                                  &dwPosition)) {

            pIniJob->Size += pChainedJob->Size;

        } else {

            SPLASSERT(pChainedJob != NULL);
        }
    }

    // SetEvent on WaitForSeek if sufficient number bytes have been written out.
    SeekPrinterSetEvent(pSpool->pIniJob, NULL, FALSE);

    //  For Printing whilst Despooling, make sure we have enough bytes before
    //  scheduling this job
    if (((pIniJob->dwValidSize - cbCommit) < dwFastPrintSlowDownThreshold) &&
        (pIniJob->dwValidSize >= dwFastPrintSlowDownThreshold) &&
        (pIniJob->WaitForWrite == NULL)) {

        CHECK_SCHEDULER();
    }

    // Support for despooling whilst spooling

    if ( pIniJob->WaitForWrite != NULL )
        SetEvent( pIniJob->WaitForWrite );

    SetPrinterChange(pSpool->pIniPrinter,
                     pIniJob,
                     NVSpoolJob,
                     PRINTER_CHANGE_WRITE_JOB,
                     pSpool->pIniSpooler);

    // If there was no error, and the job was marked in an error
    // state, clear it.
    if (pIniJob->Status & (JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR)) {
        ClearJobError(pIniJob);
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

BOOL
LocalGetSpoolFileHandle(
    HANDLE    hPrinter,
    LPWSTR    *pSpoolDir,
    LPHANDLE  phFile,
    HANDLE    hSpoolerProcess,
    HANDLE    hAppProcess)

/*++
Function Description: This function duplicates the spoolfile handle for local jobs into the
                      applications process space. For remote jobs it returns the spool directory.
                      The router will create a temp file and return its handle to the
                      application.

Parameters: hPrinter         --  printer handle
            pSpoolDir        --  pointer to recieve the spool directory
            phFile           --  pointer to get the duplicate handle
            hSpoolerProcess  --  spooler process handle
            hAppProcess      --  application process handle

Return Values: TRUE if the LOCAL job and handle can be duplicated
                       OR  REMOTE job and spool directory is available
               FALSE otherwise
--*/

{
    BOOL           bReturn = TRUE, bDuplicate;
    PSPOOL         pSpool;
    DWORD          LastError = 0;
    PMAPPED_JOB    pMappedJob = NULL, pTempMappedJob;
    LPWSTR         pszSpoolFile = NULL;

    if (pSpoolDir) {
        *pSpoolDir = NULL;
    }
    if (phFile) {
        *phFile = INVALID_HANDLE_VALUE;
    }

    if ((hPrinter && !phFile) || (!hPrinter && !pSpoolDir)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    EnterSplSem();

    // For a local hPrinter return the SpoolFile handle
    if (hPrinter) {

        pSpool = (PSPOOL) hPrinter;

        // Check handle validity
        if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER)) {

             LastError = ERROR_INVALID_HANDLE;

        } else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC) ||
                   (pSpool->Status & SPOOL_STATUS_ADDJOB)) {

             LastError = ERROR_SPL_NO_STARTDOC;

        } else if (!pSpool->pIniJob ||
                   (pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
                   (pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                            PRINTER_HANDLE_DIRECT))) {

             LastError = ERROR_INVALID_HANDLE;

        } else if ((pSpool->Status & SPOOL_STATUS_CANCELLED) &&
                   (pSpool->pIniJob->Status & JOB_PENDING_DELETION)) {

             LastError = ERROR_PRINT_CANCELLED;
        }

        if (LastError) {

            SetLastError(LastError);
            bReturn = FALSE;

        } else {
            //
            // Duplicate hWriteFile into the App process
            //
            bReturn = ((pMappedJob = AllocSplMem(sizeof( MAPPED_JOB ))) != NULL) &&

                      ((pszSpoolFile = AllocSplMem(MAX_PATH * sizeof(WCHAR))) != NULL) &&

                      DuplicateHandle(hSpoolerProcess,
                                      pSpool->pIniJob->hWriteFile,
                                      hAppProcess,
                                      phFile,
                                      0,
                                      TRUE,
                                      DUPLICATE_SAME_ACCESS);

            if (bReturn) {
                //
                // Store the jobid and the spool file name in pSpool, so that in the event
                // that EndDoc is not called by the application/GDI, the spooler can delete the
                // spool file and free the job id from the id map on ClosePrinter.
                //
                InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_TYPE_OPTIMIZE);

                if (pSpool->pIniJob->hFileItem != INVALID_HANDLE_VALUE)
                {
                    bReturn = BoolFromHResult(StringCchCopy(pszSpoolFile, MAX_PATH, pSpool->pIniJob->pszSplFileName));


                    //
                    // If a spool file handle has been duplicated, then
                    // recycling it posses a security risk. So, set the
                    // file item to not recycle. This doesn't affect the
                    // server side because it used SplReadPrinter instead.
                    //
                    if (bReturn)
                    {
                        bReturn = BoolFromHResult(SetFileItemState(pSpool->pIniJob->hFileItem, kDontRecycle));
                    }
                }
                else
                {
                    GetFullNameFromId(pSpool->pIniJob->pIniPrinter, pSpool->pIniJob->JobId, TRUE, pszSpoolFile, MAX_PATH, FALSE);
                }
            }

            if (bReturn) {
                //
                // Avoid duplicate entries in the pSpool->pMappedJob list
                //
                bDuplicate = FALSE;

                for (pTempMappedJob = pSpool->pMappedJob;
                     pTempMappedJob;
                     pTempMappedJob = pTempMappedJob->pNext) {

                    if (pTempMappedJob->JobId == pSpool->pIniJob->JobId) {

                        pTempMappedJob->fStatus |= kMappedJobSpoolFileObtained;
                        bDuplicate = TRUE;
                        break;
                    }
                }

                if (!bDuplicate) {

                    pMappedJob->pszSpoolFile = pszSpoolFile;
                    pMappedJob->JobId = pSpool->pIniJob->JobId;
                    pMappedJob->fStatus = kMappedJobSpoolFileObtained;
                    pMappedJob->pNext = pSpool->pMappedJob;
                    pSpool->pMappedJob = pMappedJob;

                } else {

                    FreeSplMem(pszSpoolFile);
                    FreeSplMem(pMappedJob);
                }
            }
        }

    } else {

        //
        // Use the default spool dir or spool\Printers
        //
        if (pLocalIniSpooler->pDefaultSpoolDir) {

            *pSpoolDir = AllocSplStr(pLocalIniSpooler->pDefaultSpoolDir);

            bReturn = *pSpoolDir != NULL;

        } else if (pLocalIniSpooler->pDir) {

            bReturn = BoolFromStatus(StrCatAlloc(pSpoolDir, pLocalIniSpooler->pDir, L"\\", szPrinterDir, NULL));
        }
    }

    LeaveSplSem();

    if (!bReturn) {
        if (pMappedJob) {
            FreeSplMem(pMappedJob);
        }
        if (pszSpoolFile) {
            FreeSplMem(pszSpoolFile);
        }
    }

    return bReturn;
}

BOOL
LocalFlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

                      The driver can call FlushPrinter several times to have a cumulative
                      effect. The printer could be sleeping for a long time, but that is acceptable
                      since the driver is authenticated to keep doing WritePrinters indefinitely.
                      Thus FlushPrinter does not introduce any security loophole.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    BOOL         bReturn = FALSE;
    DWORD        CurrentTime;
    PSPOOL       pSpool = (PSPOOL)hPrinter;
    PINIPORT     pIniPort;
    PINIMONITOR  pIniMonitor;

    EnterSplSem();

    //
    // Validate parameters
    //
    if (!pcWritten ||
        (cbBuf && !pBuf))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto CleanUp;
    }

    //
    // FlushPrinter can be called only for port handles where a prior call to WritePrinter
    // failed
    //
    if (!ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER ) ||
        !(pSpool->TypeofHandle & PRINTER_HANDLE_PORT)         ||
        !(pSpool->Status & SPOOL_STATUS_FLUSH_PRINTER))
    {
        SetLastError( ERROR_INVALID_HANDLE );
        goto CleanUp;
    }

    //
    // Send the contents of the buffer to the port with a monitor. It doesn't make sense for
    // file ports or masq printers.
    //
    pIniPort = pSpool->pIniPort;

    if ( pIniPort && pIniPort->Status & PP_ERROR)
    {
        //
        // Don't send more data to a printer who's writing to a port in error
        // state. LocalFlushPrinter is called in order to reset the printer
        // By doing this, when printer buffer gets full, the writing will
        // hung and job cannot be restarted/deleted anymore
        //
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    if (pIniPort && (pIniPort->Status & PP_MONITOR))
    {
        HANDLE hMonitor = GetMonitorHandle(pIniPort);
        pIniMonitor = GetOpenedMonitor(pIniPort);

        if (pIniMonitor && hMonitor)
        {   
            *pcWritten = 0;

            //
            // LeaveSplSem before calling into the monitor
            //
            LeaveSplSem();
            SplOutSem();

            bReturn = (*pIniMonitor->Monitor2.pfnWritePort)( hMonitor,
                                                             pBuf,
                                                             cbBuf,
                                                             pcWritten );

            EnterSplSem();
        }
        else
        {
            SetLastError(ERROR_INVALID_HANDLE);
            bReturn = FALSE;
        }
    }

    //
    // Update the IniPort to introduce cSleep ms delay before scheduling
    //
    if (pIniPort)
    {
        CurrentTime = GetTickCount();

        if (pIniPort->bIdleTimeValid && (int)(pIniPort->IdleTime - CurrentTime) > 0)
        {
            pIniPort->IdleTime += cSleep;
        }
        else
        {
            pIniPort->IdleTime = CurrentTime + cSleep;
            pIniPort->bIdleTimeValid = TRUE;
        }
    }

CleanUp:

    LeaveSplSem();

    return bReturn;
}

VOID
QuitThread(
    LPHANDLE phThread,
    DWORD    dwThreadId,
    BOOL     bInsideSplSem
)
{   //
    // This function is called on LocalWritePrinter to destroy thread created on PromptErrorMessage
    //
    if( phThread && *phThread ) {

        if( WAIT_TIMEOUT == WaitForSingleObject( *phThread, 0 )) {

            if(bInsideSplSem){

                SplInSem();
                LeaveSplSem();
            }

            //
            // See if the thread is still running or dismissed by user.
            // If it is still running, wait for it to terminate before pIniJob can be freed.
            //
            MyPostThreadMessage( *phThread, dwThreadId, WM_QUIT, IDRETRY, 0 );

            WaitForSingleObject( *phThread, INFINITE );

            if(bInsideSplSem){

                SplOutSem();
                EnterSplSem();
            }
        }

        CloseHandle( *phThread );
        *phThread = NULL;
    }
}

BOOL
LocalWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;
    PINIPORT    pIniPort;
    DWORD   cWritten, cTotal;
    DWORD   rc;
    LPBYTE  pByte=pBuf;
    DWORD   LastError=0;
    PINIJOB pIniJob, pChainedJob;
    PINIMONITOR pIniMonitor;
    HANDLE  hThread = NULL;
    DWORD   dwThreadId=0, dwPosition;
    DWORD   dwWaitingResult;
    DWORD   Size = 0;
    
    *pcWritten = 0;

    SplOutSem();

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ))

        LastError = ERROR_INVALID_HANDLE;

    else if (!(pSpool->Status & SPOOL_STATUS_STARTDOC))

        LastError = ERROR_SPL_NO_STARTDOC;

    else if (pSpool->Status & SPOOL_STATUS_ADDJOB)

        LastError = ERROR_SPL_NO_STARTDOC;

    else if (pSpool->pIniJob &&
             !(pSpool->TypeofHandle & (PRINTER_HANDLE_PORT |
                                       PRINTER_HANDLE_DIRECT))  &&
             ((pSpool->pIniJob->hWriteFile == INVALID_HANDLE_VALUE) ||
              (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE))) {

        LastError = ERROR_INVALID_HANDLE;

        DBGMSG( DBG_TRACE, ("LocalWritePrinter: hWriteFile == INVALID_HANDLE_VALUE hPrinter %x\n",hPrinter ));
    }

    else if (pSpool->Status & SPOOL_STATUS_CANCELLED)

        LastError = ERROR_PRINT_CANCELLED;

    else if (pSpool->pIniJob && (pSpool->pIniJob->Status & JOB_PENDING_DELETION) )

        LastError = ERROR_PRINT_CANCELLED;

    pIniPort = pSpool->pIniPort;

    if (LastError) {

        DBGMSG(DBG_TRACE, ("WritePrinter LastError: %x hPrinter %x\n", LastError, hPrinter));

        //
        // Mark port handles to allow FlushPrinter to be called when WritePrinter fails.
        //
        if (LastError == ERROR_PRINT_CANCELLED &&
            pSpool->TypeofHandle & PRINTER_HANDLE_PORT)
        {
            pSpool->Status |= SPOOL_STATUS_FLUSH_PRINTER;
        }

        LeaveSplSem();
        SplOutSem();

        SetLastError(LastError);
        return FALSE;
    }

    LeaveSplSem();
    SplOutSem();

    //
    // WMI Trace Events
    //
    // The port thread is already being tracked.
    if (!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT))
    {
        if( pSpool->pIniJob )
        {
            LogWmiTraceEvent(pSpool->pIniJob->JobId,
                             EVENT_TRACE_TYPE_SPL_TRACKTHREAD,
                             NULL);
        }
        else if ( pSpool->pIniPort && pSpool->pIniPort->pIniJob )
        {
            LogWmiTraceEvent(pSpool->pIniPort->pIniJob->JobId,
                             EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);
        }
    }

    cWritten = cTotal = 0;

    while (cbBuf) {

       SplOutSem();

        if ( pSpool->TypeofHandle & PRINTER_HANDLE_PORT ) {

            //
            // For a print pool, check if the port is in error state  and if the event that syncronizes
            // restarting is not null.
            // A more natural testing if this synchronisation must be done is by testing against
            // dwRestartJobOnPoolEnabled but this is bogus when dwRestartJobOnPoolEnabled is TRUE
            // and SNMP is disabled ( LocalSetPort is not called and the event is not created )
            //
            EnterSplSem();

            if ( (pSpool->pIniPrinter->cPorts > 1) &&
                 (pSpool->pIniPort->Status & PP_ERROR) &&
                 (pIniPort->hErrorEvent != NULL) ) {

                //
                // This event will be set on LocalSetPort when port gets into a non eror state
                // or when timeout and job is restarted (on another port).
                // Printing is cancelled if the event is not set in DelayErrorTime.
                //
                LeaveSplSem();
                SplOutSem();
                dwWaitingResult = WaitForSingleObject( pIniPort->hErrorEvent, pSpool->pIniSpooler->dwRestartJobOnPoolTimeout * 1000 );

                EnterSplSem();

                if( pSpool->pIniJob ){
                    pIniJob = pSpool->pIniJob;
                } else if( pSpool->pIniPort && pSpool->pIniPort->pIniJob ){
                    pIniJob = pSpool->pIniPort->pIniJob;
                } else {
                    pIniJob = NULL;
                }

                //
                // Check if the job was be deleted or restarted
                //
                if( pIniJob && pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)){

                    // We had started a message box. See if the thread is still running or dismissed by user.
                    // If it is still running, wait for it to terminate before pIniJob can be freed.
                    // We need to leave the semaphore, since the UI thread we
                    // are waiting on could need to acquire it.
                    QuitThread( &hThread, dwThreadId, TRUE );

                    SetLastError( ERROR_PRINT_CANCELLED );
                    rc = FALSE;

                    goto Fail;

                }

                //
                // If the error problem wasn't solved , set the job on error and continue
                //
                if( dwWaitingResult == WAIT_TIMEOUT ){

                    InterlockedOr((LONG*)&(pIniJob->Status), JOB_ERROR);
                    SetPrinterChange( pIniJob->pIniPrinter,
                                      pIniJob,
                                      NVJobStatus,
                                      PRINTER_CHANGE_SET_JOB,
                                      pIniJob->pIniPrinter->pIniSpooler );
                }


            }

            LeaveSplSem();
            SplOutSem();


            if ( pSpool->pIniPort->Status & PP_MONITOR ) 
            {
                HANDLE hMonitor = GetMonitorHandle(pIniPort);
                pIniMonitor = GetOpenedMonitor(pIniPort);

                if (pIniMonitor && hMonitor)
                {
                    SplOutSem();
                    cWritten = 0;
                    rc = (*pIniMonitor->Monitor2.pfnWritePort)(
                             hMonitor,
                             pByte,
                             cbBuf,
                             &cWritten );

                    //
                    // Only update if cWritten != 0.  If it is zero
                    // (for instance, when hpmon is stuck at Status
                    // not available), then we go into a tight loop
                    // sending out notifications.
                    //
                    if (cWritten) {

                        //
                        // For stress Test information gather the total
                        // number of types written.
                        //
                        EnterSplSem();

                        pSpool->pIniPrinter->cTotalBytes.QuadPart =
                            pSpool->pIniPrinter->cTotalBytes.QuadPart +
                            cWritten;

                        LeaveSplSem();
                        SplOutSem();

                    } else {

                        if (rc && dwWritePrinterSleepTime) {

                            //
                            // Sleep to avoid consuming too much CPU.
                            // Hpmon has this problem where they return
                            // success, but don't write any bytes.
                            //
                            // Be very careful: this may get called several
                            // times by a monitor that writes a lot of zero
                            // bytes (perhaps at the beginning of jobs).
                            //
                            Sleep(dwWritePrinterSleepTime);
                        }
                    }
                }
                else
                {
                    rc = FALSE;
                    SetLastError(ERROR_INVALID_HANDLE);
                    EnterSplSem();
                    goto Fail;
                }
            }
            else {

                DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor\n"));

                if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {

                    DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor - writing to file\n"));
                    rc = WriteFile(pSpool->hFile, pByte, cbBuf, &cWritten, NULL);
                } else {

                    DBGMSG(DBG_TRACE, ("LocalWritePrinter: Port has no monitor - calling into router\n"));
                    rc = WritePrinter(pSpool->hPort, pByte, cbBuf, &cWritten);
                }

            }

        } else if ( pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT ) {

            cWritten = WriteToPrinter(pSpool, pByte, cbBuf);

            if (cWritten) {

                if (pSpool->pIniJob->Size > pSpool->pIniJob->Size + cWritten && !ValidRawDatatype(pSpool->pIniJob->pDatatype)) {
                    SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                    rc = FALSE;
                    EnterSplSem();
                    goto Fail;
                }


                pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                pSpool->pIniJob->Size+=cWritten;

                EnterSplSem();
                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVSpoolJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
                LeaveSplSem();
            }
            SplOutSem();

            rc = (BOOL)cWritten;

        } else {

            SplOutSem();

            rc = WriteFile(pSpool->pIniJob->hWriteFile, pByte, cbBuf, &cWritten, NULL);
            if (cWritten) {

                DWORD FileSizeHigh = 0;
                
                Size = GetFileSize( pSpool->pIniJob->hWriteFile, &FileSizeHigh);

                EnterSplSem();

                if (FileSizeHigh && !ValidRawDatatype(pSpool->pIniJob->pDatatype)){
                    SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                    rc = FALSE;
                    goto Fail;
                }


                pSpool->pIniJob->Size = Size;

                //
                // Chained job size include all the jobs in the chain
                // But since the next jobs size field will have the size
                // of all subsequent jobs we do not need to walk thru the
                // whole chain
                //
                if ( pSpool->pIniJob->NextJobId ) {

                    if ( pChainedJob = FindJob(pSpool->pIniPrinter,
                                               pSpool->pIniJob->NextJobId,
                                               &dwPosition) )
                    {
                        if (pSpool->pIniJob->Size > pSpool->pIniJob->Size + pChainedJob->Size && !ValidRawDatatype(pSpool->pIniJob->pDatatype)) 
                        {
                            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                            rc = FALSE;
                            goto Fail;
                        }
                        
                        pSpool->pIniJob->Size += pChainedJob->Size;
                    }
                    else
                    {
                        SPLASSERT(pChainedJob != NULL);
                    }
                }

                pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;

                // SetEvent on WaitForSeek if sufficient number bytes have been written out.
                LeaveSplSem();

                SeekPrinterSetEvent(pSpool->pIniJob, NULL, FALSE);

                EnterSplSem();

                //
                //  For Printing whilst Despooling, make sure we have enough bytes before
                //  scheduling this job
                //
                if (( (pSpool->pIniJob->Size - cWritten) < dwFastPrintSlowDownThreshold ) &&
                    ( pSpool->pIniJob->Size >= dwFastPrintSlowDownThreshold ) &&
                    ( pSpool->pIniJob->WaitForWrite == NULL )) {

                    CHECK_SCHEDULER();

                }

                //
                // Support for despooling whilst spooling
                //
                if ( pSpool->pIniJob->WaitForWrite != NULL )
                    SetEvent( pSpool->pIniJob->WaitForWrite );

                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVSpoolJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
               LeaveSplSem();
               SplOutSem();

            }
        }

        SplOutSem();

        (*pcWritten)+=cWritten;
        cbBuf-=cWritten;
        pByte+=cWritten;

        EnterSplSem();

        if( pSpool->pIniJob ){
            pIniJob = pSpool->pIniJob;
        } else if( pSpool->pIniPort && pSpool->pIniPort->pIniJob ){
            pIniJob = pSpool->pIniPort->pIniJob;
        } else {
            pIniJob = NULL;
        }

        if( pIniJob ){

            if( pIniJob && pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART) ){

                    // We had started a message box. See if the thread is still running or dismissed by user.
                    // If it is still running, wait for it to terminate before pIniJob can be freed.
                    // We need to leave the semaphore, since the UI thread we
                    // are waiting on could need to acquire it.
                    QuitThread( &hThread, dwThreadId, TRUE );

                    SetLastError( ERROR_PRINT_CANCELLED );
                    rc = FALSE;

                    goto Fail;

                }

            //
            // If there was no error, and the job was marked in an error
            // state, clear it.
            //
            if( rc &&
                ( pIniJob->Status & (JOB_PAPEROUT | JOB_OFFLINE | JOB_ERROR ))){
                ClearJobError( pIniJob );
            }
        }

        LeaveSplSem();

        //
        // If we failed and we have more bytes to write, then put
        // up the warning.  Some monitors may return FALSE, but actually
        // write data to the port.  Therefore we need to check both rc
        // and also cbBuf.
        //
        if (!rc && cbBuf)
        {
            //
            // Warning: We are sending in a stack variable. We need to be sure
            // the error UI thread is cleaned up before LocalWritePrinter()
            // returns!
            //
            if( PromptWriteError( pSpool, &hThread, &dwThreadId ) == IDCANCEL )
            {
                //
                // In this case I know thread will die by itself
                //
                CloseHandle(hThread);
                hThread = NULL;

                EnterSplSem();
                goto Fail;
            }
        }
        else
        {
            // We have started a message box and now the automatically
            // retry has succeeded, we need to kill the message box
            // and continue to print.
            QuitThread( &hThread, dwThreadId, FALSE );
        }
    }
    rc = TRUE;

    EnterSplSem();

Fail:

    SplInSem();

    //
    // Mark port handles to allow FlushPrinter to be called when WritePrinter fails.
    //
    if (!rc && (pSpool->TypeofHandle & PRINTER_HANDLE_PORT))
    {
        pSpool->Status |= SPOOL_STATUS_FLUSH_PRINTER;
    }

    LeaveSplSem();

    DBGMSG(DBG_TRACE, ("WritePrinter Written %d : %d\n", *pcWritten, rc));

    SplOutSem();

    SPLASSERT( hThread == NULL );

    return rc;
}

BOOL
WaitForSeekPrinter(
    PSPOOL pSpool,
    HANDLE hFile,
    LARGE_INTEGER liSeekFilePosition,
    DWORD  dwMoveMethod
)

/*++
Function Description: WaitForSeekPrinter waits till there is enough data written to the
                      spool file before the file pointer can be moved.

Parameters: pSpool - pointer to the SPOOL struct.
            hFile  - handle to the file whose pointer is to be set.
            liDistanceToMove - Offset to move the file pointer.
            dwMoveMethod - position to take offset. FILE_BEGIN | FILE_CURRENT | FILE_END

Return Values: TRUE for success
               FALSE otherwise
--*/

{

    BOOL  bWaitForWrite = FALSE, bReturn = FALSE;
    DWORD dwFileSizeHigh, dwFileSizeLow, dwWaitResult;

    LARGE_INTEGER liCurrentFilePosition;

    // For Print while spooling wait till sufficient number of bytes have been written.
    if ( pSpool->pIniJob->Status & JOB_SPOOLING ) {

       if ( dwMoveMethod == FILE_END ) {

          pSpool->pIniJob->bWaitForEnd = TRUE;
          bWaitForWrite = TRUE;

       } else {
          // Save the current file position.
          liCurrentFilePosition.QuadPart = 0;
          liCurrentFilePosition.u.LowPart = SetFilePointer( hFile,
                                                            liCurrentFilePosition.u.LowPart,
                                                            &liCurrentFilePosition.u.HighPart,
                                                            FILE_CURRENT );
          if ((liCurrentFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
             goto CleanUp;
          }

          // Get the current size of the file
          if (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) {
              dwFileSizeLow = pSpool->pIniJob->dwValidSize;
              dwFileSizeHigh = 0;
          } else {
              dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
              if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
                  goto CleanUp;
              }
          }

          // Set the new file pointer.
          liSeekFilePosition.u.LowPart = SetFilePointer( hFile,
                                                         liSeekFilePosition.u.LowPart,
                                                         &liSeekFilePosition.u.HighPart,
                                                         dwMoveMethod );
          if ((liSeekFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
              goto CleanUp;
          }

          // Reset the file pointer using the saved current file position.
          liCurrentFilePosition.u.LowPart = SetFilePointer( hFile,
                                                            liCurrentFilePosition.u.LowPart,
                                                            &liCurrentFilePosition.u.HighPart,
                                                            FILE_BEGIN );
          if ((liCurrentFilePosition.u.LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
             goto CleanUp;
          }

          // Check new position of the file pointer with the current file size.
          if ((liSeekFilePosition.u.HighPart > (LONG)dwFileSizeHigh) ||
              ( (liSeekFilePosition.u.HighPart == (LONG)dwFileSizeHigh) &&
                (liSeekFilePosition.u.LowPart > dwFileSizeLow))) {

              // Set the fields in INIJOB.
              pSpool->pIniJob->liFileSeekPosn.QuadPart  = liSeekFilePosition.QuadPart;
              bWaitForWrite = TRUE;
          }

       }

       if (bWaitForWrite) {
          // Create and wait on an event. Exit the Spooler semaphore.
          if (pSpool->pIniJob->WaitForSeek == NULL) {
              pSpool->pIniJob->WaitForSeek  = CreateEvent( NULL,
                                                           EVENT_RESET_AUTOMATIC,
                                                           EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                           NULL );
          }
          if (!pSpool->pIniJob->WaitForSeek ||
              !ResetEvent(pSpool->pIniJob->WaitForSeek)) {
              pSpool->pIniJob->WaitForSeek = NULL;
              goto CleanUp;
          }

          pSpool->pIniJob->bWaitForSeek =  TRUE;

          // Increment ref counts before leaving the semaphore
          pSpool->cRef++;
          INCJOBREF(pSpool->pIniJob);

          LeaveSplSem();

          dwWaitResult = WaitForSingleObject(pSpool->pIniJob->WaitForSeek,
                                             INFINITE);

          EnterSplSem();

          pSpool->cRef--;
          DECJOBREF(pSpool->pIniJob);
          // If wait failed or the handles are invalid fail the call
          if ((dwWaitResult == WAIT_FAILED)              ||
              (dwWaitResult == WAIT_TIMEOUT)             ||
              (pSpool->Status & SPOOL_STATUS_CANCELLED)  ||
              (pSpool->pIniJob->Status & (JOB_TIMEOUT | JOB_PENDING_DELETION |
                                          JOB_ABANDON | JOB_RESTART))) {

              goto CleanUp;
          }
       }
    }

    // Set the return value.
    bReturn = TRUE;

CleanUp:

    pSpool->pIniJob->bWaitForSeek =  FALSE;
    DeleteJobCheck(pSpool->pIniJob);

    return bReturn;
}


BOOL
LocalSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
    )

/*++

Routine Description: LocalSeekPrinter moves the file pointer in the spool file to the position
                     indicated by liDistanceToMove. This call is synchronous and it waits if
                     the job is being spooled and the required number of bytes have not been
                     written as yet.

Arguments: hPrinter - handle to the Printer.
           liDistanceToMove - offset to move the file pointer.
           pliNewPointer - pointer to a LARGE_INTEGER which will contain the new position
                           of the file pointer.
           dwMoveMethod - position to take offset. FILE_BEGIN | FILE_CURRENT | FILE_END

Return Value: TRUE if the file pointer can be moved to the required location
              FALSE otherwise.

--*/

{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile;
    BOOL   bReturn = FALSE;
    DWORD  dwFileSizeHigh, dwFileSizeLow;

    SplOutSem();
    EnterSplSem();

    // Check for handle validity
    if( !ValidateSpoolHandle( pSpool, PRINTER_HANDLE_SERVER )){
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_INVALID_HANDLE\n"));
        goto CleanUp;
    }

    if( pSpool->Status & SPOOL_STATUS_CANCELLED ){
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    if( !( pSpool->TypeofHandle & PRINTER_HANDLE_JOB ) ||
        ( pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT )){

        DBGMSG( DBG_WARNING, ("LocalSeekPrinter: not a job handle, or direct\n" ));
        SetLastError( ERROR_NOT_SUPPORTED );
        goto CleanUp;
    }

    // Avoid waiting for jobs that can't print.
    if( !pSpool->pIniJob ||
        pSpool->pIniJob->Status & (JOB_TIMEOUT | JOB_ABANDON |
                                   JOB_PENDING_DELETION | JOB_RESTART) ) {
        DBGMSG( DBG_WARNING, ("LocalSeekPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError( ERROR_PRINT_CANCELLED );
        goto CleanUp;
    }

    // Seek fails while writing to the spool file.
    if( bWritePrinter ) {
        goto CleanUp;
    } else {
        hFile = pSpool->hReadFile;
    }

    // Wait for data to be written, if necessary.
    if (!WaitForSeekPrinter( pSpool,
                             hFile,
                             liDistanceToMove,
                             dwMoveMethod )) {
       goto CleanUp;
    }

    // Set the file pointer.
    pliNewPointer->u.LowPart = SetFilePointer( hFile,
                                               liDistanceToMove.u.LowPart,
                                               &liDistanceToMove.u.HighPart,
                                               dwMoveMethod );

    if( pliNewPointer->u.LowPart == 0xffffffff && GetLastError() != NO_ERROR ){
        goto CleanUp;
    }

    pliNewPointer->u.HighPart = liDistanceToMove.u.HighPart;

    //
    // Fail the call if the pointer is moved beyond the end of file.
    // Get the current size of the file
    //
    if (pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE) {
        dwFileSizeLow = pSpool->pIniJob->dwValidSize;
        dwFileSizeHigh = 0;
    } else {
        dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
        if ((dwFileSizeLow == 0xffffffff) && (GetLastError() != NO_ERROR)) {
            goto CleanUp;
        }
    }

    //
    // Check new position of the file pointer with the current file size.
    //
    if ((pliNewPointer->u.HighPart > (LONG)dwFileSizeHigh) ||
        ( (pliNewPointer->u.HighPart == (LONG)dwFileSizeHigh) &&
          (pliNewPointer->u.LowPart > dwFileSizeLow))) {

         SetLastError(ERROR_NO_MORE_ITEMS);
         goto CleanUp;
    }

    bReturn = TRUE;

CleanUp:

    LeaveSplSem();

    return bReturn;
}


BOOL
LocalEndPagePrinter(
    HANDLE  hPrinter
)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;


    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        return(FALSE);
    }


    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if (pSpool->pIniJob != NULL) {

        if ( (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
            ((pSpool->pIniJob->Status & JOB_PRINTING) ||
             (pSpool->pIniJob->Status & JOB_DESPOOLING))) {

            //
            // Despooling ( RapidPrint )
            //
            UpdateJobAttributes(pSpool->pIniJob);

            pSpool->pIniJob->cLogicalPagesPrinted++;
            if (pSpool->pIniJob->cLogicalPagesPrinted >=
                         pSpool->pIniJob->dwDrvNumberOfPagesPerSide)
            {
                pSpool->pIniJob->cLogicalPagesPrinted = 0;
                pSpool->pIniJob->cPagesPrinted++;
                pSpool->pIniPrinter->cTotalPagesPrinted++;
            }

        } else {

            //
            // Spooling
            //
            if ( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ) {

                //
                // If the Job is being written on the client side
                // the size is not getting updated so do it now on
                // the start page
                //
                if ( pSpool->hReadFile != INVALID_HANDLE_VALUE ) {

                    hFile = pSpool->hReadFile;

                } else {

                    hFile = pSpool->pIniJob->hWriteFile;

                }

                if ( hFile != INVALID_HANDLE_VALUE ) {

                    dwFileSize = GetFileSize(hFile, 0);

                    if (pSpool->pIniJob->Size < dwFileSize) {

                         DBGMSG( DBG_TRACE, ("EndPagePrinter adjusting size old %d new %d\n",
                            pSpool->pIniJob->Size, dwFileSize));

                         pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;
                         pSpool->pIniJob->Size = dwFileSize;

                         // Support for despooling whilst spooling
                         // for Down Level jobs

                         if (pSpool->pIniJob->WaitForWrite != NULL)
                            SetEvent( pSpool->pIniJob->WaitForWrite );
                    }

                }

                CHECK_SCHEDULER();

            }

        }

    } else {

        DBGMSG(DBG_TRACE, ("LocalEndPagePrinter issued with no Job\n"));

    }

    return TRUE;
}

BOOL
LocalAbortPrinter(
   HANDLE hPrinter
)
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
       DBGMSG( DBG_WARNING, ("ERROR in AbortPrinter: %x\n", ERROR_INVALID_HANDLE));
        return FALSE;
    }

    if (!(pSpool->Status & SPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        return(FALSE);
    }

    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR)) {

        if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {

            if (!CloseHandle(pSpool->hFile)) {
                return(FALSE);
            }
            pSpool->Status &= ~SPOOL_STATUS_PRINT_FILE;
            pSpool->Status  |= SPOOL_STATUS_CANCELLED;
            return(TRUE);

        } else {
            return AbortPrinter(pSpool->hPort);
        }
    }

    pSpool->Status |= SPOOL_STATUS_CANCELLED;

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        EnterSplSem();
        if (pSpool->pIniJob) {

            //
            // Reset JOB_RESTART flag, otherwise the job doesn't get deleted.
            // If AbortPrinter is called while the job is restarting, DeleteJob ignores the
            // job if JOB_RESTART is set and the Scheduler also ignores the job since it is
            // marked as JOB_PENDING_DELETION. The job would stay in Deleting-Restarting forever.
            //
            InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_PENDING_DELETION);
            InterlockedAnd((LONG*)&(pSpool->pIniJob->Status), ~JOB_RESTART);

            //
            // Release any thread waiting on LocalSetPort
            //
            SetPortErrorEvent(pSpool->pIniJob->pIniPort);
        }
        LeaveSplSem();
    }

    //
    // fixes bug 2646, we need to clean up AbortPrinter
    // rewrite so that it doesn't fail on cases which EndDocPrinter should fail
    // get rid of comment when done
    //

    LocalEndDocPrinter(hPrinter);

    return TRUE;
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
)
/*++
Function Description: SplReadPrinter is an internal ReadPrinter which uses a memory mapped
                      spool file and returns the pointer to the required data in *pBuf.

Parameters: hPrinter          -- printer handle
            *pBuf             -- pointer to the buffer (mapped view)
            cbBuf             -- number of bytes to be read

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    DWORD  NoBytesRead;
    BOOL   bReturn;

    //
    // Not used currently
    //
    bReturn = InternalReadPrinter(hPrinter, NULL, cbBuf, pBuf, &NoBytesRead, TRUE);

    if (!bReturn && (GetLastError() == ERROR_SUCCESS)) {
        //
        // Memory mapped ReadPrinter may fail without setting the last error
        //
        SetLastError(ERROR_NOT_SUPPORTED);
    }

    return bReturn;
}

BOOL
LocalReadPrinter(
    HANDLE   hPrinter,
    LPVOID   pBuf,
    DWORD    cbBuf,
    LPDWORD  pNoBytesRead
)
/*++
Routine Description: LocalReadPrinter reads the required number of bytes (or
                     available) into the specified buffer.

Arguments:  hPrinter      -- printer handle
            pBuf          -- pointer to the buffer to store data
            cbBuf         -- number of bytes to be read
            pNoBytesRead  -- pointer to variable to return number of bytes read

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    return InternalReadPrinter(hPrinter, pBuf, cbBuf, NULL, pNoBytesRead, FALSE);
}

BOOL
InternalReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPBYTE   *pMapBuffer,
   LPDWORD  pNoBytesRead,
   BOOL     bReadMappedView
)
/*++
Routine Description: InternalReadPrinter reads the required number of bytes(or available) into the
                     specified buffer or returns a pointer to the mapped file view.

Arguments:  hPrinter      -- printer handle
            pBuf          -- pointer to the buffer to store data
            cbBuf         -- number of bytes to be read
            *pMapBuffer   -- pointer to the mapped file view
            pNoBytesRead  -- pointer to variable to return number of bytes read
            bReadMappedView -- flag for using mapped spool file

Return Value: TRUE if successful;
              FALSE otherwise
--*/
{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       Error=0, rc;
    HANDLE      hWait;
    DWORD       dwFileSize = 0, dwCurrentPosition, dwOldValidSize;
    DWORD       ThisPortSecsToWait;
    DWORD       cbReadSize = cbBuf;
    DWORD       SizeInFile = 0;
    DWORD       BytesAllowedToRead = 0;
    NOTIFYVECTOR NotifyVector;
    PINIMONITOR  pIniMonitor;

    SplOutSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        DBGMSG( DBG_WARNING, ("LocalReadPrinter ERROR_INVALID_HANDLE\n"));
        return FALSE;
    }

    if (pSpool->Status & SPOOL_STATUS_CANCELLED) {
        DBGMSG( DBG_WARNING, ("LocalReadPrinter ERROR_PRINT_CANCELLED\n"));
        SetLastError(ERROR_PRINT_CANCELLED);
        return FALSE;
    }

    if ( pNoBytesRead != NULL ) {
        *pNoBytesRead = 0;
    }

    if (bReadMappedView) {
        //
        // Supported only for JOB handles that aren't DIRECT
        //
        if ( !(pSpool->TypeofHandle & PRINTER_HANDLE_JOB) ||
             pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT ) {

             SetLastError(ERROR_NOT_SUPPORTED);
             return FALSE;
        }
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_JOB) {

        if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) {
            DBGMSG( DBG_WARNING, ("LocalReadPrinter Error IniJob->Status %x\n",pSpool->pIniJob->Status));
            SetLastError(ERROR_PRINT_CANCELLED);
            return FALSE;
        }

        if (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT) {

            *pNoBytesRead = ReadFromPrinter(pSpool, pBuf, cbReadSize);

            SplOutSem();
            return TRUE;

        }

        //
        // Check that the user has read access.
        //
        if( !AccessGranted( SPOOLER_OBJECT_DOCUMENT,
                            JOB_READ,
                            pSpool )){

            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }


        SplOutSem();
        EnterSplSem();

        //
        // RapidPrint
        //
        // NOTE this while loop is ONLY in operation if during RapidPrint
        // ie when we are Printing the same job we are Spooling
        //

        while (( pSpool->pIniJob->WaitForWrite != NULL ) &&
               ( pSpool->pIniJob->Status & JOB_SPOOLING )) {

            //
            // Get the current file position.
            //
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            if (dwCurrentPosition < pSpool->pIniJob->dwValidSize) {
                //
                // Wait is not required
                //
                break;
            }

            SplInSem();

            //
            // We cannot rely on pIniJob->Size to be accurate since for
            // downlevel jobs or jobs that to AddJob they are writing
            // to a file without calling WritePrinter.
            // So we call the file system to get an accurate file size
            //
            dwFileSize = GetFileSize( pSpool->hReadFile, 0 );

            if ( pSpool->pIniJob->Size != dwFileSize ) {

                DBGMSG( DBG_TRACE, ("LocalReadPrinter adjusting size old %d new %d\n",
                    pSpool->pIniJob->Size, dwFileSize));

                dwOldValidSize = pSpool->pIniJob->dwValidSize;

                //
                // Fix for print while spooling.  If it was AddJobed, then
                // the valid size is going to be the previous size, since
                // we know the old data will be flushed by the time the new
                // one is extended.
                //
                if( pSpool->pIniJob->Status & JOB_TYPE_ADDJOB ){

                    //
                    // The previous size becomes the next valid size.
                    //
                    pSpool->pIniJob->dwValidSize = pSpool->pIniJob->Size;

                } else if (!(pSpool->pIniJob->Status & JOB_TYPE_OPTIMIZE)) {

                    //
                    // The valid size is not necessary for non-AddJob
                    // jobs, since the write has been committed.
                    //
                    pSpool->pIniJob->dwValidSize = dwFileSize;
                }

                pSpool->pIniJob->Size = dwFileSize;

                if (dwOldValidSize != pSpool->pIniJob->dwValidSize) {

                    SetPrinterChange(pSpool->pIniPrinter,
                                     pSpool->pIniJob,
                                     NVSpoolJob,
                                     PRINTER_CHANGE_WRITE_JOB,
                                     pSpool->pIniSpooler);

                }

                continue;
            }

            if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART | JOB_ABANDON )) {

                SetLastError(ERROR_PRINT_CANCELLED);

                LeaveSplSem();
                SplOutSem();

                DBGMSG( DBG_WARNING, ("LocalReadPrinter Error 2 IniJob->Status %x\n",pSpool->pIniJob->Status));
                return FALSE;

            }

            //
            // Wait until something is written to the file
            //
            hWait = pSpool->pIniJob->WaitForWrite;
            ResetEvent( hWait );

            DBGMSG( DBG_TRACE, ("LocalReadPrinter Waiting for Data %d milliseconds\n",dwFastPrintWaitTimeout));

            LeaveSplSem();
            SplOutSem();

            rc = WaitForSingleObjectEx(hWait, dwFastPrintWaitTimeout, FALSE);

            SplOutSem();
            EnterSplSem();

            DBGMSG( DBG_TRACE, ("LocalReadPrinter Returned from Waiting %x\n", rc));
            SPLASSERT ( pSpool->pIniJob != NULL );

            //
            // If we did NOT timeout then we may have some Data to read
            //
            if ( rc != WAIT_TIMEOUT )
                continue;

            //
            // If there are any other jobs that could be printed on
            // this port give up waiting.
            //
            InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_TIMEOUT);

            // Set the event for SeekPrinter to fail rendering threads
            SeekPrinterSetEvent(pSpool->pIniJob, NULL, TRUE);

            if ( NULL == AssignFreeJobToFreePort(pSpool->pIniJob->pIniPort, &ThisPortSecsToWait) )
                continue;

            //
            // There is another Job waiting
            // Freeze this job, the user can Restart it later
            //
            InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_ABANDON);

            CloseHandle( pSpool->pIniJob->WaitForWrite );
            pSpool->pIniJob->WaitForWrite = NULL;

            //
            // Assign it our Error String
            //
            ReallocSplStr(&pSpool->pIniJob->pStatus, szFastPrintTimeout);

            SetPrinterChange(pSpool->pIniJob->pIniPrinter,
                             pSpool->pIniJob,
                             NVJobStatusAndString,
                             PRINTER_CHANGE_SET_JOB,
                             pSpool->pIniJob->pIniPrinter->pIniSpooler );

            DBGMSG( DBG_WARNING,
                    ("LocalReadPrinter Timeout on pIniJob %x %ws %ws\n",
                      pSpool->pIniJob,
                      pSpool->pIniJob->pUser,
                      pSpool->pIniJob->pDocument));

            LogJobInfo( pSpool->pIniSpooler,
                        MSG_DOCUMENT_TIMEOUT,
                        pSpool->pIniJob->JobId,
                        pSpool->pIniJob->pDocument,
                        pSpool->pIniJob->pUser,
                        pSpool->pIniJob->pIniPrinter->pName,
                        dwFastPrintWaitTimeout );

            SetLastError(ERROR_SEM_TIMEOUT);

            LeaveSplSem();
            SplOutSem();

            return FALSE;

        }   // END WHILE

        InterlockedAnd((LONG*)&(pSpool->pIniJob->Status), ~( JOB_TIMEOUT | JOB_ABANDON ));

        //
        // RapidPrint
        //
        // Some printers (like HP 4si with PSCRIPT) timeout if they
        // don't get data, so if we fall below a threshold of data
        // in the spoolfile then throttle back the Reads to 1 Byte
        // per second until we have more data to ship to the printer
        //
        if (( pSpool->pIniJob->WaitForWrite != NULL ) &&
            ( pSpool->pIniJob->Status & JOB_SPOOLING )) {

            // Get the current file position.
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            SizeInFile = pSpool->pIniJob->Size - dwCurrentPosition;

            if ( dwFastPrintSlowDownThreshold >= SizeInFile ) {

                cbReadSize = 1;

                hWait = pSpool->pIniJob->WaitForWrite;
                ResetEvent( hWait );

                DBGMSG( DBG_TRACE, ("LocalReadPrinter Throttling IOs waiting %d milliseconds SizeInFile %d\n",
                                        dwFastPrintThrottleTimeout,SizeInFile));

                LeaveSplSem();
                SplOutSem();

                rc = WaitForSingleObjectEx( hWait, dwFastPrintThrottleTimeout, FALSE );

                SplOutSem();
                EnterSplSem();

                DBGMSG( DBG_TRACE, ("LocalReadPrinter Returned from Waiting %x\n", rc));
                SPLASSERT ( pSpool->pIniJob != NULL );

            } else {

                BytesAllowedToRead = SizeInFile - dwFastPrintSlowDownThreshold;

                if ( cbReadSize > BytesAllowedToRead ) {
                    cbReadSize = BytesAllowedToRead;
                }
            }
        }

        //
        // A client calls AddJob to get the spool filename and
        // ScheduleJob when the file is completed.  According to the
        // api spec, the spooler should not look at the job until
        // ScheduleJob has been called.
        //
        // However, our print while spooling implementation tries
        // to read the job before ScheduleJob is called.  We do this
        // by checking if the size of the file has changed.
        //
        // This causes a problem: the server service extends the
        // file then writes to it.  The spooler's size detection
        // thread sees this extension and reads the file before
        // the data is written, which puts garbage (zeros) into the
        // data stream.
        //
        // The server always extends, writes, extends, writes, etc.
        // The spooler can exploit the fact that they are in order
        // and read a write only when the file is extended again,
        // or the file is complete.
        //
        // Note that the API is still broken, but this fixes it
        // for the server service (a client could extend, extend,
        // write, write, which breaks this fix).
        //

        if( pSpool->pIniJob->Status & JOB_SPOOLING ){

            // Get the current file position.
            dwCurrentPosition = SetFilePointer( pSpool->hReadFile,
                                                0,
                                                NULL,
                                                FILE_CURRENT );

            SPLASSERT( dwCurrentPosition <= pSpool->pIniJob->dwValidSize );

            //
            // Even though the file system will satisfy a large request, limit
            // it to the extent of the previous (not current) write.
            //

            BytesAllowedToRead = pSpool->pIniJob->dwValidSize - dwCurrentPosition;


            if( cbReadSize > BytesAllowedToRead ){
                cbReadSize = BytesAllowedToRead;
            }
        }

        LeaveSplSem();
        SplOutSem();

        if (bReadMappedView) {
            //
            // Mapping partial views serves no purpose, since it can't be used incrementally.
            //
            if (cbBuf != cbReadSize) {
                rc = FALSE;
            } else {
                rc = SetMappingPointer(pSpool, pMapBuffer, cbReadSize);
            }

            if (rc) {
               *pNoBytesRead = cbReadSize;
            }

        } else {

            rc = ReadFile( pSpool->hReadFile, pBuf, cbReadSize, pNoBytesRead, NULL);
        }

        if (!bReadMappedView) {

            DBGMSG( DBG_TRACE,
                    ("LocalReadPrinter rc %x hReadFile %x pBuf %x cbReadSize %d *pNoBytesRead %d\n",
                    rc, pSpool->hReadFile, pBuf, cbReadSize, *pNoBytesRead));
        }

        //
        //  Provide Feedback so user can see printing progress
        //  on despooling, the size is updated here and not in write
        //  printer because the journal data is larger than raw
        //
        if ( ( pSpool->pIniJob->Status & JOB_PRINTING ) &&
             ( *pNoBytesRead != 0 )) {

            SplOutSem();
            EnterSplSem();

            dwFileSize = GetFileSize( pSpool->hReadFile, 0 );

            COPYNV(NotifyVector, NVWriteJob);

            if ( pSpool->pIniJob->Size < dwFileSize ) {

                DBGMSG( DBG_TRACE, ("LocalReadPrinter 2 adjusting size old %d new %d\n",
                    pSpool->pIniJob->Size, dwFileSize));

                pSpool->pIniJob->Size = dwFileSize;

                ADDNV(NotifyVector, NVSpoolJob);
            }

            pSpool->pIniJob->cbPrinted += *pNoBytesRead;

            //
            // HACK !!! Each time we read from the spool file we add the
            // number of bytes read to pIniJob->cbPrinted. GDI will read twice certain
            // parts of the spool file. The spooler cannot know what is read twice, so it adds
            // to cbPrinted the number of bytes read at each call of this function.
            // This causes cbPrinted to be larger than the actual size of the spool file.
            //
            // Don't let the ratio cbPrinted/cbSize get above 1
            //
            if (pSpool->pIniJob->cbPrinted > pSpool->pIniJob->Size)
            {
                pSpool->pIniJob->cbPrinted = pSpool->pIniJob->Size;
            }

            //
            // Provide Feedback to Printman that data has been
            // written.  Note the size written is not used to
            // update the IniJob->cbPrinted becuase there is a
            // difference in size between journal data (in the
            // spool file) and the size of RAW bytes written to
            // the printer.
            //
            SetPrinterChange(pSpool->pIniPrinter,
                             pSpool->pIniJob,
                             NotifyVector,
                             PRINTER_CHANGE_WRITE_JOB,
                             pSpool->pIniSpooler);

           LeaveSplSem();
           SplOutSem();

        }

    } else if ( pSpool->TypeofHandle & PRINTER_HANDLE_PORT ) {

        //
        // Check if caller has read access to the currently printing job.
        //
        if (pSpool->pIniJob &&
            !ValidateObjectAccess(SPOOLER_OBJECT_DOCUMENT,
                                  JOB_READ,
                                  pSpool->pIniJob,
                                  NULL,
                                  pSpool->pIniSpooler)) {

            SetLastError(ERROR_ACCESS_DENIED);
            return FALSE;
        }

        if (pSpool->pIniPort->Status & PP_FILE)
        rc = ReadFile( pSpool->hReadFile, pBuf, cbReadSize, pNoBytesRead, NULL);

        else if ( pSpool->pIniPort->Status & PP_MONITOR ) 
        {

            HANDLE hMonitor = GetMonitorHandle(pSpool->pIniPort);
            pIniMonitor = GetOpenedMonitor(pSpool->pIniPort);

            if (pIniMonitor && hMonitor)
            {
                rc = (*pIniMonitor->Monitor2.pfnReadPort)(
                         hMonitor,
                         pBuf,
                         cbReadSize,
                         pNoBytesRead );            
            }
            else
            {
                SetLastError(ERROR_INVALID_HANDLE);
                rc = FALSE;
            }

        } 
        else
        {
            rc = ReadPrinter(pSpool->hPort, pBuf, cbReadSize, pNoBytesRead);
        }

    } else {

        SetLastError(ERROR_INVALID_HANDLE);
        rc = FALSE;
    }

    SplOutSem();

    DBGMSG( DBG_TRACE, ("LocalReadPrinter returns hPrinter %x pIniJob %x rc %x pNoBytesRead %d\n",hPrinter, pSpool->pIniJob, rc, *pNoBytesRead));

    return rc;
}

LPBYTE SearchForExistingView(
    PSPOOL  pSpool,
    DWORD   dwRequired)

/*++
Function Description -- Searches for an existing mapped view of the spool file which
                        has the required number of bytes.

Parameters --  pSpool     -- Pointer to a SPOOL structure
               dwRequired -- Number of bytes to be mapped from the start of the page

Return Value -- pointer to the start of the mapped view;
                NULL if the call fails.
--*/

{
    LPBYTE        pReturn = NULL;
    PSPLMAPVIEW   pSplMapView;

    for (pSplMapView = pSpool->pSplMapView;
         pSplMapView;
         pSplMapView = pSplMapView->pNext) {

        if (dwRequired <= pSplMapView->dwMapSize) {
            pReturn = pSplMapView->pStartMapView;
            break;
        }
    }

    return pReturn;
}

LPBYTE CreateNewMapView(
    PSPOOL  pSpool,
    DWORD   dwRequired)

/*++
Function Description -- Creates a new mapping view of the required segment of the spool
                        file

Parameters --  pSpool     -- Pointer to a SPOOL structure
               dwRequired -- Number of bytes to be mapped from the start of the page

Return Value -- pointer to the start of the mapped view;
                NULL if the call fails.
--*/

{
    HANDLE          hMapSpoolFile;
    LPBYTE          pStartMapView;
    DWORD           dwMapSize, dwFileSize;
    LPBYTE          pReturn = NULL;
    PSPLMAPVIEW     pSplMapView;

    pSplMapView  =  (PSPLMAPVIEW) AllocSplMem(sizeof(SPLMAPVIEW));

    if (!pSplMapView) {
        // Allocation failed.
        goto CleanUp;
    }

    dwFileSize = GetFileSize(pSpool->hReadFile, NULL);

    pSplMapView->dwMapSize = (dwFileSize <= MAX_SPL_MAPVIEW_SIZE) ? dwFileSize
                                                                  : dwRequired;

    pSplMapView->hMapSpoolFile = NULL;
    pSplMapView->pStartMapView = NULL;
    pSplMapView->pNext = NULL;

    // Create file mapping
    pSplMapView->hMapSpoolFile = CreateFileMapping(pSpool->hReadFile, NULL, PAGE_READONLY, 0, pSplMapView->dwMapSize, NULL);
    if (!pSplMapView->hMapSpoolFile) {
        goto CleanUp;
    }

    // Map a view of the file
    pSplMapView->pStartMapView = (LPBYTE) MapViewOfFile(pSplMapView->hMapSpoolFile, FILE_MAP_READ, 0, 0, pSplMapView->dwMapSize);

    pReturn = pSplMapView->pStartMapView;

CleanUp:

    if (!pReturn && pSplMapView) {
        // Free any allocated resources
        if (pSplMapView->pStartMapView) {
            UnmapViewOfFile( (LPVOID) pSplMapView->pStartMapView);
        }
        if (pSplMapView->hMapSpoolFile) {
            CloseHandle(pSplMapView->hMapSpoolFile);
        }
        FreeSplMem(pSplMapView);
    }

    if (pReturn) {
        pSplMapView->pNext = pSpool->pSplMapView;
        pSpool->pSplMapView = pSplMapView;
    }

    return pReturn;
}

BOOL SetMappingPointer(
    PSPOOL pSpool,
    LPBYTE *pMapBuffer,
    DWORD  cbReadSize
)
/*++
Function Description: SetMappingPointer creates a file mapping object and a mapped view (if necessary).
                      If the required number of bytes are present in the view, the pointer to the
                      data is returned in the buffer (pMappedBuffer) else the call fails.
                      The current offset is taken from pSpool->hReadFile and if the buffer is available,
                      the offset of hReadFile is changed correspondingly. This ensures that SplReadPrinter
                      and ReadPrinter can be used alternately.

                      ****Modifications required for 64 bit architecture****

Parameters:   pSpool        -- pointer to the SPOOL structure
              *pMapBuffer   -- pointer to the mapped file view
              cbReadView    -- number of bytes to be read

Return Values: TRUE if successful;
               FALSE otherwise
--*/
{
    BOOL   bReturn = FALSE;
    DWORD  dwCurrentPosition, dwNewPosition, dwRequired;
    LPBYTE pStartMapView;

    dwCurrentPosition = SetFilePointer(pSpool->hReadFile, 0, NULL, FILE_CURRENT);

    if (dwCurrentPosition == 0xffffffff && GetLastError() != NO_ERROR) {
        goto CleanUp;
    }

    dwRequired = dwCurrentPosition + cbReadSize;

    if (dwRequired > MAX_SPL_MAPVIEW_SIZE) {
        // Map size is insufficient; fail the call
        SetLastError(ERROR_NOT_SUPPORTED);
        goto CleanUp;
    }

    pStartMapView = SearchForExistingView(pSpool, dwRequired);

    if (!pStartMapView) {
        pStartMapView = CreateNewMapView(pSpool, dwRequired);
    }

    if (!pStartMapView) {
        // Required view not created
        goto CleanUp;
    }

    // Check for DWORD alignment
    if ((((ULONG_PTR) pStartMapView + dwCurrentPosition) & 3) != 0) {
        // Fails unaligned reads
        SetLastError(ERROR_MAPPED_ALIGNMENT);
        goto CleanUp;
    }

    dwNewPosition = SetFilePointer(pSpool->hReadFile, cbReadSize, NULL, FILE_CURRENT);

    if (dwNewPosition == 0xffffffff && GetLastError() != NO_ERROR) {
        goto CleanUp;
    }

    if (pMapBuffer) {
        *pMapBuffer = (LPBYTE) ((ULONG_PTR) pStartMapView + dwCurrentPosition);
    }

    bReturn = TRUE;

CleanUp:

    // All the handles and associated resources will be freed along with pSpool
    return bReturn;
}

BOOL
LocalEndDocPrinter(
   HANDLE hPrinter
   )

/*++

Routine Description:

    By Default the routine is in critical section.
    The reference counts for any object we are working on (pSpool and pIniJob)
    are incremented, so that when we leave critical section for lengthy
    operations these objects are not deleted.

Arguments:


Return Value:


--*/

{
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    BOOL        bReturn = TRUE;
    DWORD       rc;
    PINIMONITOR pIniMonitor = NULL;
    HANDLE      hMonitor = NULL;
    DWORD       Position = 0;

    DBGMSG(DBG_TRACE, ("Entering LocalEndDocPrinter with %x\n", hPrinter));

    SplOutSem();
    EnterSplSem();

    if (pSpool          &&
        pSpool->pIniJob &&
        !(pSpool->TypeofHandle & PRINTER_HANDLE_PORT)) {

        INCJOBREF(pSpool->pIniJob);
        LeaveSplSem();

        LogWmiTraceEvent(pSpool->pIniJob->JobId, EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);

        EnterSplSem();
        DECJOBREF(pSpool->pIniJob);
    }

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER ))  {
        LeaveSplSem();
        return(FALSE);
    }

    if (!(pSpool->Status & SPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        LeaveSplSem();
        return(FALSE);
    }

    if (pSpool->Status & SPOOL_STATUS_ADDJOB) {
        SetLastError(ERROR_SPL_NO_STARTDOC);
        LeaveSplSem();
        return(FALSE);
    }

    if ( pSpool->pIniJob ) {
        pSpool->pIniJob->dwAlert |= JOB_ENDDOC_CALL;
    }

    pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

    //
    // Case-1 Printer Handle is PRINTER_HANDLE_PORT
    // Note - there are two cases to keep in mind here
    //
    // A] The first case is the despooling thread calling
    // a port with a monitor - LPT1:/COM1: or any port
    // created by the monitor
    //
    // B] The second case is when the application thread is
    // doing an EndDocPrinter to a port which has no monitor
    // This is the local printer masquerading as a remote  printer
    // case. Remember for this case there is no IniJob created
    // on the local printer at all. We just pass the call
    // straight to the remote printer.
    //

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {

        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER));

        //
        // Now check if this pSpool object's port has
        // a monitor
        //
        if ( pSpool->pIniPort->Status & PP_MONITOR ) { //Case A]

            //
            // Check if our job is really around
            //
            if (!pSpool->pIniJob) {
                SetLastError(ERROR_CAN_NOT_COMPLETE);
                bReturn = FALSE;
                goto CleanUp;
            }

            //
            // Originally we had a call to UpdateJobAttributes, but
            // we do not believe it is needed since it is also called during
            // LocalStartDocPrinter.  Note that you can't change the DevMode
            // in SetLocalJob, so once we calculate the information, we
            // don't have to worry about it changing.
            //

            if (pSpool->pIniJob->cLogicalPagesPrinted)
            {
                pSpool->pIniJob->cLogicalPagesPrinted = 0;
                pSpool->pIniJob->cPagesPrinted++;
                pSpool->pIniPrinter->cTotalPagesPrinted++;

                SetPrinterChange(pSpool->pIniPrinter,
                                 pSpool->pIniJob,
                                 NVWriteJob,
                                 PRINTER_CHANGE_WRITE_JOB,
                                 pSpool->pIniSpooler);
            }

            //
            // We need to leave the spooler critical section
            // because we're going call into the Monitor.
            // so bump up ref count on pSpool and pIniJob
            //
            pSpool->cRef++;

            INCJOBREF(pSpool->pIniJob);

            hMonitor = GetMonitorHandle(pSpool->pIniPort);
            pIniMonitor = GetOpenedMonitor(pSpool->pIniPort);

            if (pIniMonitor && hMonitor)
            {
                if (pIniMonitor == pSpool->pIniPort->pIniLangMonitor) 
                {

                    //
                    // If job is printing thru a language monitor we will get
                    // SetJob with JOB_CONTROL_LAST_PAGE_EJECTED in addition to
                    // JOB_CONTROL_SENT_TO_PRINTER
                    //
                    pSpool->pIniJob->dwJobControlsPending += 2;

                } 
                else 
                {
                    pSpool->pIniJob->dwJobControlsPending++;
                }

                //
                // LocalEndDocPrinter can be called because a normal termination of
                // a job or because of a delete/restart operation.
                // We need to know this when the monitor sends JOB_CONTROL_LAST_PAGE_EJECTED
                // to make the distinction if this is a real TEOJ or not.
                // Since JOB_PENDING_DELETION and JOB_RESTART are cleared later on,
                // we'll set this special flag.
                // JOB_INTERRUPTED means that LocalEndDocPrinter was issued by a
                // was a cancel/restart action.
                //
                if (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) {

                   InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_INTERRUPTED);
                }

                LeaveSplSem();

                SPLASSERT(pIniMonitor);

                SPLASSERT(pSpool->pIniPort->Status & PP_STARTDOC);

                SplOutSem();

                bReturn = (*pIniMonitor->Monitor2.pfnEndDocPort)(hMonitor);

                EnterSplSem();
                pSpool->pIniPort->Status &= ~PP_STARTDOC;
                pSpool->cRef--;
              
                ReleaseMonitorPort(pSpool->pIniPort);
                
                DECJOBREF(pSpool->pIniJob);                
            }
            else
            {
                SetLastError(ERROR_INVALID_HANDLE);
                bReturn = FALSE;                
            }

            goto CleanUp;

        } else { // Case B]

            //
            // We leave critical section here so bump pSpool object only
            // Note ----THERE IS NO INIJOB HERE AT ALL---Note
            // this call is synchronous; we will call into the router
            // who will then call the appropriate network print providor
            // e.g win32spl.dll
            //
             pSpool->cRef++;
             LeaveSplSem();

             if (pSpool->Status & SPOOL_STATUS_PRINT_FILE) {
                 if (!CloseHandle(pSpool->hFile)) {
                     DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: Printing to File, CloseHandle failed\n"));
                     bReturn = FALSE;
                 } else {
                    DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: Printing to File, CloseHandle succeeded\n"));
                    pSpool->Status &= ~SPOOL_STATUS_PRINT_FILE;
                    bReturn = TRUE;
                }
             } else {
                bReturn = (BOOL) EndDocPrinter(pSpool->hPort);
             }

             EnterSplSem();
             pSpool->cRef--;
             goto CleanUp;
        }
    }

    SplInSem();
    //
    //  Case-2  Printer Handle is Direct
    //
    //
    //  and the else clause is
    //
    //
    // Case-3  Printer Handle is Spooled
    //

    if (!pSpool->pIniJob) {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        bReturn = FALSE;
        goto CleanUp;
    }


    if (pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT) {

        HANDLE WaitForRead = pSpool->pIniJob->WaitForRead;
        PINIPORT pIniPort1 = pSpool->pIniJob->pIniPort;

        //
        // Port may have been deleted by another EndDocPrinter
        //
        if (pIniPort1) {

            SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));

            //
            // Printer Handle is Direct
            //
            pSpool->cRef++;
            INCJOBREF(pSpool->pIniJob);
            pIniPort1->cRef++;

            //
            // If the job was canceled by the user, there is no need to wait
            // for the write and read events. In certain cases when the job is
            // direct and canceled before LocalEndDocPrinter, those events
            // will never be signaled again. So waiting on them will be infinite
            //
            if (!(pSpool->pIniJob->Status & JOB_PENDING_DELETION))
            {
                LeaveSplSem();

                if( (WaitForRead != NULL) ){
                    WaitForSingleObject(WaitForRead, INFINITE);
                }

                pSpool->pIniJob->cbBuffer = 0;
                SetEvent(pSpool->pIniJob->WaitForWrite);
                WaitForSingleObject(pIniPort1->hPortThreadRunning, INFINITE);

                SplOutSem();
                EnterSplSem();

            } else {
                //
                // If the job is canceled, there are no more Write operations coming in.
                // Unlock the port thread which is waiting on this event inside ReadPrinter.
                //
                SetEvent(pSpool->pIniJob->WaitForWrite);

                //
                // Set cbBuffer on 0, since there are no more Read/Write oparatins expected.
                //
                pSpool->pIniJob->cbBuffer = 0;
            }

            pSpool->cRef--;
            pIniPort1->cRef--;
            DECJOBREF(pSpool->pIniJob);
            if ((pIniPort1->Status & PP_DELETING) && !pIniPort1->cRef)
                DeletePortEntry(pIniPort1);
        }

    } else {
        //
        // Printer Handle is Spooled
        //
        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));
        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_DIRECT));

        //
        // Update page count
        //
        LeaveSplSem();

        UpdateJobAttributes(pSpool->pIniJob);

        EnterSplSem();

        if (pSpool->pIniJob->cLogicalPages)
        {
            pSpool->pIniJob->cLogicalPages = 0;
            pSpool->pIniJob->cPages++;

            //
            // Notify the change in the page count
            //
            SetPrinterChange(pSpool->pIniPrinter,
                             pSpool->pIniJob,
                             NVSpoolJob,
                             PRINTER_CHANGE_WRITE_JOB,
                             pSpool->pIniSpooler);
        }

        if (pSpool->pIniJob->hFileItem != INVALID_HANDLE_VALUE)
        {
            // If this job is a keeper or the job is greater than 200KB and not
            // already printing close the write file, so that the memory from
            // the file can be reclaimed by the system.  Without this the
            // spooler can eat up a lot of memory.  File pooling doesn't
            // significantly help speed up printing of the larger files anyway.
            // If the printer is stopped or the job is big and not already
            // despooling or printing then close files, which closes the memory
            // mappings (buffered I/O).

            // Not necessarily bad, this also is true if the printer is paused.
            if ((PrinterStatusBad(pSpool->pIniJob->pIniPrinter->Status) ||
                 (pSpool->pIniJob->pIniPrinter->Attributes &
                  PRINTER_ATTRIBUTE_WORK_OFFLINE)) &&
                !(pSpool->pIniJob->Status & JOB_PRINTING) &&
                !(pSpool->pIniJob->Status & JOB_DESPOOLING))
            {
                LeaveSplSem();
                CloseFiles(pSpool->pIniJob->hFileItem, TRUE);
                EnterSplSem();
            }
            else if (!(pSpool->pIniJob->Status & JOB_PRINTING) &&
                 (pSpool->pIniJob->Size > FP_LARGE_SIZE))
            {
                LeaveSplSem();
                CloseFiles(pSpool->pIniJob->hFileItem, TRUE);
                EnterSplSem();
            }
            FinishedWriting(pSpool->pIniJob->hFileItem, TRUE);
            pSpool->pIniJob->hWriteFile = INVALID_HANDLE_VALUE;

        }
        else if (!CloseHandle(pSpool->pIniJob->hWriteFile)) {
            DBGMSG(DBG_WARNING, ("CloseHandle failed %d %d\n", pSpool->pIniJob->hWriteFile, GetLastError()));

        } else {
            DBGMSG(DBG_TRACE, ("LocalEndDocPrinter: ClosedHandle Success hWriteFile\n" ));
            pSpool->pIniJob->hWriteFile = INVALID_HANDLE_VALUE;
        }

        // Despooling whilst spooling requires us to wake the writing
        // thread if it is waiting.

        if ( pSpool->pIniJob->WaitForWrite != NULL )
            SetEvent(pSpool->pIniJob->WaitForWrite);

        // Set the event for SeekPrinter
        SeekPrinterSetEvent(pSpool->pIniJob, NULL, TRUE);

    }

    SPLASSERT(pSpool);
    SPLASSERT(pSpool->pIniJob);


    // Case 2 - (Direct)  and Case 3 - (Spooled) will both execute
    // this block of code because both direct and spooled handles
    // are first and foremost PRINTER_HANDLE_PRINTER handles


    if (pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER) {

        SPLASSERT(!(pSpool->TypeofHandle & PRINTER_HANDLE_PORT));

        // WARNING
        // If pIniJob->Status has JOB_SPOOLING removed and we leave
        // the critical section then the scheduler thread will
        // Start the job printing.   This could cause a problem
        // in that the job could be completed and deleted
        // before the shadow job is complete.   This would lead
        // to access violations.

        SPLASSERT(pSpool);
        SPLASSERT(pSpool->pIniJob);

        if (pSpool->pIniJob->Status & JOB_SPOOLING) {

            InterlockedAnd((LONG*)&(pSpool->pIniJob->Status), ~JOB_SPOOLING);
            pSpool->pIniJob->pIniPrinter->cSpooling--;
        }


        // It looks like the ref count on the job is != 0, so the job should not
        // get deleted while this shadow is being written.
        // Having this operation in the critsec is preventing us from getting
        // good CPU utilization.  Icecap is showing many (100+ in some cases)
        // other spool threads waiting on this when I push the server.
        WriteShadowJob(pSpool->pIniJob, TRUE);

        SplInSem();

        //
        // This line of code is crucial; for timing reasons it
        // has been moved from the Direct (Case 2) and the
        // Spooled (Case 3) clauses. This decrement is for the
        // initial
        //

        SPLASSERT(pSpool->pIniJob->cRef != 0);
        DECJOBREF(pSpool->pIniJob);

        if (pSpool->pIniJob->Status & JOB_PENDING_DELETION) {

            DBGMSG(DBG_TRACE, ("EndDocPrinter: Deleting Pending Deletion Job\n"));
            DeleteJob(pSpool->pIniJob,BROADCAST);
            pSpool->pIniJob = NULL;

        } else {

            if ( pSpool->pIniJob->Status & JOB_TIMEOUT ) {

                InterlockedAnd((LONG*)&(pSpool->pIniJob->Status), ~( JOB_TIMEOUT | JOB_ABANDON ));
                FreeSplStr(pSpool->pIniJob->pStatus);
                pSpool->pIniJob->pStatus = NULL;
            }

            DBGMSG(DBG_TRACE, ("EndDocPrinter:PRINTER:cRef = %d\n", pSpool->pIniJob->cRef));
            CHECK_SCHEDULER();
        }
    }

    if (pSpool->pIniJob) {

        SetPrinterChange(pSpool->pIniPrinter,
                         pSpool->pIniJob,
                         NVJobStatus,
                         PRINTER_CHANGE_SET_JOB,
                         pSpool->pIniSpooler);
    }

CleanUp:

    if (pSpool->pIniJob) {
        pSpool->pIniJob->dwAlert &= ~JOB_ENDDOC_CALL;

        //
        // WMI Trace Events
        //
        if (((pSpool->pIniJob->Status & JOB_PAUSED) ||
             (pSpool->pIniJob->pIniPrinter->Status & PRINTER_PAUSED)) &&
            (!((pSpool->pIniJob->Status & JOB_PRINTING)   ||
               (pSpool->pIniJob->Status & JOB_PRINTED))))
        {
            INCJOBREF(pSpool->pIniJob);
            LeaveSplSem();

            LogWmiTraceEvent(pSpool->pIniJob->JobId, EVENT_TRACE_TYPE_SPL_PAUSE, NULL);

            EnterSplSem();
            DECJOBREF(pSpool->pIniJob);

        }
        DeleteJobCheck(pSpool->pIniJob);
    }

    LeaveSplSem();
    SplOutSem();

    return bReturn;
}

BOOL
PrintingDirectlyToPort(
    PSPOOL  pSpool,
    DWORD   Level,
    LPBYTE  pDocInfo,
    LPDWORD pJobId
)
{
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    BOOL    rc = FALSE;
    DWORD   Error;
    BOOL bPrinttoFile = FALSE;
    BOOL bErrorOccurred = FALSE;
    PINIMONITOR pIniMonitor = NULL, pIniLangMonitor = NULL;
    LPWSTR      pszPrinter;
    HANDLE      hThread = NULL;
    DWORD       dwThreadId = 0;
    TCHAR       szFullPrinter[MAX_UNC_PRINTER_NAME];
    DWORD       PortError = ERROR_SUCCESS;
    
    //
    // Some monitors rely on having the non-qualified name, so only
    // use the fully qualified name for clustered spoolers.
    //
    // This means that anyone writing a cluster aware monitor will
    // need to handle both types of names.
    //
    if( pSpool->pIniPrinter->pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ){

        //
        // Must use fully qualified name.
        //
        StringCchPrintf(szFullPrinter, COUNTOF(szFullPrinter), L"%ws\\%ws", pSpool->pIniPrinter->pIniSpooler->pMachineName, pSpool->pIniPrinter->pName);

        pszPrinter = szFullPrinter;

    } else {

        //
        // Local name is sufficient.
        //
        pszPrinter = pSpool->pIniPrinter->pName;
    }

    DBGMSG( DBG_TRACE,
            ( "PrintingDirectlyToPort: Printing document %ws direct to port\n",
              DBGSTR( pDocInfo1->pDocName )));

    if (pDocInfo1 &&
        pDocInfo1->pDatatype &&
        !ValidRawDatatype(pDocInfo1->pDatatype)) {

        //
        // We want to skip the error if this flags is on and there
        // is no monitor.
        //
        if (!(pSpool->pIniSpooler->SpoolerFlags & SPL_NON_RAW_TO_MASQ_PRINTERS &&
              !(pSpool->pIniPort->Status & PP_MONITOR))){

            DBGMSG(DBG_WARNING, ("Datatype is not RAW\n"));

            SetLastError(ERROR_INVALID_DATATYPE);
            rc = FALSE;
            goto CleanUp;
        }
    }

    if (pSpool->pIniPort->Status & PP_MONITOR) {

        if ( !(pSpool->pIniPort->Status & PP_FILE) &&
             (pSpool->pIniPrinter->Attributes & PRINTER_ATTRIBUTE_ENABLE_BIDI) )
            pIniLangMonitor = pSpool->pIniPrinter->pIniDriver->pIniLangMonitor;


        //
        // WARNING!!
        //
        // We should never leave this loop unless we check for the presence of the UI
        // thread (hThread) and make sure it has been terminated.
        //
        //
        do {

            //
            // This fixes Intergraph's problem -- of wanting to print
            // to file but their 3.1 print-processor does not pass
            // thru the file name.
            //
            if (pSpool->pIniJob->Status & JOB_PRINT_TO_FILE) {
                if ( pDocInfo1 && !pDocInfo1->pOutputFile ) {
                    pDocInfo1->pOutputFile = pSpool->pIniJob->pOutputFile;
                }
            }

            //
            // Some monitors (LPRMON) may fail to initialize at startup
            // because a driver they are dependent on.
            //
            SplOutSem();
            EnterSplSem();

            //
            // Check if being deleted.
            //
            if( pSpool->pIniJob->Status & JOB_PENDING_DELETION ){

                LeaveSplSem();
                SetLastError(ERROR_PRINT_CANCELLED);

                if( hThread ) {

                    //
                    // See if the thread is still running or
                    // dismissed by user.
                    //
                    if( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {

                        MyPostThreadMessage(hThread, dwThreadId,
                                            WM_QUIT, IDRETRY, 0);
                        WaitForSingleObject( hThread, INFINITE );
                    }
                    CloseHandle( hThread );
                    hThread = NULL;
                }

                rc = FALSE;
                goto CleanUp;
            }


            PortError = StatusFromHResult(OpenMonitorPort(pSpool->pIniPort,
													      pIniLangMonitor,
														  pszPrinter));

            //
            // Chances are the port monitor doesn't work with the lang monitor,
            // but we still want to print.
            // However, if the LM says that it's busy, then don't bother to 
            // try the monito, since that is busy as well.
            //
            if (PortError != ERROR_SUCCESS && 
                PortError != ERROR_BUSY && 
                pIniLangMonitor) 
            {
                //
                // Close the monitor handle on EndDoc.
                //
                PortError = StatusFromHResult(OpenMonitorPort(pSpool->pIniPort,
															  NULL,
														      pszPrinter));

                if (PortError == ERROR_SUCCESS)
                {
                    pIniLangMonitor = NULL;
                }                
            }

            if (PortError == ERROR_SUCCESS)
            {
                pIniMonitor = GetOpenedMonitor(pSpool->pIniPort);                
            }

            LeaveSplSem();
            SplOutSem();

            if (PortError == ERROR_SUCCESS)
            {
                rc = (*pIniMonitor->Monitor2.pfnStartDocPort)(GetMonitorHandle(pSpool->pIniPort),
                                                              pszPrinter,
                                                              pSpool->pIniJob->JobId,
                                                              Level, 
                                                              pDocInfo);
                
                

                if ( rc ) {

                    pSpool->pIniPort->Status |= PP_STARTDOC;

                    //
                    // StartDoc successful.
                    //
                    if ( hThread ) {

                        //
                        // We have started a message box and now the
                        // automatically retry has succeeded, we need to
                        // kill the message box and continue to print.
                        //
                        // See if the thread is still running or dismissed
                        // by user.
                        //
                        if ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {

                            MyPostThreadMessage(hThread, dwThreadId,
                                                WM_QUIT, IDRETRY, 0 );
                            WaitForSingleObject( hThread, INFINITE );
                        }
                        CloseHandle( hThread );
                        hThread = NULL;
                    }
                } else {

                    Error = GetLastError();

                    SplOutSem();
                    EnterSplSem();
                    ReleaseMonitorPort(pSpool->pIniPort);
                    LeaveSplSem();
                    SplOutSem();

                    //
                    // Check for pending deletion first, which prevents the
                    // dialog from coming up if the user hits Del.
                    //
                    if ( (pSpool->pIniJob->Status & (JOB_PENDING_DELETION | JOB_RESTART)) ||
                        (PromptWriteError( pSpool, &hThread, &dwThreadId ) == IDCANCEL)) {

                        if ( hThread ) {

                            //
                            // See if the thread is still running or
                            // dismissed by user.
                            //
                            if ( WAIT_TIMEOUT == WaitForSingleObject( hThread, 0 )) {
                                MyPostThreadMessage(hThread, dwThreadId,
                                                    WM_QUIT, IDRETRY, 0 );
                                WaitForSingleObject( hThread, INFINITE );
                            }
                            CloseHandle( hThread );
                            hThread = NULL;
                        }

                        pSpool->pIniJob->StartDocError = Error;
                        SetLastError(ERROR_PRINT_CANCELLED);
                        rc = FALSE;
                        goto CleanUp;
                    }
                    bErrorOccurred = TRUE;
                }
            }


        } while (!rc);

        //
        // If an error occurred, we set some error bits in the job
        // status field.  Clear them now since the StartDoc succeeded.
        //
        if( bErrorOccurred ){
            EnterSplSem();
            ClearJobError( pSpool->pIniJob );
            LeaveSplSem();
        }

        pSpool->Status |= SPOOL_STATUS_STARTDOC;

        if ( pIniLangMonitor ) {

            InterlockedOr((LONG*)&(pSpool->pIniJob->Status), JOB_TRUE_EOJ);
        }

        if ( pSpool->pIniJob->pIniPrinter->pSepFile &&
             *pSpool->pIniJob->pIniPrinter->pSepFile) {

            DoSeparator(pSpool);
        }

        // Let the application's thread return from PrintingDirect:

        DBGMSG(DBG_PORT, ("PrintingDirectlyToPort: Calling SetEvent( %x )\n",
                          pSpool->pIniJob->StartDocComplete));

        if(pSpool->pIniJob->StartDocComplete) {

            if ( !SetEvent( pSpool->pIniJob->StartDocComplete ) ) {

                DBGMSG( DBG_WARNING, ("SetEvent( %x ) failed: Error %d\n",
                                      pSpool->pIniJob->StartDocComplete,
                                      GetLastError() ));
            }
        }

    } else  {

        DBGMSG(DBG_TRACE, ("Port has no monitor: Calling StartDocPrinter or maybe printing to file\n"));

        EnterSplSem();
        bPrinttoFile = (pDocInfo1 && IsGoingToFile(pDocInfo1->pOutputFile,
                                        pSpool->pIniSpooler));
        LeaveSplSem();

        if (bPrinttoFile) {

            HANDLE hFile = INVALID_HANDLE_VALUE;

            DBGMSG(DBG_TRACE, ("Port has no monitor: Printing to File %ws\n", pDocInfo1->pOutputFile));

            //
            // This is OK since we are impersonating the user at this point.
            //
            hFile = CreateFile( pDocInfo1->pOutputFile,
                                GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );

            if (hFile == INVALID_HANDLE_VALUE) {
                DBGMSG(DBG_TRACE, ("Port has no monitor: File open failed\n"));
                rc = FALSE;
            } else {
                DBGMSG(DBG_TRACE, ("Port has no monitor: File open succeeded\n"));
                SetEndOfFile(hFile);
                pSpool->hFile = hFile;
                pSpool->Status |= SPOOL_STATUS_PRINT_FILE;

                //
                // Have to set JobId to some non zero value otherwise
                // StartDocPrinter expects the JobId to be off the pSpool->pIniJob
                // We have none so we'll access violate!!
                //
                *pJobId = TRUE;
                rc = TRUE;
            }


        } else {
            DBGMSG(DBG_TRACE, ("Port has no monitor: Calling StartDocPrinter\n"));

            *pJobId = StartDocPrinter(pSpool->hPort, Level, pDocInfo);
            rc = *pJobId != 0;
        }

        if (!rc) {
            DBGMSG(DBG_WARNING, ("StartDocPrinter failed: Error %d\n", GetLastError()));
        }
    }

    SPLASSERT( hThread == NULL );

CleanUp:

    return rc;
}

DWORD
WriteToPrinter(
    PSPOOL  pSpool,
    LPBYTE  pByte,
    DWORD   cbBuf
)
{

    if( pSpool->pIniJob->WaitForRead != NULL ) {

        WaitForSingleObject(pSpool->pIniJob->WaitForRead, INFINITE);

        cbBuf = pSpool->pIniJob->cbBuffer = min(cbBuf, pSpool->pIniJob->cbBuffer);
        memcpy(pSpool->pIniJob->pBuffer, pByte, cbBuf);

    } else {

        pSpool->pIniJob->cbBuffer = cbBuf = 0;

    }

    SetEvent(pSpool->pIniJob->WaitForWrite);

    return cbBuf;
}

DWORD
ReadFromPrinter(
    PSPOOL  pSpool,
    LPBYTE  pBuf,
    DWORD   cbBuf
)
{
    pSpool->pIniJob->pBuffer = pBuf;
    pSpool->pIniJob->cbBuffer = cbBuf;

    SetEvent(pSpool->pIniJob->WaitForRead);

    WaitForSingleObject(pSpool->pIniJob->WaitForWrite, INFINITE);

    return pSpool->pIniJob->cbBuffer;
}

BOOL
ValidRawDatatype(
    LPWSTR pszDatatype)
{
    if (!pszDatatype || _wcsnicmp(pszDatatype, szRaw, 3))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\server.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    server.c

Abstract:

    Browsing

    This module contains the thread for notifying all Printer Servers

Author:

    Dave Snipp (DaveSn) 2-Aug-1992

Revision History:

--*/

#include <precomp.h>
#include <lm.h>

DWORD   ServerThreadRunning = FALSE;
HANDLE  ServerThreadSemaphore = NULL;
DWORD   ServerThreadTimeout = TEN_MINUTES;
DWORD   RefreshTimesPerDecayPeriod = DEFAULT_REFRESH_TIMES_PER_DECAY_PERIOD;
DWORD   BrowsePrintWorkstations = DEFAULT_NUMBER_BROWSE_WORKSTATIONS;
BOOL    bNetInfoReady = FALSE;            // TRUE when the browse list is "valid"
#define NT_SERVER   ( SV_TYPE_SERVER_NT | SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL )

extern FARPROC pfnNetServerEnum;
extern FARPROC pfnNetApiBufferFree;

DWORD
ServerThread(
    PVOID
    );

BOOL
UpdateServer(
    LPCTSTR pszServer
    );


BOOL
CreateServerThread(
    VOID
    )
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    SplInSem();

    if (!ServerThreadRunning) {

        ServerThreadSemaphore = CreateEvent( NULL, FALSE, FALSE, NULL );

        ThreadHandle = CreateThread( NULL, INITIAL_STACK_COMMIT,
                                     (LPTHREAD_START_ROUTINE)ServerThread,
                                     NULL,
                                     0, &ThreadId );

        if (!SetThreadPriority(ThreadHandle,
                               dwServerThreadPriority))
            DBGMSG(DBG_WARNING, ("Setting thread priority failed %d\n",
                     GetLastError()));

        ServerThreadRunning = TRUE;

        CloseHandle( ThreadHandle );
    }

    if( ServerThreadSemaphore != NULL ){

        // CreateServerThread is called each time a printer is shared out
        // see net.c ShareThisPrinter.
        // So if the ServerThread is sleeping wake prematurely so it can start
        // to tell the world about this new shared printer.

        SetEvent( ServerThreadSemaphore );

    }

    return TRUE;
}


DWORD
ServerThread(
    PVOID pv
    )

/*++

Routine Description:

    Notify other machines in our domain about our shared printers.

    We are going to have to enter and leave, revalidate, enter and leave our
    semaphore inside the loop.

Arguments:

Return Value:

--*/

{
    DWORD   NoReturned, i, Total;
    PSERVER_INFO_101 pserver_info_101;
    PINIPRINTER pIniPrinter;
    PINISPOOLER pIniSpooler;
    DWORD   ReturnValue=FALSE;
    WCHAR   ServerName[128];
    DWORD   StartTickCount;
    DWORD   TimeForAllServers;
    DWORD   dwActualWaitTime = ServerThreadTimeout;
    UINT    cPrintWorkstations;
    UINT    cPrintServers;
    UINT    cServersToInform;
    UINT    cWorkStationsToInform;

    ServerName[0] = ServerName[1] = '\\';

    while (TRUE) {

       SplOutSem();

        DBGMSG( DBG_TRACE, ("ServerThread sleeping for %d\n", dwActualWaitTime));

        WaitForSingleObject( ServerThreadSemaphore, dwActualWaitTime );

        // Wait for a couple of minutes more to avoid the boot time crunch
        Sleep(TWO_MINUTES);

        if ( !ServerThreadRunning ) {

            return FALSE;
        }

        SPLASSERT( pfnNetServerEnum != NULL );

        if (!(*pfnNetServerEnum)(NULL, 101, (LPBYTE *)&pserver_info_101, -1,
                                 &NoReturned, &Total, SV_TYPE_PRINTQ_SERVER,
                                 NULL, NULL)) {
            EnterSplSem();

            StartTickCount = GetTickCount();

            //
            //  1 Master + 3 Backup + 1 Backup per 32 Printer Servers.
            //

            cServersToInform      = DEFAULT_NUMBER_MASTER_AND_BACKUP + NoReturned/32 ;
            cWorkStationsToInform = BrowsePrintWorkstations;

            //
            //  Count the NT Server and Workstation machines ( which have a printq )
            //

            for (   i = 0, cPrintServers = 0, cPrintWorkstations = 0;
                    i < NoReturned;
                    i++ ) {

                if ( pserver_info_101[i].sv101_type & NT_SERVER ) {

                    cPrintServers++;

                } else if ( pserver_info_101[i].sv101_type & SV_TYPE_NT ) {

                    cPrintWorkstations++;
                }
            }

            //
            //  If there are no NT Servers to inform then up the number of Workstations
            //

            if ( cPrintServers == 0 ) {

                cWorkStationsToInform = max( cWorkStationsToInform, cServersToInform );
                cServersToInform = 0;

            } else if ( cPrintServers < cServersToInform ) {

                cWorkStationsToInform = max( cWorkStationsToInform, cServersToInform - cPrintServers );
            }


            DBGMSG( DBG_TRACE, ("ServerThread NetServerEnum returned %d printer servers will inform %d, workstations %d\n", NoReturned, cServersToInform, cWorkStationsToInform ));

            //
            //  Loop Until we have informed the correct Number of WorkStations and Servers
            //

            for (   i = 0,
                    cPrintServers = 0,
                    cPrintWorkstations = 0;

                        i < NoReturned &&
                        ( cPrintServers < cServersToInform || cPrintWorkstations < cWorkStationsToInform );

                            i++ ) {

                DBGMSG( DBG_TRACE, ("ServerThread  Loop Count %d cPrintServer %d cServersToInform %d cPrintWorkstations %d cWorkStationsToInform %d\n",
                                     i, cPrintServers, cServersToInform,  cPrintWorkstations, cWorkStationsToInform ));


                DBGMSG( DBG_TRACE, ("ServerThread %ws type %x\n",pserver_info_101[i].sv101_name, pserver_info_101[i].sv101_type ));

                if (( pserver_info_101[i].sv101_type & NT_SERVER ) ||
                    ( pserver_info_101[i].sv101_type & SV_TYPE_NT && cPrintWorkstations < cWorkStationsToInform )) {

                    StringCchPrintf(&ServerName[2], COUNTOF(ServerName) - 2, pserver_info_101[i].sv101_name);

                    if( UpdateServer( ServerName )){

                        // Servers are also counted as WorkStations

                        cPrintWorkstations++;

                        if ( pserver_info_101[i].sv101_type & NT_SERVER ) {

                            cPrintServers++;
                        }
                    }
                }
            }

            TimeForAllServers = GetTickCount() - StartTickCount;

            DBGMSG( DBG_TRACE, ("ServerThread took %d milliseconds for %d Workstations %d Servers\n",
                                TimeForAllServers, cPrintWorkstations, cPrintServers ));

            //
            // Calculate time to wait before we try again.
            //

            if ( NetPrinterDecayPeriod > TimeForAllServers ) {

                dwActualWaitTime = max( ServerThreadTimeout, ( NetPrinterDecayPeriod - TimeForAllServers ) / RefreshTimesPerDecayPeriod );

            } else {

                dwActualWaitTime = ServerThreadTimeout;
            }

            //
            //  Remove WAS Shared Bits
            //

            //
            // Do this for all spoolers.
            //
            for( pIniSpooler = pLocalIniSpooler;
                 pIniSpooler;
                 pIniSpooler = pIniSpooler->pIniNextSpooler ){

                for ( pIniPrinter = pIniSpooler->pIniPrinter;
                      pIniPrinter != NULL;
                      pIniPrinter = pIniPrinter->pNext ) {

                     SplInSem();
                     pIniPrinter->Status &= ~PRINTER_WAS_SHARED;
                }
            }

            LeaveSplSem();

            (*pfnNetApiBufferFree)((LPVOID)pserver_info_101);
        }
    }
    return FALSE;
}

typedef struct _UPDATE_SERVER_MAP_DATA {
    LPCWSTR pszServer;
    BOOL bSuccessfulAdd;
} UPDATE_SERVER_MAP_DATA, *PUPDATE_SERVER_MAP_DATA;

BOOL
UpdateServerPrinterMap(
    HANDLE h,
    PINIPRINTER pIniPrinter
    )

/*++

Routine Description:

    Update the a browser server with one pIniPrinter.

    Leaves Spooler Section--pIniPrinter may be invalid on return
    unless explicitly refcounted by callee.

Arguments:

    pIniPrinter - Printer that should be sent to the server.

    pszServer - Server that needs to be updated.

    pbSuccessfulAdd - Indicates whether the add was successful.

Return Value:

    Succes or failure?

--*/

{
    PUPDATE_SERVER_MAP_DATA pData = (PUPDATE_SERVER_MAP_DATA)h;

    WCHAR   string[MAX_PRINTER_BROWSE_NAME];
    WCHAR   Name[MAX_UNC_PRINTER_NAME];
    PRINTER_INFO_1  Printer1;
    HANDLE  hPrinter;
    PINISPOOLER pIniSpooler;
    DWORD dwLastError;

    Printer1.Flags = 0;

    if (( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED ) ||
        ( pIniPrinter->Status & PRINTER_WAS_SHARED )) {

        //
        // Pass our Printer Attributes so that AddNetPrinter can remove
        // this printer from the browse list if it is not shared.
        //
        Printer1.Flags = pIniPrinter->Attributes | PRINTER_ATTRIBUTE_NETWORK;

        StringCchPrintf(string, COUNTOF(string), L"%ws\\%ws,%ws,%ws",
                        pIniPrinter->pIniSpooler->pMachineName,
                        pIniPrinter->pName,
                        pIniPrinter->pIniDriver->pName,
                        pIniPrinter->pLocation ? pIniPrinter->pLocation : L"");

        Printer1.pDescription = string;

        StringCchPrintf(Name, COUNTOF(Name), L"%ws\\%ws",
                        pIniPrinter->pIniSpooler->pMachineName,
                        pIniPrinter->pName);

        Printer1.pName = Name;

        Printer1.pComment = AllocSplStr(pIniPrinter->pComment);

        SplInSem();

        LeaveSplSem();

        //
        // Keep trying until the server is not Too Busy.
        //

        for ( hPrinter = NULL;
              hPrinter == NULL;
              Sleep( GetTickCount() & 0xfff ) ) {

            hPrinter = AddPrinter( (LPTSTR)pData->pszServer, 1, (LPBYTE)&Printer1 );

            dwLastError = GetLastError();

            if ( hPrinter == NULL && dwLastError != RPC_S_SERVER_TOO_BUSY ) {

                if ( dwLastError != ERROR_PRINTER_ALREADY_EXISTS ) {

                    pData->bSuccessfulAdd = FALSE;
                }

                break;
            }
        }


        FreeSplStr(Printer1.pComment);

        if ( hPrinter != NULL ) {

            DBGMSG( DBG_TRACE,
                    ( "ServerThread AddPrinter(%ws, %ws) hPrinter %x Flags %x OK\n",
                      pData->pszServer, Printer1.pName, hPrinter, Printer1.Flags));

            ClosePrinter( hPrinter );
        }

        EnterSplSem();

        if ( hPrinter == NULL ) {


            if ( GetLastError() != ERROR_PRINTER_ALREADY_EXISTS ) {

                DBGMSG( DBG_TRACE,
                        ( "ServerThread AddPrinter(%ws, 1) Flags %x failed %d\n",
                          pData->pszServer, Printer1.Flags, GetLastError()));

                // Don't bother with this server if we get an error
                return FALSE;

            } else {

                //
                // 3.51 will return a NULL handle ( so it doesn't need closing
                // and ERROR_PRINTER_ALREADY_EXISTS on success ( see printer.c addnetprinter )
                //
                DBGMSG( DBG_TRACE,
                        ( "pszServerThread AddPrinter(%ws, %ws) hPrinter %x Flags %x OK\n",
                          pData->pszServer, Printer1.pName, hPrinter, Printer1.Flags));
            }
        }
    }

    return TRUE;
}

BOOL
UpdateServerSpoolerMap(
    HANDLE h,
    PINISPOOLER pIniSpooler
    )
{
    //
    // Do this only for spoolers that want this "feature."
    //
    if( pIniSpooler->SpoolerFlags & SPL_SERVER_THREAD ){
        RunForEachPrinter( pIniSpooler, h, UpdateServerPrinterMap );
    }
    return TRUE;
}

BOOL
UpdateServer(
    LPCTSTR pszServer
    )

/*++

Routine Description:

    Update a server about all the printers on this node.

Arguments:

    pszServer - Server to update in the form "\\server."

Return Value:

    TRUE - Successfully added.
    FALSE - Not.

--*/

{
    UPDATE_SERVER_MAP_DATA Data;
    Data.bSuccessfulAdd = TRUE;
    Data.pszServer = pszServer;

    RunForEachSpooler( &Data, UpdateServerSpoolerMap );

    return Data.bSuccessfulAdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\sources.inc ===
MAJORCOMP=console
MINORCOMP=localspl

NTPROFILEINPUT=yes

TARGETNAME=localspl
TARGETPATH=$(PROJECT_ROOT)\lib\$(_OBJ_DIR)
TARGETTYPE=DYNLINK

LINKLIBS= $(PROJECT_ROOT)\lib\$(O)\winprint.lib \
          $(PROJECT_ROOT)\lib\$(O)\localmon.lib

TARGETLIBS=\
           $(PROJECT_ROOT)\lib\$(O)\spoolss.lib \
           $(WINDOWS_LIB_PATH)\gdi32p.lib \
           $(SDK_LIB_PATH)\kernl32p.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\version.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\activeds.lib \
           $(SDK_LIB_PATH)\netapi32.lib \
           $(SDK_LIB_PATH)\adsiid.lib \
           $(SDK_LIB_PATH)\ntdsapi.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(PROJECT_ROOT)\lib\$(O)\spllib.lib \
           $(SDK_LIB_PATH)\secur32.lib \
           $(BASE_LIB_PATH)\sfc_os.lib \
           $(SDK_LIB_PATH)\userenv.lib \


DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

EXPECTED_WINVER=4.0

INCLUDES=..\;\
         ..\..\inc;\
         ..\..\inc\$(O);\
         ..\..\perflib;\
         ..\..\..\inc;\
         ..\..\..\..\inc;\
         ..\..\monitors\local;\
         $(WINDOWS_INC_PATH);\
         $(PROJECT_INC_PATH);\
         $(BASE_INC_PATH);\
         $(TERMSRV_INC_PATH)\

MISCFILES=..\sysprint.sep ..\pcl.sep ..\pscript.sep ..\sysprtj.sep

USE_MSVCRT=1

!IFNDEF DISABLE_NET_UNICODE
NET_C_DEFINES=-DNET_IS_UNICODE
!ENDIF


SOURCES=..\printer.c ..\openprn.c ..\setprn.c ..\getprn.c ..\job.c ..\msgbox.c \
        ..\spooler.c ..\addjob.c ..\driver.c ..\util.c ..\init.c ..\schedule.c \
        ..\port.c ..\prndata.c ..\monitor.c ..\prtproc.c ..\data.c ..\net.c \
        ..\forms.c ..\gdi.c ..\separate.c ..\localspl.rc \
        ..\security.c ..\server.c ..\eventlog.c ..\change.c ..\copyreg.c \
        ..\version.c ..\copyfile.c ..\files.c ..\config.c ..\upgrade.c \
        ..\sizethrd.c ..\devqury.c ..\mapsd.c ..\drvupgrd.c ..\portredn.c \
        ..\ds.cxx ..\varconv.cxx ..\property.cxx ..\inet.cxx ..\clusspl.c \
        ..\clusreg.c ..\jobid.c ..\xcv.c ..\dsupdate.cxx ..\clusport.c \
        ..\dsutil.cxx ..\dsprune.cxx ..\filepool.cxx ..\catalog.cxx \
        ..\ssp.cxx ..\openmon.cxx ..\monhndl.cxx

UMTYPE=console
UMLIBS=$(PROJECT_ROOT)\lib\*\localspl.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\mpr.lib \
       $(SDK_LIB_PATH)\netapi32.lib

UMRES=$(O)\localspl.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DNO_STRICT -DDBGLOG -DSPOOLKM -D_UNICODE

DELAYLOAD=\
            activeds.dll;\
            netapi32.dll;\
            ntdsapi.dll\

DLOAD_ERROR_HANDLER=kernel32

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\spoolsec.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    spoolsec.h

Abstract:

    Header file for print security

Author:

    Not known

Revision History:

    06-Apr-2001       AMaxa    CheckPrivilegePresent

--*/

#ifndef _SPOOLSEC_H_
#define _SPOOLSEC_H_

#ifdef __cplusplus
extern "C" {
#endif

// Object types
//

#define SPOOLER_OBJECT_SERVER   0
#define SPOOLER_OBJECT_PRINTER  1
#define SPOOLER_OBJECT_DOCUMENT 2
#define SPOOLER_OBJECT_COUNT    3
#define SPOOLER_OBJECT_XCV      4

/* These access bits must be different from those exposed in winspool.h,
 * so that no auditing takes place when we do an access check against them:
 */
#define SERVER_ACCESS_ADMINISTER_PRIVATE    0x00000004
#define PRINTER_ACCESS_ADMINISTER_PRIVATE   0x00000008
#define JOB_ACCESS_ADMINISTER_PRIVATE       0x00000080

enum
{
    kGuessTokenPrivileges = 1024
};

PSECURITY_DESCRIPTOR
CreateServerSecurityDescriptor(
    VOID
);

PSECURITY_DESCRIPTOR
CreatePrinterSecurityDescriptor(
    PSECURITY_DESCRIPTOR pCreatorSecurityDescriptor
);

PSECURITY_DESCRIPTOR
CreateDocumentSecurityDescriptor(
    PSECURITY_DESCRIPTOR pPrinterSecurityDescriptor
);

BOOL
SetPrinterSecurityDescriptor(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pModificationDescriptor,
    PSECURITY_DESCRIPTOR *ppObjectsSecurityDescriptor
);

BOOL
DeletePrinterSecurity(
    PINIPRINTER pIniPrinter
);

BOOL
DeleteDocumentSecurity(
    PINIJOB pIniJob
);

PSECURITY_DESCRIPTOR
CreateEverybodySecurityDescriptor(
    VOID
);

BOOL
ValidateObjectAccess(
    IN      DWORD               ObjectType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      LPVOID              ObjectHandle,
        OUT PACCESS_MASK        pGrantedAccess,
    IN      PINISPOOLER         pIniSpooler
    );

BOOL
ValidateObjectAccessWithToken(
    IN      HANDLE              hClientToken,
    IN      DWORD               ObjectType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      LPVOID              ObjectHandle,
        OUT PACCESS_MASK        pGrantedAccess,
    IN      PINISPOOLER         pIniSpooler
    );

BOOL
AccessGranted(
    DWORD       ObjectType,
    ACCESS_MASK DesiredAccess,
    PSPOOL      pSpool
);

VOID MapGenericToSpecificAccess(
    DWORD ObjectType,
    DWORD GenericAccess,
    PDWORD pSpecificAccess
);

BOOL
GetTokenHandle(
    PHANDLE TokenHandle
);

BOOL
GetSecurityInformation(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    PSECURITY_INFORMATION pSecurityInformation
);

ACCESS_MASK
GetPrivilegeRequired(
    SECURITY_INFORMATION SecurityInformation
);

BOOL
BuildPartialSecurityDescriptor(
    ACCESS_MASK          AccessGranted,
    PSECURITY_DESCRIPTOR pSourceSecurityDescriptor,
    PSECURITY_DESCRIPTOR *ppPartialSecurityDescriptor,
    PDWORD               pPartialSecurityDescriptorLength
);

PSECURITY_DESCRIPTOR
CreateDriversShareSecurityDescriptor(
    VOID
);


BOOL
InitializeSecurityStructures(
    VOID
    );

DWORD
PrincipalIsRemoteGuest(
    IN  HANDLE  hToken,
    OUT BOOL   *pbRemoteGuest
    );

DWORD
CheckPrivilegePresent(
    IN     HANDLE   hToken,
    IN     PLUID    pLuid,
    IN OUT LPBOOL   pbPresent,
    IN OUT LPDWORD  pAttributes OPTIONAL
    );

BOOL
GrantJobReadPermissionToLocalSystem(
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\upgrade.c ===
/*++

Copyright (c) 1990 - 2002  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    This file upgrades the forms on OS upgrade. It used to upgrade the drivers
    for NT 3 to NT 4, but that is not necessary now.

Author:

    Krishna Ganugapati (KrishnaG) 21-Apr-1994

Revision History:

    Matthew A Felton ( MattFe ) Aug 9 1995
    Remove the code which was married to TextMode setup to move drivers for one directory to another
    Now all environment upgrade from 3.1 is handled the same.

    Mark Lawrence (MLawrenc) Mar 25 2002
    Removed driver upgrade code for moving driver files around.

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

extern WCHAR *szSpoolDirectory;
extern WCHAR *szDirectory;
extern PWCHAR ipszRegistryWin32Root;
extern DWORD dwUpgradeFlag;
extern BUILTIN_FORM BuiltInForms[];

VOID
QueryUpgradeFlag(
    PINISPOOLER pIniSpooler
    )
/*++

    Description: the query update flag is set up by TedM. We will read this flag
    if the flag has been set, we will set a boolean variable saying that we're in
    the upgrade mode. All upgrade activities will be carried out based on this flag.
    For subsequents startups of the spooler, this flag will be unvailable so we
    won't run the spooler in upgrade mode.

    This code has been moved into router spoolss\dll\init.c

--*/
{
    dwUpgradeFlag  = SplIsUpgrade ();

    DBGMSG(DBG_TRACE, ("The Spooler Upgrade flag is %d\n", dwUpgradeFlag));
    return;
}

VOID UpgradeForms(
                  PINISPOOLER pIniSpooler
                 )
{
    PBUILTIN_FORM pBuiltInForm;
    HKEY          hFormsKey;
    WCHAR         BuiltInFormName[MAX_PATH];
    WCHAR         CustomFormName[FORM_NAME_LEN+1];
    WCHAR         CustomPad[CUSTOM_NAME_LEN+1];
    BYTE          FormData[32];
    DWORD         cbCustomFormName;
    DWORD         cbFormData;
    int           cForm;

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      pIniSpooler->pszRegistryForms,
                      0,
                      KEY_READ | DELETE,
                      &hFormsKey) != ERROR_SUCCESS)
    {
         DBGMSG( DBG_WARN, ("UpgradeForms Could not open %ws key\n", ipszRegistryForms));
         return;
    }


    if(!LoadStringW(hInst,
                    IDS_FORM_CUSTOMPAD,
                    CustomPad,
                    CUSTOM_NAME_LEN+1))
    {
       DBGMSG( DBG_WARN, ("UpgradeForms Could not find Custom string in resources"));
       goto CleanUp;
    }

    for(cForm=0;

        memset(CustomFormName, 0, sizeof(CustomFormName)),
        cbCustomFormName = COUNTOF(CustomFormName),
        RegEnumValueW(hFormsKey,
                      cForm,
                      CustomFormName,
                      &cbCustomFormName,
                      NULL,
                      NULL,
                      NULL,
                      NULL) == ERROR_SUCCESS;

        cForm++)
    {
        for(pBuiltInForm = BuiltInForms; pBuiltInForm->NameId; pBuiltInForm++)
        {
            if(!LoadStringW(hInst,
                            pBuiltInForm->NameId,
                            BuiltInFormName,
                            FORM_NAME_LEN+1))
            {
               DBGMSG( DBG_WARN, ("UpgradeForms Could not find Built in Form with Resource ID = %d in resource",pBuiltInForm->NameId));
               goto CleanUp;
            }

            if(!_wcsicmp(BuiltInFormName,CustomFormName))
            {
                SPLASSERT(wcslen(CustomFormName)<=FORM_NAME_LEN);
                cbFormData=FORM_DATA_LEN;
                if(RegQueryValueExW(hFormsKey, CustomFormName,
                                 NULL,NULL, (LPBYTE)FormData,
                                 &cbFormData)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not find value %ws",CustomFormName));
                   goto CleanUp;
                }
                if(RegDeleteValueW(hFormsKey,CustomFormName)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not delete value %ws",CustomFormName));
                   goto CleanUp;
                }

                StringCchCat(CustomFormName, CUSTOM_NAME_LEN, CustomPad);

                if(RegSetValueExW(hFormsKey,CustomFormName, 0, REG_BINARY,
                               (LPBYTE)FormData,
                               cbFormData)!=ERROR_SUCCESS)
                {
                   DBGMSG( DBG_WARN, ("UpgradeForms Could not set value %s",CustomFormName));
                   goto CleanUp;
                }
                cForm = -1;
                break;
            }
        }
    }
CleanUp:
    RegCloseKey(hFormsKey);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\ssp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    ssp.cxx

Abstract:

    This file wraps around wintrust functions.

Author:

    Larry Zhu   (LZhu)             6-Apr-2001  Created.

Environment:

    User Mode -Win32

Revision History:

    Robert Orleth (ROrleth)        7-Apr-2001 Contributed the following APIs:

         AddCatalogDirect

--*/

#include "precomp.h"
#pragma hdrstop

#include "ssp.hxx"

TSSP::
TSSP(
    VOID
    ) : m_hLibrary(NULL),
        m_pfnCryptCATAdminAcquireContext(NULL),
        m_pfnCryptCATAdminAddCatalog(NULL),
        m_pfnCryptCATAdminReleaseCatalogContext(NULL),
        m_pfnCryptCATAdminReleaseContext(NULL),
        m_pfnWinVerifyTrust(NULL),
        m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSSP::
~TSSP(
    VOID
    )
{
    if (m_hLibrary)
    {
        (void)FreeLibrary(m_hLibrary);
    }
}

HRESULT
TSSP::
IsValid(
    VOID
    ) const
{
    return m_hr;
}

/*++

Routine Name:

    AddCatalogDirect

Routine Description:

    This routine installs a catalog file, this routine must run with Admin
    privilege.

Arguments:

    pszCatalogFullPath  - Supplies the fully-qualified win32 path of the
                          catalog to be installed on the system
    pszCatNameOnSystem -  Catalog name used under CatRoot

Return Value:

    An HRESULT

--*/
HRESULT
TSSP::
AddCatalogDirect(
    IN    PCWSTR       pszCatalogFullPath,
    IN    PCWSTR       pszCatNameOnSystem     OPTIONAL
    )
{
    HRESULT   hRetval     = E_FAIL;
    GUID      guidDriver  = DRIVER_ACTION_VERIFY;
    HCATINFO  hCatInfo    = NULL;
    HCATADMIN hCatAdmin   = NULL;

    hRetval = pszCatalogFullPath ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = m_pfnCryptCATAdminAcquireContext(&hCatAdmin, &guidDriver, 0) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    if (SUCCEEDED(hRetval))
    {
        hCatInfo = m_pfnCryptCATAdminAddCatalog(hCatAdmin,
                                                const_cast<PWSTR>(pszCatalogFullPath),
                                                const_cast<PWSTR>(pszCatNameOnSystem),
                                                0);
        hRetval = hCatInfo ? S_OK : GetLastErrorAsHResultAndFail();
    }

    if (SUCCEEDED(hRetval))
    {
        (void)m_pfnCryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    if (hCatAdmin)
    {
        (void)m_pfnCryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return hRetval;
}

/*++

Routine Name:

    VerifyCatalog

Routine Description:

    This routine verifies a single catalog file. A catalog file is
    "self-verifying" in that there is no additional file or data required
    to verify it.

Arguments:

    pszCatalogFullPath - Supplies the fully-qualified Win32 path of the catalog
                         file to be verified

Return Value:

    An HRESULT

--*/
HRESULT
TSSP::
VerifyCatalog(
    IN     PCWSTR      pszCatalogFullPath
    )
{
    HRESULT            hRetval          = E_FAIL;
    GUID               DriverVerifyGuid = DRIVER_ACTION_VERIFY;
    WINTRUST_DATA      WintrustData     = {0};
    WINTRUST_FILE_INFO WintrustFileInfo = {0};

    hRetval = pszCatalogFullPath ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        WintrustFileInfo.cbStruct        = sizeof(WINTRUST_FILE_INFO);
        WintrustFileInfo.pcwszFilePath   = pszCatalogFullPath;

        WintrustData.cbStruct            = sizeof(WINTRUST_DATA);
        WintrustData.dwUIChoice          = WTD_UI_NONE;
        WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
        WintrustData.dwUnionChoice       = WTD_CHOICE_FILE;
        WintrustData.pFile               = &WintrustFileInfo;
        WintrustData.dwProvFlags         = WTD_REVOCATION_CHECK_NONE;

        //
        // WinVerifyTrust uses INVALID_HANDLE_VALUE as hwnd handle for
        // non-interactive operations. Do NOT pass a NULL as hwnd, since that
        // will cause the trust provider to interact with users using the
        // interactive desktop! Refer to SDK for details
        //
        hRetval = m_pfnWinVerifyTrust(INVALID_HANDLE_VALUE, &DriverVerifyGuid, &WintrustData);
    }

    return hRetval;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Load the wintrust library and get the addresses of ssp functions.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
TSSP::
Initialize(
    VOID
    )
{
    HRESULT hRetval = E_FAIL;

    m_hLibrary = LoadLibrary(L"wintrust.dll");

    hRetval = m_hLibrary ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminAcquireContext = reinterpret_cast<PFuncCryptCATAdminAcquireContext>(GetProcAddress(m_hLibrary, "CryptCATAdminAcquireContext"));

        hRetval = m_pfnCryptCATAdminAddCatalog ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminAddCatalog = reinterpret_cast<PFuncCryptCATAdminAddCatalog>(GetProcAddress(m_hLibrary, "CryptCATAdminAddCatalog"));

        hRetval = m_pfnCryptCATAdminAddCatalog ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminReleaseContext = reinterpret_cast<PFuncCryptCATAdminReleaseContext>(GetProcAddress(m_hLibrary, "CryptCATAdminReleaseContext"));

        hRetval = m_pfnCryptCATAdminReleaseContext ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnCryptCATAdminReleaseCatalogContext = reinterpret_cast<PFuncCryptCATAdminReleaseCatalogContext>(GetProcAddress(m_hLibrary, "CryptCATAdminReleaseCatalogContext"));

        hRetval = m_pfnCryptCATAdminReleaseCatalogContext ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        m_pfnWinVerifyTrust = reinterpret_cast<PFuncWinVerifyTrust>(GetProcAddress(m_hLibrary, "WinVerifyTrust"));

        hRetval = m_pfnWinVerifyTrust ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\util.c ===
/*++


Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Added utility functions for cluster spoolers. Part of the DCR regarding
    installation of printer drivers on cluster spoolers

    Muhunthan Sivapragasam ( MuhuntS ) 5-June-1995
        Moved from printer.c:
            RegSetBinaryData
            RegSetString
            RegSetDWord

        Wrote:
            SameMultiSz
            RegGetValue

    Matthew A Felton ( MattFe ) 23-mar-1995
        DeleteAllFilesAndDirectory
        DeleteAllFilesInDirectory
        CreateDirectoryWithoutImpersonatingUser


--*/

#include <precomp.h>
#pragma hdrstop

#include <winddiui.h>
#include <lm.h>
#include <aclapi.h>
#include <winsta.h>
#include "clusspl.h"


typedef LONG (WINAPI *pfnWinStationSendWindowMessage)(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,
        ULONG   Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse);

extern  BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern  BOOL (*pfnClosePrinter)(HANDLE);
extern  LONG (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

#define DEFAULT_MAX_TIMEOUT      300000 // 5 minute timeout.

CRITICAL_SECTION SpoolerSection;
PDBG_POINTERS gpDbgPointers = NULL;
pfnWinStationSendWindowMessage pfWinStationSendWindowMessage = NULL;

VOID
RunForEachSpooler(
    HANDLE h,
    PFNSPOOLER_MAP pfnMap
    )
{
    PINISPOOLER pIniSpooler;
    PINISPOOLER pIniNextSpooler;

    SplInSem();

    if( pLocalIniSpooler ){

        INCSPOOLERREF( pLocalIniSpooler );

        for( pIniSpooler = pLocalIniSpooler; pIniSpooler; pIniSpooler = pIniNextSpooler ){

            if( (*pfnMap)( h, pIniSpooler ) ){
                pIniNextSpooler = pIniSpooler->pIniNextSpooler;
            } else {
                pIniNextSpooler = NULL;
            }

            if( pIniNextSpooler ){

                INCSPOOLERREF( pIniNextSpooler );
            }
            DECSPOOLERREF( pIniSpooler );
        }
    }
}

VOID
RunForEachPrinter(
    PINISPOOLER pIniSpooler,
    HANDLE h,
    PFNPRINTER_MAP pfnMap
    )
{
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniNextPrinter;

    SplInSem();

    pIniPrinter = pIniSpooler->pIniPrinter;

    if( pIniPrinter ){

        INCPRINTERREF( pIniPrinter );

        for( ; pIniPrinter; pIniPrinter = pIniNextPrinter ){

            if( (*pfnMap)( h, pIniPrinter ) ){
                pIniNextPrinter = pIniPrinter->pNext;
            } else {
                pIniNextPrinter = NULL;
            }

            if( pIniNextPrinter ){

                INCPRINTERREF( pIniNextPrinter );
            }

            DECPRINTERREF( pIniPrinter );
            DeletePrinterCheck( pIniPrinter );
        }
    }
}

#if DBG
HANDLE hcsSpoolerSection = NULL;

VOID
SplInSem(
    VOID
    )
{
    if( hcsSpoolerSection ){

        SPLASSERT( gpDbgPointers->pfnInsideCritSec( hcsSpoolerSection ));

    } else {

        SPLASSERT( SpoolerSection.OwningThread == (HANDLE)(ULONG_PTR)(GetCurrentThreadId( )));
    }
}

VOID
SplOutSem(
    VOID
    )
{
    if( hcsSpoolerSection ){

        SPLASSERT( gpDbgPointers->pfnOutsideCritSec( hcsSpoolerSection ));

    } else {

        SPLASSERT( SpoolerSection.OwningThread != (HANDLE)((ULONG_PTR)GetCurrentThreadId( )));
    }
}

#endif // DBG

VOID
EnterSplSem(
    VOID
    )
{
#if DBG
    if( hcsSpoolerSection ){

        gpDbgPointers->pfnEnterCritSec( hcsSpoolerSection );

    } else {

        EnterCriticalSection( &SpoolerSection );
    }
#else
    EnterCriticalSection( &SpoolerSection );
#endif
}

VOID
LeaveSplSem(
    VOID
    )
{
#if DBG
    if( hcsSpoolerSection ){

        gpDbgPointers->pfnLeaveCritSec( hcsSpoolerSection );

    } else {

        LeaveCriticalSection( &SpoolerSection );
    }
#else
    LeaveCriticalSection( &SpoolerSection );

#endif
}

BOOL
IsThreadInSem(
    DWORD ThreadID
    )
{
    BOOL bInSem = FALSE;

#if DBG

    if (hcsSpoolerSection)
    {
        bInSem = gpDbgPointers->pfnInsideCritSec(hcsSpoolerSection);
    }
    else
    {
        bInSem = SpoolerSection.OwningThread == (HANDLE)(ULONG_PTR)ThreadID;
    }
#else

    bInSem = SpoolerSection.OwningThread == (HANDLE)(ULONG_PTR)ThreadID;

#endif

    return bInSem;
}


PDEVMODE
AllocDevMode(
    PDEVMODE pDevMode
    )
{
    PDEVMODE pDevModeAlloc = NULL;
    DWORD    Size;

    if (pDevMode) {

        Size = pDevMode->dmSize + pDevMode->dmDriverExtra;

        if(pDevModeAlloc = AllocSplMem(Size)) {

            memcpy(pDevModeAlloc, pDevMode, Size);
        }
    }

    return pDevModeAlloc;
}

BOOL
FreeDevMode(
    PDEVMODE pDevMode
    )
{
    if (pDevMode) {

        FreeSplMem((PVOID)pDevMode);
        return TRUE;

    } else {
        return  FALSE;
    }
}

PINIENTRY
FindName(
   PINIENTRY pIniKey,
   LPWSTR pName
)
{
   if (pName) {
      while (pIniKey) {

         if (!lstrcmpi(pIniKey->pName, pName)) {
            return pIniKey;
         }

      pIniKey=pIniKey->pNext;
      }
   }

   return FALSE;
}


BOOL
FileExists(
    LPWSTR pFileName
    )
{
    if( GetFileAttributes( pFileName ) == 0xffffffff ){
        return FALSE;
    }
    return TRUE;
}



BOOL
DirectoryExists(
    LPWSTR  pDirectoryName
    )
{
    DWORD   dwFileAttributes;

    dwFileAttributes = GetFileAttributes( pDirectoryName );

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

        return TRUE;
    }

    return FALSE;
}



BOOL
CheckSepFile(
   IN LPWSTR pFileName
   )
{
    BOOL bRetval = FALSE;

    //
    // NULL or "" is OK:
    //
    if (!pFileName || !*pFileName)
    {
        bRetval = TRUE;
    }
    else
    {
        //
        // If the name is not NULL or "" then the name must be less
        // than MAX_PATH and exist.
        //
        if ((wcslen(pFileName) < MAX_PATH-1) && FileExists(pFileName))
        {
            bRetval = TRUE;
        }
    }

    return bRetval;
}


DWORD
GetFullNameFromId(
    IN      PINIPRINTER     pIniPrinter,
    IN      DWORD           JobId,
    IN      BOOL            fJob,
    IN      PWSTR           pFileName,
    IN      SIZE_T          cchFileName,
    IN      BOOL            Remote
   )
{
   DWORD i;

   //
   // We don't have a decent return path from this error function. Make sure
   // that all callers use a buffer size at least bigger than 9.
   //
   SPLASSERT(cchFileName > 9);

   //
   // MAX_PATH - 9 is tha maximum number of chars that we want to store in pFileName since we
   // want to concatenate the SPL/SHD file
   // If GetPrinterDirectory fails i is 0.
   // The right way to fix this is that the caller of GetFullNameFromId chackes for the return value
   // which is not the case.
   //
   i = GetPrinterDirectory(pIniPrinter, Remote, pFileName, (DWORD)(cchFileName-9), pIniPrinter->pIniSpooler);

   StringCchPrintf(&pFileName[i], cchFileName - i, L"\\%05d.%ws", JobId, fJob ? L"SPL" : L"SHD");

#ifdef PREVIOUS
   for (i = 5; i--;) {
      pFileName[i++] = (CHAR)((JobId % 10) + '0');
      JobId /= 10;
   }
#endif

   while (pFileName[i++])
      ;

   return i-1;
}

DWORD
GetPrinterDirectory(
   PINIPRINTER pIniPrinter,         // Can be NULL
   BOOL Remote,
   LPWSTR pDir,
   DWORD MaxLength,
   PINISPOOLER pIniSpooler
)
{
   DWORD i=0;
   LPWSTR psz;

   if (Remote) {

       DBGMSG(DBG_ERROR, ("GetPrinterDirectory called remotely.  Not currently supported."));
       return 0;

   }

   if ((pIniPrinter == NULL) || (pIniPrinter->pSpoolDir == NULL) ) {

        if (pIniSpooler->pDefaultSpoolDir == NULL) {

            //
            // No default directory, then create a default. For cluster spoolers,
            // the default directory is N:\Spool, where N is the shared drive letter
            //
            if( StrNCatBuff(pDir,
                            MaxLength,
                            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ? pIniSpooler->pszClusResDriveLetter :
                                                                           pIniSpooler->pDir,
                            L"\\",
                            pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ? szClusterPrinterDir : szPrinterDir,
                            NULL) != ERROR_SUCCESS ) {
                return 0;
            }

            pIniSpooler->pDefaultSpoolDir = AllocSplStr(pDir);

        } else {
            //
            // Give Caller the Default
            //
            if (!BoolFromHResult(StringCchCopy(pDir, MaxLength, pIniSpooler->pDefaultSpoolDir))) {
                return 0;
            }
        }

   } else {

       //
       // Have Per Printer Directory
       //
       if (!BoolFromHResult(StringCchCopy(pDir, MaxLength, pIniPrinter->pSpoolDir))) {
           return 0;
       }
   }
   return (wcslen(pDir));
}



DWORD
GetDriverDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR   lpRemotePath,
    PINISPOOLER pIniSpooler
)
{
   LPWSTR psz;

   if (lpRemotePath) {

       if( StrNCatBuff(pDir,
                        MaxLength,
                        lpRemotePath,
                        L"\\",
                        pIniSpooler->pszDriversShare,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }


   } else {

       if( StrNCatBuff( pDir,
                        MaxLength,
                        pIniSpooler->pDir,
                        L"\\",
                        szDriverDir,
                        L"\\",
                        pIniEnvironment->pDirectory,
                        NULL) != ERROR_SUCCESS ) {
            return 0;
        }
   }

   return wcslen(pDir);
}



DWORD
GetProcessorDirectory(
    LPWSTR   *pDir,
    LPWSTR   pEnvironment,
    PINISPOOLER pIniSpooler
)
{
    return StrCatAlloc(pDir,
                       pIniSpooler->pDir,
                       L"\\",
                       szPrintProcDir,
                       L"\\",
                       pEnvironment,
                       NULL);
}



PINIENTRY
FindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR pName
)
{
   if ( pName == NULL ) {
      return NULL;
   }

   SplInSem();

   while ( pIniEntry && lstrcmpi( pName, pIniEntry->pName ))
      pIniEntry = pIniEntry->pNext;

   return pIniEntry;
}


BOOL
CreateCompleteDirectory(
    LPWSTR pDir
)
{
    LPWSTR pBackSlash=pDir;

    do {
        pBackSlash = wcschr( pBackSlash, L'\\' );

        if ( pBackSlash != NULL )
            *pBackSlash = 0;

        CreateDirectory(pDir, NULL);

        if ( pBackSlash )
            *pBackSlash++=L'\\';

   } while ( pBackSlash );

    // BUBUG Always returns TRUE

   return TRUE;
}




LPCWSTR
FindFileName(
    LPCWSTR pPathName
    )

/*++

Routine Description:

    Retrieve the filename portion of a path.

    This will can the input string until it finds the last backslash,
    then return the portion of the string immediately following it.
    If the string terminates with a backslash, then NULL is returned.

    Note: this can return illegal file names; no validation is done.

Arguments:

    pPathName - Path name to parse.

Return Value:

    Last portion of file name or NULL if none available.

--*/

{
    LPCWSTR pSlash;
    LPCWSTR pTemp;

    if( !pPathName ){
       return NULL;
    }

    pTemp = pPathName;
    while( pSlash = wcschr( pTemp, L'\\' )) {
        pTemp = pSlash+1;
    }

    if( !*pTemp ){
       return NULL;
    }

    return pTemp;
}


VOID
CreatePrintProcDirectory(
   LPWSTR pEnvironment,
   PINISPOOLER pIniSpooler
)
{
    SIZE_T cb;
    LPWSTR pEnd;
    LPWSTR pPathName;

    cb = wcslen(pIniSpooler->pDir)*sizeof(WCHAR) +
         wcslen(pEnvironment)*sizeof(WCHAR) +
         wcslen(szPrintProcDir)*sizeof(WCHAR) +
         4*sizeof(WCHAR);

    if (pPathName=AllocSplMem((DWORD)(cb))) {

        StringCbCopyEx(pPathName, cb, pIniSpooler->pDir, &pEnd, &cb, 0);

        if(CreateDirectory(pPathName, NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {

            StringCbCopyEx(pEnd, cb, L"\\", &pEnd, &cb, 0);
            StringCbCopyEx(pEnd, cb, szPrintProcDir, &pEnd, &cb, 0);

            if(CreateDirectory(pPathName, NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {

                StringCbCopyEx(pEnd, cb, L"\\", &pEnd, &cb, 0);
                StringCbCopyEx(pEnd, cb, pEnvironment, &pEnd, &cb, 0);

                if (CreateDirectory(pPathName, NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {
                }
            }
        }

        FreeSplMem(pPathName);
    }
}

BOOL
RemoveFromList(
   PINIENTRY   *ppIniHead,
   PINIENTRY   pIniEntry
)
{
   while (*ppIniHead && *ppIniHead != pIniEntry) {
      ppIniHead = &(*ppIniHead)->pNext;
   }

   if (*ppIniHead)
      *ppIniHead = (*ppIniHead)->pNext;

   return(TRUE);
}

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) + wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR));

    //
    // Then copy the key data buffer there:
    //
    StringCbCopy(pDest, cb - ((BYTE *)pDest - (BYTE *)pResult), pKeyData);

    ppToken = pResult->pTokens;

    psz = pDest;

    do {

        *ppToken++ = psz;

        if ( psz = wcschr(psz, L',') )
            *psz++ = L'\0';

    } while (psz);

    pResult->cTokens = cTokens;

    return( pResult );
}

VOID
FreePortTokenList(
    PKEYDATA    pKeyData
    )
{
    PINIPORT    pIniPort;
    DWORD       i;

    if ( pKeyData ) {

        if ( pKeyData->bFixPortRef ) {

            for ( i = 0 ; i < pKeyData->cTokens ; ++i ) {

                pIniPort = (PINIPORT)pKeyData->pTokens[i];
                DECPORTREF(pIniPort);
            }
        }
        FreeSplMem(pKeyData);
    }
}

VOID
GetPrinterPorts(
    PINIPRINTER pIniPrinter,
    LPWSTR      pszPorts,
    DWORD       *pcbNeeded
)
{
    PINIPORT    pIniPort;
    BOOL        Comma;
    DWORD       i;
    DWORD       cbNeeded = 0;
    DWORD       cbAvailable = 0;

    SPLASSERT(pcbNeeded);

    cbAvailable = *pcbNeeded;

    // Determine required size
    Comma = FALSE;
    for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

        pIniPort = pIniPrinter->ppIniPorts[i];

        if ( pIniPort->Status & PP_FILE )
            continue;

        if ( Comma )
            cbNeeded += wcslen(szComma)*sizeof(WCHAR);

        cbNeeded += wcslen(pIniPort->pName)*sizeof(WCHAR);
        Comma = TRUE;
    }

    //
    // Add in size of NULL
    //
    cbNeeded += sizeof(WCHAR);


    if (pszPorts && cbNeeded <= cbAvailable) {

        //
        // If we are given a buffer & buffer is big enough, then fill it
        //
        Comma = FALSE;
        for ( i = 0 ; i < pIniPrinter->cPorts ; ++i ) {

            pIniPort = pIniPrinter->ppIniPorts[i];

            if ( pIniPort->Status & PP_FILE )
                continue;

            if ( Comma ) {

                StringCbCat(pszPorts, cbAvailable, szComma);
                StringCbCat(pszPorts, cbAvailable, pIniPort->pName);
            } else {

                StringCbCopy(pszPorts, cbAvailable, pIniPort->pName);
            }

            Comma = TRUE;
        }
    }

    *pcbNeeded = cbNeeded;
}

BOOL
MyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
)
{
    EnterSplSem();

    if (CheckMyName(pName, pIniSpooler))
    {
        LeaveSplSem();
        return TRUE;
    }

    SetLastError(ERROR_INVALID_NAME);

    LeaveSplSem();
    return FALSE;
}

BOOL
CheckMyName(
    LPWSTR   pName,
    PINISPOOLER pIniSpooler
)
{
    DWORD   dwIndex = 0;

    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\') {

        if (!lstrcmpi(pName, pIniSpooler->pMachineName))
        {
            return TRUE;
        }

        if (pIniSpooler->pszFullMachineName && !lstrcmpi(pName + 2, pIniSpooler->pszFullMachineName))
        {
            return TRUE;
        }

        return CacheIsNameInNodeList(pIniSpooler->pMachineName + 2, pName + 2) == S_OK;

    }
    return FALSE;
}

BOOL
GetSid(
    PHANDLE phToken
)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         phToken)) {

        DBGMSG(DBG_WARNING, ("OpenThreadToken failed: %d\n", GetLastError()));
        return FALSE;

    } else

        return TRUE;
}

BOOL
SetCurrentSid(
    HANDLE  hToken
)
{
#if DBG
    WCHAR UserName[256];
    DWORD cbUserName=256;

    if( MODULE_DEBUG & DBG_TRACE )
        GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid BEFORE: user name is %ws\n", UserName));
#endif

    //
    // Normally the function SetCurrentSid is not supposed to change the last error
    // of the routine where it is called. NtSetInformationThread conveniently returns
    // a status and does not touch the last error.
    //

    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                           &hToken, sizeof(hToken));

#if DBG
    cbUserName = 256;

    if( MODULE_DEBUG & DBG_TRACE )
        GetUserName(UserName, &cbUserName);

    DBGMSG(DBG_TRACE, ("SetCurrentSid AFTER: user name is %ws\n", UserName));
#endif

    return TRUE;
}

LPWSTR
GetErrorString(
    DWORD   Error
)
{
    WCHAR   Buffer1[512];
    LPWSTR  pErrorString=NULL;
    DWORD   dwFlags;
    HANDLE  hModule = NULL;

    if ((Error >= NERR_BASE) && (Error <= MAX_NERR)) {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
        hModule = LoadLibrary(szNetMsgDll);

    } else {
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;
        hModule = NULL;
    }

    //
    // Only display out of paper and device disconnected errors.
    //
    if ((Error == ERROR_NOT_READY ||
         Error == ERROR_OUT_OF_PAPER ||
         Error == ERROR_DEVICE_REINITIALIZATION_NEEDED ||
         Error == ERROR_DEVICE_REQUIRES_CLEANING ||
         Error == ERROR_DEVICE_DOOR_OPEN ||
         Error == ERROR_DEVICE_NOT_CONNECTED) &&

        FormatMessage(dwFlags,
                      hModule,
                      Error,
                      0,
                      Buffer1,
                      COUNTOF(Buffer1),
                      NULL)) {

       EnterSplSem();
        pErrorString = AllocSplStr(Buffer1);
       LeaveSplSem();
    }

    if (hModule) {
        FreeLibrary(hModule);
    }

    return pErrorString;
}

#define NULL_TERMINATED 0



INT
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
/*++

Routine Description:

    Converts an Ansi String to a UnicodeString

Arguments:

    pAnsi - A valid source ANSI string.

    pUnicode - A pointer to a buffer large enough to accommodate
               the converted string.

    StringLength - The length of the source ANSI string.
                   If 0 (NULL_TERMINATED), the string is assumed to be
                   null-terminated.


Return Value:

    The return value from MultiByteToWideChar, the number of
    wide characters returned.

--*/
{
    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    return MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                pAnsi,
                                StringLength + 1,
                                pUnicode,
                                StringLength + 1 );
}

INT
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID, ...)
{
/*++

Routine Description:

    Displays a message by loading the strings whose IDs are passed into
    the function, and substituting the supplied variable argument list
    using the varargs macros.

Arguments:

    hwnd        Window Handle
    Type
    CaptionID
    TextId


Return Value:

--*/

    WCHAR   MsgText[512];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        StringCchVPrintf(MsgText, COUNTOF(MsgText), MsgFormat, vargs );
        va_end( vargs );

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}

typedef struct {
    DWORD   Message;
    WPARAM  wParam;
    LPARAM  lParam;
} MESSAGE, *PMESSAGE;

//  The Broadcasts are done on a separate thread, the reason it CSRSS
//  will create a server side thread when we call user and we don't want
//  that to be paired up with the RPC thread which is in the spooss server.
//  We want it to go away the moment we have completed the SendMessage.
//  We also call SendNotifyMessage since we don't care if the broadcasts
//  are syncronous this uses less resources since usually we don't have more
//  than one broadcast.

//
// TESTING
//
DWORD dwSendFormMessage = 0;

VOID
SplBroadcastChange(
    HANDLE  hPrinter,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINISPOOLER pIniSpooler;

    if (ValidateSpoolHandle( pSpool, 0 )) {

        pIniSpooler = pSpool->pIniSpooler;
        BroadcastChange(pIniSpooler, Message, wParam, lParam);
    }
}


VOID
BroadcastChange(
    IN PINISPOOLER  pIniSpooler,
    IN DWORD        Message,
    IN WPARAM       wParam,
    IN LPARAM       lParam
    )
{
    if (( pIniSpooler != NULL ) && ( pIniSpooler->SpoolerFlags & SPL_BROADCAST_CHANGE )) {

        BOOL bIsTerminalServerInstalled = (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));

        //
        // Currently we cannot determine if the TermService process is running, so at the momemt
        // we assume it is always running.
        //
        BOOL bIsTerminalServerRunning = TRUE;

        //
        // If terminal server is installed and enabled then load the winsta.dll if not already
        // loaded and get the send window message function.
        //
        if ( bIsTerminalServerInstalled && !pfWinStationSendWindowMessage ) {

            //
            // The winstadllhandle is shared among other files in the spooler, so don't
            // load the dll again if it is already loaded.  Note: we are not in a critical
            // section because winsta.dll is never unload, hence if there are two threads
            // that execute this code at the same time we may potenially load the library
            // twice.
            //
            if ( !WinStaDllHandle ) {

                UINT uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                WinStaDllHandle = LoadLibrary(L"winsta.dll");

                SetErrorMode(uOldErrorMode);
            }

            if ( WinStaDllHandle ) {

                pfWinStationSendWindowMessage = (pfnWinStationSendWindowMessage)GetProcAddress( WinStaDllHandle,
                                                                                                "WinStationSendWindowMessage" );
            }
        }

        if ( pfWinStationSendWindowMessage ) {

            //
            // Only send the message to the session that orginated
            // the call, this will go to the console session when a
            // change is made by a remote client.
            //
            LONG Response = 0;
            LONG lRetval  = FALSE;
            HANDLE hToken = NULL;
            ULONG uSession= 0;

            if (GetClientSessionData(&uSession)) {

                //
                // It appears the WinStationSendWindowMessage function has to
                // be in system context if the impersonating user is not an
                // an admin on the machine.
                //
                hToken = RevertToPrinterSelf();

                lRetval = pfWinStationSendWindowMessage( SERVERNAME_CURRENT,
                                                         uSession,
                                                         1,                    // Wait at most one second
                                                         HandleToULong(HWND_BROADCAST),
                                                         Message,
                                                         wParam,
                                                         lParam,
                                                         &Response );

                ImpersonatePrinterClient(hToken);
            }
        }

        //
        // We send the message normally if we have a null pfWinstationSendWindowMessage
        // function or if terminal server is not running.
        //
        if ( !pfWinStationSendWindowMessage || !bIsTerminalServerRunning ){

            SendNotifyMessage( HWND_BROADCAST,
                               Message,
                               wParam,
                               lParam );

        }

    } else {

        DBGMSG(DBG_TRACE, ("BroadCastChange Ignoring Change\n"));
    }
}


VOID
MyMessageBeep(
    DWORD   fuType,
    PINISPOOLER pIniSpooler
    )
{
    if ( pIniSpooler->dwBeepEnabled != 0 ) {
        MessageBeep(fuType);
    }
}


// Recursively delete any subkeys of a given key.
// Assumes that RevertToPrinterSelf() has been called.

DWORD
DeleteSubkeys(
    HKEY hKey,
    PINISPOOLER pIniSpooler
    )
{
    DWORD   cchData;
    WCHAR   SubkeyName[MAX_PATH];
    HKEY    hSubkey;
    LONG    Status;

    cchData = COUNTOF( SubkeyName );

    while ((Status = SplRegEnumKey( hKey,
                                    0,
                                    SubkeyName,
                                    &cchData,
                                    NULL,
                                    pIniSpooler )) == ERROR_SUCCESS ) {

        Status = SplRegCreateKey( hKey,
                                  SubkeyName,
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  &hSubkey,
                                  NULL,
                                  pIniSpooler );

        if( Status == ERROR_SUCCESS ) {

            Status = DeleteSubkeys( hSubkey, pIniSpooler );

            SplRegCloseKey( hSubkey, pIniSpooler);

            if( Status == ERROR_SUCCESS )
                SplRegDeleteKey( hKey, SubkeyName, pIniSpooler );
        }

        //
        // N.B. Don't increment since we've deleted the zeroth item.
        //
        cchData = COUNTOF( SubkeyName );
    }

    if( Status == ERROR_NO_MORE_ITEMS )
        Status = ERROR_SUCCESS;

    return Status;
}




long Myatol(LPWSTR nptr)
{
    int c;                                  // current char
    long total;                             // current total
    int sign;                               // if '-', then negative, otherwise positive

    // skip whitespace

    while (isspace(*nptr))
        ++nptr;

    c = *nptr++;
    sign = c;                               // save sign indication
    if (c == '-' || c == '+')
        c = *nptr++;                        // skip sign

    total = 0;

    while (isdigit(c)) {
        total = 10 * total + (c - '0');     // accumulate digit
        c = *nptr++;                        // get next char
    }

    if (sign == '-')
        return -total;
    else
        return total;                       // return result, negated if necessary
}


ULONG_PTR
atox(
   LPCWSTR psz
   )

/*++

Routine Description:

    Converts a string to a hex value, skipping any leading
    white space.  Cannot be uppercase, cannot contain leading 0x.

Arguments:

    psz - pointer to hex string that needs to be converted.  This string
        can have leading characters, but MUST be lowercase.

Return Value:

    DWORD value.

--*/

{
    ULONG_PTR Value = 0;
    ULONG_PTR Add;

    _wcslwr((LPWSTR)psz);

    while( isspace( *psz )){
        ++psz;
    }

    for( ;; ++psz ){

        if( *psz >= TEXT( '0' ) && *psz <= TEXT( '9' )){
            Add = *psz - TEXT( '0' );
        } else if( *psz >= TEXT( 'a' ) && *psz <= TEXT( 'f' )){
            Add = *psz - TEXT( 'a' ) + 0xa;
        } else {
            break;
        }

        Value *= 0x10;
        Value += Add;
    }

    return Value;
}


BOOL
ValidateSpoolHandle(
    PSPOOL pSpool,
    DWORD  dwDisallowMask
    )
{
    BOOL    ReturnValue;
    try {

        //
        // Zombied handles should return back error.  The client
        // side will see ERROR_INVALID_HANDLE, close it and revalidate.
        //
        if (( pSpool == NULL ) ||
            ( pSpool == INVALID_HANDLE_VALUE ) ||
            ( pSpool->Status & SPOOL_STATUS_ZOMBIE ) ||
            ( pSpool->signature != SJ_SIGNATURE ) ||
            ( pSpool->TypeofHandle & dwDisallowMask ) ||
            ( pSpool->TypeofHandle & PRINTER_HANDLE_XCV_PORT ) ||
            ( pSpool->pIniSpooler->signature != ISP_SIGNATURE ) ||

            ( ( pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER ) &&
              ( pSpool->pIniPrinter->signature !=IP_SIGNATURE ) )) {

                ReturnValue = FALSE;

        } else {

                ReturnValue = TRUE;

        }


    }except (1) {

        ReturnValue = FALSE;

    }

    if ( !ReturnValue )
        SetLastError( ERROR_INVALID_HANDLE );

    return ReturnValue;

}


BOOL
UpdateString(
    LPWSTR* ppszCur,
    LPWSTR pszNew)
{
    //
    // !! LATER !!
    //
    // Replace with non-nls wcscmp since we want byte comparison and
    // only care if the strings are different (ignore ordering).
    //
    if ((!*ppszCur || !**ppszCur) && (!pszNew || !*pszNew))
        return FALSE;

    if (!*ppszCur || !pszNew || wcscmp(*ppszCur, pszNew)) {

        ReallocSplStr(ppszCur, pszNew);
        return TRUE;
    }
    return FALSE;
}




BOOL
CreateDirectoryWithoutImpersonatingUser(
    LPWSTR pDirectory
    )
/*++

Routine Description:

    This routine stops impersonating the user and creates a directory

Arguments:

    pDirectory - Fully Qualified path of directory.


Return Value:

    TRUE    - Success
    FALSE   - failed ( call GetLastError )

--*/
{
    HANDLE  hToken      = INVALID_HANDLE_VALUE;
    BOOL    bReturnValue;

    SPLASSERT( pDirectory != NULL );

    hToken = RevertToPrinterSelf();

    bReturnValue = CreateDirectory(pDirectory, NULL);

    if ( bReturnValue == FALSE ) {

        DBGMSG( DBG_WARNING, ("CreateDirectoryWithoutImpersonatingUser failed CreateDirectory %ws error %d\n", pDirectory, GetLastError() ));
    }

    if ( hToken != INVALID_HANDLE_VALUE ) {
        ImpersonatePrinterClient(hToken);
    }

    return bReturnValue;
}




BOOL
DeleteAllFilesInDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
)
/*++

Routine Description:

    Deletes all files the specified directory
    If it can't be deleted it gets marked for deletion on next reboot.


Arguments:

    pDirectory  - Fully Qualified path of directory.
    bWaitForReboot - Don't delete the files until a reboot


Return Value:

    TRUE    - Success
    FALSE   - failed something major, like allocating memory.

--*/

{
    BOOL    bReturnValue = FALSE;
    HANDLE  hFindFile;
    WIN32_FIND_DATA     FindData;
    WCHAR   ScratchBuffer[ MAX_PATH ];


    DBGMSG( DBG_TRACE, ("DeleteAllFilesInDirectory: bWaitForReboot = %\n", bWaitForReboot ));

    SPLASSERT( pDirectory != NULL );

    if (StrNCatBuff(ScratchBuffer, COUNTOF(ScratchBuffer), pDirectory, L"\\*", NULL) != ERROR_SUCCESS)
        return FALSE;

    hFindFile = FindFirstFile( ScratchBuffer, &FindData );

    if ( hFindFile != INVALID_HANDLE_VALUE ) {

        do {

            //
            //  Don't Attempt to Delete Directories
            //

            if ( !( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ) {

                //
                //  Fully Qualified Path
                //

                if (StrNCatBuff(   ScratchBuffer,
                                    COUNTOF(ScratchBuffer),
                                    pDirectory,
                                    L"\\",
                                    FindData.cFileName,
                                    NULL) == ERROR_SUCCESS) {

                    if ( bWaitForReboot || !DeleteFile( ScratchBuffer ) ) {

                        DBGMSG( DBG_WARNING, ("DeleteAllFilesInDirectory failed DeleteFile( %ws ) error %d\n", ScratchBuffer, GetLastError() ));

                        if (!MoveFileEx( ScratchBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {

                            DBGMSG( DBG_WARNING, ("DeleteAllFilesInDirectory failed MoveFileEx %ws error %d\n", ScratchBuffer, GetLastError() ));

                        } else {

                            DBGMSG( DBG_TRACE, ("MoveFileEx %ws Delay until reboot OK\n", ScratchBuffer ));
                        }


                    } else {

                        DBGMSG( DBG_TRACE, ("Deleted %ws OK\n", ScratchBuffer ));
                    }
                }
            }


        } while( FindNextFile( hFindFile, &FindData ) );

        bReturnValue = FindClose( hFindFile );


    } else {

        DBGMSG( DBG_WARNING, ("DeleteOldDrivers failed findfirst ( %ws ), error %d\n", ScratchBuffer, GetLastError() ));
    }

    return  bReturnValue;

}

BOOL
DeleteAllFilesAndDirectory(
    LPWSTR pDirectory,
    BOOL   bWaitForReboot
)
/*++

Routine Description:

    Deletes all files the specified directory, then deletes the directory.
    If the Directory cannot be deleted right away, it is set to be deleted
    at reboot time.

    Security NOTE - This routine runs as SYSTEM, not imperonating the user


Arguments:

    pDirectory  - Fully Qualified path of directory.


Return Value:

    TRUE    - Success
    FALSE   - failed something major, like allocating memory.

--*/
{
    BOOL    bReturnValue;
    HANDLE  hToken      = INVALID_HANDLE_VALUE;

    DBGMSG( DBG_TRACE, ("DeleteAllFilesAndDirectory: bWaitForReboot = %d\n", bWaitForReboot ));

    hToken = RevertToPrinterSelf();


    if( bReturnValue = DeleteAllFilesInDirectory( pDirectory, bWaitForReboot ) ) {


        if ( bWaitForReboot || !RemoveDirectory( pDirectory )) {

            if (!SplMoveFileEx( pDirectory, NULL, MOVEFILE_DELAY_UNTIL_REBOOT )) {

                DBGMSG( DBG_WARNING, ("DeleteAllFilesAndDirectory failed to delete %ws until reboot %d\n", pDirectory, GetLastError() ));
            } else {

                DBGMSG( DBG_TRACE, ( "DeleteAllFilesAndDirectory: MoveFileEx Delay until reboot OK\n" ));
            }

        } else {

            DBGMSG( DBG_TRACE, ("DeleteAllFilesAndDirectory deleted %ws OK\n", pDirectory ));
        }
    }


    if ( hToken != INVALID_HANDLE_VALUE ) {
        ImpersonatePrinterClient(hToken);
    }

    return  bReturnValue;
}


VOID
DeleteDirectoryRecursively(
    LPCWSTR pszDirectory,
    BOOL    bWaitForReboot
)
/*++

Routine Name:

  DeleteDirectoryRecursively

Routine Description:

    Recursively Deletes the specified directory
    If it can't be deleted it gets marked for deletion on next reboot.

Arguments:

    pDirectory  - Fully Qualified path of directory.
    bWaitForReboot - Don't delete the files until a reboot

Return Value:

    Nothing.

--*/
{
    HANDLE  hFindFile;
    WIN32_FIND_DATA     FindData;
    WCHAR   ScratchBuffer[ MAX_PATH ];

    if ( pszDirectory &&
         StrNCatBuff(ScratchBuffer,
                     COUNTOF(ScratchBuffer),
                     pszDirectory,
                     L"\\*",
                     NULL) == ERROR_SUCCESS ) {

        hFindFile = FindFirstFile(ScratchBuffer, &FindData);

        if ( hFindFile != INVALID_HANDLE_VALUE ) {

            do {
                //
                // Don't delete current and parent directory.
                //
                if (wcscmp(FindData.cFileName, L".")  != 0 &&
                    wcscmp(FindData.cFileName, L"..") != 0 &&
                    StrNCatBuff( ScratchBuffer,
                                 COUNTOF(ScratchBuffer),
                                 pszDirectory,
                                 L"\\",
                                 FindData.cFileName,
                                 NULL) == ERROR_SUCCESS) {

                    if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                        if (bWaitForReboot || !DeleteFile(ScratchBuffer)) {

                            //
                            // Delete the file on reboot if asked or if deletion failed.
                            //
                            SplMoveFileEx(ScratchBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                        }

                    } else {

                        //
                        // Delete subdirectory
                        //
                        DeleteAllFilesAndDirectory(ScratchBuffer, bWaitForReboot);
                    }
                }

            } while (FindNextFile(hFindFile, &FindData));

            FindClose(hFindFile);

            if (bWaitForReboot || !RemoveDirectory(pszDirectory)) {

                //
                // Delete the directory on reboot if asked or if deletion failed.
                //
                SplMoveFileEx(pszDirectory, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }
    }

    return;
}

DWORD
CreateNumberedTempDirectory(
    IN  LPCWSTR  pszDirectory,
    OUT LPWSTR  *ppszTempDirectory
    )
/*++

Routine Name:

    CreateNumberedTempDirectory

Routine Description:

    Creates a temporary subdirectory named 1... 500
    The lenght of ppTempDirectory cannot be bigger than MAX_PATH
    Returns the number of directory created or -1 for failure

Arguments:

    pszDirectory - directory where to created temporary
    ppszTempDirectory - path of the new temporary directory

Return Value:

    If success, returns the number of directory created.
    Returns -1 if a failure occurs.
--*/
{
    DWORD   dwIndex, dwTempDir;
    WCHAR   szTempDir[4];
    WCHAR  *pszTemporary = NULL;

    dwTempDir = -1;

    if (pszDirectory && ppszTempDirectory)
    {
        *ppszTempDirectory = NULL;

        if (pszTemporary = AllocSplMem((wcslen(pszDirectory) + COUNTOF(szTempDir) + 1) * sizeof(WCHAR)))
        {
            for (dwIndex = 1; dwIndex < 500; ++dwIndex)
            {
                StringCchPrintf(szTempDir, COUNTOF(szTempDir), L"%d", dwIndex);

                if (StrNCatBuff(pszTemporary,
                                MAX_PATH,
                                pszDirectory,
                                L"\\",
                                szTempDir,
                                NULL) == ERROR_SUCCESS &&
                    !DirectoryExists(pszTemporary) && CreateDirectory(pszTemporary, NULL))
                {
                    dwTempDir = dwIndex;
                    break;
                }
            }
        }
    }

    if (dwTempDir != -1)
    {
        *ppszTempDirectory = pszTemporary;
    }
    else
    {
        SetLastError(ERROR_NO_SYSTEM_RESOURCES);
        FreeSplMem(pszTemporary);
    }

    return dwTempDir;
}


int
wstrcmpEx(
    LPCWSTR s1,
    LPCWSTR s2,
    BOOL    bCaseSensitive
    )
{
    if ( s1 && *s1 ) {
        if ( s2 && *s2 ) {
            return bCaseSensitive ? wcscmp(s1, s2) : _wcsicmp(s1, s2);
        }
        else {
            return 1;
        }
    }
    else {
        if ( s2 && *s2 ) {
            return -1;
        }
        else {
            return 0;
        }
    }
}


BOOL
RegSetString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    LPWSTR  pString;
    DWORD   cbString;
    DWORD   Status;

    if ( pStringValue ) {

        pString = pStringValue;
        cbString = ( wcslen( pStringValue ) + 1 )*sizeof(WCHAR);

    } else {

        pString = szNull;
        cbString = sizeof(WCHAR);
    }

    Status =  SplRegSetValue( hKey,
                              pValueName,
                              REG_SZ,
                              (LPBYTE)pString,
                              cbString,
                              pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetString value %ws string %ws error %d\n", pValueName, pString, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;

    }

    return bReturnValue;

}

BOOL
RegSetDWord(
    HANDLE  hKey,
    LPWSTR  pValueName,
    DWORD   dwParam,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    LPWSTR  pString;
    DWORD   Status;

    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_DWORD,
                             (LPBYTE)&dwParam,
                             sizeof(DWORD),
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetDWord value %ws DWORD %x error %d\n",
                               pValueName, dwParam, Status ));


        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;

}

BOOL
RegSetBinaryData(
    HKEY    hKey,
    LPWSTR  pValueName,
    LPBYTE  pData,
    DWORD   cbData,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    DWORD   Status;
    BOOL    bReturnValue;


    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_BINARY,
                             pData,
                             cbData,
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetBinaryData Value %ws pData %x cbData %d error %d\n",
                               pValueName,
                               pData,
                               cbData,
                               Status ));

        bReturnValue = FALSE;
        *pdwLastError = Status;

    } else {

        bReturnValue = TRUE;
    }

    return bReturnValue;
}

BOOL
RegSetMultiString(
    HANDLE  hKey,
    LPWSTR  pValueName,
    LPWSTR  pStringValue,
    DWORD   cchString,
    PDWORD  pdwLastError,
    PINISPOOLER pIniSpooler
    )
{
    BOOL    bReturnValue;
    DWORD   Status;
    LPWSTR  pString;
    WCHAR   szzNull[2];

    if ( pStringValue ) {
        pString    = pStringValue;
        cchString *= sizeof(WCHAR);
    } else {
        szzNull[0] = szzNull[1] = '\0';
        pString   = szNull;
        cchString = 2 * sizeof(WCHAR);
    }

    Status = SplRegSetValue( hKey,
                             pValueName,
                             REG_MULTI_SZ,
                             (LPBYTE)pString,
                             cchString,
                             pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        DBGMSG( DBG_WARNING, ("RegSetMultiString value %ws string %ws error %d\n", pValueName, pString, Status ));

        *pdwLastError = Status;
        bReturnValue = FALSE;

    } else {

        bReturnValue = TRUE;

    }

    return bReturnValue;
}

BOOL
RegGetString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:
    Allocates memory and reads a value from Registry for a value which was
    earlier set by calling RegSetValueEx.


Arguments:
    hKey            : currently open key to be used to query the registry
    pValueName      : value to be used to query the registry
    ppValue         : on return value of TRUE *ppValue (memory allocated by
                      the routine) will have the value
    pdwLastError    : on failure *dwLastError will give the error
    bFailIfNotFound : Tells if the field is mandatory (if not found error)

Return Value:
    TRUE : value is found and succesfully read.
           Memory will be allocated to hold the value
    FALSE: Value was not read.
           If bFailIfNotFound was TRUE error code will be set.

History:
    Written by MuhuntS (Muhunthan Sivapragasam)June 95

--*/
{
    BOOL    bReturnValue = TRUE;
    LPWSTR  pString;
    DWORD   cbValue;
    DWORD   Status, Type;

    //
    // First query to find out size
    //
    cbValue = 0;
    Status =  SplRegQueryValue( hKey,
                                pValueName,
                                &Type,
                                NULL,
                                &cbValue,
                                pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        // Set error code only if it is a required field
        if ( bFailIfNotFound )
            *pdwLastError = Status;

        bReturnValue = FALSE;

    } else if ( (Type == REG_SZ && cbValue > sizeof(WCHAR) ) ||
                (Type == REG_MULTI_SZ && cbValue > 2*sizeof(WCHAR)) ) {

        //
        // Something (besides \0 or \0\0) to read
        //

        if ( !(*ppValue=AllocSplMem(cbValue) ) ) {

            *pdwLastError = GetLastError();
            bReturnValue  = FALSE;
        } else {

            Status = SplRegQueryValue( hKey,
                                       pValueName,
                                       &Type,
                                       (LPBYTE)*ppValue,
                                       &cbValue,
                                       pIniSpooler );

            if ( Status != ERROR_SUCCESS ) {

                DBGMSG( DBG_WARNING, ("RegGetString value %ws string %ws error %d\n", pValueName, **ppValue, Status ));
                *pdwLastError = Status;
                bReturnValue  = FALSE;

            } else {

                *pcchValue = cbValue / sizeof(WCHAR);
                bReturnValue = TRUE;
            }

        }
    }

    return bReturnValue;
}

BOOL
RegGetMultiSzString(
    HANDLE    hKey,
    LPWSTR    pValueName,
    LPWSTR   *ppValue,
    LPDWORD   pcchValue,
    PDWORD    pdwLastError,
    BOOL      bFailIfNotFound,
    PINISPOOLER pIniSpooler
    )
/*++

Routine Description:
    Duplicate function for RegGetString. Handles multi-sz strings so that Spooler
    doesn't crash.

Arguments:
    hKey            : currently open key to be used to query the registry
    pValueName      : value to be used to query the registry
    ppValue         : on return value of TRUE *ppValue (memory allocated by
                      the routine) will have the value
    pdwLastError    : on failure *dwLastError will give the error
    bFailIfNotFound : Tells if the field is mandatory (if not found error)

Return Value:
    TRUE : value is found and succesfully read.
           Memory will be allocated to hold the value
    FALSE: Value was not read.
           If bFailIfNotFound was TRUE error code will be set.

History:

    This function is a fix for the case when 3rd party applications
    install drivers by writing registry string values instead of multi-sz. This causes Spooler
    to AV because it will handle a string as a multi-sz string. The goal of having this function
    was to provide a quick fix/low regression risk for XP RC2 release. A bug was opened for rewriting
    RegGetMultiSzString and RegGetString in BlackComb timeframe.

--*/
{
    BOOL    bReturnValue = TRUE;
    LPWSTR  pString;
    DWORD   cbValue;
    DWORD   Status, Type;

    //
    // First query to find out size
    //
    cbValue = 0;
    Status =  SplRegQueryValue( hKey,
                                pValueName,
                                &Type,
                                NULL,
                                &cbValue,
                                pIniSpooler );

    if ( Status != ERROR_SUCCESS ) {

        // Set error code only if it is a required field
        if ( bFailIfNotFound )
            *pdwLastError = Status;

        bReturnValue = FALSE;

    } else if ( (Type == REG_SZ && cbValue > sizeof(WCHAR) ) ||
                (Type == REG_MULTI_SZ && cbValue > 2*sizeof(WCHAR)) ) {

        //
        // Something (besides \0 or \0\0) to read
        //

        //
        // We expect a REG_MULTI_SZ string. Add an extra zero so Spooler doesn't crash.
        // XP RC2 fix.
        //
        if (Type == REG_SZ) {
            cbValue += sizeof(WCHAR);
        }

        if ( !(*ppValue=AllocSplMem(cbValue) ) ) {

            *pdwLastError = GetLastError();
            bReturnValue  = FALSE;
        } else {

            Status = SplRegQueryValue( hKey,
                                       pValueName,
                                       &Type,
                                       (LPBYTE)*ppValue,
                                       &cbValue,
                                       pIniSpooler );

            if ( Status != ERROR_SUCCESS ) {

                DBGMSG( DBG_WARNING, ("RegGetString value %ws string %ws error %d\n", pValueName, **ppValue, Status ));
                *pdwLastError = Status;
                bReturnValue  = FALSE;
                //
                // Caller will must the memory regardless of success or failure.
                //
            } else {

                *pcchValue = cbValue / sizeof(WCHAR);
                bReturnValue = TRUE;
            }

        }
    }

    return bReturnValue;
}

VOID
FreeStructurePointers(
    LPBYTE  lpStruct,
    LPBYTE  lpStruct2,
    LPDWORD lpOffsets)
/*++

Routine Description:
    This routine frees memory allocated to all the pointers in the structure
    If lpStruct2 is specified only pointers in lpStruct which are different
    than the ones in lpStruct will be freed

Arguments:
    lpStruct:   Pointer to the structure
    lpStruct2:  Pointer to the structure to compare with (optional)
    lpOffsets:  An array of DWORDS (terminated by -1) givings offsets in the
                structure which have memory which needs to be freed

Return Value:
    nothing

--*/
{
    register INT i;

    if ( lpStruct2 ) {

        for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

            if ( *(LPBYTE *) (lpStruct+lpOffsets[i]) &&
                 *(LPBYTE *) (lpStruct+lpOffsets[i]) !=
                        *(LPBYTE *) (lpStruct2+lpOffsets[i]) )

                FreeSplMem(*(LPBYTE *) (lpStruct+lpOffsets[i]));
        }
    } else {

        for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

            if ( *(LPBYTE *) (lpStruct+lpOffsets[i]) )
                FreeSplMem(*(LPBYTE *) (lpStruct+lpOffsets[i]));
        }
    }
}

/*++

Routine Name:

    AllocOrUpdateStringAndTestSame

Routine Description:

    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and copy the old structure to it.
    Then call this routine for all LPWSTR fields to check and update strings

    If the value changes:
        This routine will allocate memory and assign pointer in the
        temporary structure.

Arguments:

    ppString            :  Points to a pointer in the temporary sturucture
    pNewValue           : New value to be set
    pOldValue           : Value in the original strucutre
    bCaseSensitive      : Determines whether case-sensitive string compare is performed
    pbFail              :     On error set this to TRUE (Note: it could already be TRUE)
    *pbIdentical        : If the strings are diferent this is set to FALSE.
                          (Could already be false).

Return Value:

    TRUE on success, else FALSE

--*/
BOOL
AllocOrUpdateStringAndTestSame(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail,
    IN  OUT BOOL        *pbIdentical
    )
{
    BOOL    bReturn = TRUE;
    int     iReturn;

    if ( *pbFail )
        return FALSE;


    if (wstrcmpEx(pNewValue, pOldValue, bCaseSensitive)) {

        *pbIdentical = FALSE;

        if ( pNewValue && *pNewValue ) {

            if ( !(*ppString = AllocSplStr(pNewValue)) ) {

                *pbFail   = TRUE;
                bReturn = FALSE;
            }
        } else {

            *ppString = NULL;
        }
    }

    return bReturn;
}

/*++

Routine Name:

    AllocOrUpdateString

Routine Description:

    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and copy the old structure to it.
    Then call this routine for all LPWSTR fields to check and update strings

    If the value changes:
        This routine will allocate memory and assign pointer in the
        temporary structure.

Arguments:

    ppString            :  Points to a pointer in the temporary sturucture
    pNewValue           : New value to be set
    pOldValue           : Value in the original strucutre
    bCaseSensitive      : Determines whether case-sensitive string compare is performed
    pbFail              :     On error set this to TRUE (Note: it could already be TRUE)

Return Value:

    TRUE on success, else FALSE

--*/
BOOL
AllocOrUpdateString(
    IN      LPWSTR      *ppString,
    IN      LPCWSTR     pNewValue,
    IN      LPCWSTR     pOldValue,
    IN      BOOL        bCaseSensitive,
    IN  OUT BOOL        *pbFail
    )
{
    BOOL    bIdentical = FALSE;

    return AllocOrUpdateStringAndTestSame(ppString, pNewValue, pOldValue, bCaseSensitive, pbFail, &bIdentical);
}

VOID
CopyNewOffsets(
    LPBYTE  pStruct,
    LPBYTE  pTempStruct,
    LPDWORD lpOffsets)
/*++

Routine Description:
    This routine can be used to do an atomic update of values in a structure.
    Create a temporary structure and allocate memory for values which
    are being updated in it, and set the remaining pointers to those in
    the original.

    This routine is called at the end to update the structure.

Arguments:
    pStruct:        Pointer to the structure
    pTempStruct:    Pointer to the temporary structure
    lpOffsets:      An array of DWORDS givings offsets within the stuctures

Return Value:
    nothing

--*/
{
    register INT i;

    for( i=0; lpOffsets[i] != 0xFFFFFFFF; ++i ) {

        if ( *(LPBYTE *) (pStruct+lpOffsets[i]) !=
                *(LPBYTE *) (pTempStruct+lpOffsets[i]) ) {

            if ( *(LPBYTE *) (pStruct+lpOffsets[i]) )
                FreeSplMem(*(LPBYTE *) (pStruct+lpOffsets[i]));

            *(LPBYTE *) (pStruct+lpOffsets[i]) = *(LPBYTE *) (pTempStruct+lpOffsets[i]);
        }
    }
}


DWORD
GetIniDriverAndDirForThisMachine(
    IN  PINIPRINTER     pIniPrinter,
    OUT LPWSTR          pszDriverDir,
    OUT PINIDRIVER     *ppIniDriver
    )
/*++

Description:
    Gets the path to the driver directory for the printer on the local machine

Arguments:
    pIniPrinter     - Points to IniPrinter
    pszDriverDir    - A buffer of size MAX_PATH to get the directory path

Return Vlaue:
    Number of characters copied (0 on failure)

--*/
{
    PINIVERSION         pIniVersion = NULL;
    PINIENVIRONMENT     pIniEnvironment;
    PINISPOOLER         pIniSpooler = pIniPrinter->pIniSpooler;
    DWORD               dwIndex;

    EnterSplSem();
    //
    // Find driver file for the given driver and then get it's fullpath
    //
    SPLASSERT(pIniPrinter && pIniPrinter->pIniDriver && pIniPrinter->pIniDriver->pName);


    pIniEnvironment = FindEnvironment(szEnvironment, pIniSpooler);
    *ppIniDriver    = FindCompatibleDriver(pIniEnvironment,
                                           &pIniVersion,
                                           pIniPrinter->pIniDriver->pName,
                                           dwMajorVersion,
                                           dwUpgradeFlag);


    SPLASSERT(*ppIniDriver);

    dwIndex = GetDriverVersionDirectory(pszDriverDir,
                                        MAX_PATH - 2,
                                        pIniPrinter->pIniSpooler,
                                        pIniEnvironment,
                                        pIniVersion,
                                        *ppIniDriver,
                                        NULL);

    pszDriverDir[dwIndex++] = L'\\';
    pszDriverDir[dwIndex] = L'\0';

    LeaveSplSem();

    return dwIndex;

}


LPWSTR
GetConfigFilePath(
    IN PINIPRINTER  pIniPrinter
    )
/*++

Description:
    Gets the full path to the config file (driver ui file) associated with the
    driver. Memory is allocated

Arguments:
    pIniPrinter - Points to IniPrinter

Return Vlaue:
    Pointer to the printer name buffer (NULL on error)

--*/
{
    DWORD       dwIndex;
    WCHAR       szDriverPath[MAX_PATH + 1];
    PWSTR       pszConfigFile = NULL;
    PINIDRIVER  pIniDriver;

    if ( dwIndex = GetIniDriverAndDirForThisMachine(pIniPrinter,
                                                    szDriverPath,
                                                    &pIniDriver) )
    {
        if (BoolFromHResult(StringCchCopy(szDriverPath + dwIndex, COUNTOF(szDriverPath) - dwIndex, pIniDriver->pConfigFile)))
        {
            pszConfigFile = AllocSplStr(szDriverPath);
        }
    }

    return pszConfigFile;
}


PDEVMODE
ConvertDevModeToSpecifiedVersion(
    IN  PINIPRINTER pIniPrinter,
    IN  PDEVMODE    pDevMode,
    IN  LPWSTR      pszConfigFile,              OPTIONAL
    IN  LPWSTR      pszPrinterNameWithToken,    OPTIONAL
    IN  BOOL        bNt35xVersion
    )
/*++

Description:
    Calls driver UI routines to get the default devmode and then converts given devmode
    to that version. If the input devmode is in IniPrinter routine makes a copy before
    converting it.

    This routine needs to be called from inside spooler semaphore

Arguments:
    pIniPrinter     - Points to IniPrinter

    pDevMode        -  Devmode to convert to current version

    pConfigFile     - Full path to driver UI file to do LoadLibrary (optional)

    pszPrinterNameWithToken - Name of printer with token (optional)

    bToNt3xVersion          - If TRUE devmode is converted to Nt3x format, else to current version

Return Vlaue:
    Pointer to new devmode on success, NULL on failure

--*/
{
    LPWSTR          pszLocalConfigFile = pszConfigFile;
    LPWSTR          pszLocalPrinterNameWithToken = pszPrinterNameWithToken;
    LPDEVMODE       pNewDevMode = NULL, pOldDevMode = NULL;
    DWORD           dwNeeded, dwLastError;
    LONG            lNeeded;
    HANDLE          hDevModeConvert = NULL,hPrinter = NULL;
    BOOL            bCallDocumentProperties = FALSE;

    SplInSem();

    //
    // If ConfigFile or PrinterNameWithToken is not given allocate it locally
    //
    if ( !pszLocalConfigFile ) {

        pszLocalConfigFile = GetConfigFilePath(pIniPrinter);
        if ( !pszLocalConfigFile )
            goto Cleanup;
    }

    if ( !pszLocalPrinterNameWithToken ) {

        pszLocalPrinterNameWithToken = pszGetPrinterName( pIniPrinter,
                                                          TRUE,
                                                          pszLocalOnlyToken );
        if ( !pszLocalPrinterNameWithToken )
            goto Cleanup;

    }

    //
    // If we are trying to convert pIniPrinter->pDevMode make a copy since we are going to leave SplSem
    //
    if ( pDevMode  ) {

        if ( pDevMode == pIniPrinter->pDevMode ) {

            dwNeeded = pDevMode->dmSize + pDevMode->dmDriverExtra;
            SPLASSERT(dwNeeded == pIniPrinter->cbDevMode);
            pOldDevMode = AllocSplMem(dwNeeded);
            if ( !pOldDevMode )
                goto Cleanup;

            CopyMemory((LPBYTE)pOldDevMode, (LPBYTE)pDevMode, dwNeeded);

        } else {

            pOldDevMode = pDevMode;
        }
    }

    //
    // Driver is going to call OpenPrinter, so leave SplSem
    //
    LeaveSplSem();
    SplOutSem();

    hDevModeConvert = LoadDriverFiletoConvertDevmode(pszLocalConfigFile);

    if ( !hDevModeConvert ) {

        // If the function is not exported and 3.5x conversion is not required
        // the devmode can be got from DocumentProperties

        if ( bNt35xVersion != NT3X_VERSION ) {
           bCallDocumentProperties = TRUE;
        }
        goto CleanupFromOutsideSplSem;
    }


    dwNeeded = 0;
    if ( bNt35xVersion == NT3X_VERSION ) {

        //
        // Call CallDrvDevModeConversion to allocate memory and return 351 devmode
        //
        dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                               pszLocalPrinterNameWithToken,
                                               (LPBYTE)pOldDevMode,
                                               (LPBYTE *)&pNewDevMode,
                                               &dwNeeded,
                                               CDM_CONVERT351,
                                               TRUE);

        SPLASSERT(dwLastError == ERROR_SUCCESS || !pNewDevMode);
    } else {

        //
        // Call CallDrvDevModeConversion to allocate memory and give default devmode
        dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                               pszLocalPrinterNameWithToken,
                                               NULL,
                                               (LPBYTE *)&pNewDevMode,
                                               &dwNeeded,
                                               CDM_DRIVER_DEFAULT,
                                               TRUE);

        if ( dwLastError != ERROR_SUCCESS ) {

            SPLASSERT(!pNewDevMode);

            // Call DocumentProperties to get the default devmode
            bCallDocumentProperties = TRUE;

            goto CleanupFromOutsideSplSem;
        }

        //
        // If we have an input devmode to convert to current mode call driver again
        //
        if ( pOldDevMode ) {

            dwLastError = CallDrvDevModeConversion(hDevModeConvert,
                                                   pszLocalPrinterNameWithToken,
                                                   (LPBYTE)pOldDevMode,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwNeeded,
                                                   CDM_CONVERT,
                                                   FALSE);

            //
            // If call failed free devmode which was allocated by previous call
            //
            if ( dwLastError != ERROR_SUCCESS ) {

                // Call DocumentProperties to get the default devmode
                bCallDocumentProperties = TRUE;

                goto CleanupFromOutsideSplSem;
            }
        }
    }


CleanupFromOutsideSplSem:

    if (bCallDocumentProperties) {

       // Get a client side printer handle to pass to the driver
       if (!(* pfnOpenPrinter)(pszLocalPrinterNameWithToken, &hPrinter, NULL)) {
           goto ReEnterSplSem;
       }

       if (!pNewDevMode) {
          // Get the default devmode
          lNeeded = (* pfnDocumentProperties)(NULL,
                                              hPrinter,
                                              pszLocalPrinterNameWithToken,
                                              NULL,
                                              NULL,
                                              0);

          if (lNeeded <= 0  ||
              !(pNewDevMode = (LPDEVMODEW) AllocSplMem(lNeeded)) ||
              (* pfnDocumentProperties)(NULL,
                                        hPrinter,
                                        pszLocalPrinterNameWithToken,
                                        pNewDevMode,
                                        NULL,
                                        DM_OUT_BUFFER) < 0) {

               if (pNewDevMode) {
                  FreeSplMem(pNewDevMode);
                  pNewDevMode = NULL;
                  goto ReEnterSplSem;
               }
          }
       }

       if (pOldDevMode) {
          // Convert to Current mode
          if ((* pfnDocumentProperties)(NULL,
                                        hPrinter,
                                        pszLocalPrinterNameWithToken,
                                        pNewDevMode,
                                        pOldDevMode,
                                        DM_IN_BUFFER | DM_OUT_BUFFER) < 0) {

              FreeSplMem(pNewDevMode);
              pNewDevMode = NULL;
              goto ReEnterSplSem;
          }
       }
    }

ReEnterSplSem:

    if (hPrinter) {
        (* pfnClosePrinter)(hPrinter);
    }

    SplOutSem();
    EnterSplSem();

Cleanup:

    if ( hDevModeConvert )
        UnloadDriverFile(hDevModeConvert);

    if ( pszLocalConfigFile != pszConfigFile )
        FreeSplStr(pszLocalConfigFile);

    if ( pszPrinterNameWithToken != pszLocalPrinterNameWithToken )
        FreeSplStr(pszLocalPrinterNameWithToken);

    if ( pOldDevMode != pDevMode )
        FreeSplMem(pOldDevMode);

    return pNewDevMode;
}


BOOL
IsPortType(
    LPWSTR pPort,
    LPWSTR pPrefix
)
{
    DWORD   dwLen;

    SPLASSERT(pPort && *pPort && pPrefix && *pPrefix);

    dwLen = wcslen(pPrefix);

    if ( wcslen(pPort) < dwLen ) {

        return FALSE;
    }

    if ( _wcsnicmp(pPort, pPrefix, dwLen) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
/*++

Description:
    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:
    pAnsi    - Points to the ANSI string

Return Vlaue:
    Pointer to UNICODE string

--*/
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}

/*++

Routine Name:

    UnicodeToAnsiString

Routine Description:

    This allocates an ANSI string and converts it using the thread's codepage.

Arguments:

    pszUnicode      -   The incoming, non-NULL, NULL terminated unicode string.
    ppszAnsi        -   The returned ANSI string.

Return Value:

    An HRESULT

--*/
HRESULT
UnicodeToAnsiString(
    IN      PWSTR           pszUnicode,
        OUT PSTR            *ppszAnsi
    )
{
    HRESULT hRetval          = E_FAIL;
    PSTR    pszAnsi          = NULL;
    INT     AnsiStringLength = 0;

    hRetval = pszUnicode && ppszAnsi ? S_OK : E_INVALIDARG;

    if (ppszAnsi)
    {
        *ppszAnsi = NULL;
    }

    if (SUCCEEDED(hRetval))
    {
        AnsiStringLength = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, NULL, 0, NULL, NULL);

        hRetval = AnsiStringLength != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        pszAnsi = AllocSplMem(AnsiStringLength);

        hRetval = pszAnsi ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, pszAnsi, AnsiStringLength, NULL, NULL) != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        *ppszAnsi = pszAnsi;
        pszAnsi = NULL;
    }

    FreeSplMem(pszAnsi);

    return hRetval;
}

BOOL
SplMonitorIsInstalled(
    LPWSTR  pMonitorName
    )
{
    BOOL    bRet;

    EnterSplSem();
    bRet = FindMonitor(pMonitorName, pLocalIniSpooler) != NULL;
    LeaveSplSem();

    return bRet;
}


BOOL
PrinterDriverEvent(
    PINIPRINTER pIniPrinter,
    INT     PrinterEvent,
    LPARAM  lParam,
    DWORD   *pdwReturnedError
)
/*++

--*/
{
    BOOL    ReturnValue = FALSE;
    LPWSTR  pPrinterName = NULL;
    BOOL    InSpoolSem = TRUE;

    SplOutSem();
    EnterSplSem();

    //
    //  We have to Clone the name string, incase someone does a
    //  rename whilst outside criticalsection.
    //

    pPrinterName = pszGetPrinterName( pIniPrinter, TRUE, pszLocalsplOnlyToken);

    LeaveSplSem();
    SplOutSem();


    if ( (pIniPrinter->pIniSpooler->SpoolerFlags & SPL_PRINTER_DRIVER_EVENT) &&
     pPrinterName != NULL ) {

        ReturnValue = SplDriverEvent( pPrinterName, PrinterEvent, lParam, pdwReturnedError );

    }

    FreeSplStr( pPrinterName );

    return  ReturnValue;
}




BOOL
SplDriverEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    LPARAM  lParam,
    DWORD   *pdwReturnedError
)
{
    BOOL    ReturnValue = FALSE;

    if ( pfnPrinterEvent != NULL ) {

        SplOutSem();

        SPLASSERT( pName && PrinterEvent );

        DBGMSG(DBG_INFO, ("SplDriverEvent %ws %d %x\n", pName, PrinterEvent, lParam));

        ReturnValue = (*pfnPrinterEvent)( pName, PrinterEvent, PRINTER_EVENT_FLAG_NO_UI, lParam, pdwReturnedError );
    }

    return ReturnValue;
}


DWORD
OpenPrinterKey(
    PINIPRINTER pIniPrinter,
    REGSAM      samDesired,
    HANDLE      *phKey,
    LPCWSTR     pKeyName,
    BOOL        bOpen
    )

/*++

Description:    OpenPrinterKey

     Opens "Printers" and IniPrinter->pName keys, then opens
     specified subkey "pKeyName" if pKeyName is not NULL

     This routine needs to be called from inside spooler semaphore

Arguments:
    pIniPrinter     - Points to IniPrinter

    *phPrinterRootKey -  Handle to "Printers" key on return

    *phPrinterKey -     Handle to IniPrinter->pName key on return

    *hKey -             Handle to pKeyName key on return

    pKeyName -          Points to SubKey to open

Return Value:

    Success or failure status

Author: Steve Wilson (NT)

--*/

{
    LPWSTR pThisKeyName     = NULL;
    LPWSTR pPrinterKeyName  = NULL;
    DWORD  cbKeyNameLen     = 0;
    DWORD  rc               = ERROR_INVALID_FUNCTION;
    PINISPOOLER pIniSpooler = pIniPrinter->pIniSpooler;

    SplInSem();

    if (!(pPrinterKeyName = SubChar(pIniPrinter->pName, L'\\', L','))) {
        rc = GetLastError();
        goto error;
    }

    if (pKeyName && *pKeyName){

        rc = StrCatAlloc(&pThisKeyName, pPrinterKeyName, L"\\", pKeyName, NULL);

    } else {
        pThisKeyName = pPrinterKeyName;
    }

    if (bOpen) {    // Open
        rc = SplRegOpenKey( pIniSpooler->hckPrinters,
                            pThisKeyName,
                            samDesired,
                            phKey,
                            pIniSpooler );
    }
    else {  // Create
        rc = SplRegCreateKey( pIniSpooler->hckPrinters,
                              pThisKeyName,
                              0,
                              samDesired,
                              NULL,
                              phKey,
                              NULL,
                              pIniSpooler );
    }

error:

    if (pThisKeyName != pPrinterKeyName) {

        FreeSplMem(pThisKeyName);
    }

    FreeSplStr(pPrinterKeyName);

    return rc;
}

BOOL
SplGetDriverDir(
    HANDLE      hIniSpooler,
    LPWSTR      pszDir,
    LPDWORD     pcchDir
    )
{
    DWORD           cchSize;
    PINISPOOLER     pIniSpooler = (PINISPOOLER)hIniSpooler;

    SPLASSERT(pIniSpooler && pIniSpooler->signature == ISP_SIGNATURE);

    cchSize     = *pcchDir;
    *pcchDir    = wcslen(pIniSpooler->pDir) + wcslen(szDriverDir) + 2;

    if ( *pcchDir > cchSize ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    StringCchPrintf(pszDir, cchSize, L"%ws\\%ws", pIniSpooler->pDir, szDriverDir);

    return TRUE;
}

VOID
GetRegistryLocation(
    IN HANDLE hKey,
    IN LPCWSTR pszPath,
    OUT PHANDLE phKeyOut,
    OUT LPCWSTR *ppszPathOut
    )

/*++

Routine Description:

    Take a registry path and detect whether it should be absolute (rooted
    from HKEY_LOCAL_MACHINE), or if it should be branched off of the
    subkey that is passed in hKey.

    By convention, if it starts with "\" then it is an absolute path.
    Otherwise it is relative off hKey.

Arguments:

    hKey - Print hKey

    pszPath - Path to parse.  If the pszPath starts with a
        backslash, then it is absolute.

    phKeyOut - New key that should be used.

    ppszPathOut - New path that should be used.

Return Value:

--*/

{
    if( pszPath && ( pszPath[0] == TEXT( '\\' ))){
        *phKeyOut = HKEY_LOCAL_MACHINE;
        *ppszPathOut = &pszPath[1];

        return;
    }
    *phKeyOut = hKey;
    *ppszPathOut = pszPath;
}

PWSTR
FixDelim(
    PCWSTR    pszInBuffer,
    WCHAR    wcDelim
)
/*++

Routine Description:

    Removes duplicate delimiters from a set of delimited strings

Arguments:

    pszInBuffer - Input list of comma delimited strings

    wcDelim - The delimit character

Return Value:

    Returns a fixed string

--*/
{
    PWSTR    pszIn, pszOut, pszOutBuffer;
    BOOL    bFoundDelim = TRUE;

    pszOutBuffer = (PWSTR) AllocSplMem((wcslen(pszInBuffer) + 1)*sizeof(WCHAR));

    if (pszOutBuffer) {

        for(pszOut = pszOutBuffer, pszIn = (PWSTR) pszInBuffer ; *pszIn ; ++pszIn) {
            if (*pszIn == wcDelim) {
                if (!bFoundDelim) {
                    bFoundDelim = TRUE;
                    *pszOut++ = *pszIn;
                }
            } else {
                bFoundDelim = FALSE;
                *pszOut++ = *pszIn;
            }
        }

        // Check for trailing delimiter
        if (pszOut != pszOutBuffer && *(pszOut - 1) == wcDelim) {
            *(pszOut - 1) = L'\0';
        }

        *pszOut = L'\0';
    }

    return pszOutBuffer;
}

PWSTR
Array2DelimString(
    PSTRINGS    pStringArray,
    WCHAR        wcDelim
)
/*++

Routine Description:

    Converts a PSTRINGS structure to a set of delimited strings

Arguments:

    pStringArray - Input PSTRINGS structure

    wcDelim - The delimit character

Return Value:

    Delimited string buffer

--*/
{
    DWORD    i, nBytes;
    PWSTR    pszDelimString;
    WCHAR    szDelimString[2];


    if (!pStringArray || pStringArray->nElements == 0)
        return NULL;

    szDelimString[0] = wcDelim;
    szDelimString[1] = L'\0';

    // Determine memory requirement
    for (i = nBytes = 0 ; i < pStringArray->nElements  ; ++i) {
        //
        // allocate extra space for the delimiter
        //
        if (pStringArray->ppszString[i])
            nBytes += (wcslen(pStringArray->ppszString[i]) + 1)*sizeof (WCHAR);
    }

    pszDelimString = (PWSTR) AllocSplMem(nBytes);

    if (pszDelimString) {

        for (i = 0 ; i < pStringArray->nElements - 1 ; ++i) {
            if (pStringArray->ppszString[i]) {
                StringCbCat(pszDelimString, nBytes, pStringArray->ppszString[i]);
                StringCbCat(pszDelimString, nBytes, szDelimString);
            }
        }

        if (pStringArray->ppszString[i])
            StringCbCat(pszDelimString, nBytes, pStringArray->ppszString[i]);
    }

    return pszDelimString;
}




PSTRINGS
ShortNameArray2LongNameArray(
    PSTRINGS pShortNames
)
/*++

Routine Description:

    Converts a PSTRINGS structure containing short names to a PSTRINGS struct containing the dns
    equivalents

Arguments:

    pStringArray - Input PSTRINGS structure

Return Value:

    PSTRINGS struct containing the dns equivalents of the input short name PSTRINGS struct.

--*/
{
    PSTRINGS    pLongNames;
    DWORD        i;

    if (!pShortNames) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }


    // Allocate LongNameArray
    pLongNames = AllocStringArray(pShortNames->nElements);
    if (!pLongNames)
        return NULL;


    for (i = 0 ; i < pShortNames->nElements ; ++i) {
        // GetDNSMachineName may fail, leaving the LongNameArray element empty.  This is okay.
        GetDNSMachineName(pShortNames->ppszString[i], &pLongNames->ppszString[i]);
    }
    pLongNames->nElements = pShortNames->nElements;

    return pLongNames;
}


PSTRINGS
DelimString2Array(
    PCWSTR    pszDelimString,
    WCHAR    wcDelim
)
/*++

Routine Description:

    Converts a delimited string to a PSTRINGS structure

Arguments:

    pszDelimString - Input, delimited strings

    wcDelim - The delimit character

Return Value:

    PSTRINGS structure

--*/
{
    PWSTR        psz, pszDelim;
    PSTRINGS     pStrings = NULL;
    ULONG        i, cChar, nStrings;

    //
    // Get number of names
    //
    for (psz = (PWSTR) pszDelimString, nStrings = 0 ; psz++ ; psz = wcschr(psz, wcDelim))
        ++nStrings;

    pStrings = AllocStringArray(nStrings);
    if (!pStrings)
        goto error;


    //
    // Copy delimited string to array
    //
    for (i = 0, psz = (PWSTR) pszDelimString ; i < nStrings && psz ; ++i, psz = pszDelim + 1) {

        pszDelim = wcschr(psz, wcDelim);

        if (pszDelim) {

            cChar = (ULONG) (pszDelim - psz) + 1;

        } else {

            cChar = wcslen(psz) + 1;

        }

        pStrings->ppszString[i] = (PWSTR) AllocSplMem(cChar * sizeof(WCHAR));

        if (!pStrings->ppszString[i]) {
            pStrings->nElements = i;
            FreeStringArray(pStrings);
            pStrings = NULL;
            goto error;
        }

        StringCchCopy(pStrings->ppszString[i], cChar, psz);
    }

    pStrings->nElements = nStrings;


error:

    return pStrings;

}


VOID
FreeStringArray(
    PSTRINGS pString
)
/*++

Routine Description:

    Frees a PSTRINGS structure

Arguments:

    pString - PSTRINGS structure to free

Return Value:

--*/
{
    DWORD    i;

    if (pString) {
        for (i = 0 ; i < pString->nElements ; ++i) {
            if (pString->ppszString[i])
                FreeSplMem(pString->ppszString[i]);
        }

        FreeSplMem(pString);
    }
}


PSTRINGS
AllocStringArray(
    DWORD    nStrings
)
/*++

Routine Description:

    Allocates a PSTRINGS structure

Arguments:

    nStrings - number of strings in the structure

Return Value:

    pointer to allocated PSTRINGS structure, if any

 --*/
{
    PSTRINGS    pStrings;

    // Allocate the STRINGS struct
    pStrings = (PSTRINGS) AllocSplMem(sizeof(STRINGS) + (nStrings - 1)*sizeof *pStrings->ppszString);

    return pStrings;
}

BOOL
SplDeleteFile(
    LPCTSTR lpFileName
)
/*++

Routine Name
    SplDeleteFile

Routine Description:
    Removes SFP protection and Deletes a file.
    If the file is protected and I fail to remove protection,
    the user will get warned with a system pop up.

Arguments:
    lpFileName - file full path requested

Return Value:
    DeleteFile's return value

--*/
{


    HANDLE RpcHandle = INVALID_HANDLE_VALUE;

    RpcHandle = SfcConnectToServer( NULL );

    if( RpcHandle != INVALID_HANDLE_VALUE ){

        SfcFileException( RpcHandle,
                          (PWSTR)lpFileName,
                          FILE_ACTION_REMOVED
                        );
        SfcClose(RpcHandle);
    }

    //
    // SfcFileException might fail with ERROR_FILE_NOT_FOUND because the file is
    // not in the protected file list.That's why I call DeleteFile anyway.
    //


    return DeleteFile( lpFileName );

}


BOOL
SplMoveFileEx(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName,
    DWORD dwFlags
)
/*++

Routine Name
    SplMoveFileEx

Routine Description:
    Removes SFP protection and move a file;
    If the file is protected and I fail to remove protection,
    the user will get warned with a system pop up.

Arguments:
    lpExistingFileName - pointer to the name of the existing file
    lpNewFileName      - pointer to the new name for the file
    dwFlags            - flag that specifies how to move file

Return Value:
    MoveFileEx's return value

--*/
{


    HANDLE RpcHandle = INVALID_HANDLE_VALUE;

    RpcHandle = SfcConnectToServer( NULL );

    if( RpcHandle != INVALID_HANDLE_VALUE ){

        SfcFileException( RpcHandle,
                          (PWSTR)lpExistingFileName,
                          FILE_ACTION_REMOVED
                        );

        SfcClose(RpcHandle);
    }

    //
    // SfcFileException might fail with ERROR_FILE_NOT_FOUND because the file is
    // not in the protected file list.That's why I call MoveFileEx anyway.
    //


    return MoveFileEx( lpExistingFileName, lpNewFileName, dwFlags );
}


DWORD
GetDefaultForKMPrintersBlockedPolicy (
)
{
    DWORD   Default = KM_PRINTERS_ARE_BLOCKED;
    BOOL    bIsNTWorkstation;
    NT_PRODUCT_TYPE  NtProductType;

    //
    // DEFAULT_KM_PRINTERS_ARE_BLOCKED is "blocked"
    //

    if ( RtlGetNtProductType(&NtProductType) ) {

        bIsNTWorkstation = NtProductType == NtProductWinNt;

        Default =   bIsNTWorkstation  ?
                    WKS_DEFAULT_KM_PRINTERS_ARE_BLOCKED :
                    SERVER_DEFAULT_KM_PRINTERS_ARE_BLOCKED;
    }

    return Default;
}

DWORD
GetServerInstallTimeOut(
)
{
    HKEY    hKey;
    DWORD   dwDummy;
    DWORD   dwTimeOut   = DEFAULT_MAX_TIMEOUT;
    DWORD   dwSize      = sizeof(dwTimeOut);
    LPCWSTR cszPrintKey = L"SYSTEM\\CurrentControlSet\\Control\\Print";
    LPCWSTR cszTimeOut  = L"ServerInstallTimeOut";

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszPrintKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        if(RegQueryValueEx( hKey, cszTimeOut, 0, &dwDummy, (LPBYTE)&dwTimeOut, &dwSize ) != ERROR_SUCCESS)
        {
            dwTimeOut = DEFAULT_MAX_TIMEOUT;
        }
        RegCloseKey( hKey );
    }
    return dwTimeOut;
}

ULONG_PTR
AlignToRegType(
    IN  ULONG_PTR   Data,
    IN  DWORD       RegType
    )
{
    //
    // Alings the value if Data to the boundary
    // dictated by the type of data read from registry.
    //

    ULONG_PTR Boundary;

    switch ( RegType )
    {
    //
    // Binary data could store any kind of data. The pointer is casted
    // to LPDWORD or LPBOOL so make sure it is native aligned.
    //
    case REG_BINARY:
        {
            Boundary = sizeof(ULONG_PTR);
        }
        break;
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_MULTI_SZ:
        {
            Boundary = sizeof(WCHAR);
        }
        break;
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
        {
            Boundary = sizeof(DWORD32);
        }
        break;
    case REG_QWORD:
        {
            Boundary = sizeof(DWORD64);
        }
        break;
    case REG_NONE:
    default:
        {
            Boundary = sizeof(ULONG_PTR);
        }
    }

    return (Data + (Boundary - 1))&~(Boundary - 1);
}

/*++

Routine Name

    BuildAclStruct

Routine Description:

    Helper function. Builds a vector of ACEs to allow all
    access to administrators and system. The caller has to
    free the pstrName fields

Arguments:
    cElements - number of elements in the array
    pExplAcc  - vector of aces

Return Value:

    WIN32 error code

--*/
DWORD
BuildAclStruct(
    IN     DWORD            cElements,
    IN OUT EXPLICIT_ACCESS *pExplAcc
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pExplAcc && cElements==2)
    {
        PSID                     pAdminSid   = NULL;
        PSID                     pSystemSid  = NULL;
        SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

        //
        // Get SID for the built in system account
        //
        dwError = AllocateAndInitializeSid(&NtAuthority,
                                           1,
                                           SECURITY_LOCAL_SYSTEM_RID,
                                           0, 0, 0, 0, 0, 0, 0,
                                           &pSystemSid) &&
                  AllocateAndInitializeSid(&NtAuthority,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           &pAdminSid) ? ERROR_SUCCESS : GetLastError();

        if (dwError == ERROR_SUCCESS)
        {
            //
            // Initialize the EXPLICIT_ACCESS with information about administrators
            //
            pExplAcc[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pExplAcc[0].Trustee.pMultipleTrustee         = NULL;
            pExplAcc[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            pExplAcc[0].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            pExplAcc[0].Trustee.ptstrName                = (PTSTR)pAdminSid;
            pExplAcc[0].grfAccessMode                    = GRANT_ACCESS;
            pExplAcc[0].grfAccessPermissions             = GENERIC_ALL;
            pExplAcc[0].grfInheritance                   = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

            //
            // Initialize the EXPLICIT_ACCESS with information about the system
            //
            pExplAcc[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pExplAcc[1].Trustee.pMultipleTrustee         = NULL;
            pExplAcc[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            pExplAcc[1].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            pExplAcc[1].Trustee.ptstrName                = (PTSTR)pSystemSid;
            pExplAcc[1].grfAccessMode                    = GRANT_ACCESS;
            pExplAcc[1].grfAccessPermissions             = GENERIC_ALL;
            pExplAcc[1].grfInheritance                   = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
        }
        else
        {
            //
            // Note that we never end up here and have pAdminSid not NULL. However, for the
            // sake of consisentcy and extensibility we attempt to clean up both strcutures
            //
            if (pSystemSid) FreeSid(pSystemSid);
            if (pAdminSid)  FreeSid(pAdminSid);
        }
    }

    return dwError;
}

/*++

Routine Name

    CreateProtectedDirectory

Routine Description:

    Creates a directory with full access only to admins and to
    the system. Contained objects inherit these permissions.

Arguments:

    pszDir - directory name

Return Value:

    WIN32 error code

--*/
DWORD
CreateProtectedDirectory(
    IN LPCWSTR pszDir
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszDir)
    {
        SECURITY_DESCRIPTOR  SecDesc;
        SECURITY_ATTRIBUTES  SecAttr;
        PACL                 pDacl                   = NULL;
        EXPLICIT_ACCESS      ExplicitAccessVector[2] = {0};

        if ((dwError = InitializeSecurityDescriptor(&SecDesc,
                                                    SECURITY_DESCRIPTOR_REVISION) ?
                                                    ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
            //
            // Initialize the ExplicitAccessVector
            //
            (dwError = BuildAclStruct(COUNTOF(ExplicitAccessVector),
                                      ExplicitAccessVector)) == ERROR_SUCCESS &&
            //
            // Initialize the DACL
            //
            (dwError = SetEntriesInAcl(COUNTOF(ExplicitAccessVector),
                                       ExplicitAccessVector,
                                       NULL,
                                       &pDacl)) == ERROR_SUCCESS &&
            //
            // Set the DACL in the security descriptor
            //
            (dwError = SetSecurityDescriptorDacl(&SecDesc,
                                                 TRUE,
                                                 pDacl,
                                                 FALSE) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
            //
            // Check if the security descriptor is valid. Function does not set last error
            //
            (dwError = IsValidSecurityDescriptor(&SecDesc) ?
                       ERROR_SUCCESS : ERROR_INVALID_SECURITY_DESCR) == ERROR_SUCCESS)
        {
            //
            // Put the security descriptor in the security attribute
            //
            SecAttr.bInheritHandle       = FALSE;
            SecAttr.nLength              = sizeof(SecAttr);
            SecAttr.lpSecurityDescriptor = &SecDesc;

            dwError = CreateDirectory(pszDir, &SecAttr) ? ERROR_SUCCESS : GetLastError();
        }

        //
        // The ptstrName here points to a sid obtained via AllocAndInitializeSid
        //
        if (ExplicitAccessVector[0].Trustee.ptstrName)
        {
            FreeSid(ExplicitAccessVector[0].Trustee.ptstrName);
        }

        //
        // The ptstrName here points to a sid obtained via AllocAndInitializeSid
        //
        if (ExplicitAccessVector[1].Trustee.ptstrName)
        {
            FreeSid((PSID)ExplicitAccessVector[1].Trustee.ptstrName);
        }
    }

    DBGMSG(DBG_CLUSTER, ("CreateProtectedDirectory returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyFileToDirectory

Routine Description:

    Copies a file to a directory. File is fully qualified.
    The function takes a pszDestDir and up to 3 directories.
    It will create the dir: pszRoot\pszDir1\pszDir2\pszDir3
    and copy the file over there. This is a helper function
    for installing drivers on clusters. The directory strcuture
    is created with special privileges. Only the system and
    administrators have access to it.

Arguments:
    pssDestDirt     - destination directory
    pszDir1         - optional
    pszDir2         - optional
    pszdir3         - optional
    pszFullFileName - qualified file path

Return Value:

    WIN32 error code

--*/
DWORD
CopyFileToDirectory(
    IN LPCWSTR pszFullFileName,
    IN LPCWSTR pszDestDir,
    IN LPCWSTR pszDir1,
    IN LPCWSTR pszDir2,
    IN LPCWSTR pszDir3
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;
    LPWSTR pszFile = NULL;

    //
    // Our pszfullFileName must contain at least one "\"
    //
    if (pszFullFileName &&
        pszDestDir      &&
        (pszFile = wcsrchr(pszFullFileName, L'\\')))
    {
        LPCWSTR ppszArray[] = {pszDir1, pszDir2, pszDir3};
        WCHAR   szNewPath[MAX_PATH];
        DWORD   uIndex;

        DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory\n\tpszFullFile "TSTR"\n\tpszDest "TSTR"\n\tDir1 "TSTR"\n\tDir2 "TSTR"\n\tDir3 "TSTR"\n",
                             pszFullFileName, pszDestDir, pszDir1, pszDir2, pszDir3));

        //
        // Prepare buffer for the loop (initialize to pszDestDir)
        // Create destination root directory, if not existing
        //
        if ((dwError = StrNCatBuff(szNewPath,
                                   MAX_PATH,
                                   pszDestDir,
                                   NULL)) == ERROR_SUCCESS &&
            (DirectoryExists((LPWSTR)pszDestDir) ||
            (dwError = CreateProtectedDirectory(pszDestDir)) == ERROR_SUCCESS))
        {
            for (uIndex = 0;
                 uIndex < COUNTOF(ppszArray) && dwError == ERROR_SUCCESS;
                 uIndex++)
            {
                //
                // Append the first directory to the path and
                // Create the directory if not existing
                //
                if (ppszArray[uIndex] &&
                    (dwError = StrNCatBuff(szNewPath,
                                           MAX_PATH,
                                           szNewPath,
                                           L"\\",
                                           ppszArray[uIndex],
                                           NULL)) == ERROR_SUCCESS &&
                    !DirectoryExists(szNewPath) &&
                    !CreateDirectoryWithoutImpersonatingUser(szNewPath))
                {
                    dwError = GetLastError();
                }
            }

            //
            // Create the destination file full name and copy the file
            //
            if (dwError == ERROR_SUCCESS &&
                (dwError = StrNCatBuff(szNewPath,
                                       MAX_PATH,
                                       szNewPath,
                                       pszFile,
                                       NULL)) == ERROR_SUCCESS)
            {
                 dwError = CopyFile(pszFullFileName, szNewPath, FALSE) ? ERROR_SUCCESS : GetLastError();
            }

            DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory szNewPath "TSTR"\n", szNewPath));
        }
    }

    DBGMSG(DBG_CLUSTER, ("CopyFileToDirectory returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    PropagateMonitorToCluster

Routine Description:

    For a cluster we keep the following printing resources in the
    cluster data base: drivers, printers, ports, procs. We can also
    have cluster aware port monitors. When the spooler initializes
    those objects, it reads the data from the cluster data base.
    When we write those objects we pass a handle to a key to some
    spooler functions. (Ex WriteDriverIni) The handle is either to the
    local registry or to the cluster database. This procedure is not safe
    with language monitors. LMs keep data in the registry so you need
    to supply a handle to a key in the reg. They don't work with clusters.
    This function will do this:
    1) write an association key in the cluster data base. We will have
    information like (lm name, dll name) (see below where we store this)
    2) copy the lm dll to the cluster disk.
    When we fail over we have all it take to install the lm on the local
    node if needed.

    Theoretically this function works for both language and port monitors.
    But it is useless when applied to port monitors.

Arguments:
    pszName      - monitor name
    pszDllName   - dll name of the monitor
    pszEnvName   - envionment string Ex "Windows NT x86"
    pszEnvDir    - the path on disk for the environement Ex w32x86
    pIniSpooler  - cluster spooler

Return Value:

    WIN32 error code

--*/
DWORD
PropagateMonitorToCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszDLLName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    HKEY  hKeyEnvironments;
    HKEY  hKeyCurrentEnv;
    HKEY  hKeyMonitors;
    HKEY  hKeyCurrentMon;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_PRINT && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if (pszName && pszDLLName && pszEnvName && pszEnvDir)
    {
        //
        // Check if we added an entry for this lang monitor already
        // The cluster database for the spooler resource looks like:
        //
        // Parameters
        // |
        // +- Environments
        // |  |
        // |  +- Windows NT x86
        //       |
        //       +- OtherMonitors
        //          |
        //          +- Foo
        //          |  |
        //          |  +- Driver = Foo.dll
        //          |
        //          +- Bar
        //             |
        //             +- Driver = Bar.dll
        //
        if ((dwError = SplRegCreateKey(pIniSpooler->hckRoot,
                                       ipszClusterDatabaseEnvironments,
                                       0,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &hKeyEnvironments,
                                       NULL,
                                       pIniSpooler)) == ERROR_SUCCESS)
        {
            if ((dwError = SplRegCreateKey(hKeyEnvironments,
                                           pszEnvName,
                                           0,
                                           KEY_READ | KEY_WRITE,
                                           NULL,
                                           &hKeyCurrentEnv,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS)
            {
                if ((dwError = SplRegCreateKey(hKeyCurrentEnv,
                                               szClusterNonAwareMonitors,
                                               0,
                                               KEY_READ | KEY_WRITE,
                                               NULL,
                                               &hKeyMonitors,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS)
                {
                    if ((dwError = SplRegCreateKey(hKeyMonitors,
                                                   pszName,
                                                   0,
                                                   KEY_READ | KEY_WRITE,
                                                   NULL,
                                                   &hKeyCurrentMon,
                                                   NULL,
                                                   pIniSpooler)) == ERROR_SUCCESS)
                    {
                        DWORD cbNeeded = 0;

                        //
                        // Check if this driver already exists in the database
                        //
                        if ((dwError=SplRegQueryValue(hKeyCurrentMon,
                                                      L"Driver",
                                                      NULL,
                                                      NULL,
                                                      &cbNeeded,
                                                      pIniSpooler))==ERROR_MORE_DATA)
                        {
                            DBGMSG(DBG_CLUSTER, ("CopyMonitorToClusterDisks "TSTR" already exists in cluster DB\n", pszName));
                        }
                        else
                        {
                            if (RegSetString(hKeyCurrentMon,
                                             (LPWSTR)L"Driver",
                                             (LPWSTR)pszDLLName,
                                             &dwError,
                                             pIniSpooler))
                            {
                                //
                                // Copy monitor file to cluster disk
                                //
                                WCHAR szMonitor[MAX_PATH];
                                WCHAR szDestDir[MAX_PATH];

                                if (GetSystemDirectory(szMonitor, COUNTOF(szMonitor)))
                                {
                                    if ((dwError = StrNCatBuff(szMonitor,
                                                               COUNTOF(szMonitor),
                                                               szMonitor,
                                                               L"\\",
                                                               pszDLLName,
                                                               NULL)) == ERROR_SUCCESS &&
                                        (dwError = StrNCatBuff(szDestDir,
                                                               COUNTOF(szDestDir),
                                                               pIniSpooler->pszClusResDriveLetter,
                                                               L"\\",
                                                               szClusterDriverRoot,
                                                               NULL)) == ERROR_SUCCESS)
                                    {
                                        dwError = CopyFileToDirectory(szMonitor, szDestDir, pszEnvDir, NULL, NULL);
                                    }
                                }
                                else
                                {
                                    dwError = GetLastError();
                                }
                            }

                            //
                            // If anything failed, delete the entry from the database
                            //
                            if (dwError != ERROR_SUCCESS)
                            {
                                dwError = SplRegDeleteKey(hKeyMonitors, pszName, pIniSpooler);

                                DBGMSG(DBG_CLUSTER, ("CopyMonitorToClusterDisks Error %u cleaned up cluster DB\n", dwError));
                            }
                        }

                        SplRegCloseKey(hKeyCurrentMon, pIniSpooler);
                    }

                    SplRegCloseKey(hKeyMonitors, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }

            SplRegCloseKey(hKeyEnvironments, pIniSpooler);
        }
    }

    DBGMSG(DBG_CLUSTER, ("PropagateMonitorToCluster returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    InstallMonitorFromCluster

Routine Description:

    For a cluster we keep the following printing resources in the
    cluster data base: drivers, printers, ports, procs. We can also
    have cluster aware port monitors. When the spooler initializes
    those objects, it reads the data from the cluster data base.
    When we write those objects we pass a handle to a key to some
    spooler functions. (Ex WriteDriverIni) The handle is either to the
    local registry or to the cluster database. This procedure is not safe
    with language monitors. LMs keep data in the registry so you need
    to supply a handle to a key in the reg. They don't work with clusters.
    This function will do this:
    1) read an association key in the cluster data base. We will have
    information like (lm name, dll name) (see below where we store this)
    2) copy the lm dll from the cluster disk to the local disk.
    3) install the monitor with the local spooler

    Theoretically this function works for both language and port monitors.
    But it is useless when applied to port monitors.

Arguments:
    pszName      - monitor name
    pszEnvName   - envionment string Ex "Windows NT x86"
    pszEnvDir    - the path on disk for the environement Ex w32x86
    pIniSpooler  - cluster spooler

Return Value:

    WIN32 error code

--*/
DWORD
InstallMonitorFromCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    HKEY hKeyParent;
    HKEY hKeyMon;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if (pszName && pszEnvName && pszEnvDir)
    {
        HKEY hKeyEnvironments;
        HKEY hKeyCurrentEnv;
        HKEY hKeyMonitors;
        HKEY hKeyCurrentMon;

        //
        // Check if we added an entry for this lang monitor already
        // The cluster database for the spooler resource looks like:
        //
        // Parameters
        // |
        // +- Environments
        // |  |
        // |  +- Windows NT x86
        //       |
        //       +- OtherMonitors
        //          |
        //          +- Foo
        //          |  |
        //          |  +- Driver = Foo.dll
        //          |
        //          +- Bar
        //             |
        //             +- Driver = Bar.dll
        //
        if ((dwError = SplRegOpenKey(pIniSpooler->hckRoot,
                                     ipszClusterDatabaseEnvironments,
                                     KEY_READ,
                                     &hKeyEnvironments,
                                     pIniSpooler)) == ERROR_SUCCESS)
        {
            if ((dwError = SplRegOpenKey(hKeyEnvironments,
                                         pszEnvName,
                                         KEY_READ,
                                         &hKeyCurrentEnv,
                                         pIniSpooler)) == ERROR_SUCCESS)
            {
                if ((dwError = SplRegOpenKey(hKeyCurrentEnv,
                                             szClusterNonAwareMonitors,
                                             KEY_READ,
                                             &hKeyMonitors,
                                             pIniSpooler)) == ERROR_SUCCESS)
                {
                    if ((dwError = SplRegOpenKey(hKeyMonitors,
                                                 pszName,
                                                 KEY_READ,
                                                 &hKeyCurrentMon,
                                                 pIniSpooler)) == ERROR_SUCCESS)
                    {
                        LPWSTR pszDLLName = NULL;
                        DWORD  cchDLLName = 0;

                        if (RegGetString(hKeyCurrentMon,
                                         (LPWSTR)L"Driver",
                                         &pszDLLName,
                                         &cchDLLName,
                                         &dwError,
                                         TRUE,
                                         pIniSpooler))
                        {
                            //
                            // We found the monitor entry in the cluster DB
                            //
                            WCHAR szSource[MAX_PATH];
                            WCHAR szDest[MAX_PATH];

                            if (GetSystemDirectory(szDest, COUNTOF(szDest)))
                            {
                                if ((dwError = StrNCatBuff(szDest,
                                                           COUNTOF(szDest),
                                                           szDest,
                                                           L"\\",
                                                           pszDLLName,
                                                           NULL)) == ERROR_SUCCESS &&
                                    (dwError = StrNCatBuff(szSource,
                                                           COUNTOF(szSource),
                                                           pIniSpooler->pszClusResDriveLetter,
                                                           L"\\",
                                                           szClusterDriverRoot,
                                                           L"\\",
                                                           pszEnvDir,
                                                           L"\\",
                                                           pszDLLName,
                                                           NULL)) == ERROR_SUCCESS)
                                {
                                    //
                                    // Copy file from K:\PrinterDrivers\W32x86\foo.dll to
                                    // WINDIR\system32\foo.dll
                                    //
                                    if (CopyFile(szSource, szDest, FALSE))
                                    {
                                        MONITOR_INFO_2 Monitor;

                                        Monitor.pDLLName     = pszDLLName;
                                        Monitor.pName        = (LPWSTR)pszName;
                                        Monitor.pEnvironment = (LPWSTR)pszEnvName;

                                        DBGMSG(DBG_CLUSTER, ("InstallMonitorFromCluster "TSTR" copied\n", pszDLLName));

                                        //
                                        // Call AddMonitor to the local spooler
                                        //
                                        if (!SplAddMonitor(NULL, 2, (LPBYTE)&Monitor, pLocalIniSpooler))
                                        {
                                            dwError = GetLastError();
                                        }
                                    }
                                    else
                                    {
                                        dwError = GetLastError();
                                    }
                                }
                            }
                            else
                            {
                                dwError = GetLastError();
                            }
                        }

                        SplRegCloseKey(hKeyCurrentMon, pIniSpooler);
                    }

                    SplRegCloseKey(hKeyMonitors, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }

            SplRegCloseKey(hKeyEnvironments, pIniSpooler);
        }
    }

    DBGMSG(DBG_CLUSTER, ("InstallMonitorFromCluster returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyNewerOrOlderFiles

Routine Description:

    Copies all newer or older files from the source directory to the dest dir.
    If you supply a bool function that takes 2 parameters, it will apply that
    function for each copied file. func(NULL, file.) This is useful when I have
    to caopy over ICM profiles. Then I can resuse this function and have it
    install those profiles as it copies them.

Arguments:

    pszSourceDir - source directory string
    pszDestDir   - destination directory string
    pfn          - optional functin to be applied on each copied file

Return Value:

    WIN32 error code

--*/
DWORD
CopyNewerOrOlderFiles(
    IN LPCWSTR pszSourceDir,
    IN LPCWSTR pszDestDir,
    IN BOOL    (WINAPI *pfn)(LPWSTR, LPWSTR)
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszSourceDir && pszDestDir)
    {
        WCHAR szSearchPath[MAX_PATH];

        //
        // Build the search path. We look for all files
        //
        if ((dwError = StrNCatBuff(szSearchPath,
                                   COUNTOF(szSearchPath),
                                   pszSourceDir,
                                   L"\\*",
                                   NULL)) == ERROR_SUCCESS)
        {
            WIN32_FIND_DATA SourceFindData;
            HANDLE          hSourceFind;

            //
            // Find first file that meets the criteria
            //
            if ((hSourceFind = FindFirstFile(szSearchPath, &SourceFindData)) != INVALID_HANDLE_VALUE)
            {
                do
                {
                    WCHAR szMasterPath[MAX_PATH];

                    //
                    // Search for the rest of the files. We are interested in files that are not directories
                    //
                    if (!(SourceFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (dwError = StrNCatBuff(szMasterPath,
                                               COUNTOF(szMasterPath),
                                               pszDestDir,
                                               L"\\",
                                               SourceFindData.cFileName,
                                               NULL)) == ERROR_SUCCESS)
                    {
                        WIN32_FIND_DATA MasterFindData;
                        HANDLE          hMasterFind;
                        BOOL            bCopyFile = TRUE;
                        WCHAR           szFile[MAX_PATH];

                        //
                        // Check if the file found in source dir exists in the dest dir
                        //
                        if ((hMasterFind = FindFirstFile(szMasterPath, &MasterFindData)) != INVALID_HANDLE_VALUE)
                        {
                            //
                            // Do not copy file if source and dest have same time stamp
                            //
                            if (!CompareFileTime(&SourceFindData.ftLastWriteTime, &MasterFindData.ftLastWriteTime))
                            {
                                bCopyFile = FALSE;
                            }

                            FindClose(hMasterFind);
                        }

                        //
                        // File either not found in dest dir, or it has a different timp stamp
                        //
                        if (bCopyFile &&
                            (dwError = StrNCatBuff(szFile,
                                                   COUNTOF(szFile),
                                                   pszSourceDir,
                                                   L"\\",
                                                   SourceFindData.cFileName,
                                                   NULL)) == ERROR_SUCCESS &&
                            (dwError = CopyFile(szFile,
                                                szMasterPath,
                                                FALSE) ? ERROR_SUCCESS : GetLastError()) == ERROR_SUCCESS &&
                            pfn)
                        {
                            dwError = (*pfn)(NULL, szFile) ? ERROR_SUCCESS : GetLastError();
                        }
                    }

                } while (dwError == ERROR_SUCCESS && FindNextFile(hSourceFind, &SourceFindData));

                FindClose(hSourceFind);
            }
            else if ((dwError = GetLastError()) == ERROR_PATH_NOT_FOUND || dwError == ERROR_FILE_NOT_FOUND)
            {
                //
                // No directory or files, success
                //
                dwError = ERROR_SUCCESS;
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("CopyNewerOrOlderFiles returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    CopyICMFromClusterDiskToLocalDisk

Routine Description:

    Copies all newer or older files from the source directory to the destination
    directory. The source directory is the ICM directory on the cluster disk
    and the destination is the ICM directory on the local machine for the
    cluster spooler. This function will also install the icm profiles with the
    local machine/

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CopyICMFromClusterDiskToLocalDisk(
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szSource[MAX_PATH];
    WCHAR szDest[MAX_PATH];

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = StrNCatBuff(szDest,
                               COUNTOF(szDest),
                               pIniSpooler->pDir,
                               L"\\Drivers\\Color",
                               NULL)) == ERROR_SUCCESS &&
        (dwError = StrNCatBuff(szSource,
                               COUNTOF(szSource),
                               pIniSpooler->pszClusResDriveLetter,
                               L"\\",
                               szClusterDriverRoot,
                               L"\\",
                               L"Color",
                               NULL)) == ERROR_SUCCESS)
    {
        HMODULE hLib;
        typedef BOOL (WINAPI *PFN)(LPWSTR, LPWSTR);
        PFN pfn;

        //
        // Make sure the directory on the local disk exists. We will copy files
        // from K:\Printerdrivers\Color to
        // WINDIR\system32\spool\drivers\clus-spl-guid\drivers\color
        //
        CreateCompleteDirectory(szDest);

        if ((hLib = LoadLibrary(L"mscms.dll")) &&
            (pfn = (PFN)GetProcAddress(hLib, "InstallColorProfileW")))
        {
            dwError = CopyNewerOrOlderFiles(szSource, szDest, pfn);
        }
        else
        {
            dwError = GetLastError();
        }

        if (hLib)
        {
            FreeLibrary(hLib);
        }

        DBGMSG(DBG_CLUSTER, ("CopyICMFromClusterDiskToLocalDisk "TSTR" "TSTR" Error %u\n", szSource, szDest, dwError));
    }

    return dwError;
}

/*++

Routine Name

    CopyICMFromLocalDiskToClusterDisk

Routine Description:

    Copies all newer or older files from the source directory to the destination
    directory. The source directory is the ICM directory on the local machine for
    the cluster spooler. The destination is the ICM directory on the cluster disk

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CopyICMFromLocalDiskToClusterDisk(
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szSource[MAX_PATH];
    WCHAR szDest[MAX_PATH];

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = StrNCatBuff(szSource,
                               COUNTOF(szSource),
                               pIniSpooler->pDir,
                               L"\\Drivers\\Color",
                               NULL)) == ERROR_SUCCESS &&
        (dwError = StrNCatBuff(szDest,
                               COUNTOF(szDest),
                               pIniSpooler->pszClusResDriveLetter,
                               L"\\",
                               szClusterDriverRoot,
                               L"\\",
                               L"Color",
                               NULL)) == ERROR_SUCCESS &&
        //
        // Make sure the destination on the cluster disk exists. We need to create
        // it with special access rights. (only admins and system can read/write)
        //
        ((dwError = CreateProtectedDirectory(szDest)) == ERROR_SUCCESS ||
         dwError == ERROR_ALREADY_EXISTS))
    {
        dwError = CopyNewerOrOlderFiles(szSource, szDest, NULL);

        DBGMSG(DBG_CLUSTER, ("CopyICMFromLocalDiskToClusterDisk "TSTR" "TSTR" Error %u\n", szSource, szDest, dwError));
    }

    return dwError;
}

/*++

Routine Name

    CreateClusterSpoolerEnvironmentsStructure

Routine Description:

    A pIniSpooler needs a list of all possible pIniEnvironemnts. For the local
    spooler the setup creates the necessary environments keys in the registry under
    HKLM\System\CCS\Control\Print\Environments. We need to propagate the same
    structure for each cluster spooler in the cluster data base.

    Relies on the fact that pLocalIniSpooler is initialized fisrt (among all
    pinispoolers)

    This function builds the following strucutre in the cluster database

    Parameters
    |
    +- Environments
    |  |
    |  +- Windows NT x86
    |  |     (Directory = w32x86)
    |  |
    |  +- Windows 4.0
    |  |     (Directory = win40)
    |  |

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
CreateClusterSpoolerEnvironmentsStructure(
    IN PINISPOOLER pIniSpooler
    )
{
    HKEY  hEnvironmentsKey;
    DWORD dwError;

    SPLASSERT(pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER);

    if ((dwError = SplRegCreateKey(pIniSpooler->hckRoot,
                                   pIniSpooler->pszRegistryEnvironments,
                                   0,
                                   KEY_WRITE,
                                   NULL,
                                   &hEnvironmentsKey,
                                   NULL,
                                   pIniSpooler)) == ERROR_SUCCESS)
    {
        PINIENVIRONMENT pIniEnvironment;

        //
        // Loop through the environments of the local spooler
        //
        for (pIniEnvironment = pLocalIniSpooler->pIniEnvironment;
             pIniEnvironment && dwError == ERROR_SUCCESS;
             pIniEnvironment = pIniEnvironment->pNext)
        {
            HKEY hKeyCurrentEnv;

            if ((dwError = SplRegCreateKey(hEnvironmentsKey,
                                           pIniEnvironment->pName,
                                           0,
                                           KEY_WRITE,
                                           NULL,
                                           &hKeyCurrentEnv,
                                           NULL,
                                           pIniSpooler)) == ERROR_SUCCESS)
            {
                HKEY hKeyPrtProc;

                //
                // Set the value Directory (ex. = W32X86) and create
                // the print processor key
                //
                if (RegSetString(hKeyCurrentEnv,
                                 szDirectory,
                                 pIniEnvironment->pDirectory,
                                 &dwError,
                                 pIniSpooler) &&
                    (dwError = SplRegCreateKey(hKeyCurrentEnv,
                                               szPrintProcKey,
                                               0,
                                               KEY_WRITE,
                                               NULL,
                                               &hKeyPrtProc,
                                               NULL,
                                               pIniSpooler)) == ERROR_SUCCESS)
                {
                    SplRegCloseKey(hKeyPrtProc, pIniSpooler);
                }

                SplRegCloseKey(hKeyCurrentEnv, pIniSpooler);
            }
        }

        SplRegCloseKey(hEnvironmentsKey, pIniSpooler);
    }

    DBGMSG(DBG_CLUSTER, ("CreateClusterSpoolerEnvironmentsStructure returns dwError %u\n\n", dwError));

    return dwError;
}

/*++

Routine Name

    AddLocalDriverToClusterSpooler

Routine Description:

    Adds a driver that exists on the local inispooler to the cluster spooler.
    It will also add all versions of that driver. We use this function in the
    upgrade scenario. For a certain printer, we need to propage the driver
    (and all the versions of that driver) to the cluster data base and cluster
    disk.

Arguments:

    pIniSpooler - pointer to cluster spooler structure

Return Value:

    WIN32 error code

--*/
DWORD
AddLocalDriverToClusterSpooler(
    IN LPCWSTR     pszDriver,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD           dwError = ERROR_SUCCESS;
    PINIENVIRONMENT pIniEnv;
    PINIVERSION     pIniVer;

    SplInSem();

    //
    // Traverse all environments and versions
    //
    for (pIniEnv=pLocalIniSpooler->pIniEnvironment; pIniEnv; pIniEnv=pIniEnv->pNext)
    {
        for (pIniVer=pIniEnv->pIniVersion; pIniVer; pIniVer=pIniVer->pNext)
        {
            PINIDRIVER pIniDriver = (PINIDRIVER)FindIniKey((PINIENTRY)pIniVer->pIniDriver, (LPWSTR)pszDriver);

            if (pIniDriver)
            {
                DRIVER_INFO_6 DriverInfo        = {0};
                WCHAR         szDriverFile[MAX_PATH];
                WCHAR         szDataFile[MAX_PATH];
                WCHAR         szConfigFile[MAX_PATH];
                WCHAR         szHelpFile[MAX_PATH];
                WCHAR         szPrefix[MAX_PATH];
                LPWSTR        pszzDependentFiles = NULL;

                //
                // Get fully qualified driver file paths. We will call add printer
                // driver without using the scratch directory
                //
                if ((dwError = StrNCatBuff(szDriverFile,
                                           COUNTOF(szDriverFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,   L"\\",
                                           pIniEnv->pDirectory,  L"\\",
                                           pIniVer->szDirectory, L"\\",
                                           pIniDriver->pDriverFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szDataFile,
                                           COUNTOF(szDataFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,    L"\\",
                                           pIniEnv->pDirectory,   L"\\",
                                           pIniVer->szDirectory,  L"\\",
                                           pIniDriver->pDataFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szConfigFile,
                                           COUNTOF(szConfigFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,      L"\\",
                                           pIniEnv->pDirectory,     L"\\",
                                           pIniVer->szDirectory,    L"\\",
                                           pIniDriver->pConfigFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szHelpFile,
                                           COUNTOF(szHelpFile),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,    L"\\",
                                           pIniEnv->pDirectory,   L"\\",
                                           pIniVer->szDirectory,  L"\\",
                                           pIniDriver->pHelpFile,
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrNCatBuff(szPrefix,
                                           COUNTOF(szPrefix),
                                           pLocalIniSpooler->pDir,
                                           szDriversDirectory,   L"\\",
                                           pIniEnv->pDirectory,  L"\\",
                                           pIniVer->szDirectory, L"\\",
                                           NULL)) == ERROR_SUCCESS &&
                    (dwError = StrCatPrefixMsz(szPrefix,
                                               pIniDriver->pDependentFiles,
                                               &pszzDependentFiles)) == ERROR_SUCCESS)
                {
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szDriverFile "TSTR"\n", szDriverFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szDataFile   "TSTR"\n", szDataFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szConfigFile "TSTR"\n", szConfigFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szHelpFile   "TSTR"\n", szHelpFile));
                    DBGMSG(DBG_CLUSTER, ("AddLocalDrv   szPrefix     "TSTR"\n", szPrefix));

                    DriverInfo.pDriverPath        = szDriverFile;
                    DriverInfo.pName              = pIniDriver->pName;
                    DriverInfo.pEnvironment       = pIniEnv->pName;
                    DriverInfo.pDataFile          = szDataFile;
                    DriverInfo.pConfigFile        = szConfigFile;
                    DriverInfo.cVersion           = pIniDriver->cVersion;
                    DriverInfo.pHelpFile          = szHelpFile;
                    DriverInfo.pMonitorName       = pIniDriver->pMonitorName;
                    DriverInfo.pDefaultDataType   = pIniDriver->pDefaultDataType;
                    DriverInfo.pDependentFiles    = pszzDependentFiles;
                    DriverInfo.pszzPreviousNames  = pIniDriver->pszzPreviousNames;
                    DriverInfo.pszMfgName         = pIniDriver->pszMfgName;
                    DriverInfo.pszOEMUrl          = pIniDriver->pszOEMUrl;
                    DriverInfo.pszHardwareID      = pIniDriver->pszHardwareID;
                    DriverInfo.pszProvider        = pIniDriver->pszProvider;
                    DriverInfo.dwlDriverVersion   = pIniDriver->dwlDriverVersion;
                    DriverInfo.ftDriverDate       = pIniDriver->ftDriverDate;

                    LeaveSplSem();

                    if (!SplAddPrinterDriverEx(NULL,
                                               6,
                                               (LPBYTE)&DriverInfo,
                                               APD_COPY_NEW_FILES,
                                               pIniSpooler,
                                               FALSE,
                                               DO_NOT_IMPERSONATE_USER))
                    {
                        dwError = GetLastError();
                    }

                    EnterSplSem();
                }

                FreeSplMem(pszzDependentFiles);

                DBGMSG(DBG_CLUSTER, ("AddLocalDrv Env "TSTR" Ver "TSTR" Name "TSTR" Error %u\n",
                                     pIniEnv->pName, pIniVer->pName, pszDriver, dwError));
            }
        }
    }

    return dwError;
}

/*++

Routine Name

    StrCatPerfixMsz

Routine Description:

    Take a prefix which is a string Ex "C:\windows\" and a multi sz Ex: "a0b00"
    It will create: c:\windows\a0c:\windows\b00
    The prefix must have a trailing "\".

Arguments:

    pszPrefix - string to prefix all the strings in the msz
    pszzFiles - msz of files
    ppszzFullPathFiles - out param

Return Value:

    WIN32 error code

--*/
DWORD
StrCatPrefixMsz(
    IN  LPCWSTR  pszPrefix,
    IN  LPWSTR   pszzFiles,
    OUT LPWSTR  *ppszzFullPathFiles
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszPrefix && ppszzFullPathFiles)
    {
        *ppszzFullPathFiles = NULL;

        if (pszzFiles)
        {
            WCHAR  szNewPath[MAX_PATH] = {0};
            LPWSTR psz;
            LPWSTR pszReturn;
            LPWSTR pszTemp;
            DWORD  cbNeeded   = 0;
            SIZE_T cchStrings = 0;
            DWORD  dwPrifxLen = wcslen(pszPrefix);

            //
            // We count the number of character of the string
            // that we need to allocate
            //
            for (psz = pszzFiles; psz && *psz;)
            {
                DWORD dwLen = wcslen(psz);

                cbNeeded += dwPrifxLen + dwLen + 1;

                psz += dwLen + 1;
            }

            //
            // Count the number of strings needed to do the string cat, not
            // counting the null (since we will always append it but allocate
            // one more).
            //
            cchStrings = cbNeeded;

            //
            // Final \0 of the multi sz
            //
            cbNeeded++;

            //
            // Convert to number of bytes
            //
            cbNeeded *= sizeof(WCHAR);

            if (pszReturn = AllocSplMem(cbNeeded))
            {
                for (psz = pszzFiles, pszTemp = pszReturn; psz && *psz; )
                {
                    StringCchCopyEx(pszTemp, cchStrings, pszPrefix, &pszTemp, &cchStrings, 0);
                    StrCchCopyMultipleStr(pszTemp, cchStrings, psz, &pszTemp, &cchStrings);

                    psz += wcslen(psz) + 1;
                }

                //
                // Outgoing, we have preallocated this final NULL.
                //
                pszTemp = L'\0';

                //
                // Set out param
                //
                *ppszzFullPathFiles = pszReturn;

                dwError = ERROR_SUCCESS;
            }
            else
            {
                dwError = GetLastError();
            }
        }
        else
        {
            //
            // NULL input multi sz, nothing to do
            //
            dwError = ERROR_SUCCESS;
        }
    }

    DBGMSG(DBG_CLUSTER, ("StrCatPerfixMsz returns %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ClusterSplReadUpgradeKey

Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may
    not be actie at all. Thus the resdll writes a value in the local
    registry. The vaue name is the GUID for the spooler resource, the
    value is DWORD 1. When the cluster spooler resource fails over on this
    machine it (i.e. now) it queries for that value to know if it needs
    to preform post upgrade operations, like upgrading the printer drivers.

Arguments:

    pszResource - string respresenation of GUID for the cluster resource
    pdwVlaue    - will contain the value in the registry for the GUID

Return Value:

    WIN32 error code

--*/
DWORD
ClusterSplReadUpgradeKey(
    IN  LPCWSTR pszResourceID,
    OUT LPDWORD pdwValue
    )
{
    DWORD dwError   = ERROR_INVALID_PARAMETER;
    HKEY  hkRoot    = NULL;
    HKEY  hkUpgrade = NULL;

    if (pszResourceID && pdwValue)
    {
        *pdwValue = 0;

        if ((dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                    0,
                                    KEY_READ,
                                    &hkRoot)) == ERROR_SUCCESS &&
            (dwError = RegOpenKeyEx(hkRoot,
                                    SPLREG_CLUSTER_UPGRADE_KEY,
                                    0,
                                    KEY_READ,
                                    &hkUpgrade)) == ERROR_SUCCESS)
        {
            DWORD cbNeeded = sizeof(DWORD);

            dwError = RegQueryValueEx(hkUpgrade, pszResourceID, NULL, NULL, (LPBYTE)pdwValue, &cbNeeded);
        }

        if (hkUpgrade) RegCloseKey(hkUpgrade);
        if (hkRoot)    RegCloseKey(hkRoot);

        //
        // Regardless of what happened, return success
        //
        dwError = ERROR_SUCCESS;
    }

    return dwError;

}

/*++

Routine Name

    ClusterSplReadUpgradeKey

Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may
    not be actie at all. Thus the resdll writes a value in the local
    registry. The vaue name is the GUID for the spooler resource, the
    value is DWORD 1. When the cluster spooler resource fails over on this
    machine it (i.e. now) it queries for that value to know if it needs
    to preform post upgrade operations, like upgrading the printer drivers.
    After the spooler preforms upgrade taks, it will delete the value
    corresponding to its GUID. Also if that value is the only one under the
    SPLREG_CLUSTER_UPGRADE_KEY key, it will delete that key.

Arguments:

    pszResource - string respresenation of GUID for the cluster resource

Return Value:

    WIN32 error code

--*/
DWORD
ClusterSplDeleteUpgradeKey(
    IN LPCWSTR pszResourceID
    )
{
    DWORD dwError   = ERROR_INVALID_PARAMETER;
    HKEY  hkRoot    = NULL;
    HKEY  hkUpgrade = NULL;

    if ((dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                0,
                                KEY_READ,
                                &hkRoot)) == ERROR_SUCCESS &&
        (dwError = RegOpenKeyEx(hkRoot,
                                SPLREG_CLUSTER_UPGRADE_KEY,
                                0,
                                KEY_READ | KEY_WRITE,
                                &hkUpgrade)) == ERROR_SUCCESS)
    {
        DWORD cValues = 0;

        dwError = RegDeleteValue(hkUpgrade, pszResourceID);

        if (RegQueryInfoKey(hkUpgrade,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &cValues,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS && !cValues)
        {
            RegDeleteKey(hkRoot, SPLREG_CLUSTER_UPGRADE_KEY);
        }

        if (hkUpgrade) RegCloseKey(hkUpgrade);
        if (hkRoot)    RegCloseKey(hkRoot);
    }

    return dwError;
}

/*++

Routine Name

    RunProcess

Routine Description:

    Creates a process. Waits for it to terminate.

Arguments:

    pszExe      - program to execute (muist be fully qualfied)
    pszCommand  - command line to execute
    dwTimeOut   - time to wait for the process to terminate
    pszExitCode - pointer to reveice exit code of process

Return Value:

    WIN32 error code

--*/
DWORD
RunProcess(
    IN  LPCWSTR pszExe,
    IN  LPCWSTR pszCommand,
    IN  DWORD   dwTimeOut,
    OUT LPDWORD pdwExitCode OPTIONAL
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszCommand && pszExe)
    {
        HANDLE hToken = RevertToPrinterSelf();

        if (hToken)
        {
            PROCESS_INFORMATION ProcInfo  = {0};
            STARTUPINFO         StartInfo = {0};
    
            StartInfo.cb = sizeof(StartInfo);
            StartInfo.dwFlags = 0;
    
            if (!CreateProcess(pszExe,
                               (LPWSTR)pszCommand,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_NO_WINDOW,
                               NULL,
                               NULL,
                               &StartInfo,
                               &ProcInfo))
            {
                dwError = GetLastError();
            }
            else
            {
                if (WaitForSingleObject(ProcInfo.hProcess, dwTimeOut) == WAIT_OBJECT_0)
                {
                    //
                    // Process executed fine
                    //
                    dwError = ERROR_SUCCESS;
                }
    
                if (pdwExitCode && !GetExitCodeProcess(ProcInfo.hProcess, pdwExitCode))
                {
                    *pdwExitCode = 0;
                }
    
                CloseHandle(ProcInfo.hThread);
                CloseHandle(ProcInfo.hProcess);
            }

            if (!ImpersonatePrinterClient(hToken))
            {
                dwError = GetLastError();
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }

    return dwError;
}

/*++

Routine Name

    GetLocalArchEnv

Routine Description:

    Helper function. Returns a pointer to the environment
    that matches the architecture of the local machine.
    The environemnt is taken off the pInSpooler passed as
    argument

Arguments:

    pIniSpooler - pointer to spooler structure

Return Value:

    PINIENVIRONMENT

--*/
PINIENVIRONMENT
GetLocalArchEnv(
    IN PINISPOOLER pIniSpooler
    )
{
    SplInSem();

    //
    // The local spooler and cluster spooler do not share the same Environment structures.
    //
    return pIniSpooler && pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER ?
           FindEnvironment(szEnvironment, pIniSpooler) : pThisEnvironment;
}

/*++

Routine Name

    ClusterFindLanguageMonitor

Routine Description:

    If a valid monitor name is specified and the monitor
    is not found in the specified pIniSpooler, then the
    function will try to install the monitor from the
    cluster disk.

Arguments:

    pszMonitor  - monitor name
    pszEnvName  - name of environment of the lm
    pIniSpooler - pointer to cluster spooler structure

Return Value:

    Win32 error code

--*/
DWORD
ClusterFindLanguageMonitor(
    IN LPCWSTR     pszMonitor,
    IN LPCWSTR     pszEnvName,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // This is the moment where we check if we need to add the monitor
    //
    if (pszMonitor && *pszMonitor)
    {
        PINIMONITOR pIniLangMonitor;

        EnterSplSem();

        //
        // We need to find the language monitor in pLocalIniSpooler
        // LMs are not cluster aware, so the cluster pIniSpooler doesn't know about them
        //
        pIniLangMonitor = FindMonitor(pszMonitor, pLocalIniSpooler);

        LeaveSplSem();

        if (!pIniLangMonitor)
        {
            PINIENVIRONMENT pIniEnvironment;

            EnterSplSem();
            pIniEnvironment = FindEnvironment(pszEnvName, pIniSpooler);
            LeaveSplSem();

            if (pIniEnvironment)
            {
                DBGMSG(DBG_CLUSTER, ("ClusterFindLanguageMonitor Trying to install LangMonitor "TSTR"\n", pszMonitor));

                //
                // We try to install the monitor from the cluster disk to the local spooler
                //
                dwError = InstallMonitorFromCluster(pszMonitor,
                                                    pIniEnvironment->pName,
                                                    pIniEnvironment->pDirectory,
                                                    pIniSpooler);
            }
            else
            {
                dwError = ERROR_INVALID_ENVIRONMENT;
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterFindLanguageMonitor LangMonitor "TSTR" return Win32 error %u\n", pszMonitor, dwError));

    return dwError;
}

/*++

Routine Name

    WriteTimeStamp

Routine Description:

    Opens the key hkRoot\pszSubkey1\...\pszSubKey5
    and writes the value of szClusDrvTimeStamp (binary
    data representing a system time)

Arguments:
    hkRoot      - handle to driver key
    SysTime     - system time structure
    pszSubKey1  - subkey of the root key
    pszSubKey2  - subkey of key1, can be null
    pszSubKey3  - subkey of key2, can be null
    pszSubKey4  - subkey of key3, can be null
    pszSubKey5  - subkey of key4, can be null
    pIniSpooler - spooler, can be NULL

Return Value:

    WIN32 error code

--*/
DWORD
WriteTimeStamp(
    IN HKEY        hkRoot,
    IN SYSTEMTIME  SysTime,
    IN LPCWSTR     pszSubKey1,
    IN LPCWSTR     pszSubKey2,
    IN LPCWSTR     pszSubKey3,
    IN LPCWSTR     pszSubKey4,
    IN LPCWSTR     pszSubKey5,
    IN PINISPOOLER pIniSpooler
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (hkRoot)
    {
        LPCWSTR ppszKeyNames[] = {NULL,   pszSubKey1, pszSubKey2, pszSubKey3, pszSubKey4, pszSubKey5};
        HKEY    pKeyHandles[]  = {hkRoot, NULL,       NULL,       NULL,       NULL,       NULL};
        DWORD   uIndex;

        dwError = ERROR_SUCCESS;

        //
        // Open all the keys
        //
        for (uIndex = 1;
             uIndex < COUNTOF(ppszKeyNames) &&
             dwError == ERROR_SUCCESS       &&
             ppszKeyNames[uIndex];
             uIndex++)
        {
            DBGMSG(DBG_CLUSTER, ("KEY "TSTR"\n", ppszKeyNames[uIndex]));

            dwError = SplRegCreateKey(pKeyHandles[uIndex-1],
                                      ppszKeyNames[uIndex],
                                      0,
                                      KEY_WRITE,
                                      NULL,
                                      &pKeyHandles[uIndex],
                                      NULL,
                                      pIniSpooler);
        }

        //
        // If we opened successfully the keys that we wanted, write the value
        //
        if (dwError == ERROR_SUCCESS &&
            !RegSetBinaryData(pKeyHandles[uIndex-1],
                              szClusDrvTimeStamp,
                              (LPBYTE)&SysTime,
                              sizeof(SysTime),
                              &dwError,
                              pIniSpooler))
        {
            dwError = GetLastError();
        }

        //
        // Close any keys that we opened
        //
        for (uIndex = 1; uIndex < COUNTOF(ppszKeyNames); uIndex++)
        {
            if (pKeyHandles[uIndex])
            {
                SplRegCloseKey(pKeyHandles[uIndex], pIniSpooler);
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("WriteTimeStamp returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ReadTimeStamp

Routine Description:

    Opens the key hkRoot\pszSubkey1\...\pszSubKey5
    and reads the value of szClusDrvTimeStamp (binary
    data representing a system time)

Arguments:
    hkRoot      - handle to driver key
    pSysTime    - pointer to allocated system time structure
    pszSubKey1  - subkey of the root key
    pszSubKey2  - subkey of key1, can be null
    pszSubKey3  - subkey of key2, can be null
    pszSubKey4  - subkey of key3, can be null
    pszSubKey5  - subkey of key4, can be null
    pIniSpooler - spooler, can be NULL

Return Value:

    WIN32 error code

--*/
DWORD
ReadTimeStamp(
    IN     HKEY        hkRoot,
    IN OUT SYSTEMTIME *pSysTime,
    IN     LPCWSTR     pszSubKey1,
    IN     LPCWSTR     pszSubKey2,
    IN     LPCWSTR     pszSubKey3,
    IN     LPCWSTR     pszSubKey4,
    IN     LPCWSTR     pszSubKey5,
    IN     PINISPOOLER pIniSpooler
    )
{
    DWORD  dwError = ERROR_INVALID_PARAMETER;

    if (hkRoot && pSysTime)
    {
        LPCWSTR ppszKeyNames[] = {NULL,   pszSubKey1, pszSubKey2, pszSubKey3, pszSubKey4, pszSubKey5};
        HKEY    pKeyHandles[]  = {hkRoot, NULL,       NULL,       NULL,       NULL,       NULL};
        DWORD   uIndex;

        dwError = ERROR_SUCCESS;

        //
        // Open all the keys
        //
        for (uIndex = 1;
             uIndex < COUNTOF(ppszKeyNames) &&
             dwError == ERROR_SUCCESS       &&
             ppszKeyNames[uIndex];
             uIndex++)
        {
            dwError = SplRegCreateKey(pKeyHandles[uIndex-1],
                                      ppszKeyNames[uIndex],
                                      0,
                                      KEY_WRITE | KEY_READ,
                                      NULL,
                                      &pKeyHandles[uIndex],
                                      NULL,
                                      pIniSpooler);
        }

        //
        // If we opened successfully the keys that we wanted, write the value
        //
        if (dwError == ERROR_SUCCESS)
        {
            DWORD   cbSize = sizeof(SYSTEMTIME);

            dwError = SplRegQueryValue(pKeyHandles[uIndex-1],
                                       szClusDrvTimeStamp,
                                       NULL,
                                       (LPBYTE)pSysTime,
                                       &cbSize,
                                       pIniSpooler);
        }

        //
        // Close any keys that we opened
        //
        for (uIndex = 1; uIndex < COUNTOF(ppszKeyNames); uIndex++)
        {
            if (pKeyHandles[uIndex])
            {
                SplRegCloseKey(pKeyHandles[uIndex], pIniSpooler);
            }
        }
    }

    DBGMSG(DBG_CLUSTER, ("ReadTimeStamp returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name

    ClusterCheckDriverChanged

Routine Description:

    Helper function for spooler start up. When we have a cluster spooler
    and we build the environments and drivers, we need to check if the
    drivers on the local machine (in print$\GUID) are in sync with the
    drivers on the cluster disk. We store a time stamp in the cluster
    data base. The time stamp indicate when the last update on the driver
    occured. The same type of time stamp is stroed in the lcoal registry
    (for our cluster spooler). If the 2 time stamp are different, then
    we need to call an add printer driver and use data from the cluster
    disk. The drivers on the cluster spooler were updated while it was
    running on a different node.

Arguments:

    hClusterVersionKey - handle to the driver version key
    pszDriver          - driver name
    pszEnv             - driver environment name
    pszVer             - driver version name
    pIniSpooler        - spooler

Return Value:

    TRUE  - if the driver on the cluster disk is updated and we need to
            call add printer driver. If anything fails in this function,
            then we also return TRUE, to force our caller to update/add
            the driver in question.
    FALSE - if the drivers on the local mahcine and the cluster spooler
            are in sync

--*/
BOOL
ClusterCheckDriverChanged(
    IN HKEY        hClusterVersionKey,
    IN LPCWSTR     pszDriver,
    IN LPCWSTR     pszEnv,
    IN LPCWSTR     pszVer,
    IN PINISPOOLER pIniSpooler
    )
{
    BOOL bReturn = TRUE;

    if (hClusterVersionKey &&
        pszDriver &&
        pszEnv &&
        pszVer)
    {
        SYSTEMTIME ClusterTime;
        SYSTEMTIME NodeTime;

        if (ReadTimeStamp(hClusterVersionKey,
                          &ClusterTime,
                          pszDriver,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          pIniSpooler) == ERROR_SUCCESS &&
            ReadTimeStamp(HKEY_LOCAL_MACHINE,
                          &NodeTime,
                          ipszRegistryClusRepository,
                          pIniSpooler->pszClusResID,
                          pszEnv,
                          pszVer,
                          pszDriver,
                          NULL) == ERROR_SUCCESS &&
            !memcmp(&ClusterTime, &NodeTime, sizeof(SYSTEMTIME)))
        {
            bReturn = FALSE;
        }
    }

    DBGMSG(DBG_CLUSTER, ("ClusterCheckDriverChanged returns bool %u\n", bReturn));

    return bReturn;
}


/*++

Routine Name

    IsLocalFile

Routine Description:

    Checks if a file is on the local machine. If the file path is
    "\\machinename\sharename\...\filename" then machinename is checked
    against pIniSpooler->pMachineName and alternate names for
    pIniSpooler->pMachineName.

Arguments:

    pszFileName  - file name
    pIniSpooler  - INISPOOLER structure

Return Value:

    TRUE if the file is placed locally.
    FALSE if the file is placed remotely.

--*/
BOOL
IsLocalFile (
    IN  LPCWSTR     pszFileName,
    IN  PINISPOOLER pIniSpooler
    )
{
    LPWSTR  pEndOfMachineName, pMachineName;
    BOOL    bRetValue = TRUE;

    if (pszFileName &&
        *pszFileName == L'\\' &&
        *(pszFileName+1) == L'\\')
    {
        //
        // If first 2 charactes in pszFileName are '\\',
        // then search for the next '\\'. If found, then set it to 0,
        // to isolate the machine name.
        //

        pMachineName = (LPWSTR)pszFileName;

        if (pEndOfMachineName = wcschr(pszFileName + 2, L'\\'))
        {
            *pEndOfMachineName = 0;
        }

        bRetValue = CheckMyName(pMachineName, pIniSpooler);
        //
        // Restore pszFileName.
        //
        if (pEndOfMachineName)
        {
            *pEndOfMachineName = L'\\';
        }
    }

    return bRetValue;
}

/*++

Routine Name

    IsEXEFile

Routine Description:

    Checks if a file is a executable.
    The check is made against file extension, which isn't quite
    accurate.

Arguments:

    pszFileName  - file name

Return Value:

    TRUE if the file extension is either .EXE or .DLL

--*/
BOOL
IsEXEFile(
    IN  LPCWSTR  pszFileName
    )
{
    BOOL    bRetValue = FALSE;
    DWORD   dwLength;
    LPWSTR  pszExtension;

    if (pszFileName && *pszFileName)
    {
        dwLength = wcslen(pszFileName);

        if (dwLength > COUNTOF(L".EXE") - 1)
        {
            pszExtension = (LPWSTR)pszFileName + dwLength - (COUNTOF(L".EXE") - 1);

            if (_wcsicmp(pszExtension , L".EXE") == 0 ||
                _wcsicmp(pszExtension , L".DLL") == 0)
            {
                bRetValue = TRUE;
            }
        }
    }

    return bRetValue;
}


/*++

Routine Name

    PackStringToEOB

Routine Description:

    Copies a string to the end of buffer.
    The buffer must be big enough so that it can hold the string.
    This function is called by Get/Enum APIs that build BLOB buffers to
    send them with RPC.

Arguments:

    pszSource  - string to by copied to the end of buffer
    pEnd       - a pointer to the end of a pre-allocated buffer.

Return Value:

    The pointer to the end of buffer after the sting was appended.
    NULL if an error occured.

--*/
LPBYTE
PackStringToEOB(
    IN  LPWSTR pszSource,
    IN  LPBYTE pEnd
    )
{
    DWORD cbStr;

    //
    // Align the end of buffer to WORD boundaries.
    //
    WORD_ALIGN_DOWN(pEnd);

    if (pszSource && pEnd)
    {
        cbStr = (wcslen(pszSource) + 1) * sizeof(WCHAR);

        pEnd -= cbStr;

        CopyMemory(pEnd, pszSource, cbStr);
    }
    else
    {
        pEnd = NULL;
    }
    return pEnd;

}


LPVOID
MakePTR (
    IN  LPVOID pBuf,
    IN  DWORD  Quantity
    )

/*++

Routine Name

    MakePTR

Routine Description:

   Makes a pointer by adding a quantity to the beginning of a buffer.

Arguments:

    pBuf    -   pointer to buffer
    DWORD   -   quantity

Return Value:

   LPVOID pointer

--*/
{
    return (LPVOID)((ULONG_PTR)pBuf + (ULONG_PTR)Quantity);
}

DWORD
MakeOffset (
    IN  LPVOID pFirst,
    IN  LPVOID pSecond
    )

/*++

Routine Name

    MakeOffset

Routine Description:

    Substarcts two pointers.

Arguments:

    pFirst    -   pointer to buffer
    pSecond   -   pointer to buffer

Return Value:

    DWORD

--*/
{
    return (DWORD)((ULONG_PTR)pFirst - (ULONG_PTR)pSecond);
}

/*++

Routine Name

    IsValidPrinterName

Routine Description:

    Checks if a string is a valid printer name.

Arguments:

    pszPrinter - pointer to string
    cchMax     - max number of chars to scan

Return Value:

    TRUE  - the string is a valid printer name
    FALSE - the string is a invalid printer name. The function set the last error
            to ERROR_INVALID_PRINTER_NAME in this case

--*/
BOOL
IsValidPrinterName(
    IN LPCWSTR pszPrinter,
    IN DWORD   cchMax
    )
{
    DWORD Error = ERROR_INVALID_PRINTER_NAME;

    //
    // A printer name is of the form:
    //
    // \\s\p or p
    //
    // The name cannot contain the , character. Note that the add printer
    // wizard doesn't accept "!" as a valid printer name. We wanted to do
    // the same here, but we regressed in app compat with 9x apps.
    // The number of \ in the name is 0 or 3
    // If the name contains \, then the fist 2 chars must be \.
    // The printer name cannot end in \.
    // After leading "\\" then next char must not be \
    // The minimum length is 1 character
    // The maximum length is MAX_UNC_PRINTER_NAME
    //
    if (pszPrinter && !IsBadStringPtr(pszPrinter, cchMax) && *pszPrinter)
    {
        UINT    uSlashCount = 0;
        UINT    uLen        = 0;
        LPCWSTR p;

        Error = ERROR_SUCCESS;

        //
        // Count characters
        //
        for (p = pszPrinter; *p && uLen <= cchMax; p++, uLen++)
        {
            if (*p == L',')
            {
                Error = ERROR_INVALID_PRINTER_NAME;
                break;
            }
            else if (*p == L'\\')
            {
                uSlashCount++;
            }
        }

        //
        // Perform validation
        //
        if (Error == ERROR_SUCCESS &&

             //
             // Validate length
             //
            (uLen > cchMax ||

             //
             // The printer name has either no \, or exactly 3 \.
             //
             uSlashCount && uSlashCount != 3 ||

             //
             // A printer name that contains 3 \, must have the first 2 chars \ and the 3 not \.
             // The last char cannot be \.
             // Ex "\Foo", "F\oo", "\\\Foo", "\\Foo\" are invalid.
             // Ex. "\\srv\bar" is valid.
             //
             uSlashCount == 3 && (pszPrinter[0]      != L'\\' ||
                                  pszPrinter[1]      != L'\\' ||
                                  pszPrinter[2]      == L'\\' ||
                                  pszPrinter[uLen-1] == L'\\')))
        {
            Error = ERROR_INVALID_PRINTER_NAME;
        }
    }

    SetLastError(Error);

    return Error == ERROR_SUCCESS;
}

/*++

Routine Name

    SplPowerEvent

Routine Description:

    Checks if the spooler is ready for power management events like hibernation/stand by.
    If we have printing jobs that are not in an error state or offline, then we deny the
    powering down request.

Arguments:

    Event - power management event

Return Value:

    TRUE  - the spooler allowed the system to be powered down
    FALSE - the spooler denies the request for powering down

--*/
BOOL
SplPowerEvent(
    DWORD Event
    )
{
    BOOL bAllow = TRUE;

    EnterSplSem();

    switch (Event)
    {
        case PBT_APMQUERYSUSPEND:
        {
            PINISPOOLER pIniSpooler;

            for (pIniSpooler = pLocalIniSpooler;
                 pIniSpooler && bAllow;
                 pIniSpooler = pIniSpooler->pIniNextSpooler)
            {
                PINIPRINTER pIniPrinter;

                for (pIniPrinter = pIniSpooler->pIniPrinter;
                     pIniPrinter && bAllow;
                     pIniPrinter = pIniPrinter->pNext)
                {
                    PINIJOB pIniJob;

                    for (pIniJob = pIniPrinter->pIniFirstJob;
                         pIniJob && bAllow;
                         pIniJob = pIniJob->pIniNextJob)
                    {
                        if (pIniJob->Status & JOB_PRINTING &&
                            !(pIniJob->Status & JOB_ERROR | pIniJob->Status & JOB_OFFLINE))
                        {
                            bAllow = FALSE;
                        }
                    }
                }
            }

            //
            // If we allow system power down, then we need to stop scheduling jobs
            //
            if (bAllow)
            {
                ResetEvent(PowerManagementSignal);
            }

            break;
        }

        case PBT_APMQUERYSUSPENDFAILED:
        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMEAUTOMATIC:

            //
            // Set the event to allow the spooler to continue scheudling jobs
            //
            SetEvent(PowerManagementSignal);
            break;

        default:

            //
            // We ignore any other power management event
            //
            break;
    }

    LeaveSplSem();

    return bAllow;
}

/*++

Routine Name

    IsCallViaRPC

Routine Description:

    Checks if the caller of this function came in the spooler server via RPC or not.

Arguments:

    None

Return Value:

    TRUE  - the caller came in via RPC
    FALSE - the caller did not come via RPC

--*/
BOOL
IsCallViaRPC(
    IN VOID
    )
{
    UINT uType;

    return I_RpcBindingInqTransportType(NULL, &uType) == RPC_S_NO_CALL_ACTIVE ? FALSE : TRUE;
}

/*++

Routine Name

    MergeMultiSz

Routine Description:

    This merges two multisz strings such that there is a resulting multisz
    string that has no duplicate strings internally. This algorithm is
    currently N^2 which could be improved. It is currently being called from
    the driver code and the dependent files are not a large set.

Arguments:

    pszMultiSz1         -   The first multi-sz string.
    cchMultiSz1         -   The length of the multi-sz string.
    pszMultiSz2         -   The second multi-sz string.
    cchMultiSz2         -   The length of the second multi-sz string.
    ppszMultiSzMerge    -   The merged multi-sz string.
    pcchMultiSzMerge    -   The number of characters in the merge, this could be
                            less than the allocated buffer size.

Return Value:

    FALSE on failure, LastError is set.

--*/
BOOL
MergeMultiSz(
    IN      PCWSTR              pszMultiSz1,
    IN      DWORD               cchMultiSz1,
    IN      PCWSTR              pszMultiSz2,
    IN      DWORD               cchMultiSz2,
        OUT PWSTR               *ppszMultiSzMerge,
        OUT DWORD               *pcchMultiSzMerge       OPTIONAL
    )
{
    BOOL    bRet          = FALSE;
    PWSTR   pszNewMultiSz = NULL;
    DWORD   cchNewMultiSz = 0;

    *ppszMultiSzMerge = NULL;

    if (pcchMultiSzMerge)
    {
        *pcchMultiSzMerge = 0;
    }

    if (cchMultiSz1 || cchMultiSz2)
    {
        //
        // Code assumes that these are at least 1 in the allocation size.
        //
        cchMultiSz1 = cchMultiSz1 == 0 ? 1 : cchMultiSz1;
        cchMultiSz2 = cchMultiSz2 == 0 ? 1 : cchMultiSz2;

        //
        // The merged strings will be at most the size of both of them (if there are
        // no duplicates).
        //
        pszNewMultiSz = AllocSplMem((cchMultiSz1 + cchMultiSz2 - 1) * sizeof(WCHAR));

        bRet = pszNewMultiSz != NULL;

        if (bRet)
        {
            //
            // Ensure that the multi-sz string is at least empty.
            //
            *pszNewMultiSz = L'\0';
        }

        if (bRet && pszMultiSz1)
        {
            bRet = AddMultiSzNoDuplicates(pszMultiSz1, pszNewMultiSz, cchMultiSz1 + cchMultiSz2 - 1);
        }

        if (bRet && pszMultiSz2)
        {
            bRet = AddMultiSzNoDuplicates(pszMultiSz2, pszNewMultiSz, cchMultiSz1 + cchMultiSz2 - 1);
        }

        if (bRet)
        {
            cchNewMultiSz = GetMultiSZLen(pszNewMultiSz);
        }
    }

    if (bRet)
    {
        *ppszMultiSzMerge = pszNewMultiSz;

        if (pcchMultiSzMerge)
        {
            *pcchMultiSzMerge = cchNewMultiSz;
        }

        pszNewMultiSz = NULL;
    }

    FreeSplMem(pszNewMultiSz);

    return bRet;
}

/*++

Routine Name

    AddMultiSzNoDuplicates

Routine Description:

    This adds all of the strings in a multisz string to a buffer (the buffer
    must be guaranteed to be large enough to accept the strings), it makes
    sure that there are no case insensitive duplicates in the list.

Arguments:

    pszMultiSzIn    -   The multi-sz whose elements are being added.
    pszNewMultiSz   -   The buffer in which we are filling up the multi-sz
    cchMultiSz      -   The size of the multi-sz buffer.

Return Value:

    None.

--*/
BOOL
AddMultiSzNoDuplicates(
    IN      PCWSTR              pszMultiSzIn,
    IN  OUT PWSTR               pszNewMultiSz,
    IN      DWORD               cchMultiSz
    )
{
    PCWSTR pszIn         = NULL;
    BOOL   bRet          = TRUE;

    for(pszIn = pszMultiSzIn; *pszIn; pszIn += wcslen(pszIn) + 1)
    {
        BOOL            bStringFound = FALSE;
        PWSTR           pszMerge     = NULL;
        SIZE_T          cchNewMultiSz= cchMultiSz;

        //
        // For each input string, run the merged multi-sz string and add it if
        // it is not already there.
        //
        for(pszMerge = pszNewMultiSz; *pszMerge; pszMerge += wcslen(pszMerge) + 1, cchNewMultiSz -= wcslen(pszMerge) + 1)
        {
            if (!_wcsicmp(pszIn, pszMerge))
            {
                bStringFound = TRUE;
                break;
            }
        }

        //
        // If the string was not found in the multisz string, then add it to the end.
        //
        if (!bStringFound)
        {
            SIZE_T  cchRemaining = 0;

            //
            // Copy it in, we have one less character because of the final NULL termination.
            //
            bRet = BoolFromHResult(StrCchCopyMultipleStr(pszMerge, cchNewMultiSz - 1, pszIn, &pszMerge, &cchRemaining));

            if (bRet)
            {
                //
                // Add the extra null terminator for now.
                //
                *pszMerge = '\0';
            }
        }
    }

    return bRet;
}

/*++

Routine Name

    GetMultiSZLen

Routine Description:

    This returns the number of characters in a multisz string, including NULLs.

Arguments:

    pMultiSzSrc     -   The multisz string to search.

Return Value:

    The number of characters in the string.

--*/
DWORD
GetMultiSZLen(
    IN      LPWSTR              pMultiSzSrc
    )
{
    DWORD  dwLen = 0;
    LPWSTR pTmp = pMultiSzSrc;

    while( TRUE ) {
        dwLen += wcslen(pTmp) + 1;     // Incude the terminating NULL char

        pTmp = pMultiSzSrc + dwLen;           // Point to the beginning of the next string in the MULTI_SZ

        if( !*pTmp )
            return ++dwLen;     // Reached the end of the MULTI_SZ string. Add 1 to the count for the last NULL char.
    }
}

/*++

Routine Name

    LogPrintProcError

Routine Description:

    Helper function. It logs an error event when the print function in the print processor fails.
    The only reason for having this function is to make the code in the caller cleaner.

Arguments:

    Error     - Error returned by the print processor.
    pIniJob   - pIniJob structure for the job which failed to print.

Return Value:

    None.

--*/

VOID
LogPrintProcError(
    IN DWORD   Error,
    IN PINIJOB pIniJob
    )
{
    //
    // The print function in the print processor sets the last error. For better understaning
    // of the underlying problem, we log both the Win32 error code and the description of it.
    //
    LPWSTR pszDescription  = NULL;
    WCHAR  szError[40]     = {0};

    StringCchPrintf(szError, COUNTOF(szError), L"%u", Error);

    //
    // We do not care if FormatMessage fails. In that case pszDescription remains NULL,
    // and LocalFree knows how to handle NULL.
    //
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  Error,
                  0,
                  (LPWSTR)&pszDescription,
                  0,
                  NULL);

    //
    // Impersonate so the user's name appears in the event log
    //
    SetCurrentSid(pIniJob->hToken);

    SplLogEvent(pIniJob->pIniPrinter->pIniSpooler,
                LOG_ERROR,
                MSG_PRINT_ON_PROC_FAILED,
                FALSE,
                pIniJob->pDocument,
                pIniJob->pUser,
                pIniJob->pIniPrinter->pName,
                szError,
                pszDescription ? pszDescription : L"",
                NULL);

    SetCurrentSid(NULL);

    LocalFree(pszDescription);
}

LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

/*++

Routine Name:

    StrCchCopyMultipleStr

Description:

    This routine is a simple wrapper that allows multiple strings to be copied
    into a buffer. It uses the normal StringCchCopyEx function, but then advances
    one more if it is safe to do so. If it cannot advance, it returns an error.

Arguments:

    pszBuffer       -   The buffer we are writing the string into.
    cchBuffer       -   The number of characters in the buffer.
    pszSource       -   The source of the buffer.
    ppszNext        -   The pointer after this string in the buffer.
    pcchRemaining   -   The number of characters remaining.

Returns:

    An HRESULT, HRESULT_FROM_WIN23(ERROR_INSUFFICIENT_BUFFER) if we are out of
    room.

--*/
EXTERN_C
HRESULT
StrCchCopyMultipleStr(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cchBuffer,
    IN      PCWSTR      pszSource,
        OUT PWSTR       *ppszNext,
        OUT SIZE_T      *pcchRemaining
    )
{
    //
    // Unlike the strsafe function, we require both parameters.
    //
    HRESULT hr = ppszNext && pcchRemaining ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        size_t cchRemaining = 0;

        hr = StringCchCopyExW(pszBuffer, cchBuffer, pszSource, ppszNext, &cchRemaining, 0);

        *pcchRemaining = cchRemaining;

        //
        // If this succeeds, then advance the pointer, otherwise, there is no
        // room and the string will be NULL terminated anyway.
        //
        if (SUCCEEDED(hr))
        {
            hr = *pcchRemaining ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        if (SUCCEEDED(hr))
        {
            (*pcchRemaining)--;
            (*ppszNext)++;
        }
    }

    return hr;
}

/*++

Routine Name:

    StrCbCopyMultipleStr

Description:

    This is the equivalent to StrCchCopyMultipleStr for byte buffers.

--*/
EXTERN_C
HRESULT
StrCbCopyMultipleStr(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cbBuffer,
    IN      PCWSTR      pszSource,
        OUT PWSTR       *ppszNext,
        OUT SIZE_T      *pcbRemaining
    )
{
    HRESULT hr = ppszNext && pcbRemaining ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        size_t cbRemaining = 0;

        hr = StringCbCopyExW(pszBuffer, cbBuffer, pszSource, ppszNext, &cbRemaining, 0);

        *pcbRemaining = cbRemaining;

        //
        // If this succeeds, then advance the pointer, otherwise, there is no
        // room and the string will be NULL terminated anyway.
        //
        if (SUCCEEDED(hr))
        {
            //
            // We must have at least 2 bytes remaining to advance the string.
            //
            hr = *pcbRemaining > 1 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        if (SUCCEEDED(hr))
        {
            (*pcbRemaining) -= 2;
            (*ppszNext)++;
        }
    }

    return hr;
}

/*++

Routine Name:

    IsStringNullTerminatedInBuffer

Description:

    This routine checks to see whether the string in the given buffer is NULL
    terminated.

Arguments:

    pszBuffer       -   The buffer that should contain a NULL terminated string.
    cchBuffer       -   The number of characters in the buffer.

Returns:

    TRUE if there is a NULL termination within the buffer.

--*/
BOOL
IsStringNullTerminatedInBuffer(
    IN      PWSTR       pszBuffer,
    IN      SIZE_T      cchBuffer
    )
{
    for(;cchBuffer > 0; cchBuffer--, pszBuffer++)
    {
        if (!*pszBuffer)
        {
            break;
        }
    }

    return cchBuffer > 0;
}

/*++

Routine Name

    IsPrinterSharingAllowed

Routine Description:

    This checks if Spooler allows printer sharing.

Arguments:

    None

Return Value:

    TRUE if Spooler allows printer sharing.

--*/
BOOL
IsPrinterSharingAllowed(
    VOID
    )
{
    return gRemoteRPCEndPointPolicy != RpcEndPointPolicyDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\version.c ===
/*++

Copyright (c) 1994 - 1995  Microsoft Corporation

Module Name:

    version.c

Abstract:
   This module contains code that determines what the driver major
   version is.

Author:

    Krishna Ganugapati (KrishnaG) 15-Mar-1994

Revision History:

--*/

#include <precomp.h>

#define     X86_ENVIRONMENT             L"Windows NT x86"
#define     IA64_ENVIRONMENT            L"Windows IA64"
#define     MIPS_ENVIRONMENT            L"Windows NT R4000"
#define     ALPHA_ENVIRONMENT           L"Windows NT Alpha_AXP"
#define     PPC_ENVIRONMENT             L"Windows NT PowerPC"
#define     WIN95_ENVIRONMENT           L"Windows 4.0"
#define     AMD64_ENVIRONMENT           L"Windows NT AMD64"

BOOL
GetPrintDriverVersion(
    IN  LPCWSTR pszFileName,
    OUT LPDWORD pdwFileMajorVersion,
    OUT LPDWORD pdwFileMinorVersion
)
/*++

Routine Name:

    GetPrintDriverVersion

Routine Description:

    Gets version information about an executable file.
    If the file is not an executable, it will return 0
    for both major and minor version.

Arguments:

    pszFileName         -   file name
    pdwFileMajorVersion -   pointer to major version
    pdwFileMinorVersion -   pointer to minor version

Return Value:

    TRUE if success.

--*/
{
    DWORD  dwSize = 0;
    LPVOID pFileVersion = NULL;
    UINT   uLen = 0;
    LPVOID pMem = NULL;
    DWORD  dwFileVersionLS;
    DWORD  dwFileVersionMS;
    DWORD  dwProductVersionMS;
    DWORD  dwProductVersionLS;
    DWORD  dwFileOS, dwFileType, dwFileSubType;
    BOOL   bRetValue = FALSE;

    if (pdwFileMajorVersion)
    {
        *pdwFileMajorVersion = 0;
    }

    if (pdwFileMinorVersion)
    {
        *pdwFileMinorVersion = 0;
    }

    try
    {
        if (pszFileName && *pszFileName)
        {
            dwSize = GetFileVersionInfoSize((LPWSTR)pszFileName, 0);

            if (dwSize == 0)
            {
                //
                // Return version 0 for files without a version resource
                //
                bRetValue = TRUE;
            }
            else if ((pMem = AllocSplMem(dwSize)) &&
                     GetFileVersionInfo((LPWSTR)pszFileName, 0, dwSize, pMem) &&
                     VerQueryValue(pMem, L"\\", &pFileVersion, &uLen))
            {
                dwFileOS            = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileOS;
                dwFileType          = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileType;
                dwFileSubType       = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileSubtype;
                dwFileVersionMS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS;
                dwFileVersionLS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS;
                dwProductVersionMS  = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionMS;
                dwProductVersionLS  = ((VS_FIXEDFILEINFO *)pFileVersion)->dwProductVersionLS;

                //
                //  Return versions for drivers designed for Windows NT/Windows 2000,
                //  marked as printer drivers.
                //  Hold for all dlls Pre-Daytona.
                //  After Daytona, printer driver writers must support
                //  version control or we'll dump them as Version 0 drivers.
                //
                if (dwFileOS == VOS_NT_WINDOWS32)
                {
                    if (dwFileType == VFT_DRV &&
                        dwFileSubType == VFT2_DRV_VERSIONED_PRINTER)
                    {
                        if (pdwFileMinorVersion)
                        {
                            *pdwFileMinorVersion = dwFileVersionLS;
                        }

                        if (pdwFileMajorVersion)
                        {
                            *pdwFileMajorVersion = dwFileVersionMS;
                        }
                    }
                    else
                    {
                        if (pdwFileMajorVersion)
                        {
                            if (dwProductVersionMS == dwFileVersionMS)
                            {
                                 //
                                 // Hold for all dlls Pre-Daytona.
                                 // After Daytona, printer driver writers must support
                                 // version control or we'll dump them as Version 0
                                 // drivers.
                                 //
                                 *pdwFileMajorVersion = 0;
                            }
                            else
                            {
                                *pdwFileMajorVersion = dwFileVersionMS;
                            }
                        }
                    }
                }

                bRetValue = TRUE;
            }
        }
    }
    finally
    {
        FreeSplMem(pMem);
    }

    return bRetValue;
}


BOOL
CheckFilePlatform(
    IN  LPWSTR  pszFileName,
    IN  LPWSTR  pszEnvironment
    )
{
    HANDLE              hFile, hMapping;
    LPVOID              BaseAddress = NULL;
    PIMAGE_NT_HEADERS   pImgHdr;
    BOOL                bRet = FALSE;

    try {

        hFile = CreateFile(pszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile == INVALID_HANDLE_VALUE )
            leave;

        hMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL);

        if ( !hMapping )
            leave;

        BaseAddress = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);

        CloseHandle(hMapping);

        if ( !BaseAddress )
            leave;

        pImgHdr = RtlImageNtHeader(BaseAddress);

        if ( !pImgHdr ) {

            //
            // This happens for Win95 drivers. The second part of || is for
            // any environments we may add in the future
            //
            bRet = !_wcsicmp(pszEnvironment, WIN95_ENVIRONMENT) ||
                   !( _wcsicmp(pszEnvironment, X86_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, IA64_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT)  &&
                     _wcsicmp(pszEnvironment, PPC_ENVIRONMENT)    &&
                     _wcsicmp(pszEnvironment, MIPS_ENVIRONMENT) );
            leave;
        }

        switch (pImgHdr->FileHeader.Machine) {

            case IMAGE_FILE_MACHINE_I386:
                bRet = !_wcsicmp(pszEnvironment, X86_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_ALPHA:
                bRet = !_wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                bRet = !_wcsicmp(pszEnvironment, AMD64_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_IA64:
                bRet = !_wcsicmp(pszEnvironment, IA64_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_POWERPC:
                bRet = !_wcsicmp(pszEnvironment, PPC_ENVIRONMENT);
                break;

            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
            case IMAGE_FILE_MACHINE_R10000:
                bRet = !_wcsicmp(pszEnvironment, MIPS_ENVIRONMENT);
                break;

            default:
                //
                // For any environments we may add in the future.
                //
                bRet = !(_wcsicmp(pszEnvironment, X86_ENVIRONMENT)    &&
                         _wcsicmp(pszEnvironment, IA64_ENVIRONMENT)   &&
                         _wcsicmp(pszEnvironment, ALPHA_ENVIRONMENT)  &&
                         _wcsicmp(pszEnvironment, PPC_ENVIRONMENT)    &&
                         _wcsicmp(pszEnvironment, MIPS_ENVIRONMENT) );
        }

    } finally {

        if ( hFile != INVALID_HANDLE_VALUE ) {

            if ( BaseAddress )
                UnmapViewOfFile(BaseAddress);
            CloseHandle(hFile);
        }
    }

    return bRet;
}

/*++

Routine Name:

    GetBinaryVersion

Routine Description:

    Gets version information about an executable file.
    If the file is not an executable, it will return 0
    for both major and minor version. This function does 
    not are if the file is a printer driver or anything
    else as long as it has a resource.

Arguments:

    pszFileName         -   file name
    pdwFileMajorVersion -   pointer to major version
    pdwFileMinorVersion -   pointer to minor version
    
Return Value:

    TRUE if success.

--*/
BOOL
GetBinaryVersion(
    IN  PCWSTR pszFileName,
    OUT PDWORD pdwFileMajorVersion,
    OUT PDWORD pdwFileMinorVersion
    )
{
    DWORD  dwSize = 0;
    LPVOID pFileVersion = NULL;
    UINT   uLen = 0;
    LPVOID pMem = NULL;
    DWORD  dwFileVersionLS;
    DWORD  dwFileVersionMS;
    BOOL   bRetValue = FALSE;

    if (pdwFileMajorVersion && pdwFileMinorVersion && pszFileName && *pszFileName)
    {
        *pdwFileMajorVersion = 0;
        *pdwFileMinorVersion = 0;
        
        try 
        {
            dwSize = GetFileVersionInfoSize((LPWSTR)pszFileName, 0);
    
            if (dwSize == 0)
            {
                //
                // Return version 0 for files without a version resource
                //
                bRetValue = TRUE;
            } 
            else if ((pMem = AllocSplMem(dwSize)) &&
                     GetFileVersionInfo((LPWSTR)pszFileName, 0, dwSize, pMem) &&
                     VerQueryValue(pMem, L"\\", &pFileVersion, &uLen)) 
            {
                dwFileVersionMS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionMS;
                dwFileVersionLS     = ((VS_FIXEDFILEINFO *)pFileVersion)->dwFileVersionLS;
                    
                *pdwFileMinorVersion = dwFileVersionLS;       
                *pdwFileMajorVersion = dwFileVersionMS;       
                    
                bRetValue = TRUE;
            }
        }
        finally
        {
            FreeSplMem(pMem);
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRetValue;
}

typedef struct
{
    PCWSTR pszPrintProcFile;
    DWORD  PrintProcMajVer;
    DWORD  PrintProcMinVer;
} NOIMPERSONATEPRINTPROCS;


NOIMPERSONATEPRINTPROCS NoImpPrintProcs[] = 
{
    {L"lxaspp.dll",   0x00010000, 0x00000001},
    {L"lxarpp.dll",   0x00010000, 0x00000001},
    {L"lxampp.dll",   0x00010000, 0x00000001},
    {L"lxaupp.dll",   0x00010000, 0x00000001},
    {L"lxatpp.dll",   0x00010000, 0x00000001},
    {L"lxacpp.dll",   0x00010000, 0x00000001},
    {L"lxaapp.dll",   0x00010000, 0x00000001},
    {L"lxaepp.dll",   0x00010000, 0x00000001},
    {L"lxadpp.dll",   0x00010000, 0x00000001},
    {L"lxcapp.dll",   0x00010000, 0x00000001},
    {L"lexepp.dll",   0x00010000, 0x00000001},
    {L"lexfpp.dll",   0x00010000, 0x00000001},
    {L"jw61pp.dll",   0x00010000, 0x00000001},
    {L"fxj4pp.dll",   0x00010000, 0x00000001},
    {L"lxalpp5c.dll", 0x00020000, 0x00020000},
    {L"lxalpp5c.dll", 0x00010000, 0x00060000},
    {L"lxalpp5c.dll", 0x00020000, 0x00010000},
    {L"lxalpp5c.dll", 0x00010000, 0x00050000},
    {L"lxakpp5c.dll", 0x00020000, 0x00010000},
    {L"lxakpp5c.dll", 0x00010000, 0x00050001},
    {L"lxazpp5c.dll", 0x00010000, 0x00040002},
    {L"lxazpp5c.dll", 0x00010000, 0x00050001},
    {L"lxaxpp5c.dll", 0x00010000, 0x00060008},
    {L"lxaipp5c.dll", 0x00020000, 0x00020002},
    {L"lxaipp5c.dll", 0x00030000, 0x00020001},
    {L"lxajpp5c.dll", 0x00030000, 0x00010000},
    {L"lxajpp5c.dll", 0x00010000, 0x00020001},
    {L"lxavpp5c.dll", 0x00010000, 0x000A0000},
    {L"lxavpp5c.dll", 0x00010000, 0x00060000},
    {L"lg24pp5c.dll", 0x00010000, 0x00010008},
    {L"lg24pp5c.dll", 0x00010000, 0x00070002},
    {L"lgl2pp5c.dll", 0x00010000, 0x00010006},
    {L"lgaxpp5c.dll", 0x00010000, 0x00020001},
    {L"smaxpp5c.dll", 0x00010000, 0x00030000},
    {L"smazpp5c.dll", 0x00010000, 0x00020000},
    {L"lxbhpp5c.dll", 0x00010000, 0x00050000},
};


PCWSTR ArraySpecialDriversInbox[] =
{
    L"Lexmark 3200 Color Jetprinter",
    L"Lexmark 5700 Color Jetprinter",
    L"Lexmark Z11 Color Jetprinter",
    L"Lexmark Z12 Color Jetprinter",
    L"Lexmark Z22-Z32 Color Jetprinter",
    L"Lexmark Z31 Color Jetprinter",
    L"Lexmark Z42 Color Jetprinter",
    L"Lexmark Z51 Color Jetprinter",
    L"Lexmark Z52 Color Jetprinter",
    L"Compaq IJ300 Inkjet Printer",
    L"Compaq IJ600 Inkjet Printer",
    L"Compaq IJ700 Inkjet Printer",
    L"Compaq IJ750 Inkjet Printer",
    L"Compaq IJ900 Inkjet Printer",
    L"Compaq IJ1200 Inkjet Printer"
};

/*++

Name:

    IsSpecialDriver

Description:

    Checks whether a printer driver (and print processor) needs to be special 
    cased. Some print processors want to be loaded in local system context.
    The are listed in the tables above. some are inbox, some are IHV.
    
Arguments:

    pIniDriver  - pinidriver for the current job
    pIniProc    - piniprintproc for the current job
    pIniSpooler - pinispooler for current job

Return Value:

    TRUE - this print processor needs to be loaded in local system context
    FALSE - load print processor in impersonation context

--*/
BOOL
IsSpecialDriver(
    IN PINIDRIVER    pIniDriver,
    IN PINIPRINTPROC pIniProc,
    IN PINISPOOLER   pIniSpooler
    )
{
    BOOL  bSpecial = FALSE;
    DWORD i;

    //
    // Check if it is an inbox driver that needs to be special cased
    //
    for (i = 0; i < COUNTOF(ArraySpecialDriversInbox); i++)
    {
        if (!_wcsicmp(pIniDriver->pName, ArraySpecialDriversInbox[i]))
        {
            bSpecial = TRUE; 

            break;
        }
    }

    //
    // Check if it is an IHV driver that needs to be special cased
    //
    if (!bSpecial)
    {
        for (i = 0; i < COUNTOF(NoImpPrintProcs); i++)
        {
            if (!_wcsicmp(pIniProc->pDLLName, NoImpPrintProcs[i].pszPrintProcFile)   &&
                pIniProc->FileMajorVersion == NoImpPrintProcs[i].PrintProcMajVer     &&
                pIniProc->FileMinorVersion == NoImpPrintProcs[i].PrintProcMinVer)
            {
                bSpecial = TRUE; 
    
                break;
            }
        }
    }

    return bSpecial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\varconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  varconv.c
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    SWilson     Nov 1996
//----------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop


HRESULT
PackString2Variant(
    LPCWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;
    WCHAR String[] = L"";
    LPCWSTR pStr;

    pStr = lpszData ? lpszData : (LPCWSTR) String;

    VariantInit(pvData);
    V_VT(pvData) = VT_BSTR;

    bstrData = SysAllocString(pStr);

    if (!bstrData) {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_WIN32,
                            ERROR_OUTOFMEMORY);
    }

    V_VT(pvData) = VT_BSTR;
    V_BSTR(pvData) = bstrData;

    return ERROR_SUCCESS;
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( V_VT(&varSrcData) != VT_BSTR) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        return S_OK;
    }

    *pbstrDestString = SysAllocString(V_BSTR(&varSrcData));

    return hr;
}


HRESULT
UnpackDispatchfromVariant(
    VARIANT varSrcData,
    IDispatch **ppDispatch
    )
{
    HRESULT hr = S_OK;

    if( V_VT(&varSrcData) != VT_DISPATCH) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    if (!V_DISPATCH(&varSrcData)) {
        *ppDispatch = NULL;
        return S_OK;
    }

    *ppDispatch = V_DISPATCH(&varSrcData);

    return hr;
}



HRESULT
PackDispatch2Variant(
    IDispatch *pDispatch,
    VARIANT *pvData
)
{
    if (!pvData)
        return E_FAIL;

    V_VT(pvData) = VT_DISPATCH;
    V_DISPATCH(pvData) = pDispatch;

    return S_OK;
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }

    V_VT(pvData) = VT_I4;
    V_I4(pvData) = dwData;

    return S_OK;
}

HRESULT
UnpackDWORDfromVariant(
    VARIANT varSrcData,
    DWORD   *pdwData
)
{
    if( V_VT(&varSrcData) != VT_I4) {
        return E_ADS_CANT_CONVERT_DATATYPE;
    }

    *pdwData = V_I4(&varSrcData);
    return S_OK;
}

HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    V_VT(pvData) = VT_BOOL;
    V_BOOL(pvData) = (BYTE) fData;

    return S_OK;
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT *pvarInputData
    )
{
    VariantInit(pvarInputData);

    V_VT(pvarInputData) = VT_VARIANT;
    return VariantCopy( pvarInputData, &vaValue );
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i = 0;
    long j = 0;
    long nCount;

    if ( (bstrList != NULL) && (*bstrList != 0) ) {

        for (nCount = 0 ;  bstrList[nCount] ; ++nCount)
            ;

        if ( nCount == 1 ) {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            if (!(V_BSTR(pvVariant) = SysAllocString( bstrList[0]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            return hr;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = 0 ;  bstrList[i] ; ++i) {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (!(V_BSTR(&v) = SysAllocString(bstrList[i]))) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            //
            // SafeArrayPutElement actually copies the variant over,
            // this also copies the string so we need to clear our
            // copy.
            //
            VariantClear(&v);

            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    } else {

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
UI1Array2IID(
    VARIANT var,
    IID *pIID
)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    UCHAR pGUID[16];

    if ( !( (V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is only one dimension in this array

    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    // Check that there is at least one element in this array

    if ((V_ARRAY(&var))->rgsabound[0].cElements != 16) {
        DBGMSG(DBG_ERROR,("UI1Array, cElements != 16\n", (V_ARRAY(&var))->rgsabound[0].cElements));
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // We know that this is a valid single dimension array

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++)
    {

        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, pGUID + i - dwSLBound);
        if ( FAILED(hr) )
            continue;

    }

    *pIID = *(IID *) pGUID;

    hr = S_OK;

error:

    return hr;
}


HRESULT
UI1Array2SID(
    VARIANT var,
    LPWSTR  *ppszSID
)
{
    HRESULT hr = S_OK;
    void HUGEP *pSID;


    if ( !( (V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var)) )
        BAIL_ON_FAILURE(hr = E_FAIL);

    //
    // Check that there is only one dimension in this array
    //
    if ((V_ARRAY(&var))->cDims != 1)
        BAIL_ON_FAILURE(hr = E_FAIL);

    //
    // Check that there is at least one element in this array ( 28 is sizeof SID )
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements <= 0) {
        DBGMSG(DBG_ERROR,("UI1Array, cElements\n", (V_ARRAY(&var))->rgsabound[0].cElements));
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = SafeArrayAccessData(V_ARRAY(&var),&pSID);
    BAIL_ON_FAILURE(hr);

    if (ConvertSidToStringSid(pSID, ppszSID)) {
        hr = S_OK;
    }

    SafeArrayUnaccessData(V_ARRAY(&var));

error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\localspl\xcv.c ===
/*++


Copyright (c) 1997  Microsoft Corporation

Module Name:

    xcv.c

Author:

    Steve Wilson (SWilson) March 25, 1997

Revision History:

    Ali Naqvi (alinaqvi) October 17, 2001
        Changed IniXcv to keep IniMonitor rather than Monitor2. This way we can keep a refcount on
        IniMonitor, preventing the monitor to be deleted when in use. We are going to use the
        IniMonitor to get the Monitor2.


--*/

#include <precomp.h>
#include <offsets.h>


PINIXCV
CreateXcvEntry(
    PCWSTR      pszMachine,
    PCWSTR      pszName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler,
    HANDLE  hXcv
);

VOID
DeleteXcvEntry(
    PINIXCV pIniXcv
    );

BOOL
SplXcvOpenPort(
    PCWSTR              pszMachine,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
);



INIXCV IniXcvStart;


typedef struct {
    PWSTR    pszMethod;
    BOOL     (*pfn)(PINIXCV pIniXcv,
                    PCWSTR pszDataName,
                    PBYTE  pInputData,
                    DWORD  cbInputData,
                    PBYTE  pOutputData,
                    DWORD  cbOutputData,
                    PDWORD pcbOutputNeeded,
                    PDWORD pdwStatus,
                    PINISPOOLER pIniSpooler
                    );
} XCV_METHOD, *PXCV_METHOD;


XCV_METHOD  gpXcvMethod[] = {
                            {L"DeletePort", XcvDeletePort},
                            {L"AddPort", XcvAddPort},
                            {NULL, NULL}
                            };


BOOL
LocalXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    PINIXCV     pIniXcv = ((PSPOOL) hXcv)->pIniXcv;
    BOOL bReturn;

    if (!ValidateXcvHandle(pIniXcv))
        return ROUTER_UNKNOWN;

    bReturn = SplXcvData(hXcv,
                         pszDataName,
                         pInputData,
                         cbInputData,
                         pOutputData,
                         cbOutputData,
                         pcbOutputNeeded,
                         pdwStatus,
                         pIniXcv->pIniSpooler);

    return bReturn;
}



BOOL
SplXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc             = FALSE;
    BOOL        bCallXcvData   = FALSE;
    PINIXCV     pIniXcv = ((PSPOOL) hXcv)->pIniXcv;
    DWORD       i;

    SPLASSERT(pIniXcv->pIniMonitor->Monitor2.pfnXcvDataPort);

    //
    // Check to see whether the pointers we use always are not NULL
    //
    if (pdwStatus && pszDataName && pcbOutputNeeded)
    {
        rc = TRUE;
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    if (rc)
    {
        //
        // Execute well-known methods
        //
        for(i = 0 ; gpXcvMethod[i].pszMethod &&
                    wcscmp(gpXcvMethod[i].pszMethod, pszDataName) ; ++i)
            ;

        if (gpXcvMethod[i].pszMethod)
        {

            PINIPORT pIniPort = NULL;

            if (!_wcsicmp(gpXcvMethod[i].pszMethod, L"AddPort"))
            {
                //
                // Before we use the pInputData buffer, we need to check if the string
                // is NULL terminated somewhere inside it.
                //
                if (pInputData && cbInputData && IsStringNullTerminatedInBuffer((PWSTR)pInputData, cbInputData / sizeof(WCHAR)))
                {
                    EnterSplSem();

                    //
                    // Port name is the first field in the input structure. Keep Refcount on
                    // IniPort while outside CS.
                    //
                    pIniPort = FindPort(pInputData, pIniSpooler);
                    if ( pIniPort )
                    {
                        INCPORTREF(pIniPort);
                    }

                    LeaveSplSem();

                    //
                    // If this pIniPort doesn't have a monitor associated with it, it is
                    // a temporary port. We will allow it to be added, if there still is
                    // no monitor associated with it later, we will simply use this
                    // structure again.
                    //
                    if (pIniPort && !(pIniPort->Status & PP_PLACEHOLDER))
                    {
                        rc = TRUE;
                        *pdwStatus = ERROR_ALREADY_EXISTS;
                    }
                    else
                    {
                        bCallXcvData = TRUE;
                    }
                }
                else
                {
                    SetLastError(ERROR_INVALID_DATA);
                    rc = FALSE;
                }
            }
            else
            {
                bCallXcvData = TRUE;
            }

            //
            // Don't make the function call if we do AddPort and the port already exists.
            // If it is a placeholder, that's OK.
            //
            if (bCallXcvData)
            {
                rc = (*gpXcvMethod[i].pfn)( pIniXcv,
                                            pszDataName,
                                            pInputData,
                                            cbInputData,
                                            pOutputData,
                                            cbOutputData,
                                            pcbOutputNeeded,
                                            pdwStatus,
                                            pIniSpooler);
            }

            if(pIniPort)
            {
                EnterSplSem();
                DECPORTREF(pIniPort);
                LeaveSplSem();
            }

        }
        else
        {
            *pdwStatus = (*pIniXcv->pIniMonitor->Monitor2.pfnXcvDataPort)( pIniXcv->hXcv,
                                                                           pszDataName,
                                                                           pInputData,
                                                                           cbInputData,
                                                                           pOutputData,
                                                                           cbOutputData,
                                                                           pcbOutputNeeded );
            rc = TRUE;
        }
    }

    return rc;
}


DWORD
XcvOpen(
    PCWSTR              pszServer,
    PCWSTR              pszObject,
    DWORD               dwObjectType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
)
{
    BOOL        bRet;
    DWORD       dwRet;
    DWORD       dwLastError;


    if (dwObjectType == XCVPORT || dwObjectType == XCVMONITOR) {
        bRet = SplXcvOpenPort( pszServer,
                               pszObject,
                               dwObjectType,
                               pDefault,
                               phXcv,
                               pIniSpooler);

        if (!bRet) {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_INVALID_NAME)
                dwRet = ROUTER_UNKNOWN;
            else if (dwLastError == ERROR_UNKNOWN_PORT)

                // This is a case where a port exists without an associated port monitor
                // (i.e. a masq port), we need to give the partial print provider a chance
                // to intercept the XCV call
                //
                dwRet = ROUTER_UNKNOWN;
            else
                dwRet = ROUTER_STOP_ROUTING;
        }
        else {
            dwRet = ROUTER_SUCCESS;
        }

    } else {
        dwRet = ROUTER_UNKNOWN;
    }

    return dwRet;
}


BOOL
SplXcvOpenPort(
    PCWSTR              pszMachine,
    PCWSTR              pszObject,
    DWORD               dwType,
    PPRINTER_DEFAULTS   pDefault,
    PHANDLE             phXcv,
    PINISPOOLER         pIniSpooler
)
{
    PINIMONITOR pIniMonitor = NULL;
    PINIPORT    pIniPort    = NULL;
    BOOL        rc = FALSE;
    DWORD       dwStatus;
    HANDLE      hMonitor;
    PSPOOL      pSpool;
    PINIXCV     pIniXcv = NULL;


   EnterSplSem();

    if (dwType == XCVMONITOR) {
        pIniMonitor = FindMonitor(pszObject, pIniSpooler);
    }
    else {
        pIniPort = FindPort(pszObject, pIniSpooler);

        if(pIniPort && (pIniPort->Status & PP_MONITOR))
            pIniMonitor = pIniPort->pIniMonitor;
    }

    if (pIniMonitor) {

        if (!pIniMonitor->Monitor2.pfnXcvOpenPort ||
            !pIniMonitor->Monitor2.pfnXcvDataPort ||
            !pIniMonitor->Monitor2.pfnXcvClosePort) {

            SetLastError(ERROR_INVALID_PRINT_MONITOR);

        } else {
            //
            // Keeping a RefCount on IniMonitor and IniPort while outside CS.
            //
            INCMONITORREF(pIniMonitor);
            LeaveSplSem();

            dwStatus = CreateServerHandle( (PWSTR) pszMachine,
                                           phXcv,
                                           pDefault,
                                           pIniSpooler,
                                           PRINTER_HANDLE_XCV_PORT);

            EnterSplSem();

            if (dwStatus == ROUTER_SUCCESS) {       // Create port handle

                pSpool = *(PSPOOL *) phXcv; // *phXcv is pSpool

                rc = (*pIniMonitor->Monitor2.pfnXcvOpenPort)(
                           pIniMonitor->hMonitor,
                           pszObject,
                           pSpool->GrantedAccess,
                           &hMonitor);

                if (rc) {   // Create Spooler XCV entry

                    pIniXcv = CreateXcvEntry( pszMachine,
                                              pszObject,
                                              pIniMonitor,
                                              pIniSpooler,
                                              hMonitor);

                    if (pIniXcv) {

                        pSpool->pIniXcv = pIniXcv;

                    } else {

                        (*pIniMonitor->Monitor2.pfnXcvClosePort)(hMonitor);
                        rc = FALSE;
                    }
                }
            }
            DECMONITORREF(pIniMonitor);
        }
    } else {

        SetLastError(ERROR_UNKNOWN_PORT);
        rc = FALSE;
    }


   LeaveSplSem();

    return rc;
}




PINIXCV
CreateXcvEntry(
    PCWSTR      pszMachine,
    PCWSTR      pszName,
    PINIMONITOR pIniMonitor,
    PINISPOOLER pIniSpooler,
    HANDLE      hXcv
)
{
    PINIXCV pIniXcvPrev = &IniXcvStart;
    PINIXCV pIniXcv = IniXcvStart.pNext;


    for(; pIniXcv ; pIniXcv = pIniXcv->pNext)
        pIniXcvPrev = pIniXcv;


    if (!(pIniXcv = (PINIXCV) AllocSplMem(sizeof(INIXCV))))
        goto Cleanup;

    pIniXcv->hXcv = hXcv;
    pIniXcv->signature = XCV_SIGNATURE;

    pIniXcv->pIniSpooler = pIniSpooler;
    INCSPOOLERREF( pIniSpooler );

    if (pszMachine && !(pIniXcv->pszMachineName = AllocSplStr(pszMachine)))
        goto Cleanup;

    if (pszName && !(pIniXcv->pszName = AllocSplStr(pszName)))
        goto Cleanup;

    pIniXcv->pIniMonitor = pIniMonitor;

    //
    // During the lifespan of the IniXcv we keep a Refcount on the IniMonitor
    //
    INCMONITORREF(pIniXcv->pIniMonitor);

    return pIniXcvPrev->pNext = pIniXcv;


Cleanup:

    DeleteXcvEntry( pIniXcv );
    return NULL;
}

VOID
DeleteXcvEntry(
    PINIXCV pIniXcv
    )
{
    if( pIniXcv ){

        if( pIniXcv->pIniSpooler ){
            DECSPOOLERREF( pIniXcv->pIniSpooler );
        }
        //
        // Release the IniMonitor
        //
        if (pIniXcv->pIniMonitor)
        {
            DECMONITORREF(pIniXcv->pIniMonitor);
        }

        FreeSplStr(pIniXcv->pszMachineName);
        FreeSplStr(pIniXcv->pszName);
        FreeSplMem(pIniXcv);
    }
}

BOOL
XcvClose(
    PINIXCV pIniXcvIn
)
{
    PINIXCV pIniXcvPrev = &IniXcvStart;
    PINIXCV pIniXcv = IniXcvStart.pNext;
    BOOL    bRet;


    for(; pIniXcv ; pIniXcv = pIniXcv->pNext) {

        if (pIniXcv == pIniXcvIn) {

            bRet = pIniXcv->pIniMonitor->Monitor2.pfnXcvClosePort(pIniXcv->hXcv);

            if (bRet) {
                pIniXcvPrev->pNext = pIniXcv->pNext;

                DeleteXcvEntry( pIniXcv );
            }
            return bRet;
        }

        pIniXcvPrev = pIniXcv;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return FALSE;
}




BOOL
XcvDeletePort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    PINIPORT    pIniPort;
    BOOL        rc = FALSE;
    PWSTR       pPortName = (PWSTR) pInputData;

    //
    // Check to see whether the pInputData is NULL terminated within its buffer
    // before going down this path.
    //
    if (pInputData && cbInputData && IsStringNullTerminatedInBuffer((PWSTR)pInputData, cbInputData / sizeof(WCHAR)))
    {
        EnterSplSem();

        pIniPort = FindPort(pPortName, pIniSpooler);

        if ( !pIniPort || !(pIniPort->Status & PP_MONITOR) ) {
            SetLastError (*pdwStatus = ERROR_UNKNOWN_PORT);
            LeaveSplSem();
            return FALSE;
        }

        rc = DeletePortFromSpoolerStart(pIniPort);
        *pdwStatus = GetLastError ();

        LeaveSplSem();

        if (!rc)
            goto Cleanup;

        *pdwStatus = (*pIniXcv->pIniMonitor->Monitor2.pfnXcvDataPort)( pIniXcv->hXcv,
                                                                       pszDataName,
                                                                       pInputData,
                                                                       cbInputData,
                                                                       pOutputData,
                                                                       cbOutputData,
                                                                       pcbOutputNeeded);

        DeletePortFromSpoolerEnd(pIniPort, pIniSpooler, *pdwStatus == ERROR_SUCCESS);
        rc = TRUE;
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

Cleanup:

    return rc;
}




BOOL
XcvAddPort(
    PINIXCV     pIniXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    PINISPOOLER pIniSpooler
)
{
    BOOL        rc;
    PINIMONITOR pIniMonitor = NULL;
    PINIPORT    pIniPort    = NULL;

    pIniMonitor = pIniXcv->pIniMonitor;

    if (pIniMonitor) {
        *pdwStatus = (*pIniXcv->pIniMonitor->Monitor2.pfnXcvDataPort)( pIniXcv->hXcv,
                                                                       pszDataName,
                                                                       pInputData,
                                                                       cbInputData,
                                                                       pOutputData,
                                                                       cbOutputData,
                                                                       pcbOutputNeeded);

        if (*pdwStatus == ERROR_SUCCESS) {
            EnterSplSem();

            //
            // Check to see if we have a placeholder port by the same name. If we
            // do this set this as the monitor and revoke its placeholder status.
            //
            // This pInputData has already been validated by the "Add" method in
            // XcvData itself.
            //
            pIniPort = FindPort(pInputData, pIniSpooler);

            if (pIniPort && pIniPort->Status & PP_PLACEHOLDER)
            {
                pIniPort->pIniMonitor =     pIniMonitor;
                pIniPort->Status      |=    PP_MONITOR;
                pIniPort->Status      &=    ~PP_PLACEHOLDER;
            }
            else
            {
                CreatePortEntry((PWSTR) pInputData, pIniMonitor, pIniSpooler);
            }

            LeaveSplSem();
        }

        rc = TRUE;

    } else {
        SetLastError(ERROR_INVALID_NAME);
        rc = FALSE;
    }

    return rc;
}


BOOL
ValidateXcvHandle(
    PINIXCV pIniXcv
)
{
    BOOL    ReturnValue;

    try {
        if (!pIniXcv || pIniXcv->signature != XCV_SIGNATURE) {
            ReturnValue = FALSE;
        } else {
            ReturnValue = TRUE;
        }
    }except (1) {
        ReturnValue = FALSE;
    }

    if ( !ReturnValue )
        SetLastError( ERROR_INVALID_HANDLE );

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\parsepjl.c ===
/* dhi - When stable remove all #if DAN and #if FOR_WIN_TESTING sections 
   and leave in #if FOR_WIN sections.  Then get rid of these defines.
*/
#define DEBUGOUTPUT 0
#define FOR_WIN 1

/*++

Copyright (c) 1994 - 1996  Microsoft Corporation

Module Name:
    PARSEPJL.C
Abstract:
    Handles parsing of PJL printer response streams into token\value pairs.

--*/


/*
Currently returns tokens for (see enum in parsepjl.h for token values):
@PJL ECHO MSSYNC # ->#

@PJL INFO MEMORY
TOTAL=#   ->#
LARGEST=# ->#

@PJL INFO STATUS
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

@PJL INQUIRE INTRAY?SIZE   (? is 1,2,3 or 4)
LEGAL(or other PJL paper size) ->constant from DM... list in PRINT.H 

@PJL INFO CONFIG
MEMORY=# ->#
  
@PJL USTATUS JOB
END -> returns token with zero for value
  
@PJL USTATUS JOB
NAME="MSJOB #" ->#

added

@PJL USTATUS DEVICE
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

*/

#include "precomp.h"

// VOID cdecl DbgMsg( LPSTR MsgFormat, ... );


#define FF 12
#define CR 13
#define LF 10
#define TAB 9
#define SPACE 32

#define OK_IF_FF_FOUND    TRUE
#define ERROR_IF_FF_FOUND FALSE
#define TOKEN_BASE_NOT_USED 0
#define ACTION_NOT_USED 0
#define PARAM_NOT_USED 0
/* returned as value for TOKEN_USTATUS_JOB_END */
#define VALUE_RETURED_FOR_VALUELESS_TOKENS  0  

extern KeywordType readBackCommandKeywords[]; 
extern KeywordType infoCatagoryKeywords[]; 
extern KeywordType inquireVariableKeywords[];
extern KeywordType traySizeKeywords[];
extern KeywordType echoKeywords[];
extern KeywordType infoConfigKeywords[];
extern KeywordType ustatusKeywords[];
extern KeywordType ustatusJobKeywords[];
extern KeywordType ustatusDeviceKeywords[];

/* Fuctions called when a string in keyword is found */
void TokenFromParamValueFromNumberFF
   (ParseVarsType *pParseVars, ParamType);
void SetNewList(ParseVarsType *pParseVars,
   ParamType);
void GetTotalAndLargestFF(ParseVarsType *pParseVars,ParamType param);
void GetCodeAndOnlineFF(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParamFF(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromNumberEOLFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromBooleanEOL(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromStringEOL(ParseVarsType *pParseVars,ParamType param);


/* Fuctions called when no string in a keywords list is found */
void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars);
void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars);


/* Helper Functions */
void StoreToken(ParseVarsType *pParseVars, DWORD dwToken);
BOOL StoreTokenValueAndAdvancePointer
   (ParseVarsType *pParseVars, UINT_PTR dwValue);
void  ExpectFinalCRLFFF(ParseVarsType *pParseVars);
BOOL  SkipPastNextCRLF(ParseVarsType *pParseVars);
int GetPositiveInteger(ParseVarsType *pParseVars);
BOOL AdvancePointerPastString
   (ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipOverSpaces(ParseVarsType *pParseVars);
int LookForKeyword(ParseVarsType *pParseVars);
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipPastFF(ParseVarsType *pParseVars);
void ExpectFinalFF(ParseVarsType *pParseVars);

/* Helper Strings */
char lpCRLF[] = "\r\n";
char lpQuoteCRLF[] = "\"\r\n";

/*
Below are the Lists that drive the parsing.  The main loop of this 
parser looks through the keywords in the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If a FF is found in the input stream rather than a keyword, then the 
parser returns.  The return value is determined using the bFormFeedOk 
element of the ListType structure.

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

The tokenBaseValue element is a number to which the index in the
keyword's list of strings will added to calculate the token number 
corresponding to the indexed string.
*/

ListType readBackCommandList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   readBackCommandKeywords /* INFO, ECHO, INQUIRE ... */
   };

ListType infoCatagoryList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   infoCatagoryKeywords  /* MEMORY STATUS CONFIG ... */
   };


ListType infoConfigList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES, 
   PJL_TOKEN_INFO_CONFIG_BASE, 
   infoConfigKeywords  /* MEMORY= ... */
   };

ListType inquireVariableList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_INQUIRE_BASE, 
   inquireVariableKeywords /* INTRAY1SIZE ...*/
   };


ListType echoList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   echoKeywords /* MSSYNC ...*/
   };


ListType traySizeList = 
   {
   ERROR_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   TOKEN_BASE_NOT_USED, 
   traySizeKeywords /* LEGAL, C5 ...*/
   };

ListType ustatusList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusKeywords  /* JOB ... */
   };


ListType ustatusJobList = 
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF, 
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusJobKeywords  /* END ... */
   };

ListType ustatusDeviceList =
   {
   OK_IF_FF_FOUND, 
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_DEVICE_BASE,
   ustatusDeviceKeywords  /* END ... */
   };


/* Command strings that can follow @PJL USTATUS */
KeywordType ustatusKeywords[] = 
   {
      {"JOB\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusJobList},
      {"DEVICE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
//    {"DEVICE\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"TIMED\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
      NULL
   };                


/* Command strings that can follow @PJL USTATUS JOB */
KeywordType ustatusJobKeywords[] = 
   {
      {"END\r\n", ACTION_SET_VALUE_FROM_PARAM, VALUE_RETURED_FOR_VALUELESS_TOKENS},
      {"NAME=\"MSJOB ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpQuoteCRLF},
      NULL
   };                


/* command strings that can follow @PJL USTATUS DEVICE */
KeywordType ustatusDeviceKeywords[] =
   {
      {"CODE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DISPLAY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL, (struct ListTypeTag *)lpCRLF},
      {"ONLINE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL, (struct ListTypeTag *)lpCRLF},
      NULL
   };


/* Command strings that can follow @PJL */
KeywordType readBackCommandKeywords[] = 
   {
      {"INFO", ACTION_SET_NEW_LIST, &infoCatagoryList},
      {"ECHO", ACTION_SET_NEW_LIST, &echoList},
      {"INQUIRE", ACTION_SET_NEW_LIST, &inquireVariableList},
      {"USTATUS", ACTION_SET_NEW_LIST, &ustatusList},
      NULL
   };                


/* Command strings that can follow @PJL ECHO (Microsoft specific-NOT PJL!) */
KeywordType echoKeywords[] = 
   {
      {"MSSYNC", ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF, 
         (struct ListTypeTag *)TOKEN_ECHO_MSSYNC_NUMBER},
      NULL
   };                

/* Catagory strings that can follow @PJL INFO */
KeywordType infoCatagoryKeywords[] = 
   {
      {"MEMORY\r\n", ACTION_GET_TOTAL_AND_LARGEST_FF, PARAM_NOT_USED},
      {"STATUS\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"CONFIG\r\n", ACTION_SET_NEW_LIST, &infoConfigList},
      NULL
   };

/* Catagory strings that can follow @PJL INFO */
KeywordType infoConfigKeywords[] = 
   {
      {"MEMORY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"MEMORY = ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DUPLEX", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)TRUE},
      NULL
   };

/* TRUE or FALSE strings */
KeywordType FALSEandTRUEKeywords[] = 
   {
      {"FALSE", ACTION_NOT_USED, PARAM_NOT_USED},
      {"TRUE",  ACTION_NOT_USED, PARAM_NOT_USED},
      NULL
   };

/* strings that can follow @PJL INQUIRE */
KeywordType inquireVariableKeywords[] = 
   {
      {"INTRAY1SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY2SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY3SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY4SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      NULL
   };

/* strings that can follow @PJL INQUIRE INTRAY?SIZE */
/* the parameters are the Microsoft defined token values for paper size */
KeywordType traySizeKeywords[] =
   {
      {"LETTER",    ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LETTER},
      {"LEGAL",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LEGAL},
      {"A4",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_A4},
      {"EXECUTIVE", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_EXECUTIVE},
      {"COM10",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_10},
      {"MONARCH",   ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_MONARCH},
      {"C5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_C5},
      {"DL",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_DL},
      {"B5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_B5},
      NULL
   };

void (*pfnNotFoundActions[])(ParseVarsType *pParseVars) = 
   {
   ActionNotFoundSkipPastFF,
   ActionNotFoundSkipCFLFandIndentedLines
   };


void (*pfnFoundActions[])(ParseVarsType *pParseVars, ParamType param) = 
   {
   TokenFromParamValueFromNumberFF,
   SetNewList,
   GetTotalAndLargestFF,
   GetCodeAndOnlineFF,
   GetTokenFromIndexSetNewList,
   SetValueFromParamFF,
   GetTokenFromIndexValueFromNumberEOLFromParam,
   SetValueFromParam,
   GetTokenFromIndexValueFromBooleanEOL,
   GetTokenFromIndexValueFromStringEOL
   };

PJLTOPRINTERSTATUS PJLToStatus[] =
{
    { 10001,0x0 },  // clear status - printer is ready
    { 10002,0x0 },  // clear status - check ONLINE=TRUE or FALSE
    { 11002,0x0 },  // LJ4 sends this code for 00 READY
    { 40022,PORT_STATUS_PAPER_JAM    },
    { 40034,PORT_STATUS_PAPER_PROBLEM},
    { 40079,PORT_STATUS_OFFLINE      },
    { 40019,PORT_STATUS_OUTPUT_BIN_FULL},

    { 10003,PORT_STATUS_WARMING_UP   },
    { 10006,PORT_STATUS_TONER_LOW    },
    { 40038,PORT_STATUS_TONER_LOW    },

    { 30016,PORT_STATUS_OUT_OF_MEMORY},
    { 40021,PORT_STATUS_DOOR_OPEN    },
    { 30078,PORT_STATUS_POWER_SAVE   },

    //
    // Entries added by MuhuntS
    //
    { 41002, PORT_STATUS_PAPER_PROBLEM}, // Load plain
    { 35078, PORT_STATUS_POWER_SAVE},
    {0, 0}

};


#if FOR_WIN
#else
/*
test not enough room for tokens
test no FF
test zero before end
*/
main ()
{
char pInString[] = "@PJL USTATUS DEVICE\r\nCODE=25008\r\n\f\
@PJL USTATUS DEVICE\r\n\CODE=20020\r\n\f\
@PJL ECHO MSSYNC 1234567\r\n\f\
@PJL INFO CONFIG\r\n\
IN TRAYS [1 ENUMERATED]\r\n\
\tINTRAY1 PC\r\n\
OUT TRAYS [1 ENUMERATED]\r\n\
\tNORMAL FACEDOWN\r\n\
PAPERS [10 ENUMERATED]\r\n\
\tLETTER\r\n\
\tLEGAL\r\n\
\tA4\r\n\
LANGUAGES [1 ENUMERATED]\r\n\
\tPCL\r\n\
MEMORY=2097152\r\n\
DISPLAY LINES=1\r\n\
DISPLAY CHARACTER SIZE=16\r\n\f\
@PJL INQ";



//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"MSJOB 3\"\r\nPAGES=3\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"JOB 14993\"\r\nPAGES=3\r\n\f$"; //good command 1 token
/*
char pInString[] = "@PJL INFO CONFIG\r\nINTRAYS [3 ENUMERATED]\r\n\tINTRAY1\
 MP\r\n\tINTRAY2 PC\r\n\tINTRAY3 LC\r\nENVELOPE TRAY\r\nMEMORY=2087152\r\n\
DISPLAY LINES=1\r\n\f$"; //good command 1 token
*/
//char pInString[] = "@PJL INQUIRE INTRAY3SIZE\r\nC5\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL INFO STATUS\r\nCODE=10001\r\n\DISPLAY=\"00 READY\"\r\nONLINE=TRUE\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJL INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJG INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\f$"; //bad command Fail
//char pInString[] = "@PJG ECHO MSSYNC 12T4567\r\n\f$";     //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\000\f$"; //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\f$";     //bad MS command Fail
//char pInString[] = "@PJL ECHO MSSYNC 1234567\r\n\f$";     //good command Success 1 token
//char pInString[] = "@PJL ECHO 124567\r\n\f$";             //good command Success 0 token
TokenPairType tokenPairs[20];
DWORD nTokenParsedRet;
LPSTR lpRet;
DWORD i;
DWORD status;


status = GetPJLTokens(pInString, 20, tokenPairs, &nTokenParsedRet, &lpRet);

switch (status)
   {
   case STATUS_REACHED_END_OF_COMMAND_OK:
      {
      printf("STATUS_REACHED_END_OF_COMMAND_OK\n");
      break;
      }
   case STATUS_CONTINUE:
      {
      printf("STATUS_CONTINUE\n");
      break;
      }
   case STATUS_REACHED_FF:
      {
      printf("STATUS_REACHED_FF\n");
      break;
      }
   case STATUS_END_OF_STRING;
      {
      printf("STATUS_END_OF_STRING\n");
      break;
      }
   case STATUS_SYNTAX_ERROR:
      {
      printf("STATUS_SYNTAX_ERROR\n");
      break;
      }
   case STATUS_ATPJL_NOT_FOUND:
      {
      printf("STATUS_ATPJL_NOT_FOUND\n");
      break;
      }
   case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
      {
      printf("STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n");
      break;
      }
   default:
      {
      printf("INVALID STATUS RETURNED!!!!!!\n");
      break;
      }
   };

printf(" length of command=%d, numberOfTokens=%d\n", lpRet-pInString, nTokenParsedRet);
for (i=0; i<nTokenParsedRet; i++)
   {
   printf("  Token=0x%x, Value=%d\n", tokenPairs[i].token, tokenPairs[i].value);
   }

if (*lpRet==0)
   {
   printf(" Next char is terminator\n");
   }
else
   {
   printf(" Next char=%c\n", *lpRet);
   }

exit(0);
}
#endif


/* GetPJLTokens 
This function parses a single ASCII PJL command and returns token/value pairs.
Complete PJL commands must begin with '@PJL' and end with a <FF>.

The function result returns one of the following values:
   0 = STATUS_REACHED_END_OF_COMMAND_OK
   1 = STATUS_END_OF_STRING
   2 = STATUS_SYNTAX_ERROR
   3 = STATUS_ATPJL_NOT_FOUND,
   4 = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS

Also returned through the parameters are:
 1] *plpInPJL:
    If STATUS_REACHED_END_OF_COMMAND_OK
      will point to the character past the first <FF> (FF = form feed).
    If STATUS_END_OF_STRING
      will point to the terminator that was found before any <FF>.
    Else
      undefined 
  
 2] *pnTokenParsed will contain the number of pairs returned in *pToken.

 3] pToken will contain *pnTokenParsed  token pairs  

If there are characters belonging to another command trailing the first
then the caller should call again for the new command.  If only part of
the new command may be present, then the caller may want to copy the 
characters of the new command to the beginning of the buffer, and then read 
the necessary additional characters onto the end before resubmitting the
complete command to this function for parsing.  Note that the *plpInPJL
tells the caller where the next command would begin.


If the end of the string is encountered before the trailing <FF> is found then
the function returns with *plpInPJL pointing to the terminator.
If the caller wants the command parsed into
token\value pairs it should resubmit the string once the characters 
which complete the command have been appended.


Operation:
----------
Lists drive the parsing.  The main loop of this 
parser looks through the keywords of the current list and tries to
match the keyword string to the current input stream.  

If a keyword is found then the function corresponding to the Action in 
the keyword is called.  

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

*/

DWORD GetPJLTokens(
    LPSTR lpInPJL,
    DWORD nTokenInBuffer,
    TokenPairType *pToken, 
    DWORD *pnTokenParsed,
    LPSTR *plpInPJL
)
{
   /* The parseVars variables are put into a structure so that they can be
      passed efficiently to all the helper functions.
    */
   ParseVarsType parseVars;
   BOOL bFoundKeyword;
   DWORD i, keywordIndex;
   KeywordType *pKeyword;
   DWORD dwNotFoundAction;

   /* The first list to look for is the commands that can follow
      @PJL
    */
   parseVars.arrayOfLists[0] = &readBackCommandList;
   parseVars.arrayOfLists[1] = NULL;      

   parseVars.pInPJL_Local = lpInPJL;
   parseVars.nTokenInBuffer_Local = 0;
   parseVars.nTokenLeft = nTokenInBuffer;
   parseVars.pToken_Local = pToken;
   parseVars.status = STATUS_CONTINUE;

   if (!AdvancePointerPastString(&parseVars, "@PJL"))
      {
      parseVars.status = STATUS_ATPJL_NOT_FOUND;
      }
                     
   while (parseVars.status == STATUS_CONTINUE)
      {
      /* Look for next input keyword in currently valid lists.
         Sometimes may need to look for the next input keyword in more
         then one list.
       */
      bFoundKeyword = FALSE;
      for (i=0; (parseVars.pCurrentList = parseVars.arrayOfLists[i])!=NULL; i++)
         {
         dwNotFoundAction = parseVars.pCurrentList->dwNotFoundAction;
         /* Skip over spaces to start of next keyword string */
         if ( !SkipOverSpaces(&parseVars) )
            {
            /* Either the input stream has ended or FF was found */
            if (parseVars.status == STATUS_REACHED_FF)
               {
               /* Finding a FF here may or may not be an error,
                  the field in the current list tells us which
                */  

               if ( parseVars.pCurrentList->bFormFeedOK )
                  {
                  parseVars.status = STATUS_REACHED_END_OF_COMMAND_OK;
                  }
               else
                  {
                  parseVars.status = STATUS_SYNTAX_ERROR;
                  }
               }
            break;
            }
         /* Look for keyword in current keywords */
         parseVars.pCurrentKeywords = parseVars.pCurrentList->pListOfKeywords;
         keywordIndex = LookForKeyword(&parseVars);
         if ( keywordIndex!=-1 )
            {
            bFoundKeyword = TRUE;
            break;
            }
         }

      if ( parseVars.status!=STATUS_CONTINUE )
         {
         /* We are finished processing commands */
         break;
         }

      if ( bFoundKeyword )
         /* do action from keyword */
         {
         pKeyword = &parseVars.pCurrentKeywords[keywordIndex];
         (*pfnFoundActions[pKeyword->dwAction])(&parseVars, pKeyword->param);
         }
      else
         /* do not found action from list */
         {
         (*pfnNotFoundActions[dwNotFoundAction])(&parseVars);
         }
      } 

   /* We are done parsing the input command, now we return the information */
#if DEBUGOUTPUTDEBUG
 DbgMsg("ParseVars.status = %d\n", parseVars.status);
#endif

   /* Fill in returned values and return with success */
   *pnTokenParsed = parseVars.nTokenInBuffer_Local;
   *plpInPJL = parseVars.pInPJL_Local;

   return(parseVars.status);
}


/* 
int LookForKeyword(ParseVarsType *pParseVars)

This function looks through the current keyword list in search of a 
keyword that matches the characters in the input stream pointed to 
by pParseVars->pInPJL_Local.

If a match is found:
        The index of the match in the pKeyword is returned.
        pParseVars->pInPJL_Local is advanced past the last matching character.
        pParseVars->dwKeywordIndex is set to item number in list

If no match is found:
        The return value is -1.
        pParseVars->pInPJL_Local is unchanged.
*/
int LookForKeyword(ParseVarsType *pParseVars)
{
LPSTR   pInStart = pParseVars->pInPJL_Local;
LPSTR   pIn;
DWORD   dwKeywordIndex = 0;
BOOL    bFoundMatch = FALSE;
BYTE    c;
KeywordType *pKeywords = pParseVars->pCurrentKeywords;
LPSTR   pKeywordString;

while ( (pKeywordString=pKeywords[dwKeywordIndex++].lpsz)!=NULL )
   {
#if DEBUGOUTPUT
 DbgMsg("LookForIn=%hs\n", pInStart);
 DbgMsg(" Keyword=%hs\n", pKeywordString);
#endif
   pIn = pInStart;
   while ( (c=*pKeywordString++)!=0 )
      {
      if ( c!=*pIn++ )
         {
         break;
         }
      }

   if ( c==0 )
      {
      bFoundMatch = TRUE;
      pParseVars->pInPJL_Local = pIn;
      pParseVars->dwFoundIndex = dwKeywordIndex-1;
      break;
      }
   }
#if DEBUGOUTPUT
 DbgMsg("LookForOut=%hs\n", pParseVars->pInPJL_Local);
#endif
return( (bFoundMatch)?dwKeywordIndex-1:-1 );
}


/*
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)

This function looks through the input stream for a match with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
*/
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) )
      {
      if ( s==in )
         {
         pS++; /* point to next char in string to look for match */
         }
      else
         {
         pS = pString; /* start over looking for start of string */
         }
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }

   if ( in==FF )
      {
      pParseVars->status = STATUS_REACHED_FF;
      pParseVars->pInPJL_Local = pIn+1;
      }
   else
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      } 

   return(FALSE);
}



/*
BOOL SkipOverSpaces(ParseVarsType &parseVars) 
This function skips over spaces in the input stream until a non-space
character (FF and NULL are special cases) is found.

If a non-space character is found then 
   pParseVars->pInPJL_Local is set to point to the first non-space char.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before a non-space char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered before a non-space character is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipOverSpaces(ParseVarsType *pParseVars) 
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)==SPACE)&&(in!=0)&&(in!=FF) )
      {
      pIn++;
      }
   
   switch (in)
      {
      case FF:
         {
         pParseVars->status = STATUS_REACHED_FF;
         pParseVars->pInPJL_Local = pIn+1;
         return(FALSE);
         }
      case 0:
         {
         pParseVars->status = STATUS_END_OF_STRING;
         pParseVars->pInPJL_Local = pIn;
         return(FALSE);
         }
      default:
         {
         /* point to character after string in input */
         pParseVars->pInPJL_Local = pIn;
         return(TRUE);
         }
      }
}


void TokenFromParamValueFromNumberFF(
   ParseVarsType *pParseVars,ParamType param)
{
   int value;

   StoreToken(pParseVars, param.token);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars)
{
   if ( SkipPastFF(pParseVars) )
      {
      pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK;
      }
   return;
}

/*
BOOL SkipPastFF(ParseVarsType *pParseVars)
This function skips over all characters until either a zero is found or
FF is found.

If the end of input is encountered before an FF char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered 
   the return value is TRUE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipPastFF(ParseVarsType *pParseVars)
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)!=FF)&&(in!=0) )
      {
      pIn++;
      }
   
   if ( in==0 )
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      return(FALSE);
      }
   pParseVars->pInPJL_Local = pIn+1;
   pParseVars->status = STATUS_REACHED_FF;
   return(TRUE);
}

void ExpectFinalCRLFFF(ParseVarsType *pParseVars)
{
   char c;

   if ( pParseVars->status==STATUS_CONTINUE )
      {
      c=*pParseVars->pInPJL_Local;
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         return;
         }
   
      if ( !AdvancePointerPastString(pParseVars, lpCRLF) )
         {
         if ( pParseVars->status==STATUS_REACHED_FF )
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         return;
         }
      ExpectFinalFF(pParseVars);
      }
   return;
}



void ExpectFinalFF(ParseVarsType *pParseVars)
{
   if ( pParseVars->status==STATUS_CONTINUE )
      {
      if ( *pParseVars->pInPJL_Local==FF )
         {
         pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK; 
         pParseVars->pInPJL_Local++;
         }
      else
         {
         if ( *pParseVars->pInPJL_Local==0 )
            {
            pParseVars->status = STATUS_END_OF_STRING;
            }
         else
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         }
      }
   return;
}


/*
int GetPositiveInteger(ParseVarsType *pParseVars)
This function skips spaces and then interprets all the digits in input stream
as a positive integer.

If digits follow any spaces and they are not terminated by a zero then
   the return value is the positive integer.

If the first character following spaces in not a digit or the end of 
string is encountered then 
   -1 is returned as the value 
   pParseVars->status is set to STATUS_SYNTAX_ERROR
   
Note: does not check for overflow
*/
int GetPositiveInteger(ParseVarsType *pParseVars)
{
   int   value;
   LPSTR pIn; 
   BYTE  c;

   if ( !SkipOverSpaces(pParseVars) )
      {
      if ( pParseVars->status == STATUS_REACHED_FF )
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(-1);
      }
   
   pIn = pParseVars->pInPJL_Local;
   for ( value=0; ((c=*pIn++)>='0')&&(c<='9'); value=value*10+(c-'0') );
   if ( (c==0)||(pIn==pParseVars->pInPJL_Local+1) )
      {
      /* either end of string encountered or no digits found */
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         }
      else
         {   
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      pParseVars->pInPJL_Local = pIn-1;
      return(-1);
      }
   pParseVars->pInPJL_Local = pIn-1;
   return(value);
}



void SetNewList(ParseVarsType *pParseVars, ParamType param)
{
   pParseVars->arrayOfLists[0] = param.pList;
   pParseVars->arrayOfLists[1] = NULL;
   return;
}  

void StoreToken(ParseVarsType *pParseVars, DWORD dwToken)
{
   pParseVars->dwNextToken = dwToken;
   return;
}

BOOL StoreTokenValueAndAdvancePointer(ParseVarsType *pParseVars, UINT_PTR dwValue)
{
   if ( pParseVars->nTokenLeft==0 )
      {
      pParseVars->status = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS;
      return(FALSE);
      }
   pParseVars->pToken_Local->token = pParseVars->dwNextToken;
   pParseVars->pToken_Local->value = dwValue;
   pParseVars->pToken_Local++;
   pParseVars->nTokenInBuffer_Local++;
   pParseVars->nTokenLeft--;
   return(TRUE);
}


void GetTotalAndLargestFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars, "TOTAL=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_TOTAL);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nLARGEST=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_LARGEST);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void GetCodeAndOnlineFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars,"CODE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_CODE);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nDISPLAY=") )
      {
      return;
      }
   if ( !SkipPastNextCRLF(pParseVars) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "ONLINE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_ONLINE);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;
   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


/*
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)

This function looks for a match of the current stream 
position with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) && (s==in) )
      {
      pS++; 
      pIn++;
      }
   
   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }
   
   pParseVars->status = ( in!=0 )?
      STATUS_SYNTAX_ERROR:STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
   return(FALSE);
}




/*
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)

This function positions the stream pointer past the next
CRLF.

If a CRLF is found:
   pParseVars->pInPJL_Local is set to point just past the CRLF.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the CRLF is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the CRLF is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)
{
   if ( !AdvancePointerPastString(pParseVars, "\r\n") )
      {
      if ( pParseVars->status == STATUS_REACHED_FF)
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(FALSE);
      }
   return(TRUE);
}


void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars, ParamType param)
{
   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   SetNewList(pParseVars, param);
   return;
}


void SetValueFromParamFF(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


void SetValueFromParam(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   return;
}

void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars)
{
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF In=%hs\n", pParseVars->pInPJL_Local);
#endif
   do
      {
      if ( !SkipPastNextCRLF(pParseVars) )
         {
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF error skipping\n");
#endif
         return;
         }
      } while (*pParseVars->pInPJL_Local==TAB);
#if DEBUGOUTPUT
 DbgMsg("ActionNotFoundSkipCRLF Out=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;      
}

void GetTokenFromIndexValueFromNumberEOLFromParam
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromNumberIn=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
#if DEBUGOUTPUT
 DbgMsg("error getting number\n");
#endif
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
#if DEBUGOUTPUT
 DbgMsg("error storing value\n");
#endif
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromNumberOut=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}

void GetTokenFromIndexValueFromBooleanEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromBooleanEOLin=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;

   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromBooleanEOLout=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}

void GetTokenFromIndexValueFromStringEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   param; /* to eliminate not used warning */
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromStringEOLin=%hs\n", pParseVars->pInPJL_Local);
#endif

   StoreToken(pParseVars, 
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);

   if ( !StoreTokenValueAndAdvancePointer(pParseVars, (UINT_PTR)pParseVars->pInPJL_Local))
      {
      return;
      }
   SkipPastNextCRLF(pParseVars);
#if DEBUGOUTPUT
 DbgMsg("GetTokenFromIndexValueFromStringEOLout=%hs\n", pParseVars->pInPJL_Local);
#endif
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\precomp.h ===
/*++

Copyright (c) 1994 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include "spltypes.h"
#include "local.h"
#include "parsepjl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\parsepjl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved

Module Name:

    parsepjl.h

Abstract:

    Header file for PJL parser

--*/

#define MAX_POSSIBLE_LISTS_IN_BRANCH 2

/* Note: new actions must be added at end, and new functions at the
end of the function pointer array defined later in this file */
enum ParseActionsEnumTag 
   {
   ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF,
   ACTION_SET_NEW_LIST,
   ACTION_GET_TOTAL_AND_LARGEST_FF,
   ACTION_GET_CODE_AND_ONLINE_FF,
   ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST,
   ACTION_SET_VALUE_FROM_PARAM_FF,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM,   
   ACTION_SET_VALUE_FROM_PARAM,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL
   };



/* Note: new actions must be added at end, and new functions at the
   end of the function pointer array defined later in this file 
*/
enum ParseNotFoundActionsEnumTag 
   {
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES
   };



/* Note: The order of some of the Token values is related to 
   indexes in the keyword lists.  Always add new token values
   to the end of BASE group.
*/
enum pjl_token_variables_tag
   {

   PJL_TOKEN_INQUIRE_BASE = 0x10000,
   TOKEN_INQUIRE_TRAY1SIZE = 0x10000,
   TOKEN_INQUIRE_TRAY2SIZE,
   TOKEN_INQUIRE_TRAY3SIZE,
   TOKEN_INQUIRE_TRAY4SIZE,

   PJL_TOKEN_ECHO_BASE = 0x20000,
   TOKEN_ECHO_MSSYNC_NUMBER = 0x20000,

   PJL_TOKEN_INFO_MEMORY_BASE = 0x30000,
   TOKEN_INFO_MEMORY_TOTAL   = 0x30000,
   TOKEN_INFO_MEMORY_LARGEST,

   PJL_TOKEN_INFO_STATUS_BASE = 0x40000,
   TOKEN_INFO_STATUS_CODE = 0x40000,
   TOKEN_INFO_STATUS_ONLINE,

   PJL_TOKEN_INFO_CONFIG_BASE = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY_SPACE,

   PJL_TOKEN_USTATUS_JOB_BASE = 0x60000,
   TOKEN_USTATUS_JOB_END = 0x60000,
   TOKEN_USTATUS_JOB_NAME_MSJOB,

   PJL_TOKEN_USTATUS_DEVICE_BASE = 0x70000,
   TOKEN_USTATUS_DEVICE_CODE = 0x70000,
   TOKEN_USTATUS_DEVICE_DISPLAY,
   TOKEN_USTATUS_DEVICE_ONLINE,
   };

/* The first 5 values are the possible return values for GetPJLTokens() */
/* The last 2 values are used internally */
enum status_tag
   {
   STATUS_REACHED_END_OF_COMMAND_OK,
   STATUS_END_OF_STRING,
   STATUS_SYNTAX_ERROR,
   STATUS_ATPJL_NOT_FOUND,
   STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS,

   STATUS_REACHED_FF,
   STATUS_CONTINUE
   };

typedef struct
   {
   DWORD    token;
   UINT_PTR value;
   } TOKENPAIR, * PTOKENPAIR, TokenPairType;

typedef struct ParamTypeTag
   {
   union 
      {
      struct ListTypeTag *pList;
      DWORD token;
      DWORD value;
      struct KeywordTypeTag *pListOfKeywords; 
      LPSTR lpstr;
      };  
   } ParamType;

typedef struct KeywordTypeTag 
   {
   LPSTR lpsz;
   DWORD dwAction;
   ParamType param;
   } KeywordType;

typedef struct ListTypeTag
   {
   BOOL  bFormFeedOK;
   DWORD dwNotFoundAction;
   DWORD tokenBaseValue;
   KeywordType *pListOfKeywords; 
   } ListType;

typedef struct parseVarsTag
   {
   LPSTR        pInPJL_Local;
   DWORD        nTokenLeft;
   DWORD        nTokenInBuffer_Local;
   TokenPairType *pToken_Local;
   DWORD        dwNextToken;
   DWORD        dwFoundIndex;
   DWORD        status; 
   ListType     *pCurrentList;
   KeywordType  *pCurrentKeywords;
   ListType     *arrayOfLists[MAX_POSSIBLE_LISTS_IN_BRANCH+1]; 
   } ParseVarsType;



extern DWORD GetPJLTokens(LPSTR lpInPJL, DWORD nTokenInBuffer, 
   TokenPairType *pToken, DWORD *pnTokenParsed, LPSTR *plpInPJL);

typedef struct
    {
    DWORD   pjl;
    DWORD   status;
    } PJLTOPRINTERSTATUS;

extern PJLTOPRINTERSTATUS PJLToStatus[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:

    DDK version of local.h

Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#endif
// @@END_DDKSPLIT


#define READTHREADTIMEOUT                5000
#define READ_THREAD_EOJ_TIMEOUT         60000   // 1 min
#define READ_THREAD_ERROR_WAITTIME       5000   // 5 sec
#define READ_THREAD_IDLE_WAITTIME       30000   // 30 sec

#define ALL_JOBS                    0xFFFFFFFF


// ---------------------------------------------------------------------
// EXTERN VARIABLES
// ---------------------------------------------------------------------
extern  HANDLE              hInst;
extern  DWORD               dwReadThreadErrorTimeout;
extern  DWORD               dwReadThreadEOJTimeout;
extern  DWORD               dwReadThreadIdleTimeoutOther;

extern  CRITICAL_SECTION    pjlMonSection;
extern  DWORD SplDbgLevel;


// ---------------------------------------------------------------------
// FUNCTION PROTOTYPE
// ---------------------------------------------------------------------
VOID
EnterSplSem(
   VOID
    );

VOID
LeaveSplSem(
   VOID
    );

VOID
SplInSem(
   VOID
    );

VOID
SplOutSem(
    VOID
    );

DWORD
UpdateTimeoutsFromRegistry(      
    IN HANDLE      hPrinter,
    IN HKEY        hKey,
    IN PMONITORREG pMonitorReg
    );

PINIPORT
FindIniPort(
   IN LPTSTR pszName
    );

PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    );

VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    );

VOID
FreeIniJobs(
    PINIPORT pIniPort
    );

VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    );
VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    );

// @@BEGIN_DDKSPLIT
// ---------------------------------------------------------------------
// UNICODE TO ANSI MACRO
// ??? !!! we should get rid of these sooner or later
// ---------------------------------------------------------------------
// @@END_DDKSPLIT
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

LPSTR
mystrrchr(
    LPSTR cs,
    char c
);

LPSTR
mystrchr(
    LPSTR cs,
    char c
);

int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
);


// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

extern  CRITICAL_SECTION    pjlMonSection;

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT

/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DEBUG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}


#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define SPLASSERT(exp)
#endif

#endif
// @@END_DDKSPLIT

//
// Needed by DDK
//
// @@BEGIN_DDKSPLIT
/*
// @@END_DDKSPLIT
#define DBGMSG(x,y)
#define SPLASSERT(exp)
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\spltypes.h ===
/*++

Copyright (c) 1995 - 1996 Microsoft Corporation
All rights reserved.

Module Name:

    Spltypes.h

Abstract:

    PJLMON header file


--*/

#ifndef MODULE
#define MODULE "PJLMON:"
#define MODULE_DEBUG PjlmonDebug
#endif

typedef struct _INIJOB {
    DWORD   signature;
    struct _INIJOB FAR *pNext;
    LPTSTR  pszPrinterName;
    HANDLE  hPrinter;
    DWORD   JobId;
    DWORD   status;
    DWORD   TimeoutCount;
} INIJOB, FAR *PINIJOB;

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT FAR *pNext;
    LPTSTR  pszPortName;

    DWORD   cRef;

    DWORD   status;
    PINIJOB pIniJob;

    HANDLE  hPort;
    HANDLE  WakeUp;
    HANDLE  DoneReading;
    HANDLE  DoneWriting;

    DWORD   PrinterStatus;
    DWORD   dwLastReadTime;
    DWORD   dwAvailableMemory;
    DWORD   dwInstalledMemory;

    MONITOR2 fn;

} INIPORT, FAR *PINIPORT;

#define PJ_SIGNATURE   0x4F4A  /* 'PJ' is the signature value */

//
// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_LJ4L, PP_RESETDEV
//      are set/cleared on per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
//
#define PP_INSTARTDOC       0x00000001  // Inside StartDoc, sending data to the printer
#define PP_RUN_THREAD       0x00000002  // Tell the ustatus thread to start running
#define PP_THREAD_RUNNING   0x00000004  // Tell the main thread that the ustatus thread is running

//
// If PP_RUN_THREAD is set and PP_THREAD_RUNNING is not that means UStatus
// thread is being created or it is already running but has not determined if
// printer is PJL or not yet
//
#define PP_PRINTER_OFFLINE  0x00000008  // The printer is OFFLINE
#define PP_PJL_SENT         0x00000010  // PJL Command was sent to the printer
#define PP_SEND_PJL         0x00000020  // Set at StartDoc so that we initialize PJL
                                        // commands during the first write port
#define PP_IS_PJL           0x00000040  // Port is PJL
#define PP_DONT_TRY_PJL     0x00000080  // Don't try again...
#define PP_WRITE_ERROR      0x00000100  // A write was not succesful

// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_PORT_OPEN are set/cleared on
//           per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\pjlmon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
All Rights Reserved


Module Name:

Abstract:

Author:

Revision History:

--*/

#define USECOMM

#include "precomp.h"
#include <winioctl.h>
#include <ntddpar.h>


// ---------------------------------------------------------------------
// PROTO, CONSTANT, and GLOBAL
//
// ---------------------------------------------------------------------

DWORD   ProcessPJLString(PINIPORT, CHAR *, DWORD *);
VOID    ProcessParserError(DWORD);
VOID    InterpreteTokens(PINIPORT, PTOKENPAIR, DWORD);
BOOL    IsPJL(PINIPORT);
BOOL    WriteCommand(HANDLE, LPSTR);
BOOL    ReadCommand(HANDLE);

#define WAIT_FOR_WRITE                  100 // 0.1 sec
#define WAIT_FOR_DATA_TIMEOUT           100 // 0.1 sec
#define WAIT_FOR_USTATUS_THREAD_TIMEOUT 500 // 0.5 sec
#define GETDEVICEID                     IOCTL_PAR_QUERY_DEVICE_ID
#define MAX_DEVID                       1024

static TCHAR   cszInstalledMemory[]    = TEXT("Installed Memory");
static TCHAR   cszAvailableMemory[]    = TEXT("Available Memory");

BOOL
DllMain(
    IN HANDLE   hModule,
    IN DWORD    dwReason,
    IN LPVOID   lpRes
    )
/*++

Routine Description:
    Dll entry point

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&pjlMonSection);
            DisableThreadLibraryCalls(hModule);
            break;

        default:
            // do nothing
            ;
    }

    return TRUE;
}


VOID
ClearPrinterStatusAndIniJobs(
    PINIPORT    pIniPort
    )
{
    PORT_INFO_3 PortInfo3;

    if ( pIniPort->PrinterStatus ||
         (pIniPort->status & PP_PRINTER_OFFLINE) ) {

        pIniPort->PrinterStatus = 0;
        pIniPort->status &= ~PP_PRINTER_OFFLINE;

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        SetPort(NULL, pIniPort->pszPortName, 3, (LPBYTE)&PortInfo3);
    }

    SendJobLastPageEjected(pIniPort, ALL_JOBS, FALSE);
}


VOID
RefreshPrinterInfo(
    PINIPORT    pIniPort
    )
{
    //
    // Only one thread should write to the printer at a time
    //
    if ( WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->DoneWriting,
                                              WAIT_FOR_WRITE) ) {

        return;
    }

    //
    // If printer is power cycled and it does not talk back (but answers
    // PnP id) we got to clear the error on spooler to send jobs
    //
    ClearPrinterStatusAndIniJobs(pIniPort);
    if ( !IsPJL(pIniPort) ) {

        pIniPort->status &= ~PP_IS_PJL;
    }

    SetEvent(pIniPort->DoneWriting);
}


VOID
UstatusThread(
    HANDLE hPort
)
/*++

Routine Description:
    Unsolicited status information thread. This thread will continue to
    read unsolicited until it's asked to terminate, which will happen
    under one of these conditions:
        1) Receive EOJ confirmation from the printer.
        2) Timeout waiting for EOJ confirmation.
        3) The port is been closed.

Arguments:
    hPort   : IniPort structure for the port

Return Value:

--*/
{
    PINIPORT        pIniPort = (PINIPORT)((INIPORT *)hPort);
    HANDLE          hToken;

    DBGMSG (DBG_TRACE, ("Enter UstatusThread hPort=%x\n", hPort));

    SPLASSERT(pIniPort                              &&
              pIniPort->signature == PJ_SIGNATURE   &&
              (pIniPort->status & PP_THREAD_RUNNING) == 0);

    if ( IsPJL(pIniPort) )
        pIniPort->status |= PP_IS_PJL;


    SetEvent(pIniPort->DoneWriting);

    if ( !(pIniPort->status & PP_IS_PJL) )
        goto StopThread;

    //
    // manual-reset event, initially signal state
    //
    pIniPort->DoneReading = CreateEvent(NULL, TRUE, TRUE, NULL);

    if ( !pIniPort->DoneReading )
        goto StopThread;

    pIniPort->status |= PP_THREAD_RUNNING;

    pIniPort->PrinterStatus     = 0;
    pIniPort->status           &= ~PP_PRINTER_OFFLINE;
    pIniPort->dwLastReadTime    = 0;

    for ( ; ; ) {

        //
        // check if PP_RUN_THREAD has been cleared to terminate
        //
        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            if ( pIniPort->status & PP_INSTARTDOC ) {

                //
                // there's an active job, can't end the thread
                //
                pIniPort->status |= PP_RUN_THREAD;
            } else {

                DBGMSG(DBG_INFO,
                       ("PJLMon Read Thread for Port %ws Closing Down.\n",
                       pIniPort->pszPortName));

                pIniPort->status &= ~PP_THREAD_RUNNING;

                ClearPrinterStatusAndIniJobs(pIniPort);
                goto StopThread;
            }
        }

        //
        // check if the printer is bi-di
        //
        if (pIniPort->status & PP_IS_PJL) {

            (VOID)ReadCommand(hPort);

            //
            // If we are under error condition or if we have jobs pending
            // read status back from printer more frequently
            //
            if ( pIniPort->pIniJob                          ||
                 (pIniPort->status & PP_PRINTER_OFFLINE)    ||
                 (pIniPort->status & PP_WRITE_ERROR) ) {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadErrorTimeout);
            } else {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadIdleTimeoutOther);
            }

            if ( pIniPort->pIniJob &&
                 !(pIniPort->status & PP_PRINTER_OFFLINE) &&
                 !(pIniPort->status & PP_WRITE_ERROR) ) {

                //
                // Some printers are PJL bi-di, but do not send
                // EOJ. We want jobs to disappear from printman
                //
                SendJobLastPageEjected(pIniPort,
                                       GetTickCount() - dwReadThreadEOJTimeout,
                                       TRUE);
            }

            //
            // If we did not read from printer for more than a minute
            // and no more jobs talk to printer again
            //
            if ( !(pIniPort->status & PP_INSTARTDOC) &&
                 (GetTickCount() - pIniPort->dwLastReadTime) > 240000
)
                RefreshPrinterInfo(pIniPort);

        } else {

            //
            // exit the thread if printer is not PJL bi-di capable
            //
            Sleep(2000);
            pIniPort->status &= ~PP_RUN_THREAD;
#ifdef  DEBUG
            OutputDebugStringA("Set ~PP_RUN_THREAD because printer is not bi-di\n");
#endif
        }
    }

StopThread:
    pIniPort->status &= ~PP_RUN_THREAD;
    pIniPort->status &= ~PP_THREAD_RUNNING;
    CloseHandle(pIniPort->DoneReading);

    //
    // By closing the handle and then setting it to NULL we know the main
    // thread will not end up setting a wrong event
    //
    CloseHandle(pIniPort->WakeUp);
    pIniPort->WakeUp = NULL;

    DBGMSG (DBG_TRACE, ("Leave UstatusThread\n"));

}


BOOL
CreateUstatusThread(
    PINIPORT pIniPort
)
/*++

Routine Description:
    Creates the Ustatus thread

Arguments:
    pIniPort    : IniPort structure for the port

Return Value:
    TRUE on succesfully creating the thread, else FALSE
--*/
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    DBGMSG(DBG_INFO, ("PJLMon Read Thread for Port %ws Starting.\n",
                      pIniPort->pszPortName));

    pIniPort->status |= PP_RUN_THREAD;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    pIniPort->WakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);

    if ( !pIniPort->WakeUp )
        goto Fail;

    ThreadHandle = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)UstatusThread,
                                pIniPort,
                                0, &ThreadId);

    if ( ThreadHandle ) {

        SetThreadPriority(ThreadHandle, THREAD_PRIORITY_LOWEST);
        CloseHandle(ThreadHandle);
        return TRUE;
    }

Fail:

    if ( pIniPort->WakeUp ) {

        CloseHandle(pIniPort->WakeUp);
        pIniPort->WakeUp = NULL;
    }

    pIniPort->status &= ~PP_RUN_THREAD;
    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave CreateUstatusThread\n"));

    return FALSE;
}


BOOL
WINAPI
PJLMonOpenPortEx(
    IN     HANDLE       hMonitor,
    IN     HANDLE       hMonitorPort,
    IN     LPWSTR       pszPortName,
    IN     LPWSTR       pszPrinterName,
    IN OUT LPHANDLE     pHandle,
    IN OUT LPMONITOR2   pMonitor
)
/*++

Routine Description:
    Opens the port

Arguments:
    pszPortName     : Port name
    pszPrinterName  : Printer name
    pHandle         : Pointer to the handle to return
    pMonitor        : Port monitor function table

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort;
    BOOL        bRet = FALSE;
    BOOL        bInSem = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonOpenPortEx (portname = %s)\n", pszPortName));


    //
    // Validate port monitor
    //
    if ( !pMonitor                  ||
         !pMonitor->pfnOpenPort     ||
         !pMonitor->pfnStartDocPort ||
         !pMonitor->pfnWritePort    ||
         !pMonitor->pfnReadPort     ||
         !pMonitor->pfnClosePort ) {


        DBGMSG(DBG_WARNING,
               ("PjlMon: Invalid port monitors passed to OpenPortEx\n"));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Cleanup;
    }

    EnterSplSem();
    bInSem = TRUE;

    //
    // Is the port open already?
    //
    if ( pIniPort = FindIniPort(pszPortName) ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    pIniPort = CreatePortEntry(pszPortName);
    LeaveSplSem();
    bInSem = FALSE;

    if ( pIniPort &&
         (*pMonitor->pfnOpenPort)(hMonitorPort, pszPortName, &pIniPort->hPort) ) {

        *pHandle = pIniPort;
        CopyMemory((LPBYTE)&pIniPort->fn, (LPBYTE)pMonitor, sizeof(*pMonitor));

        //
        // Create the ustatus thread always
        // If printer is not PJL it will die by itself
        // We do not want to write to the printer in this thread to determine
        //      printer is PJL since that may take several seconds to fail
        //
        CreateUstatusThread(pIniPort);
        bRet = TRUE;
    } else {

        DBGMSG(DBG_WARNING, ("PjlMon: OpenPort %s : Failed\n", pszPortName));
    }

Cleanup:
    if ( bInSem ) {

        LeaveSplSem();
    }
    SplOutSem();

    DBGMSG (DBG_TRACE, ("Leave PJLMonOpenPortEx bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonStartDocPort(
    IN HANDLE  hPort,
    IN LPTSTR  pszPrinterName,
    IN DWORD   dwJobId,
    IN DWORD   dwLevel,
    IN LPBYTE  pDocInfo
)
/*++

Routine Description:
    Language monitor StartDocPort

Arguments:
    hPort           : Port handle
    pszPrinterName  : Printer name
    dwJobId         : Job identifier
    dwLevel         : Level of Doc info strucuture
    pDocInfo        : Pointer to doc info structure

Return Value:
    TRUE on success, FALSE on error

--*/
{

    PINIPORT            pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB             pIniJob = NULL;
    DWORD               cbJob;
    BOOL                bRet = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonStartDocPort hPort=0x%x\n", hPort));

    //
    // Validate parameters
    //
    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ||
         !pDocInfo ||
         !pszPrinterName ||
         !*pszPrinterName ) {

        SPLASSERT(pIniPort &&
                  pIniPort->signature == PJ_SIGNATURE &&
                  pDocInfo);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwLevel != 1 ) {

        SPLASSERT(dwLevel == 1);
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Serialize access to the port
    //
    if ( pIniPort->status & PP_INSTARTDOC ) {

        SetLastError(ERROR_BUSY);
        return FALSE;
    }

    cbJob   = sizeof(*pIniJob) + lstrlen(pszPrinterName) * sizeof(TCHAR)
                               + sizeof(TCHAR);
    pIniJob = (PINIJOB) AllocSplMem(cbJob);
    if ( !pIniJob ) {

        goto Cleanup;
    }

    pIniJob->pszPrinterName = wcscpy((LPTSTR)(pIniJob+1), pszPrinterName);

    if ( !OpenPrinter(pIniJob->pszPrinterName, &pIniJob->hPrinter, NULL) ) {

        DBGMSG(DBG_WARNING,
               ("pjlmon: OpenPrinter failed for %s, last error %d\n",
                pIniJob->pszPrinterName, GetLastError()));

        goto Cleanup;
    }

    pIniPort->status |= PP_INSTARTDOC;

    bRet = (*pIniPort->fn.pfnStartDocPort)(pIniPort->hPort,
                                           pszPrinterName,
                                           dwJobId,
                                           dwLevel,
                                           pDocInfo);

    if ( !bRet ) {

        pIniPort->status &= ~PP_INSTARTDOC;
        goto Cleanup;
    }

    //
    // If Ustatus thread is not running then check if printer understands
    // PJL, unless we determined that printer does not understand PJL earlier
    //
    if ( !(pIniPort->status & PP_RUN_THREAD) &&
         !(pIniPort->status & PP_DONT_TRY_PJL) ) {

        CreateUstatusThread(pIniPort);
    }

    //
    // set PP_SEND_PJL flag here so the first write of the job
    // will try to send PJL command to initiate the job control
    //

    pIniJob->JobId = dwJobId;
    pIniJob->status |= PP_INSTARTDOC;

    EnterSplSem();
    if ( !pIniPort->pIniJob ) {

        pIniPort->pIniJob = pIniJob;
    } else {

        pIniJob->pNext = pIniPort->pIniJob;
        pIniPort->pIniJob = pIniJob;
    }
    LeaveSplSem();

    if ( pIniPort->status & PP_IS_PJL )
        pIniJob->status |= PP_SEND_PJL;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

Cleanup:

    if ( !bRet ) {

        if ( pIniJob )
            FreeIniJob(pIniJob);
    }

    DBGMSG (DBG_TRACE, ("Leave PJLMonEndDocPort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonReadPort(
    IN  HANDLE  hPort,
    OUT LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD pcbRead
)
/*++

Routine Description:
    Language monitor ReadPort

Arguments:
    hPort           : Port handle
    pBuffer         : Buffer to read data to
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return read count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL bRet;

    DBGMSG (DBG_TRACE, ("Enter PJLMonReadPort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    bRet =  (*pIniPort->fn.pfnReadPort)(pIniPort->hPort, pBuffer, cbBuf, pcbRead);

    DBGMSG (DBG_TRACE, ("Leave PJLMonReadPort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
)
/*++

Routine Description:
    Language monitor WritePort

Arguments:
    hPort           : Port handle
    pBuffer         : Data Buffer
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return written count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet;

    DBGMSG (DBG_TRACE, ("Enter PJLMonWritePort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's the fist write of the job
    //
    if ( pIniPort->pIniJob &&
         (pIniPort->pIniJob->status & PP_SEND_PJL) ) {

        // PP_SEND_PJL is set if it's the first write of the job
        char string[256];

        if ( !WriteCommand(hPort, "\033%-12345X@PJL \015\012") ) {

            return FALSE;
        }

        //
        // clear PP_SEND_PJL here if we have successfully send a PJL command.
        //
        pIniPort->pIniJob->status &= ~PP_SEND_PJL;

        //
        // set PP_PJL_SENT meaning that we have successfully sent a
        // PJL command to the printer, though it doesn't mean that
        // we will get a successfully read. PP_PJL_SENT gets cleared in
        // StartDocPort.
        //
        pIniPort->pIniJob->status |= PP_PJL_SENT;

        sprintf(string, "@PJL JOB NAME = \"MSJOB %d\"\015\012",
                    pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        WriteCommand(hPort, "@PJL USTATUS JOB = ON \015\012@PJL USTATUS PAGE = OFF \015\012@PJL USTATUS DEVICE = ON \015\012@PJL USTATUS TIMED = 30 \015\012\033%-12345X");
    }

    //
    // writing to port monitor
    //
    bRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, pBuffer,
                                       cbBuf, pcbWritten);

    if ( bRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
    }

    if ( (!bRet || pIniPort->PrinterStatus) &&
         (pIniPort->status & PP_THREAD_RUNNING) ) {

        //
        // By waiting for the UStatus thread to finish reading if there
        // is an error and printer sends unsolicited status
        // and user gets status on queue view before the win32 popup
        //
        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, INFINITE);
    }

    DBGMSG (DBG_TRACE, ("Leave PJLMonWritePort bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonEndDocPort(
   HANDLE   hPort
)
/*++

Routine Description:
    Language monitor EndDocPort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB     pIniJob;

    DBGMSG (DBG_TRACE, ("Enter PJLMonEndDocPort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Find the job (which is the last)
    //
    pIniJob = pIniPort->pIniJob;

    if ( !pIniJob )
        DBGMSG(DBG_ERROR, ("No jobs?\n"));

    //
    // check if we had sent PJL command, i.e. if the printer is bi-di
    //
    if ( pIniJob && (pIniJob->status & PP_PJL_SENT) ) {

        //
        // if the printer is bi-di, tell printer to let us know when the job
        // is don't in the printer and we'll really EndDoc then. this is so
        // that we can continue to monitor the job status until the job is
        // really done in case there's an error occurs.
        // but some cheap printers like 4L, doesn't handle this EOJ command
        // reliably, so we time out if printer doesn't tell us EOJ after a
        // while so that we don't end up having the port open forever in this
        // case.
        //

        char    string[256];

        sprintf(string,
                "\033%%-12345X@PJL EOJ NAME = \"MSJOB %d\"\015\012\033%%-12345X",
                pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        pIniJob->TimeoutCount = GetTickCount();
        pIniJob->status &= ~PP_INSTARTDOC;
    }

    (*pIniPort->fn.pfnEndDocPort)(pIniPort->hPort);

    if ( pIniJob && !(pIniJob->status & PP_PJL_SENT) ) {

        //
        // This is not bi-di printer send EOJ so that spooler deletes it
        //
        SendJobLastPageEjected(pIniPort, pIniJob->JobId, FALSE);
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    // wake up the UStatus read thread if printer is bi-di

    if ( pIniPort->status & PP_THREAD_RUNNING )
        SetEvent(pIniPort->WakeUp);

    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave PJLMonEndDocPort\n"));

    return TRUE;
}


BOOL
WINAPI
PJLMonClosePort(
    HANDLE  hPort
)
/*++

Routine Description:
    Language monitor ClosePort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    DBGMSG (DBG_TRACE, ("Enter PJLMonClosePort hPort=0x%x\n", hPort));

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    //
    // Kill Ustatus thread if it is running
    //
    if (pIniPort->status & PP_RUN_THREAD) {

        pIniPort->status &= ~PP_RUN_THREAD;
#ifdef DEBUG
        OutputDebugStringA("Set ~PP_RUN_THREAD from close port\n");
#endif

        SetEvent(pIniPort->WakeUp);

        //
        // if UStatusThread is still running at this point,
        // wait utill it terminates, because we can't DeletePortEntry
        // until it terminates.
        //
        while (pIniPort->WakeUp)
            Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
    }

    if ( pIniPort->fn.pfnClosePort )
        (*pIniPort->fn.pfnClosePort)(pIniPort->hPort);

    EnterSplSem();
    DeletePortEntry(pIniPort);
    LeaveSplSem();

    DBGMSG (DBG_TRACE, ("Leave PJLMonClosePort\n"));

    return TRUE;
}


BOOL
WriteCommand(
    HANDLE hPort,
    LPSTR cmd
)
/*++

Routine Description:
    Write a command to the port

Arguments:
    hPort           : Port handle
    cmd             : Command buffer

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD cbWrite, cbWritten, dwRet;
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    DBGMSG (DBG_TRACE, ("Enter WriteCommand cmd=|%s|\n", cmd));

    cbWrite = strlen(cmd);

    dwRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, (LPBYTE) cmd, cbWrite, &cbWritten);

    if ( dwRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
        DBGMSG(DBG_INFO, ("PJLMON!No data Written\n"));
        if ( pIniPort->status & PP_THREAD_RUNNING )
            SetEvent(pIniPort->WakeUp);
    }

    DBGMSG (DBG_TRACE, ("Leave WriteCommand dwRet=%d\n", dwRet));
    return dwRet;
}


#define CBSTRING 1024

BOOL
ReadCommand(
    HANDLE hPort
)
/*++

Routine Description:
    Read a command from the port

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on successfully reading one or more commands, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    DWORD       cbRead, cbToRead, cbProcessed, cbPrevious;
    char        string[CBSTRING];
    DWORD       status = STATUS_SYNTAX_ERROR; //Value should not matter
    BOOL        bRet=FALSE;

    DBGMSG (DBG_TRACE, ("Enter ReadCommand\n"));

    cbPrevious = 0;

    ResetEvent(pIniPort->DoneReading);

    cbToRead = CBSTRING - 1;

    for ( ; ; ) {

        if ( !PJLMonReadPort(hPort, (LPBYTE) &string[cbPrevious], cbToRead, &cbRead) )
            break;


        if ( cbRead ) {

            string[cbPrevious + cbRead] = '\0';
            DBGMSG(DBG_INFO, ("Read |%s|\n", &string[cbPrevious] ));

            status = ProcessPJLString(pIniPort, string, &cbProcessed);
            if ( cbProcessed )
                bRet = TRUE;

            if (status == STATUS_END_OF_STRING ) {

                if ( cbProcessed )
                    strcpy(string, string+cbProcessed);
                cbPrevious = cbRead + cbPrevious - cbProcessed;
            }
        } else {

            SPLASSERT(!cbPrevious);
        }

        if ( status != STATUS_END_OF_STRING && cbRead != cbToRead )
            break;

        cbToRead = CBSTRING - cbPrevious - 1;
        if ( cbToRead == 0 )
            DBGMSG(DBG_ERROR,
                   ("ReadCommand cbToRead is 0 (buffer too small)\n"));

        Sleep(WAIT_FOR_DATA_TIMEOUT);
    }

    SetEvent(pIniPort->DoneReading);

    //
    // Update the time we last read from printer
    //
    if ( bRet )
        pIniPort->dwLastReadTime = GetTickCount();

    DBGMSG (DBG_TRACE, ("Leave ReadCommand bRet=%d\n", bRet));

    return bRet;
}


BOOL
WINAPI
PJLMonGetPrinterDataFromPort(
    HANDLE   hPort,
    DWORD   ControlID,
    LPTSTR  pValueName,
    LPTSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPTSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
)
/*++

Routine Description:
    GetPrinter data from port. Supports predefined commands/valuenames.

    When we support Value name commands (not supported by DeviceIoControl)
    we should check for startdoc -- MuhuntS

    This monitor function supports the following two functionalities,

         1. Allow spooler or language monitor to call DeviceIoControl to get
            information from the port driver vxd, i.e. ControlID != 0.
            And only port monitor support this functionality, language monitor
            doesn't, so language monitor just pass this kind of calls down to
            port monitor.

         2. Allow app or printer driver query language monitor for some device
            information by specifying some key names that both parties understand,
            i.e. ControlID == 0 && pValueName != 0. So when printer driver call
            DrvGetPrinterData DDI, gdi will call spooler -> language monitor
            to get specific device information, for example, UNIDRV does this
            to get installed printer memory from PJL printers thru PJLMON.
            Only language monitor support this functionality,
            port monitor doesn't.

Arguments:
    hPort           : Port handle
    ControId        : Control id
    pValueName      : Value name
    lpInBuffer      : Input buffer for the command
    cbinBuffer      : Input buffer size
    lpOutBuffer     : Output buffer
    cbOutBuffer     : Output buffer size
    lpcbReturned    : Set to the amount of data in output buffer on success

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;

    DBGMSG (DBG_TRACE, ("Enter PJLMonGetPrinterDataFromPort hPort=0x%x\n", hPort));

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
    if ( ControlID ) {

        if ( !pIniPort->fn.pfnGetPrinterDataFromPort ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return (*pIniPort->fn.pfnGetPrinterDataFromPort)(
                        pIniPort->hPort,
                        ControlID,
                        pValueName,
                        lpInBuffer,
                        cbInBuffer,
                        lpOutBuffer,
                        cbOutBuffer,
                        lpcbReturned);
    }

    //
    // Only 2 keys supported
    //
    if ( lstrcmpi(pValueName, cszInstalledMemory)   &&
         lstrcmpi(pValueName, cszAvailableMemory) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Wait for crrent job to print since we can't send a PJL command
    // in the middle of job
    //
    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    // make sure the first write succeeds

    // WIN95C BUG 14299, ccteng, 5/18/95
    //
    // The multi-language printers (4M, 4ML, 4MP, 4V, 4SI), if you print a
    // PS print job, the memory resources claimed by the PS processor are not
    // release until you enter PCL or reset the printer with "EscE".
    //
    // So if we had just printed a PS job, the available memory will be
    // incorrect if we don't have the "EscE" here.

    if ( (pIniPort->status & PP_IS_PJL) &&
         WriteCommand(hPort, "\033E\033%-12345X@PJL INFO CONFIG\015\012") ) {

        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            bStopUstatusThread = TRUE;
            CreateUstatusThread(pIniPort);
        }

        // PJLMON currently only supports the following pValueName
        //  1. installed printer memory
        //  2. available printer memory

        if ( !lstrcmpi(pValueName, cszInstalledMemory) )
            pIniPort->dwInstalledMemory = 0;
        else if (!lstrcmpi(pValueName, cszAvailableMemory))
            pIniPort->dwAvailableMemory = 0;

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        WriteCommand(hPort,
                     "@PJL INFO MEMORY\015\012@PJL INFO STATUS\015\012");

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        if ( bStopUstatusThread ) {

            pIniPort->status &= ~PP_RUN_THREAD;
            SetEvent(pIniPort->WakeUp);
        }

        if ( !lstrcmpi(pValueName, cszInstalledMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                pIniPort->dwInstalledMemory ) {

                *((LPDWORD)lpOutBuffer) = pIniPort->dwInstalledMemory;

                bRet = TRUE;
            }
        } else if ( !lstrcmpi(pValueName, cszAvailableMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                 pIniPort->dwAvailableMemory)
            {
                *((LPDWORD)lpOutBuffer) = pIniPort->dwAvailableMemory;

                bRet = TRUE;
            }
        }

        if ( bStopUstatusThread ) {

            while (pIniPort->WakeUp)
                Sleep(WAIT_FOR_USTATUS_THREAD_TIMEOUT);
        }

    }

    if ( !bRet )
        SetLastError(ERROR_INVALID_PARAMETER);

    SetEvent(pIniPort->DoneWriting);

    DBGMSG (DBG_TRACE, ("Leave PJLMonGetPrinterDataFromPort bRet=0d\n", bRet));

    return bRet;
}

#if 0
PBIDI_RESPONSE_CONTAINER
AllocResponse (DWORD dwCount)
{
    PBIDI_RESPONSE_CONTAINER pResponse;

    pResponse = (PBIDI_RESPONSE_CONTAINER)
                LocalAlloc (LPTR, sizeof (PBIDI_RESPONSE_CONTAINER) +
                            (dwCount - 1) * sizeof (BIDI_RESPONSE_DATA) );

    pResponse->Version = 1;
    pResponse->Flags = 0;
    pResponse->Count = dwCount;
    return pResponse;

}
#endif


DWORD
WINAPI
PJLMonBidiSendRecv (
    HANDLE                    hPort,
    DWORD                     dwAccessBit,
    LPCWSTR                   pszAction,
    PBIDI_REQUEST_CONTAINER   pRequestContainer,
    PBIDI_RESPONSE_CONTAINER* ppResponse)
/*++

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;
    PBIDI_RESPONSE_CONTAINER pResponse = NULL;



#define BIDI_SCHEMA_DUPLEX          L"/Printer/Installableoption/Duplexunit"
#define BIDI_SCHEMA_MULTICHANNEL    L"/Capability/MultiChannel"
#define BIDI_SCHEMA_VERSION         L"/Communication/Version"
#define BIDI_SCHEMA_BIDIPROTOCOL    L"/Communication/BidiProtocol"
#define BIDI_SCHEMA_INK_LEVEL       L"/Printer/BlackInk1/Level"
#define BIDI_SCHEMA_ALERTS          L"/Printer/Alerts"
#define BIDI_PJL L"PJL"
#define BIDI_ALERTNAME L"/Printer/Alerts/1/Name"
#define BIDI_ALERTVALUE L"CoverOpen"

    static LPWSTR ppszSchema[] = {
        BIDI_SCHEMA_DUPLEX, BIDI_SCHEMA_MULTICHANNEL,
        BIDI_SCHEMA_VERSION,  BIDI_SCHEMA_BIDIPROTOCOL,
        BIDI_SCHEMA_INK_LEVEL, BIDI_SCHEMA_ALERTS
        };
    static DWORD dwSchemaCount = sizeof (ppszSchema) / sizeof (ppszSchema[0]);
    DWORD i, j;
    DWORD dwCount;
    DWORD dwIndex = 0;

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);

    if (!lstrcmpi (pszAction, BIDI_ACTION_ENUM_SCHEMA)) {
        // Enum Schema call

        dwCount = dwSchemaCount;

        pResponse = RouterAllocBidiResponseContainer (dwCount);

        pResponse->Version = 1;
        pResponse->Count = dwCount;


        for (i = 0; i <dwCount; i++ ) {
            pResponse->aData[i].dwReqNumber = 0;
            pResponse->aData[i].dwResult = S_OK;
            pResponse->aData[i].data.dwBidiType = BIDI_TEXT;
            pResponse->aData[i].data.u.sData = (LPTSTR)RouterAllocBidiMem (sizeof (TCHAR) * (1 + lstrlen (ppszSchema[i])));
            SPLASSERT (pResponse->aData[i].data.u.sData);

            lstrcpy (pResponse->aData[i].data.u.sData, ppszSchema[i]);
        }
    }
    else if (!lstrcmpi (pszAction, BIDI_ACTION_GET)) {


        dwCount = pRequestContainer->Count;
        pResponse = RouterAllocBidiResponseContainer (dwCount);
        SPLASSERT (pResponse);

        pResponse->Version = 1;
        pResponse->Count = dwCount;

        for (i = 0; i <dwCount; i++ ) {

            DWORD dwSchemaId = 0xffffffff;

            for (j = 0; j < dwSchemaCount;j++ ) {
                if (!lstrcmpi (ppszSchema[j], pRequestContainer->aData[i].pSchema)) {
                    dwSchemaId = j;
                    break;
                }
            }

            switch (dwSchemaId) {
            case 0:
                // duplex
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_BOOL;
                pResponse->aData[i].data.u.bData = TRUE;
                break;
            case 1:
                // multiple channel
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_BOOL;
                pResponse->aData[i].data.u.bData = FALSE;
                break;
            case 2:
                // Version
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_INT;
                pResponse->aData[i].data.u.iData = 1;
                break;
            case 3:
                // BidiProtocol
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_ENUM;
                pResponse->aData[i].data.u.sData = (LPWSTR) RouterAllocBidiMem (
                    sizeof (WCHAR) * (lstrlen (BIDI_PJL) + 1));;
                lstrcpy (pResponse->aData[i].data.u.sData , BIDI_PJL);
                break;

            case 4:
                // Ink Level
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = S_OK;
                pResponse->aData[i].data.dwBidiType = BIDI_FLOAT;
                pResponse->aData[i].data.u.fData = (FLOAT) 0.69;
                break;

            default:
                pResponse->aData[i].dwReqNumber = i;
                pResponse->aData[i].dwResult = E_FAIL;
            }
        }
    }
    else if (!lstrcmpi (pszAction, BIDI_ACTION_GET_ALL)) {

        dwCount = pRequestContainer->Count;
        pResponse = RouterAllocBidiResponseContainer (256);
        SPLASSERT (pResponse);
        pResponse->Version = 1;
        pResponse->Count = 256;

        for (i = 0; i < dwCount; i++) {
            if (!lstrcmpi (pRequestContainer->aData[i].pSchema, ppszSchema[5])) {

                for (j = 0; j < 3; j++) {
                    pResponse->aData[dwIndex].dwReqNumber = i;
                    pResponse->aData[dwIndex].pSchema = (LPTSTR) RouterAllocBidiMem (
                        sizeof (TCHAR) * (lstrlen (BIDI_ALERTNAME) + 1));
                    lstrcpy (pResponse->aData[dwIndex].pSchema, BIDI_ALERTNAME);
                    pResponse->aData[dwIndex].dwResult = S_OK;
                    pResponse->aData[dwIndex].data.dwBidiType = BIDI_ENUM;
                    pResponse->aData[dwIndex].data.u.sData = (LPTSTR) RouterAllocBidiMem (
                        sizeof (TCHAR) * (lstrlen (BIDI_ALERTVALUE) + 1));
                    lstrcpy (pResponse->aData[dwIndex].data.u.sData, BIDI_ALERTVALUE);
                    dwIndex ++;
                }
            }
            else {
                pResponse->aData[dwIndex].dwReqNumber = i;
                pResponse->aData[dwIndex].dwResult = E_FAIL;
                dwIndex++;
            }
        }
        pResponse->Count = dwIndex;
    }
    else {
        pResponse = NULL;
    }

    *ppResponse = pResponse;
    return 0;
}


VOID WINAPI
PJLShutdown (
    HANDLE hMonitor
    )
{
}


MONITOR2 Monitor2 = {
    sizeof(MONITOR2),
    NULL,                           // EnumPrinters not supported
    NULL,                           // OpenPort  not supported
    PJLMonOpenPortEx,
    PJLMonStartDocPort,
    PJLMonWritePort,
    PJLMonReadPort,
    PJLMonEndDocPort,
    PJLMonClosePort,
    NULL,                           // AddPort not supported
    NULL,                           // AddPortEx not supported
    NULL,                           // ConfigurePort not supported
    NULL,                           // DeletePort not supported
    PJLMonGetPrinterDataFromPort,
    NULL,                           // SetPortTimeOuts not supported
    NULL,                           // XcvOpen
    NULL,                           // XcvData
    NULL,                           // XcvClose
    PJLShutdown,                    // Shutdown
    PJLMonBidiSendRecv
};


LPMONITOR2
WINAPI
InitializePrintMonitor2(
    IN     PMONITORINIT pMonitorInit,
    IN     PHANDLE phMonitor

)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll
    lpMonitor       : Pointer to monitor fucntion table to be filled

Return Value:
    TRUE on successfully initializing the monitor, false on error.

--*/
{

    if ( !pMonitorInit || !(pMonitorInit->hckRegistryRoot)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if ( UpdateTimeoutsFromRegistry(pMonitorInit->hSpooler,
                                    pMonitorInit->hckRegistryRoot,
                                    pMonitorInit->pMonitorReg) != ERROR_SUCCESS ) {

        return NULL;
    }

    *phMonitor = NULL;

    return &Monitor2;
}


#define NTOKEN  20

DWORD
ProcessPJLString(
    PINIPORT    pIniPort,
    LPSTR       pInString,
    DWORD      *lpcbProcessed
)
/*++

Routine Description:
    Process a PJL string read from the printer

Arguments:
    pIniPort        : Ini port
    pInString       : Input string to process
    lpcbProcessed   : On return set to the amount of data processed

Return Value:
    Status value of the processing

--*/
{
    TOKENPAIR tokenPairs[NTOKEN];
    DWORD nTokenParsedRet;
    LPSTR lpRet;
    DWORD status = 0;

    lpRet = pInString;

#ifdef DEBUG
    OutputDebugStringA("String to process: <");
    OutputDebugStringA(pInString);
    OutputDebugStringA(">\n");
#endif

    for (*lpcbProcessed = 0; *pInString != 0; pInString = lpRet) {

        //
        // hack to determine if printer is bi-di.  LJ 4 does not have p1284
        // device ID so we do PCL memory query and see if it returns anything
        //
        if (!(pIniPort->status & PP_IS_PJL) &&
            !mystrncmp(pInString, "PCL\015\012INFO MEMORY", 16) )
            pIniPort->status |= PP_IS_PJL;

        status = GetPJLTokens(pInString, NTOKEN, tokenPairs,
                              &nTokenParsedRet, &lpRet);

        if (status == STATUS_REACHED_END_OF_COMMAND_OK) {

            pIniPort->status |= PP_IS_PJL;
            InterpreteTokens(pIniPort, tokenPairs, nTokenParsedRet);
        } else {

            ProcessParserError(status);
        }

        //
        // if a PJL command straddles between buffers
        //
        if (status == STATUS_END_OF_STRING)
            break;

        *lpcbProcessed += (DWORD)(lpRet - pInString);
    }

    return status;
}


DWORD
SeverityFromPjlStatus(
    DWORD   dwPjlStatus
    )
{
    if ( dwPjlStatus >= 10000 && dwPjlStatus < 12000 ) {

        //
        // 10xyz
        // 11xyz : load paper (paper available on another tray)
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus >= 30000 && dwPjlStatus < 31000 ) {

        //
        // 30xyz : Auto continuable errors
        //
        return PORT_STATUS_TYPE_WARNING;

    } else if ( dwPjlStatus >= 35000 && dwPjlStatus < 36000 ) {

        //
        // 35xyz : Potential operator intervention conditions
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus > 40000 && dwPjlStatus < 42000 ) {

        //
        // 40xyz : Operator intervention required
        // 41xyz : Load paper errors
        //
        return PORT_STATUS_TYPE_ERROR;
    }

    DBGMSG(DBG_ERROR,
           ("SeverityFromPjlStatus: Unknown status %d\n", dwPjlStatus));
    return PORT_STATUS_TYPE_INFO;
}


VOID
InterpreteTokens(
    PINIPORT pIniPort,
    PTOKENPAIR tokenPairs,
    DWORD nTokenParsed
)
/*++

Routine Description:
    Interpret succesfully read PJL tokens

Arguments:
    pIniPort        : Ini port
    tokenPairs      : List of token pairs
    nTokenParsed    : Number of token pairs

Return Value:
    None

--*/
{
    DWORD                   i, OldStatus;
    PJLTOPRINTERSTATUS     *pMap;
    PORT_INFO_3             PortInfo3;
    DWORD                   dwSeverity = 0;
    HANDLE                  hToken;

#ifdef DEBUG
    char    msg[CBSTRING];
    msg[0]  = '\0';
#endif

    OldStatus = pIniPort->PrinterStatus;
    pIniPort->PrinterStatus = 0;

    for (i = 0; i < nTokenParsed; i++) {

        // DBGMSG(DBG_INFO, ("pjlmon!Token=0x%x, Value=%d\n",
        //                   tokenPairs[i].token, tokenPairs[i].value));

        switch(tokenPairs[i].token) {

        case TOKEN_INFO_STATUS_CODE:
        case TOKEN_USTATUS_DEVICE_CODE:

            for (pMap = PJLToStatus; pMap->pjl; pMap++) {

                if (pMap->pjl == tokenPairs[i].value) {

                    pIniPort->PrinterStatus = pMap->status;
                    dwSeverity = SeverityFromPjlStatus(pMap->pjl);
                    if ( dwSeverity == PORT_STATUS_TYPE_ERROR )
                        pIniPort->status |= PP_PRINTER_OFFLINE;
                    else
                        pIniPort->status &= ~PP_PRINTER_OFFLINE;
                    break;
                }
            }

            if ( pMap->pjl && pMap->pjl == tokenPairs[i].value )
                break;

            //
            // some printers use this to signal online/ready
            //
            if ( tokenPairs[i].value == 10001  ||
                 tokenPairs[i].value == 10002  ||
                 tokenPairs[i].value == 11002 ) {

                pIniPort->status       &= ~PP_PRINTER_OFFLINE;
                pIniPort->PrinterStatus = 0;
                dwSeverity              = 0;
            }


            //
            // background or foreground paper out
            //
            if ( tokenPairs[i].value > 11101 && tokenPairs[i].value < 12000  ||
                 tokenPairs[i].value > 41101 && tokenPairs[i].value < 42000 ) {

                pIniPort->PrinterStatus  = PORT_STATUS_PAPER_OUT;

                if ( tokenPairs[i].value > 4000 ) {

                    dwSeverity           = PORT_STATUS_TYPE_ERROR;
                    pIniPort->status    |= PP_PRINTER_OFFLINE;
                } else {

                    dwSeverity = PORT_STATUS_TYPE_WARNING;
                }
            } else if (tokenPairs[i].value > 40000) {

                pIniPort->PrinterStatus = PORT_STATUS_USER_INTERVENTION;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }

            break;

        case TOKEN_INFO_STATUS_ONLINE:
        case TOKEN_USTATUS_DEVICE_ONLINE:

            // DBGMSG(DBG_INFO, ("PJLMON:ONLINE = %d\n", tokenPairs[i].value));

            if (tokenPairs[i].value) {

                pIniPort->status        &= ~PP_PRINTER_OFFLINE;
                dwSeverity = pIniPort->PrinterStatus ? PORT_STATUS_TYPE_WARNING :
                                                       0;
            } else {

                if ( !pIniPort->PrinterStatus )
                    pIniPort->PrinterStatus = PORT_STATUS_OFFLINE;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }
            break;

        case TOKEN_USTATUS_JOB_NAME_MSJOB:

#ifdef DEBUG
            sprintf(msg, "EOJ for %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            SendJobLastPageEjected(pIniPort, (DWORD)tokenPairs[i].value, FALSE);
            break;

        case TOKEN_INFO_CONFIG_MEMORY:
        case TOKEN_INFO_CONFIG_MEMORY_SPACE:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

#ifdef DEBUG
            sprintf(msg, "PJLMON installed memory %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            pIniPort->dwInstalledMemory = (DWORD)tokenPairs[i].value;
            break;

        case TOKEN_INFO_MEMORY_TOTAL:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

#ifdef DEBUG
            sprintf(msg, "PJLMON available memory %d\n", tokenPairs[i].value);
            OutputDebugStringA(msg);
#endif
            pIniPort->dwAvailableMemory = (DWORD)tokenPairs[i].value;
            break;

        default:
            break;
        }
    }

    if ( OldStatus != pIniPort->PrinterStatus ) {

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        PortInfo3.dwStatus      = pIniPort->PrinterStatus;
        PortInfo3.dwSeverity    = dwSeverity;

        if ( !SetPort(NULL,
                      pIniPort->pszPortName,
                      3,
                      (LPBYTE)&PortInfo3) ) {

            DBGMSG(DBG_WARNING,
                   ("pjlmon: SetPort failed %d (LE: %d)\n",
                    pIniPort->PrinterStatus, GetLastError()));

            pIniPort->PrinterStatus = OldStatus;
        }
    }
}


VOID
ProcessParserError(
    DWORD status
)
/*++

Routine Description:
    Print error messages on parsing error

Arguments:
    status  : status

Return Value:
    None

--*/
{
#ifdef DEBUG
    LPSTR pString;

    switch (status)
    {
    case STATUS_REACHED_END_OF_COMMAND_OK:
        pString = "STATUS_REACHED_END_OF_COMMAND_OK\n";
        break;

    case STATUS_CONTINUE:
        pString = "STATUS_CONTINUE\n";
        break;

    case STATUS_REACHED_FF:
        pString = "STATUS_REACHED_FF\n";
        break;

    case STATUS_END_OF_STRING:
        pString = "STATUS_END_OF_STRING\n";
        break;

    case STATUS_SYNTAX_ERROR:
        pString = "STATUS_SYNTAX_ERROR\n";
        break;

    case STATUS_ATPJL_NOT_FOUND:
        pString = "STATUS_ATPJL_NOT_FOUND\n";
        break;

    case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
        pString = "STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n";
        break;

    default:
        pString = "INVALID STATUS RETURNED!!!!!!\n";
        break;
    };

    OutputDebugStringA(pString);
#endif
}


#define MODEL                       "MODEL:"
#define MDL                         "MDL:"
#define COMMAND                     "COMMAND SET:"
#define CMD                         "CMD:"
#define COLON                       ':'
#define SEMICOLON                   ';'


LPSTR
FindP1284Key(
    PINIPORT    pIniPort,
    LPSTR   lpKey
    )
/*++

Routine Description:
    Find the 1284 key identifying the device id

Arguments:
    status  : status

Return Value:
    Pointer to the command string, NULL if not found.

--*/
{
    LPSTR   lpValue;                // Pointer to the Key's value
    WORD    wKeyLength;             // Length for the Key (for stringcmps)
    LPSTR   bRet = NULL;

    // While there are still keys to look at.
#ifdef DEBUG
    OutputDebugStringA("PJLMon!DeviceId : <");
    OutputDebugStringA(lpKey);
    OutputDebugStringA(">\n");
#endif

    while (lpKey && *lpKey) {

        //
        // Is there a terminating COLON character for the current key?
        //
        if (!(lpValue = mystrchr(lpKey, COLON)) ) {

            //
            // N: OOPS, somthing wrong with the Device ID
            //
            return bRet;
        }

        //
        // The actual start of the Key value is one past the COLON
        //
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (WORD)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        if ( *lpKey == 'C' ) {

            //
            // Look for COMMAND SET or CMD
            //
            if ( !mystrncmp(lpKey, COMMAND, wKeyLength) ||
                 !mystrncmp(lpKey, CMD, wKeyLength) ) {

                bRet = lpValue;
            }
        }

        // Go to the next Key

        if ( lpKey = mystrchr(lpValue, SEMICOLON) ) {

            *lpKey = '\0';
            ++lpKey;
        }
    }

    return bRet;
}


BOOL
IsPJL(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Finds out if the printer is a PJL bi-di printer

Arguments:
    pIniPort  : Points to an INIPORT

Return Value:
    TRUE if printer is PJL bi-di, else FALSE

    On failure PP_DONT_TRY_PJL is set

--*/
{
    char        szID[MAX_DEVID];
    DWORD       cbRet;
    LPSTR       lpCMD;
    HANDLE      hPort = (HANDLE)pIniPort;
    BOOL        bRet = FALSE;

    //
    // for printers that supports P1284 plug and play like LJ 4L, DJ540.
    // we parse the COMMAND string and see if PJL is supported
    //
    if (pIniPort->fn.pfnGetPrinterDataFromPort) {

        //
        // Only try P1284 if port monitor supports DeviceIOCtl
        //
        memset((LPBYTE)szID, 0, sizeof(szID));
        cbRet = 0;
        if ((*pIniPort->fn.pfnGetPrinterDataFromPort)
                (pIniPort->hPort, GETDEVICEID, NULL, NULL,
                    0, (LPWSTR)szID, sizeof(szID), &cbRet)
            && cbRet) {

            //
            // succeeded the P1284 plug and play protocol
            //
            szID[cbRet] = '\0';

            if ( lpCMD = FindP1284Key(pIniPort, szID) ) {

                // found the COMMAND string

                while (*lpCMD) {

                    //
                    // look for "PJL"
                    //
                    if ( lpCMD[0] == 'P' && lpCMD[1] == 'J' && lpCMD[2] == 'L' ){

                        pIniPort->status &= ~PP_DONT_TRY_PJL;
                        bRet = TRUE;
                        goto Cleanup;
                    }

                    lpCMD++;
                }

                pIniPort->status |= PP_DONT_TRY_PJL;
                goto Cleanup;
            }
        }

        //
        // fall thru to try PJL bi-di if we failed the P1284 communication
        // or P1284 didn't return a COMMAND string
        //
    }

    //
    // for printers that don't support P1284 plug and play, but support PJL
    // language command, like LJ 4 and 4M. we try to write/read PJL
    // command and see if it succeeds.
    // if we can't set the time outs we don't want to try to read, just fail.
    //
    if ( pIniPort->fn.pfnSetPortTimeOuts &&
         !(pIniPort->status & PP_DONT_TRY_PJL)) {

        COMMTIMEOUTS CTO;

        memset((LPSTR)&CTO, 0, sizeof(CTO));
        CTO.ReadTotalTimeoutConstant = 5000;
        CTO.ReadIntervalTimeout = 200;
        if ( !(*pIniPort->fn.pfnSetPortTimeOuts)(pIniPort->hPort, &CTO, 0) ) {

            goto Cleanup;
        }

        // This <ESC>*s1M is a PCL5 command to determine the amount of memory
        // in a PCL5 printer, and if the printer is PCL5 and bi-di capable,
        // it will return "PCL\015\012INFO MEMORY".
        // See PJL Tech Ref Manual page 7-21.

        pIniPort->status &= ~PP_IS_PJL;

        if ( !WriteCommand(hPort, "\033*s1M") )
            goto Cleanup;

        // ReadCommand->ProcessPJLString will set PP_IS_PJL
        // if we read any valid PJL command back from the printer

        if ( !ReadCommand(hPort) ) {

            //
            // We have jumped through the hoop to determin if this printer can
            // understand PJL.  It DOES NOT.  We are not going to try again.
            // until there is a printer change.
            //
            pIniPort->status |= PP_DONT_TRY_PJL;
        }

        if (pIniPort->status & PP_IS_PJL) {

            bRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( bRet ) {

        WriteCommand(hPort, "\033%-12345X@PJL \015\012@PJL USTATUS TIMED 30 \015\012\033%-12345X");
        pIniPort->dwLastReadTime = GetTickCount();
    }

    //return bRet;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\1394port.cpp ===
// 1394Port.cpp: implementation of the C1394Port class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

C1394Port::C1394Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, csz1394PortDesc )

{
   // Basically let the default constructor do the work.
}

C1394Port::~C1394Port()
{

}

PORTTYPE C1394Port::getPortType()
{
   return P1394PORT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\bidipjlmon\util.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

--*/

#include "precomp.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
MODULE_DEBUG_INIT( DBG_WARN|DBG_ERROR|DBG_INFO|DBG_TRACE, DBG_ERROR );
#endif
// @@END_DDKSPLIT

CRITICAL_SECTION pjlMonSection      = {0,0,0,0,0,0};

PINIPORT pIniFirstPort  = NULL;

DWORD dwReadThreadErrorTimeout;
DWORD dwReadThreadEOJTimeout;
DWORD dwReadThreadIdleTimeoutOther;

TCHAR cszEOJTimeout[]        = TEXT("EOJTimeout");


VOID
SplInSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread != (HANDLE) GetCurrentThreadId() ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Not in spooler semaphore !!\n"));
    }
}


VOID
SplOutSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread == (HANDLE) GetCurrentThreadId() ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Inside spooler semaphore !!\n"));
    }
}

VOID
EnterSplSem(
   VOID
    )
{
    EnterCriticalSection(&pjlMonSection);
}


VOID
LeaveSplSem(
   VOID
    )
{
    SplInSem();
    LeaveCriticalSection(&pjlMonSection);
}


VOID
UpdateRegistryValue(
    IN     HANDLE   hPrinter,
    IN     HKEY     hKey,
    IN     PMONITORREG pMonitorReg,
    IN     LPCTSTR  cszValueName,
    OUT    LPDWORD  pdwValue,
    IN     DWORD    dwDefault,
    IN OUT LPDWORD  pdwLastError
    )
/*++

Routine Description:
    Gets value assoicated with give value name from the registry. If value name
    is not found default value is written to registry.

    On error last error value is set to pdwLastError.

Arguments:
    hKey         : Registry key under which value should be searched
    pMonitorReg  : Port monitor registry function pointers
    cszValueName : Value name to search in the registry
    pdwValue     : On return will have the value
    dwDefault    : If value name not found in the registry set to this value
    pdwLastError : On error set last error to this

Return Value:
    None

--*/
{
    DWORD   dwSize = sizeof(*pdwValue);

    if ( *pdwLastError != ERROR_SUCCESS )
        return;

    if ( ERROR_SUCCESS != (* pMonitorReg->fpQueryValue) (hKey,
                                                        cszValueName,
                                                        NULL,
                                                        (LPBYTE)pdwValue,
                                                        &dwSize,
                                                        hPrinter) ) {

        *pdwValue = dwDefault;
        *pdwLastError = (* pMonitorReg->fpSetValue) (hKey,
                                                     cszValueName,
                                                     REG_DWORD,
                                                     (LPBYTE)pdwValue,
                                                     sizeof(*pdwValue),
                                                     hPrinter);
    }

}


DWORD
UpdateTimeoutsFromRegistry(      
    IN HANDLE      hPrinter,
    IN HKEY        hKey,
    IN PMONITORREG pMonitorReg
    )
/*++

Routine Description:
    Get the timeout values from the registry, or initialize registry with
    default values if entries are not found.

    Users/apps can change the registry to change the behavior.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    ERROR_SUCCESS on success, else last error value

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;

    UpdateRegistryValue(hPrinter,
                        hKey,
                        pMonitorReg,
                        cszEOJTimeout,
                        &dwReadThreadEOJTimeout,
                        READ_THREAD_EOJ_TIMEOUT,
                        &dwLastError);

    dwReadThreadErrorTimeout        = READ_THREAD_ERROR_WAITTIME;
    dwReadThreadIdleTimeoutOther    = READ_THREAD_IDLE_WAITTIME;

    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_ERROR,
               ("UpdateTimeoutsFromRegistry: Failed with %d", dwLastError));
    }

    return dwLastError;
}


PINIPORT
FindIniPort(
   IN LPTSTR pszName
    )
{
    PINIPORT    pIniPort = pIniFirstPort;

    if ( !pszName || !*pszName )
        return NULL;

    SplInSem();

    while ( pIniPort && lstrcmpi(pszName, pIniPort->pszPortName))
      pIniPort = pIniPort->pNext;

   return pIniPort;
}


PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    )
/*++

Routine Description:
    Creates a IniPort entry for a port. Needs to be called inside monitor
    critical section.

Arguments:
    pszPortName       : Name of the port

Return Value:
      On success pointer to the IniPort stucture.
      On failure NULL

--*/
{
    PINIPORT    pIniPort, pPort;
    HANDLE      DoneWriting = NULL;

    SplInSem();

    DoneWriting = CreateEvent(NULL, FALSE, TRUE, NULL);
    if ( !DoneWriting )
        return NULL;

    pIniPort = (PINIPORT) AllocSplMem(sizeof(*pIniPort));
    if ( !pIniPort ) {

        CloseHandle(DoneWriting);
        return NULL;
    }

    pIniPort->pszPortName       = AllocSplStr(pszPortName);

    if ( !pIniPort->pszPortName ) {

        CloseHandle(DoneWriting);
        FreeSplMem(pIniPort);
        return NULL;
    }

    pIniPort->pNext         = NULL;
    pIniPort->signature     = PJ_SIGNATURE;
    pIniPort->DoneWriting   = DoneWriting;

    pIniPort->pNext         = pIniFirstPort;
    pIniFirstPort           = pIniPort;

    return pIniPort;
}


VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    )
/*++

Routine Description:
    Deletes a port entry. Needs to be called inside monitor critical section

Arguments:
    pIniPort    : Pointer to the IniPort structure to be deleted

Return Value:

--*/
{
    SplInSem();

    if ( pIniPort == pIniFirstPort ) {

        pIniFirstPort = pIniPort->pNext;
    } else {

        PINIPORT    pPort;

        pPort = pIniFirstPort;
        while ( pPort && pPort->pNext != pIniPort )
            pPort = pPort->pNext;

        if (pPort) {

            pPort->pNext = pIniPort->pNext;
        } else {

            DBGMSG(DBG_ERROR, ("pjlmon: DeletePortEntry port not found\n"));
            return;
        }
    }

    CloseHandle(pIniPort->DoneWriting);
    FreeIniJobs(pIniPort);
    FreeSplStr(pIniPort->pszPortName);
    FreeSplMem(pIniPort);

    return;
}


VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    )
/*++

Routine Description:
    Deletes a job entry.

Arguments:
    pIniJob    : Pointer to the IniJob structure to be deleted

Return Value:
    None

--*/
{
    SPLASSERT(pIniJob);
    if ( pIniJob->hPrinter )
        ClosePrinter(pIniJob->hPrinter);
    FreeSplMem(pIniJob);
}


VOID
FreeIniJobs(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Free all the InJob structures assigned to this port

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed

--*/
{
    PINIJOB pIniJob, pIniNextJob;

    EnterSplSem();
    pIniJob = pIniPort->pIniJob;
    while ( pIniJob ) {

        pIniNextJob = pIniJob->pNext;
        FreeIniJob(pIniJob);
        pIniJob = pIniNextJob;
    }

    pIniPort->pIniJob = NULL;
    LeaveSplSem();
}


VOID
SendLastPageEjectedForIniJob(
    PINIPORT    pIniPort,
    PINIJOB     pIniJob
    )
{
    SplInSem();

    if ( !SetJob(pIniJob->hPrinter, pIniJob->JobId, 0,
                 NULL, JOB_CONTROL_LAST_PAGE_EJECTED) ) {

        DBGMSG(DBG_WARNING,
               ("SetJob failed with last error %d\n", GetLastError()));
    }
}


PINIJOB
FindIniJobFromJobId(
    PINIPORT    pIniPort,
    DWORD       dwJobId,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pCur, pPre, pIniJob;

    SplInSem();

    //
    // If JOB_RESTART is given there will be multiple jobs with same id
    // we need to find the last entry with given id in the list
    //
    for ( pCur = pIniPort->pIniJob, pPre = pIniJob = *ppPrevIniJob = NULL ;
          pCur ;
          pPre = pCur, pCur = pCur->pNext ) {

        if ( pCur->JobId == dwJobId ) {

            *ppPrevIniJob   = pPre;
            pIniJob         = pCur;
        }
    }

    return pIniJob;
}


PINIJOB
FindFirstIniJobTimedOut(
    PINIPORT    pIniPort,
    DWORD       dwTime,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pIniJob = pIniPort->pIniJob;

    SplInSem();
    *ppPrevIniJob = NULL;

    //
    // Look for a job not in STARTDOC and timedout
    //
    while ( pIniJob &&
            ( (pIniJob->status & PP_INSTARTDOC) ||
               pIniJob->TimeoutCount > dwTime ) ) {

        *ppPrevIniJob = pIniJob;
        pIniJob = pIniJob->pNext;
    }

    if ( !pIniJob )
        *ppPrevIniJob = NULL;

    return pIniJob;
}


VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    )
/*++

Routine Description:
    Send LastPageEjected notification for 1 or more jobs to spooler

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed
    dwValue     : if bTime is TRUE send EOJ to any jobs rcvd before dwValue
                  else dwValue is JobId -- ALL_JOBS is for all jobs
    bTime       : Tells how to interpret dwValue

--*/
{
    PINIJOB pIniJob;

    EnterSplSem();
    //
    // JobId == ALL_JOBS is a special case where we want to send LastPage
    // ejected for all jobs pending
    //
    if ( !bTime && dwValue == ALL_JOBS ) {

        pIniJob = pIniPort->pIniJob;
        pIniPort->pIniJob = NULL;

        while ( pIniJob ) {

            PINIJOB pTempJob = pIniJob;

            SendLastPageEjectedForIniJob(pIniPort, pIniJob);
            pIniJob = pIniJob->pNext;
            FreeIniJob(pTempJob);
        }

    } else {

        PINIJOB pPrevIniJob = NULL;

        pIniJob = pIniPort->pIniJob;

        //
        // If bTime we want to send LastPageEjected for all jobs timedout
        //
        if ( bTime )  {

            pIniJob = FindFirstIniJobTimedOut(pIniPort, dwValue, &pPrevIniJob);
        } else {

            pIniJob = FindIniJobFromJobId(pIniPort, dwValue, &pPrevIniJob);
        }

        if ( pIniJob ) {

            //
            // Send notifications for any previous jobs too
            //
            if ( pIniPort->pIniJob == pIniJob )
                pIniPort->pIniJob = NULL;
            else
                pPrevIniJob->pNext = NULL;

            do {

                SendLastPageEjectedForIniJob(pIniPort, pIniJob);

                pPrevIniJob = pIniJob;
                pIniJob = pIniJob->pNext;
                FreeIniJob(pPrevIniJob);
            } while ( pIniJob );
        }
    }

    LeaveSplSem();
}



// -----------------------------------------------------------------------
//
// DEBUG Stuff
//
// -----------------------------------------------------------------------
#ifdef DEBUG

DWORD SplDbgLevel = 0;

#ifndef INTERNAL

VOID cdecl DbgMsg( LPSTR MsgFormat, ... )
{
    char   MsgText[1024];

    sprintf(MsgText,MsgFormat,(LPSTR)(((LPSTR)(&MsgFormat))+sizeof(MsgFormat)) );
    strcat( MsgText, "\r");

    OutputDebugStringA(MsgText);
}
#endif

#endif


// -----------------------------------------------------------------------
//
// String helper function to remove crt dependency
//
// -----------------------------------------------------------------------
int
mystrnicmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}


LPSTR
mystrchr(
    LPSTR cs,
    char c
)
{
    while (*cs != 0)
    {
        if (IsDBCSLeadByte(*cs))
          cs++;
        else
        if (*cs == c)
            return cs;
        cs++;
    }

    // fail to find c in cs
    return NULL;
}


int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}


// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\1394port.h ===
// 1394Port.h: interface for the C1394Port class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_)
#define AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class C1394Port : public CBasePort
{
public:
   C1394Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~C1394Port();
   virtual PORTTYPE getPortType( void );

};

#endif // !defined(AFX_1394PORT_H__57C00EFD_2389_4D3D_A7D6_B67712ECD219__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved

Module Name:

    Debug.h

Abstract:

   Debug header for DynaMon

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef MODULE
#define MODULE "DynaMon:"
#define MODULE_DEBUG DynaMonDebug
#define LINK_SPLLIB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\dynadefs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaDefs.h

Abstract:
    Definitons & Declarations for global info

Author: M. Fenelon

Revision History:

--*/

#ifndef DYNADEFS_H

#define DYNADEFS_H

//
// Default timeout values
//
#define     READ_TIMEOUT_MULTIPLIER         0
#define     READ_TIMEOUT_CONSTANT       60000
#define     WRITE_TIMEOUT_MULTIPLIER        0
#define     WRITE_TIMEOUT_CONSTANT      60000

//
// Sizes
//
#define MAX_PORT_LEN                        20
#define MAX_PORT_DESC_LEN                   60
#define MAX_DEVICE_PATH                    256
#define PAR_QUERY_TIMEOUT                 5000

static const GUID USB_PRINTER_GUID =
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2}};

extern TCHAR   cszUSB[];
extern TCHAR   cszDOT4[];
extern TCHAR   cszTS[];
extern TCHAR   csz1394[];
extern TCHAR   cszBaseName[];
extern TCHAR   cszPortNumber[];
extern TCHAR   cszRecyclable[];
extern TCHAR   cszPortDescription[];
extern TCHAR   cszMaxBufferSize[];
extern TCHAR   cszUSBPortDesc[];
extern TCHAR   cszDot4PortDesc[];
extern TCHAR   csz1394PortDesc[];
extern TCHAR   cszTSPortDesc[];

enum PORTTYPE { USBPORT, DOT4PORT, TSPORT, P1394PORT, PARPORT, UNKNOWNPORT };

#define  DYNAMON_SIGNATURE   0x89AB

//
// Shortcuts for all Critical Section routines
//
#define  ECS(arg1)   EnterCriticalSection( &arg1 )
#define  LCS(arg1)   LeaveCriticalSection( &arg1 )
#define  ICS(arg1)   InitializeCriticalSection( &arg1 )
#define  DCS(arg1)   DeleteCriticalSection( &arg1 )

#define  IF_INVALID_PORT_FAIL( pPort )  if ( !pPort || ( pPort->dwSignature != DYNAMON_SIGNATURE ) )      \
                                        {  SetLastError(ERROR_PATH_NOT_FOUND); return FALSE; }

#define  SET_FLAGS   0
#define  ADD_FLAGS   1
#define  CLEAR_FLAGS 2


//  Define for Port Flags
#define  DYNAMON_STARTDOC          0x00000001

#define  JOB_ABORTCHECK_TIMEOUT    5000

#define  LPT_NOT_ERROR             0x08
#define  LPT_SELECT                0x10
#define  LPT_PAPER_EMPTY           0x20
#define  LPT_BENIGN_STATUS         LPT_NOT_ERROR | LPT_SELECT

#define  MAX_TIMEOUT               300000 //5 minutes

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\dot4port.h ===
// Dot4Port.h: interface for the Dot4Port class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_)
#define AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CDot4Port : public CBasePort
{
public:
   CDot4Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CDot4Port();
   PORTTYPE getPortType( void );

protected:
   BOOL checkPnP();

};

#endif // !defined(AFX_DOT4PORT_H__D808E471_8C2B_47D6_8CF1_3D4C3A73828D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\dynamon.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaMon.cpp

Abstract:
    Multiple Transport core port monitor routines

Author: M. Fenelon

Revision History:

--*/

#include "precomp.h"
#include "ntddpar.h"

// Global Values for Monitor
TCHAR   cszUSB[]                        = TEXT("USB");
TCHAR   cszDOT4[]                       = TEXT("DOT4");
TCHAR   cszTS[]                         = TEXT("TS");
TCHAR   csz1394[]                       = TEXT("1394");
TCHAR   cszBaseName[]                   = TEXT("Base Name");
TCHAR   cszPortNumber[]                 = TEXT("Port Number");
TCHAR   cszRecyclable[]                 = TEXT("recyclable");
TCHAR   cszPortDescription[]            = TEXT("Port Description");
TCHAR   cszMaxBufferSize[]              = TEXT("MaxBufferSize");
TCHAR   cszUSBPortDesc[]                = TEXT("Virtual printer port for USB");
TCHAR   cszDot4PortDesc[]               = TEXT("Virtual printer port for Dot4");
TCHAR   csz1394PortDesc[]               = TEXT("Virtual printer port for 1394");
TCHAR   cszTSPortDesc[]                 = TEXT("Virtual printer port for TS");

DYNAMON_MONITOR_INFO gDynaMonInfo;

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

BOOL
APIENTRY
DllMain(
       HANDLE hModule,
       DWORD dwReason,
       LPVOID lpRes
       )
{

   if ( dwReason == DLL_PROCESS_ATTACH )
      DisableThreadLibraryCalls(hModule);

   return TRUE;
}


//  Construct MonitorEx structure to provide to Spooler
MONITOREX MonitorEx = {
sizeof(MONITOR),
{
   DynaMon_EnumPorts,
   DynaMon_OpenPort,
   NULL,                           // OpenPortEx not supported
   DynaMon_StartDocPort,
   DynaMon_WritePort,
   DynaMon_ReadPort,
   DynaMon_EndDocPort,
   DynaMon_ClosePort,
   NULL,                           // AddPort not supported
   NULL,                           // AddPortEx not supported
   NULL,                           // ConfigurePort not supported
   NULL,                           // DeletePort not supported
   DynaMon_GetPrinterDataFromPort,
   DynaMon_SetPortTimeOuts,
   NULL,                           // XcvOpenPort not supported
   NULL,                           // XcvDataPort not supported
   NULL                            // XcvClosePort not supported
}
};


LPMONITOREX
WINAPI
InitializePrintMonitor(
                      LPTSTR  pszRegistryRoot
                      )

{
   BOOL bEnumPortsCS = FALSE;
   BOOL bUpdateListCS = FALSE;
   LPMONITOREX pMonitorEx = NULL;
   DWORD dwStatus = ERROR_SUCCESS;

   // Clear the Global info
   ZeroMemory( &gDynaMonInfo, sizeof(gDynaMonInfo) );

   if (dwStatus == ERROR_SUCCESS)
   {
       __try
       {
           InitializeCriticalSection (&gDynaMonInfo.EnumPortsCS);
           bEnumPortsCS = TRUE;
       }
       __except (EXCEPTION_EXECUTE_HANDLER)
       {
           dwStatus = GetExceptionCode ();
       }
   }

   if (dwStatus == ERROR_SUCCESS)
   {
       __try
       {
           InitializeCriticalSection (&gDynaMonInfo.UpdateListCS);
           bUpdateListCS = TRUE;
       }
       __except (EXCEPTION_EXECUTE_HANDLER)
       {
           dwStatus = GetExceptionCode ();
       }
   }
   if (dwStatus == ERROR_SUCCESS)
   {
       gDynaMonInfo.hUpdateEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
       if (gDynaMonInfo.hUpdateEvent == NULL)
       {
           dwStatus = GetLastError ();
       }
   }
   if (dwStatus == ERROR_SUCCESS)
   {
       //
       // Get the Background Thread going
       //
       dwStatus = SpinUpdateThread ();
   }
   //
   //
   if (dwStatus == ERROR_SUCCESS)
   {
       pMonitorEx = &MonitorEx;
   }
   else
   {
       if (bEnumPortsCS)
       {
           DeleteCriticalSection (&gDynaMonInfo.EnumPortsCS);
       }
       if (bUpdateListCS)
       {
           DeleteCriticalSection (&gDynaMonInfo.UpdateListCS);
       }
       if (gDynaMonInfo.hUpdateEvent)
       {
           CloseHandle (&gDynaMonInfo.hUpdateEvent);
       }
       ZeroMemory( &gDynaMonInfo, sizeof(gDynaMonInfo) );
       SetLastError (dwStatus);
   }
   return pMonitorEx;
}


BOOL
WINAPI
DynaMon_EnumPorts(
                LPTSTR      pszName,
                DWORD       dwLevel,
                LPBYTE      pPorts,
                DWORD       cbBuf,
                LPDWORD     pcbNeeded,
                LPDWORD     pcReturned
                )
{
   DWORD          dwLastError = ERROR_SUCCESS, dwRequestIndex;
   LPBYTE         pEnd;
   PDYNAMON_PORT  pPortList;
   PPORT_UPDATE   pPortUpdateList = NULL;

   *pcbNeeded = *pcReturned = 0;
   if ( dwLevel != 1 && dwLevel != 2 )
   {

      SetLastError(ERROR_INVALID_LEVEL);
      return FALSE;
   }

   dwRequestIndex = gDynaMonInfo.dwLastEnumIndex;
   ECS( gDynaMonInfo.EnumPortsCS );

   if ( dwRequestIndex >= gDynaMonInfo.dwLastEnumIndex )
   {
      //
      // No complete enumeration has occurred since this request was made.
      // Since the request may be an indication that something has changed,
      // the full reenumeration must be done.
      //
      // Updated the index of enumeration before actually doing the
      // work so it will show up as the most conservative
      //
      // Consequence of rollover on gdwLastEnumIndex:
      //     Any threads that recorded 0xFFFFFFFF as the dwRequestIndex
      // will show as greater than the new value 0 and therefore reenum
      // gratuitously. Not very much extra work.
      //
      ++gDynaMonInfo.dwLastEnumIndex;
      if ( dwLastError = BuildPortList( &gDynaMonInfo, &pPortUpdateList) )
         goto Done;
   }

   for ( pPortList = gDynaMonInfo.pPortList ;
         pPortList ;
         pPortList = pPortList->pNext )
   {
      *pcbNeeded += pPortList->pBasePort->getEnumInfoSize( dwLevel );
   }

   if ( cbBuf < *pcbNeeded )
   {
      dwLastError = ERROR_INSUFFICIENT_BUFFER;
      goto Done;
   }

   pEnd = pPorts + cbBuf;

   for ( pPortList = gDynaMonInfo.pPortList ;
         pPortList ;
         pPortList = pPortList->pNext )
   {

      pEnd = pPortList->pBasePort->copyEnumInfo( dwLevel, pPorts, pEnd );
      if ( dwLevel == 1 )
          pPorts += sizeof(PORT_INFO_1);
      else
          pPorts += sizeof(PORT_INFO_2);
      ++(*pcReturned);

   }

   SPLASSERT(pEnd >= pPorts);

Done:
   // If we have anything to update do it now
   if ( pPortUpdateList )
      PassPortUpdateListToUpdateThread( pPortUpdateList );

   LCS( gDynaMonInfo.EnumPortsCS );

   if ( dwLastError )
   {
      SetLastError(dwLastError);
      return FALSE;
   }
   else
      return TRUE;
}


BOOL
WINAPI
DynaMon_OpenPort(
                LPTSTR      pszPortName,
                LPHANDLE    pHandle
                )
{
   PDYNAMON_PORT   pPort, pPrev;

   pPort = FindPort( &gDynaMonInfo, pszPortName,  &pPrev);

   if ( pPort )
   {
      *pHandle = (LPHANDLE)pPort;
      pPort->pBasePort->InitCS();
      return TRUE;
   }
   else
   {
      SetLastError(ERROR_PATH_NOT_FOUND);
      return FALSE;
   }
}


BOOL
WINAPI
DynaMon_ClosePort(
                 HANDLE  hPort
                 )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   pPort->pBasePort->ClearCS();
   return TRUE;
}


BOOL
WINAPI
DynaMon_StartDocPort(
                    HANDLE  hPort,
                    LPTSTR  pPrinterName,
                    DWORD   dwJobId,
                    DWORD   dwLevel,
                    LPBYTE  pDocInfo
                    )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->startDoc( pPrinterName, dwJobId, dwLevel, pDocInfo );
}


BOOL
WINAPI
DynaMon_EndDocPort(
                  HANDLE  hPort
                  )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->endDoc();
}


BOOL
WINAPI
DynaMon_GetPrinterDataFromPort(
                              HANDLE      hPort,
                              DWORD       dwControlID,
                              LPWSTR      pValueName,
                              LPWSTR      lpInBuffer,
                              DWORD       cbInBuffer,
                              LPWSTR      lpOutBuffer,
                              DWORD       cbOutBuffer,
                              LPDWORD     lpcbReturned
                              )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->getPrinterDataFromPort( dwControlID, pValueName, lpInBuffer, cbInBuffer,
                                                    lpOutBuffer, cbOutBuffer, lpcbReturned );
}


BOOL
WINAPI
DynaMon_ReadPort(
                HANDLE      hPort,
                LPBYTE      pBuffer,
                DWORD       cbBuffer,
                LPDWORD     pcbRead
                )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->read( pBuffer, cbBuffer, pcbRead );
}


BOOL
WINAPI
DynaMon_WritePort(
                 HANDLE      hPort,
                 LPBYTE      pBuffer,
                 DWORD       cbBuffer,
                 LPDWORD     pcbWritten
                 )
{
   PDYNAMON_PORT pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->write( pBuffer, cbBuffer, pcbWritten );
}


BOOL
WINAPI
DynaMon_SetPortTimeOuts(
                       HANDLE hPort,
                       LPCOMMTIMEOUTS lpCTO,
                       DWORD reserved
                       )
{
   PDYNAMON_PORT   pPort = (PDYNAMON_PORT) hPort;

   IF_INVALID_PORT_FAIL( pPort )

   return pPort->pBasePort->setPortTimeOuts( lpCTO );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\baseport.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    BasePort.cpp

Abstract:
    Basic Port Class
    Implementation of the CBasePort class.

Author: M. Fenelon

Revision History:

--*/

//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ntddpar.h"

TCHAR   cszMonitorName[]                = TEXT("Dynamic Print Monitor");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBasePort::CBasePort()
   : m_cRef(0), m_dwFlags(0), m_hDeviceHandle(INVALID_HANDLE_VALUE),
     m_hPrinter(INVALID_HANDLE_VALUE), m_pWriteBuffer(NULL), m_dwBufferSize(0),
     m_dwDataSize(0), m_dwDataCompleted(0), m_dwDataScheduled(0), m_dwReadTimeoutMultiplier(READ_TIMEOUT_MULTIPLIER),
     m_dwReadTimeoutConstant(READ_TIMEOUT_CONSTANT), m_dwWriteTimeoutMultiplier(WRITE_TIMEOUT_MULTIPLIER),
     m_dwWriteTimeoutConstant(WRITE_TIMEOUT_CONSTANT), m_dwMaxBufferSize(0)
{

}


CBasePort::CBasePort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath, LPTSTR pszPortDesc )
   : m_cRef(0), m_dwFlags(0), m_bActive(bActive), m_hDeviceHandle(INVALID_HANDLE_VALUE),
     m_hPrinter(INVALID_HANDLE_VALUE), m_pWriteBuffer(NULL), m_dwBufferSize(0),
     m_dwDataSize(0), m_dwDataCompleted(0), m_dwDataScheduled(0), m_dwReadTimeoutMultiplier(READ_TIMEOUT_MULTIPLIER),
     m_dwReadTimeoutConstant(READ_TIMEOUT_CONSTANT), m_dwWriteTimeoutMultiplier(WRITE_TIMEOUT_MULTIPLIER),
     m_dwWriteTimeoutConstant(WRITE_TIMEOUT_CONSTANT), m_dwMaxBufferSize(0)
{
    // Setup the Port Name
   ::SafeCopy( MAX_PORT_LEN, pszPortName, m_szPortName );
   // Setup the DevicePath
   ::SafeCopy( MAX_PATH, pszDevicePath, m_szDevicePath );
   // Setup Port Description
   ::SafeCopy( MAX_PORT_DESC_LEN, pszPortDesc, m_szPortDescription );
}


CBasePort::~CBasePort()
{
   // Cleanup any left over resources
   if ( m_hDeviceHandle != INVALID_HANDLE_VALUE )
   {
      CloseHandle( m_hDeviceHandle );
      CloseHandle( m_Ov.hEvent );
   }
}


BOOL CBasePort::open()
{
   BOOL    bRet = FALSE;

   ECS( m_CritSec );

   if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
   {
      //
      // If we have an invalid handle and refcount is non-zero we want the
      // job to fail and restart to accept writes. In other words if the
      // handle got closed prematurely, because of failing writes, then we
      // need the ref count to go down to 0 before calling CreateFile again
      //
      if ( m_cRef )
         goto Done;

      m_hDeviceHandle = CreateFile( m_szDevicePath,
                                    GENERIC_WRITE | GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_OVERLAPPED,
                                    NULL);
      //
      // If we failed to open the port - test to see if it is a Dot4 port.
      //
      if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
      {
         //
         // ERROR_FILE_NOT_FOUND -> Error code for port not there.
         //
         if ( ERROR_FILE_NOT_FOUND != GetLastError() ||
              !checkPnP() )
            goto Done;
      }

      m_Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
      if ( m_Ov.hEvent == NULL )
      {
         CloseHandle(m_hDeviceHandle);
         m_hDeviceHandle = INVALID_HANDLE_VALUE;
         goto Done;
      }

   }

   ++m_cRef;
   bRet = TRUE;

Done:

   LCS( m_CritSec );
   return bRet;

}


BOOL CBasePort::close()
{
   BOOL bRet = TRUE;

   ECS( m_CritSec );

   --m_cRef;
   if ( m_cRef != 0 )
      goto Done;

   bRet = CloseHandle( m_hDeviceHandle);
   CloseHandle( m_Ov.hEvent);
   m_hDeviceHandle = INVALID_HANDLE_VALUE;

Done:
   LCS( m_CritSec );
   return bRet;

}


BOOL CBasePort::startDoc(LPTSTR pPrinterName, DWORD dwJobId, DWORD dwLevel, LPBYTE pDocInfo)
{
   BOOL bRet;
   SPLASSERT( notInWrite() );

   if ( !openPrinter( pPrinterName ) )
      return FALSE;

   m_dwJobId = dwJobId;
   bRet = open();

   if ( !bRet )
      closePrinter();
   else
      m_dwFlags |= DYNAMON_STARTDOC;

   return bRet;
}

BOOL CBasePort::endDoc()
{
   DWORD         dwLastError = ERROR_SUCCESS;

   dwLastError = sendQueuedData();
   freeWriteBuffer();

   m_dwFlags &= ~DYNAMON_STARTDOC;

   close();
   setJobStatus( JOB_CONTROL_SENT_TO_PRINTER );

   closePrinter();

   return TRUE;
}

BOOL CBasePort::read(LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead)
{
   DWORD               dwLastError = ERROR_SUCCESS;
   DWORD               dwTimeout;
   HANDLE              hReadHandle;
   OVERLAPPED          Ov;

   //
   // Create separate read handle since we have to cancel reads which do
   // not complete within the specified timeout without cancelling writes
   //
   hReadHandle = CreateFile( m_szDevicePath,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED,
                             NULL);

   if ( hReadHandle == INVALID_HANDLE_VALUE )
      return FALSE;

   ZeroMemory( &Ov, sizeof(Ov) );

   if ( !( Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL) ) )
      goto Done;

   if ( !ReadFile( hReadHandle, pBuffer, cbBuffer, pcbRead, &Ov ) &&
        ( dwLastError = GetLastError() ) != ERROR_IO_PENDING )
      goto Done;

   dwTimeout = m_dwReadTimeoutConstant +
               m_dwReadTimeoutMultiplier * cbBuffer;

   if ( dwTimeout == 0 )
      dwTimeout=MAX_TIMEOUT;

   if ( WaitForSingleObject( Ov.hEvent, dwTimeout ) == WAIT_TIMEOUT )
   {
      CancelIo( hReadHandle );
      WaitForSingleObject( Ov.hEvent, INFINITE );
   }

   if ( !GetOverlappedResult( hReadHandle, &Ov, pcbRead, FALSE ) )
   {
      *pcbRead = 0;
      dwLastError = GetLastError();
   }
   else
      dwLastError = ERROR_SUCCESS;

Done:
   if ( Ov.hEvent )
      CloseHandle( Ov.hEvent );

   CloseHandle( hReadHandle );

   if ( dwLastError )
      SetLastError(dwLastError);

   return dwLastError == ERROR_SUCCESS;
}


BOOL CBasePort::write(LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten)
{
   DWORD         dwLastError = ERROR_SUCCESS;
   DWORD         dwBytesLeft, dwBytesSent;
   DWORD         dwStartTime, dwTimeLeft, dwTimeout;
   BYTE          bPrinterStatus;
   BOOL          bStartDoc = ( ( m_dwFlags & DYNAMON_STARTDOC ) != 0 );

   *pcbWritten = 0;
   dwStartTime = GetTickCount();
   dwTimeout   = m_dwWriteTimeoutConstant + m_dwWriteTimeoutMultiplier * cbBuffer;

   if ( dwTimeout == 0 )
      dwTimeout = MAX_TIMEOUT;

   // Usbprint currently can't handle write greater than 4K.
   // For Win2K we will make a fix here, later usbprint will be fixed
   //
   // It is ok to change the size here since spooler will resubmit the rest
   // later
   //
   cbBuffer = adjustWriteSize( cbBuffer );

   //
   // For writes outside startdoc/enddoc we do not carry them across WritePort
   // calls. These are typically from language monitors (i.e. not job data)
   //
   SPLASSERT(bStartDoc || m_pWriteBuffer == NULL);

   if ( bStartDoc && ( m_hDeviceHandle == INVALID_HANDLE_VALUE ) )
   {
      setJobStatus( JOB_CONTROL_RESTART );
      SetLastError(ERROR_CANCELLED);
      return FALSE;
   }

   if ( !open() )
      return FALSE;

   // First complete any data from previous WritePort call
   while ( m_dwDataSize > m_dwDataCompleted )
   {

      if ( m_dwDataScheduled )
      {
         dwTimeLeft  = getTimeLeft( dwStartTime, dwTimeout );
         dwLastError = getWriteStatus( dwTimeLeft );
      }
      else
         dwLastError = writeData();

      if ( dwLastError != ERROR_SUCCESS )
         goto Done;
   }

   SPLASSERT(m_dwDataSize == m_dwDataCompleted   &&
             m_dwDataScheduled == 0                       &&
             dwLastError == ERROR_SUCCESS);

   //
   // Copy the data to our own buffer
   //
   if ( m_dwBufferSize < cbBuffer )
   {
      freeWriteBuffer();
      if ( m_pWriteBuffer = (LPBYTE) AllocSplMem( cbBuffer ) )
         m_dwBufferSize = cbBuffer;
      else
      {
         dwLastError = ERROR_OUTOFMEMORY;
         goto Done;
      }
   }

   // We have to clear the counters
   m_dwDataCompleted = m_dwDataScheduled = 0;

   CopyMemory( m_pWriteBuffer, pBuffer, cbBuffer );
   m_dwDataSize = cbBuffer;

   //
   // Now do the write for the data for this WritePort call
   //
   while ( m_dwDataSize > m_dwDataCompleted )
   {

      if ( m_dwDataScheduled )
      {

         dwTimeLeft  = getTimeLeft( dwStartTime, dwTimeout );
         dwLastError = getWriteStatus( dwTimeLeft );
      }
      else
         dwLastError = writeData();

      if ( dwLastError != ERROR_SUCCESS )
         break;
   }

   //
   // For writes outside startdoc/enddoc, which are from language monitors,
   // do not carry pending writes to next WritePort.
   //
   if ( !bStartDoc && m_dwDataSize > m_dwDataCompleted )
   {
      CancelIo( m_hDeviceHandle );
      dwLastError = getWriteStatus( INFINITE );
      *pcbWritten = m_dwDataCompleted;
      freeWriteBuffer();
   }

   //
   // We will tell spooler we wrote all the data if some data got scheduled
   //  (or scheduled and completed)
   //
   if ( m_dwDataCompleted > 0 || m_dwDataScheduled != 0 )
      *pcbWritten = cbBuffer;
   else
      freeWriteBuffer();

Done:

   if ( needToResubmitJob( dwLastError ) )
      invalidatePortHandle();
   else if ( dwLastError == ERROR_TIMEOUT )
   {
      if (getLPTStatus( m_hDeviceHandle, &bPrinterStatus ))
      {
          if ( bPrinterStatus & LPT_PAPER_EMPTY )
             dwLastError=ERROR_OUT_OF_PAPER;
      }
   }

   close();
   SetLastError(dwLastError);
   return dwLastError == ERROR_SUCCESS;

}


BOOL CBasePort::getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned )
{
   BOOL       bRet = FALSE;
   OVERLAPPED Ov;
   HANDLE     hDeviceHandle;
   DWORD      dwWaitResult;

   *lpcbReturned = 0;

   if ( dwControlID == 0 )
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   ZeroMemory(&Ov, sizeof(Ov));
   if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
      return FALSE;

   if ( !open() )
   {
      CloseHandle(Ov.hEvent);
      return FALSE;
   }

   if ( dwControlID == IOCTL_PAR_QUERY_DEVICE_ID )
   {
      hDeviceHandle = CreateFile( m_szDevicePath,
                                  GENERIC_WRITE | GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_FLAG_OVERLAPPED,
                                  NULL);

      if ( hDeviceHandle == INVALID_HANDLE_VALUE )
         goto Done;

      if ( !DeviceIoControl( m_hDeviceHandle, dwControlID, lpInBuffer, cbInBuffer, lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)
           && GetLastError() != ERROR_IO_PENDING )
      {
         CloseHandle( hDeviceHandle );
         goto Done;
      }

      if ( WaitForSingleObject( Ov.hEvent, PAR_QUERY_TIMEOUT ) != WAIT_OBJECT_0 )
         CancelIo( hDeviceHandle );

      bRet = GetOverlappedResult( m_hDeviceHandle, &Ov, lpcbReturned, TRUE );
      CloseHandle( hDeviceHandle );
   }
   else
   {
      if ( !DeviceIoControl( m_hDeviceHandle, dwControlID,
                             lpInBuffer, cbInBuffer,
                             lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)  &&
           GetLastError() != ERROR_IO_PENDING )
         goto Done;

      bRet = GetOverlappedResult( m_hDeviceHandle, &Ov, lpcbReturned, TRUE);
   }

Done:
   CloseHandle(Ov.hEvent);
   close();

   return bRet;
}

BOOL CBasePort::setPortTimeOuts( LPCOMMTIMEOUTS lpCTO )
{
   m_dwReadTimeoutConstant    =  lpCTO->ReadTotalTimeoutConstant;
   m_dwReadTimeoutMultiplier  =  lpCTO->ReadTotalTimeoutMultiplier;
   m_dwWriteTimeoutConstant   =  lpCTO->WriteTotalTimeoutConstant;
   m_dwWriteTimeoutMultiplier =  lpCTO->WriteTotalTimeoutMultiplier;

   return TRUE;
}


void CBasePort::InitCS()
{
   ICS( m_CritSec );
}


void CBasePort::ClearCS()
{
   DCS( m_CritSec );
}


PORTTYPE CBasePort::getPortType()
{
   return USBPORT;
}


LPTSTR CBasePort::getPortDesc()
{
   return m_szPortDescription;
}


void CBasePort::setPortDesc( LPTSTR pszPortDesc )
{
   if ( pszPortDesc )
      ::SafeCopy( MAX_PORT_DESC_LEN, pszPortDesc, m_szPortDescription );
}


BOOL CBasePort::isActive( void )
{
   return m_bActive;
}


void CBasePort::setActive( BOOL bValue )
{
   m_bActive = bValue;
}


BOOL CBasePort::compActiveState( BOOL bValue )
{
   return (m_bActive == bValue);
}


LPTSTR CBasePort::getPortName()
{
   return m_szPortName;
}


void CBasePort::setPortName(LPTSTR pszPortName)
{
   if ( pszPortName )
      ::SafeCopy( MAX_PORT_LEN, pszPortName, m_szPortName );
}


INT CBasePort::compPortName(LPTSTR pszPortName)
{
   return _tcsicmp( pszPortName, m_szPortName );
}


LPTSTR CBasePort::getDevicePath()
{
   return m_szDevicePath;
}


void CBasePort::setDevicePath(LPTSTR pszDevicePath)
{
   if ( pszDevicePath )
      ::SafeCopy( MAX_PATH, pszDevicePath, m_szDevicePath );
}


INT CBasePort::compDevicePath(LPTSTR pszDevicePath)
{
   return _tcsicmp( pszDevicePath, m_szDevicePath );
}


DWORD CBasePort::getEnumInfoSize(DWORD dwLevel )
{
   // Need to calcualted how much data will be used for this port
   DWORD dwBytesNeeded = 0;

   switch ( dwLevel )
   {
      case 1:
         // Start with size of Port Info struct
         dwBytesNeeded += sizeof( PORT_INFO_1 );
         // Add the length of the string
         dwBytesNeeded += ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR);
         break;
      case 2:
         // Start with size of Port Info struct
         dwBytesNeeded += sizeof( PORT_INFO_2 );
         // Add the length of the strings
         dwBytesNeeded += ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR);
         dwBytesNeeded += ( _tcslen( m_szPortDescription ) + 1 ) * sizeof(TCHAR);
         dwBytesNeeded += ( _tcslen( cszMonitorName ) + 1 ) * sizeof(TCHAR);
         break;
   }

   return dwBytesNeeded;
}


LPBYTE CBasePort::copyEnumInfo(DWORD dwLevel, LPBYTE pPort, LPBYTE pEnd)
{
   LPTSTR pStrStart;
   PPORT_INFO_1 pPort1 = (PPORT_INFO_1) pPort;
   PPORT_INFO_2 pPort2 = (PPORT_INFO_2) pPort;

   switch ( dwLevel )
   {
      case 2:
         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( m_szPortDescription ) + 1 ) * sizeof(TCHAR) ) );
         if (pPort < (LPBYTE) pStrStart)
         {
             (VOID) StringCchCopy (pStrStart, COUNTOF (m_szPortDescription), m_szPortDescription);
         }
         pPort2->pDescription = pStrStart;
         pEnd = (LPBYTE) pStrStart;

         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( cszMonitorName ) + 1 ) * sizeof(TCHAR) ) );
         if (pPort < (LPBYTE) pStrStart)
         {
             (VOID) StringCchCopy (pStrStart, COUNTOF (cszMonitorName), cszMonitorName);
         }
         pPort2->pMonitorName = pStrStart;
         pEnd = (LPBYTE) pStrStart;

      case 1:
         // Assign the Port name
         pStrStart = (LPTSTR) ( pEnd - ( ( _tcslen( m_szPortName ) + 1 ) * sizeof(TCHAR) ) );
         if (pPort < (LPBYTE) pStrStart)
         {
             (VOID) StringCchCopy (pStrStart, COUNTOF (m_szPortName), m_szPortName);
         }
         pPort1->pName = pStrStart;
   }

   return (LPBYTE) pStrStart;
}


BOOL CBasePort::notInWrite()
{
   return( m_pWriteBuffer    == NULL &&
           m_dwBufferSize    == 0    &&
           m_dwDataSize      == 0    &&
           m_dwDataCompleted == 0    &&
           m_dwDataScheduled == 0       );
}


BOOL CBasePort::openPrinter(LPTSTR pPrinterName)
{
    if (INVALID_HANDLE_VALUE != m_hPrinter)
    {
        //
        // Printer is already opened
        //
        return TRUE;
    }
    //
    // Opening the printer...
    //
    BOOL bRet =
        OpenPrinter (
            pPrinterName,
            &m_hPrinter,
            NULL
            );
    if (!bRet)
    {
        //
        // ...printer is not opened...
        //
        m_hPrinter = INVALID_HANDLE_VALUE;
    }
    return bRet;
}

void CBasePort::closePrinter()
{
   if (INVALID_HANDLE_VALUE != m_hPrinter)
   {
      ClosePrinter( m_hPrinter );
      m_hPrinter = INVALID_HANDLE_VALUE;
   }
}


void CBasePort::setJobStatus( DWORD dwJobStatus )
{
   // Make sure that we have a valid printer handle
   if ( m_hPrinter != INVALID_HANDLE_VALUE )
      SetJob( m_hPrinter, m_dwJobId, 0, NULL, dwJobStatus );
}


void CBasePort::setJobID(DWORD dwJobID)
{
   m_dwJobId = dwJobID;
}


DWORD CBasePort::getJobID()
{
   return m_dwJobId;
}


BOOL CBasePort::checkPnP()
{
   // If a class wants to do something, it needs to override
   return FALSE;
}


DWORD CBasePort::sendQueuedData()
{
   DWORD dwLastError = ERROR_SUCCESS;

   // Wait for any outstanding write to complete
   while ( m_dwDataSize > m_dwDataCompleted )
   {
      // If job needs to be aborted ask KM driver to cancel the I/O
      //
      if ( abortThisJob() )
      {
         if ( m_dwDataScheduled )
         {
            CancelIo( m_hDeviceHandle);
            dwLastError = getWriteStatus( INFINITE );
         }
         return dwLastError;
      }

      if ( m_dwDataScheduled )
         dwLastError = getWriteStatus( JOB_ABORTCHECK_TIMEOUT );
      else
      {
         // If for some reason KM is failing to complete all write do not
         // send data in a busy loop. Use 1 sec between Writes
         //
         if ( dwLastError != ERROR_SUCCESS )
            Sleep(1*1000);

         dwLastError = writeData();
      }

      //
      // Check if we can use the same handle and continue
      //
      if ( needToResubmitJob( dwLastError ) )
      {
         invalidatePortHandle();
         setJobStatus( JOB_CONTROL_RESTART );
      }
   }

   return dwLastError;
}


BOOL CBasePort::abortThisJob()
{
   BOOL            bRet = FALSE;
   DWORD           dwNeeded;
   LPJOB_INFO_1    pJobInfo = NULL;

   dwNeeded = 0;
   //
   if (INVALID_HANDLE_VALUE == m_hPrinter)
   {
       SetLastError (
           ERROR_INVALID_HANDLE
           );
       goto Done;
   }
   //
   GetJob( m_hPrinter, m_dwJobId, 1, NULL, 0, &dwNeeded);

   if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
      goto Done;

   if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
        !GetJob( m_hPrinter, m_dwJobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
      )
      goto Done;

   bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
          (pJobInfo->Status & JOB_STATUS_DELETED)  ||
          (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
   FreeSplMem(pJobInfo);

   return bRet;
}


/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS   : Write got done succesfully
    ERROR_TIMEOUT   : Timeout occured
    Others          : Write completed with a failure

--*/
DWORD CBasePort::getWriteStatus(DWORD dwTimeOut)
{
   DWORD   dwLastError = ERROR_SUCCESS;
   DWORD   dwWritten = 0;

   SPLASSERT( m_dwDataScheduled > 0);

   if ( WAIT_TIMEOUT == WaitForSingleObject( m_Ov.hEvent, dwTimeOut) )
   {
      dwLastError = ERROR_TIMEOUT;
      goto Done;
   }

   if ( !GetOverlappedResult( m_hDeviceHandle, &m_Ov,
                             &dwWritten, FALSE) )
   {
      if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
         dwLastError = STG_E_UNKNOWN;
   }

   ResetEvent( m_Ov.hEvent );

   // We are here because either a write completed succesfully,
   // or failed but the error is not serious enough to resubmit job
   if ( dwWritten <= m_dwDataScheduled )
      m_dwDataCompleted += dwWritten;
   else
      SPLASSERT( dwWritten <= m_dwDataScheduled );

   m_dwDataScheduled = 0;

Done:
   // Either we timed out, or write sheduled completed (success of failure)
   SPLASSERT( dwLastError == ERROR_TIMEOUT || m_dwDataScheduled == 0 );
   return dwLastError;
}


/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS : Write got succesfully scheduled
                    (may or may not have completed on return)
                    pPortInfo->dwScheduledData is the amount that got scheduled
    Others: Write failed, return code is the Win32 error

--*/
DWORD CBasePort::writeData()
{
   DWORD   dwLastError = ERROR_SUCCESS, dwDontCare;

   // When a sheduled write is pending we should not try to send data
   // any more
   SPLASSERT( m_dwDataScheduled == 0);

   // Send all the data that is not confirmed
   SPLASSERT( m_dwDataSize >= m_dwDataCompleted);
   m_dwDataScheduled = m_dwDataSize - m_dwDataCompleted;

   // Clear Overlapped fields before sending
   m_Ov.Offset = m_Ov.OffsetHigh = 0x00;
   if ( !WriteFile( m_hDeviceHandle, m_pWriteBuffer + m_dwDataCompleted,
                    m_dwDataScheduled, &dwDontCare, &m_Ov) )
   {
      if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
         dwLastError = STG_E_UNKNOWN;
      else if ( dwLastError == ERROR_IO_PENDING )
         dwLastError = ERROR_SUCCESS;
   }

   // If scheduling of the write failed then no data is pending
   if ( dwLastError != ERROR_SUCCESS )
      m_dwDataScheduled = 0;

   return dwLastError;
}


BOOL CBasePort::needToResubmitJob(DWORD dwError)
{
   //
   // I used winerror -s ntstatus to map KM error codes to user mode errors
   //
   // 5   ERROR_ACCESS_DENIED     <-->  c0000056 STATUS_DELETE_PENDING
   // 6   ERROR_INVALID_HANDLE    <-->  c0000008 STATUS_INVALID_HANDLE
   // 23  ERROR_CRC               <-->  c000003e STATUS_DATA_ERROR
   // 23  ERROR_CRC               <-->  c000003f STATUS_CRC_ERROR
   // 23  ERROR_CRC               <-->  c000009c STATUS_DEVICE_DATA_ERROR
   // 55  ERROR_DEV_NOT_EXIST     <-->  c00000c0 STATUS_DEVICE_DOES_NOT_EXIST
   // 303 ERROR_DELETE_PENDING    <-->  c0000056 STATUS_DELETE_PENDING
   // 995 ERROR_OPERATION_ABORTED
   //
   return dwError == ERROR_ACCESS_DENIED   ||
          dwError == ERROR_INVALID_HANDLE  ||
          dwError == ERROR_CRC             ||
          dwError == ERROR_DELETE_PENDING  ||
          dwError == ERROR_DEV_NOT_EXIST   ||
          dwError == ERROR_OPERATION_ABORTED;

}


void CBasePort::invalidatePortHandle()
{
   SPLASSERT( m_hDeviceHandle != INVALID_HANDLE_VALUE );

   CloseHandle( m_hDeviceHandle );
   m_hDeviceHandle = INVALID_HANDLE_VALUE;

   CloseHandle( m_Ov.hEvent );
   m_Ov.hEvent = NULL;

   freeWriteBuffer();
}


void CBasePort::freeWriteBuffer()
{
   FreeSplMem( m_pWriteBuffer );
   m_pWriteBuffer=NULL;

   m_dwBufferSize = m_dwDataSize
                  = m_dwDataCompleted
                  = m_dwDataScheduled = 0;
}


void CBasePort::setMaxBuffer(DWORD dwMaxBufferSize)
{
   m_dwMaxBufferSize = dwMaxBufferSize;
}


DWORD CBasePort::adjustWriteSize(DWORD dwBytesToWrite)
{
   // If this port has a data size limit....
   if ( m_dwMaxBufferSize )
   {
      // Check and adjust the current write size.
      if ( dwBytesToWrite > m_dwMaxBufferSize )
         dwBytesToWrite = m_dwMaxBufferSize;
   }

   return dwBytesToWrite;
}


DWORD CBasePort::getTimeLeft(DWORD dwStartTime, DWORD dwTimeout)
{
   DWORD dwCurrentTime;
   DWORD dwTimeLeft;

   if ( dwTimeout == MAX_TIMEOUT )
      return MAX_TIMEOUT;
   dwCurrentTime = GetTickCount();
   if ( dwTimeout < ( dwCurrentTime - dwStartTime ) )
      dwTimeLeft=0;
   else
      dwTimeLeft = dwTimeout - ( dwCurrentTime - dwStartTime );
   return dwTimeLeft;
}


BOOL CBasePort::getLPTStatus(HANDLE hDeviceHandle, BYTE *Status)
{
   BYTE StatusByte;
   OVERLAPPED Ov = {0};

   BOOL bResult;
   DWORD dwBytesReturned;
   DWORD dwLastError;
   Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
   if (Ov.hEvent)
   {
       bResult = DeviceIoControl( hDeviceHandle, IOCTL_USBPRINT_GET_LPT_STATUS, NULL,
                                  0, &StatusByte, 1, &dwBytesReturned, &Ov );
       dwLastError=GetLastError();
       if ( bResult || ( dwLastError == ERROR_IO_PENDING ) )
           bResult = GetOverlappedResult( hDeviceHandle, &Ov, &dwBytesReturned, TRUE );

       if ( bResult )
          *Status=StatusByte;
       else
          *Status=LPT_BENIGN_STATUS; //benign printer status...  0 would indicate a particular error status from the printer
       CloseHandle( Ov.hEvent );
   }
   else
   {
       bResult = FALSE;
   }
   return bResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\baseport.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    BasePort.h

Abstract:
    Interface for the CBasePort class.

Author: M. Fenelon

Revision History:

--*/

//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_)
#define AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CBasePort
{
public:
   CBasePort();
   CBasePort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath, LPTSTR pszPortDesc );
   virtual ~CBasePort();
   BOOL startDoc( LPTSTR pPrinterName, DWORD dwJobId, DWORD dwLevel, LPBYTE pDocInfo );
   BOOL endDoc();
   BOOL write( LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten );
   BOOL read( LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead );
   virtual BOOL getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );
   virtual BOOL setPortTimeOuts( LPCOMMTIMEOUTS lpCTO );
   void ClearCS();
   void InitCS();
   virtual PORTTYPE getPortType( void );
   LPTSTR getPortDesc();
   virtual void setPortDesc( LPTSTR pszPortDesc );
   // DWORD getDeviceFlags( void );
   // void setDeviceFlags(DWORD dwFlags, DWORD dwType = SET_FLAGS);
   // BOOL compDeviceFlags( DWORD dwFlags );
   BOOL isActive( void );
   void setActive( BOOL bValue );
   BOOL compActiveState( BOOL bValue );
   LPTSTR getDevicePath( void );
   void setDevicePath( LPTSTR pszDevicePath );
   INT compDevicePath( LPTSTR pszDevicePath );
   LPTSTR getPortName( void );
   void setPortName( LPTSTR pszPortName );
   INT compPortName( LPTSTR pszPortName );
   DWORD getEnumInfoSize( DWORD Level );
   LPBYTE copyEnumInfo( DWORD dwLevel, LPBYTE pPort, LPBYTE pEnd );
   void setMaxBuffer(DWORD dwMaxBufferSize);

protected:
   DWORD       m_cRef;
   DWORD       m_dwFlags;
   BOOL        m_bActive;              // Is this port currently Active
   DWORD       m_dwJobId;
   DWORD       m_dwMaxBufferSize;
   HANDLE      m_hDeviceHandle;
   HANDLE      m_hPrinter;
   LPBYTE      m_pWriteBuffer;
   DWORD       m_dwBufferSize,         // dwBufferSize     : size of buffer
               m_dwDataSize,           // dwDataSize       : size of data in buffer
                                       //      (could be smaller than dwBufferSize)
               m_dwDataCompleted,      // dwDataCompleted  : size of data sent and acknowledged
               m_dwDataScheduled;      // dwScheduledData  : size of data we have scheduled using WriteFile
   OVERLAPPED  m_Ov;
   CRITICAL_SECTION m_CritSec;
   DWORD       m_dwReadTimeoutMultiplier;
   DWORD       m_dwReadTimeoutConstant;
   DWORD       m_dwWriteTimeoutMultiplier;
   DWORD       m_dwWriteTimeoutConstant;
   TCHAR       m_szPortName[MAX_PORT_LEN];
   TCHAR       m_szPortDescription[MAX_PORT_DESC_LEN];
   TCHAR       m_szDevicePath[MAX_PATH];

   virtual BOOL checkPnP();
   BOOL getLPTStatus(HANDLE hDeviceHandle,BYTE *Status );
   DWORD getTimeLeft( DWORD dwStartTime,DWORD dwTimeout );
   void freeWriteBuffer();
   BOOL needToResubmitJob( DWORD dwError );
   DWORD getWriteStatus( DWORD dwTimeOut );
   BOOL abortThisJob();
   virtual DWORD adjustWriteSize( DWORD dwBytesToWrite );
   void invalidatePortHandle();
   DWORD sendQueuedData();
   DWORD writeData();
   BOOL close();
   void closePrinter();
   BOOL open();
   BOOL openPrinter( LPTSTR  pPrinterName );
   void setJobStatus( DWORD dwJobStatus );
   DWORD getJobID();
   void setJobID( DWORD dwJobID );
   BOOL notInWrite( void );

private:

};

#endif // !defined(AFX_BASEPORT_H__9B0AE97A_9ADB_4B48_846F_29D41B1263C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\dot4port.cpp ===
// Dot4Port.cpp: implementation of the Dot4Port class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "initguid.h"
#include "ntddpar.h"


const TCHAR cszCFGMGR32[]=TEXT("cfgmgr32.dll");

const CHAR cszReenumFunc[]="CM_Reenumerate_DevNode_Ex";
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDot4Port::CDot4Port( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszDot4PortDesc )
{
   // Basically let the default constructor do the work.
}


CDot4Port::~CDot4Port()
{

}


PORTTYPE CDot4Port::getPortType()
{
   return DOT4PORT;
}


BOOL CDot4Port::checkPnP()
{
   SETUPAPI_INFO      SetupApiInfo;
   BOOL               bRet = FALSE;
   DWORD              dwIndex, dwLastError;
   UINT               uOldErrorMode;
   HANDLE             hToken = NULL;
   HDEVINFO           hDevList = INVALID_HANDLE_VALUE;
   SP_DEVINFO_DATA    DeviceInfoData;
   HINSTANCE          hCfgMgr32 = 0;   // Library instance.
   // Pointers to the pnp function...
   pfCM_Reenumerate_DevNode_Ex pfnReenumDevNode;

   if ( !LoadSetupApiDll( &SetupApiInfo ) )
      return FALSE;

   // For a dot4 device we need to force a pnp event on the parallel port to get the
   // dot4 stack rebuilt.
   // If any of these fail, fail the call just as if the port couldn't be opened.
   //
   // Load the pnp dll.
   uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   hCfgMgr32 = LoadLibrary( cszCFGMGR32 );
   if(!hCfgMgr32)
   {
       SetErrorMode(uOldErrorMode);
       goto Done;
   }
   SetErrorMode(uOldErrorMode);

   //
   // Get the Addressed of pnp functions we want to call...
   //
   pfnReenumDevNode = (pfCM_Reenumerate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszReenumFunc );

   if( !pfnReenumDevNode )
       goto Done;

   hToken = RevertToPrinterSelf();
   if ( !hToken )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   hDevList = SetupApiInfo.GetClassDevs( (LPGUID) &GUID_PARALLEL_DEVICE,
                                         NULL, NULL, DIGCF_INTERFACEDEVICE);

   if ( hDevList == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   // Now get the DevInst handles for each DevNode
   dwLastError = ERROR_SUCCESS;
   dwIndex = 0;
   do
   {
      DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
      if ( !SetupApiInfo.EnumDeviceInfo( hDevList,
                                         dwIndex,
                                         &DeviceInfoData) )
      {
         dwLastError = GetLastError();
         if ( dwLastError == ERROR_NO_MORE_ITEMS )
            break;      // Normal exit

         DBGMSG(DBG_WARNING,
                ("DynaMon: Dot4.CheckPnP: SetupDiEnumDeviceInfo failed with %d for index %d\n",
                 dwLastError, dwIndex));
         goto Next;
      }

      // ReEnum on the current parallel port DevNode
      pfnReenumDevNode( DeviceInfoData.DevInst, CM_REENUMERATE_NORMAL, NULL );

Next:
      dwLastError = ERROR_SUCCESS;
      ++dwIndex;
   } while ( dwLastError == ERROR_SUCCESS );

   // Revert back to the user's context.
   if ( !ImpersonatePrinterClient(hToken) )
   {
      // Failure - Clear token so it won't happen again and save the error
      hToken = NULL;
      dwLastError = GetLastError();
      goto Done;
   }

   // Impersonate worked so clear token
   hToken = NULL;

   // Try and open the port again.
   // If we fail, then the device must not be there any more or still switched off - fail as usual.
   m_hDeviceHandle = CreateFile( m_szDevicePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL);

   if ( m_hDeviceHandle == INVALID_HANDLE_VALUE )
       goto Done;

   bRet = TRUE;

Done:
   if ( hDevList != INVALID_HANDLE_VALUE )
      SetupApiInfo.DestroyDeviceInfoList( hDevList );

   if (hToken)
   {
      if ( !ImpersonatePrinterClient(hToken) )
      {
         if (bRet)
         {
            dwLastError = GetLastError();
            bRet = FALSE;
         }
      }
   }

   if ( hCfgMgr32 )
      FreeLibrary( hCfgMgr32 );

   if ( SetupApiInfo.hSetupApi )
      FreeLibrary(SetupApiInfo.hSetupApi);

   SetLastError( dwLastError );
   return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\dynamon.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    DynaMon.h

Abstract:
    Definitons & Declarations for global info

Author: M. Fenelon

Revision History:

--*/

#include "DynaDefs.h"
#include "BasePort.h"

#ifndef DYNAMON_H

#define DYNAMON_H

typedef struct DynaMon_Port_Struct
{
   DWORD       dwSignature;
   struct      DynaMon_Port_Struct *pNext;
   CBasePort*  pBasePort;
} DYNAMON_PORT, *PDYNAMON_PORT;


typedef struct Port_Update_Struct
{
   struct Port_Update_Struct* pNext;
   TCHAR                      szPortName[MAX_PORT_LEN];
   HKEY                       hKey;
   BOOL                       bActive;
} PORT_UPDATE, *PPORT_UPDATE;

typedef struct  Useless_Port_Struct
{
   struct Useless_Port_Struct* pNext;
   TCHAR                       szDevicePath[MAX_PATH];
} USELESS_PORT, *PUSELESS_PORT;


//
// Global Data needed for Monitor
//
typedef struct  DynaMon_Monitor_Info_Struct
{
   DWORD             dwLastEnumIndex;
   PDYNAMON_PORT     pPortList;
   PUSELESS_PORT     pJunkList;
   CRITICAL_SECTION  EnumPortsCS,
                     UpdateListCS;
   PPORT_UPDATE      pUpdateList;
   HANDLE            hUpdateEvent;
} DYNAMON_MONITOR_INFO, *PDYNAMON_MONITOR_INFO;


extern DYNAMON_MONITOR_INFO gDynaMonInfo;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\enumutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    EnumUtil.cpp

Abstract:
    Utiltiy functions used by the EnumPorts function.

Author: M. Fenelon

Revision History:

--*/

#include "precomp.h"

TCHAR   sComma = TEXT(',');
TCHAR   sNull  = TEXT('\0');

DWORD
SpinUpdateThread( void )
{
   HANDLE  hThread = NULL;
   DWORD dwStatus = ERROR_SUCCESS;

   hThread = CreateThread (
       NULL,
       0,
       (LPTHREAD_START_ROUTINE)UpdateThread,
       &gDynaMonInfo,
       0,
       NULL
       );
   if (hThread)
  {
     CloseHandle(hThread);
  }
  else
  {
      dwStatus = GetLastError ();
  }
  return dwStatus;
}


VOID
UpdateThread(
    PDYNAMON_MONITOR_INFO   pMonInfo
    )
{
   PPORT_UPDATE        pUpdateList = NULL,
                       pNext;
   DWORD               dwPrinters;
   LPPRINTER_INFO_5    pPrinterInfo5List = NULL;
   BOOL bCheck;

   // Loop indefinitely
   while ( 1 )
   {
      // Wait for the Event to be signaled
      WaitForSingleObject( pMonInfo->hUpdateEvent, INFINITE );

      // Get access to the Update List Pointer
      ECS( pMonInfo->UpdateListCS );

      // Get the current list
      pUpdateList = pMonInfo->pUpdateList;
      pMonInfo->pUpdateList = NULL;

      // Release acces to the list pointer
      LCS( pMonInfo->UpdateListCS );

      dwPrinters = 0;
      pPrinterInfo5List = NULL;
      bCheck = GetPrinterInfo( &pPrinterInfo5List, &dwPrinters );

      // If there is anything in the list process it....
      while ( pUpdateList )
      {
         // First get a pointer to the next update
         pNext = pUpdateList->pNext;

         if ( bCheck &&
              !PortNameNeededBySpooler( pUpdateList->szPortName,
                                        pPrinterInfo5List,
                                        dwPrinters,
                                        pUpdateList->bActive )     &&
              !pUpdateList->bActive )
         {
             RegSetValueEx( pUpdateList->hKey, cszRecyclable, 0, REG_NONE, 0, 0);
         }

         // Close the Reg Key & Free the memory
         RegCloseKey( pUpdateList->hKey);
         FreeSplMem( pUpdateList );
         pUpdateList = pNext;
      }

      if ( pPrinterInfo5List )
         FreeSplMem( pPrinterInfo5List );

   }

}

BOOL
GetPrinterInfo(
              OUT LPPRINTER_INFO_5   *ppPrinterInfo5,
              OUT LPDWORD             pdwReturned
              )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_5s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPrinterInfo5  : Points to PRINTER_INFO_5s on return
    pdwReturned     : Tells how many PRINTER_INFO_5s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
   BOOL            bRet = FALSE;
   static  DWORD   dwNeeded = 0;
   LPBYTE          pBuf = NULL;

   *pdwReturned = 0;

   if ( !(pBuf = (LPBYTE) AllocSplMem( dwNeeded ) ) )
      goto Cleanup;

   if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                      NULL,
                      5,
                      pBuf,
                      dwNeeded,
                      &dwNeeded,
                      pdwReturned) )
   {
      if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
         goto Cleanup;

      FreeSplMem(pBuf);
      if ( !(pBuf = (LPBYTE) AllocSplMem( dwNeeded ) )   ||
           !EnumPrinters(PRINTER_ENUM_LOCAL,
                         NULL,
                         5,
                         pBuf,
                         dwNeeded,
                         &dwNeeded,
                         pdwReturned) )
      {
         goto Cleanup;
      }
   }

   bRet = TRUE;

Cleanup:

   if ( bRet && *pdwReturned )
   {
      *ppPrinterInfo5 = (LPPRINTER_INFO_5)pBuf;
   }
   else
   {
      FreeSplMem(pBuf);
      *ppPrinterInfo5 = NULL;
      *pdwReturned = 0;
   }

   return bRet;
}


BOOL
PortNameNeededBySpooler(
                       IN  LPTSTR           pszPortName,
                       IN  LPPRINTER_INFO_5 pPrinterInfo5,
                       IN  DWORD            dwPrinters,
                       IN  BOOL             bActive
                       )
/*++

Routine Description:
    Tells if a port is needed by spooler. Any port to which spooler currently
    has a printer going is needed.

Arguments:
    pszPortName         : Port name in question
    pPrinterInfo5       : List of PrinterInfo5s
    dwPrinters          : Count of the list of printers

Return Value:
    TRUE if spooler currently has a printer which is using the port
    FALSE otherwise

--*/
{
   BOOL    bPortUsedByAPrinter = FALSE,
           bPrinterUsesOnlyThisPort;
   DWORD   dwIndex;
   LPTSTR  pszStr1, pszStr2;

   for ( dwIndex = 0 ; dwIndex < dwPrinters ; ++dwIndex, ++pPrinterInfo5 )
   {

      bPrinterUsesOnlyThisPort = FALSE;
      //
      // Port names are returned comma separated by spooler,
      // and there are blanks
      //
      pszStr1 = pPrinterInfo5->pPortName;

      if ( _tcsicmp( (LPCTSTR) pszPortName, pszStr1 ) == 0 )
         bPortUsedByAPrinter = bPrinterUsesOnlyThisPort = TRUE;
      else
      {
         //
         // Look at each port in the list of ports printer uses
         //
         while ( pszStr2 = _tcschr( pszStr1, sComma ) )
         {
            *pszStr2 = sNull;
            if ( _tcsicmp( pszPortName, pszStr1 ) == 0 )
               bPortUsedByAPrinter = TRUE;
            *pszStr2 = sComma;  // Put the comma back

            if ( bPortUsedByAPrinter )
               break;

            pszStr1 = pszStr2 + 1;

            // Skip spaces
            while ( *pszStr1 == TEXT(' ') )
               ++pszStr1;
         }

         if ( !bPortUsedByAPrinter )
            bPortUsedByAPrinter = _tcsicmp( pszPortName, pszStr1 ) == 0;
      }

      // We will change only status of printer for non-pooled printers only
      if ( bPrinterUsesOnlyThisPort )
         SetOnlineStaus( pPrinterInfo5, bActive );
   }

   return bPortUsedByAPrinter;
}


BOOL
SetOnlineStaus(
              LPPRINTER_INFO_5    pPrinterInfo5,
              BOOL                bOnline
              )
{
   BOOL                bRet = FALSE;
   HANDLE              hPrinter;
   PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

   //
   // Don't change Online Status at all for TS ports
   //
   if ( _tcsnicmp( pPrinterInfo5->pPortName, cszTS, _tcslen(cszTS) ) == 0 )
      return TRUE;

   //
   // Force all DOT4 ports to remain online at all times.
   //
   if ( _tcsnicmp( pPrinterInfo5->pPortName, cszDOT4, _tcslen(cszDOT4) ) == 0 )
      bOnline = TRUE;

   //
   // Check if spooler already has the correct status
   //  (can happen on spooler startup)
   //
   if ( bOnline )
   {
      if ( !(pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) )
         return TRUE;
   }
   else
      if ( pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
         return TRUE;

   if ( !OpenPrinter( pPrinterInfo5->pPrinterName, &hPrinter, &PrinterDefault ) )
      return FALSE;

   if ( bOnline )
      pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
   else
      pPrinterInfo5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

   bRet = SetPrinter( hPrinter, 5, (LPBYTE)pPrinterInfo5, 0 );

   ClosePrinter( hPrinter );

   return bRet;
}


DWORD
BuildPortList(
             PDYNAMON_MONITOR_INFO pMonitorInfo,
             PPORT_UPDATE*         ppPortUpdateList
             )
{
   DWORD           dwLastError;
   SETUPAPI_INFO   SetupApiInfo;

   if ( !LoadSetupApiDll( &SetupApiInfo ) )
      return GetLastError();

   ECS( pMonitorInfo->EnumPortsCS );

   dwLastError = ProcessGUID( &SetupApiInfo, pMonitorInfo,
                              ppPortUpdateList, (LPGUID) &USB_PRINTER_GUID );

   LCS( pMonitorInfo->EnumPortsCS );

   if ( SetupApiInfo.hSetupApi )
      FreeLibrary(SetupApiInfo.hSetupApi);

   return dwLastError;
}


BOOL
LoadSetupApiDll(
               PSETUPAPI_INFO  pSetupInfo
               )
{
   UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   pSetupInfo->hSetupApi = LoadLibrary(TEXT("setupapi"));
   SetErrorMode(uOldErrMode);


   if ( !pSetupInfo->hSetupApi )
      return FALSE;

   pSetupInfo->DestroyDeviceInfoList = (pfSetupDiDestroyDeviceInfoList) GetProcAddress(pSetupInfo->hSetupApi,
                                                                "SetupDiDestroyDeviceInfoList");

   pSetupInfo->GetClassDevs = (pfSetupDiGetClassDevs) GetProcAddress(pSetupInfo->hSetupApi,
                                                       "SetupDiGetClassDevsW");

   pSetupInfo->EnumDeviceInfo = (pfSetupDiEnumDeviceInfo) GetProcAddress(pSetupInfo->hSetupApi,
                                                               "SetupDiEnumDeviceInfo");

   pSetupInfo->EnumDeviceInterfaces = (pfSetupDiEnumDeviceInterfaces) GetProcAddress(pSetupInfo->hSetupApi,
                                                               "SetupDiEnumDeviceInterfaces");

   pSetupInfo->GetDeviceInterfaceDetail = (pfSetupDiGetDeviceInterfaceDetail) GetProcAddress(pSetupInfo->hSetupApi,
                                                                   "SetupDiGetDeviceInterfaceDetailW");

   pSetupInfo->OpenDeviceInterfaceRegKey = (pfSetupDiOpenDeviceInterfaceRegKey) GetProcAddress(pSetupInfo->hSetupApi,
                                                                    "SetupDiOpenDeviceInterfaceRegKey");

   if ( !pSetupInfo->DestroyDeviceInfoList         ||
        !pSetupInfo->GetClassDevs                  ||
        !pSetupInfo->EnumDeviceInfo                ||
        !pSetupInfo->EnumDeviceInterfaces          ||
        !pSetupInfo->GetDeviceInterfaceDetail      ||
        !pSetupInfo->OpenDeviceInterfaceRegKey )
   {
      SPLASSERT(FALSE);
      FreeLibrary(pSetupInfo->hSetupApi);
      pSetupInfo->hSetupApi = NULL;
      return FALSE;
   }

   return TRUE;
}


DWORD
ProcessGUID(
           PSETUPAPI_INFO           pSetupApiInfo,
           PDYNAMON_MONITOR_INFO    pMonitorInfo,
           PPORT_UPDATE*            ppPortUpdateList,
           LPGUID                   pGUID
           )
{
   DWORD                               dwIndex, dwLastError, dwSize, dwNeeded;
   BOOL                                bIsPortActive;
   HANDLE                              hToken;
   HDEVINFO                            hDevList = INVALID_HANDLE_VALUE;
   PDYNAMON_PORT                       pPtr;
   PUSELESS_PORT                       pCur, pPrev;
   SP_DEVICE_INTERFACE_DATA            DeviceInterface;
   PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail = NULL;

   hToken = RevertToPrinterSelf();

   hDevList = pSetupApiInfo->GetClassDevs( pGUID,
                                           NULL,
                                           NULL,
                                           DIGCF_INTERFACEDEVICE);

   if ( hDevList == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   dwSize = sizeof(PSP_DEVICE_INTERFACE_DETAIL_DATA)
            + MAX_DEVICE_PATH * sizeof(TCHAR);

   pDeviceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA) AllocSplMem(dwSize);

   if ( !pDeviceDetail )
   {
      dwLastError = GetLastError();
      goto Done;
   }

   dwLastError = ERROR_SUCCESS;
   dwIndex = 0;
   pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
   DeviceInterface.cbSize  = sizeof(DeviceInterface);
   do
   {
      if ( !pSetupApiInfo->EnumDeviceInterfaces( hDevList,
                                                 NULL,
                                                 pGUID,
                                                 dwIndex,
                                                 &DeviceInterface) )
      {
         dwLastError = GetLastError();
         if ( dwLastError == ERROR_NO_MORE_ITEMS )
            break;      // Normal exit

         DBGMSG(DBG_WARNING,
                ("DynaMon: ProcessGUID: SetupDiEnumDeviceInterfaces failed with %d for inderx %d\n",
                 dwLastError, dwIndex));
         goto Next;
      }

      if ( !pSetupApiInfo->GetDeviceInterfaceDetail( hDevList,
                                                     &DeviceInterface,
                                                     pDeviceDetail,
                                                     dwSize,
                                                     &dwNeeded,
                                                     NULL) )
      {
         dwLastError = GetLastError();
         DBGMSG(DBG_ERROR,
                ("DynaMon: ProcessGUID: SetupDiGetDeviceInterfaceDetail failed with error %d size %d\n",
                 dwLastError, dwNeeded));
         goto Next;
      }

      //
      // This is the only flag we care about
      //
      bIsPortActive = (DeviceInterface.Flags & SPINT_ACTIVE);


      //
      // For inactive port if it is already known as a useless port
      // no need to process further
      //
      if ( !bIsPortActive && FindUselessEntry( pMonitorInfo, pDeviceDetail->DevicePath, &pPrev) )
      {
         goto Next;
      }

      //
      // When port active status did not change we should have nothing
      // to update. By skipping the PortUpdateInfo we avoid registry access
      // and it is a performance improvement
      //
      if ( (pPtr = FindPortUsingDevicePath( pMonitorInfo,
                                            pDeviceDetail->DevicePath ) )    &&
            pPtr->pBasePort->compActiveState( bIsPortActive ) )
      {
          if (!bIsPortActive && pPtr-> pBasePort-> getPortType () == TSPORT)
          {
              //
              // Potential update
              //
          }
          else
          {
              goto Next;
          }
      }

      ProcessPortInfo( pSetupApiInfo, pMonitorInfo, hDevList, &DeviceInterface,
                       pDeviceDetail, bIsPortActive, ppPortUpdateList);

Next:
      dwLastError = ERROR_SUCCESS;
      ++dwIndex;
      pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
      DeviceInterface.cbSize  = sizeof(DeviceInterface);
   } while ( dwLastError == ERROR_SUCCESS );

   if ( dwLastError == ERROR_NO_MORE_ITEMS )
      dwLastError = ERROR_SUCCESS;

Done:
   if ( hDevList != INVALID_HANDLE_VALUE )
      pSetupApiInfo->DestroyDeviceInfoList( hDevList );

   if ( !ImpersonatePrinterClient(hToken) )
      dwLastError = GetLastError();

   FreeSplMem(pDeviceDetail);

   return dwLastError;
}


PUSELESS_PORT
FindUselessEntry(
                IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                IN  LPTSTR                pszDevicePath,
                OUT PUSELESS_PORT*        ppPrev
                )

/*++
Routine Description:
    Searches for a device path in the useless port list

Arguments:

Return Value:
    NULL if no entry found in the list
    Else a valid USELESS_PORT_INFO pointer
    Weather port is found or not *ppPrev will return the previous element

--*/
{
   INT            iCmp;
   PUSELESS_PORT  pHead;

   for ( pHead = pMonitorInfo->pJunkList, *ppPrev = NULL ;
       pHead && (iCmp = lstrcmp(pszDevicePath, pHead->szDevicePath)) < 0 ;
       *ppPrev = pHead, pHead = pHead->pNext )
      ;

   //
   // If useless port should go in the middle but not currently there
   //
   if ( pHead && iCmp != 0 )
      pHead = NULL;

   return pHead;
}


PDYNAMON_PORT
FindPortUsingDevicePath(
                       IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                       IN  LPTSTR                pszDevicePath
                       )
/*++

Routine Description:
    Finds a port by device path.

Arguments:
    pMonitorInfo    : Pointer to MONITOR_INFO structure
    pszDevicePath   : Device path name to search for

Return Value:
    If NULL port is not in list, else pointer to the PORT_INFO entry for the
    given device path

--*/
{
   INT           iCmp;
   PDYNAMON_PORT pHead;

   ECS( pMonitorInfo->EnumPortsCS );

   //
   // Port list is sorted on port name, so we have to scan the whole list
   //
   for ( pHead = pMonitorInfo->pPortList ; pHead ; pHead = pHead->pNext )
      if ( pHead->pBasePort->compDevicePath( pszDevicePath ) == 0 )
         break;

   LCS( pMonitorInfo->EnumPortsCS );

   return pHead;
}


VOID
ProcessPortInfo(
               IN      PSETUPAPI_INFO                   pSetupApiInfo,
               IN      PDYNAMON_MONITOR_INFO            pMonitorInfo,
               IN      HDEVINFO                         hDevList,
               IN      PSP_DEVICE_INTERFACE_DATA        pDeviceInterface,
               IN      PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,
               IN      BOOL                             bIsPortActive,
               IN OUT  PPORT_UPDATE*                    ppPortUpdateList
               )
{
   HKEY                hKey = INVALID_HANDLE_VALUE;
   TCHAR               szPortName[MAX_PORT_LEN];
   PDYNAMON_PORT       pCur, pPrev;
   PORTTYPE            portType = USBPORT;

   hKey = GetPortNameAndRegKey( pSetupApiInfo, hDevList, pDeviceInterface,
                                szPortName, COUNTOF (szPortName), &portType );

   if ( hKey == INVALID_HANDLE_VALUE )
   {
      //
      // If this port is inactive and is not in our known port list
      // add to useless list. Earlier we would have been opening the registry
      // every time and find that port number is missing because of KM drivers
      // not deleting the inactive device interfaces
      //
      if ( !bIsPortActive  &&
           !FindPortUsingDevicePath(pMonitorInfo, pDeviceDetail->DevicePath) )
         AddUselessPortEntry(pMonitorInfo, pDeviceDetail->DevicePath);

      return;
   }

   pCur = FindPort(pMonitorInfo, szPortName, &pPrev);

   //
   // Port info is currently in our list?
   //
   if ( pCur )
   {
      //
      // Did the device path or flags change?
      //
      BOOL bActiveStateChanged = !pCur->pBasePort->
          compActiveState (
              bIsPortActive
              );
      BOOL bDevicePathChanged = pCur->pBasePort->
          compDevicePath (
              pDeviceDetail->DevicePath
              );
      if (bActiveStateChanged || bDevicePathChanged ||
          (!bIsPortActive && pCur-> pBasePort-> getPortType () == TSPORT)
          )
      {
          //
          // Even nothing has been changed, for INACTIVE TS ports
          // we need to call UpdatePortInfo to check if recyclable flag is set.
          //
          if (bDevicePathChanged)
          {
            for (
                 PDYNAMON_PORT pDuplicate = pMonitorInfo-> pPortList;
                 pDuplicate;
                 pDuplicate = pDuplicate-> pNext
                 )
            {
                if (pDuplicate == pCur || pDuplicate-> pBasePort-> isActive ())
                {
                    continue;
                }
                //
                // Search for CBasePort with the same DevicePath
                // but with a different PortName...
                //
                if (pDuplicate-> pBasePort-> compDevicePath (pDeviceDetail-> DevicePath) == 0 &&
                    pDuplicate-> pBasePort-> compPortName (szPortName) != 0
                    )
                {
                    //
                    // Clear the port's device path and description...
                    //
                    pDuplicate-> pBasePort-> setDevicePath (L"");
                    pDuplicate-> pBasePort-> setPortDesc (L"");
                }
            }//end for
            //
            // If pJunkList has the entry with the DeviceName equal to pCur,
            // this entry has to be deleted.
            //
            PUSELESS_PORT pPrevUseless = NULL;
            PUSELESS_PORT pUseless =
                FindUselessEntry (
                    pMonitorInfo,
                    pDeviceDetail-> DevicePath,
                    &pPrevUseless
                    );
            if (pUseless)
            {
                if (pPrevUseless)
                {
                    pPrevUseless-> pNext = pUseless-> pNext;
                }
                else
                {
                    pMonitorInfo-> pJunkList = pUseless-> pNext;
                }
                FreeSplMem (pUseless);
            }
         }//end if
         UpdatePortInfo (
             pCur,
             pDeviceDetail->DevicePath,
             bIsPortActive,
             &hKey,
             ppPortUpdateList
             );
      }//end if
   }
   else
   {

      AddPortToList( portType, szPortName, pDeviceDetail->DevicePath,
                     bIsPortActive, &hKey, pMonitorInfo, pPrev,
                     ppPortUpdateList);

   }

   if ( hKey != INVALID_HANDLE_VALUE )
      RegCloseKey(hKey);
}


HKEY
GetPortNameAndRegKey(
                    IN  PSETUPAPI_INFO              pSetupInfo,
                    IN  HDEVINFO                    hDevList,
                    IN  PSP_DEVICE_INTERFACE_DATA   pDeviceInterface,
                    OUT LPTSTR                      pszPortName,
                    IN  size_t                      cchPortName,
                    OUT PORTTYPE*                   pPortType
                    )
/*++

Routine Description:
    Find port name for a device interface and also return reg handle

Arguments:
    hDevList            : List of USB printer devices
    pDeviceInterface    : pointer to device interface in question
    pszPortName         : Port name on return.

Return Value:
    INVALID_HANDLE_VALUE on some errors.
    Otherwize a valid registry handle with pszPortName giving port name

--*/
{
   HKEY    hKey = INVALID_HANDLE_VALUE;
   DWORD   dwPortNumber, dwNeeded, dwLastError;
   TCHAR   szPortBaseName[MAX_PORT_LEN-3];

   hKey = pSetupInfo->OpenDeviceInterfaceRegKey(hDevList,
                                                pDeviceInterface,
                                                0,
                                                KEY_ALL_ACCESS);
   if ( hKey == INVALID_HANDLE_VALUE )
   {
      dwLastError = GetLastError();
      DBGMSG(DBG_WARNING,
             ("DynaMon: GetPortNameAndRegKey: SetupDiOpenDeviceInterfaceRegKey failed with error %d\n",
              dwLastError));
      return INVALID_HANDLE_VALUE;
   }

   dwNeeded = sizeof(dwPortNumber);
   if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortNumber, 0, NULL,
                                         (LPBYTE)&dwPortNumber, &dwNeeded) )
   {

      dwLastError = GetLastError();
      DBGMSG(DBG_WARNING,
             ("DynaMon: GetPortNameAndRegKey: RegQueryValueEx failed for port number with error %d\n", dwLastError));
      goto Fail;
   }

   dwNeeded = sizeof(szPortBaseName);
   if ( ERROR_SUCCESS != (dwLastError =  RegQueryValueEx(hKey, cszBaseName, 0, NULL,
                                                        (LPBYTE)szPortBaseName, &dwNeeded) ) )
   {
       dwLastError = GetLastError();
       DBGMSG(DBG_WARNING,
              ("GetPortNameAndRegKey: RegQueryValueEx failed for Base Name with error %d\n", dwLastError));
       goto Fail;
   }

   *pPortType = USBPORT;
   if ( _tcsncmp( szPortBaseName, cszDOT4, _tcslen(cszDOT4) ) == 0 )
      *pPortType = DOT4PORT;
   else if ( _tcsncmp( szPortBaseName, csz1394, _tcslen(csz1394) ) == 0 )
      *pPortType = P1394PORT;
   else if ( _tcsncmp( szPortBaseName, cszTS, _tcslen(cszTS) ) == 0 )
      *pPortType = TSPORT;

   (VOID)StringCchPrintf (pszPortName, cchPortName, TEXT("%s%03u"), szPortBaseName, dwPortNumber);

   return hKey;

Fail:
   RegCloseKey(hKey);
   return INVALID_HANDLE_VALUE;
}


VOID
AddUselessPortEntry(
                   IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
                   IN  LPTSTR                pszDevicePath
                   )
/*++
Routine Description:
    This adds a useless port entry to our list. So next time we see an inactive
    port that is already in our known usless port list we can skip the port
    entry

Arguments:
    pMonitorInfo        : Pointer to monitor inf
    pszDevicePath       : Device path for the useless port

Return Value:
    None. Under normal circumstances will add a useless entry to our list

--*/
{
   PUSELESS_PORT  pTemp, pPrev;

   pTemp = FindUselessEntry( pMonitorInfo, pszDevicePath, &pPrev );

   //
   // Don't add an entry that is already there
   //
   SPLASSERT(pTemp == NULL);

   if ( pTemp = (PUSELESS_PORT) AllocSplMem(sizeof(*pTemp)) )
   {
      SafeCopy(MAX_PATH, pszDevicePath, pTemp->szDevicePath);

      if ( pPrev )
      {
         pTemp->pNext  = pPrev->pNext;
         pPrev->pNext = pTemp;
      }
      else
      {
         pTemp->pNext            = pMonitorInfo->pJunkList;
         pMonitorInfo->pJunkList = pTemp;
      }
   }
}


PDYNAMON_PORT
FindPort(
        IN  PDYNAMON_MONITOR_INFO pMonitorInfo,
        IN  LPTSTR                pszPortName,
        OUT PDYNAMON_PORT*        ppPrev
        )
/*++

Routine Description:
    Finds a port by name. Ports are kept in singly linked list sorted by name.
    If found previous in the list is returned via *ppPrev.

Arguments:
    pHead       : Head pointer to port list
    pszPortName : Name of port to look
    ppPrev      : On return will have pointer to previous element

Return Value:
    If NULL port is not in list, else the found element
    Weather port is found or not *ppPrev will return the previous element

--*/
{
   INT     iCmp;
   PDYNAMON_PORT   pHead;

   ECS( pMonitorInfo->EnumPortsCS );

   pHead = pMonitorInfo->pPortList;
   for ( *ppPrev = NULL ;
       pHead && ( iCmp = pHead->pBasePort->compPortName( pszPortName) ) < 0 ;
       *ppPrev = pHead, pHead = pHead->pNext )
      ;

   //
   // If port should go in the middle but not currently there
   //
   if ( pHead && iCmp != 0 )
      pHead = NULL;

   LCS( pMonitorInfo->EnumPortsCS );

   return pHead;
}


VOID
UpdatePortInfo(
    PDYNAMON_PORT   pPort,
    LPTSTR          pszDevicePath,
    BOOL            bIsPortActive,
    HKEY*           phKey,
    PPORT_UPDATE*   ppPortUpdateList
    )
{
   DWORD   dwSize;
   CBasePort* pCurrentPort = pPort->pBasePort;

    if (bIsPortActive && !pCurrentPort-> isActive ())
    {
        //
        // This port goes active.
        // 'recyclable' flag has to be removed
        //
        DWORD dwRetVal =
            RegDeleteValue (
                *phKey,
                cszRecyclable
                );
        if (dwRetVal != ERROR_SUCCESS &&
            dwRetVal != ERROR_FILE_NOT_FOUND
            )
        {
            //
            // 'recyclable' flag removing failed.
            // This port cannot be activated
            //
            return;
        }
    }

   pCurrentPort->setDevicePath( pszDevicePath );

   TCHAR   szPortDescription[MAX_PORT_DESC_LEN];
   dwSize = sizeof(szPortDescription);
   if ( ERROR_SUCCESS == RegQueryValueEx( *phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE) szPortDescription,
                                          &dwSize) )
   {
      pCurrentPort->setPortDesc( szPortDescription );
   }

   if ( !pCurrentPort->compActiveState( bIsPortActive ) )
   {
       pCurrentPort->setActive( bIsPortActive );
       AddToPortUpdateList(ppPortUpdateList, pPort, phKey);
   }
   else
   {
       //
       // TS Ports only
       //
       if (!bIsPortActive && pCurrentPort-> getPortType () == TSPORT)
       {
           //
           // Is it already recyclable?
           //
           DWORD dwRetValue =
               RegQueryValueEx (
                   *phKey,
                   cszRecyclable,
                   0,
                   NULL,
                   NULL,
                   NULL
                   );
           if (dwRetValue == ERROR_FILE_NOT_FOUND)
           {
               //
               // The port is inactive and it is not recyclable.
               // I have to add this port in update list to check is it still needed
               // by the spooler. Only UpdateThread checks if the port name is in use.
               AddToPortUpdateList(ppPortUpdateList, pPort, phKey);
           }
           //
           // If dwRetValue is equal to ERROR_SUCCESS, then it is already recyclable.
           // If dwRetVal has some other value, some error occured but next EnumPort
           // will check this status again.
           //
       }
   }
}


BOOL
AddPortToList(
             PORTTYPE              portType,
             LPTSTR                pszPortName,
             LPTSTR                pszDevicePath,
             BOOL                  bIsPortActive,
             HKEY*                 phKey,
             PDYNAMON_MONITOR_INFO pMonitorInfo,
             PDYNAMON_PORT         pPrevPort,
             PPORT_UPDATE*         ppPortUpdateList
             )
{
   DWORD          dwSize, dwLastError;
   PDYNAMON_PORT  pPort;
   PUSELESS_PORT  pCur, pPrev;
   CBasePort*     pNewPort;

   SPLASSERT(FindPortUsingDevicePath(pMonitorInfo, pszDevicePath) == NULL);

   if (bIsPortActive)
   {
       //
       // If the port goes active, recyclable flag should be removed
       //
       DWORD dwRetVal =
           RegDeleteValue (
               *phKey,
               cszRecyclable
               );
       if (dwRetVal != ERROR_SUCCESS &&
           dwRetVal != ERROR_FILE_NOT_FOUND
           )
       {
           //
           // Recyclable flag removing failed. Don't use this port.
           //
           return FALSE;
       }
   }


   pPort = (PDYNAMON_PORT) AllocSplMem(sizeof(DYNAMON_PORT));
   if ( !pPort )
      return FALSE;

   pPort->dwSignature      = DYNAMON_SIGNATURE;

   // Now create the port based on Port Type.
   switch ( portType )
   {
      case DOT4PORT:
         pNewPort = new CDot4Port( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case TSPORT:
         pNewPort = new CTSPort( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case P1394PORT:
         pNewPort = new C1394Port( bIsPortActive, pszPortName, pszDevicePath );
         break;
      case USBPORT:
      default:
         pNewPort = new CUSBPort( bIsPortActive, pszPortName, pszDevicePath );
         break;
   }

   if ( !pNewPort )
   {
      dwLastError = GetLastError();
      FreeSplMem( pPort );
      SetLastError( dwLastError );
      return FALSE;
   }

   TCHAR   szPortDescription[MAX_PORT_DESC_LEN];
   dwSize = sizeof(szPortDescription);
   if ( ERROR_SUCCESS == RegQueryValueEx(*phKey,
                                         cszPortDescription,
                                         0,
                                         NULL,
                                         (LPBYTE) szPortDescription,
                                         &dwSize) )
   {
      pNewPort->setPortDesc( szPortDescription );
   }

   // See if the port has a max data size restriction
   DWORD dwMaxBufferSize;
   dwSize = sizeof(dwMaxBufferSize);
   if ( ERROR_SUCCESS == RegQueryValueEx(*phKey,
                                         cszMaxBufferSize,
                                         0,
                                         NULL,
                                         (LPBYTE) &dwMaxBufferSize,
                                         &dwSize) )
   {
      pNewPort->setMaxBuffer( dwMaxBufferSize );
   }

   // Assign Object Pointer to port list entry
   pPort->pBasePort = pNewPort;

   if ( pPrevPort )
   {
      pPort->pNext = pPrevPort->pNext;
      pPrevPort->pNext = pPort;
   }
   else
   {
      pPort->pNext = pMonitorInfo->pPortList;
      pMonitorInfo->pPortList = pPort;
   }

   //
   // If this is a port that is getting recycled remove from useless list
   //
   if ( pCur = FindUselessEntry( pMonitorInfo, pszDevicePath, &pPrev) )
   {

      if ( pPrev )
         pPrev->pNext = pCur->pNext;
      else
         pMonitorInfo->pJunkList = pCur->pNext;

      FreeSplMem(pCur);
   }

   //
   // On spooler startup we always have to check if the online/offline status
   // has to be changed. This is because spooler will remember the last state
   // before previous spooler shutdown which may be incorrect
   //
   AddToPortUpdateList(ppPortUpdateList, pPort, phKey);

   return TRUE;
}


VOID
AddToPortUpdateList(
                   IN OUT  PPORT_UPDATE* ppPortUpdateList,
                   IN      PDYNAMON_PORT pPort,
                   IN OUT  HKEY*         phKey
                   )
/*++

Routine Description:
    Adds a port to the list of ports that need to status updated.

Arguments:
    ppPortUpdateList    : Pointer to the head of port update list
    pPort           : Gives the port for which we need to update
                          port status
    phKey               : Pointer to reg handle. If port update element created
                          this will be passed to background thread for use and
                          closing

Return Value:
    None

    If the port update element is created then phKey is set to invalid hanlde
    since ownership is going to be passed to background thread.

    New port update element will be the first in the list

--*/
{
   PPORT_UPDATE pTemp;

   if ( pTemp = (PPORT_UPDATE) AllocSplMem( sizeof(PORT_UPDATE) ) )
   {
      SafeCopy( MAX_PORT_LEN, pPort->pBasePort->getPortName(), pTemp->szPortName );
      pTemp->bActive      = pPort->pBasePort->isActive();
      pTemp->hKey         = *phKey;
      pTemp->pNext        = *ppPortUpdateList;
      *ppPortUpdateList   = pTemp;

      *phKey              = INVALID_HANDLE_VALUE;
   }
}


VOID
PassPortUpdateListToUpdateThread(
    PPORT_UPDATE      pNewUpdateList
    )
{
   // Get access to the Update List Pointer
   ECS( gDynaMonInfo.UpdateListCS );

   // Add the new list to the current list
   if ( gDynaMonInfo.pUpdateList )
   {
      // THere is something in the list already so add it to the end
      PPORT_UPDATE pCurUpdateList = gDynaMonInfo.pUpdateList;
      while ( pCurUpdateList->pNext )
         pCurUpdateList = pCurUpdateList->pNext;

      pCurUpdateList->pNext = pNewUpdateList;
   }
   else
      gDynaMonInfo.pUpdateList = pNewUpdateList;

   // Release acces to the list pointer
   LCS( gDynaMonInfo.UpdateListCS );

   // Now let the Update Thread go...
   SetEvent( gDynaMonInfo.hUpdateEvent );

}

void
SafeCopy(
    IN     DWORD    MaxBufLen,
    IN     LPTSTR   pszInString,
    IN OUT LPTSTR   pszOutString
    )
{
    // Check if the input string is bigger than the output buffer
    (VOID) StringCchCopy (pszOutString, MaxBufLen, pszInString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file for usbmon

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include "tchar.h"
#include <strsafe.h>
#include "debug.h"
#include "splcom.h"
#include "mysetupapi.h"
#include "dynamon.h"
#include "Baseport.h"
#include "usbport.h"
#include "tsport.h"
#include "dot4port.h"
#include "1394port.h"
#include "devioctl.h"
#include "ioctl.h"
#include "protos.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\protos.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved


Module Name:
    Protos.h

Abstract:
    Prototypes for all functions

Author: M. Fenelon

Revision History:

--*/

//
//  Functions in DynaMon.cpp
//

BOOL WINAPI DynaMon_EnumPorts( LPTSTR pszName, DWORD dwLevel, LPBYTE pPorts, DWORD cbBuf,
                               LPDWORD pcbNeeded, LPDWORD pcReturned );

BOOL WINAPI DynaMon_OpenPort( LPTSTR pszPortName, LPHANDLE pHandle );

BOOL WINAPI DynaMon_ClosePort( HANDLE hPort );

BOOL WINAPI DynaMon_StartDocPort( HANDLE hPort, LPTSTR pPrinterName, DWORD dwJobId,
                                  DWORD dwLevel, LPBYTE pDocInfo );

BOOL WINAPI DynaMon_EndDocPort( HANDLE hPort );

BOOL WINAPI DynaMon_GetPrinterDataFromPort( HANDLE hPort, DWORD dwControlID, LPWSTR pValueName, LPWSTR lpInBuffer,
                                            DWORD cbInBuffer, LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );

BOOL WINAPI DynaMon_ReadPort( HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead );

BOOL WINAPI DynaMon_WritePort( HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbWritten );

BOOL WINAPI DynaMon_SetPortTimeOuts( HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved );

//
//  Functions in EnumUtil.cpp
//

DWORD SpinUpdateThread( void );

VOID UpdateThread( PDYNAMON_MONITOR_INFO pMonInfo );

BOOL GetPrinterInfo( LPPRINTER_INFO_5 *ppPrinterInfo5, LPDWORD pdwReturned );

BOOL PortNameNeededBySpooler( LPTSTR pszPortName, LPPRINTER_INFO_5 pPrinterInfo5,
                              DWORD dwPrinters, BOOL bActive );

BOOL SetOnlineStaus( LPPRINTER_INFO_5 pPrinterInfo5, BOOL bOnline );

DWORD BuildPortList( PDYNAMON_MONITOR_INFO pMonitorInfo, PPORT_UPDATE* ppPortUpdateList );

BOOL LoadSetupApiDll( PSETUPAPI_INFO  pSetupInfo );

DWORD ProcessGUID( PSETUPAPI_INFO pSetupApiInfo, PDYNAMON_MONITOR_INFO pMonitorInfo,
                   PPORT_UPDATE* ppPortUpdateList, LPGUID pGUID );

PUSELESS_PORT FindUselessEntry( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath, PUSELESS_PORT* ppPrev );

PDYNAMON_PORT FindPortUsingDevicePath( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath );

VOID ProcessPortInfo( PSETUPAPI_INFO pSetupApiInfo, PDYNAMON_MONITOR_INFO pMonitorInfo, HDEVINFO hDevList,
                      PSP_DEVICE_INTERFACE_DATA pDeviceInterface, PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceDetail,
                      BOOL bIsPortActive, PPORT_UPDATE* ppPortUpdateInfo );

HKEY GetPortNameAndRegKey( PSETUPAPI_INFO pSetupInfo, HDEVINFO hDevList, PSP_DEVICE_INTERFACE_DATA pDeviceInterface,
                           LPTSTR pszPortName, size_t cchPortName, PORTTYPE* pPortType );

VOID AddUselessPortEntry( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszDevicePath );

PDYNAMON_PORT FindPort( PDYNAMON_MONITOR_INFO pMonitorInfo, LPTSTR pszPortName, PDYNAMON_PORT* ppPrev );

VOID UpdatePortInfo( PDYNAMON_PORT pPort, LPTSTR pszDevicePath, BOOL bIsPortActive,
                     HKEY* phKey, PPORT_UPDATE* ppPortUpdateList );

BOOL
AddPortToList( PORTTYPE portType, LPTSTR pszPortName, LPTSTR pszDevicePath, BOOL bIsPortActive, HKEY* phKey,
               PDYNAMON_MONITOR_INFO pMonitorInfo, PDYNAMON_PORT pPrevPort, PPORT_UPDATE* ppPortUpdateList );

VOID AddToPortUpdateList( PPORT_UPDATE* ppPortUpdateList, PDYNAMON_PORT pPort, HKEY* phKey );

VOID PassPortUpdateListToUpdateThread( PPORT_UPDATE pNewUpdateList );

void SafeCopy(DWORD MaxBufLen, LPTSTR pszInString, LPTSTR pszOutString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\ioctl.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef IOCTL_H

#define IOCTL_H


#define USBPRINT_IOCTL_INDEX  0x0000

#ifdef NEEDED

#define IOCTL_USBPRINT_GET_PIPE_INFO     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_GET_CONFIG_DESCRIPTOR     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+1,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_SET_PIPE_PARAMETER     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+2,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+3,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+4,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_REGISTER_NOTIFY_EVENT   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+5,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+6,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+7,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RETURN_PERF_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+8,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RESET_DEVICE   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+9,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_CLOCK_MASTER_TEST   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+10,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_RESET_PIPE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+11,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)
#endif

#define IOCTL_USBPRINT_GET_LPT_STATUS  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+12,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#ifdef NEEDED

#define IOCTL_USBPRINT_GET_1284_ID     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+13,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+14,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+15,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)


#include <PSHPACK1.H>

#define BULK      0
#define INTERRUPT 1
#define CONTROL   2
#define ISO       3

typedef struct _USBPRINT_PIPE_PERF_INFO {
    ULONG               BytesPerSecond;
   ULONG             ClockCyclesPerByte;
} USBPRINT_PIPE_PERF_INFO, *PUSBPRINT_PIPE_PERF_INFO;

typedef struct _USBPRINT_PIPE_INFO {
    BOOLEAN             In;
    UCHAR               PipeType;
    UCHAR               EndpointAddress;
    UCHAR               Interval;
    ULONG               MaximumPacketSize;
    ULONG               MaximumTransferSize;
    UCHAR               Name[32];
   USBPRINT_PIPE_PERF_INFO PerfInfo;
} USBPRINT_PIPE_INFO, *PUSBPRINT_PIPE_INFO;


typedef struct _USBPRINT_INTERFACE_INFO {
    ULONG PipeCount;
    USBPRINT_PIPE_INFO Pipes[];
} USBPRINT_INTERFACE_INFO, *PUSBPRINT_INTERFACE_INFO;



#include <POPPACK.H>

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\mysetupapi.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    MySetup.h

Abstract:

    USBMON setupapi header file


--*/

#ifndef MYSETUPAPI_H

#define MYSETUPAPI_H

#include <setupapi.h>
#include <cfgmgr32.h>       // For dot4 pnp reenumeration code.


typedef
(WINAPI * pfSetupDiDestroyDeviceInfoList)(
    IN HDEVINFO DeviceInfoSet
    );

typedef
HDEVINFO
(WINAPI * pfSetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCTSTR Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

typedef
BOOL
(WINAPI * pfSetupDiEnumDeviceInfo)(
    IN  HDEVINFO          DeviceInfoSet,
    IN  DWORD             MemberIndex,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    );


typedef
BOOL
(WINAPI * pfSetupDiEnumDeviceInterfaces)(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    );

typedef
BOOL
(WINAPI * pfSetupDiGetDeviceInterfaceDetail)(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
#ifdef  UNICODE
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
#else
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
#endif
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );

typedef
HKEY
(WINAPI * pfSetupDiOpenDeviceInterfaceRegKey)(
    IN     HDEVINFO                     DeviceInfoSet,
    IN     PSP_DEVICE_INTERFACE_DATA    pDeviceInterface,
    IN     DWORD                        Reserved,
    IN     REGSAM                       samDesired
    );

typedef struct  _SETUPAPI_INFO {

    HMODULE     hSetupApi;

    pfSetupDiGetClassDevs               GetClassDevs;
    pfSetupDiDestroyDeviceInfoList      DestroyDeviceInfoList;
    pfSetupDiEnumDeviceInfo             EnumDeviceInfo;
    pfSetupDiEnumDeviceInterfaces       EnumDeviceInterfaces;
    pfSetupDiGetDeviceInterfaceDetail   GetDeviceInterfaceDetail;
    pfSetupDiOpenDeviceInterfaceRegKey  OpenDeviceInterfaceRegKey;
} SETUPAPI_INFO, *PSETUPAPI_INFO;

// For dot4 pnp reenumeration code.
typedef
CONFIGRET
(WINAPI * pfCM_Locate_DevNode_Ex)(
    OUT PDEVINST    pdnDevInst,
#ifdef UNICODE
    IN  DEVINSTID_W pDeviceID,   OPTIONAL
#else
    IN  DEVINSTID_A pDeviceID,   OPTIONAL
#endif
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

typedef
CONFIGRET
(WINAPI * pfCM_Reenumerate_DevNode_Ex)(
    IN DEVINST  dnDevInst,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\usbport.cpp ===
// USBPort.cpp: implementation of the CUSBPort class.
//
//////////////////////////////////////////////////////////////////////

#include "USBPort.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUSBPort::CUSBPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszUSBPortDesc )
{
   // Basically let the default constructor do the work.
   m_dwMaxBufferSize = 0x1000;
}

CUSBPort::~CUSBPort()
{

}

PORTTYPE CUSBPort::getPortType()
{
   return USBPORT;
}


void CUSBPort::setPortDesc( LPTSTR pszPortDesc )
{
   // Don't change the description
}


void CUSBPort::setMaxBuffer(DWORD dwMaxBufferSize)
{
   m_dwMaxBufferSize = 0x1000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\tsport.h ===
// TSPort.h: interface for the CTSPort class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_)
#define AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CTSPort : public CBasePort
{
public:
   CTSPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CTSPort();
   PORTTYPE getPortType( void );
   BOOL setPortTimeOuts( LPCOMMTIMEOUTS lpCTO );
   BOOL getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                        LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned );

protected:
};

#endif // !defined(AFX_TSPORT_H__9A4E1220_F515_4480_AF3A_42D050B3D278__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\usbport.h ===
// USBPort.h: interface for the CUSBPort class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_)
#define AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

class CUSBPort : public CBasePort
{
public:
   CUSBPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath );
   ~CUSBPort();
   PORTTYPE getPortType( void );
   void setPortDesc( LPTSTR pszPortDesc );
   void setMaxBuffer(DWORD dwMaxBufferSize);

protected:

};

#endif // !defined(AFX_USBPORT_H__07A29C2C_7517_4A19_936D_CADB7735C567__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\tsport.cpp ===
// TSPort.cpp: implementation of the CTSPort class.
//
//////////////////////////////////////////////////////////////////////

#include "TSPort.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTSPort::CTSPort( BOOL bActive, LPTSTR pszPortName, LPTSTR pszDevicePath )
   : CBasePort( bActive, pszPortName, pszDevicePath, cszTSPortDesc )
{
   // Basically let the default constructor do the work.
}


CTSPort::~CTSPort()
{

}


PORTTYPE CTSPort::getPortType()
{
   return TSPORT;
}


BOOL CTSPort::getPrinterDataFromPort( DWORD dwControlID, LPTSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer,
                                      LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned )
{
   SetLastError( ERROR_INVALID_FUNCTION );
   return FALSE;
}


BOOL CTSPort::setPortTimeOuts( LPCOMMTIMEOUTS lpCTO )
{
   SetLastError( ERROR_INVALID_FUNCTION );
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\usbmon.old\enumports.c ===
/*++

Copyright (c) 1999  Microsoft Corporation
All Rights Reserved


Module Name:
    EnumPorts.c

Abstract:
    USBMON enumports routines

Author:

Revision History:

--*/

#include "precomp.h"


TCHAR   sComma                          = TEXT(',');
TCHAR   sZero                           = TEXT('\0');
TCHAR   cszUSB[]                        = TEXT("USB");
TCHAR   cszBaseName[]                   = TEXT("Base Name");
TCHAR   cszPortNumber[]                 = TEXT("Port Number");
TCHAR   cszRecyclable[]                 = TEXT("recyclable");
TCHAR   cszPortDescription[]            = TEXT("Port Description");
TCHAR   cszUSBDescription[]             = TEXT("Virtual printer port for USB");
TCHAR   cszMonitorName[]                = TEXT("USB Print Monitor");


DWORD                   gdwMonitorNameSize  = sizeof(cszMonitorName);
BACKGROUND_THREAD_DATA  FirstBackgroundThreadData = { NULL, NULL, NULL },
                        SecondBackgroundThreadData = { NULL, NULL, NULL };

#ifdef      MYDEBUG
#include    <stdio.h>

DWORD   dwCount[10], dwTotalTime[10];
DWORD   dwSkippedPorts, dwSkippedEnumPorts, dwPortUpdates;
#endif
//
// Default timeout values
//
#define     READ_TIMEOUT_MULTIPLIER         0
#define     READ_TIMEOUT_CONSTANT       60000
#define     WRITE_TIMEOUT_MULTIPLIER        0
#define     WRITE_TIMEOUT_CONSTANT      60000



/*++
    This section explains how we do multiple thread synchronization between
    enumport threads and background threads.

    1. Only one enumports thread can walk the port list of dynamon.
       Enumports uses EnumPortsCS critical section to ensure this.

    2. We never want to make a spooler call from the EnumPorts thread. This is
       because such a call could generate another call back to dynamon and we
       do not want a deadlock. For example OpenPrinter call to netware print
       provider will generate an EnumPorts call.

       So when we find a need to change the printer online/offline staus,
       because correponding dynamon ports are active/inactive, we will spin a
       background thread to make the spooler calls to do that.

    3. We want to make sure background thread does not block EnumPorts. The
       reason is each EnumPorts call could spin a background thread, and
       each backgound thread call a number of OpenPrinter calls, and each
       OpenPrinter call generate an EnumPorts call.

       So we pass a separate port update list to the background thread. And
       we make sure EnumPorts thread does not wait for the background thread
       to complete to return to spooler.

    4. We want to control the number and execution order of background threads.

       We will make sure at a time there can be only 2 background threads. One
       actually processing port update lists, and another just pending
       execution -- scheduled, but waiting for the active background thread
       to complete execution before processing it's port update list.

--*/


PUSELESS_PORT_INFO
FindUselessEntry(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath,
    OUT PUSELESS_PORT_INFO     *ppPrev
    )
/*++
Routine Description:
    Searches for a device path in the useless port list

Arguments:

Return Value:
    NULL if no entry found in the list
    Else a valid USELESS_PORT_INFO pointer
    Weather port is found or not *ppPrev will return the previous element

--*/
{
    INT                 iCmp;
    PUSELESS_PORT_INFO  pHead;

    for ( pHead = pMonitorInfo->pJunkList, *ppPrev = NULL ;
          pHead && (iCmp = lstrcmp(pszDevicePath, pHead->szDevicePath)) < 0 ;
          *ppPrev = pHead, pHead = pHead->pNext )
    ;

    //
    // If useless port should go in the middle but not currently there
    //
    if ( pHead && iCmp != 0 )
        pHead = NULL;

    return pHead;
}


VOID
AddUselessPortEntry(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath
    )
/*++
Routine Description:
    This adds a useless port entry to our list. So next time we see an inactive
    port that is already in our known usless port list we can skip the port
    entry

Arguments:
    pMonitorInfo        : Pointer to monitor inf
    pszDevicePath       : Device path for the useless port

Return Value:
    None. Under normal circumstances will add a useless entry to our list

--*/
{
    PUSELESS_PORT_INFO  pTemp, pPrev;

    pTemp = FindUselessEntry(pMonitorInfo, pszDevicePath, &pPrev);

    //
    // Don't add an entry that is already there
    //
    SPLASSERT(pTemp == NULL);

    if ( pTemp = (PUSELESS_PORT_INFO) AllocSplMem(sizeof(*pTemp)) ) {

        lstrcpy(pTemp->szDevicePath, pszDevicePath);
        ++pMonitorInfo->dwUselessPortCount;

        if ( pPrev ) {

            pTemp->pNext  = pPrev->pNext;
            pPrev->pNext = pTemp;
        } else {

            pTemp->pNext            = pMonitorInfo->pJunkList;
            pMonitorInfo->pJunkList = pTemp;
        }
    }
}


VOID
AddToPortUpdateList(
    IN OUT  PPORT_UPDATE_INFO  *ppPortUpdateInfo,
    IN      PUSBMON_PORT_INFO   pPortInfo,
    IN OUT  HKEY               *phKey
    )
/*++

Routine Description:
    Adds a port to the list of ports that need to status updated.

Arguments:
    ppPortUpdateInfo    : Pointer to the head of port update list
    pPortInfo           : Gives the port for which we need to update
                          port status
    phKey               : Pointer to reg handle. If port update element created
                          this will be passed to background thread for use and
                          closing

Return Value:
    None

    If the port update element is created then phKey is set to invalid hanlde
    since ownership is going to be passed to background thread.

    New port update element will be the first in the list

--*/
{
    PPORT_UPDATE_INFO pTemp;

    if ( pTemp = (PPORT_UPDATE_INFO) AllocSplMem(sizeof(*pTemp)) ) {

        lstrcpy(pTemp->szPortName, pPortInfo->szPortName);
        pTemp->bActive      = (pPortInfo->dwDeviceFlags & SPINT_ACTIVE) != 0;
        pTemp->hKey         = *phKey;
        pTemp->pNext        = *ppPortUpdateInfo;
        *ppPortUpdateInfo   = pTemp;

        *phKey              = INVALID_HANDLE_VALUE;
    }
}


PUSBMON_PORT_INFO
FindPortUsingDevicePath(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszDevicePath
    )
/*++

Routine Description:
    Finds a port by device path.

Arguments:
    pMonitorInfo    : Pointer to MONITOR_INFO structure
    pszDevicePath   : Device path name to search for

Return Value:
    If NULL port is not in list, else pointer to the PORT_INFO entry for the
    given device path

--*/
{
    INT     iCmp;
    PUSBMON_PORT_INFO   pHead;

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);

    //
    // Port list is sorted on port name, so we have to scan the whole list
    //
    for ( pHead = pMonitorInfo->pPortInfo ; pHead ; pHead = pHead->pNext )
        if ( lstrcmp(pszDevicePath, pHead->szDevicePath) == 0 )
            break;

    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);

    return pHead;
}


PUSBMON_PORT_INFO
FindPort(
    IN  PUSBMON_MONITOR_INFO    pMonitorInfo,
    IN  LPTSTR                  pszPortName,
    OUT PUSBMON_PORT_INFO      *ppPrev
    )
/*++

Routine Description:
    Finds a port by name. Ports are kept in singly linked list sorted by name.
    If found previous in the list is returned via *ppPrev.

Arguments:
    pHead       : Head pointer to port list
    pszPortName : Name of port to look
    ppPrev      : On return will have pointer to previous element

Return Value:
    If NULL port is not in list, else the found element
    Weather port is found or not *ppPrev will return the previous element

--*/
{
    INT     iCmp;
    PUSBMON_PORT_INFO   pHead;

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);

    pHead = pMonitorInfo->pPortInfo;
    for ( *ppPrev = NULL ;
          pHead && (iCmp = lstrcmp(pszPortName, pHead->szPortName)) < 0 ;
          *ppPrev = pHead, pHead = pHead->pNext )
    ;

    //
    // If port should go in the middle but not currently there
    //
    if ( pHead && iCmp != 0 )
        pHead = NULL;

    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);

    return pHead;
}


BOOL
AddPortToList(
    LPTSTR                  pszPortName,
    LPTSTR                  pszDevicePath,
    DWORD                   dwDeviceFlags,
    HKEY                   *phKey,
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PUSBMON_PORT_INFO       pPrevPortInfo,
    PPORT_UPDATE_INFO      *ppPortUpdateInfo
    )
{
    DWORD               dwSize;
    PUSBMON_PORT_INFO   pPortInfo;
    PUSELESS_PORT_INFO  pCur, pPrev;

    SPLASSERT(FindPortUsingDevicePath(pMonitorInfo, pszDevicePath) == NULL);

    pPortInfo = (PUSBMON_PORT_INFO) AllocSplMem(sizeof(USBMON_PORT_INFO));
    if ( !pPortInfo )
        return FALSE;

    pPortInfo->dwSignature      = USB_SIGNATURE;
    pPortInfo->hDeviceHandle    = INVALID_HANDLE_VALUE;
    pPortInfo->dwDeviceFlags    = dwDeviceFlags;

    pPortInfo->ReadTimeoutMultiplier    = READ_TIMEOUT_MULTIPLIER;
    pPortInfo->ReadTimeoutMultiplier    = READ_TIMEOUT_MULTIPLIER;
    pPortInfo->WriteTimeoutConstant     = WRITE_TIMEOUT_CONSTANT;
    pPortInfo->WriteTimeoutConstant     = WRITE_TIMEOUT_CONSTANT;

    lstrcpy(pPortInfo->szPortName, pszPortName);
    lstrcpy(pPortInfo->szDevicePath, pszDevicePath);

    dwSize = sizeof(pPortInfo->szPortDescription);
    if ( ERROR_SUCCESS != RegQueryValueEx(*phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE)(pPortInfo->szPortDescription),
                                          &dwSize) ) {

        lstrcpy(pPortInfo->szPortDescription, cszUSBDescription);
    }

    if ( pPrevPortInfo ) {

        pPortInfo->pNext = pPrevPortInfo->pNext;
        pPrevPortInfo->pNext = pPortInfo;
    } else {

        pPortInfo->pNext = pMonitorInfo->pPortInfo;
        pMonitorInfo->pPortInfo = pPortInfo;
    }

    //
    // If this is a port that is getting recycled remove from useless list
    //
    if ( pCur = FindUselessEntry(pMonitorInfo, pszDevicePath, &pPrev) ) {
    
        if ( pPrev )
            pPrev->pNext = pCur->pNext;
        else
            pMonitorInfo->pJunkList = pCur->pNext;
    
        --pMonitorInfo->dwUselessPortCount;
        FreeSplMem(pCur);
    }
    
    //
    // On spooler startup we always have to check if the online/offline status
    // has to be changed. This is because spooler will remember the last state
    // before previous spooler shutdown which may be incorrect
    //
    AddToPortUpdateList(ppPortUpdateInfo, pPortInfo, phKey);

    ++pMonitorInfo->dwPortCount;
    
    return TRUE;
}
    
    
HKEY
GetPortNameAndRegKey(
    IN  PSETUPAPI_INFO              pSetupInfo,
    IN  HDEVINFO                    hDevList,
    IN  PSP_DEVICE_INTERFACE_DATA   pDeviceInterface,
    OUT LPTSTR                      pszPortName
    )
/*++
    
Routine Description:
    Find port name for a device interface and also return reg handle
    
Arguments:
    hDevList            : List of USB printer devices
    pDeviceInterface    : pointer to device interface in question
    pszPortName         : Port name on return.
        
Return Value:
    INVALID_HANDLE_VALUE on some errors.
    Otherwize a valid registry handle with pszPortName giving port name
    
--*/
{
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   dwPortNumber, dwNeeded, dwLastError;
    TCHAR   szPortBaseName[MAX_PORT_LEN-3];
    
#ifdef      MYDEBUG
    DWORD   dwTime;
    
    dwTime = GetTickCount();
#endif
    
    hKey = pSetupInfo->OpenDeviceInterfaceRegKey(hDevList,
                                                pDeviceInterface,
                                                0,
                                                KEY_ALL_ACCESS);
#ifdef      MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[0];
    dwTotalTime[0] += dwTime;
#endif
    
    if ( hKey == INVALID_HANDLE_VALUE ) {
    
        dwLastError = GetLastError();
        DBGMSG(DBG_ERROR,
               ("usbmon: WalkPortList: SetupDiOpenDeviceInterfaceRegKey failed with error %d\n",
               dwLastError));
        return INVALID_HANDLE_VALUE;
    }
    
    dwNeeded = sizeof(dwPortNumber);
    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszPortNumber, 0, NULL,
                                          (LPBYTE)&dwPortNumber, &dwNeeded) ) {

        DBGMSG(DBG_WARNING,
               ("usbmon: GetPortNameAndRegKey: RegQueryValueEx failed for port number\n"));
        goto Fail;
    }

    dwNeeded = sizeof(szPortBaseName);
    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, cszBaseName, 0, NULL,
                                          (LPBYTE)szPortBaseName, &dwNeeded) ) {
        lstrcpy(szPortBaseName, cszUSB);
    }

    wsprintf(pszPortName, TEXT("%s%03u"), szPortBaseName, dwPortNumber);

    return hKey;
    
Fail:
    RegCloseKey(hKey);
    return INVALID_HANDLE_VALUE;
}


BOOL
SetOnlineStaus(
    LPPRINTER_INFO_5    pPrinterInfo5,
    BOOL                bOnline
    )
{
    BOOL                bRet = FALSE;
    HANDLE              hPrinter;
    PRINTER_DEFAULTS    PrinterDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

#ifdef      MYDEBUG
    DWORD               dwTime;
#endif

    //
    // Force all DOT4 ports to remain online at all times.
    //
    if( lstrncmpi( pPrinterInfo5->pPortName, TEXT("DOT4"), lstrlen(TEXT("DOT4")) ) == 0 )
        bOnline = TRUE;

    //
    // Check if spooler already has the correct status
    //  (can happen on spooler startup)
    //
    if ( bOnline ) {

        if ( !(pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE) )
            return TRUE;
    } else
        if ( pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
            return TRUE;

#ifdef      MYDEBUG
    dwTime = GetTickCount();
#endif

    if ( !OpenPrinter(pPrinterInfo5->pPrinterName, &hPrinter, &PrinterDefault) )
        return FALSE;

    if ( bOnline )
        pPrinterInfo5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
    else
        pPrinterInfo5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

    bRet = SetPrinter(hPrinter, 5, (LPBYTE)pPrinterInfo5, 0);

    ClosePrinter(hPrinter);

#ifdef      MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[7];
    dwTotalTime[7] += dwTime;
#endif

    return bRet;
}


BOOL
PortNameNeededBySpooler(
    IN  LPTSTR              pszPortName,
    IN  LPPRINTER_INFO_5    pPrinterInfo5,
    IN  DWORD               dwPrinters,
    IN  BOOL                bActive
    )
/*++

Routine Description:
    Tells if a port is needed by spooler. Any port to which spooler currently
    has a printer going is needed.

Arguments:
    pszPortName         : Port name in question
    pPrinterInfo5       : List of PrinterInfo5s
    dwPrinters          : Count of the list of printers

Return Value:
    TRUE if spooler currently has a printer which is using the port
    FALSE otherwise

--*/
{
    BOOL    bPortUsedByAPrinter = FALSE, bPrinterUsesOnlyThisPort;
    DWORD   dwIndex;
    LPTSTR  pszStr1, pszStr2;

    for ( dwIndex = 0 ; dwIndex < dwPrinters ; ++dwIndex, ++pPrinterInfo5 ) {

        bPrinterUsesOnlyThisPort = FALSE;
        //
        // Port names are returned comma separated by spooler,
        // and there are blanks
        //
        pszStr1 = pPrinterInfo5->pPortName;

        if ( lstrcmpi(pszPortName, pszStr1) == 0 )
            bPortUsedByAPrinter = bPrinterUsesOnlyThisPort = TRUE;
        else {

            //
            // Look at each port in the list of ports printer uses
            //
            while ( pszStr2 = lstrchr(pszStr1, sComma) ) {

                *pszStr2 = sZero;
                if( lstrcmpi(pszPortName, pszStr1) == 0 )
                    bPortUsedByAPrinter = TRUE;
                *pszStr2 = sComma;  // Put the comma back

                if ( bPortUsedByAPrinter )
                    break;

                pszStr1 = pszStr2 + 1;

                //
                // Skip spaces
                //
                while ( *pszStr1 == TEXT(' ') )
                    ++pszStr1;
            }

            if ( !bPortUsedByAPrinter )
                bPortUsedByAPrinter = lstrcmpi(pszPortName, pszStr1) == 0;
        }

        //
        // We will change only status of printer for non-pooled printers only
        //
        if ( bPrinterUsesOnlyThisPort )
            SetOnlineStaus(pPrinterInfo5, bActive);
    }

    return bPortUsedByAPrinter;
}


VOID
UpdatePortInfo(
    PUSBMON_PORT_INFO   pPortInfo,
    LPTSTR              pszDevicePath,
    DWORD               dwDeviceFlags,
    HKEY               *phKey,
    PPORT_UPDATE_INFO  *ppPortUpdateInfo
    )
{
    DWORD   dwSize;

    lstrcpy(pPortInfo->szDevicePath, pszDevicePath);

    dwSize = sizeof(pPortInfo->szPortDescription);
    if ( ERROR_SUCCESS != RegQueryValueEx(*phKey,
                                          cszPortDescription,
                                          0,
                                          NULL,
                                          (LPBYTE)(pPortInfo->szPortDescription),
                                          &dwSize) ) {

        lstrcpy(pPortInfo->szPortDescription, cszUSBDescription);
    }

    if ( pPortInfo->dwDeviceFlags != dwDeviceFlags ) {

        pPortInfo->dwDeviceFlags = dwDeviceFlags;
        AddToPortUpdateList(ppPortUpdateInfo, pPortInfo, phKey);
    }

}


BOOL
PrinterInfo5s(
    OUT LPPRINTER_INFO_5   *ppPrinterInfo5,
    OUT LPDWORD             pdwReturned
    )
/*++

Routine Description:
    Does an EnumPrinter and returns a list of PRINTER_INFO_5s of all local
    printers. Caller should free the pointer.

Arguments:
    ppPrinterInfo5  : Points to PRINTER_INFO_5s on return
    pdwReturned     : Tells how many PRINTER_INFO_5s are returned

Return Value:
    TRUE on success, FALSE else

--*/
{
    BOOL            bRet = FALSE;
    static  DWORD   dwNeeded = 0;
    LPBYTE          pBuf = NULL;

#ifdef      MYDEBUG
    DWORD           dwTime;

    dwTime = GetTickCount();
#endif

    *pdwReturned = 0;

    if ( !(pBuf = AllocSplMem(dwNeeded)) )
        goto Cleanup;

    if ( !EnumPrinters(PRINTER_ENUM_LOCAL,
                       NULL,
                       5,
                       pBuf,
                       dwNeeded,
                       &dwNeeded,
                       pdwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            goto Cleanup;

        FreeSplMem(pBuf);
        if ( !(pBuf = AllocSplMem(dwNeeded))   ||
             !EnumPrinters(PRINTER_ENUM_LOCAL,
                           NULL,
                           5,
                           pBuf,
                           dwNeeded,
                           &dwNeeded,
                           pdwReturned) ) {

            goto Cleanup;
        }
   }

   bRet = TRUE;

Cleanup:

    if ( bRet && *pdwReturned ) {

        *ppPrinterInfo5 = (LPPRINTER_INFO_5)pBuf;
    } else {

        FreeSplMem(pBuf);

        *ppPrinterInfo5 = NULL;
        *pdwReturned = 0;
   }

#ifdef      MYDEBUG
   dwTime = GetTickCount() - dwTime;
   ++dwCount[6];
   dwTotalTime[6] += dwTime;
#endif

   return bRet;
}


VOID
BackgroundThread(
    HANDLE    hEvent
    )
/*++
    This is the body of background thread which does the following:
        1. Update printer online/offline with spooler for printers using
           dynamon ports
        2. Mark those ports that are inactive and not needed by spooler
           as recyclable
        3. When exiting if there is a second background thread scheduled
           then trigger it to go
--*/
{
    HANDLE              hEventToSet = NULL;
    DWORD               dwPrinters;
    PPORT_UPDATE_INFO   pPortUpdateList, pCur;
    LPCRITICAL_SECTION  pBackThreadCS;
    LPPRINTER_INFO_5    pPrinterInfo5List = NULL;

#ifdef  MYDEBUG
    DWORD               dwTime;
    CHAR                szBuf[200];

    dwTime = GetTickCount();
#endif

    //
    // Background waits here to be triggered to do it's work
    //
    WaitForSingleObject(hEvent, INFINITE);

    //
    // This is the first/active background thread at this point
    //
    SPLASSERT(hEvent == FirstBackgroundThreadData.hWaitToStart);

    //
    // Until we are here (i.e. the thread is triggered to tell this is the
    // active/first background thread) we can't access any of these things
    //

    pPortUpdateList = FirstBackgroundThreadData.pPortUpdateList;
    pBackThreadCS   = &FirstBackgroundThreadData.pMonitorInfo->BackThreadCS;

    if ( PrinterInfo5s(&pPrinterInfo5List, &dwPrinters) ) {

        for ( pCur = pPortUpdateList ; pCur ; pCur = pCur->pNext ) {

            if ( !PortNameNeededBySpooler(pCur->szPortName,
                                          pPrinterInfo5List,
                                          dwPrinters,
                                          pCur->bActive)     &&
                 !pCur->bActive ) {

                RegSetValueEx(pCur->hKey, cszRecyclable, 0, REG_NONE, 0, 0);
            }

        }
    }

    //
    // Now the thread has done what it was spun off to do.
    //

    EnterCriticalSection(pBackThreadCS);

    //
    // Remove this thread from being the first/active background thread
    //
    FirstBackgroundThreadData.hWaitToStart      = NULL;
    FirstBackgroundThreadData.pPortUpdateList   = NULL;
    FirstBackgroundThreadData.pMonitorInfo      = NULL;
    CloseHandle(hEvent);

    //
    // If there is a second thread it becomes the first now
    //
    if ( SecondBackgroundThreadData.hWaitToStart ) {

        hEventToSet
                = FirstBackgroundThreadData.hWaitToStart
                = SecondBackgroundThreadData.hWaitToStart;
        FirstBackgroundThreadData.pPortUpdateList
                = SecondBackgroundThreadData.pPortUpdateList;
        FirstBackgroundThreadData.pMonitorInfo
                = SecondBackgroundThreadData.pMonitorInfo;

        SecondBackgroundThreadData.hWaitToStart     = NULL;
        SecondBackgroundThreadData.pPortUpdateList  = NULL;
        SecondBackgroundThreadData.pMonitorInfo     = NULL;
    }
    LeaveCriticalSection(pBackThreadCS);

    //
    // If there is a second thread trigger it
    //
    if ( hEventToSet )
        SetEvent(hEventToSet);

    FreeSplMem(pPrinterInfo5List);

    //
    // Free the port update list
    //
    while ( pCur = pPortUpdateList ) {

        pPortUpdateList = pPortUpdateList->pNext;
        RegCloseKey(pCur->hKey);
        FreeSplMem(pCur);
    }

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[4];
    dwTotalTime[4] += dwTime;
    sprintf(szBuf, "BackgroundThread:                   %d\n",
            dwTotalTime[4]/dwCount[4]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "PrinterInfo5s:                      %d\n",
            dwTotalTime[6]/dwCount[6]);
    OutputDebugStringA(szBuf);

    if ( dwCount[7] ) {

        sprintf(szBuf, "SetOnlineStatus:                    %d\n",
                dwTotalTime[7]/dwCount[7]);
        OutputDebugStringA(szBuf);
    }
#endif
}


HANDLE
CreateBackgroundThreadAndReturnEventToTrigger(
    VOID
    )
/*++
    Creates a background thread and passes it an event on which to wait for
    starting execution. Returns the event handle.
--*/
{
    HANDLE  hThread = NULL, hEvent;
    DWORD   dwThreadId;

    if ( hEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) {

        if (  hThread = CreateThread(NULL,
                                     0,
                                     (LPTHREAD_START_ROUTINE)BackgroundThread,
                                     hEvent,
                                     0,
                                     &dwThreadId) ) {

            CloseHandle(hThread);
        } else {

            CloseHandle(hEvent);
            hEvent = NULL;
        }
    }

    return hEvent;
}


VOID
PassPortUpdateListToBackgroundThread(
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PPORT_UPDATE_INFO       pPortUpdateList
    )
/*++
    Called from EnumPorts thread with a list of port update elements to be
    passed to the background thread.
    a. If there is no background thread then spin one and trigger it
    b. If there is only one background thread then spin the second one. First
       one will trigger the second one on completion
    c. If there are two background threads, one active and one waiting to be
       triggered, then add the port update elements to the second one's list
--*/
{
    DWORD               dwThreadCount = 0;
    PPORT_UPDATE_INFO   pCur, pNext, pLast;

    if ( pPortUpdateList == NULL )
        return;

    EnterCriticalSection(&pMonitorInfo->BackThreadCS);

    if ( FirstBackgroundThreadData.hWaitToStart ) {

        ++dwThreadCount;
        if ( SecondBackgroundThreadData.hWaitToStart )
            ++dwThreadCount;
    }

    switch (dwThreadCount) {

        case 0:
            if ( FirstBackgroundThreadData.hWaitToStart
                        = CreateBackgroundThreadAndReturnEventToTrigger() ) {

                FirstBackgroundThreadData.pMonitorInfo      = pMonitorInfo;
                FirstBackgroundThreadData.pPortUpdateList   = pPortUpdateList;
                SetEvent(FirstBackgroundThreadData.hWaitToStart);
            }
            break;
        case 1:
            if ( SecondBackgroundThreadData.hWaitToStart
                        = CreateBackgroundThreadAndReturnEventToTrigger() ) {

                SecondBackgroundThreadData.pMonitorInfo      = pMonitorInfo;
                SecondBackgroundThreadData.pPortUpdateList   = pPortUpdateList;
            }
            break;

        case 2:
            //
            // Note: We know both lists can't be empty
            //
            for ( pCur = pPortUpdateList; pCur ; pCur = pNext ) {

                pNext = pCur->pNext;

                for ( pLast = SecondBackgroundThreadData.pPortUpdateList ;
                      pLast ; pLast = pLast->pNext ) {

                    //
                    // If there is a duplicate update old entry with info
                    // from new one and free the new entry
                    //
                    if ( !lstrcmpi(pLast->szPortName, pCur->szPortName) ) {

                        RegCloseKey(pLast->hKey);
                        pLast->hKey     = pCur->hKey;
                        pLast->bActive  = pCur->bActive;
                        FreeSplMem(pCur);
                        break; // out of inner for loop
                    } else if ( pLast->pNext == NULL ) {

                        //
                        // If we hit end of list then append entry
                        //
                        pLast->pNext = pCur;
                        pCur->pNext  = NULL;
                        break; // out of inner for loop
                    }
                }
            }
            break;

        default:
            //
            // Should not happen
            //
            SPLASSERT(dwThreadCount == 0);
    }

    LeaveCriticalSection(&pMonitorInfo->BackThreadCS);
}


VOID
ProcessPortInfo(
    IN      PSETUPAPI_INFO                      pSetupApiInfo,
    IN      PUSBMON_MONITOR_INFO                pMonitorInfo,
    IN      HDEVINFO                            hDevList,
    IN      PSP_DEVICE_INTERFACE_DATA           pDeviceInterface,
    IN      PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail,
    IN OUT  PPORT_UPDATE_INFO                  *ppPortUpdateInfo
    )
{
    HKEY                hKey = INVALID_HANDLE_VALUE;
    TCHAR               szPortName[MAX_PORT_LEN];
    PUSBMON_PORT_INFO   pCur, pPrev;

#ifdef  MYDEBUG
    ++dwPortUpdates;
#endif

    hKey = GetPortNameAndRegKey(pSetupApiInfo, hDevList,
                                pDeviceInterface, szPortName);

    if ( hKey == INVALID_HANDLE_VALUE ) {

        //
        // If this port is inactive and is not in our known port list
        // add to useless list. Earlier we would have been opening the registry
        // every time and find that port number is missing because of KM drivers
        // not deleting the inactive device interfaces
        //
        if ( !(pDeviceInterface->Flags & SPINT_ACTIVE)    &&
             !FindPortUsingDevicePath(pMonitorInfo, pDeviceDetail->DevicePath) )
            AddUselessPortEntry(pMonitorInfo, pDeviceDetail->DevicePath);

        return;
    }

    pCur = FindPort(pMonitorInfo, szPortName, &pPrev);

    //
    // Port info is currently in our list?
    //
    if ( pCur ) {

        //
        // Did the device path or flags change?
        //
        if ( pCur->dwDeviceFlags != pDeviceInterface->Flags     ||
             lstrcmp(pDeviceDetail->DevicePath, pCur->szDevicePath) ) {

            UpdatePortInfo(pCur, pDeviceDetail->DevicePath,
                           pDeviceInterface->Flags, &hKey, ppPortUpdateInfo);
        }
    } else {

        AddPortToList(szPortName, pDeviceDetail->DevicePath,
                      pDeviceInterface->Flags, &hKey, pMonitorInfo, pPrev,
                      ppPortUpdateInfo);

    }

    if ( hKey != INVALID_HANDLE_VALUE )
        RegCloseKey(hKey);
}


DWORD
WalkPortList(
    PSETUPAPI_INFO          pSetupApiInfo,
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    PPORT_UPDATE_INFO      *ppPortUpdateInfo
    )
{
    DWORD                               dwIndex, dwLastError, dwSize, dwNeeded;
    HANDLE                              hToken;
    HDEVINFO                            hDevList = INVALID_HANDLE_VALUE;
    PUSBMON_PORT_INFO                   pPtr;
    PUSELESS_PORT_INFO                  pCur, pPrev;
    SP_DEVICE_INTERFACE_DATA            DeviceInterface;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceDetail = NULL;

#ifdef  MYDEBUG
    DWORD                               dwTime;
#endif

    EnterCriticalSection(&pMonitorInfo->EnumPortsCS);
    
    hToken = RevertToPrinterSelf();

    hDevList = pSetupApiInfo->GetClassDevs((GUID *)&USB_PRINTER_GUID,
                                           NULL,
                                           NULL,
                                           DIGCF_INTERFACEDEVICE);

    if ( hDevList == INVALID_HANDLE_VALUE ) {

        dwLastError = GetLastError();
        goto Done;
    }

    dwSize = sizeof(PSP_DEVICE_INTERFACE_DETAIL_DATA)
                        + MAX_DEVICE_PATH * sizeof(TCHAR);

    pDeviceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA) AllocSplMem(dwSize);

    if ( !pDeviceDetail ) {

        dwLastError = GetLastError();
        goto Done;
    }

    dwLastError = ERROR_SUCCESS;
    dwIndex = 0;
    pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
    DeviceInterface.cbSize  = sizeof(DeviceInterface);
    do {

#ifdef  MYDEBUG
        dwTime = GetTickCount();
#endif
        if ( !pSetupApiInfo->EnumDeviceInterfaces(hDevList,
                                                  NULL,
                                                  (GUID *)&USB_PRINTER_GUID,
                                                  dwIndex,
                                                  &DeviceInterface) ) {

            dwLastError = GetLastError();
            if ( dwLastError == ERROR_NO_MORE_ITEMS )
                break;      // Normal exit

            DBGMSG(DBG_WARNING,
                   ("usbmon: WalkPortList: SetupDiEnumDeviceInterfaces failed with %d for inderx %d\n",
                   dwLastError, dwIndex));
            goto Next;
        }

#ifdef  MYDEBUG
        dwTime = GetTickCount() - dwTime;
        ++dwCount[1];
        dwTotalTime[1] += dwTime;

        dwTime = GetTickCount();
#endif

        if ( !pSetupApiInfo->GetDeviceInterfaceDetail(hDevList,
                                                      &DeviceInterface,
                                                      pDeviceDetail,
                                                      dwSize,
                                                      &dwNeeded,
                                                      NULL) ) {

            dwLastError = GetLastError();
            DBGMSG(DBG_ERROR,
                   ("usbmon: WalkPortList: SetupDiGetDeviceInterfaceDetail failed with error %d size %d\n",
                   dwLastError, dwNeeded));
            goto Next;
        }

#ifdef  MYDEBUG
        dwTime = GetTickCount() - dwTime;
        ++dwCount[2];
        dwTotalTime[2] += dwTime;
#endif

        //
        // This is the only flag we care about
        //
        DeviceInterface.Flags &= SPINT_ACTIVE;

        //
        // For inactive port if it is already known as a useless port
        // no need to process further
        //
        if ( !(DeviceInterface.Flags & SPINT_ACTIVE)    &&
              FindUselessEntry(pMonitorInfo, pDeviceDetail->DevicePath, &pPrev) ) {

#ifdef  MYDEBUG
            ++dwSkippedPorts;
#endif
            goto Next;
        }

        //
        // When port active status did not change we should have nothing
        // to update. By skipping the PortUpdateInfo we avoid registry access
        // and it is a performance improvement
        //
        if ( (pPtr = FindPortUsingDevicePath(pMonitorInfo,
                                             pDeviceDetail->DevicePath))    &&
             DeviceInterface.Flags == pPtr->dwDeviceFlags ) {
    
#ifdef  MYDEBUG
            ++dwSkippedPorts;
#endif
            goto Next;
        }
    
        ProcessPortInfo(pSetupApiInfo, pMonitorInfo, hDevList, &DeviceInterface,
                        pDeviceDetail, ppPortUpdateInfo);

Next:
        dwLastError = ERROR_SUCCESS;
        ++dwIndex;
        pDeviceDetail->cbSize   = sizeof(*pDeviceDetail);
        DeviceInterface.cbSize  = sizeof(DeviceInterface);
    } while ( dwLastError == ERROR_SUCCESS);

    if ( dwLastError == ERROR_NO_MORE_ITEMS )
        dwLastError = ERROR_SUCCESS;

Done:
    LeaveCriticalSection(&pMonitorInfo->EnumPortsCS);
    if ( hDevList != INVALID_HANDLE_VALUE )
        pSetupApiInfo->DestroyDeviceInfoList(hDevList);

    ImpersonatePrinterClient(hToken);
    FreeSplMem(pDeviceDetail);

    return dwLastError;
}


LPBYTE
CopyPortToBuf(
    PUSBMON_PORT_INFO   pPortInfo,
    DWORD               dwLevel,
    LPBYTE              pPorts,
    LPBYTE              pEnd
    )
{
    DWORD   dwLen;
    LPTSTR  pszStr;
    LPPORT_INFO_1   pPortInfo1 = (LPPORT_INFO_1) pPorts;
    LPPORT_INFO_2   pPortInfo2 = (LPPORT_INFO_2) pPorts;

    switch (dwLevel) {

        case 2:
            dwLen   = gdwMonitorNameSize;
            pEnd   -= dwLen;
            pPortInfo2->pMonitorName = (LPTSTR)pEnd;
            lstrcpy(pPortInfo2->pMonitorName, cszMonitorName);

            dwLen   = lstrlen(pPortInfo->szPortDescription) + 1;
            dwLen  *= sizeof(TCHAR);
            pEnd   -= dwLen;
            pPortInfo2->pDescription = (LPTSTR)pEnd;
            lstrcpy(pPortInfo2->pDescription, pPortInfo->szPortDescription);

            //
            // Fall through
            //

        case 1:
            dwLen   = lstrlen(pPortInfo->szPortName) + 1;
            dwLen  *= sizeof(TCHAR);
            pEnd   -= dwLen;
            pPortInfo1->pName = (LPTSTR)pEnd;
            lstrcpy(pPortInfo1->pName, pPortInfo->szPortName);
    }

    return pEnd;
}


BOOL
LoadSetupApiDll(
    PSETUPAPI_INFO  pSetupInfo
    )
{
    UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

#ifdef  MYDEBUG
    DWORD   dwTime;

    dwTime = GetTickCount();
#endif

    pSetupInfo->hSetupApi = LoadLibrary(TEXT("setupapi"));
    SetErrorMode(uOldErrMode);


    if ( !pSetupInfo->hSetupApi )
        return FALSE;

    (FARPROC) pSetupInfo->DestroyDeviceInfoList
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiDestroyDeviceInfoList");

    (FARPROC) pSetupInfo->GetClassDevs
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetClassDevsW");

    (FARPROC) pSetupInfo->EnumDeviceInterfaces
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiEnumDeviceInterfaces");

    (FARPROC) pSetupInfo->GetDeviceInterfaceDetail
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetDeviceInterfaceDetailW");

    (FARPROC) pSetupInfo->OpenDeviceInterfaceRegKey
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiOpenDeviceInterfaceRegKey");

    if ( !pSetupInfo->DestroyDeviceInfoList         ||
         !pSetupInfo->GetClassDevs                  ||
         !pSetupInfo->EnumDeviceInterfaces          ||
         !pSetupInfo->GetDeviceInterfaceDetail      ||
         !pSetupInfo->OpenDeviceInterfaceRegKey ) {

        SPLASSERT(FALSE);
        FreeLibrary(pSetupInfo->hSetupApi);
        pSetupInfo->hSetupApi = NULL;
        return FALSE;
    }

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++dwCount[5];
    dwTotalTime[5] += dwTime;
#endif

    return TRUE;
}


BOOL
WINAPI
USBMON_EnumPorts(
    LPTSTR      pszName,
    DWORD       dwLevel,
    LPBYTE      pPorts,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned
    )
{
    DWORD               dwLastError = ERROR_SUCCESS, dwRequestIndex;
    LPBYTE              pEnd;
    SETUPAPI_INFO       SetupApiInfo;
    PUSBMON_PORT_INFO   pPortInfo;
    PPORT_UPDATE_INFO   pPortUpdateInfo = NULL;

#ifdef  MYDEBUG
    DWORD               dwTime;
    CHAR                szBuf[200];

    dwTime = GetTickCount();
#endif

    dwRequestIndex = gUsbmonInfo.dwLastEnumIndex;

    *pcbNeeded = *pcReturned = 0;
    if ( dwLevel != 1 && dwLevel != 2 ) {

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if ( !LoadSetupApiDll(&SetupApiInfo) )
        return FALSE;

    EnterCriticalSection(&gUsbmonInfo.EnumPortsCS);

    if ( dwRequestIndex >= gUsbmonInfo.dwLastEnumIndex ) {

        //
        // No complete enumeration has occurred since this request was made.
        // Since the request may be an indication that something has changed,
        // the full reenumeration must be done.
        //
        // Updated the index of enumeration before actually doing the
        // work so it will show up as the most conservative
        //
        // Consequence of rollover on gdwLastEnumIndex:
        //     Any threads that recorded 0xFFFFFFFF as the dwRequestIndex
        // will show as greater than the new value 0 and therefore reenum
        // gratuitously. Not very much extra work.
        //
        ++gUsbmonInfo.dwLastEnumIndex;
        if ( dwLastError = WalkPortList(&SetupApiInfo, &gUsbmonInfo,
                                    &pPortUpdateInfo) )
            goto Done;
    }
#ifdef MYDEBUG
    else
        ++dwSkippedEnumPorts;
#endif

    for ( pPortInfo = gUsbmonInfo.pPortInfo ;
          pPortInfo ;
          pPortInfo = pPortInfo->pNext ) {

        if ( dwLevel == 1 )
            *pcbNeeded += sizeof(PORT_INFO_1) +
                            (lstrlen(pPortInfo->szPortName) + 1)
                                        * sizeof(TCHAR);
        else
            *pcbNeeded += sizeof(PORT_INFO_2)   +
                            gdwMonitorNameSize  +
                            (lstrlen(pPortInfo->szPortName) + 1 +
                             lstrlen(pPortInfo->szPortDescription) + 1 )
                                        * sizeof(TCHAR);

    }

    if ( cbBuf < *pcbNeeded ) {

        dwLastError = ERROR_INSUFFICIENT_BUFFER;
        goto Done;
    }

    pEnd = pPorts + cbBuf;

    for ( pPortInfo = gUsbmonInfo.pPortInfo ;
          pPortInfo ;
          pPortInfo = pPortInfo->pNext ) {

        pEnd = CopyPortToBuf(pPortInfo, dwLevel, pPorts, pEnd);

        if ( dwLevel == 1 )
            pPorts += sizeof(PORT_INFO_1);
        else
            pPorts += sizeof(PORT_INFO_2);
        ++(*pcReturned);
    }

    SPLASSERT(pEnd >= pPorts);

Done:
    PassPortUpdateListToBackgroundThread(&gUsbmonInfo, pPortUpdateInfo);

    LeaveCriticalSection(&gUsbmonInfo.EnumPortsCS);

    if ( SetupApiInfo.hSetupApi )
        FreeLibrary(SetupApiInfo.hSetupApi);

    ++gUsbmonInfo.dwEnumPortCount;

#ifdef  MYDEBUG
    dwTime = GetTickCount() - dwTime;
    ++(dwCount[3]);
    dwTotalTime[3] += dwTime;

    sprintf(szBuf, "SetupDiOpenDeviceInterfaceRegKey:   %d\n", dwTotalTime[0]/dwCount[0]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "SetupDiSetupDiEnumDeviceInterfaces: %d\n", dwTotalTime[1]/dwCount[1]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "SetupDiGetDeviceInterfaceDetail:    %d\n", dwTotalTime[2]/dwCount[2]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "EnumPorts:                          %d\n", dwTotalTime[3]/dwCount[3]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "LoadSetupApi:                       %d\n", dwTotalTime[5]/dwCount[5]);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Port updates per call               %d\n", dwPortUpdates/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Skipped port updates per call       %d\n", dwSkippedPorts/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Skipped enumport percentage         %d\n", 100 * dwSkippedEnumPorts/gUsbmonInfo.dwEnumPortCount);
    OutputDebugStringA(szBuf);
    sprintf(szBuf, "Ports/Useless ports           %d/%d\n", gUsbmonInfo.dwPortCount, gUsbmonInfo.dwUselessPortCount);
    OutputDebugStringA(szBuf);
    
#endif


    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    } else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\usbmon.old\usbmon.c ===
/*++             

Copyright (c) 1999  Microsoft Corporation
All Rights Reserved


Module Name:
    Usbmon.c

Abstract:
    USBMON core port monitor routines

Author:

Revision History:

--*/

#include "precomp.h"
#include "ntddpar.h"

#define LPT_NOT_ERROR     0x8
#define LPT_SELECT        0x10
#define LPT_PAPER_EMPTY   0x20
#define LPT_BENIGN_STATUS LPT_NOT_ERROR | LPT_SELECT

#define MAX_TIMEOUT 300000 //5 minutes

#define JOB_ABORTCHECK_TIMEOUT 5000

const TCHAR cszCFGMGR32[]=TEXT("cfgmgr32.dll");

const CHAR cszReenumFunc[]="CM_Reenumerate_DevNode_Ex";

#ifdef UNICODE
const CHAR cszLocalFunc[]="CM_Locate_DevNode_ExW";
#else
const CHAR cszLocalFunc[]="CM_Locate_DevNode_ExA";
#endif

BOOL GetLptStatus(HANDLE hDeviceHandle,BYTE *Return);

DWORD UsbmonDebug;


BOOL
APIENTRY
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
    )
{

    if ( dwReason == DLL_PROCESS_ATTACH )
        DisableThreadLibraryCalls(hModule);

    return TRUE;
}

BOOL
AbortThisJob(PUSBMON_PORT_INFO pPortInfo)
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
         !GetJob(pPortInfo->hPrinter, pPortInfo->dwJobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
 )
        goto Done;

    bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
           (pJobInfo->Status & JOB_STATUS_DELETED)  ||
           (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
    FreeSplMem(pJobInfo);

    return bRet;
}




BOOL
WINAPI
USBMON_OpenPort(
    LPTSTR      pszPortName,
    LPHANDLE    pHandle
    )
{
    PUSBMON_PORT_INFO   pPortInfo, pPrev;

    pPortInfo = FindPort(&gUsbmonInfo, pszPortName,  &pPrev);

    if ( pPortInfo ) {

        *pHandle = (LPHANDLE)pPortInfo;
        InitializeCriticalSection(&pPortInfo->CriticalSection);
        return TRUE;
    } else {

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

}

BOOL
WINAPI
USBMON_ClosePort(
    HANDLE  hPort
    )
{
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    DeleteCriticalSection(&pPortInfo->CriticalSection);
    return TRUE;
}


//
// Dot4Pnp - test whether we need to force a dot4 pnp event if the dot4 stack doesn't exist.
//
BOOL
Dot4Pnp(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL      bRet = FALSE;
    HANDLE    hToken;
    DEVINST   hLPTDevInst;
    TCHAR     szPnpEntry[]=TEXT("Root\\ParallelClass\\0000");   // The pnp node to reenumerate.
    TCHAR     cszDot4[]=TEXT("DOT4");                           // This relates to the array size below.
    TCHAR     szPort[5];                                        // 4 chars for "DOT4" and the ending 0.
    UINT      uOldErrorMode;
    HINSTANCE hCfgMgr32 = 0;                                    // Library instance.
    // Pointers to pnp functions...
    pfCM_Locate_DevNode_Ex pfnLocateDevNode; 
    pfCM_Reenumerate_DevNode_Ex pfnReenumDevNode;

    //
    //  Make a copy of the first 4 chars of the port name - to compare against Dot4.
    //  Copy length of 4 chars + 1 for null.
    lstrcpyn( szPort, pPortInfo->szPortName, lstrlen(cszDot4)+1 );
    szPort[lstrlen(cszDot4)]=0;

    if( lstrcmpi( szPort, cszDot4) != 0)
    {
        //
        // If this is not a dot4 port and we failed to open it - fail.
        //
        goto Done;
    }

    //
    // If it is a dot4 device we need to force a pnp event on the parallel port to get the
    // dot4 stack rebuilt.  
    // If any of these fail, fail the call just as if the port couldn't be opened.
    //
    // Load the pnp dll.
    //

    uOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hCfgMgr32 = LoadLibrary( cszCFGMGR32 );
    if(!hCfgMgr32)
    {
        SetErrorMode(uOldErrorMode);
        goto Done;
    }
    SetErrorMode(uOldErrorMode);

    //
    // Get the Addressed of pnp functions we want to call...
    //
    pfnLocateDevNode = (pfCM_Locate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszLocalFunc );
    pfnReenumDevNode = (pfCM_Reenumerate_DevNode_Ex)GetProcAddress( hCfgMgr32, cszReenumFunc );

    if( !pfnLocateDevNode || !pfnReenumDevNode )
        goto Done;

    //
    // We need to revert to system context here as otherwise the pnp call will fail if the user
    // is anything other than an admin as this requires admin rights.
    // If this fails, the pnp will fail anyway, so we don't need to test the return value.
    //
    hToken = RevertToPrinterSelf();

    //
    // Reenumerate from the root of the devnode tree
    //
    if( ( pfnLocateDevNode( &hLPTDevInst, szPnpEntry, CM_LOCATE_DEVNODE_NORMAL, NULL ) != CR_SUCCESS) ||
        ( pfnReenumDevNode( hLPTDevInst, CM_REENUMERATE_NORMAL, NULL ) != CR_SUCCESS) )
    {
        //
        // Revert back to the user's context in case we failed for another reason other than 
        // ACCESS DENIED (not admin)
        //
        ImpersonatePrinterClient(hToken);
        goto Done;
    }

    //
    // Revert back to the user's context.
    //
    ImpersonatePrinterClient(hToken);

    //
    // Try and open the port again.  
    // If we fail, then the device must not be there any more or still switched off - fail as usual.
    // 
    pPortInfo->hDeviceHandle = CreateFile(pPortInfo->szDevicePath,
                                          GENERIC_WRITE | GENERIC_READ,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
                                          OPEN_EXISTING,
                                          FILE_FLAG_OVERLAPPED,
                                          NULL);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE )
        goto Done;

    bRet = TRUE;
Done:
    if(hCfgMgr32)
        FreeLibrary(hCfgMgr32);

    return bRet;
}


BOOL
LocalOpenPort(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL    bRet = FALSE;

    EnterCriticalSection(&pPortInfo->CriticalSection);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE ) {

        //
        // If we have an invalid handle and refcount is non-zero we want the
        // job to fail and restart to accept writes. In other words if the
        // handle got closed prematurely, because of failing writes, then we
        // need the ref count to go down to 0 before calling CreateFile again
        //
        if ( pPortInfo->cRef )
            goto Done;

        pPortInfo->hDeviceHandle = CreateFile(pPortInfo->szDevicePath,
                                              GENERIC_WRITE | GENERIC_READ,
                                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                                              NULL,
                                              OPEN_EXISTING,
                                              FILE_FLAG_OVERLAPPED,
                                              NULL);
        //
        // If we failed to open the port - test to see if it is a Dot4 port.
        //
        if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE )
        {
            //
            // ERROR_FILE_NOT_FOUND -> Error code for port not there.
            //
            if( ERROR_FILE_NOT_FOUND != GetLastError() || 
                !Dot4Pnp(pPortInfo) )
                goto Done;
        }

        pPortInfo->Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
        if ( pPortInfo->Ov.hEvent == NULL ) {

            CloseHandle(pPortInfo->hDeviceHandle);
            pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;
            goto Done;
        }

    }

    ++(pPortInfo->cRef);
    bRet = TRUE;

Done:
    LeaveCriticalSection(&pPortInfo->CriticalSection);
    return bRet;
}


BOOL
LocalClosePort(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    BOOL    bRet = TRUE;
    BOOL bJobCanceled=FALSE;

    EnterCriticalSection(&pPortInfo->CriticalSection);

    --(pPortInfo->cRef);
    if ( pPortInfo->cRef != 0 )
        goto Done;

    bRet = CloseHandle(pPortInfo->hDeviceHandle);
    CloseHandle(pPortInfo->Ov.hEvent);
    pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;

Done:
    LeaveCriticalSection(&pPortInfo->CriticalSection);
    return bRet;
}


VOID
FreeWriteBuffer(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    FreeSplMem(pPortInfo->pWriteBuffer);
    pPortInfo->pWriteBuffer=NULL;

    pPortInfo->dwBufferSize = pPortInfo->dwDataSize
                            = pPortInfo->dwDataCompleted
                            = pPortInfo->dwDataScheduled = 0;

}


BOOL
WINAPI
USBMON_StartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   dwJobId,
    DWORD   dwLevel,
    LPBYTE  pDocInfo
    )
{
    BOOL                bRet = FALSE;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    SPLASSERT(pPortInfo->pWriteBuffer       == NULL &&
              pPortInfo->dwBufferSize       == 0    &&
              pPortInfo->dwDataSize         == 0    &&
              pPortInfo->dwDataCompleted    == 0    &&
              pPortInfo->dwDataScheduled    == 0);

    if ( !OpenPrinter(pPrinterName, &pPortInfo->hPrinter, NULL) )
        return FALSE;

    pPortInfo->dwJobId = dwJobId;
    bRet = LocalOpenPort(pPortInfo);

    if ( !bRet ) {

        if ( pPortInfo->hPrinter ) {

            ClosePrinter(pPortInfo->hPrinter);
            pPortInfo->hPrinter = NULL;
        }
    } else
        pPortInfo->dwFlags |= USBMON_STARTDOC;

    return bRet;
}


BOOL
NeedToResubmitJob(
    DWORD   dwLastError
    )
{
    //
    // I used winerror -s ntstatus to map KM error codes to user mode errors
    //
    // 5 ERROR_ACCESS_DENIED <--> c0000056 STATUS_DELETE_PENDING
    // 6 ERROR_INVALID_HANDLE <--> c0000008 STATUS_INVALID_HANDLE
    // 23 ERROR_CRC <--> 0xc000003e STATUS_DATA_ERROR
    // 23 ERROR_CRC <--> 0xc000003f STATUS_CRC_ERROR
    // 23 ERROR_CRC <--> 0xc000009c STATUS_DEVICE_DATA_ERROR
    // 55 ERROR_DEV_NOT_EXIST <--> c00000c0 STATUS_DEVICE_DOES_NOT_EXIST
    //
    return dwLastError == ERROR_ACCESS_DENIED   ||
           dwLastError == ERROR_INVALID_HANDLE  ||
           dwLastError == ERROR_CRC             ||
           dwLastError == ERROR_DEV_NOT_EXIST;
}


VOID
InvalidatePortHandle(
    PUSBMON_PORT_INFO   pPortInfo
    )
{
    SPLASSERT(pPortInfo->hDeviceHandle != INVALID_HANDLE_VALUE);

    CloseHandle(pPortInfo->hDeviceHandle);
    pPortInfo->hDeviceHandle = INVALID_HANDLE_VALUE;

    CloseHandle(pPortInfo->Ov.hEvent);
    pPortInfo->Ov.hEvent = NULL;

    FreeWriteBuffer(pPortInfo);
}



DWORD
ScheduleWrite(
    PUSBMON_PORT_INFO   pPortInfo
    )
/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS : Write got succesfully scheduled
                    (may or may not have completed on return)
                    pPortInfo->dwScheduledData is the amount that got scheduled
    Others: Write failed, return code is the Win32 error 

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS, dwDontCare;

    //
    // When a sheduled write is pending we should not try to send data
    // any more
    //
    SPLASSERT(pPortInfo->dwDataScheduled == 0);

    //
    // Send all the data that is not confirmed
    //
    SPLASSERT(pPortInfo->dwDataSize >= pPortInfo->dwDataCompleted);
    pPortInfo->dwDataScheduled = pPortInfo->dwDataSize -
                                      pPortInfo->dwDataCompleted;

    if ( !WriteFile(pPortInfo->hDeviceHandle,
                    pPortInfo->pWriteBuffer + pPortInfo->dwDataCompleted,
                    pPortInfo->dwDataScheduled,
                    &dwDontCare,
                    &pPortInfo->Ov) ) {

        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
            dwLastError = STG_E_UNKNOWN;
        else  if ( dwLastError == ERROR_IO_PENDING )
            dwLastError = ERROR_SUCCESS;
    }

    //
    // If scheduling of the write failed then no data is pending
    //
    if ( dwLastError != ERROR_SUCCESS )
        pPortInfo->dwDataScheduled = 0;

    return dwLastError;
}


DWORD
ScheduledWriteStatus(
    PUSBMON_PORT_INFO   pPortInfo,
    DWORD               dwTimeout
    )
/*++
    Routine Description:

Arguments:

Return Value:
    ERROR_SUCCESS   : Write got done succesfully
    ERROR_TIMEOUT   : Timeout occured
    Others          : Write completed with a failure

--*/
{
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   dwWritten = 0;

    SPLASSERT(pPortInfo->dwDataScheduled > 0);

    if ( WAIT_TIMEOUT == WaitForSingleObject(pPortInfo->Ov.hEvent,
                                             dwTimeout) ) {

        dwLastError = ERROR_TIMEOUT;
        goto Done;
    }

    if ( !GetOverlappedResult(pPortInfo->hDeviceHandle,
                              &pPortInfo->Ov,
                              &dwWritten,
                              FALSE) ) {

        if ( (dwLastError = GetLastError()) == ERROR_SUCCESS )
            dwLastError = STG_E_UNKNOWN;
    }

    ResetEvent(pPortInfo->Ov.hEvent);

    //
    // We are here because either a write completed succesfully,
    // or failed but the error is not serious enough to resubmit job
    //
    if ( dwWritten <= pPortInfo->dwDataScheduled )
        pPortInfo->dwDataCompleted += dwWritten;
    else
        SPLASSERT(dwWritten <= pPortInfo->dwDataScheduled);

    pPortInfo->dwDataScheduled = 0;

Done:
    //
    // Either we timed out, or write sheduled completed (success of failure)
    //
    SPLASSERT(dwLastError == ERROR_TIMEOUT || pPortInfo->dwDataScheduled == 0);
    return dwLastError;
}


BOOL
WINAPI
USBMON_EndDocPort(
    HANDLE  hPort
    )
{
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    DWORD               dwLastError = ERROR_SUCCESS;

    //
    // Wait for any outstanding write to complete
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        //
        // If job needs to be aborted ask KM driver to cancel the I/O
        //
        if ( AbortThisJob(pPortInfo) ) {

            if ( pPortInfo->dwDataScheduled ) {

                CancelIo(pPortInfo->hDeviceHandle);
                dwLastError = ScheduledWriteStatus(pPortInfo, INFINITE);
            }
            goto Done;
        }

        if ( pPortInfo->dwDataScheduled )
            dwLastError = ScheduledWriteStatus(pPortInfo,
                                               JOB_ABORTCHECK_TIMEOUT);
        else {

            //
            // If for some reason KM is failing to complete all write do not
            // send data in a busy loop. Use 1 sec between Writes
            //
            if ( dwLastError != ERROR_SUCCESS )
                Sleep(1*1000);

            dwLastError = ScheduleWrite(pPortInfo);
        }

        //
        // Check if we can use the same handle and continue
        //
        if ( NeedToResubmitJob(dwLastError) ) {

            InvalidatePortHandle(pPortInfo);
            SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
                   NULL, JOB_CONTROL_RESTART);
            goto Done;
        }
    }

Done:
    FreeWriteBuffer(pPortInfo);

    pPortInfo->dwFlags  &= ~USBMON_STARTDOC;

    LocalClosePort(pPortInfo);
    SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
           NULL, JOB_CONTROL_SENT_TO_PRINTER);

    ClosePrinter(pPortInfo->hPrinter);
    pPortInfo->hPrinter = NULL;
    
    return TRUE;
    

}

    
BOOL
WINAPI
USBMON_GetPrinterDataFromPort(
    HANDLE      hPort,
    DWORD       dwControlID,
    LPWSTR      pValueName,
    LPWSTR      lpInBuffer,
    DWORD       cbInBuffer,
    LPWSTR      lpOutBuffer,
    DWORD       cbOutBuffer,
    LPDWORD     lpcbReturned
    )
{
    BOOL                bRet = FALSE;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    OVERLAPPED          Ov;
    HANDLE hDeviceHandle;
    DWORD dwWaitResult;

    *lpcbReturned = 0;

    if ( dwControlID == 0 ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ZeroMemory(&Ov, sizeof(Ov));
    if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        return FALSE;

    if ( !LocalOpenPort(pPortInfo) ) {

        CloseHandle(Ov.hEvent);
        return FALSE;
    }

    if(dwControlID==IOCTL_PAR_QUERY_DEVICE_ID)
    {
        hDeviceHandle=CreateFile(pPortInfo->szDevicePath,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,
                                 NULL);
        if(hDeviceHandle==INVALID_HANDLE_VALUE)
            goto Done;
        if ( !DeviceIoControl(pPortInfo->hDeviceHandle, dwControlID,lpInBuffer, cbInBuffer,lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov) 
            && GetLastError() != ERROR_IO_PENDING )
        {
          CloseHandle(hDeviceHandle);
          goto Done;
        }

        if(WaitForSingleObject(Ov.hEvent,PAR_QUERY_TIMEOUT)!=WAIT_OBJECT_0)
          CancelIo(hDeviceHandle);
        bRet = GetOverlappedResult(pPortInfo->hDeviceHandle, &Ov,lpcbReturned,TRUE);
      CloseHandle(hDeviceHandle);
    }
    else
    {
      if ( !DeviceIoControl(pPortInfo->hDeviceHandle, dwControlID,
                          lpInBuffer, cbInBuffer,
                          lpOutBuffer, cbOutBuffer, lpcbReturned, &Ov)  &&
          GetLastError() != ERROR_IO_PENDING )
        goto Done;

      bRet = GetOverlappedResult(pPortInfo->hDeviceHandle, &Ov,
                               lpcbReturned, TRUE);
    }

Done:
    CloseHandle(Ov.hEvent);

    LocalClosePort(pPortInfo);

            
    return bRet;
}


BOOL
WINAPI
USBMON_ReadPort(
    HANDLE      hPort,
    LPBYTE      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pcbRead
    )
{
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwTimeout;
    HANDLE              hReadHandle;
    OVERLAPPED          Ov;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;

    //
    // Create separate read handle since we have to cancel reads which do
    // not complete within the specified timeout without cancelling writes
    //
    hReadHandle = CreateFile(pPortInfo->szDevicePath,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_OVERLAPPED,
                             NULL);

    if ( hReadHandle == INVALID_HANDLE_VALUE )
        return FALSE;

    ZeroMemory(&Ov, sizeof(Ov));

    if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
        goto Done;

    if ( !ReadFile(hReadHandle, pBuffer, cbBuffer, pcbRead, &Ov) &&
         (dwLastError = GetLastError()) != ERROR_IO_PENDING )
        goto Done;

    dwTimeout = pPortInfo->ReadTimeoutConstant +
                    pPortInfo->ReadTimeoutMultiplier * cbBuffer;

    if ( dwTimeout == 0 )
        dwTimeout=MAX_TIMEOUT;

    if( WaitForSingleObject(Ov.hEvent, dwTimeout) == WAIT_TIMEOUT ) {

        CancelIo(hReadHandle);
        WaitForSingleObject(Ov.hEvent, INFINITE);
    }

    if( !GetOverlappedResult(hReadHandle, &Ov, pcbRead, FALSE) ) {

        *pcbRead = 0;
        dwLastError = GetLastError();
    } else
        dwLastError = ERROR_SUCCESS;

Done:
    if ( Ov.hEvent )
        CloseHandle(Ov.hEvent);

    CloseHandle(hReadHandle);

    if ( dwLastError )
        SetLastError(dwLastError);

    return dwLastError == ERROR_SUCCESS;
}

DWORD dwGetTimeLeft(DWORD dwStartTime,DWORD dwTimeout)
{
    DWORD dwCurrentTime;
    DWORD dwTimeLeft;

    if(dwTimeout==MAX_TIMEOUT)
        return MAX_TIMEOUT;
    dwCurrentTime=GetTickCount();
    if(dwTimeout<(dwCurrentTime-dwStartTime))
        dwTimeLeft=0;
    else
      dwTimeLeft=dwTimeout-(dwCurrentTime-dwStartTime);
    return dwTimeLeft;
}

BOOL
WINAPI
USBMON_WritePort(
    HANDLE      hPort,
    LPBYTE      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pcbWritten
    )
{
    DWORD               dwLastError = ERROR_SUCCESS;
    DWORD               dwBytesLeft, dwBytesSent;
    DWORD               dwStartTime, dwTimeLeft, dwTimeout;
    PUSBMON_PORT_INFO   pPortInfo = (PUSBMON_PORT_INFO)hPort;
    BOOL                bStartDoc = (pPortInfo->dwFlags & USBMON_STARTDOC) != 0;
    BYTE                bPrinterStatus;

    *pcbWritten = 0;
    dwStartTime = GetTickCount();
    dwTimeout   = pPortInfo->WriteTimeoutConstant + pPortInfo->WriteTimeoutMultiplier * cbBuffer;

    if ( dwTimeout == 0 )
        dwTimeout = MAX_TIMEOUT;

    //
    // Usbprint currently can't handle write greater than 4K.
    // For Win2K we will make a fix here, later usbprint will be fixed
    //
    // It is ok to change the size here since spooler will resubmit the rest
    // later
    //
    if ( cbBuffer > 0x1000  &&
         !lstrncmpi(pPortInfo->szPortName, TEXT("USB"), lstrlen(TEXT("USB"))) )
        cbBuffer = 0x1000;

    //
    // For writes outside startdoc/enddoc we do not carry them across WritePort
    // calls. These are typically from language monitors (i.e. not job data)
    //
    SPLASSERT(bStartDoc || pPortInfo->pWriteBuffer == NULL);

    if ( pPortInfo->hDeviceHandle == INVALID_HANDLE_VALUE ) {

        SetJob(pPortInfo->hPrinter, pPortInfo->dwJobId, 0,
               NULL, JOB_CONTROL_RESTART);
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    if ( !LocalOpenPort(pPortInfo) )
        return FALSE;

    //
    // First complete any data from previous WritePort call
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        if ( pPortInfo->dwDataScheduled ) {

            dwTimeLeft  = dwGetTimeLeft(dwStartTime, dwTimeout);
            dwLastError = ScheduledWriteStatus(pPortInfo, dwTimeLeft);
        } else
            dwLastError = ScheduleWrite(pPortInfo);

        if ( dwLastError != ERROR_SUCCESS )
            goto Done;
    }

    SPLASSERT(pPortInfo->dwDataSize == pPortInfo->dwDataCompleted   &&
              pPortInfo->dwDataScheduled == 0                       &&
              dwLastError == ERROR_SUCCESS);

    //
    // Copy the data to our own buffer
    //
    if ( pPortInfo->dwBufferSize < cbBuffer ) {

        FreeWriteBuffer(pPortInfo);
        if ( pPortInfo->pWriteBuffer = AllocSplMem(cbBuffer) )
            pPortInfo->dwBufferSize = cbBuffer;
        else {

            dwLastError = ERROR_OUTOFMEMORY;
            goto Done;
        }
    } else {

        pPortInfo->dwDataCompleted = pPortInfo->dwDataScheduled = 0;
    }

    CopyMemory(pPortInfo->pWriteBuffer, pBuffer, cbBuffer);
    pPortInfo->dwDataSize = cbBuffer;

    //
    // Now do the write for the data for this WritePort call
    //
    while ( pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        if ( pPortInfo->dwDataScheduled ) {

            dwTimeLeft  = dwGetTimeLeft(dwStartTime, dwTimeout);
            dwLastError = ScheduledWriteStatus(pPortInfo, dwTimeLeft);
        } else
            dwLastError = ScheduleWrite(pPortInfo);

        if ( dwLastError != ERROR_SUCCESS )
            break;
    }

    //
    // For writes outside startdoc/enddoc, which are from language monitors,
    // do not carry pending writes to next WritePort.
    //
    if ( !bStartDoc && pPortInfo->dwDataSize > pPortInfo->dwDataCompleted ) {

        CancelIo(pPortInfo->hDeviceHandle);
        dwLastError = ScheduledWriteStatus(pPortInfo, INFINITE);
        *pcbWritten = pPortInfo->dwDataCompleted;
        FreeWriteBuffer(pPortInfo);
    }

    //
    // We will tell spooler we wrote all the data if some data got scheduled
    //  (or scheduled and completed)
    //
    if ( pPortInfo->dwDataCompleted > 0 || pPortInfo->dwDataScheduled != 0 )
        *pcbWritten = cbBuffer;
    else
        FreeWriteBuffer(pPortInfo);

Done:
    if ( NeedToResubmitJob(dwLastError) )
        InvalidatePortHandle(pPortInfo);
    else if ( dwLastError == ERROR_TIMEOUT ) {

        GetLptStatus(pPortInfo->hDeviceHandle, &bPrinterStatus);
        if ( bPrinterStatus & LPT_PAPER_EMPTY )
            dwLastError=ERROR_OUT_OF_PAPER;
    }
  
    LocalClosePort(pPortInfo);
    SetLastError(dwLastError);
    return dwLastError == ERROR_SUCCESS;
}


BOOL
WINAPI
USBMON_SetPortTimeOuts(
    HANDLE hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD reserved
    )
{
    
    PUSBMON_PORT_INFO pPortInfo = (PUSBMON_PORT_INFO)hPort;
    pPortInfo->ReadTimeoutMultiplier    = lpCTO->ReadTotalTimeoutMultiplier;
    pPortInfo->ReadTimeoutConstant      = lpCTO->ReadTotalTimeoutConstant;
    pPortInfo->WriteTimeoutMultiplier   = lpCTO->WriteTotalTimeoutMultiplier;
    pPortInfo->WriteTimeoutConstant     = lpCTO->WriteTotalTimeoutConstant;

    return TRUE;
}



BOOL GetLptStatus(HANDLE hDeviceHandle,BYTE *Status)
{
    BYTE StatusByte;
    OVERLAPPED Ov;

    BOOL bResult;
    DWORD dwBytesReturned;
    DWORD dwLastError;
    Ov.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
    bResult=DeviceIoControl(hDeviceHandle,IOCTL_USBPRINT_GET_LPT_STATUS,NULL,0,&StatusByte,1,&dwBytesReturned,&Ov);
    dwLastError=GetLastError();      
    if((bResult)||(dwLastError==ERROR_IO_PENDING))
        bResult=GetOverlappedResult(hDeviceHandle,&Ov,&dwBytesReturned,TRUE);
    if(bResult)
    {
        *Status=StatusByte;
    }
    else
    {
        *Status=LPT_BENIGN_STATUS; //benign printer status...  0 would indicate a particular error status from the printer
    }
    CloseHandle(Ov.hEvent);
    return bResult;
}














MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        USBMON_EnumPorts,
        USBMON_OpenPort,
        NULL,                           // OpenPortEx not supported
        USBMON_StartDocPort,
        USBMON_WritePort,
        USBMON_ReadPort,
        USBMON_EndDocPort,
        USBMON_ClosePort,
        NULL,                           // AddPort not supported
        NULL,                           // AddPortEx not supported
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        USBMON_GetPrinterDataFromPort,
        USBMON_SetPortTimeOuts,
        NULL,                           // XcvOpenPort not supported
        NULL,                           // XcvDataPort not supported
        NULL                            // XcvClosePort not supported
    }
};

USBMON_MONITOR_INFO gUsbmonInfo;

LPMONITOREX
WINAPI
InitializePrintMonitor(
    LPTSTR  pszRegistryRoot
    )

{
    ZeroMemory(&gUsbmonInfo, sizeof(gUsbmonInfo));
    InitializeCriticalSection(&gUsbmonInfo.EnumPortsCS);
    InitializeCriticalSection(&gUsbmonInfo.BackThreadCS);

    return &MonitorEx;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\config.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    config.c

Abstract:

    Handles spooler entry points for adding, deleting, and configuring
    localmon ports.

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


PINIPORT
LcmCreatePortEntry(
    PINILOCALMON pIniLocalMon,
    PWSTR pPortName
    )
{
    DWORD       cb;
    PINIPORT    pIniPort, pPort;
    size_t cchPortName = wcslen (pPortName) + 1;

    if (!pPortName || wcslen(pPortName) > 247)
    {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }

    cb = sizeof(INIPORT) + cchPortName * sizeof (WCHAR);

    pIniPort=AllocSplMem(cb);

    if( pIniPort )
    {
        pIniPort->pName = (LPWSTR)(pIniPort+1);
        StringCchCopy (pIniPort->pName, cchPortName, pPortName);
        pIniPort->cb = cb;
        pIniPort->pNext = 0;
        pIniPort->pIniLocalMon = pIniLocalMon;
        pIniPort->signature = IPO_SIGNATURE;

        // @@BEGIN_DDKSPLIT
        //
        // KrishnaG --  initialized the hFile value; it will be set to
        // a legal value in the StartDocPort call
        //
        // @@END_DDKSPLIT

        pIniPort->hFile = INVALID_HANDLE_VALUE;

        LcmEnterSplSem();

        if (pPort = pIniLocalMon->pIniPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniPort;

        } else
            pIniLocalMon->pIniPort = pIniPort;

        LcmLeaveSplSem();
    }   

    return pIniPort;
}


PINIXCVPORT
CreateXcvPortEntry(
    PINILOCALMON pIniLocalMon,
    LPCWSTR pszName,
    ACCESS_MASK GrantedAccess
)
{
    DWORD       cb;
    PINIXCVPORT pIniXcvPort, pPort;
    size_t cchName = wcslen (pszName) + 1;

    cb = sizeof(INIXCVPORT) + cchName*sizeof(WCHAR);

    pIniXcvPort = AllocSplMem(cb);

    if( pIniXcvPort )
    {
        pIniXcvPort->pszName = (LPWSTR)(pIniXcvPort+1);
        StringCchCopy (pIniXcvPort->pszName, cchName, pszName);
        pIniXcvPort->dwMethod = 0;
        pIniXcvPort->cb = cb;
        pIniXcvPort->pNext = 0;
        pIniXcvPort->signature = XCV_SIGNATURE;
        pIniXcvPort->GrantedAccess = GrantedAccess;
        pIniXcvPort->pIniLocalMon = pIniLocalMon;


        if (pPort = pIniLocalMon->pIniXcvPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniXcvPort;

        } else
            pIniLocalMon->pIniXcvPort = pIniXcvPort;
    }

    return pIniXcvPort;
}

BOOL
DeleteXcvPortEntry(
    PINIXCVPORT  pIniXcvPort
)
{
    PINILOCALMON pIniLocalMon = pIniXcvPort->pIniLocalMon;
    PINIXCVPORT  pPort, pPrevPort;

    for (pPort = pIniLocalMon->pIniXcvPort;
         pPort && pPort != pIniXcvPort;
         pPort = pPort->pNext){

        pPrevPort = pPort;
    }

    if (pPort) {    // found the port
        if (pPort == pIniLocalMon->pIniXcvPort) {
            pIniLocalMon->pIniXcvPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }

        FreeSplMem(pPort);

        return TRUE;
    }
    else            // port not found
        return FALSE;
}



BOOL
LcmDeletePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
)
{
    DWORD       cb;
    PINIPORT    pPort, pPrevPort;

    cb = sizeof(INIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

    pPort = pIniLocalMon->pIniPort;


    while (pPort) {

        if (!lstrcmpi(pPort->pName, pPortName)) {
            if (pPort->Status & PP_FILEPORT) {
                pPrevPort = pPort;
                pPort = pPort->pNext;
                continue;
            }
            break;
        }

        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort) {
        if (pPort == pIniLocalMon->pIniPort) {
            pIniLocalMon->pIniPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplMem(pPort);

        return TRUE;
    }
    else
        return FALSE;
}



DWORD
GetPortSize(
    PINIPORT pIniPort,
    DWORD   Level
)
{
    DWORD   cb;
    WCHAR   szLocalMonitor[MAX_PATH+1], szPortDesc[MAX_PATH+1];

    switch (Level) {

    case 1:

        cb=sizeof(PORT_INFO_1) +
           wcslen(pIniPort->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    case 2:
        LoadString(LcmhInst, IDS_LOCALMONITORNAME, szLocalMonitor, MAX_PATH);
        LoadString(LcmhInst, IDS_LOCALMONITOR, szPortDesc, MAX_PATH);
        cb = wcslen(pIniPort->pName) + 1 +
             wcslen(szLocalMonitor) + 1 +
             wcslen(szPortDesc) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(PORT_INFO_2);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

LPBYTE
CopyIniPortToPort(
    PINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
)
{
    LPWSTR         *SourceStrings,  *pSourceStrings;
    PPORT_INFO_2    pPort2 = (PPORT_INFO_2)pPortInfo;
    WCHAR           szLocalMonitor[MAX_PATH+1], szPortDesc[MAX_PATH+1];
    DWORD          *pOffsets;
    DWORD           Count;

    switch (Level) {

    case 1:
        pOffsets = LcmPortInfo1Strings;
        break;

    case 2:
        pOffsets = LcmPortInfo2Strings;
        break;

    default:
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
        return NULL;
    }

    for ( Count = 0 ; pOffsets[Count] != -1 ; ++Count ) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(Count * sizeof(LPWSTR));

    if ( !SourceStrings ) {

        DBGMSG( DBG_WARNING, ("Failed to alloc port source strings.\n"));
        return NULL;
    }

    switch (Level) {

    case 1:
        *pSourceStrings++=pIniPort->pName;

        break;

    case 2:
        *pSourceStrings++=pIniPort->pName;

        LoadString(LcmhInst, IDS_LOCALMONITORNAME, szLocalMonitor, MAX_PATH);
        LoadString(LcmhInst, IDS_LOCALMONITOR, szPortDesc, MAX_PATH);
        *pSourceStrings++ = szLocalMonitor;
        *pSourceStrings++ = szPortDesc;

        // @@BEGIN_DDKSPLIT
        // How do i findout other types ???
        // @@END_DDKSPLIT
        pPort2->fPortType = PORT_TYPE_WRITE;

        // Reserved
        pPort2->Reserved = 0;

        break;

    default:
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
        return NULL;
    }

    pEnd = PackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);

    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\irda.c ===
/*++

Copyright (c) 1997-2003  Microsoft Corporation
All rights reserved

Module Name:

    irda.c

Abstract:

    IRDA printing support in localmon

// @@BEGIN_DDKSPLIT
Author:
    Muhunthan Sivapragasam (MuhuntS)    27-Oct-97

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include    "precomp.h"
#pragma hdrstop

#include    <af_irda.h>
#include    "irda.h"

#define     PRINTER_HINT_BIT     0x08
#define     DEVICE_LIST_LEN         5
#define     WRITE_TIMEOUT       60000   // 60 seconds
#define     BUF_SIZE            sizeof(DEVICELIST) + (DEVICE_LIST_LEN - 1) * sizeof(IRDA_DEVICE_INFO)


typedef struct _IRDA_INFO  {
    DWORD           dwBeginTime;
    DWORD           dwSendPduLen;
    WSAOVERLAPPED   WsaOverlapped;
    WSABUF          WsaBuf;
    LPBYTE          pBuf;
} IRDA_INFO, *PIRDA_INFO;


BOOL
IsIRDAInstalled(
    )
{
    BOOL        bRet = FALSE;
    WORD        WSAVerReq = MAKEWORD(1,1);
    SOCKET      hSock;
    WSADATA     WSAData;


    if ( WSAStartup(WSAVerReq, &WSAData) == ERROR_SUCCESS       &&
         (hSock = socket(AF_IRDA, SOCK_STREAM, 0)) != INVALID_SOCKET ) {

        closesocket(hSock);
        bRet = TRUE;
    }

    WSACleanup();
    return bRet;
}


VOID
CheckAndAddIrdaPort(
    PINILOCALMON    pIniLocalMon
    )
{
    PINIPORT    pIniPort;

    LcmEnterSplSem();

    for ( pIniPort = pIniLocalMon->pIniPort ;
          pIniPort && !IS_IRDA_PORT(pIniPort->pName) ;
          pIniPort = pIniPort->pNext )
    ;

    LcmLeaveSplSem();

    if ( pIniPort || !IsIRDAInstalled() )
        return;

    //
    // Add the port to the list and write to registry
    //
    LcmCreatePortEntry(pIniLocalMon, szIRDA);

// @@BEGIN_DDKSPLIT
/*
    if ( (pIniPort = LcmCreatePortEntry(pIniLocalMon, szIRDA))  &&
         !WriteProfileString(szPorts, szIRDA, L"") ) {

        DeletePortNode(pIniLocalMon, pIniPort);
    }
*/
// @@END_DDKSPLIT
}


VOID
CloseIrdaConnection(
    PINIPORT    pIniPort
    )
{
    PIRDA_INFO  pIrda = (PIRDA_INFO) pIniPort->pExtra;

    if ( pIrda ) {

        if ( pIrda->WsaOverlapped.hEvent )
            WSACloseEvent(pIrda->WsaOverlapped.hEvent);

        FreeSplMem(pIrda);
        pIniPort->pExtra = NULL;
    }

    if ( (SOCKET)pIniPort->hFile != INVALID_SOCKET ) {

        closesocket((SOCKET)pIniPort->hFile);
        pIniPort->hFile = (HANDLE)INVALID_SOCKET;
    }
}


DWORD
IrdaConnect(
    PINIPORT    pIniPort
    )
{
    BOOL            bRet = FALSE;
    WORD            WSAVerReq = MAKEWORD(1,1);
    DWORD           dwIndex, dwNeeded = BUF_SIZE, dwEnableIrLPT = TRUE,
                    dwLastError = ERROR_SUCCESS, dwSendPduLen;
    LPSTR           pBuf = NULL;
    WSADATA         WSAData;
    SOCKET          Socket = INVALID_SOCKET;
    IAS_QUERY       IasQuery;
    PIRDA_INFO      pIrda;
    PDEVICELIST     pDevList;
    SOCKADDR_IRDA   PrinterAddr  = { AF_IRDA, 0, 0, 0, 0, "IrLPT" };

    SPLASSERT(pIniPort->hFile == (HANDLE)INVALID_SOCKET && pIniPort->pExtra == NULL);

    if ( dwLastError = WSAStartup(WSAVerReq, &WSAData) )
        goto Done;

    if ( !(pBuf = AllocSplMem(dwNeeded)) ) {

        dwLastError = GetLastError();
        goto Done;
    }

    if ( (Socket = WSASocket(AF_IRDA, SOCK_STREAM, 0, NULL, 0,
                             WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET    ||
         getsockopt(Socket, SOL_IRLMP, IRLMP_ENUMDEVICES,
                    (LPSTR)pBuf, &dwNeeded) == SOCKET_ERROR ) {

        dwLastError = WSAGetLastError();
        goto Done;
    }

    if ( dwNeeded > BUF_SIZE ) {

        FreeSplMem(pBuf);
        if ( !(pBuf = AllocSplMem(dwNeeded)) ) {

            dwLastError = GetLastError();
            goto Done;
        }

        if ( getsockopt(Socket, SOL_IRLMP, IRLMP_ENUMDEVICES,
                        (LPSTR)pBuf, &dwNeeded) == SOCKET_ERROR ) {

            dwLastError = WSAGetLastError();
            goto Done;
        }
    }

    pDevList = (PDEVICELIST) pBuf;

    //
    // Any of the devices a printer?
    //
    for ( dwIndex = 0 ; dwIndex < pDevList->numDevice ; ++dwIndex ) {

        if ( (pDevList->Device[dwIndex].irdaDeviceHints1 & PRINTER_HINT_BIT)  ||
             (pDevList->Device[dwIndex].irdaDeviceHints2 & PRINTER_HINT_BIT) )
            break;
    }

    //
    // Any printers found?
    //
    if ( dwIndex == pDevList->numDevice ) {

        dwLastError = ERROR_PRINTER_NOT_FOUND;
        goto Done;
    }

    //
    // Move printer's address into the socket address
    //
    memcpy(PrinterAddr.irdaDeviceID,
           pDevList->Device[dwIndex].irdaDeviceID,
           sizeof(PrinterAddr.irdaDeviceID));

    dwIndex = 0;
    dwNeeded = sizeof(dwSendPduLen);
    bRet = SOCKET_ERROR != setsockopt(Socket,
                                      SOL_IRLMP,
                                      IRLMP_IRLPT_MODE,
                                      (LPCSTR)&dwEnableIrLPT,
                                      sizeof(dwEnableIrLPT))    &&
           SOCKET_ERROR != connect(Socket,
                                   (const struct sockaddr *)&PrinterAddr,
                                   sizeof(PrinterAddr))         &&
           // @@BEGIN_DDKSPLIT
           //
           // What size should we use for sends?
           //
           // @@END_DDKSPLIT
           SOCKET_ERROR != getsockopt(Socket,
                                      SOL_IRLMP,
                                      IRLMP_SEND_PDU_LEN,
                                      (char *)&dwSendPduLen,
                                      &dwNeeded) &&
           // @@BEGIN_DDKSPLIT
           //
           // No buffering (i.e. buffer size of 0)
           //
           // @@END_DDKSPLIT
           SOCKET_ERROR != setsockopt(Socket,
                                      SOL_SOCKET,
                                      SO_SNDBUF,
                                      (LPCSTR)&dwIndex,
                                      sizeof(dwIndex));


    if ( bRet ) {

        SPLASSERT(pIniPort->pExtra == NULL);

        dwNeeded = sizeof(IRDA_INFO) + dwSendPduLen;

        if ( !(pIrda = (PIRDA_INFO) AllocSplMem(dwNeeded)) ) {

            bRet = FALSE;
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        pIniPort->hFile     = (HANDLE)Socket;
        pIniPort->pExtra    = (LPBYTE)pIrda;

        pIrda->dwSendPduLen = dwSendPduLen;
        pIrda->pBuf         = ((LPBYTE) pIrda) + sizeof(IRDA_INFO);

    } else
        dwLastError = WSAGetLastError();

Done:
    FreeSplMem(pBuf);

    if ( !bRet ) {

        if ( Socket != INVALID_SOCKET )
            closesocket(Socket);

        FreeSplMem(pIniPort->pExtra);
        pIniPort->pExtra = NULL;
    }

    return bRet ? ERROR_SUCCESS : dwLastError;
}


BOOL
AbortThisJob(
    PINIPORT    pIniPort
    )
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(pIniPort->hPrinter, pIniPort->JobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) AllocSplMem(dwNeeded))     ||
         !GetJob(pIniPort->hPrinter, pIniPort->JobId,
                 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded)
 )
        goto Done;

    bRet = (pJobInfo->Status & JOB_STATUS_DELETING) ||
           (pJobInfo->Status & JOB_STATUS_DELETED)  ||
           (pJobInfo->Status & JOB_STATUS_RESTART);
Done:
    if ( pJobInfo )
        FreeSplMem(pJobInfo);

    return bRet;
}


VOID
IrdaDisconnect(
    PINIPORT    pIniPort
    )
{
    BOOL        bRet;
    DWORD       dwRet, dwSent, dwFlags;
    SOCKET      Socket = (SOCKET) pIniPort->hFile;
    PIRDA_INFO  pIrda = (PIRDA_INFO) pIniPort->pExtra;

    //
    // If the job has already been cancelled close socket and quit
    //
    if ( Socket == INVALID_SOCKET )
        goto Done;

    //
    // If a send is pending wait for all the data to go through indefinitly
    //
    if ( pIrda->WsaOverlapped.hEvent ) {

        do {

            dwRet = WaitForSingleObject(pIrda->WsaOverlapped.hEvent,
                                        WRITE_TIMEOUT);

            if ( dwRet == WAIT_TIMEOUT ) {

                //
                // If user has cancelled the job close connection
                //
                if ( AbortThisJob(pIniPort) )
                    goto Done;
            } else if ( dwRet != WAIT_OBJECT_0 )
                goto Done;
        } while ( dwRet == WAIT_TIMEOUT );

        //
        // IRDA can only send the whole packet so we do not check dwSent
        //
    }

    //
    // No more sends
    //
    shutdown(Socket, SD_SEND);

Done:
    CloseIrdaConnection(pIniPort);
}


BOOL
IrdaStartDocPort(
    IN OUT  PINIPORT    pIniPort
    )
{
    HANDLE hToken;
    DWORD  dwLastError;
     
    //
    // If remote guest is the first user to print, then the connect fails.
    // Thus we need to revert to system context before calling IrdaConnect
    //

    hToken = RevertToPrinterSelf();

    if (!hToken) {
        return FALSE;
    }
    
    dwLastError = IrdaConnect(pIniPort);

    ImpersonatePrinterClient(hToken);

    if ( dwLastError ) {

        SetLastError(dwLastError);
        return FALSE;
    } else
        return TRUE;
}


BOOL
IrdaWritePort(
    IN  HANDLE      hPort,
    IN  LPBYTE      pBuf,
    IN  DWORD       cbBuf,
    IN  LPDWORD     pcbWritten
    )
{
    INT             iRet = ERROR_SUCCESS;
    DWORD           dwSent, dwFlags, dwTimeout, dwBuffered;
    PINIPORT        pIniPort = (PINIPORT)hPort;
    SOCKET          Socket = (SOCKET) pIniPort->hFile;
    PIRDA_INFO      pIrda = (PIRDA_INFO)pIniPort->pExtra;

    *pcbWritten = 0;

    //
    // When we have to close socket we fail the write.
    // If anothe write comes through it is because user wanted to retry
    //
    if ( Socket == INVALID_SOCKET ) {

        SPLASSERT(pIrda == NULL);

        SetJob(pIniPort->hPrinter, pIniPort->JobId, 0, NULL, JOB_CONTROL_RESTART);
        iRet = WSAENOTSOCK;
        goto Done;
    }

    SPLASSERT(pIrda != NULL);

    //
    // This is the time spooler issued the write to us
    //
    pIrda->dwBeginTime = GetTickCount();

    do {

        //
        // If event is non-NULL at the beginning we have a pending write from
        // last WritePort call
        //
        if ( pIrda->WsaOverlapped.hEvent ) {

            dwTimeout = GetTickCount() - pIrda->dwBeginTime;

            //
            // We want to wait for WRITE_TIMEOUT time from the time spooler
            // issued the WritePort.
            // If it is already more than that still check what happened to the
            // write before returning
            //
            if ( dwTimeout > WRITE_TIMEOUT )
                dwTimeout = 0;
            else
                dwTimeout = WRITE_TIMEOUT - dwTimeout;

            //
            // Let's wait for the timeout period for the last send to complete
            //
            if ( WAIT_OBJECT_0 != WaitForSingleObject(pIrda->WsaOverlapped.hEvent,
                                                      dwTimeout) ) {

                iRet = ERROR_TIMEOUT;
                goto Done;
            }

            //
            // What happened to the last send?
            //
            if ( WSAGetOverlappedResult(Socket, &pIrda->WsaOverlapped,
                                        &dwSent, FALSE, &dwFlags) == FALSE ) {

                iRet = WSAGetLastError();
                CloseIrdaConnection(pIniPort);
                goto Done;
            }

            //
            // IRDA can only send the whole packet so we do not check dwSent
            //

            //
            // Reset the manual reset event and do the next send
            //
            WSAResetEvent(pIrda->WsaOverlapped.hEvent);

            //
            // Have we already sent all the data?
            //
            if ( cbBuf == 0 ) {

                WSACloseEvent(pIrda->WsaOverlapped.hEvent);
                pIrda->WsaOverlapped.hEvent = NULL;
                goto Done;
            }
        } else {

            pIrda->WsaOverlapped.hEvent = WSACreateEvent();

            if ( !pIrda->WsaOverlapped.hEvent ) {

                iRet = GetLastError();
                CloseIrdaConnection(pIniPort);
                goto Done;
            }
        }

        do {

            //
            // Have we already sent all the data?
            //
            if ( cbBuf == 0 ) {

                WSACloseEvent(pIrda->WsaOverlapped.hEvent);
                pIrda->WsaOverlapped.hEvent = NULL;
                goto Done;
            }

            //
            // Send no more than pIrda->dwSendPduLen
            //
            if ( cbBuf < pIrda->dwSendPduLen )
                dwBuffered = cbBuf;
            else
                dwBuffered = pIrda->dwSendPduLen;

            pIrda->WsaBuf.len   = dwBuffered;
            pIrda->WsaBuf.buf   = pIrda->pBuf;

            CopyMemory(pIrda->pBuf, pBuf, dwBuffered);

            //
            // We are asking a non-blocking send. Typically this will
            // return with I/O pending
            //
            if ( WSASend(Socket, &pIrda->WsaBuf, 1, &dwSent,
                         MSG_PARTIAL, &pIrda->WsaOverlapped, NULL) != NO_ERROR ) {

                iRet = WSAGetLastError();
                break;
            }

            pBuf        += dwSent;
            cbBuf       -= dwSent;
            *pcbWritten += dwSent;
        } while ( iRet == NO_ERROR );

        if ( iRet == WSA_IO_PENDING ) {

            //
            // Lie to spooler we sent the whole data. Next time we will find out
            //
            pBuf        += dwBuffered;
            cbBuf       -= dwBuffered;
            *pcbWritten += dwBuffered;
            iRet = NO_ERROR;
        } else {

            DBGMSG(DBG_ERROR, ("IrdaWritePort: WSASend failed %d\n", iRet));
            CloseIrdaConnection(pIniPort);
        }
    } while ( cbBuf && iRet == NO_ERROR );


Done:
    if ( iRet != ERROR_SUCCESS )
        SetLastError(iRet);

    return iRet == ERROR_SUCCESS;
}


VOID
IrdaEndDocPort(
    PINIPORT    pIniPort
    )
{
    IrdaDisconnect(pIniPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\irda.h ===
/*++

Copyright (c) 1997-2003  Microsoft Corporation
All rights reserved.

Module Name:

    irda.h

Abstract:

    Definitions used for IRDA printing

// @@BEGIN_DDKSPLIT
Author:

    Muhunthan Sivapragasam (MuhuntS)  27-Oct-97

Revision History:
// @@END_DDKSPLIT
--*/

VOID
CheckAndAddIrdaPort(
    PINILOCALMON    pIniLocalMon
    );

VOID
CheckAndDeleteIrdaPort(
    PINILOCALMON    pIniLocalMon
    );

BOOL
IrdaStartDocPort(
    IN OUT  PINIPORT    pIniPort
    );

BOOL
IrdaWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuf,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
    );

VOID
IrdaEndDocPort(
    PINIPORT    pIniPort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\dynamon\usbmon.old\enumports.h ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved.

Module Name:

    enumports.h

Abstract:

    USBMON header file


--*/

//
// Sizes
//
#define MAX_PORT_LEN                        20
#define MAX_PORT_DESC_LEN                   60
#define MAX_DEVICE_PATH                    256
#define PAR_QUERY_TIMEOUT                 5000

static const GUID USB_PRINTER_GUID =
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };

//
// Functions needed
#ifdef UNICODE
#define lstrchr     wcschr
#define lstrncmpi   _wcsnicmp
#else
#define lstrchr     strchr
#define lstrncmpi   _strnicmp
#endif

#define USB_SIGNATURE   0x89AB


typedef struct USBMON_PORT_INFO_DEF {

    DWORD       dwSignature;
    struct USBMON_PORT_INFO_DEF *pNext;
    DWORD       cRef;
    DWORD       dwFlags;
    DWORD       dwDeviceFlags;
    DWORD       dwJobId;
    HANDLE      hDeviceHandle;
    HANDLE      hPrinter;
    LPBYTE      pWriteBuffer;
    //
    // dwBufferSize     : size of buffer
    // dwDataSize       : size of data in buffer
    //                      (could be smaller than dwBufferSize)
    // dwDataCompleted  : size of data sent and acknowledged
    // dwScheduledData  : size of data we have scheduled using WriteFile
    //
    DWORD       dwBufferSize, dwDataSize, dwDataCompleted, dwDataScheduled;
    OVERLAPPED  Ov;
    CRITICAL_SECTION    CriticalSection;
    DWORD       ReadTimeoutMultiplier;
    DWORD       ReadTimeoutConstant;
    DWORD       WriteTimeoutMultiplier;
    DWORD       WriteTimeoutConstant;
    TCHAR       szPortName[MAX_PORT_LEN];
    TCHAR       szPortDescription[MAX_PORT_DESC_LEN];
    TCHAR       szDevicePath[256];
} USBMON_PORT_INFO, *PUSBMON_PORT_INFO;


#define     USBMON_STARTDOC             0x00000001


typedef struct  PORT_UPDATE_INFO_DEF {
    struct  PORT_UPDATE_INFO_DEF   *pNext;
    TCHAR                           szPortName[MAX_PORT_LEN];
    HKEY                            hKey;
    BOOL                            bActive;
} PORT_UPDATE_INFO, *PPORT_UPDATE_INFO;

typedef struct  USELESS_PORT_INFO_DEF {

    struct USELESS_PORT_INFO_DEF   *pNext;
    TCHAR                           szDevicePath[256];
} USELESS_PORT_INFO, *PUSELESS_PORT_INFO;

typedef struct  USBMON_MONITOR_INFO_DEF {

    DWORD                   dwLastEnumIndex, dwEnumPortCount,
                            dwPortCount, dwUselessPortCount;
    PUSBMON_PORT_INFO       pPortInfo;
    PUSELESS_PORT_INFO      pJunkList;
    CRITICAL_SECTION        EnumPortsCS, BackThreadCS;
} USBMON_MONITOR_INFO, *PUSBMON_MONITOR_INFO;


typedef struct BACKGROUND_THREAD_DEF {

        PUSBMON_MONITOR_INFO    pMonitorInfo;
        PPORT_UPDATE_INFO       pPortUpdateList;
        HANDLE                  hWaitToStart;
} BACKGROUND_THREAD_DATA, PBACKGROUND_THREAD_DATA;

extern  USBMON_MONITOR_INFO gUsbmonInfo;

PUSBMON_PORT_INFO
FindPort(
    PUSBMON_MONITOR_INFO    pMonitorInfo,
    LPTSTR                  pszPortName,
    PUSBMON_PORT_INFO      *pPrev
    );

BOOL
WINAPI
USBMON_EnumPorts(
    LPTSTR      pszName,
    DWORD       dwLevel,
    LPBYTE      pPorts,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\local.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:



Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT


LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)


/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define LcmDBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define LcmDBGMSG
#endif

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\localmon.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    localmon.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:


    Adina Trufinescu (adinatru) 07-December 1998-2003
    Commented LocalMonInitializePrintMonitor2 that used to be called by InitializePrintMonitor2;
    Changed back to the old interface - InitializePrintMonitor which initialize LcmhMonitor to a MONITOREX structure.
    MONITOREX structure are filled with old style functions(LcmxNAME) that (don't takes hMonitor as parameter).This functions calls
    LcmNAME functions passing LcmhMonitor as hMonitor parameter.

// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "lmon.h"
#include "irda.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
//MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN, DBG_ERROR);
#endif
// @@END_DDKSPLIT

HANDLE LcmhMonitor;
HANDLE LcmhInst;
CRITICAL_SECTION LcmSpoolerSection;
DWORD LocalmonDebug;

DWORD LcmPortInfo1Strings[]={FIELD_OFFSET(PORT_INFO_1, pName),
                          (DWORD)-1};

DWORD LcmPortInfo2Strings[]={FIELD_OFFSET(PORT_INFO_2, pPortName),
                          FIELD_OFFSET(PORT_INFO_2, pMonitorName),
                          FIELD_OFFSET(PORT_INFO_2, pDescription),
                          (DWORD)-1};

WCHAR szPorts[]   = L"ports";
WCHAR gszPorts[]  = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Ports";
WCHAR szPortsEx[] = L"portsex"; /* Extra ports values */
WCHAR szFILE[]    = L"FILE:";
WCHAR szLcmCOM[]     = L"COM";
WCHAR szLcmLPT[]     = L"LPT";
WCHAR szIRDA[]    = L"IR";

extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];

BOOL
LocalMonInit(HANDLE hModule)
{
    LcmhInst = hModule;

    InitializeCriticalSection(&LcmSpoolerSection);

    return TRUE;
}



BOOL
LcmEnumPorts(
    HANDLE hMonitor,
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    PINIPORT pIniPort;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   LastError=0;

    LcmEnterSplSem();

    cb=0;

    pIniPort = pIniLocalMon->pIniPort;

    CheckAndAddIrdaPort(pIniLocalMon);

    while (pIniPort) {

        if ( !(pIniPort->Status & PP_FILEPORT) ) {

            cb+=GetPortSize(pIniPort, Level);
        }
        pIniPort=pIniPort->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pIniLocalMon->pIniPort;
        while (pIniPort) {

            if (!(pIniPort->Status & PP_FILEPORT)) {

                pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);

                if( !pEnd ){
                    LastError = GetLastError();
                    break;
                }

                switch (Level) {
                case 1:
                    pPorts+=sizeof(PORT_INFO_1);
                    break;
                case 2:
                    pPorts+=sizeof(PORT_INFO_2);
                    break;
                default:
                    DBGMSG(DBG_ERROR,
                           ("EnumPorts: invalid level %d", Level));
                    LastError = ERROR_INVALID_LEVEL;
                    goto Cleanup;
                }
                (*pcReturned)++;
            }
            pIniPort=pIniPort->pNext;
        }

    } else

        LastError = ERROR_INSUFFICIENT_BUFFER;

Cleanup:
   LcmLeaveSplSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;

    } else

        return TRUE;
}


BOOL
LcmxEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    return LcmEnumPorts(LcmhMonitor, pName, Level, pPorts, cbBuf, pcbNeeded, pcReturned);
}

BOOL
LcmOpenPort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    PINILOCALMON    pIniLocalMon = (PINILOCALMON)hMonitor;
    PINIPORT        pIniPort;
    BOOL            bRet = FALSE;

    LcmEnterSplSem();

    if ( IS_FILE_PORT(pName) ) {

        //
        // We will always create multiple file port
        // entries, so that the spooler can print
        // to multiple files.
        //
        DBGMSG(DBG_TRACE, ("Creating a new pIniPort for %ws\n", pName));
        pIniPort = LcmCreatePortEntry( pIniLocalMon, pName );
        if ( !pIniPort )
            goto Done;

        pIniPort->Status |= PP_FILEPORT;
        *pHandle = pIniPort;
        bRet = TRUE;
        goto Done;
    }

    pIniPort = FindPort(pIniLocalMon, pName);

    if ( !pIniPort )
        goto Done;

    //
    // For LPT ports language monitors could do reads outside Start/End doc
    // port to do bidi even when there are no jobs printing. So we do a
    // CreateFile and keep the handle open all the time.
    //
    // But for COM ports you could have multiple devices attached to a COM
    // port (ex. a printer and some other device with a switch)
    // To be able to use the other device they write a utility which will
    // do a net stop serial and then use the other device. To be able to
    // stop the serial service spooler should not have a handle to the port.
    // So we need to keep handle to COM port open only when there is a job
    // printing
    //
    //
    if ( IS_COM_PORT(pName) ) {

        bRet = TRUE;
        goto Done;
    }

    //
    // If it is not a port redirected we are done (succeed the call)
    //
    if ( ValidateDosDevicePort(pIniPort) ) {

        bRet = TRUE;

        //
        // If it isn't a true dosdevice port (ex. net use lpt1 \\<server>\printer)
        // then we need to do CreateFile and CloseHandle per job so that
        // StartDoc/EndDoc is issued properly for the remote printer
        //
        if ( (pIniPort->Status & PP_DOSDEVPORT) &&
            !(pIniPort->Status & PP_COMM_PORT) ) {

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;

            (VOID)RemoveDosDeviceDefinition(pIniPort);
        }
    }

Done:
    if ( !bRet && pIniPort && (pIniPort->Status & PP_FILEPORT) )
        DeletePortNode(pIniLocalMon, pIniPort);

    if ( bRet )
        *pHandle = pIniPort;

    LcmLeaveSplSem();
    return bRet;
}

BOOL
LcmxOpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    return LcmOpenPort(LcmhMonitor, pName, pHandle);
}

BOOL
LcmStartDocPort(
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    PDOC_INFO_1 pDocInfo1 = (PDOC_INFO_1)pDocInfo;
    DWORD Error = 0;

    DBGMSG(DBG_TRACE, ("StartDocPort(%08x, %ws, %d, %d, %08x)\n",
                       hPort, pPrinterName, JobId, Level, pDocInfo));

    if (pIniPort->Status & PP_STARTDOC) {
        return TRUE;
    }

    LcmEnterSplSem();
    pIniPort->Status |= PP_STARTDOC;
    LcmLeaveSplSem();

    pIniPort->hPrinter = NULL;
    pIniPort->pPrinterName = AllocSplStr(pPrinterName);

    if (pIniPort->pPrinterName) {

        if (OpenPrinter(pPrinterName, &pIniPort->hPrinter, NULL)) {

            pIniPort->JobId = JobId;

            //
            // For COMx port we need to validates dos device now since
            // we do not do it during OpenPort
            //
            if ( IS_COM_PORT(pIniPort->pName) &&
                 !ValidateDosDevicePort(pIniPort) ) {

                goto Fail;
            }

            if ( IS_FILE_PORT(pIniPort->pName) ) {

                HANDLE hFile = INVALID_HANDLE_VALUE;

                if (pDocInfo1                 &&
                    pDocInfo1->pOutputFile    &&
                    pDocInfo1->pOutputFile[0]){

                    hFile = CreateFile( pDocInfo1->pOutputFile,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                         NULL );

                    DBGMSG(DBG_TRACE,
                           ("Print to file and the handle is %x\n", hFile));

                }
                else
                {
                    Error = ERROR_INVALID_PARAMETER;
                }

                if (hFile != INVALID_HANDLE_VALUE)
                    SetEndOfFile(hFile);

                pIniPort->hFile = hFile;
            } else if ( IS_IRDA_PORT(pIniPort->pName) ) {

                if ( !IrdaStartDocPort(pIniPort) )
                    goto Fail;
            } else if ( !(pIniPort->Status & PP_DOSDEVPORT) ) {

                //
                // For non dosdevices CreateFile on the name of the port
                //
                pIniPort->hFile = CreateFile(pIniPort->pName,
                                             GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL  |
                                             FILE_FLAG_SEQUENTIAL_SCAN,
                                             NULL);

                if ( pIniPort->hFile != INVALID_HANDLE_VALUE )
                    SetEndOfFile(pIniPort->hFile);

            } else if ( !IS_COM_PORT(pIniPort->pName) ) {

                if ( !FixupDosDeviceDefinition(pIniPort) )
                    goto Fail;
            }
        }
    } // end of if (pIniPort->pPrinterName)

    if (pIniPort->hFile == INVALID_HANDLE_VALUE)
        goto Fail;

    return TRUE;


Fail:
    SPLASSERT(pIniPort->hFile == INVALID_HANDLE_VALUE);

    LcmEnterSplSem();
    pIniPort->Status &= ~PP_STARTDOC;
    LcmLeaveSplSem();

    if (pIniPort->hPrinter) {
        ClosePrinter(pIniPort->hPrinter);
    }

    if (pIniPort->pPrinterName) {
        FreeSplStr(pIniPort->pPrinterName);
    }

    if (Error)
        SetLastError(Error);

    return FALSE;
}


BOOL
LcmWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE, ("WritePort(%08x, %08x, %d)\n", hPort, pBuffer, cbBuf));

    if ( IS_IRDA_PORT(pIniPort->pName) )
        rc = IrdaWritePort(pIniPort, pBuffer, cbBuf, pcbWritten);
    else if ( !pIniPort->hFile || pIniPort->hFile == INVALID_HANDLE_VALUE ) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    } else {

        rc = WriteFile(pIniPort->hFile, pBuffer, cbBuf, pcbWritten, NULL);
        if ( rc && *pcbWritten == 0 ) {

            SetLastError(ERROR_TIMEOUT);
            rc = FALSE;
        }
    }

    DBGMSG(DBG_TRACE, ("WritePort returns %d; %d bytes written\n", rc, *pcbWritten));

    return rc;
}


BOOL
LcmReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuf,
    LPDWORD pcbRead)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE, ("ReadPort(%08x, %08x, %d)\n", hPort, pBuffer, cbBuf));

    if ( !pIniPort->hFile                           ||
         pIniPort->hFile == INVALID_HANDLE_VALUE    ||
         !(pIniPort->Status & PP_COMM_PORT) ) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    rc = ReadFile(pIniPort->hFile, pBuffer, cbBuf, pcbRead, NULL);

    DBGMSG(DBG_TRACE, ("ReadPort returns %d; %d bytes read\n", rc, *pcbRead));

    return rc;
}

BOOL
LcmEndDocPort(
    HANDLE   hPort
    )
{
    PINIPORT    pIniPort = (PINIPORT)hPort;

    DBGMSG(DBG_TRACE, ("EndDocPort(%08x)\n", hPort));

    if (!(pIniPort->Status & PP_STARTDOC)) {
        return TRUE;
    }

    // The flush here is done to make sure any cached IO's get written
    // before the handle is closed.   This is particularly a problem
    // for Intelligent buffered serial devices

    FlushFileBuffers(pIniPort->hFile);

    //
    // For any ports other than real LPT ports we open during StartDocPort
    // and close it during EndDocPort
    //
    if ( !(pIniPort->Status & PP_COMM_PORT) || IS_COM_PORT(pIniPort->pName) ) {

        if ( IS_IRDA_PORT(pIniPort->pName) ) {

            IrdaEndDocPort(pIniPort);
        } else {

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;

            if ( pIniPort->Status & PP_DOSDEVPORT ) {

                (VOID)RemoveDosDeviceDefinition(pIniPort);
            }

            if ( IS_COM_PORT(pIniPort->pName) ) {

                pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);
                FreeSplStr(pIniPort->pDeviceName);
                pIniPort->pDeviceName = NULL;
            }
        }
    }

    SetJob(pIniPort->hPrinter, pIniPort->JobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);

    ClosePrinter(pIniPort->hPrinter);

    FreeSplStr(pIniPort->pPrinterName);

    //
    // Startdoc no longer active.
    //
    pIniPort->Status &= ~PP_STARTDOC;

    return TRUE;
}

BOOL
LcmClosePort(
    HANDLE  hPort
    )
{
    PINIPORT pIniPort = (PINIPORT)hPort;

    FreeSplStr(pIniPort->pDeviceName);
    pIniPort->pDeviceName = NULL;

    if (pIniPort->Status & PP_FILEPORT) {

        LcmEnterSplSem();
        DeletePortNode(pIniPort->pIniLocalMon, pIniPort);
        LcmLeaveSplSem();
    } else if ( pIniPort->Status & PP_COMM_PORT ) {

        (VOID) RemoveDosDeviceDefinition(pIniPort);
        if ( pIniPort->hFile != INVALID_HANDLE_VALUE ) {

            // @@BEGIN_DDKSPLIT
            if ( pIniPort->hNotify ) {

                SplUnregisterForDeviceEvents(pIniPort->hNotify);
                pIniPort->hNotify = NULL;
            }
            // @@END_DDKSPLIT

            CloseHandle(pIniPort->hFile);
            pIniPort->hFile = INVALID_HANDLE_VALUE;
        }
        pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);
    }

    return TRUE;
}


BOOL
LcmAddPortEx(
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    LPWSTR pPortName;
    DWORD  Error;
    LPPORT_INFO_1 pPortInfo1;
    LPPORT_INFO_FF pPortInfoFF;

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (LPPORT_INFO_FF)pBuffer;
        pPortName = pPortInfoFF->pName;
        break;

    case 1:
        pPortInfo1 =  (LPPORT_INFO_1)pBuffer;
        pPortName = pPortInfo1->pName;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return(FALSE);
    }
    if (!pPortName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (PortExists(pName, pPortName, &Error)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (Error != NO_ERROR) {
        SetLastError(Error);
        return(FALSE);
    }
    if (!LcmCreatePortEntry(pIniLocalMon, pPortName)) {
        return(FALSE);
    }
    if (!WriteProfileString(szPorts, pPortName, L"")) {
        LcmDeletePortEntry( pIniLocalMon, pPortName );
        return(FALSE);
    }
    return TRUE;
}

BOOL
LcmxAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    return LcmAddPortEx(LcmhMonitor, pName, Level, pBuffer, pMonitorName);
}

BOOL
LcmGetPrinterDataFromPort(
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned)
{
    PINIPORT    pIniPort = (PINIPORT)hPort;
    BOOL    rc;

    DBGMSG(DBG_TRACE,
           ("GetPrinterDataFromPort(%08x, %d, %ws, %ws, %d, ",
           hPort, ControlID, pValueName, lpInBuffer, cbInBuffer));

    if ( !ControlID                                 ||
         !pIniPort->hFile                           ||
         pIniPort->hFile == INVALID_HANDLE_VALUE    ||
         !(pIniPort->Status & PP_DOSDEVPORT) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    rc = DeviceIoControl(pIniPort->hFile,
                         ControlID,
                         lpInBuffer,
                         cbInBuffer,
                         lpOutBuffer,
                         cbOutBuffer,
                         lpcbReturned,
                         NULL);

    DBGMSG(DBG_TRACE,
           ("%ws, %d, %d)\n", lpOutBuffer, cbOutBuffer, lpcbReturned));

    return rc;
}

BOOL
LcmSetPortTimeOuts(
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved)    // must be set to 0
{
    PINIPORT        pIniPort = (PINIPORT)hPort;
    COMMTIMEOUTS    cto;

    if (reserved != 0)
        return FALSE;

    if ( !(pIniPort->Status & PP_DOSDEVPORT) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( GetCommTimeouts(pIniPort->hFile, &cto) )
    {
        cto.ReadTotalTimeoutConstant = lpCTO->ReadTotalTimeoutConstant;
        cto.ReadIntervalTimeout = lpCTO->ReadIntervalTimeout;
        return SetCommTimeouts(pIniPort->hFile, &cto);
    }

    return FALSE;
}

VOID
LcmShutdown(
    HANDLE hMonitor
    )
{
    PINIPORT pIniPort;
    PINIPORT pIniPortNext;
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;

    //
    // Delete the ports, then delete the LOCALMONITOR.
    //
    for( pIniPort = pIniLocalMon->pIniPort; pIniPort; pIniPort = pIniPortNext ){
        pIniPortNext = pIniPort->pNext;
        FreeSplMem( pIniPort );
    }

    FreeSplMem( pIniLocalMon );
}


BOOL
LcmxXcvOpenPort(
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    return LcmXcvOpenPort(LcmhMonitor, pszObject, GrantedAccess, phXcv);
}

// @@BEGIN_DDKSPLIT
#ifdef _SPL_CLUST
// @@END_DDKSPLIT

MONITOR2 Monitor2 = {
    sizeof(MONITOR2),
    LcmEnumPorts,
    LcmOpenPort,
    NULL,           // OpenPortEx is not supported
    LcmStartDocPort,
    LcmWritePort,
    LcmReadPort,
    LcmEndDocPort,
    LcmClosePort,
    NULL,           // AddPort is not supported
    LcmAddPortEx,
    NULL,           // ConfigurePort is not supported
    NULL,           // DeletePort is not supported
    LcmGetPrinterDataFromPort,
    LcmSetPortTimeOuts,
    LcmXcvOpenPort,
    LcmXcvDataPort,
    LcmXcvClosePort,
    LcmShutdown
};


LPMONITOR2
LocalMonInitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
    )
{
    LPWSTR   pPortTmp;
    DWORD    dwCharCount=1024, rc, i, j;
    PINILOCALMON pIniLocalMon = NULL;
    LPWSTR   pPorts = NULL;

    // @@BEGIN_DDKSPLIT
    //
    // If we are clustered (e.g., bLocal is FALSE), then we don't want to
    // initialize, since local ports can't be used with clustering.
    //
    // @@END_DDKSPLIT
    if( !pMonitorInit->bLocal ){
        return NULL;
    }

    do {
        FreeSplMem((LPVOID)pPorts);

        dwCharCount *= 2;
        pPorts = (LPWSTR) AllocSplMem(dwCharCount*sizeof(WCHAR));
        if ( !pPorts ) {

            DBGMSG(DBG_ERROR,
                   ("Failed to alloc %d characters for ports\n", dwCharCount));
            goto Fail;
        }

        rc = GetProfileString(szPorts, NULL, szNULL, pPorts, dwCharCount);
        //
        // GetProfileString will does not return the proper character count for long port names.
        // fail the call if the port list length exceeds 1mb
        //
        if ( !rc || dwCharCount >= 1024*1024 ) {

            DBGMSG(DBG_ERROR,
                   ("GetProfilesString failed with %d\n", GetLastError()));
            goto Fail;
        }

    } while ( rc >= dwCharCount - 2 );

    pIniLocalMon = (PINILOCALMON)AllocSplMem( sizeof( INILOCALMON ));

    if( !pIniLocalMon ){
        goto Fail;
    }

    pIniLocalMon->signature = ILM_SIGNATURE;
    pIniLocalMon->pMonitorInit = pMonitorInit;

    //
    // dwCharCount is now the count of return buffer, not including
    // the NULL terminator.  When we are past pPorts[rc], then
    // we have parsed the entire string.
    //
    dwCharCount = rc;

   LcmEnterSplSem();

    //
    // We now have all the ports
    //
    for( j = 0; j <= dwCharCount; j += rc + 1 ){

        pPortTmp = pPorts + j;

        rc = wcslen(pPortTmp);

        if( !rc ){
            continue;
        }

        if (!_wcsnicmp(pPortTmp, L"Ne", 2)) {

            i = 2;
            //
            // For Ne-ports
            //
            if ( rc > 2 && pPortTmp[2] == L'-' )
                ++i;
            for ( ; i < rc - 1 && iswdigit(pPortTmp[i]) ; ++i )
            ;

            if ( i == rc - 1 && pPortTmp[rc-1] == L':' ) {
                continue;
            }
        }

        LcmCreatePortEntry(pIniLocalMon, pPortTmp);
    }

    FreeSplMem(pPorts);

    LcmLeaveSplSem();

    CheckAndAddIrdaPort(pIniLocalMon);

    *phMonitor = (HANDLE)pIniLocalMon;

    return &Monitor2;

Fail:

    FreeSplMem( pPorts );
    FreeSplMem( pIniLocalMon );

    return NULL;
}

// @@BEGIN_DDKSPLIT
#endif

MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        LcmxEnumPorts,
        LcmxOpenPort,
        NULL,
        LcmStartDocPort,
        LcmWritePort,
        LcmReadPort,
        LcmEndDocPort,
        LcmClosePort,
        NULL,                           // AddPort not supported
        LcmxAddPortEx,
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        LcmGetPrinterDataFromPort,
        LcmSetPortTimeOuts,              // SetPortTimeOuts not supported
        LcmxXcvOpenPort,
        LcmXcvDataPort,
        LcmXcvClosePort
    }
};

DWORD
GetPortStrings(
    PWSTR   *ppPorts,
    PDWORD  pdwUsed
    )
{
    DWORD   sRetval  = ERROR_INVALID_PARAMETER;
    HKEY    hPortKey = NULL;

    if (ppPorts && pdwUsed)
    {
        sRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, gszPorts, 0, KEY_READ, &hPortKey);

        if (sRetval == ERROR_SUCCESS)
        {
            DWORD dwcValues = 0;
            DWORD dwMaxValueName = 0;

            sRetval = RegQueryInfoKey(hPortKey, NULL, NULL, NULL, NULL, NULL, NULL, &dwcValues, &dwMaxValueName, NULL, NULL, NULL);

            if (sRetval == ERROR_SUCCESS)
            {
                PWSTR pPorts = NULL;
                DWORD cbMaxMemNeeded = ((dwcValues * (dwMaxValueName + 1) + 1) * sizeof(WCHAR));

                pPorts = (LPWSTR)AllocSplMem(cbMaxMemNeeded);

                if (pPorts)
                {
                    DWORD sTempRetval = ERROR_SUCCESS;
                    INT   CharsAvail = cbMaxMemNeeded/sizeof(WCHAR);
                    INT   cIndex = 0;
                    PWSTR pPort = NULL;
                    DWORD dwCurLen = 0;


                    for (pPort = pPorts; (sTempRetval == ERROR_SUCCESS) && (CharsAvail > 0); cIndex++)
                    {
                        if (dwCurLen)
                        {
                            dwCurLen++;
                            CharsAvail -= dwCurLen;
                            pPort += dwCurLen;
                        }

                        dwCurLen = dwMaxValueName + 1;
                        sTempRetval = RegEnumValue(hPortKey, cIndex, pPort, &dwCurLen, NULL, NULL, NULL, NULL);
                    }

                    if ((sTempRetval == ERROR_NO_MORE_ITEMS) && (CharsAvail > 0))
                    {
                        *pPort = L'\0';
                        *ppPorts = pPorts;
                        CharsAvail--;
                        *pdwUsed = (cbMaxMemNeeded / sizeof(WCHAR)) - CharsAvail;
                    }
                    else
                    {
                        sRetval = sTempRetval;

                        if (sRetval == ERROR_SUCCESS)
                        {
                            sRetval = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }
                else
                {
                    sRetval = GetLastError();
                }
            }

            RegCloseKey(hPortKey);
        }
    }

    return sRetval;
}


LPMONITOREX
WINAPI
InitializePrintMonitor(
    IN     LPTSTR      pszRegistryRoot
)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    Pointer to monitor function table

--*/
{
    LPWSTR   pPortTmp;
    DWORD    dwCharCount=0, rc, i;
    DWORD    sRetval = ERROR_SUCCESS;
    PINILOCALMON pIniLocalMon = NULL;
    LPWSTR   pPorts = NULL;

    if ( !pszRegistryRoot || !*pszRegistryRoot ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (sRetval = GetPortStrings(&pPorts, &dwCharCount) != ERROR_SUCCESS)
    {
        SetLastError(sRetval);
        goto Fail;
    }

    pIniLocalMon = (PINILOCALMON)AllocSplMem( sizeof( INILOCALMON ));

    if( !pIniLocalMon ){
        goto Fail;
    }

    pIniLocalMon->signature = ILM_SIGNATURE;


   LcmEnterSplSem();

    //
    // We now have all the ports
    //
    for(pPortTmp = pPorts; pPortTmp && *pPortTmp; pPortTmp += rc + 1){

        rc = wcslen(pPortTmp);

        if (!_wcsnicmp(pPortTmp, L"Ne", 2)) {

            i = 2;

            //
            // For Ne- ports
            //
            if ( rc > 2 && pPortTmp[2] == L'-' )
                ++i;
            for ( ; i < rc - 1 && iswdigit(pPortTmp[i]) ; ++i )
            ;

            if ( i == rc - 1 && pPortTmp[rc-1] == L':' ) {
                continue;
            }
        }

        LcmCreatePortEntry(pIniLocalMon, pPortTmp);
    }

    FreeSplMem(pPorts);

    LcmLeaveSplSem();

    CheckAndAddIrdaPort(pIniLocalMon);

    LcmhMonitor = (HANDLE)pIniLocalMon;

    return &MonitorEx;

Fail:

    FreeSplMem( pPorts );
    FreeSplMem( pIniLocalMon );

    return NULL;

}

#if 0

//
// Since the DDK is a standalone DLL, we need a DLL init routine.
// However, the NT version is a library and we call LocamonInit
// directly, so this isn't needed.
//

// @@END_DDKSPLIT

VOID
LocalMonCleanUp(
    VOID
    )
{
    DeleteCriticalSection(&LcmSpoolerSection);
}

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        LocalMonInit(hModule);
        DisableThreadLibraryCalls(hModule);
        return TRUE;

    case DLL_PROCESS_DETACH:

        LocalMonCleanUp();
        return TRUE;
    }

    UNREFERENCED_PARAMETER(lpRes);

    return TRUE;
}

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localmon.rc
//
#define IDS_LOCALMONITOR               500
#define IDS_COULD_NOT_OPEN_FILE        504
#define IDS_UNKNOWN_ERROR              505
#define IDS_OVERWRITE_EXISTING_FILE    506
#define IDS_LOCALMONITORNAME           507

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        600
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           603
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\localmon.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    localmon.h

// @@BEGIN_DDKSPLIT
Abstract:

Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#else
// @@END_DDKSPLIT


LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)
#define COUNTOF(x)                (sizeof(x)/sizeof *(x))


/* DEBUGGING:
 */

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the LcmDBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with LcmDBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     LcmDBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define LcmDBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define LcmDBGMSG
#endif
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
);

BOOL
PortIsValid(
    LPWSTR pPortName
);

extern HANDLE   LcmhInst;
extern CRITICAL_SECTION    LcmSpoolerSection;
extern DWORD    LcmPortInfo1Strings[];
extern DWORD    LcmPortInfo2Strings[];
extern PINIPORT pIniFirstPort;
extern PINIXCVPORT pIniFirstXcvPort;

extern WCHAR szNULL[];
extern WCHAR szPorts[];
extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];
extern WCHAR szLcmDeviceNameHeader[];
extern WCHAR szFILE[];
extern WCHAR szLcmCOM[];
extern WCHAR szLcmLPT[];
extern WCHAR szIRDA[];

#define MSG_ERROR           MB_OK | MB_ICONSTOP
#define MSG_WARNING         MB_OK | MB_ICONEXCLAMATION
#define MSG_YESNO           MB_YESNO | MB_ICONQUESTION
#define MSG_INFORMATION     MB_OK | MB_ICONINFORMATION
#define MSG_CONFIRMATION    MB_OKCANCEL | MB_ICONEXCLAMATION

#define TIMEOUT_MIN         1
#define TIMEOUT_MAX         999999
#define TIMEOUT_STRING_MAX  6

#define WITHINRANGE( val, lo, hi ) \
    ( ( val <= hi ) && ( val >= lo ) )


#define IS_FILE_PORT(pName) \
    !_wcsicmp( pName, szFILE )

#define IS_IRDA_PORT(pName) \
    !_wcsicmp( pName, szIRDA )

#define IS_COM_PORT(pName) \
    IsCOMPort( pName )

#define IS_LPT_PORT(pName) \
    IsLPTPort( pName )

BOOL
IsCOMPort(
    LPWSTR pPort
);

BOOL
IsLPTPort(
    LPWSTR pPort
);


VOID
LcmEnterSplSem(
   VOID
);

VOID
LcmLeaveSplSem(
   VOID
);

VOID
LcmSplOutSem(
   VOID
);

PINIENTRY
LcmFindName(
   PINIENTRY pIniKey,
   LPWSTR pName
);

PINIENTRY
LcmFindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR lpName
);

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
);

INT
LcmMessage(
    HWND hwnd,
    DWORD Type,
    INT CaptionID,
    INT TextID,
    ...
);

DWORD
ReportError(
    HWND  hwndParent,
    DWORD idTitle,
    DWORD idDefaultError
);

VOID
LcmRemoveColon(
    LPWSTR  pName
);


PINIPORT
LcmCreatePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
);

BOOL
LcmDeletePortEntry(
    PINILOCALMON pIniLocalMon,
    LPWSTR   pPortName
);


PINIXCVPORT
CreateXcvPortEntry(
    PINILOCALMON pIniLocalMon,
    LPCWSTR pszName,
    ACCESS_MASK GrantedAccess
);

BOOL
DeleteXcvPortEntry(
    PINIXCVPORT  pIniXcvPort
);


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
);

BOOL
LocalAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    );

BOOL
MakeLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR *ppOldNtDeviceName,
    LPWSTR  pNewNtDeviceName,
    SECURITY_DESCRIPTOR *pSecurityDescriptor
);

BOOL
RemoveLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR  *ppOldNtDeviceName
);


DWORD
ConfigureLPTPortCommandOK(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);



DWORD
GetPortSize(
    PINIPORT pIniPort,
    DWORD   Level
);

LPBYTE
CopyIniPortToPort(
    PINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
);

BOOL
ValidateDosDevicePort(
    PINIPORT    pIniPort
    );

BOOL
RemoveDosDeviceDefinition(
    PINIPORT    pIniPort
    );

BOOL
DeletePortNode(
    PINILOCALMON pIniLocalMon,
    PINIPORT  pIniPort
    );

BOOL
FixupDosDeviceDefinition(
    PINIPORT    pIniPort
    );

DWORD
LcmXcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

BOOL
LcmXcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

BOOL
LcmXcvClosePort(
    HANDLE  hXcv
    );

DWORD
WINAPIV
StrNCatBuffW(
    IN      PWSTR       pszBuffer,
    IN      UINT        cchBuffer,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\setlink.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation

Module Name:

    setlink.c

Abstract:

    Utility to display or change the value of a symbolic link.

// @@BEGIN_DDKSPLIT
Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


BOOL
MakeLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR *ppOldNtDeviceName,
    LPWSTR  pNewNtDeviceName,
    SECURITY_DESCRIPTOR *pSecurityDescriptor
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING OldDosDeviceName;
    UNICODE_STRING NewDosDeviceName;
    UNICODE_STRING PreviousNtDeviceName;
    UNICODE_STRING NewNtDeviceName;
    HANDLE  Handle, Handle1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR   Buffer[MAX_PATH];

    RtlInitUnicodeString( &OldDosDeviceName, pOldDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &OldDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );
    
    // Try to open \DosDevices\LPT1
 
    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_WARNING, ("Symbolic link %ws does not exist\n", pOldDosDeviceName ));
        return FALSE;

    }

    memset(Buffer, 0, sizeof(Buffer));

    PreviousNtDeviceName.Length = 0;
    PreviousNtDeviceName.MaximumLength = sizeof( Buffer );
    PreviousNtDeviceName.Buffer = Buffer;

    // Get \Device\Parallel0 into Buffer

    Status = NtQuerySymbolicLinkObject( Handle,
                                        &PreviousNtDeviceName,
                                        NULL );

    if (!NT_SUCCESS( Status )) {
        SetLastError(Status);
        NtClose(Handle);
        return FALSE;
    }

    *ppOldNtDeviceName = AllocSplStr(Buffer);

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    ObjectAttributes.Attributes |= OBJ_PERMANENT;
    RtlInitUnicodeString( &NewNtDeviceName, pNewNtDeviceName );

    // Make \DosDevices\LPT1 point to \Device\NamedPipe\Spooler\LPT1

    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &NewNtDeviceName );

    if (!NT_SUCCESS( Status )) {
        DBGMSG( DBG_WARNING, ("Error creating symbolic link %ws => %ws\n",
                 pOldDosDeviceName,
                 pNewNtDeviceName ));
        DBGMSG( DBG_WARNING, ("Error status was:  %X\n", Status ));
        return FALSE;
    } else {
        NtClose( Handle );
    }

    RtlInitUnicodeString( &NewDosDeviceName, pNewDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &NewDosDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                (HANDLE) NULL,
                                pSecurityDescriptor );

    // Finally make \DosDevices\NONSPOOLED_LPT1 => \Device\Parallel0

    Status = NtCreateSymbolicLinkObject(&Handle,
                                        SYMBOLIC_LINK_ALL_ACCESS,
                                        &ObjectAttributes,
                                        &PreviousNtDeviceName);

    if (NT_SUCCESS(Status))
        NtClose(Handle);

    return TRUE;
}

BOOL
RemoveLink(
    LPWSTR  pOldDosDeviceName,
    LPWSTR  pNewDosDeviceName,
    LPWSTR  *ppOldNtDeviceName
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING OldDosDeviceName;
    UNICODE_STRING NewDosDeviceName;
    UNICODE_STRING PreviousNtDeviceName;
    UNICODE_STRING OldNtDeviceName;
    HANDLE  Handle, Handle1;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString( &NewDosDeviceName, pNewDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &NewDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    // Try to open \DosDevices\NONSPOOLED_LPT1

    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_ERROR, ("Symbolic link %ws does not exist\n", pNewDosDeviceName ));
        return FALSE;

    }

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    RtlInitUnicodeString( &OldDosDeviceName, pOldDosDeviceName);

    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &OldDosDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    // Try to open \DosDevices\LPT1

    Status = NtOpenSymbolicLinkObject( &Handle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {

        DBGMSG( DBG_ERROR, ("Symbolic link %ws does not exist\n", pOldDosDeviceName ));
        return FALSE;
    }

    // Mark this object as temporary so when we close it it will be deleted

    Status = NtMakeTemporaryObject( Handle );
    if (NT_SUCCESS( Status )) {
        NtClose( Handle );
    }

    ObjectAttributes.Attributes |= OBJ_PERMANENT;

    RtlInitUnicodeString( &OldNtDeviceName, *ppOldNtDeviceName );

    // Make \DosDevices\LPT1 point to \Device\Parallel0

    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &OldNtDeviceName );

    if (!NT_SUCCESS( Status )) {
        DBGMSG( DBG_WARNING, ("Error creating symbolic link %ws => %ws\n",
                 pOldDosDeviceName,
                 *ppOldNtDeviceName ));
        DBGMSG( DBG_WARNING, ("Error status was:  %X\n", Status ));
    } else {
        NtClose( Handle );
    }

    FreeSplStr(*ppOldNtDeviceName);

    *ppOldNtDeviceName = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\precomp.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

// @@BEGIN_DDKSPLIT
Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

// @@BEGIN_DDKSPLIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// @@END_DDKSPLIT

                      
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winsock2.h>
#include <wchar.h>
#include <stddef.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <strsafe.h>

#include "resource.h"
#include "spltypes.h"
#include "localmon.h"

// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT

#undef DBGMSG
#define DBGMSG(x,y)
#undef SPLASSERT
#define SPLASSERT(x) 

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\util.c ===
/*++

Copyright (c) 1990-2003 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

// @@BEGIN_DDKSPLIT
Abstract:

    This module provides all the utility functions for localmon.

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop


//
// These globals are needed so that AddPort can call
// SPOOLSS!EnumPorts to see whether the port to be added
// already exists.
// @@BEGIN_DDKSPLIT
// They will be initialized the first time AddPort is called.
//
// !! LATER !!
//
// This is common code. move PortExists into the router.
//
// @@END_DDKSPLIT

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

VOID
LcmRemoveColon(
    LPWSTR  pName)
{
    DWORD   Length;

    Length = wcslen(pName);

    if (pName[Length-1] == L':')
        pName[Length-1] = 0;
}


BOOL
IsCOMPort(
    LPWSTR pPort
)
{
    //
    // Must begin with szLcmCOM
    //
    if ( _wcsnicmp( pPort, szLcmCOM, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

BOOL
IsLPTPort(
    LPWSTR pPort
)
{
    //
    // Must begin with szLcmLPT
    //
    if ( _wcsnicmp( pPort, szLcmLPT, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}




#define NEXTVAL(pch)                    \
    while( *pch && ( *pch != L',' ) )    \
        pch++;                          \
    if( *pch )                          \
        pch++


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
)
{
    BOOL    bRet = FALSE;
    DWORD   rc, dwCharCount = 10;
    LPVOID  pszEntry = NULL;

    do {

        FreeSplMem(pszEntry);

        dwCharCount *= 2;
        pszEntry = AllocSplMem(dwCharCount*sizeof(WCHAR));

        if ( !pszEntry  ||
             !(rc = GetProfileString(szPorts, pName, szNULL,
                                     pszEntry, dwCharCount)) )
            goto Done;

    } while ( rc >= dwCharCount - 2 );

    bRet =  BuildCommDCB((LPWSTR)pszEntry, pdcb);

    pcto->WriteTotalTimeoutConstant = GetProfileInt(szWindows,
                                            szINIKey_TransmissionRetryTimeout,
                                            45 );
    pcto->WriteTotalTimeoutConstant*=1000;

Done:
    FreeSplMem(pszEntry);
    return bRet;
}


/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
)
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1 pPorts;
    DWORD i;
    BOOL  Found = TRUE;

    *pError = NO_ERROR;

    if (!hSpoolssDll) {

        hSpoolssDll = LoadLibrary(L"SPOOLSS.DLL");

        if (hSpoolssDll) {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll,
                                                 "EnumPortsW");
            if (!pfnSpoolssEnumPorts) {

                *pError = GetLastError();
                FreeLibrary(hSpoolssDll);
                hSpoolssDll = NULL;
            }

        } else {

            *pError = GetLastError();
        }
    }

    if (!pfnSpoolssEnumPorts)
        return FALSE;


    if (!(*pfnSpoolssEnumPorts)(pName, 1, NULL, 0, &cbNeeded, &cReturned))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            cbPorts = cbNeeded;

            pPorts = AllocSplMem(cbPorts);

            if (pPorts)
            {
                if ((*pfnSpoolssEnumPorts)(pName, 1, (LPBYTE)pPorts, cbPorts,
                                           &cbNeeded, &cReturned))
                {
                    Found = FALSE;

                    for (i = 0; i < cReturned; i++)
                    {
                        if (!lstrcmpi(pPorts[i].pName, pPortName))
                            Found = TRUE;
                    }
                }
            }

            FreeSplMem(pPorts);
        }
    }

    else
        Found = FALSE;


    return Found;
}


VOID
LcmSplInSem(
   VOID
)
{
    if (LcmSpoolerSection.OwningThread != (HANDLE) UIntToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Not in spooler semaphore\n"));
    }
}

VOID
LcmSplOutSem(
   VOID
)
{
    if (LcmSpoolerSection.OwningThread == (HANDLE) UIntToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Inside spooler semaphore !!\n"));
    }
}

VOID
LcmEnterSplSem(
   VOID
)
{
    EnterCriticalSection(&LcmSpoolerSection);
}

VOID
LcmLeaveSplSem(
   VOID
)
{
#if DBG
    LcmSplInSem();
#endif
    LeaveCriticalSection(&LcmSpoolerSection);
}

PINIENTRY
LcmFindName(
   PINIENTRY pIniKey,
   LPWSTR pName
)
{
    if (pName) {
        while (pIniKey) {

            if (!lstrcmpi(pIniKey->pName, pName)) {
                return pIniKey;
            }

            pIniKey=pIniKey->pNext;
        }
    }

    return FALSE;
}

PINIENTRY
LcmFindIniKey(
   PINIENTRY pIniEntry,
   LPWSTR pName
)
{
   if (!pName)
      return NULL;

   LcmSplInSem();

   while (pIniEntry && lstrcmpi(pName, pIniEntry->pName))
      pIniEntry = pIniEntry->pNext;

   return pIniEntry;
}

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
)
{
   while (*DestOffsets != -1) {
      if (*pSource) {
          size_t cbString = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
         pEnd-= cbString;
         StringCbCopy ((LPWSTR) pEnd, cbString, *pSource);;
         *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)= (LPWSTR) pEnd;
      } else
         *(LPWSTR UNALIGNED *)(pDest+*DestOffsets)=0;
      pSource++;
      DestOffsets++;
   }

   return pEnd;
}


/* LcmMessage
 *
 * Displays a LcmMessage by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
int LcmMessage(HWND hwnd, DWORD Type, int CaptionID, int TextID, ...)
{
    WCHAR   MsgText[256];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( LcmhInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( LcmhInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        StringCchVPrintf (MsgText, COUNTOF (MsgText), MsgFormat, vargs );
        va_end( vargs );

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}


/*
 *
 */
LPTSTR
LcmGetErrorString(
    DWORD   Error
)
{
    TCHAR   Buffer[1024];
    LPTSTR  pErrorString = NULL;

    if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL, Error, 0, Buffer,
                       COUNTOF(Buffer), NULL )
      == 0 )

        LoadString( LcmhInst, IDS_UNKNOWN_ERROR,
                    Buffer, COUNTOF(Buffer) );

    pErrorString = AllocSplStr(Buffer);

    return pErrorString;
}




DWORD ReportError( HWND  hwndParent,
                   DWORD idTitle,
                   DWORD idDefaultError )
{
    DWORD  ErrorID;
    DWORD  MsgType;
    LPTSTR pErrorString;

    ErrorID = GetLastError( );

    if( ErrorID == ERROR_ACCESS_DENIED )
        MsgType = MSG_INFORMATION;
    else
        MsgType = MSG_ERROR;


    pErrorString = LcmGetErrorString( ErrorID );

    LcmMessage( hwndParent, MsgType, idTitle,
             idDefaultError, pErrorString );

    FreeSplStr( pErrorString );


    return ErrorID;
}


// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

DWORD
WINAPIV
StrNCatBuffW(
    IN      PWSTR       pszBuffer,
    IN      UINT        cchBuffer,
    ...
    )
/*++

Description:

    This routine concatenates a set of null terminated strings
    into the provided buffer.  The last argument must be a NULL
    to signify the end of the argument list.  This only called
        from LocalMon by functions that use WCHARS.

Arguments:

    pszBuffer  - pointer buffer where to place the concatenated
                 string.
    cchBuffer  - character count of the provided buffer including
                 the null terminator.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

--*/
{
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    PCWSTR  pszTemp     = NULL;
    PWSTR   pszDest     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (pszBuffer && cchBuffer)
    {
        //
        // Assume success.
        //
        dwRetval = ERROR_SUCCESS;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, cchBuffer);

        //
        // Get temp destination pointer.
        //
        pszDest = pszBuffer;

        //
        // Insure we have space for the null terminator.
        //
        cchBuffer--;

        //
        // Collect all the arguments.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, PCWSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Copy the data into the destination buffer.
            //
            for ( ; cchBuffer; cchBuffer-- )
            {
                if (!(*pszDest = *pszTemp))
                {
                    break;
                }

                pszDest++, pszTemp++;
            }

            //
            // If were unable to write all the strings to the buffer,
            // set the error code and nuke the incomplete copied strings.
            //
            if (!cchBuffer && pszTemp && *pszTemp)
            {
                dwRetval = ERROR_BUFFER_OVERFLOW;
                *pszBuffer = L'\0';
                break;
            }
        }

        //
        // Terminate the buffer always.
        //
        *pszDest = L'\0';

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;

}

/* PortIsValid
 *
 * Validate the port by attempting to create/open it.
 */
BOOL
PortIsValid(
    LPWSTR pPortName
)
{
    HANDLE hFile;
    BOOL   Valid;

    //
    // For COM and LPT ports, no verification
    //
    if ( IS_COM_PORT( pPortName ) ||
        IS_LPT_PORT( pPortName ) ||
        IS_FILE_PORT( pPortName ) )
    {
        return TRUE;
    }

    hFile = CreateFile(pPortName,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = CreateFile(pPortName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                           NULL);
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        Valid = TRUE;
    } else {
        Valid = FALSE;
    }

    return Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\spltypes.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h

// @@BEGIN_DDKSPLIT
Abstract:


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef MODULE
#define MODULE "LMON:"
#define MODULE_DEBUG LocalmonDebug
#endif

#define ILM_SIGNATURE   0x4d4c49  /* 'ILM' is the signature value */

typedef struct _INIPORT  *PINIPORT;
typedef struct _INIXCVPORT  *PINIXCVPORT;

typedef struct _INILOCALMON {
    DWORD signature;
// @@BEGIN_DDKSPLIT
#ifdef _SPL_CLUST
// @@END_DDKSPLIT
    PMONITORINIT pMonitorInit;
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
    PINIPORT pIniPort;
    PINIXCVPORT pIniXcvPort;
} INILOCALMON, *PINILOCALMON;

typedef struct _INIENTRY {
    DWORD       signature;
    DWORD       cb;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;

// IMPORTANT: the offset to pNext in INIPORT must be the same as in INIXCVPORT (DeletePortNode)
typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hFile;               // File handle
    DWORD   cbWritten;
    DWORD   Status;              // see PORT_ manifests
    LPWSTR  pPrinterName;
    LPWSTR  pDeviceName;
    HANDLE  hPrinter;
    DWORD   JobId;
    PINILOCALMON        pIniLocalMon;
    LPBYTE              pExtra;
    // @@BEGIN_DDKSPLIT
    HANDLE              hNotify;
    // @@END_DDKSPLIT
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x5450  /* 'PT' is the signature value */

// IMPORTANT: the offset to pNext in INIXCVPORT must be the same as in INIPORT (DeletePortNode)
typedef struct _INIXCVPORT {
    DWORD       signature;
    DWORD       cb;
    struct      _INIXCVPORT *pNext;
    DWORD       cRef;
    DWORD       dwMethod;
    LPWSTR      pszName;
    DWORD       dwState;
    ACCESS_MASK GrantedAccess;
    PINILOCALMON pIniLocalMon;
} INIXCVPORT, *PINIXCVPORT;

#define XCV_SIGNATURE   0x5843  /* 'XC' is the signature value */


#define PP_DOSDEVPORT     0x0001  // A port for which we did DefineDosDevice
#define PP_COMM_PORT      0x0002  // A port for which GetCommTimeouts was successful
#define PP_FILEPORT       0x0004  // The port is a file port
#define PP_STARTDOC       0x0008  // Port is in use (startdoc called)

#define FindPort(pIniLocalMon, psz)                          \
    (PINIPORT)LcmFindIniKey( (PINIENTRY)pIniLocalMon->pIniPort, \
                          (LPWSTR)(psz))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\winspool.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    winspool.c

Abstract:

    Implements the spooler supported apis for printing.

// @@BEGIN_DDKSPLIT
Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

WCHAR   szNULL[] = L"";
WCHAR   szLcmDeviceNameHeader[] = L"\\Device\\NamedPipe\\Spooler\\";
WCHAR   szWindows[] = L"windows";
WCHAR   szINIKey_TransmissionRetryTimeout[] = L"TransmissionRetryTimeout";


//
// Timeouts for serial printing
//
#define WRITE_TOTAL_TIMEOUT     3000    // 3 seconds
#define READ_TOTAL_TIMEOUT      5000    // 5 seconds
#define READ_INTERVAL_TIMEOUT   200     // 0.2 second


BOOL
DeletePortNode(
    PINILOCALMON pIniLocalMon,
    PINIPORT  pIniPort
    )
{
    PINIPORT    pPort, pPrevPort;

    for( pPort = pIniLocalMon->pIniPort;
         pPort && pPort != pIniPort;
         pPort = pPort->pNext){

        pPrevPort = pPort;
    }

    if (pPort) {    // found the port
        if (pPort == pIniLocalMon->pIniPort) {
            pIniLocalMon->pIniPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplMem(pPort);

        return TRUE;
    }
    else            // port not found
        return FALSE;
}


BOOL
RemoveDosDeviceDefinition(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Removes the NONSPOOLED.. dos device definition created by localmon

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on success, FALSE on error

--*/
{
    WCHAR   TempDosDeviceName[MAX_PATH];

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"NONSPOOLED_", pIniPort->pName, NULL ))
        return FALSE;

    LcmRemoveColon(TempDosDeviceName);

    return DefineDosDevice(DDD_REMOVE_DEFINITION, TempDosDeviceName, NULL);
}

// @@BEGIN_DDKSPLIT
DWORD
HandleLptQueryRemove(
    LPVOID  pData
    )
{
    DWORD       dwRet = NO_ERROR;
    PINIPORT    pIniPort = (PINIPORT)pData;

    SPLASSERT(pIniPort && pIniPort->signature == IPO_SIGNATURE
                       && pIniPort->hNotify != NULL );

    LcmEnterSplSem();
    //
    // Fix is not multi-thread safe now
    //
    if ( pIniPort->Status & PP_STARTDOC ) {

        dwRet = ERROR_BUSY;
        goto Done;
    }

    // InitializeCriticalSection(pIniPort->&CritSection);
    CloseHandle(pIniPort->hFile);
    SplUnregisterForDeviceEvents(pIniPort->hNotify);
    pIniPort->hNotify   = NULL;
    pIniPort->hFile     = INVALID_HANDLE_VALUE;

Done:
    LcmLeaveSplSem();
    return dwRet;
}
// @@END_DDKSPLIT

BOOL
ValidateDosDevicePort(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Checks if the given port corresponds to a dos device.
    For a dos device port the following is done:
        -- Dos device definition for the NONSPOOLED.. is created
        -- CreateFile is done on the NONSPOOLED.. port

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on all validations passing, FALSE otherwise

    Side effect:
        For dos devices :
        a. CreateFile is called on the NONSPOOLED.. name
        b. PP_DOSDEVPORT flag is set
        c. pIniPort->pDeviceName is set to the first string found on
           QueryDosDefition this could be used to see if the definition changed
           (ex. when user did a net use lpt1 \\server\printer the connection
                is effective only when the user is logged in)
        d. PP_COMM_PORT is set for real LPT/COM port
           (ie. GetCommTimeouts worked, not a net use lpt1 case)

--*/
{
    DCB             dcb;
    COMMTIMEOUTS    cto;
    WCHAR           TempDosDeviceName[MAX_PATH];
    HANDLE          hToken = NULL;
    WCHAR           DeviceNames[MAX_PATH];
    WCHAR           DosDeviceName[MAX_PATH];
    WCHAR           NewNtDeviceName[MAX_PATH];
    WCHAR          *pDeviceNames=DeviceNames;
    BOOL            bRet = FALSE;
    LPWSTR          pDeviceName = NULL;

    hToken = RevertToPrinterSelf();
    if (!hToken)
       goto Done;

    if( ERROR_SUCCESS != StrNCatBuffW( DosDeviceName, COUNTOF(DosDeviceName),
                                       pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(DosDeviceName);

    //
    // If the port is not a dos device port nothing to do -- return success
    //
    if ( !QueryDosDevice(DosDeviceName, DeviceNames, COUNTOF (DeviceNames)) ) {

        bRet = TRUE;
        goto Done;
    }

    pDeviceName = AllocSplStr(pDeviceNames);
    if ( !pDeviceName )
        goto Done;

    if( ERROR_SUCCESS != StrNCatBuffW( NewNtDeviceName, COUNTOF(NewNtDeviceName),
                                       szLcmDeviceNameHeader, pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(NewNtDeviceName);

    //
    // Search for the first non-matching name in pDeviceNames list.
    //
    while ( lstrcmpi(pDeviceNames, NewNtDeviceName) == 0 ) {

        pDeviceNames+=wcslen(pDeviceNames)+1;
    }

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"NONSPOOLED_", pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(TempDosDeviceName);

    //
    // Delete any existing definition for TempDosDeviceName. This ensures that
    // there exists only one definition for the nonspooled_port device name.
    //
    DefineDosDevice(DDD_REMOVE_DEFINITION, TempDosDeviceName, NULL);
    DefineDosDevice(DDD_RAW_TARGET_PATH, TempDosDeviceName, pDeviceNames);

    ImpersonatePrinterClient(hToken);
    hToken = NULL;

    if( ERROR_SUCCESS != StrNCatBuffW( TempDosDeviceName, COUNTOF(TempDosDeviceName),
                                       L"\\\\.\\NONSPOOLED_", pIniPort->pName, NULL ))
        goto Done;

    LcmRemoveColon(TempDosDeviceName);

    pIniPort->hFile = CreateFile(TempDosDeviceName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL |
                                 FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);

    //
    // If CreateFile fails remove redirection and fail the call
    //
    if ( pIniPort->hFile == INVALID_HANDLE_VALUE ) {

        (VOID)RemoveDosDeviceDefinition(pIniPort);
        goto Done;
    }

    pIniPort->Status |= PP_DOSDEVPORT;

    SetEndOfFile(pIniPort->hFile);

    if ( IS_COM_PORT (pIniPort->pName) ) {

        if ( GetCommState(pIniPort->hFile, &dcb) ) {

            GetCommTimeouts(pIniPort->hFile, &cto);
            GetIniCommValues (pIniPort->pName, &dcb, &cto);
            SetCommState (pIniPort->hFile, &dcb);
            cto.WriteTotalTimeoutConstant   = WRITE_TOTAL_TIMEOUT;
            cto.WriteTotalTimeoutMultiplier = 0;
            cto.ReadTotalTimeoutConstant    = READ_TOTAL_TIMEOUT;
            cto.ReadIntervalTimeout         = READ_INTERVAL_TIMEOUT;
            SetCommTimeouts(pIniPort->hFile, &cto);

            pIniPort->Status |= PP_COMM_PORT;
        } else {

            DBGMSG(DBG_WARNING,
                   ("ERROR: Failed GetCommState pIniPort->hFile %x\n",pIniPort->hFile) );
        }
    } else if ( IS_LPT_PORT (pIniPort->pName) ) {

        if ( GetCommTimeouts(pIniPort->hFile, &cto) ) {

            cto.WriteTotalTimeoutConstant =
                            GetProfileInt(szWindows,
                                          szINIKey_TransmissionRetryTimeout,
                                          45 );
            cto.WriteTotalTimeoutConstant*=1000;
            SetCommTimeouts(pIniPort->hFile, &cto);

            // @@BEGIN_DDKSPLIT
            hToken = RevertToPrinterSelf();
            pIniPort->hNotify = SplRegisterForDeviceEvents(
                                    pIniPort->hFile,
                                    (LPVOID)pIniPort,
                                    HandleLptQueryRemove);
            ImpersonatePrinterClient(hToken);
            hToken = NULL;
            // @@END_DDKSPLIT

            pIniPort->Status |= PP_COMM_PORT;
        } else {

            DBGMSG(DBG_WARNING,
                   ("ERROR: Failed GetCommTimeouts pIniPort->hFile %x\n",pIniPort->hFile) );
        }
    }

    FreeSplStr( pIniPort->pDeviceName );

    pIniPort->pDeviceName = pDeviceName;
    bRet = TRUE;

Done:
    if (hToken)
        ImpersonatePrinterClient(hToken);

    if ( !bRet && pDeviceName )
        FreeSplStr(pDeviceName);

    return bRet;
}


BOOL
FixupDosDeviceDefinition(
    PINIPORT    pIniPort
    )
/*++

Routine Description:
    Called before every StartDocPort for a DOSDEVPORT. The routine will check if
    the dos device defintion has changed (if a user logged and his connection
    is remembered). Also for a connection case the CreateFile is called since
    that needs to be done per job

Arguments:
    pIniPort    : Pointer to the INIPORT

Return Value:
    TRUE on all validations passing, FALSE otherwise

--*/
{
    WCHAR       DeviceNames[MAX_PATH];
    WCHAR       DosDeviceName[MAX_PATH];
    HANDLE      hToken;

    //
    // If the port is not a real LPT port we open it per job
    // @@BEGIN_DDKSPLIT
    // Also parallel ports could be closed on QUERYREMOVE if user undocks
    // then it will be opened on next job's StartDocPort
    // @@END_DDKSPLIT
    //

    if ( !(pIniPort->Status & PP_COMM_PORT) ||
         pIniPort->hFile == INVALID_HANDLE_VALUE )
        return ValidateDosDevicePort(pIniPort);

    if( ERROR_SUCCESS != StrNCatBuffW( DosDeviceName, COUNTOF (DosDeviceName),
                                       pIniPort->pName, NULL ))
        return FALSE;

    LcmRemoveColon(DosDeviceName);

    hToken = RevertToPrinterSelf();

    if (!hToken) {
        return FALSE;
    }

    if ( !QueryDosDevice(DosDeviceName, DeviceNames, COUNTOF (DeviceNames) ) ) {

        ImpersonatePrinterClient(hToken);
        return FALSE;
    }

    //
    // If strings are same then definition has not changed
    //
    if ( !lstrcmpi(DeviceNames, pIniPort->pDeviceName) )
    {
        ImpersonatePrinterClient(hToken);
        return TRUE;
    }

    (VOID)RemoveDosDeviceDefinition(pIniPort);

    CloseHandle(pIniPort->hFile);
    pIniPort->hFile = INVALID_HANDLE_VALUE;

    // @@BEGIN_DDKSPLIT
    if ( pIniPort->hNotify ) {

        SplUnregisterForDeviceEvents(pIniPort->hNotify);
        pIniPort->hNotify   = NULL;
    }
    // @@END_DDKSPLIT

    pIniPort->Status &= ~(PP_COMM_PORT | PP_DOSDEVPORT);

    FreeSplStr(pIniPort->pDeviceName);
    pIniPort->pDeviceName = NULL;

    ImpersonatePrinterClient(hToken);

    return ValidateDosDevicePort(pIniPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\config.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    config.c

Abstract:

    Handles spooler entry points for adding, deleting, and configuring
    localui ports.

// @@BEGIN_DDKSPLIT
Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"
#include "lmon.h"

/* From Control Panel's control.h:
 */
#define CHILD_PORTS 0

/* From cpl.h:
 */
#define CPL_INIT        1
#define CPL_DBLCLK      5
#define CPL_EXIT        7

// @@BEGIN_DDKSPLIT
/* Hack:
 */
// @@END_DDKSPLIT
#define CHILD_PORTS_HELPID  0

/* ConfigCOMPort
 *
 * Calls the Control Panel Ports applet
 * to permit user to set Baud rate etc.
 */
typedef void (WINAPI *CFGPROC)(HWND, ULONG, ULONG, ULONG);


BOOL
ConfigLPTPort(
    HWND    hWnd,
    HANDLE  hXcv
);

BOOL
ConfigCOMPort(
    HWND    hWnd,
    HANDLE  hXcv,
    PCWSTR  pszServer,
    PCWSTR  pszPortName
);

LPWSTR
GetPortName(
    HWND    hWnd,
    HANDLE  hXcv
);


BOOL
AddPortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
)
{
    PWSTR  pszPortName = NULL;
    BOOL   rc = TRUE;
    WCHAR  szLocalMonitor[MAX_PATH+1];
    DWORD  dwReturn, dwStatus;
    DWORD  cbNeeded;
    PRINTER_DEFAULTS Default;
    PWSTR  pszServerName = NULL;
    HANDLE  hXcv = NULL;
    DWORD dwLastError = ERROR_SUCCESS;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        //
        // Invalid parent window handle causes problems in function with DialogBoxParam call.
        // That function when the handle is bad returns ZERO, the same value as ERROR_SUCCEED.
        // PortNameDlg function calls EndDialog (ERROR_SUCCEES) if everything is alright.
        //
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        if (ppszPortNameOut)
        {
            *ppszPortNameOut = NULL;
        }
        return FALSE;
    }
    //
    //
    //
    /* Get the user to enter a port name:
     */

    if (!(pszServerName = ConstructXcvName(pszServer, pszMonitorNameIn, L"XcvMonitor"))) {
        rc = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(rc = OpenPrinter((PWSTR) pszServerName, &hXcv, &Default))) {
        rc = FALSE;
        goto Done;
    }

    if (!(pszPortName = GetPortName(hWnd, hXcv))) {
        rc = FALSE;
        goto Done;
    }

    // We can't Add, Configure, or Delete Remote COM ports
    if (IS_COM_PORT(pszPortName) || IS_LPT_PORT(pszPortName)) {
        SetLastError(ERROR_NOT_SUPPORTED);
        rc = FALSE;
        goto Done;
    }

    if(IS_COM_PORT(pszPortName))
        CharUpperBuff(pszPortName, 3);
    else if(IS_LPT_PORT(pszPortName))
        CharUpperBuff(pszPortName, 3);

    rc = XcvData(   hXcv,
                    L"AddPort",
                    (PBYTE) pszPortName,
                    (wcslen(pszPortName) + 1)*sizeof(WCHAR),
                    (PBYTE) &dwReturn,
                    0,
                    &cbNeeded,
                    &dwStatus);

    if (rc) {
        if(dwStatus == ERROR_SUCCESS) {
            if(ppszPortNameOut)
                *ppszPortNameOut = AllocSplStr(pszPortName);

            if(IS_LPT_PORT(pszPortName))
                rc = ConfigLPTPort(hWnd, hXcv);
            else if(IS_COM_PORT(pszPortName))
                rc = ConfigCOMPort(hWnd, hXcv, pszServer, pszPortName);

        } else if (dwStatus == ERROR_ALREADY_EXISTS) {
            Message( hWnd, MSG_ERROR, IDS_LOCALMONITOR, IDS_PORTALREADYEXISTS_S, pszPortName );

        } else {
            SetLastError(dwStatus);
            rc = FALSE;
        }
    }


Done:
    dwLastError = GetLastError ();

    FreeSplStr(pszPortName);
    FreeSplMem(pszServerName);

    if (hXcv)
        ClosePrinter(hXcv);

    SetLastError (dwLastError);
    return rc;
}


BOOL
DeletePortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
)
{
    PRINTER_DEFAULTS Default;
    PWSTR   pszServerName = NULL;
    DWORD   dwOutput;
    DWORD   cbNeeded;
    BOOL    bRet;
    HANDLE  hXcv = NULL;
    DWORD   dwStatus;
    DWORD   dwLastError = ERROR_SUCCESS;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        return FALSE;
    }
    //
    //
    //
    if (!(pszServerName = ConstructXcvName(pszServer, pszPortName, L"XcvPort"))) {
        bRet = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(bRet = OpenPrinter((PWSTR) pszServerName, &hXcv, &Default)))
        goto Done;

    // Since we can't Add or Configure Remote COM ports, let's not allow deletion either

    if (IS_COM_PORT(pszPortName) || IS_LPT_PORT(pszPortName)) {
        SetLastError(ERROR_NOT_SUPPORTED);
        bRet = FALSE;

    } else {

        bRet = XcvData( hXcv,
                        L"DeletePort",
                        (PBYTE) pszPortName,
                        (wcslen(pszPortName) + 1)*sizeof(WCHAR),
                        (PBYTE) &dwOutput,
                        0,
                        &cbNeeded,
                        &dwStatus);

        if (!bRet && (ERROR_BUSY == dwStatus))
        {
            //
            // Port cannot be deleted cause it is in use.
            //
            ErrorMessage (
                hWnd,
                dwStatus
                );
            //
            // Error is handled here and caller does not need to do anything
            //
            SetLastError (ERROR_CANCELLED);
        }
        else if (bRet && (ERROR_SUCCESS != dwStatus))
        {
            SetLastError(dwStatus);
            bRet = FALSE;
        }
    }

Done:
    dwLastError = GetLastError ();
    if (hXcv)
        ClosePrinter(hXcv);

    FreeSplMem(pszServerName);

    SetLastError (dwLastError);
    return bRet;
}




/* ConfigurePortUI
 *
 */
BOOL
ConfigurePortUI(
    PCWSTR pName,
    HWND   hWnd,
    PCWSTR pPortName
)
{
    BOOL   bRet;
    PRINTER_DEFAULTS Default;
    PWSTR  pServerName = NULL;
    HANDLE hXcv = NULL;
    DWORD  dwLastError = ERROR_SUCCESS;
    //
    //
    //
    if (hWnd && !IsWindow (hWnd))
    {
        SetLastError (ERROR_INVALID_WINDOW_HANDLE);
        return FALSE;
    }
    //
    //
    //
    if (!(pServerName = ConstructXcvName(pName, pPortName, L"XcvPort"))) {
        bRet = FALSE;
        goto Done;
    }

    Default.pDatatype = NULL;
    Default.pDevMode = NULL;
    Default.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!(bRet = OpenPrinter((PWSTR) pServerName, &hXcv, &Default)))
        goto Done;


    if( IS_LPT_PORT( (PWSTR) pPortName ) )
        bRet = ConfigLPTPort(hWnd, hXcv);
    else if( IS_COM_PORT( (PWSTR) pPortName ) )
        bRet = ConfigCOMPort(hWnd, hXcv, pName, pPortName);
    else {
        Message( hWnd, MSG_INFORMATION, IDS_LOCALMONITOR,
                 IDS_NOTHING_TO_CONFIGURE );

        SetLastError(ERROR_CANCELLED);
        bRet = FALSE;
    }

Done:
    dwLastError = GetLastError ();

    FreeSplMem(pServerName);

    if (hXcv) {
        ClosePrinter(hXcv);
        hXcv = NULL;
    }
    SetLastError (dwLastError);

    return bRet;
}



/* ConfigLPTPort
 *
 * Calls a dialog box which prompts the user to enter timeout and retry
 * values for the port concerned.
 * The dialog writes the information to the registry (win.ini for now).
 */
BOOL
ConfigLPTPort(
    HWND    hWnd,
    HANDLE  hXcv
)
{
    PORTDIALOG  Port;
    INT         iRet;
    //
    //
    ZeroMemory (&Port, sizeof (Port));
    iRet = -1;
    //
    //
    Port.hXcv = hXcv;

    iRet = (INT)DialogBoxParam(hInst, MAKEINTRESOURCE( DLG_CONFIGURE_LPT ),
                               hWnd, ConfigureLPTPortDlg, (LPARAM) &Port);

    if (iRet == ERROR_SUCCESS)
    {
        //
        // DialogBoxParam returns zero if hWnd is invalid.
        // ERROR_SUCCESS is equal to zero.
        // => We need to check LastError too.
        //
        return ERROR_SUCCESS == GetLastError ();
    }

    if (iRet == -1)
        return FALSE;

    SetLastError(iRet);
    return FALSE;
}


/* ConfigCOMPort
 *
 */
BOOL
ConfigCOMPort(
    HWND    hWnd,
    HANDLE  hXcv,
    PCWSTR  pszServer,
    PCWSTR  pszPortName
)
{
    DWORD       dwStatus;
    BOOL        bRet = FALSE;
    COMMCONFIG  CommConfig;
    COMMCONFIG  *pCommConfig = &CommConfig;
    COMMCONFIG  *pCC = NULL;
    PWSTR       pszPort = NULL;
    DWORD       cbNeeded;


    // GetDefaultCommConfig can't handle trailing :, so remove it!
    if (!(pszPort = (PWSTR) AllocSplStr(pszPortName)))
        goto Done;
    pszPort[wcslen(pszPort) - 1] = L'\0';

    cbNeeded = sizeof CommConfig;

    if (!XcvData(   hXcv,
                    L"GetDefaultCommConfig",
                    (PBYTE) pszPort,
                    (wcslen(pszPort) + 1)*sizeof *pszPort,
                    (PBYTE) pCommConfig,
                    cbNeeded,
                    &cbNeeded,
                    &dwStatus))
        goto Done;

    if (dwStatus != ERROR_SUCCESS) {
        if (dwStatus != ERROR_INSUFFICIENT_BUFFER) {
            SetLastError(dwStatus);
            goto Done;
        }

        if (!(pCommConfig = pCC = AllocSplMem(cbNeeded)))
            goto Done;

        if (!XcvData(   hXcv,
                        L"GetDefaultCommConfig",
                        (PBYTE) pszPort,
                        (wcslen(pszPort) + 1)*sizeof *pszPort,
                        (PBYTE) pCommConfig,
                        cbNeeded,
                        &cbNeeded,
                        &dwStatus))
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            SetLastError(dwStatus);
            goto Done;
        }
    }

    if (CommConfigDialog(pszPort, hWnd, pCommConfig)) {
        if (!XcvData(   hXcv,
                        L"SetDefaultCommConfig",
                        (PBYTE) pCommConfig,
                        pCommConfig->dwSize,
                        (PBYTE) NULL,
                        0,
                        &cbNeeded,
                        &dwStatus))
            goto Done;

        if (dwStatus != ERROR_SUCCESS) {
            SetLastError(dwStatus);
            goto Done;
        }
        bRet = TRUE;
    }


Done:

    FreeSplMem(pCC);
    FreeSplStr(pszPort);

    return bRet;
}



//
// Support routines
//


/* GetPortName
 *
 * Puts up a dialog containing a free entry field.
 * The dialog allocates a string for the name, if a selection is made.
 */

LPWSTR
GetPortName(
    HWND    hWnd,
    HANDLE  hXcv
)
{
    PORTDIALOG Port;
    INT        Result;
    LPWSTR     pszPort = NULL;
    //
    //
    ZeroMemory (&Port, sizeof (Port));
    Result = -1;
    //
    //
    Port.hXcv = hXcv;

    Result = (INT)DialogBoxParam(hInst,
                                 MAKEINTRESOURCE(DLG_PORTNAME),
                                 hWnd,
                                 PortNameDlg,
                                 (LPARAM)&Port);

    if (Result == ERROR_SUCCESS)
    {
        //
        // DialogBoxParam returns zero if hWnd is invalid.
        // ERROR_SUCCESS is equal to zero.
        // => We need to check LastError too.
        //
        if (ERROR_SUCCESS == GetLastError ())
        {
            //
            // DialogBoxParam executed successfully and a port name was retrieved
            //
            pszPort = Port.pszPortName;
        }
    }
    else if (Result != -1)
    {
        //
        // DialogBoxParam executed successfully, but the user canceled the dialog
        //
        SetLastError(Result);
    }

    return pszPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\local.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation
All rights reserved

Module Name:

    local.h
    
// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#ifndef _LOCAL_H_
#define _LOCAL_H_


LPWSTR AllocSplStr(LPCWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        ((pMem) ? (GlobalFree(pMem) ? FALSE:TRUE):TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

#define COUNTOF(x) (sizeof(x)/sizeof *(x))

//
// DEBUGGING:
//

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_EXEC      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800
#define DBG_TIME      0x1000
#define DBG_FOLDER    0x2000
#define DBG_NOHEAD    0x8000


#if DBG

ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS  LocalMonDebug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */

#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */

#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#define SPLASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgMsg( L"Failed: %s\nLine %d, %ws\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define SPLASSERT(expr)
#endif


#endif // _LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\localui.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    localui.h

// @@BEGIN_DDKSPLIT
Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _LOCALUI_H_
#define _LOCALUI_H_

extern  HANDLE   hInst;
extern  DWORD    PortInfo1Strings[];
extern  DWORD    PortInfo2Strings[];
extern  PINIPORT pIniFirstPort;
extern  PINIXCVPORT pIniFirstXcvPort;

extern WCHAR szPorts[];
extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];
extern WCHAR szDeviceNameHeader[];
extern WCHAR szFILE[];
extern WCHAR szCOM[];
extern WCHAR szLPT[];


#define IDS_LOCALMONITOR               300
#define IDS_INVALIDPORTNAME_S          301
#define IDS_PORTALREADYEXISTS_S        302
#define IDS_NOTHING_TO_CONFIGURE       303

#define MSG_ERROR           MB_OK | MB_ICONSTOP
#define MSG_WARNING         MB_OK | MB_ICONEXCLAMATION
#define MSG_YESNO           MB_YESNO | MB_ICONQUESTION
#define MSG_INFORMATION     MB_OK | MB_ICONINFORMATION
#define MSG_CONFIRMATION    MB_OKCANCEL | MB_ICONEXCLAMATION

#define TIMEOUT_MIN         1
#define TIMEOUT_MAX         999999
#define TIMEOUT_STRING_MAX  6

#define WITHINRANGE( val, lo, hi ) \
    ( ( val <= hi ) && ( val >= lo ) )


#define IS_FILE_PORT(pName) \
    !_wcsicmp( pName, szFILE )

#define IS_COM_PORT(pName) \
    IsCOMPort( pName )

#define IS_LPT_PORT(pName) \
    IsLPTPort( pName )

BOOL
IsCOMPort(
    PCWSTR pPort
);

BOOL
IsLPTPort(
    PCWSTR pPort
);

INT_PTR APIENTRY
ConfigureLPTPortDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
);


int
Message(
    HWND hwnd,
    DWORD Type,
    int CaptionID,
    int TextID,
    ...
);



PINIXCVPORT
CreateXcvPortEntry(
    DWORD   dwMethod,
    LPCWSTR pszName
);


BOOL
GetIniCommValues(
    LPWSTR          pName,
    LPDCB          pdcb,
    LPCOMMTIMEOUTS pcto
);

BOOL
ConfigurePortUI(
    LPCWSTR  pName,
    HWND    hWnd,
    LPCWSTR  pPortName
    );


BOOL
DeletePortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);

INT_PTR CALLBACK
PortNameDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
);


PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
);


INT
ErrorMessage(
    HWND hwnd,
    DWORD dwStatus
);

VOID cdecl DbgMsg( LPWSTR MsgFormat, ... );

#endif // _LOCALUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\local\xcv.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    xcv.c

Abstract:

    Implements xcv functions.

// @@BEGIN_DDKSPLIT
Author:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

//
// The ddk montior samples will be build with the name ddklocalmon and ddklocalui
// so they can be installed without clashing with existing files
//                 
// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT
//
// change this to the name of the dll that provides the ui for the monitor
//
#define SZLOCALUI  L"DDKLocalUI.dll"
// @@BEGIN_DDKSPLIT
#endif

#define SZLOCALUI  L"LocalUI.dll"
// @@END_DDKSPLIT

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoPortExists(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoPortIsValid(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoSetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);

DWORD
DoGetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);


DWORD
GetTransmissionRetryTimeout(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
);


typedef struct {
    PWSTR   pszMethod;
    DWORD   (*pfn)( PBYTE  pInputData,
                    DWORD  cbInputData,
                    PBYTE  pOutputData,
                    DWORD  cbOutputData,
                    PDWORD pcbOutputNeeded,
                    PINIXCVPORT pIniXcv
                    );
} XCV_METHOD, *PXCV_METHOD;


XCV_METHOD  gpLcmXcvMethod[] = {
                            {L"MonitorUI", GetMonitorUI},
                            {L"ConfigureLPTPortCommandOK", ConfigureLPTPortCommandOK},
                            {L"AddPort", DoAddPort},
                            {L"DeletePort", DoDeletePort},
                            {L"PortExists", DoPortExists},
                            {L"PortIsValid", DoPortIsValid},
                            {L"GetTransmissionRetryTimeout", GetTransmissionRetryTimeout},
                            {L"SetDefaultCommConfig", DoSetDefaultCommConfig},
                            {L"GetDefaultCommConfig", DoGetDefaultCommConfig},
                            {NULL, NULL}
                            };

DWORD
LcmXcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    )
{
    DWORD dwRet;
    DWORD i;

    for(i = 0 ; gpLcmXcvMethod[i].pszMethod &&
                wcscmp(gpLcmXcvMethod[i].pszMethod, pszDataName) ; ++i)
        ;

    if (gpLcmXcvMethod[i].pszMethod) {
        dwRet = (*gpLcmXcvMethod[i].pfn)(  pInputData,
                                        cbInputData,
                                        pOutputData,
                                        cbOutputData,
                                        pcbOutputNeeded,
                                        (PINIXCVPORT) hXcv);

    } else {
        dwRet = ERROR_INVALID_PARAMETER;
    }

    return dwRet;
}

BOOL
LcmXcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    PINILOCALMON pIniLocalMon = (PINILOCALMON)hMonitor;
    *phXcv = CreateXcvPortEntry(pIniLocalMon, pszObject, GrantedAccess);

    return !!*phXcv;
}


BOOL
LcmXcvClosePort(
    HANDLE  hXcv
    )
{
    LcmEnterSplSem();
    DeleteXcvPortEntry((PINIXCVPORT) hXcv);
    LcmLeaveSplSem();

    return TRUE;
}

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet = ERROR_SUCCESS;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    LcmEnterSplSem();

    if (LcmDeletePortEntry( pIniXcv->pIniLocalMon, (PWSTR)pInputData))
        WriteProfileString(szPorts, (PWSTR) pInputData, NULL);
    else
        dwRet = ERROR_FILE_NOT_FOUND;

    LcmLeaveSplSem();

    return dwRet;
}


DWORD
DoPortExists(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet;
    BOOL  bPortExists;

    *pcbOutputNeeded = sizeof(DWORD);

    if (cbOutputData < sizeof(DWORD)) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    bPortExists = PortExists(NULL, (PWSTR) pInputData, &dwRet);

    if (dwRet == ERROR_SUCCESS)
        *(DWORD *) pOutputData = bPortExists;

    return dwRet;
}


DWORD
DoPortIsValid(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    BOOL bRet;

    bRet = PortIsValid((PWSTR) pInputData);

    return bRet ? ERROR_SUCCESS : GetLastError();
}



DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD       dwRet, bPortExists;
    PINIPORT    pIniPort = NULL;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    if ( cbInputData == 0   ||
         pInputData == NULL ||
         ( wcslen((LPWSTR)pInputData) + 1 ) * sizeof(WCHAR) != cbInputData )
        return ERROR_INVALID_PARAMETER;

    bPortExists = PortExists(NULL, (PWSTR) pInputData, &dwRet);

    if (dwRet == ERROR_SUCCESS) {
        if (bPortExists) {
            SetLastError(ERROR_ALREADY_EXISTS);
        } else {
            pIniPort = LcmCreatePortEntry( pIniXcv->pIniLocalMon, (PWSTR)pInputData );

            if (pIniPort) {
                if (!WriteProfileString(szPorts, (PWSTR) pInputData, L""))
                {
                    LcmDeletePortEntry(pIniXcv->pIniLocalMon, (PWSTR) pInputData);
                    pIniPort = NULL;
                }
            }
        }
    }

    return pIniPort ? ERROR_SUCCESS : GetLastError();
}


DWORD
DoSetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    BOOL        bRet = FALSE;
    DWORD       dwLength;
    PWSTR       pszPortName = NULL;
    COMMCONFIG  *pCommConfig = (COMMCONFIG *) pInputData;

    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    dwLength = wcslen(pIniXcv->pszName);
    if (pIniXcv->pszName[dwLength - 1] == L':') {
        if (!(pszPortName = AllocSplStr(pIniXcv->pszName)))
            goto Done;
        pszPortName[dwLength - 1] = L'\0';
    }

    bRet = SetDefaultCommConfig(pszPortName,
                                pCommConfig,
                                pCommConfig->dwSize);

Done:

    FreeSplStr(pszPortName);

    return bRet ? ERROR_SUCCESS : GetLastError();
}


DWORD
DoGetDefaultCommConfig(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    PWSTR       pszPortName = (PWSTR) pInputData;
    COMMCONFIG  *pCommConfig = (COMMCONFIG *) pOutputData;
    BOOL        bRet;


    if (cbOutputData < sizeof(COMMCONFIG))
        return ERROR_INSUFFICIENT_BUFFER;

    pCommConfig->dwProviderSubType = PST_RS232;
    *pcbOutputNeeded = cbOutputData;

    bRet = GetDefaultCommConfig(pszPortName, pCommConfig, pcbOutputNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
GetTransmissionRetryTimeout(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    *pcbOutputNeeded = sizeof(DWORD);

    if (cbOutputData < sizeof(DWORD))
        return ERROR_INSUFFICIENT_BUFFER;

    *(PDWORD) pOutputData = GetProfileInt(szWindows,
                                          szINIKey_TransmissionRetryTimeout,
                                          45 );
    return ERROR_SUCCESS;
}

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    DWORD dwRet;

    *pcbOutputNeeded = sizeof( SZLOCALUI );

    if (cbOutputData < *pcbOutputNeeded) {

        dwRet =  ERROR_INSUFFICIENT_BUFFER;

    } else {

        dwRet = HRESULT_CODE (StringCbCopy ((PWSTR) pOutputData, cbOutputData, SZLOCALUI));
    }

    return dwRet;
}


DWORD
ConfigureLPTPortCommandOK(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PINIXCVPORT pIniXcv
)
{
    if (!(pIniXcv->GrantedAccess & SERVER_ACCESS_ADMINISTER))
        return ERROR_ACCESS_DENIED;

    if (!WriteProfileString(  szWindows, szINIKey_TransmissionRetryTimeout, (PWSTR) pInputData ))
        return GetLastError();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\dialogs.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.h

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

//
// Use the window word of the entry field to store last valid entry
//
#define SET_LAST_VALID_ENTRY( hwnd, id, val ) \
    SetWindowLongPtr( GetDlgItem( hwnd, id ), GWLP_USERDATA, (LONG_PTR)val )
#define GET_LAST_VALID_ENTRY( hwnd, id ) \
    GetWindowLongPtr( GetDlgItem( hwnd, id ), GWLP_USERDATA )

BOOL
PortNameInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
    );

BOOL
PortNameCommandOK(
    HWND    hwnd
    );

BOOL
PortNameCommandCancel(
    HWND hwnd
    );

BOOL
ConfigureLPTPortInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
    );

BOOL
ConfigureLPTPortCommandOK(
    HWND    hwnd
    );

BOOL
ConfigureLPTPortCommandCancel(
    HWND hwnd
    );

BOOL
ConfigureLPTPortCommandTransmissionRetryUpdate(
    HWND hwnd,
    WORD CtlId
    );

BOOL
LocalUIHelp( 
    IN HWND        hDlg,
    IN UINT        uMsg,        
    IN WPARAM      wParam,
    IN LPARAM      lParam
    );

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\dialogs.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    dialogs.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"
#include "dialogs.h"

WCHAR szINIKey_TransmissionRetryTimeout[] = L"TransmissionRetryTimeout";
WCHAR szHelpFile[] = L"WINDOWS.HLP";

#define MAX_LOCAL_PORTNAME  246

const DWORD g_aHelpIDs[]=
{
    IDD_PN_EF_PORTNAME,             8805136, // Port Name: "" (Edit)
    IDD_CL_EF_TRANSMISSIONRETRY,    8807704, // Configure LPT Port: "" (Edit)
    0, 0
};


INT_PTR APIENTRY
ConfigureLPTPortDlg(
   HWND   hwnd,
   UINT   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return ConfigureLPTPortInitDialog(hwnd, (PPORTDIALOG) lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return ConfigureLPTPortCommandOK(hwnd);

        case IDCANCEL:
            return ConfigureLPTPortCommandCancel(hwnd);

        case IDD_CL_EF_TRANSMISSIONRETRY:
            if( HIWORD(wparam) == EN_UPDATE )
                ConfigureLPTPortCommandTransmissionRetryUpdate(hwnd, LOWORD(wparam));
            break;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return LocalUIHelp(hwnd, msg, wparam, lparam);
        break;
    }

    return FALSE;
}


/*
 *
 */
BOOL
ConfigureLPTPortInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
)
{
    DWORD dwTransmissionRetryTimeout;
    DWORD cbNeeded;
    DWORD dwDummy;
    BOOL  rc;
    DWORD dwStatus;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pPort);

    SetForegroundWindow(hwnd);

    SendDlgItemMessage( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                        EM_LIMITTEXT, TIMEOUT_STRING_MAX, 0 );


    // Get the Transmission Retry Timeout from the host
    rc = XcvData(   pPort->hXcv,
                    L"GetTransmissionRetryTimeout",
                    (PBYTE) &dwDummy,
                    0,
                    (PBYTE) &dwTransmissionRetryTimeout,
                    sizeof dwTransmissionRetryTimeout,
                    &cbNeeded,
                    &dwStatus);
    if(!rc) {
        DBGMSG(DBG_WARNING, ("Error %d checking TransmissionRetryTimeout\n", GetLastError()));

    } else if(dwStatus != ERROR_SUCCESS) {
        DBGMSG(DBG_WARNING, ("Error %d checking TransmissionRetryTimeout\n", dwStatus));
        SetLastError(dwStatus);
        rc = FALSE;

    } else {

        SetDlgItemInt( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                       dwTransmissionRetryTimeout, FALSE );

        SET_LAST_VALID_ENTRY( hwnd, IDD_CL_EF_TRANSMISSIONRETRY,
                              dwTransmissionRetryTimeout );

    }

    return rc;
}


/*
 *
 */
BOOL
ConfigureLPTPortCommandOK(
    HWND hwnd
)
{
    WCHAR String[TIMEOUT_STRING_MAX+1];
    UINT  TransmissionRetryTimeout;
    BOOL  b;
    DWORD cbNeeded;
    PPORTDIALOG pPort;
    DWORD dwStatus;

    if ((pPort = (PPORTDIALOG) GetWindowLongPtr(hwnd, GWLP_USERDATA)) == NULL)
    {
        dwStatus = ERROR_INVALID_DATA;
        ErrorMessage (hwnd, dwStatus);
        SetLastError (dwStatus);
        return FALSE;
    }

    TransmissionRetryTimeout = GetDlgItemInt( hwnd,
                                              IDD_CL_EF_TRANSMISSIONRETRY,
                                              &b,
                                              FALSE );

    StringCchPrintf (String, COUNTOF (String), L"%d", TransmissionRetryTimeout);

    b = XcvData(pPort->hXcv,
                L"ConfigureLPTPortCommandOK",
                (PBYTE) String,
                (wcslen(String) + 1)*sizeof(WCHAR),
                (PBYTE) &cbNeeded,
                0,
                &cbNeeded,
                &dwStatus);

    EndDialog(hwnd, b ? dwStatus : GetLastError());

    return TRUE;
}



/*
 *
 */
BOOL
ConfigureLPTPortCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, ERROR_CANCELLED);
    return TRUE;
}


/*
 *
 */
BOOL
ConfigureLPTPortCommandTransmissionRetryUpdate(
    HWND hwnd,
    WORD CtlId
)
{
    int  Value;
    BOOL OK;

    Value = GetDlgItemInt( hwnd, CtlId, &OK, FALSE );

    if( WITHINRANGE( Value, TIMEOUT_MIN, TIMEOUT_MAX ) )
    {
        SET_LAST_VALID_ENTRY( hwnd, CtlId, Value );
    }

    else
    {
        SetDlgItemInt( hwnd, CtlId, (UINT) GET_LAST_VALID_ENTRY( hwnd, CtlId ), FALSE );
        SendDlgItemMessage( hwnd, CtlId, EM_SETSEL, 0, (LPARAM)-1 );
    }

    return TRUE;
}


/*
 *
 */
INT_PTR CALLBACK
PortNameDlg(
   HWND   hwnd,
   WORD   msg,
   WPARAM wparam,
   LPARAM lparam
)
{
    switch(msg)
    {
    case WM_INITDIALOG:
        return PortNameInitDialog(hwnd, (PPORTDIALOG)lparam);

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            return PortNameCommandOK(hwnd);

        case IDCANCEL:
            return PortNameCommandCancel(hwnd);
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return LocalUIHelp(hwnd, msg, wparam, lparam);
    }

    return FALSE;
}


/*
 *
 */
BOOL
PortNameInitDialog(
    HWND        hwnd,
    PPORTDIALOG pPort
)
{
    SetForegroundWindow(hwnd);

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pPort);
    // Number used to check port length in LocalMon (247)
    SendDlgItemMessage (hwnd, IDD_PN_EF_PORTNAME, EM_LIMITTEXT, MAX_LOCAL_PORTNAME, 0);

    return TRUE;
}


/*
 *
 */
BOOL
PortNameCommandOK(
    HWND    hwnd
)
{
    PPORTDIALOG pPort;
    WCHAR   string [MAX_LOCAL_PORTNAME + 1];
    BOOL    rc;
    DWORD   cbNeeded;
    DWORD   dwStatus;

    if ((pPort = (PPORTDIALOG) GetWindowLongPtr( hwnd, GWLP_USERDATA )) == NULL)
    {
        dwStatus = ERROR_INVALID_DATA;
        ErrorMessage (hwnd, dwStatus);
        SetLastError (dwStatus);
        return FALSE;
    }

    GetDlgItemText( hwnd, IDD_PN_EF_PORTNAME, string, COUNTOF (string) );

    rc = XcvData(   pPort->hXcv,
                    L"PortIsValid",
                    (PBYTE) string,
                    (wcslen(string) + 1)*sizeof *string,
                    (PBYTE) NULL,
                    0,
                    &cbNeeded,
                    &dwStatus);

    if (!rc) {
        return FALSE;

    } else if (dwStatus != ERROR_SUCCESS) {
        SetLastError(dwStatus);

        if (dwStatus == ERROR_INVALID_NAME)
            Message( hwnd, MSG_ERROR, IDS_LOCALMONITOR, IDS_INVALIDPORTNAME_S, string );
        else
            ErrorMessage(hwnd, dwStatus);

        return FALSE;

    } else {
        pPort->pszPortName = AllocSplStr( string );
        EndDialog( hwnd, ERROR_SUCCESS );
        return TRUE;
    }

}



/*
 *
 */
BOOL
PortNameCommandCancel(
    HWND hwnd
)
{
    EndDialog(hwnd, ERROR_CANCELLED);
    return TRUE;
}


/*++

Routine Name:

    LocalUIHelp

Routine Description:

    Handles context sensitive help for the configure LPTX:
    port and the dialog for adding a local port.

Arguments:

    UINT        uMsg,
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam

Return Value:

    TRUE if message handled, otherwise FALSE.

--*/

BOOL
LocalUIHelp(
    IN HWND        hDlg,
    IN UINT        uMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_HELP:

        bStatus = WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                           szHelpFile,
                           HELP_WM_HELP,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    case WM_CONTEXTMENU:

        bStatus = WinHelp((HWND)wParam,
                           szHelpFile,
                           HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aHelpIDs );
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\precomp.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <wchar.h>
#include <stddef.h>
#include <commctrl.h>
#include <strsafe.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\localui.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    localui.c

// @@BEGIN_DDKSPLIT
Abstract:

Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "localui.h"
#include "local.h"


//
// Common string definitions
//


HANDLE hInst;
PINIPORT pIniFirstPort;
PINIXCVPORT pIniFirstXcvPort;
DWORD LocalMonDebug;

DWORD PortInfo1Strings[]={FIELD_OFFSET(PORT_INFO_1, pName),
                          (DWORD)-1};

DWORD PortInfo2Strings[]={FIELD_OFFSET(PORT_INFO_2, pPortName),
                          FIELD_OFFSET(PORT_INFO_2, pMonitorName),
                          FIELD_OFFSET(PORT_INFO_2, pDescription),
                          (DWORD)-1};

WCHAR szPorts[]   = L"ports";
WCHAR szPortsEx[] = L"portsex"; /* Extra ports values */
WCHAR szFILE[]    = L"FILE:";
WCHAR szCOM[]     = L"COM";
WCHAR szLPT[]     = L"LPT";


MONITORUI MonitorUI =
{
    sizeof(MONITORUI),
    AddPortUI,
    ConfigurePortUI,
    DeletePortUI
};


extern WCHAR szWindows[];
extern WCHAR szINIKey_TransmissionRetryTimeout[];

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    INITCOMMONCONTROLSEX icc;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        hInst = hModule;

        DisableThreadLibraryCalls(hModule);

        //
        // Initialize the common controls, needed for fusion applications
        // because standard controls were moved to comctl32.dll
        //
        InitCommonControls();

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icc);
       
        return TRUE;

    case DLL_PROCESS_DETACH:
        return TRUE;
    }

    UNREFERENCED_PARAMETER( lpRes );
    return TRUE;
}

PMONITORUI
InitializePrintMonitorUI(
    VOID
)
{
    return &MonitorUI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localui.rc
//
#define DLG_PORTNAME                200
#define IDD_PN_PB_HELP              201
#define IDD_PN_EF_PORTNAME          202

#define DLG_CONFIGURE_LPT           300
#define IDD_CL_EF_TRANSMISSIONRETRY 303
#define IDD_CF_PB_HELP              304

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        305
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           305
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\parsepjl.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved

Module Name:

    parsepjl.h

Abstract:

    Header file for PJL parser

--*/

#define MAX_POSSIBLE_LISTS_IN_BRANCH 2

/* Note: new actions must be added at end, and new functions at the
end of the function pointer array defined later in this file */
enum ParseActionsEnumTag 
   {
   ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF,
   ACTION_SET_NEW_LIST,
   ACTION_GET_TOTAL_AND_LARGEST_FF,
   ACTION_GET_CODE_AND_ONLINE_FF,
   ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST,
   ACTION_SET_VALUE_FROM_PARAM_FF,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM,   
   ACTION_SET_VALUE_FROM_PARAM,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL,
   ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL
   };



/* Note: new actions must be added at end, and new functions at the
   end of the function pointer array defined later in this file 
*/
enum ParseNotFoundActionsEnumTag 
   {
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES
   };



/* Note: The order of some of the Token values is related to 
   indexes in the keyword lists.  Always add new token values
   to the end of BASE group.
*/
enum pjl_token_variables_tag
   {

   PJL_TOKEN_INQUIRE_BASE = 0x10000,
   TOKEN_INQUIRE_TRAY1SIZE = 0x10000,
   TOKEN_INQUIRE_TRAY2SIZE,
   TOKEN_INQUIRE_TRAY3SIZE,
   TOKEN_INQUIRE_TRAY4SIZE,

   PJL_TOKEN_ECHO_BASE = 0x20000,
   TOKEN_ECHO_MSSYNC_NUMBER = 0x20000,

   PJL_TOKEN_INFO_MEMORY_BASE = 0x30000,
   TOKEN_INFO_MEMORY_TOTAL   = 0x30000,
   TOKEN_INFO_MEMORY_LARGEST,

   PJL_TOKEN_INFO_STATUS_BASE = 0x40000,
   TOKEN_INFO_STATUS_CODE = 0x40000,
   TOKEN_INFO_STATUS_ONLINE,

   PJL_TOKEN_INFO_CONFIG_BASE = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY = 0x50000,
   TOKEN_INFO_CONFIG_MEMORY_SPACE,

   PJL_TOKEN_USTATUS_JOB_BASE = 0x60000,
   TOKEN_USTATUS_JOB_END = 0x60000,
   TOKEN_USTATUS_JOB_NAME_MSJOB,

   PJL_TOKEN_USTATUS_DEVICE_BASE = 0x70000,
   TOKEN_USTATUS_DEVICE_CODE = 0x70000,
   TOKEN_USTATUS_DEVICE_DISPLAY,
   TOKEN_USTATUS_DEVICE_ONLINE,
   };

/* The first 5 values are the possible return values for GetPJLTokens() */
/* The last 2 values are used internally */
enum status_tag
   {
   STATUS_REACHED_END_OF_COMMAND_OK,
   STATUS_END_OF_STRING,
   STATUS_SYNTAX_ERROR,
   STATUS_ATPJL_NOT_FOUND,
   STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS,

   STATUS_REACHED_FF,
   STATUS_CONTINUE
   };

typedef struct
   {
   DWORD    token;
   UINT_PTR value;
   } TOKENPAIR, * PTOKENPAIR, TokenPairType;

typedef struct ParamTypeTag
   {
   union 
      {
      struct ListTypeTag *pList;
      DWORD token;
      DWORD value;
      struct KeywordTypeTag *pListOfKeywords; 
      LPSTR lpstr;
      };  
   } ParamType;

typedef struct KeywordTypeTag 
   {
   LPSTR lpsz;
   DWORD dwAction;
   ParamType param;
   } KeywordType;

typedef struct ListTypeTag
   {
   BOOL  bFormFeedOK;
   DWORD dwNotFoundAction;
   DWORD tokenBaseValue;
   KeywordType *pListOfKeywords; 
   } ListType;

typedef struct parseVarsTag
   {
   LPSTR        pInPJL_Local;
   DWORD        nTokenLeft;
   DWORD        nTokenInBuffer_Local;
   TokenPairType *pToken_Local;
   DWORD        dwNextToken;
   DWORD        dwFoundIndex;
   DWORD        status; 
   ListType     *pCurrentList;
   KeywordType  *pCurrentKeywords;
   ListType     *arrayOfLists[MAX_POSSIBLE_LISTS_IN_BRANCH+1]; 
   } ParseVarsType;



extern DWORD GetPJLTokens(LPSTR lpInPJL, DWORD nTokenInBuffer, 
   TokenPairType *pToken, DWORD *pnTokenParsed, LPSTR *plpInPJL);

typedef struct
    {
    DWORD   pjl;
    DWORD   status;
    } PJLTOPRINTERSTATUS;

extern PJLTOPRINTERSTATUS PJLToStatus[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\precomp.h ===
/*++

Copyright (c) 1994-2003 Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

Revision History:

--*/


#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <strsafe.h>
#include "spltypes.h"
#include "local.h"
#include "parsepjl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\spltypes.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All rights reserved

Module Name:

    spltypes.h
    
// @@BEGIN_DDKSPLIT
Abstract:


Environment:

    User Mode -Win32

Revision History:
// @@END_DDKSPLIT
--*/
#ifndef _SPLTYPES_H_
#define _SPLTYPES_H_

#ifndef MODULE
#define MODULE "LMON:"
#define MODULE_DEBUG LocalmonDebug
#endif

typedef struct _PORTDIALOG {
    HANDLE  hXcv;
    PWSTR   pszServer;
    PWSTR   pszPortName;
} PORTDIALOG, *PPORTDIALOG;

typedef struct _INIENTRY {
    DWORD       signature;
    DWORD       cb;
    struct _INIENTRY *pNext;
    DWORD       cRef;
    LPWSTR      pName;
} INIENTRY, *PINIENTRY;

//
// IMPORTANT: the offset to pNext in INIPORT must be the same as in INIXCVPORT (DeletePortNode)
//
typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _INIPORT *pNext;
    DWORD   cRef;
    LPWSTR  pName;
    HANDLE  hFile;               
    DWORD   cbWritten;
    DWORD   Status;          // see PORT_ manifests    
    LPWSTR  pPrinterName;
    LPWSTR  pDeviceName;
    HANDLE  hPrinter;
    DWORD   JobId;
} INIPORT, *PINIPORT;

#define IPO_SIGNATURE   0x5450  /* 'PT' is the signature value */

//
// IMPORTANT: the offset to pNext in INIXCVPORT must be the same as in INIPORT (DeletePortNode)
//
typedef struct _INIXCVPORT {
    DWORD       signature;
    DWORD       cb;
    struct      _INIXCVPORT *pNext;
    DWORD       cRef;
    DWORD       dwMethod;
    LPWSTR      pszName;
    DWORD       dwState;
} INIXCVPORT, *PINIXCVPORT;

#define XCV_SIGNATURE   0x5843  /* 'XC' is the signature value */


#define PP_DOSDEVPORT     0x0001  // A port for which we did DefineDosDevice
#define PP_COMM_PORT      0x0002  // A port for which GetCommTimeouts was successful
#define PP_FILEPORT       0x0004  // The port is a file port
#define PP_STARTDOC       0x0008  // Port is in use (startdoc called)


#endif // _SPLTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\localui\util.c ===
/*++

Copyright (c) 1990-2003 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for localui.

// @@BEGIN_DDKSPLIT

Revision History:
// @@END_DDKSPLIT
--*/

#include "precomp.h"
#pragma hdrstop

#include "spltypes.h"
#include "local.h"
#include "localui.h"

PWSTR
ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    size_t   cchOutput;
    PWSTR   pOut;

    cchOutput = pServerName ? (wcslen(pServerName) + 2) : 1;   /* "\\Server\," */
    cchOutput += wcslen(pObjectType) + 2;                        /* "\\Server\,XcvPort _" */
    cchOutput += pObjectName ? wcslen(pObjectName) : 0;      /* "\\Server\,XcvPort Object_" */

    if (pOut = AllocSplMem(cchOutput * sizeof (pOut [0]))) {

        if (pServerName) {
            StringCchCopy(pOut, cchOutput, pServerName);
            StringCchCat (pOut, cchOutput, L"\\,");
        }
        else
        {
            StringCchCopy (pOut, cchOutput, L",");         
        }

        StringCchCat (pOut, cchOutput, pObjectType);
        StringCchCat (pOut, cchOutput, L" ");

        if (pObjectName)
        {
            StringCchCat (pOut, cchOutput, pObjectName);
        }
    }

    return pOut;
}


BOOL
IsCOMPort(
    PCWSTR pPort
)
{
    //
    // Must begin with szCom
    //
    if ( _wcsnicmp( pPort, szCOM, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}

BOOL
IsLPTPort(
    PCWSTR pPort
)
{
    //
    // Must begin with szLPT
    //
    if ( _wcsnicmp( pPort, szLPT, 3 ) )
    {
        return FALSE;
    }

    //
    // wcslen guarenteed >= 3
    //
    return pPort[ wcslen( pPort ) - 1 ] == L':';
}




/* Message
 *
 * Displays a message by loading the strings whose IDs are passed into
 * the function, and substituting the supplied variable argument list
 * using the varargs macros.
 *
 */
int Message(HWND hwnd, DWORD Type, int CaptionID, int TextID, ...)
{
    WCHAR   MsgText[2*MAX_PATH + 1];
    WCHAR   MsgFormat[256];
    WCHAR   MsgCaption[40];
    va_list vargs;

    if( ( LoadString( hInst, TextID, MsgFormat,
                      sizeof MsgFormat / sizeof *MsgFormat ) > 0 )
     && ( LoadString( hInst, CaptionID, MsgCaption,
                      sizeof MsgCaption / sizeof *MsgCaption ) > 0 ) )
    {
        va_start( vargs, TextID );
        StringCchVPrintf ( MsgText, COUNTOF(MsgText), MsgFormat, vargs );
        va_end( vargs );

        MsgText[COUNTOF(MsgText) - 1] = L'\0';

        return MessageBox(hwnd, MsgText, MsgCaption, Type);
    }
    else
        return 0;
}


INT
ErrorMessage(
    HWND hwnd,
    DWORD dwStatus
)
{
    WCHAR   MsgCaption[MAX_PATH];
    PWSTR   pBuffer = NULL;
    INT     iRet = 0;

    FormatMessage(  FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    NULL,
                    dwStatus,
                    0,
                    (PWSTR) &pBuffer,
                    0,
                    NULL);

    if (pBuffer) {
        if (LoadString( hInst, IDS_LOCALMONITOR, MsgCaption,
                  sizeof MsgCaption / sizeof *MsgCaption) > 0) {

             iRet = MessageBox(hwnd, pBuffer, MsgCaption, MSG_ERROR);
        }

        LocalFree(pBuffer);
    }

    return iRet;
}


LPWSTR
AllocSplStr(
    LPCWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    return GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cbAlloc);
}


// -----------------------------------------------------------------------
//
// DEBUG Stuff
//
// -----------------------------------------------------------------------

DWORD SplDbgLevel = 0;

VOID cdecl DbgMsg( LPWSTR MsgFormat, ... )
{
    WCHAR   MsgText[1024];
    
    va_list pArgs;
    va_start( pArgs, MsgFormat);	

    StringCchVPrintf (MsgText, COUNTOF (MsgText), MsgFormat, pArgs);
    StringCchCat( MsgText, COUNTOF (MsgText), L"\r");

    va_end( pArgs);
		
    OutputDebugString(MsgText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\local.h ===
/*++

Copyright (c) 1996-2003  Microsoft Corporation
All rights reserved

Module Name:

    local.h

Abstract:

    DDK version of local.h

Environment:

    User Mode -Win32

Revision History:

--*/

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL

#include "splcom.h"

#endif
// @@END_DDKSPLIT


#define READTHREADTIMEOUT                5000
#define READ_THREAD_EOJ_TIMEOUT         60000   // 1 min
#define READ_THREAD_ERROR_WAITTIME       5000   // 5 sec
#define READ_THREAD_IDLE_WAITTIME       30000   // 30 sec

#define ALL_JOBS                    0xFFFFFFFF


// ---------------------------------------------------------------------
// EXTERN VARIABLES
// ---------------------------------------------------------------------
extern  HANDLE              hInst;
extern  DWORD               dwReadThreadErrorTimeout;
extern  DWORD               dwReadThreadEOJTimeout;
extern  DWORD               dwReadThreadIdleTimeoutOther;

extern  CRITICAL_SECTION    pjlMonSection;
extern  DWORD SplDbgLevel;


// ---------------------------------------------------------------------
// FUNCTION PROTOTYPE
// ---------------------------------------------------------------------
VOID
EnterSplSem(
   VOID
    );

VOID
LeaveSplSem(
   VOID
    );

VOID
SplInSem(
   VOID
    );

VOID
SplOutSem(
    VOID
    );

DWORD
UpdateTimeoutsFromRegistry(
    IN LPTSTR      pszRegistryRoot
    );

PINIPORT
FindIniPort(
   IN LPTSTR pszName
    );

PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    );

VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    );

VOID
FreeIniJobs(
    PINIPORT pIniPort
    );

VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    );
VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    );

// @@BEGIN_DDKSPLIT
// ---------------------------------------------------------------------
// UNICODE TO ANSI MACRO
// ??? !!! we should get rid of these sooner or later
// ---------------------------------------------------------------------
// @@END_DDKSPLIT
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

LPSTR
mystrstr(
    LPSTR cs,
    LPSTR ct
);

LPSTR
mystrrchr(
    LPSTR cs,
    char c
);

LPSTR
mystrchr(
    LPSTR cs,
    char c
);

int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
);

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

extern  CRITICAL_SECTION    pjlMonSection;

LPWSTR AllocSplStr(LPWSTR pStr);
LPVOID AllocSplMem(DWORD cbAlloc);

#define FreeSplMem( pMem )        (GlobalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (GlobalFree(lpStr) ? FALSE:TRUE):TRUE)

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

//
// Needed by DDK
//
// @@BEGIN_DDKSPLIT
/*
// @@END_DDKSPLIT
#define DBGMSG(x,y)
#define SPLASSERT(exp)
#define COUNTOF(x) (sizeof(x)/sizeof *(x))
// @@BEGIN_DDKSPLIT
*/
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\parsepjl.c ===
/*++

Copyright (c) 1994-2003  Microsoft Corporation

Module Name:

    PARSEPJL.C

Abstract:

    Handles parsing of PJL printer response streams into token\value pairs.

--*/


/*
Currently returns tokens for (see enum in parsepjl.h for token values):
@PJL ECHO MSSYNC # ->#

@PJL INFO MEMORY
TOTAL=#   ->#
LARGEST=# ->#

@PJL INFO STATUS
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

@PJL INQUIRE INTRAY?SIZE   (? is 1,2,3 or 4)
LEGAL(or other PJL paper size) ->constant from DM... list in PRINT.H

@PJL INFO CONFIG
MEMORY=# ->#

@PJL USTATUS JOB
END -> returns token with zero for value

@PJL USTATUS JOB
NAME="MSJOB #" ->#

added

@PJL USTATUS DEVICE
CODE=#  ->#
DISPLAY=# (not returned)
ONLINE=TRUE (or FALSE) -> 1 or 0 returned

*/

#include "precomp.h"

#define FF 12
#define CR 13
#define LF 10
#define TAB 9
#define SPACE 32

#define OK_IF_FF_FOUND    TRUE
#define ERROR_IF_FF_FOUND FALSE
#define TOKEN_BASE_NOT_USED 0
#define ACTION_NOT_USED 0
#define PARAM_NOT_USED 0
/* returned as value for TOKEN_USTATUS_JOB_END */
#define VALUE_RETURED_FOR_VALUELESS_TOKENS  0

extern KeywordType readBackCommandKeywords[];
extern KeywordType infoCatagoryKeywords[];
extern KeywordType inquireVariableKeywords[];
extern KeywordType traySizeKeywords[];
extern KeywordType echoKeywords[];
extern KeywordType infoConfigKeywords[];
extern KeywordType ustatusKeywords[];
extern KeywordType ustatusJobKeywords[];
extern KeywordType ustatusDeviceKeywords[];

/* Fuctions called when a string in keyword is found */
void TokenFromParamValueFromNumberFF
   (ParseVarsType *pParseVars, ParamType);
void SetNewList(ParseVarsType *pParseVars,
   ParamType);
void GetTotalAndLargestFF(ParseVarsType *pParseVars,ParamType param);
void GetCodeAndOnlineFF(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParamFF(ParseVarsType *pParseVars,ParamType param);
void SetValueFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromNumberEOLFromParam(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromBooleanEOL(ParseVarsType *pParseVars,ParamType param);
void GetTokenFromIndexValueFromStringEOL(ParseVarsType *pParseVars,ParamType param);


/* Fuctions called when no string in a keywords list is found */
void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars);
void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars);


/* Helper Functions */
void StoreToken(ParseVarsType *pParseVars, DWORD dwToken);
BOOL StoreTokenValueAndAdvancePointer
   (ParseVarsType *pParseVars, UINT_PTR dwValue);
void  ExpectFinalCRLFFF(ParseVarsType *pParseVars);
BOOL  SkipPastNextCRLF(ParseVarsType *pParseVars);
int GetPositiveInteger(ParseVarsType *pParseVars);
BOOL AdvancePointerPastString
   (ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipOverSpaces(ParseVarsType *pParseVars);
int LookForKeyword(ParseVarsType *pParseVars);
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString);
BOOL SkipPastFF(ParseVarsType *pParseVars);
void ExpectFinalFF(ParseVarsType *pParseVars);

/* Helper Strings */
char lpCRLF[] = "\r\n";
char lpQuoteCRLF[] = "\"\r\n";

/*
Below are the Lists that drive the parsing.  The main loop of this
parser looks through the keywords in the current list and tries to
match the keyword string to the current input stream.

If a keyword is found then the function corresponding to the Action in
the keyword is called.

If a FF is found in the input stream rather than a keyword, then the
parser returns.  The return value is determined using the bFormFeedOk
element of the ListType structure.

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

The tokenBaseValue element is a number to which the index in the
keyword's list of strings will added to calculate the token number
corresponding to the indexed string.
*/

ListType readBackCommandList =
   {
   ERROR_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   TOKEN_BASE_NOT_USED,
   readBackCommandKeywords /* INFO, ECHO, INQUIRE ... */
   };

ListType infoCatagoryList =
   {
   ERROR_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   TOKEN_BASE_NOT_USED,
   infoCatagoryKeywords  /* MEMORY STATUS CONFIG ... */
   };


ListType infoConfigList =
   {
   OK_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_CFLF_AND_INDENTED_LINES,
   PJL_TOKEN_INFO_CONFIG_BASE,
   infoConfigKeywords  /* MEMORY= ... */
   };

ListType inquireVariableList =
   {
   ERROR_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_INQUIRE_BASE,
   inquireVariableKeywords /* INTRAY1SIZE ...*/
   };


ListType echoList =
   {
   OK_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   TOKEN_BASE_NOT_USED,
   echoKeywords /* MSSYNC ...*/
   };


ListType traySizeList =
   {
   ERROR_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   TOKEN_BASE_NOT_USED,
   traySizeKeywords /* LEGAL, C5 ...*/
   };

ListType ustatusList =
   {
   OK_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusKeywords  /* JOB ... */
   };


ListType ustatusJobList =
   {
   OK_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_JOB_BASE,
   ustatusJobKeywords  /* END ... */
   };

ListType ustatusDeviceList =
   {
   OK_IF_FF_FOUND,
   ACTION_IF_NOT_FOUND_SKIP_PAST_FF,
   PJL_TOKEN_USTATUS_DEVICE_BASE,
   ustatusDeviceKeywords  /* END ... */
   };


/* Command strings that can follow @PJL USTATUS */
KeywordType ustatusKeywords[] =
   {
      {"JOB\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusJobList},
      {"DEVICE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
//    {"DEVICE\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"TIMED\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &ustatusDeviceList},
      NULL
   };


/* Command strings that can follow @PJL USTATUS JOB */
KeywordType ustatusJobKeywords[] =
   {
      {"END\r\n", ACTION_SET_VALUE_FROM_PARAM, VALUE_RETURED_FOR_VALUELESS_TOKENS},
      {"NAME=\"MSJOB ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpQuoteCRLF},
      NULL
   };


/* command strings that can follow @PJL USTATUS DEVICE */
KeywordType ustatusDeviceKeywords[] =
   {
      {"CODE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"DISPLAY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_STRING_EOL, (struct ListTypeTag *)lpCRLF},
      {"ONLINE=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_BOOLEAN_EOL, (struct ListTypeTag *)lpCRLF},
      NULL
   };


/* Command strings that can follow @PJL */
KeywordType readBackCommandKeywords[] =
   {
      {"INFO", ACTION_SET_NEW_LIST, &infoCatagoryList},
      {"ECHO", ACTION_SET_NEW_LIST, &echoList},
      {"INQUIRE", ACTION_SET_NEW_LIST, &inquireVariableList},
      {"USTATUS", ACTION_SET_NEW_LIST, &ustatusList},
      NULL
   };


/* Command strings that can follow @PJL ECHO (Microsoft specific-NOT PJL!) */
KeywordType echoKeywords[] =
   {
      {"MSSYNC", ACTION_TOKEN_FROM_PARAM_VALUE_FROM_NUMBER_FF,
         (struct ListTypeTag *)(INT_PTR)TOKEN_ECHO_MSSYNC_NUMBER},
      NULL
   };

/* Catagory strings that can follow @PJL INFO */
KeywordType infoCatagoryKeywords[] =
   {
      {"MEMORY\r\n", ACTION_GET_TOTAL_AND_LARGEST_FF, PARAM_NOT_USED},
      {"STATUS\r\n", ACTION_GET_CODE_AND_ONLINE_FF, PARAM_NOT_USED},
      {"CONFIG\r\n", ACTION_SET_NEW_LIST, &infoConfigList},
      NULL
   };

/* Catagory strings that can follow @PJL INFO */
KeywordType infoConfigKeywords[] =
   {
      {"MEMORY=", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      {"MEMORY = ", ACTION_GET_TOKEN_FROM_INDEX_VALUE_FROM_NUMBER_EOL_FROM_PARAM, (struct ListTypeTag *)lpCRLF},
      NULL
   };

/* TRUE or FALSE strings */
KeywordType FALSEandTRUEKeywords[] =
   {
      {"FALSE", ACTION_NOT_USED, PARAM_NOT_USED},
      {"TRUE",  ACTION_NOT_USED, PARAM_NOT_USED},
      NULL
   };

/* strings that can follow @PJL INQUIRE */
KeywordType inquireVariableKeywords[] =
   {
      {"INTRAY1SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY2SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY3SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      {"INTRAY4SIZE\r\n", ACTION_TOKEN_FROM_INDEX_SET_NEW_LIST, &traySizeList},
      NULL
   };

/* strings that can follow @PJL INQUIRE INTRAY?SIZE */
/* the parameters are the Microsoft defined token values for paper size */
KeywordType traySizeKeywords[] =
   {
      {"LETTER",    ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LETTER},
      {"LEGAL",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_LEGAL},
      {"A4",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_A4},
      {"EXECUTIVE", ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_EXECUTIVE},
      {"COM10",     ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_10},
      {"MONARCH",   ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_MONARCH},
      {"C5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_C5},
      {"DL",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_DL},
      {"B5",        ACTION_SET_VALUE_FROM_PARAM_FF, (struct ListTypeTag *)DMPAPER_ENV_B5},
      NULL
   };

void (*pfnNotFoundActions[])(ParseVarsType *pParseVars) =
   {
   ActionNotFoundSkipPastFF,
   ActionNotFoundSkipCFLFandIndentedLines
   };


void (*pfnFoundActions[])(ParseVarsType *pParseVars, ParamType param) =
   {
   TokenFromParamValueFromNumberFF,
   SetNewList,
   GetTotalAndLargestFF,
   GetCodeAndOnlineFF,
   GetTokenFromIndexSetNewList,
   SetValueFromParamFF,
   GetTokenFromIndexValueFromNumberEOLFromParam,
   SetValueFromParam,
   GetTokenFromIndexValueFromBooleanEOL,
   GetTokenFromIndexValueFromStringEOL
   };

PJLTOPRINTERSTATUS PJLToStatus[] =
{
    { 10001,0x0 },  // clear status - printer is ready
    { 10002,0x0 },  // clear status - check ONLINE=TRUE or FALSE
    { 11002,0x0 },  // LJ4 sends this code for 00 READY
    { 40022,PORT_STATUS_PAPER_JAM    },
    { 40034,PORT_STATUS_PAPER_PROBLEM},
    { 40079,PORT_STATUS_OFFLINE      },
    { 40019,PORT_STATUS_OUTPUT_BIN_FULL},

    { 10003,PORT_STATUS_WARMING_UP   },
    { 10006,PORT_STATUS_TONER_LOW    },
    { 40038,PORT_STATUS_TONER_LOW    },

    { 30016,PORT_STATUS_OUT_OF_MEMORY},
    { 40021,PORT_STATUS_DOOR_OPEN    },
    { 30078,PORT_STATUS_POWER_SAVE   },

    //
    // Entries added by MuhuntS
    //
    { 41002, PORT_STATUS_PAPER_PROBLEM}, // Load plain
    { 35078, PORT_STATUS_POWER_SAVE},
    {0, 0}

};


// @@BEGIN_DDKSPLIT
#if 0
/*
test not enough room for tokens
test no FF
test zero before end
*/
main ()
{
char pInString[] = "@PJL USTATUS DEVICE\r\nCODE=25008\r\n\f\
@PJL USTATUS DEVICE\r\n\CODE=20020\r\n\f\
@PJL ECHO MSSYNC 1234567\r\n\f\
@PJL INFO CONFIG\r\n\
IN TRAYS [1 ENUMERATED]\r\n\
\tINTRAY1 PC\r\n\
OUT TRAYS [1 ENUMERATED]\r\n\
\tNORMAL FACEDOWN\r\n\
PAPERS [10 ENUMERATED]\r\n\
\tLETTER\r\n\
\tLEGAL\r\n\
\tA4\r\n\
LANGUAGES [1 ENUMERATED]\r\n\
\tPCL\r\n\
MEMORY=2097152\r\n\
DISPLAY LINES=1\r\n\
DISPLAY CHARACTER SIZE=16\r\n\f\
@PJL INQ";


//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"MSJOB 3\"\r\nPAGES=3\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL USTATUS JOB\r\nEND\r\nNAME=\"JOB 14993\"\r\nPAGES=3\r\n\f$"; //good command 1 token
/*
char pInString[] = "@PJL INFO CONFIG\r\nINTRAYS [3 ENUMERATED]\r\n\tINTRAY1\
 MP\r\n\tINTRAY2 PC\r\n\tINTRAY3 LC\r\nENVELOPE TRAY\r\nMEMORY=2087152\r\n\
DISPLAY LINES=1\r\n\f$"; //good command 1 token
*/
//char pInString[] = "@PJL INQUIRE INTRAY3SIZE\r\nC5\r\n\f$"; //good command 1 token
//char pInString[] = "@PJL INFO STATUS\r\nCODE=10001\r\n\DISPLAY=\"00 READY\"\r\nONLINE=TRUE\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJL INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\r\n\f$"; //good command 2 tokens
//char pInString[] = "@PJG INFO MEMORY\r\nTOTAL=9876543\r\n\LARGEST=123456\f$"; //bad command Fail
//char pInString[] = "@PJG ECHO MSSYNC 12T4567\r\n\f$";     //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\000\f$"; //bad command Fail
//char pInString[] = "@PJL ECHO MSSYNC 12T4567\r\n\f$";     //bad MS command Fail
//char pInString[] = "@PJL ECHO MSSYNC 1234567\r\n\f$";     //good command Success 1 token
//char pInString[] = "@PJL ECHO 124567\r\n\f$";             //good command Success 0 token
TokenPairType tokenPairs[20];
DWORD nTokenParsedRet;
LPSTR lpRet;
DWORD i;
DWORD status;


status = GetPJLTokens(pInString, 20, tokenPairs, &nTokenParsedRet, &lpRet);

switch (status)
   {
   case STATUS_REACHED_END_OF_COMMAND_OK:
      {
      printf("STATUS_REACHED_END_OF_COMMAND_OK\n");
      break;
      }
   case STATUS_CONTINUE:
      {
      printf("STATUS_CONTINUE\n");
      break;
      }
   case STATUS_REACHED_FF:
      {
      printf("STATUS_REACHED_FF\n");
      break;
      }
   case STATUS_END_OF_STRING;
      {
      printf("STATUS_END_OF_STRING\n");
      break;
      }
   case STATUS_SYNTAX_ERROR:
      {
      printf("STATUS_SYNTAX_ERROR\n");
      break;
      }
   case STATUS_ATPJL_NOT_FOUND:
      {
      printf("STATUS_ATPJL_NOT_FOUND\n");
      break;
      }
   case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
      {
      printf("STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n");
      break;
      }
   default:
      {
      printf("INVALID STATUS RETURNED!!!!!!\n");
      break;
      }
   };

printf(" length of command=%d, numberOfTokens=%d\n", lpRet-pInString, nTokenParsedRet);
for (i=0; i<nTokenParsedRet; i++)
   {
   printf("  Token=0x%x, Value=%d\n", tokenPairs[i].token, tokenPairs[i].value);
   }

if (*lpRet==0)
   {
   printf(" Next char is terminator\n");
   }
else
   {
   printf(" Next char=%c\n", *lpRet);
   }

exit(0);
}
#endif
// @@END_DDKSPLIT

/* GetPJLTokens
This function parses a single ASCII PJL command and returns token/value pairs.
Complete PJL commands must begin with '@PJL' and end with a <FF>.

The function result returns one of the following values:
   0 = STATUS_REACHED_END_OF_COMMAND_OK
   1 = STATUS_END_OF_STRING
   2 = STATUS_SYNTAX_ERROR
   3 = STATUS_ATPJL_NOT_FOUND,
   4 = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS

Also returned through the parameters are:
 1] *plpInPJL:
    If STATUS_REACHED_END_OF_COMMAND_OK
      will point to the character past the first <FF> (FF = form feed).
    If STATUS_END_OF_STRING
      will point to the terminator that was found before any <FF>.
    Else
      undefined

 2] *pnTokenParsed will contain the number of pairs returned in *pToken.

 3] pToken will contain *pnTokenParsed  token pairs

If there are characters belonging to another command trailing the first
then the caller should call again for the new command.  If only part of
the new command may be present, then the caller may want to copy the
characters of the new command to the beginning of the buffer, and then read
the necessary additional characters onto the end before resubmitting the
complete command to this function for parsing.  Note that the *plpInPJL
tells the caller where the next command would begin.


If the end of the string is encountered before the trailing <FF> is found then
the function returns with *plpInPJL pointing to the terminator.
If the caller wants the command parsed into
token\value pairs it should resubmit the string once the characters
which complete the command have been appended.


Operation:
----------
Lists drive the parsing.  The main loop of this
parser looks through the keywords of the current list and tries to
match the keyword string to the current input stream.

If a keyword is found then the function corresponding to the Action in
the keyword is called.

If no keyword from the list is found then the function corresponding
to the notFoundAction is called.

*/

DWORD GetPJLTokens(
    LPSTR lpInPJL,
    DWORD nTokenInBuffer,
    TokenPairType *pToken,
    DWORD *pnTokenParsed,
    LPSTR *plpInPJL
)
{
   /* The parseVars variables are put into a structure so that they can be
      passed efficiently to all the helper functions.
    */
   ParseVarsType parseVars;
   BOOL bFoundKeyword;
   DWORD i, keywordIndex;
   KeywordType *pKeyword;
   DWORD dwNotFoundAction;
   BOOL bNotFoundAction = FALSE;

   /* The first list to look for is the commands that can follow
      @PJL
    */
   parseVars.arrayOfLists[0] = &readBackCommandList;
   parseVars.arrayOfLists[1] = NULL;

   parseVars.pInPJL_Local = lpInPJL;
   parseVars.nTokenInBuffer_Local = 0;
   parseVars.nTokenLeft = nTokenInBuffer;
   parseVars.pToken_Local = pToken;
   parseVars.status = STATUS_CONTINUE;

   if (!AdvancePointerPastString(&parseVars, "@PJL"))
      {
      parseVars.status = STATUS_ATPJL_NOT_FOUND;
      }

   while (parseVars.status == STATUS_CONTINUE)
      {
      /* Look for next input keyword in currently valid lists.
         Sometimes may need to look for the next input keyword in more
         then one list.
       */
      bFoundKeyword = FALSE;
      bNotFoundAction = FALSE;
      for (i=0; (parseVars.pCurrentList = parseVars.arrayOfLists[i])!=NULL; i++)
         {
         dwNotFoundAction = parseVars.pCurrentList->dwNotFoundAction;
         bNotFoundAction = TRUE;
         /* Skip over spaces to start of next keyword string */
         if ( !SkipOverSpaces(&parseVars) )
            {
            /* Either the input stream has ended or FF was found */
            if (parseVars.status == STATUS_REACHED_FF)
               {
               /* Finding a FF here may or may not be an error,
                  the field in the current list tells us which
                */

               if ( parseVars.pCurrentList->bFormFeedOK )
                  {
                  parseVars.status = STATUS_REACHED_END_OF_COMMAND_OK;
                  }
               else
                  {
                  parseVars.status = STATUS_SYNTAX_ERROR;
                  }
               }
            break;
            }
         /* Look for keyword in current keywords */
         parseVars.pCurrentKeywords = parseVars.pCurrentList->pListOfKeywords;
         keywordIndex = LookForKeyword(&parseVars);
         if ( keywordIndex!=-1 )
            {
            bFoundKeyword = TRUE;
            break;
            }
         }

      if ( parseVars.status!=STATUS_CONTINUE )
         {
         /* We are finished processing commands */
         break;
         }

      if ( bFoundKeyword )
         /* do action from keyword */
         {
         pKeyword = &parseVars.pCurrentKeywords[keywordIndex];
         (*pfnFoundActions[pKeyword->dwAction])(&parseVars, pKeyword->param);
         }
      else if (bNotFoundAction)
         /* An action was not found, call the not found routine */
         {
         (*pfnNotFoundActions[dwNotFoundAction])(&parseVars);
         }
      }

   /* We are done parsing the input command, now we return the information */

   DBGMSG(DBG_TRACE, ("ParseVars.status = %d\n", parseVars.status));

   /* Fill in returned values and return with success */
   *pnTokenParsed = parseVars.nTokenInBuffer_Local;
   *plpInPJL = parseVars.pInPJL_Local;

   return(parseVars.status);
}


/*
int LookForKeyword(ParseVarsType *pParseVars)

This function looks through the current keyword list in search of a
keyword that matches the characters in the input stream pointed to
by pParseVars->pInPJL_Local.

If a match is found:
        The index of the match in the pKeyword is returned.
        pParseVars->pInPJL_Local is advanced past the last matching character.
        pParseVars->dwKeywordIndex is set to item number in list

If no match is found:
        The return value is -1.
        pParseVars->pInPJL_Local is unchanged.
*/
int LookForKeyword(ParseVarsType *pParseVars)
{
LPSTR   pInStart = pParseVars->pInPJL_Local;
LPSTR   pIn;
DWORD   dwKeywordIndex = 0;
BOOL    bFoundMatch = FALSE;
BYTE    c;
KeywordType *pKeywords = pParseVars->pCurrentKeywords;
LPSTR   pKeywordString;

while ( (pKeywordString=pKeywords[dwKeywordIndex++].lpsz)!=NULL )
{
   DBGMSG(DBG_TRACE, ("LookForIn=%hs\n", pInStart));
   DBGMSG(DBG_TRACE, ("Keyword=%hs\n", pKeywordString));

   pIn = pInStart;
   while ( (c=*pKeywordString++)!=0 )
      {
      if ( c!=*pIn++ )
         {
         break;
         }
      }

   if ( c==0 )
      {
      bFoundMatch = TRUE;
      pParseVars->pInPJL_Local = pIn;
      pParseVars->dwFoundIndex = dwKeywordIndex-1;
      break;
      }
   }

   DBGMSG(DBG_TRACE, ("LookForOut=%hs\n", pParseVars->pInPJL_Local));

   return( (bFoundMatch)?dwKeywordIndex-1:-1 );
}


/*
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)

This function looks through the input stream for a match with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
*/
BOOL AdvancePointerPastString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) )
      {
      if ( s==in )
         {
         pS++; /* point to next char in string to look for match */
         }
      else
         {
         pS = pString; /* start over looking for start of string */
         }
      pIn++;
      }

   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }

   if ( in==FF )
      {
      pParseVars->status = STATUS_REACHED_FF;
      pParseVars->pInPJL_Local = pIn+1;
      }
   else
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      }

   return(FALSE);
}



/*
BOOL SkipOverSpaces(ParseVarsType &parseVars)
This function skips over spaces in the input stream until a non-space
character (FF and NULL are special cases) is found.

If a non-space character is found then
   pParseVars->pInPJL_Local is set to point to the first non-space char.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before a non-space char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered before a non-space character is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipOverSpaces(ParseVarsType *pParseVars)
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)==SPACE)&&(in!=0)&&(in!=FF) )
      {
      pIn++;
      }

   switch (in)
      {
      case FF:
         {
         pParseVars->status = STATUS_REACHED_FF;
         pParseVars->pInPJL_Local = pIn+1;
         return(FALSE);
         }
      case 0:
         {
         pParseVars->status = STATUS_END_OF_STRING;
         pParseVars->pInPJL_Local = pIn;
         return(FALSE);
         }
      default:
         {
         /* point to character after string in input */
         pParseVars->pInPJL_Local = pIn;
         return(TRUE);
         }
      }
}


void TokenFromParamValueFromNumberFF(
   ParseVarsType *pParseVars,ParamType param)
{
   int value;

   StoreToken(pParseVars, param.token);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void ActionNotFoundSkipPastFF(ParseVarsType *pParseVars)
{
   if ( SkipPastFF(pParseVars) )
      {
      pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK;
      }
   return;
}

/*
BOOL SkipPastFF(ParseVarsType *pParseVars)
This function skips over all characters until either a zero is found or
FF is found.

If the end of input is encountered before an FF char is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING_ENCOUNTERED
   pParseVars->pInPJL_Local is set to point to the terminating 0.

If an FF is encountered
   the return value is TRUE
   pParseVars->status is set to STATUS_REACHED_FF
   pParseVars->pInPJL_Local is set to point just past the FF.
*/
BOOL SkipPastFF(ParseVarsType *pParseVars)
{
LPSTR pIn = pParseVars->pInPJL_Local;
BYTE  in;

   while ( ((in=*pIn)!=FF)&&(in!=0) )
      {
      pIn++;
      }

   if ( in==0 )
      {
      pParseVars->status = STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
      return(FALSE);
      }
   pParseVars->pInPJL_Local = pIn+1;
   pParseVars->status = STATUS_REACHED_FF;
   return(TRUE);
}

void ExpectFinalCRLFFF(ParseVarsType *pParseVars)
{
   char c;

   if ( pParseVars->status==STATUS_CONTINUE )
      {
      c=*pParseVars->pInPJL_Local;
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         return;
         }

      if ( !AdvancePointerPastString(pParseVars, lpCRLF) )
         {
         if ( pParseVars->status==STATUS_REACHED_FF )
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         return;
         }
      ExpectFinalFF(pParseVars);
      }
   return;
}



void ExpectFinalFF(ParseVarsType *pParseVars)
{
   if ( pParseVars->status==STATUS_CONTINUE )
      {
      if ( *pParseVars->pInPJL_Local==FF )
         {
         pParseVars->status = STATUS_REACHED_END_OF_COMMAND_OK;
         pParseVars->pInPJL_Local++;
         }
      else
         {
         if ( *pParseVars->pInPJL_Local==0 )
            {
            pParseVars->status = STATUS_END_OF_STRING;
            }
         else
            {
            pParseVars->status = STATUS_SYNTAX_ERROR;
            }
         }
      }
   return;
}


/*
int GetPositiveInteger(ParseVarsType *pParseVars)
This function skips spaces and then interprets all the digits in input stream
as a positive integer.

If digits follow any spaces and they are not terminated by a zero then
   the return value is the positive integer.

If the first character following spaces in not a digit or the end of
string is encountered then
   -1 is returned as the value
   pParseVars->status is set to STATUS_SYNTAX_ERROR

Note: does not check for overflow
*/
int GetPositiveInteger(ParseVarsType *pParseVars)
{
   int   value;
   LPSTR pIn;
   BYTE  c;

   if ( !SkipOverSpaces(pParseVars) )
      {
      if ( pParseVars->status == STATUS_REACHED_FF )
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(-1);
      }

   pIn = pParseVars->pInPJL_Local;
   for ( value=0; ((c=*pIn++)>='0')&&(c<='9'); value=value*10+(c-'0') );
   if ( (c==0)||(pIn==pParseVars->pInPJL_Local+1) )
      {
      /* either end of string encountered or no digits found */
      if ( c==0 )
         {
         pParseVars->status = STATUS_END_OF_STRING;
         }
      else
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      pParseVars->pInPJL_Local = pIn-1;
      return(-1);
      }
   pParseVars->pInPJL_Local = pIn-1;
   return(value);
}



void SetNewList(ParseVarsType *pParseVars, ParamType param)
{
   pParseVars->arrayOfLists[0] = param.pList;
   pParseVars->arrayOfLists[1] = NULL;
   return;
}

void StoreToken(ParseVarsType *pParseVars, DWORD dwToken)
{
   pParseVars->dwNextToken = dwToken;
   return;
}

BOOL StoreTokenValueAndAdvancePointer(ParseVarsType *pParseVars, UINT_PTR dwValue)
{
   if ( pParseVars->nTokenLeft==0 )
      {
      pParseVars->status = STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS;
      return(FALSE);
      }
   pParseVars->pToken_Local->token = pParseVars->dwNextToken;
   pParseVars->pToken_Local->value = dwValue;
   pParseVars->pToken_Local++;
   pParseVars->nTokenInBuffer_Local++;
   pParseVars->nTokenLeft--;
   return(TRUE);
}


void GetTotalAndLargestFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars, "TOTAL=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_TOTAL);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nLARGEST=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_MEMORY_LARGEST);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}

void GetCodeAndOnlineFF(ParseVarsType *pParseVars, ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   if ( !ExpectString(pParseVars,"CODE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_CODE);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "\r\nDISPLAY=") )
      {
      return;
      }
   if ( !SkipPastNextCRLF(pParseVars) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, "ONLINE=") )
      {
      return;
      }
   StoreToken(pParseVars, TOKEN_INFO_STATUS_ONLINE);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;
   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


/*
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)

This function looks for a match of the current stream
position with pString.

If a match is found:
   pParseVars->pInPJL_Local is set to point just past the string.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the string is found then
   pParseVars->pInPJL_Local is set to point just past the FF.
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL ExpectString(ParseVarsType *pParseVars, LPSTR pString)
{
LPSTR pIn = pParseVars->pInPJL_Local;
LPSTR pS = pString;
BYTE  s, in;

   while ( ((s=*pS) != 0) && ((in=*pIn)!=0) && (in!=FF) && (s==in) )
      {
      pS++;
      pIn++;
      }

   if ( s==0 )
      {
      /* The whole string matched  */
      /* point to character after string in input */
      pParseVars->pInPJL_Local = pIn;
      return(TRUE);
      }

   pParseVars->status = ( in!=0 )?
      STATUS_SYNTAX_ERROR:STATUS_END_OF_STRING;
      pParseVars->pInPJL_Local = pIn;
   return(FALSE);
}




/*
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)

This function positions the stream pointer past the next
CRLF.

If a CRLF is found:
   pParseVars->pInPJL_Local is set to point just past the CRLF.
   the return value is TRUE
   (pParseVars->status is unchanged)

If the end of input is encountered before the CRLF is found then
   pParseVars->pInPJL_Local is set to point to the terminating 0.
   the return value is FALSE
   pParseVars->status is set to STATUS_END_OF_STRING

If an FF is encountered before the CRLF is found then
   the return value is FALSE
   pParseVars->status is set to STATUS_SYNTAX_ERROR
*/
BOOL SkipPastNextCRLF(ParseVarsType *pParseVars)
{
   if ( !AdvancePointerPastString(pParseVars, "\r\n") )
      {
      if ( pParseVars->status == STATUS_REACHED_FF)
         {
         pParseVars->status = STATUS_SYNTAX_ERROR;
         }
      return(FALSE);
      }
   return(TRUE);
}


void GetTokenFromIndexSetNewList(ParseVarsType *pParseVars, ParamType param)
{
   StoreToken(pParseVars,
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   SetNewList(pParseVars, param);
   return;
}


void SetValueFromParamFF(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   ExpectFinalCRLFFF(pParseVars);
   return;
}


void SetValueFromParam(ParseVarsType *pParseVars, ParamType param)
{
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, param.value) )
      {
      return;
      }
   return;
}

void ActionNotFoundSkipCFLFandIndentedLines(ParseVarsType *pParseVars)
{
   DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF In=%hs\n", pParseVars->pInPJL_Local));

   do
      {
      if ( !SkipPastNextCRLF(pParseVars) )
         {

         DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF error skipping\n"));

         return;
         }
      } while (*pParseVars->pInPJL_Local==TAB);

   DBGMSG(DBG_TRACE, ("ActionNotFoundSkipCRLF Out=%hs\n", pParseVars->pInPJL_Local));

   return;
}

void GetTokenFromIndexValueFromNumberEOLFromParam
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromNumberIn=%hs\n", pParseVars->pInPJL_Local));

   StoreToken(pParseVars,
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   if ( (value=GetPositiveInteger(pParseVars))==-1 )
      {
      /* Not a valid number - status set by GetPositiveInteger() */

      DBGMSG(DBG_TRACE, ("error getting number\n"));

      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {

      DBGMSG(DBG_TRACE, ("error storing value\n"));

      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromNumberOut=%hs\n", pParseVars->pInPJL_Local));

   return;
}

void GetTokenFromIndexValueFromBooleanEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   int value;

   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromBooleanEOLin=%hs\n", pParseVars->pInPJL_Local));

   StoreToken(pParseVars,
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);
   pParseVars->pCurrentKeywords = FALSEandTRUEKeywords;

   if ( (value=LookForKeyword(pParseVars))==-1 )
      {
      /* Not TRUE or FALSE */
      pParseVars->status = STATUS_SYNTAX_ERROR;
      return;
      }
   if ( !StoreTokenValueAndAdvancePointer(pParseVars, value) )
      {
      return;
      }
   if ( !ExpectString(pParseVars, param.lpstr) )
      {
      return;
      }

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromBooleanEOLout=%hs\n", pParseVars->pInPJL_Local));

   return;
}

void GetTokenFromIndexValueFromStringEOL
   (ParseVarsType *pParseVars,ParamType param)
{
   param; /* to eliminate not used warning */

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromStringEOLin=%hs\n", pParseVars->pInPJL_Local));


   StoreToken(pParseVars,
      pParseVars->pCurrentList->tokenBaseValue+pParseVars->dwFoundIndex);

   if ( !StoreTokenValueAndAdvancePointer(pParseVars, (UINT_PTR)pParseVars->pInPJL_Local))
      {
      return;
      }
   SkipPastNextCRLF(pParseVars);

   DBGMSG(DBG_TRACE, ("GetTokenFromIndexValueFromStringEOLout=%hs\n", pParseVars->pInPJL_Local));

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\pjlmon.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation
All Rights Reserved


Module Name:

Abstract:

Author:

Revision History:

--*/

#define USECOMM

#include "precomp.h"
#include <winioctl.h>
#include <ntddpar.h>


// ---------------------------------------------------------------------
// PROTO, CONSTANT, and GLOBAL
//
// ---------------------------------------------------------------------

DWORD   ProcessPJLString(PINIPORT, CHAR *, DWORD *);
VOID    ProcessParserError(DWORD);
VOID    InterpreteTokens(PINIPORT, PTOKENPAIR, DWORD);
BOOL    IsPJL(PINIPORT);
BOOL    WriteCommand(HANDLE, LPSTR);
BOOL    ReadCommand(HANDLE);

#define WAIT_FOR_WRITE                  100 // 0.1 sec
#define WAIT_FOR_DATA_TIMEOUT           100 // 0.1 sec
#define WAIT_FOR_USTATUS_THREAD_TIMEOUT 500 // 0.5 sec
#define GETDEVICEID                     IOCTL_PAR_QUERY_DEVICE_ID
#define MAX_DEVID                       1024

TCHAR   cszInstalledMemory[]    = TEXT("Installed Memory");
TCHAR   cszAvailableMemory[]    = TEXT("Available Memory");

BOOL
DllMain(
    IN HANDLE   hModule,
    IN DWORD    dwReason,
    IN LPVOID   lpRes
    )
/*++

Routine Description:
    Dll entry point

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&pjlMonSection);
            DisableThreadLibraryCalls(hModule);
            break;

        default:
            // do nothing
            ;
    }

    return TRUE;
}


VOID
ClearPrinterStatusAndIniJobs(
    PINIPORT    pIniPort
    )
{
    PORT_INFO_3 PortInfo3;

    if ( pIniPort->PrinterStatus ||
         (pIniPort->status & PP_PRINTER_OFFLINE) ) {

        pIniPort->PrinterStatus = 0;
        pIniPort->status &= ~PP_PRINTER_OFFLINE;

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        SetPort(NULL, pIniPort->pszPortName, 3, (LPBYTE)&PortInfo3);
    }

    SendJobLastPageEjected(pIniPort, ALL_JOBS, FALSE);
}


VOID
RefreshPrinterInfo(
    PINIPORT    pIniPort
    )
{
    //
    // Only one thread should write to the printer at a time
    //
    if ( WAIT_OBJECT_0 != WaitForSingleObject(pIniPort->DoneWriting,
                                              WAIT_FOR_WRITE) ) {

        return;
    }

    //
    // If printer is power cycled and it does not talk back (but answers
    // PnP id) we got to clear the error on spooler to send jobs
    //
    ClearPrinterStatusAndIniJobs(pIniPort);
    if ( !IsPJL(pIniPort) ) {

        pIniPort->status &= ~PP_IS_PJL;
    }

    SetEvent(pIniPort->DoneWriting);
}


VOID
UstatusThread(
    HANDLE hPort
)
/*++

Routine Description:
    Unsolicited status information thread. This thread will continue to
    read unsolicited until it's asked to terminate, which will happen
    under one of these conditions:
        1) Receive EOJ confirmation from the printer.
        2) Timeout waiting for EOJ confirmation.
        3) The port is been closed.

Arguments:
    hPort   : IniPort structure for the port

Return Value:

--*/
{
    PINIPORT        pIniPort = (PINIPORT)((INIPORT *)hPort);
    HANDLE          hToken;

    SPLASSERT(pIniPort                              &&
              pIniPort->signature == PJ_SIGNATURE   &&
              (pIniPort->status & PP_THREAD_RUNNING) == 0);

    if ( IsPJL(pIniPort) )
        pIniPort->status |= PP_IS_PJL;


    SetEvent(pIniPort->DoneWriting);

    if ( !(pIniPort->status & PP_IS_PJL) )
        goto StopThread;

    pIniPort->status |= PP_THREAD_RUNNING;

    pIniPort->PrinterStatus     = 0;
    pIniPort->status           &= ~PP_PRINTER_OFFLINE;
    pIniPort->dwLastReadTime    = GetTickCount ();

    for ( ; ; ) {

        //
        // check if PP_RUN_THREAD has been cleared to terminate
        //
        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            if ( pIniPort->status & PP_INSTARTDOC ) {

                //
                // there's an active job, can't end the thread
                //
                pIniPort->status |= PP_RUN_THREAD;
            } else {

                DBGMSG(DBG_INFO,
                       ("PJLMon Read Thread for Port %ws Closing Down.\n",
                       pIniPort->pszPortName));

                pIniPort->status &= ~PP_THREAD_RUNNING;

                ClearPrinterStatusAndIniJobs(pIniPort);
                goto StopThread;
            }
        }

        //
        // check if the printer is bi-di
        //
        if (pIniPort->status & PP_IS_PJL) {

            (VOID)ReadCommand(hPort);

            //
            // If we are under error condition or if we have jobs pending
            // read status back from printer more frequently
            //
            if ( pIniPort->pIniJob                          ||
                 (pIniPort->status & PP_PRINTER_OFFLINE)    ||
                 (pIniPort->status & PP_WRITE_ERROR) ) {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadErrorTimeout);
            } else {

                WaitForSingleObject(pIniPort->WakeUp,
                                    dwReadThreadIdleTimeoutOther);
            }

            if ( pIniPort->pIniJob &&
                 !(pIniPort->status & PP_PRINTER_OFFLINE) &&
                 !(pIniPort->status & PP_WRITE_ERROR) ) {

                //
                // Some printers are PJL bi-di, but do not send
                // EOJ. We want jobs to disappear from printman
                //
                SendJobLastPageEjected(pIniPort,
                                       GetTickCount() - dwReadThreadEOJTimeout,
                                       TRUE);
            }

            //
            // If we did not read from printer for more than a minute
            // and no more jobs talk to printer again
            //
            if ( !(pIniPort->status & PP_INSTARTDOC) &&
                 (GetTickCount() - pIniPort->dwLastReadTime) > 240000
)
                RefreshPrinterInfo(pIniPort);

        } else {

            //
            // exit the thread if printer is not PJL bi-di capable
            //
            Sleep(2000);
            pIniPort->status &= ~PP_RUN_THREAD;

            DBGMSG(DBG_TRACE, ("Set ~PP_RUN_THREAD because printer is not bi-di\n"));
        }
    }

StopThread:
    pIniPort->status &= ~PP_RUN_THREAD;
    pIniPort->status &= ~PP_THREAD_RUNNING;
}


BOOL
CreateUstatusThread(
    PINIPORT pIniPort
)
/*++

Routine Description:
    Creates the Ustatus thread

Arguments:
    pIniPort    : IniPort structure for the port

Return Value:
    TRUE on succesfully creating the thread, else FALSE
--*/
{
    HANDLE  ThreadHandle;
    DWORD   ThreadId;

    DBGMSG(DBG_INFO, ("PJLMon Read Thread for Port %ws Starting.\n",
                      pIniPort->pszPortName));
    if (pIniPort->hUstatusThread)
    {
        //
        // Make sure there is no running UstatusThread
        //
        pIniPort->status &= ~PP_RUN_THREAD;
        SetEvent (pIniPort->WakeUp);
        WaitForSingleObject (pIniPort->hUstatusThread, INFINITE);
        CloseHandle (pIniPort->hUstatusThread);
        pIniPort->hUstatusThread = NULL;
    }

    pIniPort->status |= PP_RUN_THREAD;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    //
    // Initialize events
    //
    ResetEvent (pIniPort->WakeUp);
    SetEvent   (pIniPort->DoneReading);

    ThreadHandle = CreateThread(NULL, 16*1024,
                                (LPTHREAD_START_ROUTINE)UstatusThread,
                                pIniPort,
                                0, &ThreadId);

    if ( ThreadHandle ) {

        SetThreadPriority(ThreadHandle, THREAD_PRIORITY_LOWEST);
        pIniPort-> hUstatusThread = ThreadHandle;
        return TRUE;
    }
    else
    {
        pIniPort->status &= ~PP_RUN_THREAD;
        SetEvent(pIniPort->DoneWriting);
        return FALSE;
    }
}


BOOL
WINAPI
PJLMonOpenPortEx(
    IN     LPTSTR       pszPortName,
    IN     LPTSTR       pszPrinterName,
    IN OUT LPHANDLE     pHandle,
    IN OUT LPMONITOR    pMonitor
)
/*++

Routine Description:
    Opens the port

Arguments:
    pszPortName     : Port name
    pszPrinterName  : Printer name
    pHandle         : Pointer to the handle to return
    pMonitor        : Port monitor function table

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort;
    BOOL        bRet = FALSE;
    BOOL        bInSem = FALSE;

    //
    // Validate port monitor
    //
    if ( !pMonitor                  ||
         !pMonitor->pfnOpenPort     ||
         !pMonitor->pfnStartDocPort ||
         !pMonitor->pfnWritePort    ||
         !pMonitor->pfnReadPort     ||
         !pMonitor->pfnClosePort ) {


        DBGMSG(DBG_WARNING,
               ("PjlMon: Invalid port monitors passed to OpenPortEx\n"));
        SetLastError(ERROR_INVALID_PRINT_MONITOR);
        goto Cleanup;
    }

    EnterSplSem();
    bInSem = TRUE;

    //
    // Is the port open already?
    //
    if ( pIniPort = FindIniPort(pszPortName) ) {

        SetLastError(ERROR_BUSY);
        goto Cleanup;
    }

    pIniPort = CreatePortEntry(pszPortName);
    LeaveSplSem();
    bInSem = FALSE;

    if ( pIniPort &&
         (*pMonitor->pfnOpenPort)(pszPortName, &pIniPort->hPort) ) {

        *pHandle = pIniPort;
        CopyMemory((LPBYTE)&pIniPort->fn, (LPBYTE)pMonitor, sizeof(*pMonitor));

        //
        // Create the ustatus thread always
        // If printer is not PJL it will die by itself
        // We do not want to write to the printer in this thread to determine
        //      printer is PJL since that may take several seconds to fail
        //
        CreateUstatusThread(pIniPort);
        bRet = TRUE;
    } else {

        DBGMSG(DBG_WARNING, ("PjlMon: OpenPort "TSTR" : Failed\n", pszPortName));
    }

Cleanup:
    if ( bInSem ) {

        LeaveSplSem();
    }
    SplOutSem();

    return bRet;
}


BOOL
WINAPI
PJLMonStartDocPort(
    IN HANDLE  hPort,
    IN LPTSTR  pszPrinterName,
    IN DWORD   dwJobId,
    IN DWORD   dwLevel,
    IN LPBYTE  pDocInfo
)
/*++

Routine Description:
    Language monitor StartDocPort

Arguments:
    hPort           : Port handle
    pszPrinterName  : Printer name
    dwJobId         : Job identifier
    dwLevel         : Level of Doc info strucuture
    pDocInfo        : Pointer to doc info structure

Return Value:
    TRUE on success, FALSE on error

--*/
{

    PINIPORT            pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB             pIniJob = NULL;
    DWORD               cbJob;
    BOOL                bRet = FALSE;

    //
    // Validate parameters
    //
    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ||
         !pDocInfo ||
         !pszPrinterName ||
         !*pszPrinterName ) {

        SPLASSERT(pIniPort &&
                  pIniPort->signature == PJ_SIGNATURE &&
                  pDocInfo);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwLevel != 1 ) {

        SPLASSERT(dwLevel == 1);
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // Serialize access to the port
    //
    if ( pIniPort->status & PP_INSTARTDOC ) {

        SetLastError(ERROR_BUSY);
        return FALSE;
    }

    cbJob   = sizeof(*pIniJob) + lstrlen(pszPrinterName) * sizeof(TCHAR)
                               + sizeof(TCHAR);
    pIniJob = (PINIJOB) AllocSplMem(cbJob);
    if ( !pIniJob ) {

        goto Cleanup;
    }

    pIniJob->pszPrinterName = (LPTSTR) (pIniJob + 1);
    StringCbCopy (pIniJob->pszPrinterName, cbJob - sizeof (*pIniJob), pszPrinterName);


    if ( !OpenPrinter(pIniJob->pszPrinterName, &pIniJob->hPrinter, NULL) ) {

        DBGMSG(DBG_WARNING,
               ("pjlmon: OpenPrinter failed for "TSTR", last error %d\n",
                pIniJob->pszPrinterName, GetLastError()));

        goto Cleanup;
    }

    pIniPort->status |= PP_INSTARTDOC;

    bRet = (*pIniPort->fn.pfnStartDocPort)(pIniPort->hPort,
                                           pszPrinterName,
                                           dwJobId,
                                           dwLevel,
                                           pDocInfo);

    if ( !bRet ) {

        pIniPort->status &= ~PP_INSTARTDOC;
        goto Cleanup;
    }

    //
    // If Ustatus thread is not running then check if printer understands
    // PJL, unless we determined that printer does not understand PJL earlier
    //
    if ( !(pIniPort->status & PP_RUN_THREAD) &&
         !(pIniPort->status & PP_DONT_TRY_PJL) ) {

        CreateUstatusThread(pIniPort);
    }

    //
    // set PP_SEND_PJL flag here so the first write of the job
    // will try to send PJL command to initiate the job control
    //

    pIniJob->JobId = dwJobId;
    pIniJob->status |= PP_INSTARTDOC;

    EnterSplSem();
    if ( !pIniPort->pIniJob ) {

        pIniPort->pIniJob = pIniJob;
    } else {

        pIniJob->pNext = pIniPort->pIniJob;
        pIniPort->pIniJob = pIniJob;
    }
    LeaveSplSem();

    if ( pIniPort->status & PP_IS_PJL )
        pIniJob->status |= PP_SEND_PJL;

    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

Cleanup:

    if ( !bRet ) {

        if ( pIniJob )
            FreeIniJob(pIniJob);
    }

    return bRet;
}


BOOL
WINAPI
PJLMonReadPort(
    IN  HANDLE  hPort,
    OUT LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD pcbRead
)
/*++

Routine Description:
    Language monitor ReadPort

Arguments:
    hPort           : Port handle
    pBuffer         : Buffer to read data to
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return read count

Return Value:
    TRUE on success, FALSE on error
--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return (*pIniPort->fn.pfnReadPort)(pIniPort->hPort, pBuffer, cbBuf, pcbRead);
}


BOOL
WINAPI
PJLMonWritePort(
    IN  HANDLE  hPort,
    IN  LPBYTE  pBuffer,
    IN  DWORD   cbBuf,
    IN  LPDWORD pcbWritten
)
/*++

Routine Description:
    Language monitor WritePort

Arguments:
    hPort           : Port handle
    pBuffer         : Data Buffer
    cbBuf           : Buffer size
    pcbRead         : Pointer to the variable to return written count

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        ret;

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's the fist write of the job
    //
    if ( pIniPort->pIniJob &&
         (pIniPort->pIniJob->status & PP_SEND_PJL) ) {

        // PP_SEND_PJL is set if it's the first write of the job
        char string[256];

        if ( !WriteCommand(hPort, "\033%-12345X@PJL \015\012") ) {

            return FALSE;
        }

        //
        // clear PP_SEND_PJL here if we have successfully send a PJL command.
        //
        pIniPort->pIniJob->status &= ~PP_SEND_PJL;

        //
        // set PP_PJL_SENT meaning that we have successfully sent a
        // PJL command to the printer, though it doesn't mean that
        // we will get a successfully read. PP_PJL_SENT gets cleared in
        // StartDocPort.
        //
        pIniPort->pIniJob->status |= PP_PJL_SENT;

        StringCchPrintfA (string, COUNTOF (string), "@PJL JOB NAME = \"MSJOB %d\"\015\012",
                    pIniPort->pIniJob->JobId);

        WriteCommand(hPort, string);
        WriteCommand(hPort, "@PJL USTATUS JOB = ON \015\012@PJL USTATUS PAGE = OFF \015\012@PJL USTATUS DEVICE = ON \015\012@PJL USTATUS TIMED = 30 \015\012\033%-12345X");
    }

    //
    // writing to port monitor
    //
    ret = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, pBuffer,
                                       cbBuf, pcbWritten);

    if ( ret ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
    }

    if ( (!ret || pIniPort->PrinterStatus) &&
         (pIniPort->status & PP_THREAD_RUNNING) ) {

        //
        // By waiting for the UStatus thread to finish reading if there
        // is an error and printer sends unsolicited status
        // and user gets status on queue view before the win32 popup
        //
        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, INFINITE);
    }

    return ret;
}


BOOL
WINAPI
PJLMonEndDocPort(
   HANDLE   hPort
)
/*++

Routine Description:
    Language monitor EndDocPort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    PINIJOB     pIniJob;

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Find the job (which is the last)
    //
    pIniJob = pIniPort->pIniJob;

    if ( !pIniJob )
        DBGMSG(DBG_ERROR, ("No jobs?\n"));

    //
    // check if we had sent PJL command, i.e. if the printer is bi-di
    //
    if ( pIniJob && (pIniJob->status & PP_PJL_SENT) ) {

        //
        // if the printer is bi-di, tell printer to let us know when the job
        // is don't in the printer and we'll really EndDoc then. this is so
        // that we can continue to monitor the job status until the job is
        // really done in case there's an error occurs.
        // but some cheap printers like 4L, doesn't handle this EOJ command
        // reliably, so we time out if printer doesn't tell us EOJ after a
        // while so that we don't end up having the port open forever in this
        // case.
        //

        char    string[256];
        StringCchPrintfA (string, COUNTOF (string),
                "\033%%-12345X@PJL EOJ NAME = \"MSJOB %d\"\015\012\033%%-12345X",
                pIniPort->pIniJob->JobId);
        WriteCommand(hPort, string);
        pIniJob->TimeoutCount = GetTickCount();
        pIniJob->status &= ~PP_INSTARTDOC;
    }

    (*pIniPort->fn.pfnEndDocPort)(pIniPort->hPort);

    if ( pIniJob && !(pIniJob->status & PP_PJL_SENT) ) {

        //
        // This is not bi-di printer send EOJ so that spooler deletes it
        //
        SendJobLastPageEjected(pIniPort, pIniJob->JobId, FALSE);
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    // wake up the UStatus read thread if printer is bi-di

    if ( pIniPort->status & PP_THREAD_RUNNING )
        SetEvent(pIniPort->WakeUp);

    SetEvent(pIniPort->DoneWriting);

    return TRUE;
}


BOOL
WINAPI
PJLMonClosePort(
    HANDLE  hPort
)
/*++

Routine Description:
    Language monitor ClosePort

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    if ( !pIniPort ||
         pIniPort->signature != PJ_SIGNATURE ) {

        SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pIniPort->status &= ~PP_INSTARTDOC;

    //
    // Kill Ustatus thread if it is running
    //
    if (pIniPort-> hUstatusThread)
    {
        pIniPort->status &= ~PP_RUN_THREAD;
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject (pIniPort-> hUstatusThread, INFINITE);
    }
    if ( pIniPort->fn.pfnClosePort )
        (*pIniPort->fn.pfnClosePort)(pIniPort->hPort);

    EnterSplSem();
    DeletePortEntry(pIniPort);
    LeaveSplSem();

    return TRUE;
}


BOOL
WriteCommand(
    HANDLE hPort,
    LPSTR cmd
)
/*++

Routine Description:
    Write a command to the port

Arguments:
    hPort           : Port handle
    cmd             : Command buffer

Return Value:
    TRUE on success, FALSE on error

--*/
{
    DWORD cbWrite, cbWritten, dwRet;
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);

    cbWrite = strlen(cmd);

    dwRet = (*pIniPort->fn.pfnWritePort)(pIniPort->hPort, cmd, cbWrite, &cbWritten);

    if ( dwRet ) {

        pIniPort->status &= ~PP_WRITE_ERROR;
    } else {

        pIniPort->status |= PP_WRITE_ERROR;
        DBGMSG(DBG_INFO, ("PJLMON!No data Written\n"));
        if ( pIniPort->status & PP_THREAD_RUNNING )
            SetEvent(pIniPort->WakeUp);
    }

    return dwRet;
}


#define CBSTRING 1024

BOOL
ReadCommand(
    HANDLE hPort
)
/*++

Routine Description:
    Read a command from the port

Arguments:
    hPort           : Port handle

Return Value:
    TRUE on successfully reading one or more commands, FALSE on error
--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    DWORD       cbRead, cbToRead, cbProcessed, cbPrevious;
    char        string[CBSTRING];
    DWORD       status = STATUS_SYNTAX_ERROR; //Value should not matter
    BOOL        bRet=FALSE;

    cbPrevious = 0;

    ResetEvent(pIniPort->DoneReading);

    cbToRead = CBSTRING - 1;

    for ( ; ; ) {

        if ( !PJLMonReadPort(hPort, &string[cbPrevious], cbToRead, &cbRead) )
            break;
        if ( cbRead ) {
            if (cbPrevious + cbRead > CBSTRING - 1)
            {
                bRet = FALSE;
                break;
            }
            string[cbPrevious + cbRead] = '\0';
            status = ProcessPJLString(pIniPort, string, &cbProcessed);
            if ( cbProcessed )
                bRet = TRUE;

            if (status == STATUS_END_OF_STRING ) {

                if ( cbProcessed )
                {
                    size_t cbUnprocessed = min (
                        strlen (string + cbProcessed) + 1,
                        COUNTOF (string) - cbProcessed
                        ) * sizeof (string [0]);
                    memmove (string, string + cbProcessed, cbUnprocessed);
                }
                cbPrevious = cbRead + cbPrevious - cbProcessed;
            }
        } else {

            SPLASSERT(!cbPrevious);
        }

        if ( status != STATUS_END_OF_STRING && cbRead != cbToRead )
            break;

        cbToRead = CBSTRING - cbPrevious - 1;
        if ( cbToRead == 0 )
        {
            DBGMSG(DBG_ERROR,
                   ("ReadCommand cbToRead is 0 (buffer too small)\n"));
            bRet = FALSE;
            break;
        }
        Sleep(WAIT_FOR_DATA_TIMEOUT);
    }

    SetEvent(pIniPort->DoneReading);

    //
    // Update the time we last read from printer
    //
    if ( bRet )
        pIniPort->dwLastReadTime = GetTickCount();

    return bRet;
}


BOOL
WINAPI
PJLMonGetPrinterDataFromPort(
    HANDLE   hPort,
    DWORD   ControlID,
    LPTSTR  pValueName,
    LPTSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPTSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
)
/*++

Routine Description:
    GetPrinter data from port. Supports predefined commands/valuenames.

    When we support Value name commands (not supported by DeviceIoControl)
    we should check for startdoc

    This monitor function supports the following two functionalities,

         1. Allow spooler or language monitor to call DeviceIoControl to get
            information from the port driver vxd, i.e. ControlID != 0.
            And only port monitor support this functionality, language monitor
            doesn't, so language monitor just pass this kind of calls down to
            port monitor.

         2. Allow app or printer driver query language monitor for some device
            information by specifying some key names that both parties understand,
            i.e. ControlID == 0 && pValueName != 0. So when printer driver call
            DrvGetPrinterData DDI, gdi will call spooler -> language monitor
            to get specific device information, for example, UNIDRV does this
            to get installed printer memory from PJL printers thru PJLMON.
            Only language monitor support this functionality,
            port monitor doesn't.

Arguments:
    hPort           : Port handle
    ControId        : Control id
    pValueName      : Value name
    lpInBuffer      : Input buffer for the command
    cbinBuffer      : Input buffer size
    lpOutBuffer     : Output buffer
    cbOutBuffer     : Output buffer size
    lpcbReturned    : Set to the amount of data in output buffer on success

Return Value:
    TRUE on success, FALSE on error

--*/
{
    PINIPORT    pIniPort = (PINIPORT)((INIPORT *)hPort);
    BOOL        bRet = FALSE, bStopUstatusThread = FALSE;

    SPLASSERT(pIniPort && pIniPort->signature == PJ_SIGNATURE);
    if ( ControlID ) {

        if ( !pIniPort->fn.pfnGetPrinterDataFromPort ) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return (*pIniPort->fn.pfnGetPrinterDataFromPort)(
                        pIniPort->hPort,
                        ControlID,
                        pValueName,
                        lpInBuffer,
                        cbInBuffer,
                        lpOutBuffer,
                        cbOutBuffer,
                        lpcbReturned);
    }

    //
    // Only 2 keys supported
    //
    if ( lstrcmpi(pValueName, cszInstalledMemory)   &&
         lstrcmpi(pValueName, cszAvailableMemory) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Wait for crrent job to print since we can't send a PJL command
    // in the middle of job
    //
    WaitForSingleObject(pIniPort->DoneWriting, INFINITE);

    // make sure the first write succeeds
    // The multi-language printers (4M, 4ML, 4MP, 4V, 4SI), if you print a
    // PS print job, the memory resources claimed by the PS processor are not
    // release until you enter PCL or reset the printer with "EscE".
    //
    // So if we had just printed a PS job, the available memory will be
    // incorrect if we don't have the "EscE" here.

    if ( (pIniPort->status & PP_IS_PJL) &&
         WriteCommand(hPort, "\033E\033%-12345X@PJL INFO CONFIG\015\012") ) {

        if ( !(pIniPort->status & PP_RUN_THREAD) ) {

            bStopUstatusThread = TRUE;
            CreateUstatusThread(pIniPort);
        }

        // PJLMON currently only supports the following pValueName
        //  1. installed printer memory
        //  2. available printer memory

        if ( !lstrcmpi(pValueName, cszInstalledMemory) )
            pIniPort->dwInstalledMemory = 0;
        else if (!lstrcmpi(pValueName, cszAvailableMemory))
            pIniPort->dwAvailableMemory = 0;

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        WriteCommand(hPort,
                     "@PJL INFO MEMORY\015\012@PJL INFO STATUS\015\012");

        ResetEvent(pIniPort->DoneReading);
        SetEvent(pIniPort->WakeUp);
        WaitForSingleObject(pIniPort->DoneReading, READTHREADTIMEOUT);

        if ( bStopUstatusThread ) {

            pIniPort->status &= ~PP_RUN_THREAD;
            SetEvent(pIniPort->WakeUp);
        }

        if ( !lstrcmpi(pValueName, cszInstalledMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                pIniPort->dwInstalledMemory ) {

                *((LPDWORD)lpOutBuffer) = pIniPort->dwInstalledMemory;

                bRet = TRUE;
            }
        } else if ( !lstrcmpi(pValueName, cszAvailableMemory) ) {

            *lpcbReturned = sizeof(DWORD);

            if ( lpOutBuffer &&
                 cbOutBuffer >= sizeof(DWORD) &&
                 pIniPort->dwAvailableMemory)
            {
                *((LPDWORD)lpOutBuffer) = pIniPort->dwAvailableMemory;

                bRet = TRUE;
            }
        }

        if ( bStopUstatusThread ) {
            WaitForSingleObject (pIniPort-> hUstatusThread, INFINITE);
        }

    }

    if ( !bRet )
        SetLastError(ERROR_INVALID_PARAMETER);

    SetEvent(pIniPort->DoneWriting);

    return bRet;
}


MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        NULL,                           // EnumPrinters not supported
        NULL,                           // OpenPort  not supported
        PJLMonOpenPortEx,
        PJLMonStartDocPort,
        PJLMonWritePort,
        PJLMonReadPort,
        PJLMonEndDocPort,
        PJLMonClosePort,
        NULL,                           // AddPort not supported
        NULL,                           // AddPortEx not supported
        NULL,                           // ConfigurePort not supported
        NULL,                           // DeletePort not supported
        PJLMonGetPrinterDataFromPort,
        NULL                            // SetPortTimeOuts not supported
    }
};


LPMONITOREX
WINAPI
InitializePrintMonitor(
    IN     LPTSTR      pszRegistryRoot
)
/*++

Routine Description:
    Fill the monitor function table. Spooler makes call to this routine
    to get the monitor functions.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll
    lpMonitor       : Pointer to monitor fucntion table to be filled

Return Value:
    TRUE on successfully initializing the monitor, false on error.

--*/
{

    if ( !pszRegistryRoot || !*pszRegistryRoot ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if ( UpdateTimeoutsFromRegistry(pszRegistryRoot) != ERROR_SUCCESS ) {

        return NULL;
    }


    return &MonitorEx;
}


#define NTOKEN  20

DWORD
ProcessPJLString(
    PINIPORT    pIniPort,
    LPSTR       pInString,
    DWORD      *lpcbProcessed
)
/*++

Routine Description:
    Process a PJL string read from the printer

Arguments:
    pIniPort        : Ini port
    pInString       : Input string to process
    lpcbProcessed   : On return set to the amount of data processed

Return Value:
    Status value of the processing

--*/
{
    TOKENPAIR tokenPairs[NTOKEN];
    DWORD nTokenParsedRet;
    LPSTR lpRet;
    DWORD status = 0;

    lpRet = pInString;

    DBGMSG(DBG_TRACE, ("String to process: <"TSTR">\n", pInString));

    for (*lpcbProcessed = 0; *pInString != 0; pInString = lpRet) {

        //
        // Determine if printer is bi-di.  LJ 4 does not have p1284
        // device ID so we do PCL memory query and see if it returns anything
        //
        if (!(pIniPort->status & PP_IS_PJL) &&
            !mystrncmp(pInString, "PCL\015\012INFO MEMORY", 16) )
            pIniPort->status |= PP_IS_PJL;

        status = GetPJLTokens(pInString, NTOKEN, tokenPairs,
                              &nTokenParsedRet, &lpRet);

        if (status == STATUS_REACHED_END_OF_COMMAND_OK) {

            pIniPort->status |= PP_IS_PJL;
            InterpreteTokens(pIniPort, tokenPairs, nTokenParsedRet);
        } else {

            ProcessParserError(status);
        }

        //
        // if a PJL command straddles between buffers
        //
        if (status == STATUS_END_OF_STRING)
            break;

        *lpcbProcessed += (DWORD)(lpRet - pInString);
    }

    return status;
}


DWORD
SeverityFromPjlStatus(
    DWORD   dwPjlStatus
    )
{
    if ( dwPjlStatus >= 10000 && dwPjlStatus < 12000 ) {

        //
        // 10xyz
        // 11xyz : load paper (paper available on another tray)
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus >= 30000 && dwPjlStatus < 31000 ) {

        //
        // 30xyz : Auto continuable errors
        //
        return PORT_STATUS_TYPE_WARNING;

    } else if ( dwPjlStatus >= 35000 && dwPjlStatus < 36000 ) {

        //
        // 35xyz : Potential operator intervention conditions
        //
        return PORT_STATUS_TYPE_WARNING;
    } else if ( dwPjlStatus > 40000 && dwPjlStatus < 42000 ) {

        //
        // 40xyz : Operator intervention required
        // 41xyz : Load paper errors
        //
        return PORT_STATUS_TYPE_ERROR;
    }

    DBGMSG(DBG_ERROR,
           ("SeverityFromPjlStatus: Unknown status %d\n", dwPjlStatus));
    return PORT_STATUS_TYPE_INFO;
}


VOID
InterpreteTokens(
    PINIPORT pIniPort,
    PTOKENPAIR tokenPairs,
    DWORD nTokenParsed
)
/*++

Routine Description:
    Interpret succesfully read PJL tokens

Arguments:
    pIniPort        : Ini port
    tokenPairs      : List of token pairs
    nTokenParsed    : Number of token pairs

Return Value:
    None

--*/
{
    DWORD                   i, OldStatus;
    PJLTOPRINTERSTATUS     *pMap;
    PORT_INFO_3             PortInfo3;
    DWORD                   dwSeverity = 0;
    HANDLE                  hToken;

    OldStatus = pIniPort->PrinterStatus;
    pIniPort->PrinterStatus = 0;

    for (i = 0; i < nTokenParsed; i++) {

        // DBGMSG(DBG_INFO, ("pjlmon!Token=0x%x, Value=%d\n",
        //                   tokenPairs[i].token, tokenPairs[i].value));

        switch(tokenPairs[i].token) {

        case TOKEN_INFO_STATUS_CODE:
        case TOKEN_USTATUS_DEVICE_CODE:

            for (pMap = PJLToStatus; pMap->pjl; pMap++) {

                if (pMap->pjl == tokenPairs[i].value) {

                    pIniPort->PrinterStatus = pMap->status;
                    dwSeverity = SeverityFromPjlStatus(pMap->pjl);
                    if ( dwSeverity == PORT_STATUS_TYPE_ERROR )
                        pIniPort->status |= PP_PRINTER_OFFLINE;
                    else
                        pIniPort->status &= ~PP_PRINTER_OFFLINE;
                    break;
                }
            }

            if ( pMap->pjl && pMap->pjl == tokenPairs[i].value )
                break;

            //
            // some printers use this to signal online/ready
            //
            if ( tokenPairs[i].value == 10001  ||
                 tokenPairs[i].value == 10002  ||
                 tokenPairs[i].value == 11002 ) {

                pIniPort->status       &= ~PP_PRINTER_OFFLINE;
                pIniPort->PrinterStatus = 0;
                dwSeverity              = 0;
            }


            //
            // background or foreground paper out
            //
            if ( tokenPairs[i].value > 11101 && tokenPairs[i].value < 12000  ||
                 tokenPairs[i].value > 41101 && tokenPairs[i].value < 42000 ) {

                pIniPort->PrinterStatus  = PORT_STATUS_PAPER_OUT;

                if ( tokenPairs[i].value > 4000 ) {

                    dwSeverity           = PORT_STATUS_TYPE_ERROR;
                    pIniPort->status    |= PP_PRINTER_OFFLINE;
                } else {

                    dwSeverity = PORT_STATUS_TYPE_WARNING;
                }
            } else if (tokenPairs[i].value > 40000) {

                pIniPort->PrinterStatus = PORT_STATUS_USER_INTERVENTION;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }

            break;

        case TOKEN_INFO_STATUS_ONLINE:
        case TOKEN_USTATUS_DEVICE_ONLINE:

            // DBGMSG(DBG_INFO, ("PJLMON:ONLINE = %d\n", tokenPairs[i].value));

            if (tokenPairs[i].value) {

                pIniPort->status        &= ~PP_PRINTER_OFFLINE;
                dwSeverity = pIniPort->PrinterStatus ? PORT_STATUS_TYPE_WARNING :
                                                       0;
            } else {

                if ( !pIniPort->PrinterStatus )
                    pIniPort->PrinterStatus = PORT_STATUS_OFFLINE;
                pIniPort->status       |= PP_PRINTER_OFFLINE;
                dwSeverity              = PORT_STATUS_TYPE_ERROR;
            }
            break;

        case TOKEN_USTATUS_JOB_NAME_MSJOB:

            DBGMSG(DBG_TRACE, ("EOJ for %d\n", tokenPairs[i].value));

            SendJobLastPageEjected(pIniPort, (DWORD)tokenPairs[i].value, FALSE);
            break;

        case TOKEN_INFO_CONFIG_MEMORY:
        case TOKEN_INFO_CONFIG_MEMORY_SPACE:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

            DBGMSG(DBG_TRACE, ("PJLMON installed memory %d\n", tokenPairs[i].value));

            pIniPort->dwInstalledMemory = (DWORD)tokenPairs[i].value;
            break;

        case TOKEN_INFO_MEMORY_TOTAL:

            // IMPORTANT NOTE:
            //
            // Use SetPrinterData to cache the information in printer's registry.
            // GDI's DrvGetPrinterData will check the printer's registry first,
            // and if cache data is available, it will use it and not call
            // GetPrinterData (which calls language monitor's
            // GetPrinterDataFromPort).

            DBGMSG(DBG_TRACE, ("PJLMON available memory %d\n", tokenPairs[i].value));

            pIniPort->dwAvailableMemory = (DWORD)tokenPairs[i].value;
            break;

        default:
            break;
        }
    }

    if ( OldStatus != pIniPort->PrinterStatus ) {

        ZeroMemory(&PortInfo3, sizeof(PortInfo3));
        PortInfo3.dwStatus      = pIniPort->PrinterStatus;
        PortInfo3.dwSeverity    = dwSeverity;

        if ( !SetPort(NULL,
                      pIniPort->pszPortName,
                      3,
                      (LPBYTE)&PortInfo3) ) {

            DBGMSG(DBG_WARNING,
                   ("pjlmon: SetPort failed %d (LE: %d)\n",
                    pIniPort->PrinterStatus, GetLastError()));

            pIniPort->PrinterStatus = OldStatus;
        }
    }
}


VOID
ProcessParserError(
    DWORD status
)
/*++

Routine Description:
    Print error messages on parsing error

Arguments:
    status  : status

Return Value:
    None

--*/
{
#ifdef DEBUG
    LPSTR pString;

    switch (status)
    {
    case STATUS_REACHED_END_OF_COMMAND_OK:
        pString = "STATUS_REACHED_END_OF_COMMAND_OK\n";
        break;

    case STATUS_CONTINUE:
        pString = "STATUS_CONTINUE\n";
        break;

    case STATUS_REACHED_FF:
        pString = "STATUS_REACHED_FF\n";
        break;

    case STATUS_END_OF_STRING:
        pString = "STATUS_END_OF_STRING\n";
        break;

    case STATUS_SYNTAX_ERROR:
        pString = "STATUS_SYNTAX_ERROR\n";
        break;

    case STATUS_ATPJL_NOT_FOUND:
        pString = "STATUS_ATPJL_NOT_FOUND\n";
        break;

    case STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS:
        pString = "STATUS_NOT_ENOUGH_ROOM_FOR_TOKENS\n";
        break;

    default:
        pString = "INVALID STATUS RETURNED!!!!!!\n";
        break;
    };

    OutputDebugStringA(pString);
#endif
}


#define MODEL                       "MODEL:"
#define MDL                         "MDL:"
#define COMMAND                     "COMMAND SET:"
#define CMD                         "CMD:"
#define COLON                       ':'
#define SEMICOLON                   ';'


LPSTR
FindP1284Key(
    PINIPORT    pIniPort,
    LPSTR   lpKey
    )
/*++

Routine Description:
    Find the 1284 key identifying the device id

Arguments:
    status  : status

Return Value:
    Pointer to the command string, NULL if not found.

--*/
{
    LPSTR   lpValue;                // Pointer to the Key's value
    WORD    wKeyLength;             // Length for the Key (for stringcmps)
    LPSTR   ret = NULL;

    // While there are still keys to look at.

    DBGMSG(DBG_TRACE, ("PJLMon!DeviceId : <"TSTR">\n", lpKey));

    while (lpKey && *lpKey) {

        //
        // Is there a terminating COLON character for the current key?
        //
        if (!(lpValue = mystrchr(lpKey, COLON)) ) {

            //
            // Something is wrong with the Device ID
            //
            return ret;
        }

        //
        // The actual start of the Key value is one past the COLON
        //
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (WORD)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        if ( *lpKey == 'C' ) {

            //
            // Look for COMMAND SET or CMD
            //
            if ( !mystrncmp(lpKey, COMMAND, wKeyLength) ||
                 !mystrncmp(lpKey, CMD, wKeyLength) ) {

                ret = lpValue;
            }
        }

        // Go to the next Key

        if ( lpKey = mystrchr(lpValue, SEMICOLON) ) {

            *lpKey = '\0';
            ++lpKey;
        }
    }

    return ret;
}


BOOL
IsPJL(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Finds out if the printer is a PJL bi-di printer

Arguments:
    pIniPort  : Points to an INIPORT

Return Value:
    TRUE if printer is PJL bi-di, else FALSE

    On failure PP_DONT_TRY_PJL is set

--*/
{
    char        szID[MAX_DEVID];
    DWORD       cbRet;
    LPSTR       lpCMD;
    HANDLE      hPort = (HANDLE)pIniPort;
    BOOL        bRet = FALSE;

    //
    // for printers that supports P1284 plug and play like LJ 4L, DJ540.
    // we parse the COMMAND string and see if PJL is supported
    //
    if (pIniPort->fn.pfnGetPrinterDataFromPort) {

        //
        // Only try P1284 if port monitor supports DeviceIOCtl
        //
        memset((LPBYTE)szID, 0, sizeof(szID));
        cbRet = 0;
        if ((*pIniPort->fn.pfnGetPrinterDataFromPort)
                (pIniPort->hPort, GETDEVICEID, NULL, NULL,
                    0, (LPWSTR)szID, sizeof(szID), &cbRet)
            && cbRet) {

            //
            // succeeded the P1284 plug and play protocol
            //
            szID[cbRet] = '\0';

            if ( lpCMD = FindP1284Key(pIniPort, szID) ) {

                // found the COMMAND string

                while (*lpCMD) {

                    //
                    // look for "PJL"
                    //
                    if ( lpCMD[0] == 'P' && lpCMD[1] == 'J' && lpCMD[2] == 'L' ){

                        pIniPort->status &= ~PP_DONT_TRY_PJL;
                        bRet = TRUE;
                        goto Cleanup;
                    }

                    lpCMD++;
                }

                pIniPort->status |= PP_DONT_TRY_PJL;
                goto Cleanup;
            }
        }

        //
        // fall thru to try PJL bi-di if we failed the P1284 communication
        // or P1284 didn't return a COMMAND string
        //
    }

    //
    // for printers that don't support P1284 plug and play, but support PJL
    // language command, like LJ 4 and 4M. we try to write/read PJL
    // command and see if it succeeds.
    // if we can't set the time outs we don't want to try to read, just fail.
    //
    if ( pIniPort->fn.pfnSetPortTimeOuts &&
         !(pIniPort->status & PP_DONT_TRY_PJL)) {

        COMMTIMEOUTS CTO;

        memset((LPSTR)&CTO, 0, sizeof(CTO));
        CTO.ReadTotalTimeoutConstant = 5000;
        CTO.ReadIntervalTimeout = 200;
        if ( !(*pIniPort->fn.pfnSetPortTimeOuts)(pIniPort->hPort, &CTO, 0) ) {

            goto Cleanup;
        }

        // This <ESC>*s1M is a PCL5 command to determine the amount of memory
        // in a PCL5 printer, and if the printer is PCL5 and bi-di capable,
        // it will return "PCL\015\012INFO MEMORY".
        // See PJL Tech Ref Manual page 7-21.

        pIniPort->status &= ~PP_IS_PJL;

        if ( !WriteCommand(hPort, "\033*s1M") )
            goto Cleanup;

        // ReadCommand->ProcessPJLString will set PP_IS_PJL
        // if we read any valid PJL command back from the printer

        if ( !ReadCommand(hPort) ) {

            //
            // We have jumped through the hoop to determin if this printer can
            // understand PJL.  It DOES NOT.  We are not going to try again.
            // until there is a printer change.
            //
            pIniPort->status |= PP_DONT_TRY_PJL;
        }

        if (pIniPort->status & PP_IS_PJL) {

            bRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( bRet ) {

        WriteCommand(hPort, "\033%-12345X@PJL \015\012@PJL USTATUS TIMED 30 \015\012\033%-12345X");
        pIniPort->dwLastReadTime = GetTickCount();
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\spltypes.h ===
/*++

Copyright (c) 1995-2003 Microsoft Corporation
All rights reserved.

Module Name:

    Spltypes.h

Abstract:

    PJLMON header file


--*/

#ifndef MODULE
#define MODULE "PJLMON:"
#define MODULE_DEBUG PjlmonDebug
#endif

typedef struct _INIJOB {
    DWORD   signature;
    struct _INIJOB FAR *pNext;
    LPTSTR  pszPrinterName;
    HANDLE  hPrinter;
    DWORD   JobId;
    DWORD   status;
    DWORD   TimeoutCount;
} INIJOB, FAR *PINIJOB;

typedef struct _INIPORT {       /* ipo */
    DWORD   signature;
    struct  _INIPORT FAR *pNext;
    LPTSTR  pszPortName;

    DWORD   cRef;

    DWORD   status;
    PINIJOB pIniJob;

    HANDLE  hPort;
    HANDLE  WakeUp;
    HANDLE  DoneReading;
    HANDLE  DoneWriting;
    HANDLE  hUstatusThread;

    DWORD   PrinterStatus;
    DWORD   dwLastReadTime;
    DWORD   dwAvailableMemory;
    DWORD   dwInstalledMemory;

    MONITOR fn;

} INIPORT, FAR *PINIPORT;

#define PJ_SIGNATURE   0x4F4A  /* 'PJ' is the signature value */

//
// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_LJ4L, PP_RESETDEV
//      are set/cleared on per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
//
#define PP_INSTARTDOC       0x00000001  // Inside StartDoc, sending data to the printer
#define PP_RUN_THREAD       0x00000002  // Tell the ustatus thread to start running
#define PP_THREAD_RUNNING   0x00000004  // Tell the main thread that the ustatus thread is running

//
// If PP_RUN_THREAD is set and PP_THREAD_RUNNING is not that means UStatus
// thread is being created or it is already running but has not determined if
// printer is PJL or not yet
//
#define PP_PRINTER_OFFLINE  0x00000008  // The printer is OFFLINE
#define PP_PJL_SENT         0x00000010  // PJL Command was sent to the printer
#define PP_SEND_PJL         0x00000020  // Set at StartDoc so that we initialize PJL
                                        // commands during the first write port
#define PP_IS_PJL           0x00000040  // Port is PJL
#define PP_DONT_TRY_PJL     0x00000080  // Don't try again...
#define PP_WRITE_ERROR      0x00000100  // A write was not succesful

// PP_PJL_SENT, PP_SEND_PJL, PP_IS_PJL, PP_PORT_OPEN are set/cleared on
//           per job basis.
// PP_DONT_TRY_PJL is set/cleared on per printer basis.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\debug.cpp ===
/*****************************************************************************
 *
 * $Workfile: debug.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/
#include "precomp.h"

#include "debug.h"

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations
HANDLE	g_hDebugFile;

///////////////////////////////////////////////////////////////////////////////
//  InitDebug

void
InitDebug( LPTSTR pszDebugFile )
{
	g_hDebugFile = CreateFile(	pszDebugFile,	// file name
								GENERIC_WRITE,			// access mode
								FILE_SHARE_WRITE | FILE_SHARE_READ,		// share mode
								NULL,					// security attributes
								OPEN_ALWAYS,			// creation
								FILE_ATTRIBUTE_NORMAL,	// file attributes
								NULL );				// template file
	if (g_hDebugFile == INVALID_HANDLE_VALUE)
	{
		DWORD dwError = GetLastError();
		//_RPT1(_CRT_WARN, "\t>ERROR!! CreateFile dwError = %d\n", dwError);
	}
 	_CrtSetReportMode(_CRT_WARN,  _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
	_CrtSetReportFile(_CRT_WARN, (_HFILE)g_hDebugFile);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);		

}	// InitDebug()


///////////////////////////////////////////////////////////////////////////////
//  DeInitDebug

void
DeInitDebug(void)
{
	if (g_hDebugFile)
	{
		CloseHandle(g_hDebugFile);
	}

}	// DeInitDebug()


///////////////////////////////////////////////////////////////////////////////
//  debugRPT -- used w/ the macros

void
debugRPT(char *p, int i)
{
	//_RPT2(_CRT_WARN, "%s %d\n", p, i);

}

///////////////////////////////////////////////////////////////////////////////
//  debugCSect -- used w/ the macros

void
debugCSect(char *p, int i, char *fileName, int lineNum, long csrc)
{
	//_RPT4(_CRT_WARN, "%s (%d) @%s %d", p, i, fileName, lineNum);
	//_RPT1(_CRT_WARN, " [recursioncount=(%ld)]\n", csrc);

}


///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug

DWORD	CMemoryDebug::m_dwMemUsed = 0;

///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug::CMemoryDebug

CMemoryDebug::CMemoryDebug()
{

}	// ::CMemoryDebug()
							

///////////////////////////////////////////////////////////////////////////////
//  CMemoryDebug::~CMemoryDebug

CMemoryDebug::~CMemoryDebug()
{

}	// ::~CMemoryDebug()


///////////////////////////////////////////////////////////////////////////////
//	operator new

void *
CMemoryDebug::operator new(size_t in s)
{
	m_dwMemUsed += s;
	//_RPT2(_CRT_WARN, "DEBUG -- operator new() ----- Bytes allocated = %d, Total Memory used upto date = %d\n", s, m_dwMemUsed);

	return (void *) new char[s];

}	// ::operator new()


///////////////////////////////////////////////////////////////////////////////
//	operator delete

void
CMemoryDebug::operator delete(void		in *p,
							  size_t	in s)
{
	m_dwMemUsed -= s;
	//_RPT2(_CRT_WARN, "DEBUG -- operator delete() ----- Bytes deleted = %d,Total Memory used upto date = %d\n", s, m_dwMemUsed);
	delete [] p;

}	// ::operator delete()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\debug.h ===
/*****************************************************************************
 *
 * $Workfile: debug.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_DEBUG_H
#define INC_DEBUG_H

#include <crtdbg.h>		// debug functions

#define in
#define out
#define inout

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations
extern HANDLE	g_hDebugFile;


///////////////////////////////////////////////////////////////////////////////
//  function prototypes
#ifdef __cplusplus
extern "C" {
#endif
	void InitDebug( LPTSTR pszDebugFile );
	void DeInitDebug(void);
	void debugRPT(char *p, int i);
	void debugCSect(char *p, int i, char *fileName, int lineNum, LONG csrc);
#ifdef __cplusplus
}
#endif


///////////////////////////////////////////////////////////////////////////////
//  debug macros
#define	MON_DEBUG_FILE	__TEXT("c:\\tmp\\DebugMon.out")
#define	MONUI_DEBUG_FILE	__TEXT("c:\\tmp\\UIDbgMon.out")

#ifdef IS_INTEL
#define BREAK	{ if ( CreateFile((LPCTSTR)__TEXT("c:\\tmp\\breakmon.on"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING,	\
							FILE_ATTRIBUTE_NORMAL, 0) == INVALID_HANDLE_VALUE)					\
					{	}													\
				  else { { _asm { int 3h } } }																\
				}
#else
#define BREAK	{}
#endif

#if defined NDEBUG
	#ifdef BREAK
	#undef BREAK
	#define BREAK
	#endif
#endif


///////////////////////////////////////////////////////////////////////////////
//  memory watch routines

class CMemoryDebug 
{
public:
	CMemoryDebug();
	~CMemoryDebug();

	// override new & delete to keep track of memory usage
	void*	operator	new(size_t s);
	void	operator	delete( void   *p, 
								size_t s );		// 2nd parameter optional

private:
	static DWORD	m_dwMemUsed;

};

#endif		// INC_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\pjlmon\util.c ===
/*++

Copyright (c) 1990-2003 Microsoft Corporation
All Rights Reserved

Module Name:

    util.c

--*/

#include "precomp.h"

// @@BEGIN_DDKSPLIT
#ifdef INTERNAL
MODULE_DEBUG_INIT( DBG_WARN|DBG_ERROR, DBG_ERROR );
#endif
// @@END_DDKSPLIT

CRITICAL_SECTION pjlMonSection      = {0,0,0,0,0,0};

PINIPORT pIniFirstPort  = NULL;

DWORD dwReadThreadErrorTimeout;
DWORD dwReadThreadEOJTimeout;
DWORD dwReadThreadIdleTimeoutOther;

TCHAR cszEOJTimeout[]        = TEXT("EOJTimeout");


VOID
SplInSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread != (HANDLE) UIntToPtr(GetCurrentThreadId()) ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Not in spooler semaphore !!\n"));
    }
}


VOID
SplOutSem(
   VOID
    )
{
    if ( pjlMonSection.OwningThread == (HANDLE) UIntToPtr(GetCurrentThreadId()) ) {
        DBGMSG(DBG_ERROR, ("Pjlmon: Inside spooler semaphore !!\n"));
    }
}

VOID
EnterSplSem(
   VOID
    )
{
    EnterCriticalSection(&pjlMonSection);
}


VOID
LeaveSplSem(
   VOID
    )
{
    SplInSem();
    LeaveCriticalSection(&pjlMonSection);
}


VOID
UpdateRegistryValue(
    IN     HKEY     hKey,
    IN     LPCTSTR  cszValueName,
    OUT    LPDWORD  pdwValue,
    IN     DWORD    dwDefault,
    IN OUT LPDWORD  pdwLastError
    )
/*++

Routine Description:
    Gets value assoicated with give value name from the registry. If value name
    is not found default value is written to registry.

    On error last error value is set to pdwLastError.

Arguments:
    hKey         : Registry key under which value should be searched
    cszValueName : Value name to search in the registry
    pdwValue     : On return will have the value
    dwDefault    : If value name not found in the registry set to this value
    pdwLastError : On error set last error to this

Return Value:
    None

--*/
{
    DWORD   dwSize = sizeof(*pdwValue);

    if ( *pdwLastError != ERROR_SUCCESS )
        return;

    if ( ERROR_SUCCESS != RegQueryValueEx(hKey,
                                          cszValueName,
                                          NULL,
                                          NULL,
                                          (LPBYTE)pdwValue,
                                          &dwSize) ) {

        *pdwValue = dwDefault;
        *pdwLastError = RegSetValueEx(hKey,
                                      cszValueName,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)pdwValue,
                                      sizeof(*pdwValue));
    }

}


DWORD
UpdateTimeoutsFromRegistry(
    IN LPTSTR      pszRegistryRoot
    )
/*++

Routine Description:
    Get the timeout values from the registry, or initialize registry with
    default values if entries are not found.

    Users/apps can change the registry to change the behavior.

Arguments:
    pszRegistryRoot : Registry root to be used by this dll

Return Value:
    ERROR_SUCCESS on success, else last error value

--*/
{
    HKEY    hKey;
    DWORD   dwLastError = ERROR_SUCCESS;

    dwLastError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegistryRoot,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &hKey,
                                 NULL);

    if ( dwLastError != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    UpdateRegistryValue(hKey,
                        cszEOJTimeout,
                        &dwReadThreadEOJTimeout,
                        READ_THREAD_EOJ_TIMEOUT,
                        &dwLastError);

    dwReadThreadErrorTimeout        = READ_THREAD_ERROR_WAITTIME;
    dwReadThreadIdleTimeoutOther    = READ_THREAD_IDLE_WAITTIME;

    RegCloseKey(hKey);

Cleanup:

    if ( dwLastError != ERROR_SUCCESS ) {

        DBGMSG(DBG_ERROR,
               ("UpdateTimeoutsFromRegistry: Failed with %d", dwLastError));
    }

    return dwLastError;
}


PINIPORT
FindIniPort(
   IN LPTSTR pszName
    )
{
    PINIPORT    pIniPort = pIniFirstPort;

    if ( !pszName || !*pszName )
        return NULL;

    SplInSem();

    while ( pIniPort && lstrcmpi(pszName, pIniPort->pszPortName))
      pIniPort = pIniPort->pNext;

   return pIniPort;
}


PINIPORT
CreatePortEntry(
    IN LPTSTR  pszPortName
    )
/*++

Routine Description:
    Creates a IniPort entry for a port. Needs to be called inside monitor
    critical section.

Arguments:
    pszPortName       : Name of the port

Return Value:
      On success pointer to the IniPort stucture.
      On failure NULL

--*/
{
    PINIPORT    pIniPort    = NULL;
    HANDLE      DoneWriting = NULL;
    HANDLE      DoneReading = NULL;
    HANDLE      WakeUp      = NULL;
    LPWSTR      pszString   = NULL;

    SplInSem();


    if (!(DoneWriting = CreateEvent(NULL, FALSE, TRUE, NULL)))
    {
        goto Fail;
    }
    if (!(WakeUp = CreateEvent(NULL, FALSE, FALSE, NULL)))
    {
        goto Fail;
    }
    //
    // manual-reset event, initially signal state
    //
    if (!(DoneReading = CreateEvent(NULL, TRUE, TRUE, NULL)))
    {
        goto Fail;
    }
    if (!(pIniPort = (PINIPORT) AllocSplMem(sizeof(*pIniPort))))
    {
        goto Fail;
    }
    if (!(pszString = AllocSplStr(pszPortName)))
    {
        goto Fail;
    }
    pIniPort->pNext         = NULL;
    pIniPort->signature     = PJ_SIGNATURE;
    pIniPort->DoneWriting   = DoneWriting;
    pIniPort->DoneReading   = DoneReading;
    pIniPort->WakeUp        = WakeUp;
    pIniPort->hUstatusThread= NULL;
    pIniPort->pszPortName   = pszString;

    pIniPort->pNext         = pIniFirstPort;
    pIniFirstPort           = pIniPort;
    return pIniPort;

Fail:
    if (DoneWriting)
    {
        CloseHandle (DoneWriting);
    }
    if (DoneReading)
    {
        CloseHandle (DoneReading);
    }
    if (WakeUp)
    {
        CloseHandle (WakeUp);
    }
    FreeSplMem (pszString);
    FreeSplMem (pIniPort);
    return NULL;
}


VOID
DeletePortEntry(
    IN PINIPORT pIniPort
    )
/*++

Routine Description:
    Deletes a port entry. Needs to be called inside monitor critical section

Arguments:
    pIniPort    : Pointer to the IniPort structure to be deleted

Return Value:

--*/
{
    SplInSem();

    if ( pIniPort == pIniFirstPort ) {

        pIniFirstPort = pIniPort->pNext;
    } else {

        PINIPORT    pPort;

        pPort = pIniFirstPort;
        while ( pPort && pPort->pNext != pIniPort )
            pPort = pPort->pNext;

        if (pPort) {

            pPort->pNext = pIniPort->pNext;
        } else {

            DBGMSG(DBG_ERROR, ("pjlmon: DeletePortEntry port not found\n"));
            return;
        }
    }
    if (pIniPort-> DoneWriting)
    {
        CloseHandle(pIniPort->DoneWriting);
        pIniPort->DoneWriting = NULL;
    }
    if (pIniPort-> DoneReading)
    {
        CloseHandle(pIniPort->DoneReading);
        pIniPort->DoneReading = NULL;
    }
    if (pIniPort-> WakeUp)
    {
        CloseHandle(pIniPort->WakeUp);
        pIniPort->WakeUp = NULL;
    }
    if (pIniPort-> hUstatusThread)
    {
        CloseHandle (pIniPort-> hUstatusThread);
        pIniPort->hUstatusThread = NULL;
    }
    FreeIniJobs(pIniPort);
    FreeSplStr(pIniPort->pszPortName);
    pIniPort->pszPortName = NULL;
    FreeSplMem(pIniPort);

    return;
}


VOID
FreeIniJob(
    IN OUT PINIJOB pIniJob
    )
/*++

Routine Description:
    Deletes a job entry.

Arguments:
    pIniJob    : Pointer to the IniJob structure to be deleted

Return Value:
    None

--*/
{
    SPLASSERT(pIniJob);
    if ( pIniJob->hPrinter )
        ClosePrinter(pIniJob->hPrinter);
    FreeSplMem(pIniJob);
}


VOID
FreeIniJobs(
    PINIPORT pIniPort
    )
/*++

Routine Description:
    Free all the InJob structures assigned to this port

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed

--*/
{
    PINIJOB pIniJob, pIniNextJob;

    EnterSplSem();
    pIniJob = pIniPort->pIniJob;
    while ( pIniJob ) {

        pIniNextJob = pIniJob->pNext;
        FreeIniJob(pIniJob);
        pIniJob = pIniNextJob;
    }

    pIniPort->pIniJob = NULL;
    LeaveSplSem();
}


VOID
SendLastPageEjectedForIniJob(
    PINIPORT    pIniPort,
    PINIJOB     pIniJob
    )
{
    SplInSem();

    if ( !SetJob(pIniJob->hPrinter, pIniJob->JobId, 0,
                 NULL, JOB_CONTROL_LAST_PAGE_EJECTED) ) {

        DBGMSG(DBG_WARNING,
               ("SetJob failed with last error %d\n", GetLastError()));
    }
}


PINIJOB
FindIniJobFromJobId(
    PINIPORT    pIniPort,
    DWORD       dwJobId,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pCur, pPre, pIniJob;

    SplInSem();

    //
    // If JOB_RESTART is given there will be multiple jobs with same id
    // we need to find the last entry with given id in the list
    //
    for ( pCur = pIniPort->pIniJob, pPre = pIniJob = *ppPrevIniJob = NULL ;
          pCur ;
          pPre = pCur, pCur = pCur->pNext ) {

        if ( pCur->JobId == dwJobId ) {

            *ppPrevIniJob   = pPre;
            pIniJob         = pCur;
        }
    }

    return pIniJob;
}


PINIJOB
FindFirstIniJobTimedOut(
    PINIPORT    pIniPort,
    DWORD       dwTime,
    PINIJOB    *ppPrevIniJob
    )
{
    PINIJOB pIniJob = pIniPort->pIniJob;

    SplInSem();
    *ppPrevIniJob = NULL;

    //
    // Look for a job not in STARTDOC and timedout
    //
    while ( pIniJob &&
            ( (pIniJob->status & PP_INSTARTDOC) ||
               pIniJob->TimeoutCount > dwTime ) ) {

        *ppPrevIniJob = pIniJob;
        pIniJob = pIniJob->pNext;
    }

    if ( !pIniJob )
        *ppPrevIniJob = NULL;

    return pIniJob;
}


VOID
SendJobLastPageEjected(
    PINIPORT    pIniPort,
    DWORD       dwValue,
    BOOL        bTime
    )
/*++

Routine Description:
    Send LastPageEjected notification for 1 or more jobs to spooler

Arguments:
    pIniPort    : IniPort for the port for which all jobs need to be freed
    dwValue     : if bTime is TRUE send EOJ to any jobs rcvd before dwValue
                  else dwValue is JobId -- ALL_JOBS is for all jobs
    bTime       : Tells how to interpret dwValue

--*/
{
    PINIJOB pIniJob;

    EnterSplSem();
    //
    // JobId == ALL_JOBS is a special case where we want to send LastPage
    // ejected for all jobs pending
    //
    if ( !bTime && dwValue == ALL_JOBS ) {

        pIniJob = pIniPort->pIniJob;
        pIniPort->pIniJob = NULL;

        while ( pIniJob ) {

            PINIJOB pTempJob = pIniJob;

            SendLastPageEjectedForIniJob(pIniPort, pIniJob);
            pIniJob = pIniJob->pNext;
            FreeIniJob(pTempJob);
        }

    } else {

        PINIJOB pPrevIniJob = NULL;

        pIniJob = pIniPort->pIniJob;

        //
        // If bTime we want to send LastPageEjected for all jobs timedout
        //
        if ( bTime )  {

            pIniJob = FindFirstIniJobTimedOut(pIniPort, dwValue, &pPrevIniJob);
        } else {

            pIniJob = FindIniJobFromJobId(pIniPort, dwValue, &pPrevIniJob);
        }

        if ( pIniJob ) {

            //
            // Send notifications for any previous jobs too
            //
            if ( pIniPort->pIniJob == pIniJob )
                pIniPort->pIniJob = NULL;
            else
                pPrevIniJob->pNext = NULL;

            do {

                SendLastPageEjectedForIniJob(pIniPort, pIniJob);

                pPrevIniJob = pIniJob;
                pIniJob = pIniJob->pNext;
                FreeIniJob(pPrevIniJob);
            } while ( pIniJob );
        }
    }

    LeaveSplSem();
}

// -----------------------------------------------------------------------
//
// String helper function to remove crt dependency
//
// -----------------------------------------------------------------------
LPSTR
mystrchr(
    LPSTR cs,
    char c
)
{
    while (*cs != 0)
    {
        if (IsDBCSLeadByte(*cs))
          cs++;
        else
        if (*cs == c)
            return cs;
        cs++;
    }

    // fail to find c in cs
    return NULL;
}


int
mystrncmp(
    LPSTR cs,
    LPSTR ct,
    int n
)
{
    char ret = 0;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (int)ret;
}

// @@BEGIN_DDKSPLIT
#ifndef INTERNAL
// @@END_DDKSPLIT

LPWSTR
AllocSplStr(
    LPWSTR pStr
    )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/

{
    LPWSTR pMem;
    DWORD  cbStr;

    if (!pStr) {
        return NULL;
    }

    cbStr = wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR);

    if (pMem = AllocSplMem( cbStr )) {
        CopyMemory( pMem, pStr, cbStr );
    }
    return pMem;
}


LPVOID
AllocSplMem(
    DWORD cbAlloc
    )

{
    PVOID pvMemory;

    pvMemory = GlobalAlloc(GMEM_FIXED, cbAlloc);

    if( pvMemory ){
        ZeroMemory( pvMemory, cbAlloc );
    }

    return pvMemory;
}


// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\lprdata.h ===
/*****************************************************************************
 *
 * $Workfile: LPRData.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_LPRDATA_H
#define INC_LPRDATA_H

// globals shared by the UI & transport dlls
#if (!defined(LPR))
    #define	LPR						2
    #define	PROTOCOL_LPR_TYPE		LPR
#endif    
#define	PROTOCOL_LPR_VERSION1	1		// supports ADDPORT_DATA_1; REGPORT_DATA_1; CONFIGPORT_DATA_1

#define LPR_DEFAULT_PORT_NUMBER 515


typedef struct _LPR_PORT_DATA_1						// used by the registry
{
	TCHAR	sztPortName[MAX_PORTNAME_LEN];
	TCHAR	sztHostName[MAX_NETWORKNAME_LEN];
	TCHAR	sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR	sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR	sztQueue[MAX_QUEUENAME_LEN];
	TCHAR	sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
    DWORD   dwDoubleSpool;
	DWORD	dwSNMPEnabled;
	DWORD	dwSNMPDevIndex;
	DWORD	dwPortNumber;
}	LPR_PORT_DATA_1, *PLPR_PORT_DATA_1;

#endif	// INC_LPRDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\coreui.h ===
/*****************************************************************************
 *
 * $Workfile: CoreUI.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (c) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/Common/CoreUI.h $
 * 
 * 14    9/17/97 2:45p Dsnelson
 * For XcvData need the port name to be the first element of the data
 * structure pass in.
 * 
 * 13    9/09/97 2:52p Dsnelson
 * Changed the port info struct. ( resolved multiple memory issues )
 * 
 * 12    9/03/97 4:24p Dsnelson
 * Updated SNMP Member structures
 * 
 * 11    8/14/97 4:54p Becky
 * Added DELETE_PORT_DATA_1 for deleting a port using XcvData().
 * 
 * 10    7/25/97 10:12a Becky
 * Changed COREUI_DATA_1 to use extension bytes for config port UI.
 * 
 * 9     7/23/97 12:12p Becky
 * Modified the struct CORE_UIDATA_1 to include info needed for
 * configuration.
 * 
 * 8     7/17/97 5:14p Becky
 * Added Struct CORE_UIDATA_1
 * 
 * 7     7/15/97 12:26p Becky
 * 
 * 6     7/15/97 11:18a Becky
 * 
 * 5     7/15/97 12:20p Binnur
 * core ui changes -- again!
 * 
 * 3     7/15/97 11:06a Becky
 * Updated the Core Add Port UI structure
 * 
 * 2     7/11/97 4:45p Becky
 * Just getting started.
 * 
 * 1     7/11/97 3:14p Binnur
 * Initial file
 * 
 *****************************************************************************/

#ifndef INC_COREUI_H
#define INC_COREUI_H

/***************************************************************************** 
 *
 * Important Note: This file defines the interface between the UI pieces of the
 *	standard TCP/IP port monitor. Changes to this interface will impact the 
 *	existing UI pieces.
 * 
 *****************************************************************************/

#ifndef	DllExport
#define	DllExport	__declspec(dllexport)
#endif

#include "tcpmon.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
// LocalCoreAddPortUI -- 
//	Return Codes:
//		NO_ERROR if successful
//		ERROR_INSUFFICIENT_BUFFER if buffer size is small
//		ERROR_INVALID_LEVEL	if version is not supported
DWORD DllExport CoreAddPortUI(	HWND hWnd,				// parent window handle
								PPORT_DATA_1 pData,	// Input and Output data, see above structure for which items are input and which are output.
								DWORD dwDeviceType,		// determined by the core UI -- the type of device returned by GetDeviceType (ERROR_DEVICE_NOT_FOUND, SUCCESS_DEVICE_SINGLE_PORT, SUCCESS_DEVICE_MULTI_PORT, or SUCCESS_DEVICE_UNKNOWN)
								PDWORD pcbExtensionDataSizeNeeded,	// needed buffer size, refers to pData->pExtensionData, (input and output).
								DWORD  *pdwUserPressed);// output, if set to IDOK then the port is created otherwise it is treated as IDCANCEL, the main dialog is left open for further user input/changes.

BOOL DllExport CoreConfigPortUI(HWND hWndParent);
BOOL DllExport CoreDeletePortUI(HWND hWndParent);

#ifdef __cplusplus
}
#endif


#endif	// INC_COREUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\precomp.h ===
/*****************************************************************************
 *
 * $Workfile: pch_mon.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/Common/pch_mon.h $
 *
 * 4     9/25/97 9:08a Dsnelson
 * removed target.h
 *
 * 3     7/14/97 2:35p Binnur
 * copyright statement
 *
 * 2     7/11/97 1:52p Dsnelson
 * added blank last line
 *
 * 1     7/02/97 2:25p Binnur
 * Initial File
 *
 *****************************************************************************/


#ifndef _PRECOMP_H
#define _PRECOMP_H

#include <tchar.h>
#include <windows.h>
#include <windowsx.h>

//  Include the correct spooler definitions, etc
#include <winspool.h>
#include <strsafe.h>

#endif	// INC_PCH_MON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\mibabc.h ===
/*****************************************************************************
 *
 * $Workfile: MibABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_TCPMIBABC_H
#define INC_TCPMIBABC_H

#include <snmp.h>
#include <mgmtapi.h>
#include <winspool.h>



// error codes -- device type operation
#define  ERROR_DEVICE_NOT_FOUND                 10000
#define  SUCCESS_DEVICE_SINGLE_PORT             10001
#define  SUCCESS_DEVICE_MULTI_PORT              10002
#define  SUCCESS_DEVICE_UNKNOWN                 10003


class   CTcpMibABC;

typedef CTcpMibABC* (CALLBACK *RPARAM_1) ( void );

#ifndef DllExport
#define DllExport       __declspec(dllexport)
#endif


#ifdef __cplusplus
extern "C" {
#endif
	//      return the pointer to the interface
	CTcpMibABC* GetTcpMibPtr( void );

#ifdef __cplusplus
}
#endif


/***************************************************************************** 
 *
 * Important Note: This abstract base class defines the interface for the CTcpMib 
 *      class. Changing this interface will cause problems for the existing DLLs that 
 *      uses the TcpMib.dll & CTcpMib class.
 * 
 *****************************************************************************/

class DllExport CTcpMibABC      
#if defined _DEBUG || defined DEBUG
//      , public CMemoryDebug
#endif
{
public:
	CTcpMibABC() { };
	virtual ~CTcpMibABC() { };

	virtual BOOL   SupportsPrinterMib( LPCSTR        pHost,
							           LPCSTR        pCommunity,
                                       DWORD         dwDevIndex,
                                       PBOOL         pbSupported) = 0;
	virtual DWORD   GetDeviceDescription(LPCSTR        pHost,
									     LPCSTR        pCommunity,
									     DWORD         dwDevIndex,
                                         LPTSTR        pszPortDescription,
										 DWORD		   dwDescLen) = 0;
	virtual DWORD   GetDeviceStatus ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex) = 0;
	virtual DWORD   GetJobStatus    ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex) = 0;
	virtual DWORD   GetDeviceHWAddress( LPCSTR      pHost,
									    LPCSTR      pCommunity,
										DWORD   dwDevIndex,
										DWORD   dwSize, // Size in characters of the dest hardware address
									    LPTSTR      psztHWAddress) = 0;
	virtual DWORD   GetDeviceName   ( LPCSTR        pHost,
									  LPCSTR        pCommunity,
									  DWORD         dwDevIndex,
									  DWORD         dwSize, // Size in characters of the dest psztDescription
									  LPTSTR        psztDescription) = 0;
	virtual DWORD   SnmpGet( LPCSTR                      pHost,
							 LPCSTR pCommunity,
							 DWORD          dwDevIndex,
							 AsnObjectIdentifier *pMibObjId,
							 RFC1157VarBindList  *pVarBindList) = 0;
	virtual DWORD   SnmpWalk( LPCSTR                          pHost,
							  LPCSTR                          pCommunity,
							  DWORD                           dwDevIndex,
							  AsnObjectIdentifier *pMibObjId,
							  RFC1157VarBindList  *pVarBindList) = 0;
	virtual DWORD   SnmpGetNext( LPCSTR                          pHost,
							     LPCSTR                              pCommunity,
							     DWORD                               dwDevIndex,
								 AsnObjectIdentifier *pMibObjId,
								 RFC1157VarBindList  *pVarBindList) = 0;
	virtual BOOL SNMPToPortStatus( const DWORD in dwStatus, 
								 PPORT_INFO_3 pPortInfo ) = 0;

	virtual DWORD SNMPToPrinterStatus( const DWORD in dwStatus) = 0;


private:


};      // class CTcpMibABC



#endif  // INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\rtcpdata.h ===
/*****************************************************************************
 *
 * $Workfile: RTcpData.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_RAWTCPDATA_H
#define INC_RAWTCPDATA_H
 
// globals shared by the UI & transport dlls

#if (!defined(RAWTCP))
    #define	RAWTCP						1
    #define	PROTOCOL_RAWTCP_TYPE		RAWTCP
#endif    
#define	PROTOCOL_RAWTCP_VERSION		1		// supports ADDPORT_DATA_1; REGPORT_DATA_1; CONFIGPORT_DATA_1

// UI structures
typedef struct _RAWTCP_PORT_DATA_1						// used by the registry
{
	TCHAR	sztPortName[MAX_PORTNAME_LEN];
	TCHAR	sztHostName[MAX_NETWORKNAME_LEN];
	TCHAR	sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR	sztHWAddress[MAX_ADDRESS_STR_LEN];
	TCHAR	sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD	dwSNMPEnabled;
	DWORD	dwSNMPDevIndex;
	DWORD	dwPortNumber;
}	RAWTCP_PORT_DATA_1, *PRAWTCP_PORT_DATA_1;

typedef struct _RAWTCP_CONFIG_DATA_1					// used by the UI -- configPort
{
	TCHAR   sztIPAddress[MAX_IPADDR_STR_LEN];
	TCHAR   sztHardwareAddress[MAX_ADDRESS_STR_LEN];
	TCHAR   sztDeviceType[MAX_DEVICEDESCRIPTION_STR_LEN];
}	RAWTCP_CONFIG_DATA_1, *PRAWTCP_CONFIG_DATA_1;

#endif	// INC_RAWTCPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\pingicmp.h ===
/*****************************************************************************
 *
 * $Workfile: PingICMP.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/Common/PingICMP.h $
 *
 * 2     7/14/97 2:35p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:25p Binnur
 * Initial File
 *
 *****************************************************************************/

#ifndef INC_PINGICMP_H
#define INC_PINGICMP_H

class CMemoryDebug;

class CPingICMP
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CPingICMP( const char *pHost );
	~CPingICMP();

	BOOL	Ping();

private:
	HANDLE  hIcmp;
	int		m_iLastError;		// Last error from Winsock call

	char	m_szHost[MAX_NETWORKNAME_LEN];	
	BOOL	Open();
	BOOL	Close();
	IPAddr	ResolveAddress();

};

#endif	// INC_PINGICMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tcpmib.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\common\tcpmon.h ===
/*****************************************************************************
 *
 * $Workfile: TcpMon.h $
 *
 * Copyright (C) 1997 - 1999 Hewlett-Packard Company.
 * Copyright (C) 1997 - 1999 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_HPSPPMON_H
#define INC_HPSPPMON_H

#include <wininet.h>
#include <splcom.h>
#include "debug.h"
#include "tcpxcv.h"

typedef BOOL (* SETPORTPARAM)(LPTSTR, LPTSTR, DWORD, LPBYTE);
typedef BOOL (* ENUMPORTPARAM)(LPTSTR, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD);

// externs
extern int           g_cntGlobalAlloc;
extern int           g_csGlobalCount;
extern HINSTANCE     g_hInstance;
extern HINSTANCE     g_hTcpMib;
extern HINSTANCE     g_hSpoolLib;
extern SETPORTPARAM  g_pfnSetPort;
extern ENUMPORTPARAM g_pfnEnumPorts;

// Additional Dll's

#define TCPMIB_DLL_NAME         TEXT("tcpmib.dll")


// macros
#define ENTER_CRITICAL_SECTION(cs, fn, ln, csrc)                        ( debugCSect("DEBUG -- EnterCriticalSection count = ", ++g_csGlobalCount, fn, ln, csrc), EnterCriticalSection(cs) )
#define EXIT_CRITICAL_SECTION(cs, fn, ln, csrc)                 ( debugCSect("DEBUG -- ExitCriticalSection count = ", --g_csGlobalCount, fn, ln, csrc), LeaveCriticalSection(cs) )


#if defined (UNICODE) || defined (_UNICODE)
#define MBCS_TO_UNICODE(dest, destsize, src)                                   \
      {                                                         \
      _ASSERTE(strlen(src)<(size_t)destsize); /* make sure dest is big enough -- should a bigger buffer be allocated? */ \
      MultiByteToWideChar(CP_ACP, 0L, src, -1, dest, destsize); \
	  (dest)[destsize - 1 ] = '\0'; \
      }

#define UNICODE_TO_MBCS(dest, destsize, src, srcsize)                  \
      {                                                         \
      _ASSERTE((int)srcsize == -1 || _tcslen(src)<=(size_t)srcsize);  /* make sure the source string did not go past the provided buffer size */ \
      WideCharToMultiByte(CP_ACP, 0L, src, -1, dest, destsize, NULL, NULL); \
	  (dest)[destsize - 1 ] = '\0'; \
      }

#define SIZEOF_IN_CHAR(buf)             (sizeof(buf)/sizeof(buf[0]))
#define STRLEN_IN_BYTES(buf)    (_tcslen(buf)*sizeof(TCHAR))                            // String length in bytes
#define STRLENN_IN_BYTES(buf)   (_tcslen(buf)*sizeof(TCHAR)+sizeof(TCHAR))      // string length including NULL terminator
#endif

// Required Winsock version info
#define WS_VERSION_REQUIRED             (0x0101)                        // WinSock V1.1 is required
#define WS_VERSION_MAJOR                HIBYTE(WS_VERSION_REQUIRED)
#define WS_VERSION_MINOR                LOBYTE(WS_VERSION_REQUIRED)
 
// strings

#define NULLSTR					 TEXT("");
#ifdef HP_BUILD
#define PORTMONITOR_CLASS_NAME   TEXT("STDTCPMON")
#define PORTMONITOR_HELP_FILE    TEXT("HPTCPMUI.HLP")
#define PORTMONITOR_NAME         TEXT("HPTCPMON.DLL")
#define PORTMONITOR_UI_NAME      TEXT("HPTcpMUI.dll")
#define PORTMONITOR_DESC         TEXT("HP Standard TCP/IP Port")
#define SZEVENTLOG_NAME          TEXT("HPTcpMon")
#define PORTMONITOR_INI_FILE     TEXT("\\HPTcpMon.ini")
#else
#define PORTMONITOR_CLASS_NAME   TEXT("HPJETADMIN")
#define PORTMONITOR_HELP_FILE    TEXT("TCPMON.HLP")
#define PORTMONITOR_NAME         TEXT("TCPMON.DLL")
#define PORTMONITOR_UI_NAME      TEXT("TCPMonUI.dll")
#define PORTMONITOR_DESC         TEXT("Standard TCP/IP Port")
#define SZEVENTLOG_NAME          TEXT("TCPMon")
#define PORTMONITOR_INI_FILE     TEXT("\\TcpMon.ini")
#endif

#define DEFAULT_SNMP_COMMUNITYA  "public"
#define DEFAULT_SNMP_COMUNITY    TEXT( DEFAULT_SNMP_COMMUNITYA )
#define DEFAULT_QUEUE			 TEXT( "LPR" )
#define TCP_PROTOCOL             TEXT( "TCP_IP" )

// Defaults
#define DEFAULT_PORT_NUMBER  9100
#define DEFAULT_PROTOCOL		1
#define DEFAULT_VERSION			1

// SNMP Constants
#define DEFAULT_SNMP_DEVICE_INDEX 1

// lengths 
#define MAX_SECTION_NAME                 64
#define MAX_PRINTERNAME_LEN              MAX_UNC_PRINTER_NAME  // printer name 
#define MAX_FULLY_QUALIFIED_HOSTNAME_LEN 128                   // fully qualified hostname length
#define MAX_PORT_DESCRIPTION_LEN		 256
#define MAX_NUM_OF_DEVICEPORTS           1024

//Status Constants
#define PORT_STATUS_IDLE                 0
#define PORT_STATUS_ERROR                1
#define PORT_STATUS_PRINTING             2
#define STATUS_ERROR_FACTOR              20
#define STATUS_PRINTINT_FACTOR           10
#define STATUS_ERROR_MIN                 10                    // Seconds

class CPortMgr;
#define     MONITOR_SIGNATURE        (0xE9324C33)
typedef struct _MONITOR_HANDLE {
	DWORD           cb;
	DWORD           dSignature;
	CPortMgr        *pPortMgr;
} MONITOR_HANDLE, *PMONITOR_HANDLE;

typedef struct _SNMP_INFO
{
	TCHAR   sztSNMPCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	TCHAR   sztAddress[MAX_NETWORKNAME_LEN];
	DWORD   dwSNMPEnabled;
	DWORD   dwSNMPDeviceIndex;
}   SNMP_INFO, *PSNMP_INFO;


// This must be included after the length definitions because
// the structures in it depend on these definitions.

#define SPOOLER_SUPPORTED_LEVEL 2                   // spooler supported level

#ifdef __cplusplus
extern "C" {
#endif

	DWORD EncodeMonitorHandle( PHANDLE phMonitor, CPortMgr *pPortMgr );

	DWORD ValidateMonitorHandle( HANDLE hMonitor );

	DWORD FreeMonitorHandle( HANDLE hMonitor );

	BOOL WINAPI EndDocPort  (HANDLE hPort);
	BOOL WINAPI StartDocPort(HANDLE hPort,
							 LPTSTR pPrinterName,
							 DWORD  jobId,
							 DWORD  level,
							 LPBYTE pDocInfo);
	BOOL AddPortExW(LPTSTR psztName,
					DWORD  Level,   
					LPBYTE lpBuffer,
					LPTSTR psztMonitorName);

	BOOL WINAPI     AddPortUIEx(LPBYTE pData);
	BOOL WINAPI ConfigPortUIEx(const LPBYTE pData);

	BOOL ClusterOpenPort(HANDLE             hcKey,
						 LPTSTR         pName,
						 PHANDLE                pHandle);

	BOOL ClusterXcvOpenPort( HANDLE hcKey,
							  LPCTSTR               pszObject,
							  ACCESS_MASK   GrantedAccess,
						  PHANDLE               phXcv);

	BOOL ClusterAddPort(HANDLE      hcKey,
						LPTSTR  psztName,
						HWND    hWnd,
						LPTSTR  psztMonitorName);

	BOOL ClusterAddPortExW( HANDLE hcKey,
							LPTSTR psztName,
							DWORD  Level,   
							LPBYTE lpBuffer,
							LPTSTR psztMonitorName);

	BOOL ClusterConfigurePort(      HANDLE  hcKey,
								LPTSTR  psztName,
								HWND    hWnd,
								LPTSTR  psztPortName);

	BOOL ClusterDeletePort( HANDLE hcKey,
							LPTSTR psztName,
							HWND   hWnd,
							LPTSTR psztPortName);

	BOOL ClusterEnumPorts(  HANDLE          hcKey,
							LPTSTR          psztName,
							DWORD           Level,  // 1 (PORT_INFO_1) or 2 (PORT_INFO_2)
							LPBYTE          pPorts, // port data is written to
							DWORD           cbBuf,  // buffer size of pPorts points to
							LPDWORD         pcbNeeded,      // needed buffer size
							LPDWORD         pcReturned) ;   // number of structs written to pPorts

	VOID ClusterShutdown( HANDLE hTcpMon );

    _inline char *strncpyn(char *pszdest, const char *pszsrc, size_t n) {
        (strncpy( pszdest, pszsrc, n))[n - 1] = NULL;
        return pszdest;
    }



#ifdef __cplusplus
}
#endif

#endif // INC_HPSPPMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\precomp.h ===
/*++

Copyright (C) 2001  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Weihai Chen (weihaic)  2/20/2001

Revision History:

--*/

#ifndef _TCPMIB_PRECOMP_H_
#define _TCPMIB_PRECOMP_H_

#include <windows.h>
//#include <windowsx.h>
#include <winsock2.h>
#include <ipexport.h>

#include <tchar.h>
#include <snmp.h>
#include <mgmtapi.h>

#include <stdio.h>
#include <winspool.h>
#include <stdlib.h>
#include <icmpapi.h>
#include <strsafe.h>


//
//  Files at ..\Common
//
#include "tcpmon.h"
#include "rtcpdata.h"
#include "CoreUI.h"
#include "mibabc.h"
#include "debug.h"		// debug functions


#endif	// INC_PCH_SPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\pingicmp.cpp ===
/*****************************************************************************
 *
 * $Workfile: PingICMP.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"
#include "pingicmp.h"


///////////////////////////////////////////////////////////////////////////////
//  CPingICMP::CPingICMP()

CPingICMP::CPingICMP(const char   *pHost) :
                        hIcmp(INVALID_HANDLE_VALUE), m_iLastError(NO_ERROR)
{
    strncpyn(m_szHost, pHost, sizeof( m_szHost));
}   // ::CPingICMP()


///////////////////////////////////////////////////////////////////////////////
//  CPingICMP::~CPingICMP()

CPingICMP::~CPingICMP()
{
    _ASSERTE(hIcmp == INVALID_HANDLE_VALUE);
}   // ::~CPingICMP()


///////////////////////////////////////////////////////////////////////////////
//  Open -- AF_INET, SOCK_RAW, IPPROTO_ICMP

BOOL
CPingICMP::Open()
{
    _ASSERTE(hIcmp == INVALID_HANDLE_VALUE);

    if ( (hIcmp = IcmpCreateFile()) == INVALID_HANDLE_VALUE )
    {
        m_iLastError = GetLastError();
        return FALSE;
    }

    return TRUE;
}   // ::Open()


///////////////////////////////////////////////////////////////////////////////
//  Close

BOOL
CPingICMP::Close()
{
    BOOL    bRet = (hIcmp == INVALID_HANDLE_VALUE || IcmpCloseHandle(hIcmp));

    if ( !bRet )
        m_iLastError = GetLastError();
    else
        hIcmp = INVALID_HANDLE_VALUE;

    return bRet;

}   // ::Close()


///////////////////////////////////////////////////////////////////////////////
//  Ping -- sends an ICMP Echo Request & reads the ICMP Echo Reply back. It
//      records the round trip time.
//      Note: SOCK_RAW support is optional in WinSock V1.1, so this will not
//      work over all WinSock implementations.
//      Error Codes:
//          NO_ERROR if successfull
//          WinSock error otherwise

BOOL
CPingICMP::Ping()
{
    BOOL                    bRet = FALSE;
    DWORD                   timeOut = 5 * 1000; // 5 seconds, 5000 milliseconds
    int                     i, nReplies, nRetries   = 2;    // It is not necessary to retry 3 times.
                                                            // Printers need retry means they are
                                                            // too far away to print

    char                    cSendBuf[4], cRcvBuf[1024];
    IP_OPTION_INFORMATION   IpOptions;
    PICMP_ECHO_REPLY        pReply;
    IPAddr                  IpAddr;


    if ( (IpAddr = ResolveAddress()) == INADDR_NONE || !Open() )
        return FALSE;

    ZeroMemory(&IpOptions, sizeof(IpOptions));
    IpOptions.Ttl   = 128;      // From ping utility (net\sockets\tcpcmd\ping)

    //
    // *** Since 0 initialized the following is not needed
    //
    // IpOptions.Tos   = 0;
    // IpOptions.OptionsSize    = 0;
    // IpOptions.OptionsData    = NULL;
    // IpOptions.Flags          = 0;

    for ( i = 0 ; i < sizeof(cSendBuf) ; ++i )
        cSendBuf[i] = 'a' + i;


    // send ICMP echo request
    for (i = 0; !bRet && i < nRetries; i++)
    {

        nReplies = IcmpSendEcho(hIcmp,
                                IpAddr,
                                cSendBuf,
                                sizeof(cSendBuf),
                                &IpOptions,
                                cRcvBuf,
                                sizeof(cRcvBuf),
                                timeOut);



        pReply = (PICMP_ECHO_REPLY)cRcvBuf;
        while (!bRet && nReplies--)
        {
            bRet = sizeof(cSendBuf) == pReply->DataSize  &&
                   memcmp(cSendBuf, pReply->Data, sizeof(cSendBuf)) == 0;
            pReply++;
        }
    }

    Close();

    return bRet;    // device is found

}   // ::Ping()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress

IPAddr
CPingICMP::ResolveAddress()
{
    IPAddr  ipAddr = INADDR_NONE;
    struct hostent  *h_info;        /* host information */

    /*
     * m_szHost is not necessarily a host name. It could be an IP address as well
     */

    if ( (ipAddr = inet_addr(m_szHost)) == INADDR_NONE )
    {
        if ((h_info = gethostbyname(m_szHost)) != NULL)
        {
            /*
            * Copy the IP address to the address structure.
            */
            memcpy(&ipAddr, h_info->h_addr, sizeof(ipAddr));
        }
    }

    return ipAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\status.h ===
/*****************************************************************************
 *
 * $Workfile: Status.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

//status.h

#ifndef STATUS_H
#define STATUS_H


/*  Asynch status codes, Peripheral Status Values */
#define MAX_ASYNCH_STATUS           76          /* MAX for generic printer applet */

#define ASYNCH_STATUS_UNKNOWN       0xFFFFFFFF
#define ASYNCH_PRINTER_ERROR        0
#define ASYNCH_DOOR_OPEN            1
#define ASYNCH_WARMUP               2
#define ASYNCH_RESET                3
#define ASYNCH_OUTPUT_BIN_FULL      4           /* yellow condition */
#define ASYNCH_PAPER_JAM            5
#define ASYNCH_TONER_GONE           6
#define ASYNCH_MANUAL_FEED          7
#define ASYNCH_PAPER_OUT            8
#define ASYNCH_PAGE_PUNT            9
#define ASYNCH_MEMORY_OUT           10
#define ASYNCH_OFFLINE              11
#define ASYNCH_INTERVENTION         12
#define ASYNCH_INITIALIZING         13
#define ASYNCH_TONER_LOW            14
#define ASYNCH_PRINTING_TEST_PAGE   15
#define ASYNCH_PRINTING             16
#define ASYNCH_ONLINE               17
#define ASYNCH_BUSY                 18
#define ASYNCH_NOT_CONNECTED        19
#define ASYNCH_STATUS_UNAVAILABLE   20
#define ASYNCH_NETWORK_ERROR        21
#define ASYNCH_COMM_ERROR           22
#define ASYNCH_BLACK_AGENT_EMPTY    23
#define ASYNCH_MAGENTA_AGENT_EMPTY  24
#define ASYNCH_CYAN_AGENT_EMPTY     25
#define ASYNCH_YELLOW_AGENT_EMPTY   26
#define ASYNCH_BLACK_AGENT_MISSING  27
#define ASYNCH_MAGENTA_AGENT_MISSING 28
#define ASYNCH_CYAN_AGENT_MISSING   29
#define ASYNCH_YELLOW_AGENT_MISSING 30
#define ASYNCH_TRAY1_EMPTY          31          /* yellow condition */
#define ASYNCH_TRAY2_EMPTY          32          /* yellow condition */
#define ASYNCH_TRAY3_EMPTY          33          /* yellow condition */
#define ASYNCH_TRAY1_JAM            34
#define ASYNCH_TRAY2_JAM            35
#define ASYNCH_TRAY3_JAM            36
#define ASYNCH_POWERSAVE_MODE       37          /* MAX for generic printer & Arrakis */
#define ASYNCH_ENVL_ERROR           38
#define ASYNCH_HCI_ERROR            39
#define ASYNCH_HCO_ERROR            40
#define ASYNCH_HCI_EMPTY            41          /* yellow condition */
#define ASYNCH_HCI_JAM              42
#define ASYNCH_TRAY1_ADD            43          /* red condition */
#define ASYNCH_TRAY2_ADD            44          /* red condition */
#define ASYNCH_TRAY3_ADD            45          /* red condition */
#define ASYNCH_HCI_ADD              46          /* red condition */
#define ASYNCH_TRAY1_UNKNOWN_MEDIA  47          /* yellow condition */
#define ASYNCH_CLEAR_OUTPUT_BIN     48          /* red condition */
#define ASYNCH_CARRIAGE_STALL             49
#define ASYNCH_COLOR_AGENT_EMPTY          50
#define ASYNCH_COLOR_AGENT_MISSING           51
#define ASYNCH_BLACK_AGENT_INCORRECT         52
#define ASYNCH_MAGENTA_AGENT_INCORRECT       53
#define ASYNCH_CYAN_AGENT_INCORRECT          54
#define ASYNCH_YELLOW_AGENT_INCORRECT        55
#define ASYNCH_COLOR_AGENT_INCORRECT         56
#define ASYNCH_BLACK_AGENT_INCORRECT_INSTALL 57
#define ASYNCH_MAGENTA_AGENT_INCORRECT_INSTALL  58
#define ASYNCH_CYAN_AGENT_INCORRECT_INSTALL     59
#define ASYNCH_YELLOW_AGENT_INCORRECT_INSTALL   60
#define ASYNCH_COLOR_AGENT_INCORRECT_INSTALL 61
#define ASYNCH_BLACK_AGENT_FAILURE           62
#define ASYNCH_MAGENTA_AGENT_FAILURE         63
#define ASYNCH_CYAN_AGENT_FAILURE            64
#define ASYNCH_YELLOW_AGENT_FAILURE          65
#define ASYNCH_COLOR_AGENT_FAILURE           66
#define ASYNCH_TRAY1_MISSING              67
#define ASYNCH_TRAY2_MISSING              68
#define ASYNCH_TRAY3_MISSING              69

//imports==================================================

#ifdef __cplusplus
extern "C" {
#endif

//prototypes===============================================
DWORD StdMibGetPeripheralStatus( const char *pHost, const char *pCommunity, DWORD dwDevIndex );
DWORD ProcessCriticalAlerts( DWORD errorState);
DWORD ProcessWarningAlerts( DWORD errorState);
DWORD ProcessOtherAlerts( DWORD deviceStatus);
void GetBitsFromString( LPSTR getVal, DWORD getSiz, LPDWORD bits);

#ifdef __cplusplus
}
#endif

#endif		//STATUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\snmpmgr.cpp ===
/*****************************************************************************
 *
 * $Workfile: SnmpMgr.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "stdoids.h"
#include "snmpmgr.h"


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr()

CSnmpMgr::CSnmpMgr() :
                    m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
                    m_iLastError(NO_ERROR), m_iRetries(DEFAULT_RETRIES),
                    m_iTimeout(DEFAULT_TIMEOUT),
                    m_bRequestType(DEFAULT_SNMP_REQUEST)
{
}   // ::CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr() -- establishes a session w/ a given agent
//          uses the default request type (get) & community name (public)

CSnmpMgr::CSnmpMgr( const char  in  *pHost,
                    const char  in  *pCommunity,
                    DWORD           dwDevIndex ) :
                        m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
                        m_iLastError(NO_ERROR), m_iRetries(DEFAULT_RETRIES),
                        m_iTimeout(DEFAULT_TIMEOUT),
                        m_bRequestType(DEFAULT_SNMP_REQUEST)
{
    size_t cchAgent = strlen(pHost) + 1;
    m_pAgent = (LPSTR)SNMP_malloc(cchAgent * sizeof m_pAgent [0]);      // copy the agent
    if( m_pAgent != NULL )
    {
        StringCchCopyA (m_pAgent, cchAgent, pHost);
    }
    size_t cchCommunity = strlen(pCommunity) + 1;
    m_pCommunity = (LPSTR)SNMP_malloc(cchCommunity * sizeof m_pCommunity [0]);  // copy the community name
    if( m_pCommunity != NULL )
    {
        StringCchCopyA (m_pCommunity, cchCommunity, pCommunity);
    }

    m_bRequestType = DEFAULT_SNMP_REQUEST;      // set the default request type == GET request

    m_pSession = NULL;
    if ( !Open() )              // establish a session w/ the agent
    {
        m_iLastError = GetLastError();
    }

}   // ::CSnmpMgr()


                                                        ///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::CSnmpMgr() -- establishes a session w/ a given agent
//          uses the default request type (get) & community name (public)

CSnmpMgr::CSnmpMgr( const char          in  *pHost,
                    const char          in  *pCommunity,
                    DWORD               in  dwDevIndex,
                    AsnObjectIdentifier in  *pMibObjId,
                    RFC1157VarBindList  out *pVarBindList) :
                        m_pAgent(NULL), m_pCommunity(NULL),m_pSession(NULL),
                        m_iLastError(NO_ERROR), m_iRetries(DEFAULT_RETRIES),
                        m_iTimeout(DEFAULT_TIMEOUT),
                        m_bRequestType(DEFAULT_SNMP_REQUEST)
{
    DWORD   dwRetCode = SNMPAPI_NOERROR;

    size_t cchAgent = strlen(pHost) + 1;
    m_pAgent = (LPSTR)SNMP_malloc(cchAgent * sizeof m_pAgent [0]);      // copy the agent
    if( m_pAgent != NULL )
    {
        StringCchCopyA (m_pAgent, cchAgent, pHost);
    }
    size_t cchCommunity = strlen(pCommunity) + 1;
    m_pCommunity = (LPSTR)SNMP_malloc(cchCommunity * sizeof m_pCommunity [0]);  // copy the community name
    if( m_pCommunity != NULL )
    {
        StringCchCopyA (m_pCommunity, cchCommunity, pCommunity);
    }

    m_bRequestType = DEFAULT_SNMP_REQUEST;      // set the default request type == GET request

    dwRetCode = BldVarBindList(pMibObjId, pVarBindList);
    if (dwRetCode == SNMPAPI_NOERROR)
    {
        m_pSession = NULL;
        if ( !Open() )              // establish a session w/ the agent
        {
            m_iLastError = GetLastError();
        }
    }

}   // ::CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  CSnmpMgr::~CSnmpMgr()

CSnmpMgr::~CSnmpMgr()
{
    if (m_pSession)     Close();    // close the session

    // delete the allocated memory from community & agent names
    if (m_pAgent)       SNMP_free(m_pAgent);
    if (m_pCommunity)   SNMP_free(m_pCommunity);

}   // ::~CSnmpMgr()


///////////////////////////////////////////////////////////////////////////////
//  Open() -- establishes a session
//      Error Codes:
//          SNMPAPI_NOERROR if successful
//          SNMPAPI_ERROR if fails

BOOL
CSnmpMgr::Open()
{
    m_iLastError = SNMPAPI_NOERROR;

    m_pSession = SnmpMgrOpen(m_pAgent, m_pCommunity, m_iTimeout, m_iRetries);
    if ( m_pSession == NULL )
    {
        m_iLastError = SNMPAPI_ERROR;
        m_pSession = NULL;
        return FALSE;
    }

    return TRUE;

}   // ::Open()


///////////////////////////////////////////////////////////////////////////////
//  Close() -- closes the previously established session

void
CSnmpMgr::Close()
{
    _ASSERTE( m_pSession != NULL);

    if ( !SnmpMgrClose(m_pSession) )
    {
        m_iLastError = GetLastError();
    }
    m_pSession = NULL;

}   // ::Close()


///////////////////////////////////////////////////////////////////////////////
//  Get() -- does an SNMP command (m_bRequestType) given a set of OIDs
//      Error Codes:
//              SNMP_ERRORSTATUS_NOERROR    if no error
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

int
CSnmpMgr::Get( RFC1157VarBindList   in  *pVariableBindings)
{
    int iRetCode = SNMP_ERRORSTATUS_NOERROR;

    AsnInteger  errorStatus;
    AsnInteger  errorIndex;

    if ( !SnmpMgrRequest( m_pSession, m_bRequestType, pVariableBindings, &errorStatus, &errorIndex) )
    {
        iRetCode = m_iLastError = GetLastError();
    }
    else
    {
        if (errorStatus > 0)
        {
            iRetCode = errorStatus;
        }
        else    // return the result of the variable bindings?
        {
            // variableBindings->list[x]->value contains the return value
        }
    }

    return iRetCode;

}   // ::Get()


///////////////////////////////////////////////////////////////////////////////
//  Walk -- given an object, it walks until the tree is done
//      Error Codes:
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

int
CSnmpMgr::Walk( RFC1157VarBindList  inout  *pVariableBindings)
{
    int iRetCode = SNMP_ERRORSTATUS_NOERROR;
    RFC1157VarBindList  variableBindings;
    UINT    numElements=0;
    LPVOID  pTemp;

    variableBindings.len = 0;
    variableBindings.list = NULL;

    variableBindings.len++;
    if ( (variableBindings.list = (RFC1157VarBind *)SNMP_realloc(variableBindings.list,
            sizeof(RFC1157VarBind) * variableBindings.len)) == NULL)
    {
        iRetCode = ERROR_NOT_ENOUGH_MEMORY;
        return iRetCode;
    }

    if ( !SnmpUtilVarBindCpy(&(variableBindings.list[variableBindings.len -1]), &(pVariableBindings->list[0])) )
    {
        iRetCode = ERROR_NOT_ENOUGH_MEMORY;
        return iRetCode;
    }

    AsnObjectIdentifier root;
    AsnObjectIdentifier tempOid;
    AsnInteger  errorStatus;
    AsnInteger  errorIndex;

    if (!SnmpUtilOidCpy(&root, &variableBindings.list[0].name))
    {
        iRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;
    while(1)        // walk the MIB tree (or sub-tree)
    {
        if (!SnmpMgrRequest(m_pSession, m_bRequestType, &variableBindings,
                        &errorStatus, &errorIndex))
        {
            // The API is indicating an error.
            iRetCode = m_iLastError = GetLastError();
            break;
        }
        else
        {
            // The API succeeded, errors may be indicated from the remote agent.
            // Test for end of subtree or end of MIB.
            if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
                        SnmpUtilOidNCmp(&variableBindings.list[0].name, &root, root.idLength))
            {
                iRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
                break;
            }

            // Test for general error conditions or sucesss.
            if (errorStatus > 0)
            {
                iRetCode = errorStatus;
                break;
            }
            numElements++;
        } // end if()

        // append the variableBindings to the pVariableBindings
        _ASSERTE(pVariableBindings->len != 0);
        if ( ( pTemp = (RFC1157VarBind *)SNMP_realloc(pVariableBindings->list,
                sizeof(RFC1157VarBind) * (pVariableBindings->len + 1))) == NULL)
        {
            iRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        else
        {
            pVariableBindings->list = (SnmpVarBind *)pTemp;
            pVariableBindings->len++;
        }

        if ( !SnmpUtilVarBindCpy(&(pVariableBindings->list[pVariableBindings->len -1]), &(variableBindings.list[0])) )
        {
            iRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Prepare for the next iteration.  Make sure returned oid is
        // preserved and the returned value is freed
        if( SnmpUtilOidCpy(&tempOid, &variableBindings.list[0].name) )
        {
            SnmpUtilVarBindFree(&variableBindings.list[0]);

            if ( SnmpUtilOidCpy(&variableBindings.list[0].name, &tempOid))
            {
                variableBindings.list[0].value.asnType = ASN_NULL;

                SnmpUtilOidFree(&tempOid);
            }
            else
            {
                iRetCode = SNMP_ERRORSTATUS_GENERR;
                goto CleanUp;
            }
        }
        else
        {
            iRetCode = SNMP_ERRORSTATUS_GENERR;
            goto CleanUp;
        }


    } // end while()

CleanUp:
    // Free the variable bindings that have been allocated.
    SnmpUtilVarBindListFree(&variableBindings);
    SnmpUtilOidFree(&root);

    if (iRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
        if (numElements != 0)   // list is full; iRetCode indicates the end of the MIB
            iRetCode = SNMP_ERRORSTATUS_NOERROR;

    return (iRetCode);

}   // Walk()


///////////////////////////////////////////////////////////////////////////////
//  WalkNext -- given object(s), it walks until the table has no more object
//      entries. The end of the table is determined by the first item in the list.
//      Error Codes:
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

int
CSnmpMgr::WalkNext( RFC1157VarBindList  inout  *pVariableBindings)
{
    int iRetCode = SNMP_ERRORSTATUS_NOERROR;
    RFC1157VarBindList  variableBindings;
    UINT    numElements=0;
    UINT    len=0, i=0;
    LPVOID  pTemp;

    variableBindings.len = 0;
    variableBindings.list = NULL;

    variableBindings.len = pVariableBindings->len;
    if ( (variableBindings.list = (RFC1157VarBind *)SNMP_realloc(variableBindings.list,
            sizeof(RFC1157VarBind) * variableBindings.len)) == NULL)
    {
        iRetCode = ERROR_NOT_ENOUGH_MEMORY;
        return iRetCode;
    }

    for (i=0; i<variableBindings.len; i++)
    {
        if ( !SnmpUtilVarBindCpy(&(variableBindings.list[i]), &(pVariableBindings->list[i])) )
        {
            iRetCode = ERROR_NOT_ENOUGH_MEMORY;
            return iRetCode;
        }
    }

    AsnObjectIdentifier root;
    AsnObjectIdentifier tempOid;
    AsnInteger  errorStatus;
    AsnInteger  errorIndex;

    if (!SnmpUtilOidCpy(&root, &variableBindings.list[0].name))
    {
        iRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }


    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;
    while(1)        // get the object(s) in the MIB table
    {
        if (!SnmpMgrRequest(m_pSession, m_bRequestType, &variableBindings,
                        &errorStatus, &errorIndex))
        {
            // The API is indicating an error.
            iRetCode = m_iLastError = GetLastError();
            break;
        }
        else
        {
            // The API succeeded, errors may be indicated from the remote agent.
            // Test for end of subtree or end of MIB.
            if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
                        SnmpUtilOidNCmp(&variableBindings.list[0].name, &root, root.idLength))
            {
                iRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
                break;
            }

            // Test for general error conditions or sucesss.
            if (errorStatus > 0)
            {
                iRetCode = errorStatus;
                break;
            }
            numElements++;
        } // end if()

        // append the variableBindings to the pVariableBindings
        _ASSERTE(pVariableBindings->len != 0);
        len = pVariableBindings->len;
        if ( (pTemp = (RFC1157VarBind *)SNMP_realloc(pVariableBindings->list,
                sizeof(RFC1157VarBind) * (pVariableBindings->len + variableBindings.len))) == NULL)
        {
            iRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        else
        {
            pVariableBindings->list = (SnmpVarBind *)pTemp;
            pVariableBindings->len += variableBindings.len;
        }

        int j=0;
        for ( i=len; i < pVariableBindings->len; i++, j++)
        {
            if ( !SnmpUtilVarBindCpy(&(pVariableBindings->list[i]), &(variableBindings.list[j])) )
            {
                iRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        // Prepare for the next iteration.  Make sure returned oid is
        // preserved and the returned value is freed
        for (i=0; i<variableBindings.len; i++)
        {
            if ( SnmpUtilOidCpy(&tempOid, &variableBindings.list[i].name) )
            {
                SnmpUtilVarBindFree(&variableBindings.list[i]);
                if( SnmpUtilOidCpy(&variableBindings.list[i].name, &tempOid))
                {
                    variableBindings.list[i].value.asnType = ASN_NULL;
                    SnmpUtilOidFree(&tempOid);
                }
                else
                {
                    iRetCode = SNMP_ERRORSTATUS_GENERR;
                    goto CleanUp;
                }
            }
            else
            {
                iRetCode = SNMP_ERRORSTATUS_GENERR;
                goto CleanUp;
            }

        }

    } // end while()

CleanUp:
    // Free the variable bindings that have been allocated.
    SnmpUtilVarBindListFree(&variableBindings);
    SnmpUtilOidFree(&root);

    if (iRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
        if (numElements != 0)   // list is full; iRetCode indicates the end of the MIB
            iRetCode = SNMP_ERRORSTATUS_NOERROR;

    return (iRetCode);

}   // WalkNext()


///////////////////////////////////////////////////////////////////////////////
//  GetNext -- does an SNMP GetNext command on the set of OID(s)
//      Error Codes:
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

int
CSnmpMgr::GetNext(  RFC1157VarBindList  inout  *pVariableBindings)
{
    int iRetCode = SNMP_ERRORSTATUS_NOERROR;
    AsnInteger  errorStatus;
    AsnInteger  errorIndex;

    m_bRequestType = ASN_RFC1157_GETNEXTREQUEST;

    if ( !SnmpMgrRequest( m_pSession, m_bRequestType, pVariableBindings, &errorStatus, &errorIndex) )
    {
        iRetCode = m_iLastError = GetLastError();
    }
    else
    {
        if (errorStatus > 0)
        {
            iRetCode = errorStatus;
        }
        else    // return the result of the variable bindings?
        {
            // variableBindings->list[x]->value contains the return value
        }
    }

    return (iRetCode);

}   // GetNext()


///////////////////////////////////////////////////////////////////////////////
//  BldVarBindList -- given a category, it retuns the RFC1157VarBindList
//      Error Codes:
//          NO_ERROR if successful
//          ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//          ERROR_INVALID_HANDLE        if can't build the variable bindings

DWORD
CSnmpMgr::BldVarBindList( AsnObjectIdentifier in     *pMibObjId,        // group identifier
                          RFC1157VarBindList  inout  *pVarBindList)
{
    DWORD   dwRetCode = SNMPAPI_NOERROR;
    LPVOID  pTemp;

    m_iLastError = SNMPAPI_NOERROR;
    while (pMibObjId->idLength != 0)
    {
        // setup the variable bindings
        CONST UINT uNewLen = pVarBindList->len + 1;
        if ( (pTemp = (RFC1157VarBind *)SNMP_realloc(pVarBindList->list,
                sizeof(RFC1157VarBind) * uNewLen)) == NULL)
        {
            m_iLastError = ERROR_NOT_ENOUGH_MEMORY;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            pVarBindList->list = (SnmpVarBind *)pTemp;
            pVarBindList-> len = uNewLen;
        }

        AsnObjectIdentifier reqObject;
        if ( !SnmpUtilOidCpy(&reqObject, pMibObjId) )
        {
            m_iLastError = ERROR_INVALID_HANDLE;
            return ERROR_INVALID_HANDLE;
        }

        pVarBindList->list[pVarBindList->len -1].name = reqObject;
        pVarBindList->list[pVarBindList->len -1].value.asnType = ASN_NULL;

        pMibObjId++;
    }

    return dwRetCode;

}   // BldVarBindList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\status.cpp ===
/*****************************************************************************
 *
 * $Workfile: Status.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdoids.h"
#include "status.h"


/********************************************************
    status notes:

    1. ASYNCH_NETWORK_ERROR handled by calling function,
        GetObjectSNMP() located in snmp.c

*********************************************************/



//constants==============================================
#define NA 0
#define OTHER_ALERTS        MAX_ASYNCH_STATUS+1
#define WARNING_ALERTS      MAX_ASYNCH_STATUS+2
#define CRITICAL_ALERTS     MAX_ASYNCH_STATUS+3

//hrPrinterDetectedErrorState Masks
#define LOW_PAPER               0x00000080
#define NO_PAPER                0x00000040
#define LOW_TONER               0x00000020
#define NO_TONER                0x00000010
#define DOOR_OPEN               0x00000008
#define PAPER_JAM               0x00000004
#define OFF_LINE                0x00000002
#define SERVICE_REQUESTED       0x00000001


//subunit status
#define AVAIL_IDLE              0L          //available and idle
#define AVAIL_STDBY             2L          //available and in standby
#define AVAIL_ACTIVE            4L          //available and active
#define AVAIL_BUSY              6L


#define UNAVAIL_ONREQ           1L          //unavailable and on-request
#define UNAVAIL_BROKEN          3L          //unavailable because broken
#define AVAIL_UNKNOWN           5L

#define NON_CRITICAL_ALERT      8L
#define CRITICAL_ALERT          16L

#define OFF_LINEx               32L

#define TRANS                   64L         //transitioning to intended state


#define NUM_TRAYS 2

/*************
   Printer     hrDeviceStatus  hrPrinterStatus  hrPrinterDetectedErrorState
   Status

   Normal         running(2)     idle(3)        none set

   Busy/          running(2)     printing(4)
   Temporarily
   Unavailable

   Non Critical   warning(3)     idle(3) or     could be: lowPaper,
   Alert Active                  printing(4)    lowToner, or
                                                serviceRequested

   Critical       down(5)        other(1)       could be: jammed,
   Alert Active                                 noPaper, noToner,
                                                coverOpen, or
                                                serviceRequested

   Unavailable    down(5)        other(1)

   Moving off-    warning(3)     idle(3) or     offline
   line                          printing(4)




   Smith, Wright, Hastings, Zilles & Gyllenskog                   [Page 14]

   RFC 1759                      Printer MIB                     March 1995


   Off-line       down(5)        other(1)       offline

   Moving         down(5)        warmup(5)
   on-line

   Standby        running(2)     other(1)
*************/

//lookup table for basic status
// [device status][printer status]
#define LOOKUP_TABLE_ROWS  5
#define LOOKUP_TABLE_COLS  5
BYTE basicStatusTable[LOOKUP_TABLE_COLS][LOOKUP_TABLE_ROWS] =
{
                    /*other                 unknown idle              printing                      warmup*/
/*unknown*/ { NA,                       NA,         NA,                     NA,                                 NA },
/*running*/ { ASYNCH_POWERSAVE_MODE,    NA,         ASYNCH_ONLINE,          ASYNCH_PRINTING,                    ASYNCH_WARMUP },
/*warning*/ { NA,                       NA,         WARNING_ALERTS,         WARNING_ALERTS,                     WARNING_ALERTS },
/*testing*/ { OTHER_ALERTS,             NA,         NA,                     ASYNCH_PRINTING_TEST_PAGE,          NA },
/*down*/    { CRITICAL_ALERTS,          NA,         NA,                     NA,                                 ASYNCH_WARMUP }
};


///////////////////////////////////////////////////////////////////////////////
//  StdMibGetPeripheralStatus
//      Returns Printer status ( Async Code )
//          or ASYNCH_STATUS_UNKNOWN     if Printer MIB is not supported on the device

DWORD
StdMibGetPeripheralStatus( const char in *pHost,
                           const char in *pCommunity,
                           DWORD      in dwDevIndex)
{
    DWORD       dwRetCode   = NO_ERROR;
    DWORD       errorState;
    WORD        wLookup     = NA;
    RFC1157VarBindList  variableBindings;

    UINT  OID_HRMIB_hrDeviceStatus[]                = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5, dwDevIndex};
    UINT  OID_HRMIB_hrPrinterStatus[]               = { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1, dwDevIndex};
    UINT  OID_HRMIB_hrPrinterDetectedErrorState[]   = { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2, dwDevIndex};

    AsnObjectIdentifier OT_DEVICE_STATUS[] = {  { OID_SIZEOF(OID_HRMIB_hrDeviceStatus), OID_HRMIB_hrDeviceStatus },
                                                { OID_SIZEOF(OID_HRMIB_hrPrinterStatus), OID_HRMIB_hrPrinterStatus },
                                                { OID_SIZEOF(OID_HRMIB_hrPrinterDetectedErrorState), OID_HRMIB_hrPrinterDetectedErrorState },
                                                { 0, 0 } };
    // build the variable bindings list
    variableBindings.list = NULL;
    variableBindings.len = 0;

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);

    if ( !pSnmpMgr )
    {
        return ERROR_OUTOFMEMORY;
    }

    if (pSnmpMgr->GetLastError() != SNMPAPI_NOERROR )
    {
        delete pSnmpMgr;
        return ASYNCH_STATUS_UNKNOWN;
    }

    dwRetCode = pSnmpMgr->BldVarBindList(OT_DEVICE_STATUS, &variableBindings);
    if (dwRetCode != SNMPAPI_NOERROR)
    {
        SnmpUtilVarBindListFree(&variableBindings);
        delete pSnmpMgr;
        return ASYNCH_STATUS_UNKNOWN;
    }

    // get the status objects
    dwRetCode = pSnmpMgr->Get(&variableBindings);
    if (dwRetCode != NO_ERROR)
    {
        SnmpUtilVarBindListFree(&variableBindings);
        delete pSnmpMgr;
        if (dwRetCode == SNMP_ERRORSTATUS_NOSUCHNAME)
            dwRetCode = ASYNCH_ONLINE;
        else
            dwRetCode = ASYNCH_STATUS_UNKNOWN;
        return dwRetCode;
    }


    if(dwRetCode == NO_ERROR)
    {
        if( (variableBindings.list[0].value.asnValue.number-1 < 0) ||
            (variableBindings.list[0].value.asnValue.number-1>=LOOKUP_TABLE_COLS) )
        {
            wLookup = OTHER_ALERTS;
        }
        else if( (variableBindings.list[1].value.asnValue.number-1 < 0) ||
                 (variableBindings.list[1].value.asnValue.number-1 >=LOOKUP_TABLE_ROWS) )
        {
            wLookup = OTHER_ALERTS;
        }
        else
        {
            wLookup = basicStatusTable[variableBindings.list[0].value.asnValue.number-1]
                                      [variableBindings.list[1].value.asnValue.number-1];
        }
        switch(wLookup)
        {
            case NA:
                dwRetCode = ASYNCH_STATUS_UNKNOWN;
                break;

            case CRITICAL_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessCriticalAlerts(errorState);
                break;

            case WARNING_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessWarningAlerts(errorState);
                break;

            case OTHER_ALERTS:
                GetBitsFromString((LPSTR)(variableBindings.list[2].value.asnValue.string.stream),
                    variableBindings.list[2].value.asnValue.string.length, &errorState );
                dwRetCode = ProcessOtherAlerts( errorState);
                break;

            default:
                dwRetCode = wLookup;
                break;
        }
    }
    else
    {
        dwRetCode = ASYNCH_STATUS_UNKNOWN;
    }


    SnmpUtilVarBindListFree(&variableBindings);
    delete pSnmpMgr;

    return dwRetCode;

}   // StdMibGetPeripheralStatus()


///////////////////////////////////////////////////////////////////////////////
//  ProcessCriticalAlerts  - determine active critical error
//
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )

DWORD
ProcessCriticalAlerts( DWORD    errorState )
{
    DWORD status = ASYNCH_ONLINE;

    if ( errorState & DOOR_OPEN) {
        status = ASYNCH_DOOR_OPEN;
    }
    else if( errorState & NO_TONER) {
        status = ASYNCH_TONER_GONE;
    }
    else if( errorState & NO_PAPER) {
        status = ASYNCH_PAPER_OUT;
    }
    else if( errorState & PAPER_JAM ) {
        status = ASYNCH_PAPER_JAM;
    }
    else if(errorState & SERVICE_REQUESTED) {
        status = ASYNCH_PRINTER_ERROR;
    }
    else if( errorState & OFF_LINE) {
        status = ASYNCH_OFFLINE;
    }
    else
        status = ASYNCH_PRINTER_ERROR;

    return status;

}   // ProcessCriticalAlerts()

///////////////////////////////////////////////////////////////////////////////
//  ProcessWarningAlerts  - determine active warning
//
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )

DWORD
ProcessWarningAlerts( DWORD errorState )
{
    DWORD status = ASYNCH_ONLINE;

    if( errorState & LOW_PAPER) {
        status = ASYNCH_ONLINE;
    }
    else if(errorState & LOW_TONER) {
        status = ASYNCH_TONER_LOW;
    }
    else if( errorState & SERVICE_REQUESTED) {

        // Changed it from ASYNCH_INTERVENTION; since if hrDeviceStatus = warning,
        // the printer can still print even though hrPrinterDetectedErrorState = serviceRequested
        //

        status = ASYNCH_ONLINE;
    }
    else if( errorState == 0) {
        status = ASYNCH_ONLINE;
    }
    else {
        status = ASYNCH_STATUS_UNKNOWN;
    }

    return status;
}   // ProcessWarningAlerts()

///////////////////////////////////////////////////////////////////////////////
//  ProcessWarningAlerts  - determine status for other Alerts
//      returns the device status for Critical Alerts ( ASYNC_XXXXX )
DWORD ProcessOtherAlerts( DWORD errorState )
{
    DWORD status = ASYNCH_ONLINE;

    //
    // This is a place holder for future functionality
    //

    status = ASYNCH_STATUS_UNKNOWN;

    return status;
}   // ProcessOtherAlerts

///////////////////////////////////////////////////////////////////////////////
//  GetBitsFromString  -
//      extracts the bin numbers from collection string returned by the get
//
void GetBitsFromString( LPSTR    getVal,
                        DWORD    getSiz,
                        LPDWORD  bits)
{
   char* ptr = (char*)bits;
   *bits = 0;

#if defined(_INTEL) || defined(WINNT)

   switch(getSiz)
   {
      case 1:
         ptr[0] = getVal[0];
         break;

      case 2:
         ptr[1] = getVal[0];
         ptr[0] = getVal[1];
         break;

      case 3:
         ptr[2] = getVal[0];
         ptr[1] = getVal[1];
         ptr[0] = getVal[2];
         break;

      case 4:
         ptr[3] = getVal[0];
         ptr[2] = getVal[1];
         ptr[1] = getVal[2];
         ptr[0] = getVal[3];
         break;
   }

#elif defined(_MOTOROLLA)

   switch(getSiz)
   {
      case 1:
         ptr[3] = getVal[0];
         break;

      case 2:
         ptr[2] = getVal[0];
         ptr[3] = getVal[1];
         break;

      case 3:
         ptr[1] = getVal[0];
         ptr[2] = getVal[1];
         ptr[3] = getVal[2];
         break;

      case 4:
         ptr[0] = getVal[0];
         ptr[1] = getVal[1];
         ptr[2] = getVal[2];
         ptr[3] = getVal[3];
         break;
   }

#else

   #error #define a swap method ( _INTEL, _MOTOROLLA )

#endif /* _INTEL, _MOTOROLLA */

}   // GetBitsFromString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\snmpmgr.h ===
/*****************************************************************************
 *
 * $Workfile: SnmpMgr.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_SNMPMGR_H
#define INC_SNMPMGR_H

#define	DEFAULT_IP_GET_COMMUNITY_ALT	"internal"	// HP devices only


#define	MAX_JDPORTS				3						// # of JetDirect Ex ports
#define	MAX_COMMUNITY_LEN		32						// maximum community length
#define	DEFAULT_SNMP_REQUEST	ASN_RFC1157_GETREQUEST	// get request is the default
#define	DEFAULT_TIMEOUT			6000					// milliseconds
#define	DEFAULT_RETRIES			3

typedef enum {
	DEV_UNKNOWN	= 0,
	DEV_OTHER	= 1,
	DEV_HP_JETDIRECT= 2,
	DEV_TEK_PRINTER	= 3,
	DEV_LEX_PRINTER	= 4,
	DEV_IBM_PRINTER	= 5,
	DEV_KYO_PRINTER	= 6,
	DEV_XER_PRINTER	= 7
}	DeviceType;

class CMemoryDebug;


class CSnmpMgr
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CSnmpMgr();
	CSnmpMgr( const char *pHost,
			  const char *pCommunity,
			  DWORD		 dwDevIndex);
	CSnmpMgr( const char			*pHost,
			  const char			*pCommunity,
			  DWORD					dwDevIndex,
			  AsnObjectIdentifier	*pMibObjId,
			  RFC1157VarBindList	*pVarBindList);
	~CSnmpMgr();

	INT		GetLastError(void)	 { return m_iLastError; };
	INT		Get( RFC1157VarBindList	*pVariableBindings);
	INT		Walk(RFC1157VarBindList *pVariableBindings);
	INT		WalkNext(RFC1157VarBindList  *pVariableBindings);
	INT		GetNext(RFC1157VarBindList  *pVariableBindings);
	DWORD	BldVarBindList( AsnObjectIdentifier   *pMibObjId,		// builds the varBindList
						    RFC1157VarBindList    *pVarBindList);

private:	// methods
	BOOL	Open();		// establish a session
	void	Close();	// close the previously established session

private:	// attributes
	LPSTR				m_pCommunity;
	LPSTR				m_pAgent;			
	LPSNMP_MGR_SESSION	m_pSession;

	INT					m_iLastError;
	INT					m_iTimeout;
	INT					m_iRetries;
	BYTE				m_bRequestType;
};


#endif	// INC_SNMPMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdmib.h ===
/*****************************************************************************
 *
 * $Workfile: StdMib.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_STDMIB_H
#define INC_STDMIB_H

#define	IFTYPE_OTHER		1
#define	IFTYPE_ETHERNET		6

enum SNMPCMD	{ SNMP_GET,			// SNMP commands
				  SNMP_WALK,
				  SNMP_GETNEXT,
				  SNMP_SET };

class CMemoryDebug;
class CTcpMib;

class CStdMib
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CStdMib( CTcpMib *pParent );

	CStdMib(const char	*pHost,
		    const char  *pszCommunity,
			DWORD		dwDevIndex,
			CTcpMib		*pParent );

	~CStdMib();

	BOOL	GetDeviceDescription(LPTSTR       pszPortDescription, DWORD dwDescLen);
	DWORD	GetDeviceStatus( );
	DWORD	GetJobStatus( );
	DWORD	GetDeviceHWAddress( LPTSTR psztHWAddress, DWORD dwSize);
	DWORD	GetDeviceName( LPTSTR psztDescription, DWORD dwSize );
	BOOL	TestPrinterMIB( );
	DWORD	MapJobErrorToSpooler( const DWORD dwStatus);

private:	// method
	DWORD	OIDQuery( AsnObjectIdentifier *pMibObjId,
					  SNMPCMD			  eSnmpCmd);	
	DWORD	OIDQuery( RFC1157VarBindList *pVarBindList,
					  SNMPCMD			 eSnmpCmd );
	BOOL	OIDVarBindCpy( RFC1157VarBindList	*pVarBindList );
    static  BOOL GetAsnOctetString(  char               *pszStr,
                                     DWORD              dwCount,
                                     RFC1157VarBindList *pVarBindList,
                                     UINT               i);



private:	// attributes
	char	m_szAgent[MAX_NETWORKNAME_LEN];
	char	m_szCommunity[MAX_SNMP_COMMUNITY_STR_LEN];
	DWORD	m_dwDevIndex;
	CTcpMib	*m_pParent;

	RFC1157VarBindList	m_VarBindList;

};


#endif	// INC_STDMIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdoids.cpp ===
/*****************************************************************************
 *
 * $Workfile: StdOids.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "stdoids.h"


// MIB2 group
UINT OID_Mib2_Prefix[] = { 1, 3, 6, 1, 2, 1 };
AsnObjectIdentifier MIB2_OidPrefix = { OID_SIZEOF(OID_Mib2_Prefix), OID_Mib2_Prefix };

// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
// all others are used for GetNext purposes, and they are located in a table

// MIB2 - system group
UINT OID_Mib2_sysDescr[] = { 1, 3, 6, 1, 2, 1, 1, 1, 0 };
UINT OID_Mib2_sysContact[] = { 1, 3, 6, 1, 2, 1, 1, 4, 0};

// MIB2 - interfaces group
UINT OID_Mib2_ifType[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 3 };
AsnObjectIdentifier OID_Mib2_ifTypeTree = { OID_SIZEOF(OID_Mib2_ifType), OID_Mib2_ifType };
UINT OID_Mib2_ifPhysAddress[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 6 };


// MIB2 - tcp group
UINT OID_Mib2_tcpConnTable[] = { 1, 3, 6, 1, 2, 1, 6, 13, 1 };
UINT OID_Mib2_tcpConnLocalPort[] = { 1, 3, 6, 1, 2, 1, 6, 13, 1, 3 };

// Printer MIB group
UINT OID_PrtMIB_Prefix[] = { 1, 3, 6, 1, 2, 1, 43 };
AsnObjectIdentifier PrtMIB_OidPrefix = { OID_SIZEOF(OID_PrtMIB_Prefix), OID_PrtMIB_Prefix };

UINT OID_PrtMIB_testPrinterMIB[] = { 1, 3, 6, 1, 2, 1, 43 };

// HR MIB - host resources
UINT OID_HRMIB_hrDeviceType[] = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 2};
UINT OID_HRMIB_hrDeviceDescr[] = { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 3};
UINT OID_HRMIB_hrDevicePrinter[] = { 1, 3, 6, 1, 2, 1, 25, 3, 1, 5};
AsnObjectIdentifier HRMIB_hrDevicePrinter = { OID_SIZEOF(OID_HRMIB_hrDevicePrinter), OID_HRMIB_hrDevicePrinter };

// status objects are defined in status .cpp
//  OID_HRMIB_hrDeviceStatus[] 				= { 1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5, 1};
//  OID_HRMIB_hrPrinterStatus[] 				= { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1, 1};
//  OID_HRMIB_hrPrinterDetectedErrorState[] 	= { 1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2, 1};


// OT_groups
// tests the existance of Printer MIB in the device
AsnObjectIdentifier OT_TEST_PRINTER_MIB[] =   {	{ OID_SIZEOF(OID_PrtMIB_testPrinterMIB), OID_PrtMIB_testPrinterMIB },
												{ 0, 0}
											};

// identifies the type of device
AsnObjectIdentifier OT_DEVICE_TYPE[] =  {	{ OID_SIZEOF(OID_Mib2_sysDescr), OID_Mib2_sysDescr },
											{ OID_SIZEOF(OID_Mib2_tcpConnLocalPort), OID_Mib2_tcpConnLocalPort },
											{ 0, 0}
										};

// identifies the ports on the device
AsnObjectIdentifier OT_DEVICE_TCPPORTS[] =  {	{ OID_SIZEOF(OID_Mib2_tcpConnLocalPort), OID_Mib2_tcpConnLocalPort },
												{ 0, 0}
											};

// identifies the hardware address of the device
AsnObjectIdentifier OT_DEVICE_ADDRESS[] =   {	{ OID_SIZEOF(OID_Mib2_ifType), OID_Mib2_ifType },
												{ OID_SIZEOF(OID_Mib2_ifPhysAddress), OID_Mib2_ifPhysAddress },
												{ 0, 0}
											};

// identifies the MIB 2 device description
AsnObjectIdentifier OT_DEVICE_SYSDESCR[] =   {	{ OID_SIZEOF(OID_Mib2_sysDescr), OID_Mib2_sysDescr },
												{ 0, 0}
											};

// identifies the HR device description (manufacturer id)
AsnObjectIdentifier OT_DEVICE_DESCRIPTION[] =   {	{ OID_SIZEOF(OID_HRMIB_hrDeviceType), OID_HRMIB_hrDeviceType },
													{ OID_SIZEOF(OID_HRMIB_hrDeviceDescr), OID_HRMIB_hrDeviceDescr },
													{ 0, 0}
												};

// identifies the status of the device defined in status .cpp
// AsnObjectIdentifier OT_DEVICE_STATUS[]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdoids.h ===
/*****************************************************************************
 *
 * $Workfile: StdOids.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/TcpMib/StdOids.h $
 * 
 * 4     9/22/97 2:15p Dsnelson
 * Updates the device status based on the device index
 * 
 * 3     7/18/97 1:16p Binnur
 * Fixed the Hardware address code
 * 
 * 2     7/14/97 2:34p Binnur
 * copyright statement
 * 
 * 1     7/08/97 5:18p Binnur
 * Initial File
 * 
 * 1     7/02/97 2:25p Binnur
 * Initial File
 * 
 *****************************************************************************/

#ifndef INC_OIDLIST_H
#define INC_OIDLIST_H

// Macro to determine number of sub-oid's in array.
#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )
#define	MAX_OIDSTR_SIZE		256

#define MIB_NUMITEMS(mib)		( sizeof(mib)/sizeof(AsnObjectIdentifier) )

// System Groups
extern AsnObjectIdentifier OT_DEVICE_TYPE[];		// identifies the type of device, such as multi-port device
extern AsnObjectIdentifier OT_DEVICE_TCPPORTS[];	// identifies the TCP ports on the device
extern AsnObjectIdentifier OT_DEVICE_ADDRESS[];		// identifies the hardware address of the device
extern AsnObjectIdentifier OT_DEVICE_SYSDESCR[];		// identifies the device manufacturer (description) -- mib2 table
extern AsnObjectIdentifier OT_DEVICE_DESCRIPTION[];		// identifies the device manufacturer -- host resources table
extern AsnObjectIdentifier OT_TEST_PRINTER_MIB[];		// tests the existance of Printer MIB

extern AsnObjectIdentifier PrtMIB_OidPrefix;			// identifies the Printer MIB tree
extern AsnObjectIdentifier HRMIB_hrDevicePrinter;		// identifies the printer entry in the HR device table
extern AsnObjectIdentifier OID_Mib2_ifTypeTree;


#endif	// INC_OIDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\stdmib.cpp ===
/*****************************************************************************
 *
 * $Workfile: StdMib.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdoids.h"
#include "status.h"
#include "stdmib.h"
#include "tcpmib.h"


///////////////////////////////////////////////////////////////////////////////
//  CStdMib::CStdMib()

CStdMib::CStdMib( CTcpMib	in	*pParent ) :
					m_dwDevIndex( 1 ),m_pParent(pParent)
{
	m_VarBindList.len = 0;
	m_VarBindList.list = NULL;

	*m_szAgent = '\0';
	strncpyn(m_szCommunity, DEFAULT_SNMP_COMMUNITYA, sizeof( m_szCommunity));
}	// ::CStdMib()

///////////////////////////////////////////////////////////////////////////////
//  CStdMib::CStdMib()

CStdMib::CStdMib(const char in *pHost,
				 const char in *pCommunity,
				 DWORD		   dwDevIndex,
				 CTcpMib	in *pParent ) :
					m_dwDevIndex( dwDevIndex ),m_pParent(pParent)
{
	m_VarBindList.len = 0;
	m_VarBindList.list = NULL;

	strncpyn(m_szAgent, pHost, sizeof( m_szAgent ));
	strncpyn(m_szCommunity, pCommunity, sizeof( m_szCommunity ));
}	// ::CStdMib()


///////////////////////////////////////////////////////////////////////////////
//  CStdMib::~CStdMib()

CStdMib::~CStdMib()
{
	m_pParent = NULL;
}	// ::~CStdMib()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceDescription
//

BOOL
CStdMib::GetDeviceDescription(
    OUT LPTSTR       pszPortDescription,
	IN  DWORD	     dwDescLen
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLen;
    LPSTR   psz;

    m_VarBindList.list = NULL;
    m_VarBindList.len = 0;

    if ( NO_ERROR != OIDQuery(OT_DEVICE_SYSDESCR, SNMP_GET) )
        goto cleanup;

    //
    // If we got the device description successfully, allocate memory and
    // return this back in a UNICODE string. Caller is responsible for
    // freeing it using free()
    //
    psz = (LPSTR)m_VarBindList.list[0].value.asnValue.string.stream;
    dwLen = (DWORD)m_VarBindList.list[0].value.asnValue.string.length;

    if ( bRet = MultiByteToWideChar(CP_ACP,
                                    MB_PRECOMPOSED,
                                    psz,
                                    dwLen,
                                    pszPortDescription,
                                    dwDescLen) )
        pszPortDescription[dwDescLen-1] = TEXT('\0');

cleanup:
    SnmpUtilVarBindListFree(&m_VarBindList);

    return bRet;

}	// ::GetDeviceDescription()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceStatus -- gets the device status

DWORD
CStdMib::GetDeviceStatus( )
{
	DWORD	dwRetCode = NO_ERROR;

	dwRetCode = StdMibGetPeripheralStatus( m_szAgent, m_szCommunity, m_dwDevIndex);

	return dwRetCode;

}	// ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus -- gets the device status, and maps it to the spooler
//		error codes -- see JOB_INFO_2
//			Error Codes:
//				Spooler error codes

DWORD
CStdMib::GetJobStatus( )
{
	DWORD	dwRetCode = NO_ERROR;
	DWORD	dwStatus = NO_ERROR;

	dwRetCode = StdMibGetPeripheralStatus( m_szAgent, m_szCommunity, m_dwDevIndex );
	if (dwRetCode != NO_ERROR)
	{
		dwStatus = MapJobErrorToSpooler( dwRetCode );
	}

	return dwStatus;

}	// ::GetJobStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceAddress -- gets the device hardware address
//		Error Codes:
//			NO_ERROR if successful
//			ERROR_NOT_ENOUGH_MEMORY		if memory allocation failes
//			ERROR_INVALID_HANDLE		if can't build the variable bindings
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()
//			SNMPAPI_ERROR if open fails -- set by GetLastError()

DWORD
CStdMib::GetDeviceHWAddress( LPTSTR out	psztHWAddress,
							 DWORD dwSize ) // Size of in characters in of HW address
{
	DWORD	dwRetCode = NO_ERROR;
	UINT i = 0;
	char szTmpHWAddr[256];

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	// get the hardware address
	dwRetCode = OIDQuery(OT_DEVICE_ADDRESS, SNMP_GETNEXT);		// query the first entry in the table
	if (dwRetCode != NO_ERROR)
	{
		goto cleanup;
	}

	while (1)	// instead of walking the tree, do a get next, until we filled up the HW address -- saves on the network communications
	{
		i = 0;
		// process the variableBinding
		if ( IS_ASN_INTEGER(m_VarBindList, i) )	// check the ifType
		{
			if ( GET_ASN_NUMBER(m_VarBindList, i) == IFTYPE_ETHERNET)
			{
				StringCchPrintfA (szTmpHWAddr, COUNTOF (szTmpHWAddr), "%02X%02X%02X%02X%02X%02X", GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 0),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 1),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 2),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 3),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 4),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 5) );
				MBCS_TO_UNICODE(psztHWAddress, dwSize, szTmpHWAddr);
				dwRetCode = NO_ERROR;
				break;
			}
			else if ( GET_ASN_NUMBER(m_VarBindList, i) == IFTYPE_OTHER)	// apperently, XEROX encodes their HW address w/ ifType = other
			{
				// check if the HWAddress is NULL
				if ( GET_ASN_STRING_LEN(m_VarBindList, i+1) != 0)
				{
					StringCchPrintfA (szTmpHWAddr, COUNTOF (szTmpHWAddr), "%02X%02X%02X%02X%02X%02X", GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 0),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 1),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 2),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 3),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 4),
													GET_ASN_OCTETSTRING_CHAR(m_VarBindList, i+1, 5) );
					MBCS_TO_UNICODE(psztHWAddress, dwSize, szTmpHWAddr);
					dwRetCode = NO_ERROR;
					break;
				}
			}
		}

		// didn't get what we were looking for, so copy the address over & do a another GetNext()
		if( !OIDVarBindCpy(&m_VarBindList) )
		{
			dwRetCode = GetLastError();
			goto cleanup;
		}

		if ( !SnmpUtilOidNCmp( &m_VarBindList.list[0].name, &OID_Mib2_ifTypeTree, OID_Mib2_ifTypeTree.idLength) )
		{
			break;		// end of the tree
		}

		dwRetCode = OIDQuery(&m_VarBindList, SNMP_GETNEXT);		// query the next entry in the table
		if (dwRetCode != NO_ERROR)		
		{
			goto cleanup;
		}
	}	// end while()

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);

	return dwRetCode;

}	// ::GetDeviceHWAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- gets the device description, such as the manufacturer string
//		Error Codes:
//			NO_ERROR if successful
//			ERROR_NOT_ENOUGH_MEMORY		if memory allocation failes
//			ERROR_INVALID_HANDLE		if can't build the variable bindings
//				SNMP_ERRORSTATUS_TOOBIG	if the packet returned is big
//				SNMP_ERRORSTATUS_NOSUCHNAME	if the OID isn't supported
//				SNMP_ERRORSTATUS_BADVALUE		
//				SNMP_ERRORSTATUS_READONLY
//				SNMP_ERRORSTATUS_GENERR
//				SNMP_MGMTAPI_TIMEOUT		-- set by GetLastError()
//				SNMP_MGMTAPI_SELECT_FDERRORS	-- set by GetLastError()
//			SNMPAPI_ERROR	if Open() for session fails

DWORD
CStdMib::GetDeviceName( LPTSTR out psztDescription,
					    DWORD  in  dwSize ) //Size in characters of the psztDescription
{
	DWORD	dwRetCode = NO_ERROR;

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	// 1st test for the support of Printer MIB -- note if Printer MIB supported, so is HR MIB
	BOOL bTestPrtMIB = TestPrinterMIB();

	char		szTmpDescr[MAX_DEVICEDESCRIPTION_STR_LEN];
	UINT i=0;
	// process the bindings
	if (bTestPrtMIB)	// parse the data from the HR MIB device entry
	{
		while (1)	// instead of walking the tree, do a get next, until we filled up the HW address -- saves on the network communications
		{
			i = 0;
			dwRetCode = OIDQuery(OT_DEVICE_DESCRIPTION, SNMP_GETNEXT);
			if (dwRetCode != NO_ERROR)
			{
				goto cleanup;
			}

			// process the variableBinding
			if ( IS_ASN_OBJECTIDENTIFIER(m_VarBindList, i) )	// check the hrDeviceType
			{
				// compare it to hrDevicePrinter
				if (SnmpUtilOidCmp(GET_ASN_OBJECT(&m_VarBindList, i), &HRMIB_hrDevicePrinter) == 0)
				{
					// found the printer description, get the hrDeviceDescr
					if ( IS_ASN_OCTETSTRING(m_VarBindList, i) )
					{
						if (GET_ASN_OCTETSTRING(szTmpDescr, sizeof(szTmpDescr), m_VarBindList, i))
                        {
                            MBCS_TO_UNICODE(psztDescription, dwSize, szTmpDescr);
                            dwRetCode = NO_ERROR;
                            break;
                        } else
                        {
                            dwRetCode =  SNMP_ERRORSTATUS_TOOBIG;
                            break;
                        }
					}
					else
					{
						dwRetCode = SNMP_ERRORSTATUS_NOSUCHNAME;
						break;
					}
				}
			}
			
			// didn't get what we were looking for, so copy the address over & do a another GetNext()
			if( !OIDVarBindCpy(&m_VarBindList) )
			{
				dwRetCode = GetLastError();
				goto cleanup;
			}
		}	// end while()

	}	// if TestPrinterMIB() TRUE
	else
	{
		dwRetCode = OIDQuery(OT_DEVICE_SYSDESCR, SNMP_GET);
		if (dwRetCode != NO_ERROR)
		{
			goto cleanup;
		}
		// process the variables
		if (GET_ASN_OCTETSTRING(szTmpDescr, sizeof(szTmpDescr), m_VarBindList, i))
        {
            MBCS_TO_UNICODE(psztDescription, dwSize, szTmpDescr);
            dwRetCode = NO_ERROR;
        }
	}	// if TestPrinterMIB() FALSE

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);

	return dwRetCode;

}	// ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  TestPrinterMIB -- tests if the device supports Printer MIB

BOOL
CStdMib::TestPrinterMIB( )
{
	DWORD	dwRetCode = NO_ERROR;
	BOOL	bRetCode = FALSE;

	// Process the variableBinding
	m_VarBindList.list = NULL;
	m_VarBindList.len = 0;

	dwRetCode = OIDQuery(OT_TEST_PRINTER_MIB, SNMP_GETNEXT);
	if (dwRetCode != NO_ERROR)
	{
		bRetCode = FALSE;
		goto cleanup;
	}

	// compare the resulting value w/ the Printer MIB tree value
	if (SnmpUtilOidNCmp(GET_ASN_OID_NAME(&m_VarBindList, 0), &PrtMIB_OidPrefix, PrtMIB_OidPrefix.idLength) == 0)
	{
		bRetCode = TRUE;
		goto cleanup;
	}

cleanup:
	SnmpUtilVarBindListFree(&m_VarBindList);
	
	return (bRetCode);

}	// ::TestPrinterMIB()


///////////////////////////////////////////////////////////////////////////////
//  OIDQuery -- calls into the CTcpMib class to query the OIDs passed in

DWORD	
CStdMib::OIDQuery( AsnObjectIdentifier in *pMibObjId,
				   SNMPCMD			   in eSnmpCmd )
{
	DWORD	dwRetCode = NO_ERROR;

	if( m_pParent == NULL ) {
		dwRetCode = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	switch (eSnmpCmd)
	{
		case SNMP_GET:
			dwRetCode = m_pParent->SnmpGet(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_WALK:
			dwRetCode = m_pParent->SnmpWalk(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_GETNEXT:
			dwRetCode = m_pParent->SnmpGetNext(m_szAgent, m_szCommunity,  m_dwDevIndex, pMibObjId, &m_VarBindList);
			goto cleanup;

			break;

		case SNMP_SET:
		default:
			dwRetCode = ERROR_NOT_SUPPORTED;
			goto cleanup;
	}

cleanup:
	if (dwRetCode != NO_ERROR)
	{
		SnmpUtilVarBindListFree(&m_VarBindList);
	}

	return (dwRetCode);

}	// ::OIDQuery()


///////////////////////////////////////////////////////////////////////////////
//  OIDQuery -- calls into the CTcpMib class to query the OIDs passed in

DWORD	
CStdMib::OIDQuery( RFC1157VarBindList inout *pVarBindList,
				   SNMPCMD			  in	eSnmpCmd )
{
	DWORD	dwRetCode = NO_ERROR;

	if( m_pParent == NULL ) {
		dwRetCode = ERROR_INVALID_HANDLE;
		goto cleanup;
	}

	switch (eSnmpCmd)
	{
		case SNMP_GET:
			dwRetCode = m_pParent->SnmpGet(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_WALK:
			dwRetCode = m_pParent->SnmpWalk(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_GETNEXT:
			dwRetCode = m_pParent->SnmpGetNext(m_szAgent, m_szCommunity,  m_dwDevIndex, pVarBindList);
			goto cleanup;

			break;

		case SNMP_SET:
		default:
			dwRetCode = ERROR_NOT_SUPPORTED;
			goto cleanup;
	}

cleanup:
	if (dwRetCode != NO_ERROR)
	{
		SnmpUtilVarBindListFree(pVarBindList);
	}

	return (dwRetCode);

}	// ::OIDQuery()


///////////////////////////////////////////////////////////////////////////////
//  OIDVarBindCpy --

BOOL	
CStdMib::OIDVarBindCpy( RFC1157VarBindList	inout	*pVarBindList )
{		
	UINT	i=0;
	AsnObjectIdentifier tempOid;

	for (i=0; i< PRFC1157_VARBINDLIST_LEN(pVarBindList); i++)
	{
		if( SnmpUtilOidCpy( &tempOid, &(PGET_ASN_OID_NAME(pVarBindList, i))))
		{
			SnmpUtilVarBindFree(&(pVarBindList->list[i]));
			if ( SnmpUtilOidCpy(&(PGET_ASN_OID_NAME(pVarBindList, i)), &tempOid))
			{
				PGET_ASN_TYPE(pVarBindList, i) = ASN_NULL;
				SnmpUtilOidFree(&tempOid);
			}
			else
			{
				return(FALSE);
			}
		}
		else
		{
			return(FALSE);
		}
	}
	
	return( TRUE );
}	// ::OIDVarBindCpy()


///////////////////////////////////////////////////////////////////////////////
//  MapJobErrorToSpooler -- Maps the received device error to the spooler
//		error codes.
//		Return Values:
//			Spooler device error codes

DWORD
CStdMib::MapJobErrorToSpooler( const DWORD in dwStatus)
{
	DWORD	dwRetCode = NO_ERROR;

	switch (dwStatus)
	{
		case ASYNCH_WARMUP:
		case ASYNCH_INITIALIZING:
			dwRetCode = JOB_STATUS_OFFLINE;
			break;
		case ASYNCH_DOOR_OPEN:
		case ASYNCH_PRINTER_ERROR:
		case ASYNCH_TONER_LOW:
		case ASYNCH_OUTPUT_BIN_FULL:
		case ASYNCH_STATUS_UNKNOWN:
		case ASYNCH_RESET:
		case ASYNCH_MANUAL_FEED:
		case ASYNCH_BUSY:
		case ASYNCH_PAPER_JAM:
		case ASYNCH_TONER_GONE:
			dwRetCode = JOB_STATUS_ERROR;
			break;
		case ASYNCH_PAPER_OUT:
			dwRetCode = JOB_STATUS_PAPEROUT;
			break;
		case ASYNCH_OFFLINE:
			dwRetCode = JOB_STATUS_OFFLINE;
			break;
		case ASYNCH_INTERVENTION:
			dwRetCode = JOB_STATUS_USER_INTERVENTION;
			break;
		case ASYNCH_PRINTING:
			dwRetCode = JOB_STATUS_PRINTING;
			break;
		case ASYNCH_ONLINE:
			dwRetCode = NO_ERROR;		
			break;
		default:
			dwRetCode = JOB_STATUS_PRINTING;
	}
	
	return dwRetCode;

}	// ::MapJobErrorToSpooler()

BOOL CStdMib::GetAsnOctetString(  char               *pszStr,
                                  DWORD              dwCount,
                                  RFC1157VarBindList *pVarBindList,
                                  UINT               i) {

    _ASSERTE( pszStr && pVarBindList );

    DWORD dwSize = GET_ASN_STRING_LEN( *pVarBindList, i);

    return dwCount >= dwSize ?
           memcpy(pszStr, pVarBindList->list[i].value.asnValue.string.stream, dwSize) != NULL :
           FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\tcpmib.cpp ===
/*****************************************************************************
 *
 * $Workfile: TcpMib.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "snmpmgr.h"
#include "stdmib.h"
#include "pingicmp.h"
#include "tcpmib.h"
#include "status.h"


///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

CTcpMib     *g_pTcpMib = 0;
int g_cntGlobalAlloc=0;     // used for debugging purposes
int g_csGlobalCount=0;

// to ensure that the CTCPMib is not being deleted improperly, perform usage count on the DLL
int g_cntUsage = 0;


///////////////////////////////////////////////////////////////////////////////
//  GetDLLInterfacePtr -- returns the pointer to the DLL interface

extern "C" CTcpMibABC*
GetTcpMibPtr( void )
{
    return (g_pTcpMib);

}   // GetDLLInterfacePtr()


///////////////////////////////////////////////////////////////////////////////
//  Ping -- pings the given device
//  Return Codes:
//      NO_ERROR            if ping is successfull
//      DEVICE_NOT_FOUND    if device is not found

extern "C" DWORD
Ping( LPCSTR    in  pHost )
{
    DWORD   dwRetCode = NO_ERROR;

    // do icmpPing
    CPingICMP *pPingICMP = new CPingICMP(pHost);

    if ( !pPingICMP )
        return (dwRetCode = GetLastError()) ? dwRetCode : ERROR_OUTOFMEMORY;

    if (  !pPingICMP->Ping() )
    {
        dwRetCode = ERROR_DEVICE_NOT_FOUND;
    }

    delete pPingICMP;

    return (dwRetCode);

}   // Ping()


///////////////////////////////////////////////////////////////////////////////
//  DllMain
//

BOOL APIENTRY
DllMain (   HANDLE in hInst,
            DWORD  in dwReason,
            LPVOID in lpReserved )
{

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInst );

            g_cntUsage++;       // DLL usage count
            if ( !g_pTcpMib)
            {
                g_pTcpMib = new CTcpMib();  // create the port manager object
                if (!g_pTcpMib)
                {
                    return FALSE;
                }
            }
            return TRUE;

        case DLL_PROCESS_DETACH:
            g_cntUsage--;       // DLL usage count
            if (g_cntUsage == 0)
            {
                if (g_pTcpMib)
                {
                    delete g_pTcpMib;   // FIX! do we need to worry about usage count here??
                    g_pTcpMib = NULL;
                }
            }
            return TRUE;

    }

    return FALSE;

}   // DllMain()


/*****************************************************************************
*
* CTcpMib implementation
*
*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
//  static functions & member initialization


///////////////////////////////////////////////////////////////////////////////
//  CTcpMib::CTcpMib()

CTcpMib::CTcpMib( )
{
    InitializeCriticalSection(&m_critSect);

}   // ::CTcpMib()


///////////////////////////////////////////////////////////////////////////////
//  CTcpMib::~CTcpMib()

CTcpMib::~CTcpMib( )
{
    DeleteCriticalSection(&m_critSect);

}   // ::~CTcpMib()


///////////////////////////////////////////////////////////////////////////////
//  EnterCSection -- enters the critical section

void
CTcpMib::EnterCSection( )
{
    EnterCriticalSection(&m_critSect);      // enter critical section

}   //  ::EnterCSection()


///////////////////////////////////////////////////////////////////////////////
//  ExitCSection -- enters the critical section

void
CTcpMib::ExitCSection( )
{
    LeaveCriticalSection(&m_critSect);      // exit critical section

}   //  ::ExitCSection()

///////////////////////////////////////////////////////////////////////////////
//  SupportsPrinterMib --
//
BOOL
CTcpMib::
SupportsPrinterMib(
    IN  LPCSTR      pHost,
    IN  LPCSTR      pCommunity,
    IN  DWORD       dwDevIndex,
    OUT PBOOL       pbSupported
    )
{
    BOOL    bRet = FALSE;
    DWORD   dwLastError = ERROR_SUCCESS;

    EnterCSection();

    if ( (dwLastError = Ping(pHost)) == NO_ERROR ) {
        CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);

        if ( pStdMib ) {

            *pbSupported = pStdMib->TestPrinterMIB();
            bRet = TRUE;
            delete pStdMib;
        }
    }

    ExitCSection();

    if (!bRet)
        SetLastError (dwLastError);

    return bRet;
}   // ::SupportsPrinterMib()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceDescription --
//
//  Returns:
//     NO_ERROR -
//     ERROR_DEVICE_NOT_FOUND -
//     SUCCESS_DEVICE_UNKNOWN
DWORD
CTcpMib::
GetDeviceDescription(
    IN  LPCSTR      pHost,
    IN  LPCSTR      pCommunity,
    IN  DWORD       dwDevIndex,
    OUT LPTSTR      pszPortDesc,
    IN  DWORD       dwDescLen
    )
{
    DWORD    dwRet = NO_ERROR;

    EnterCSection();

    if ( Ping(pHost) == NO_ERROR ) {
        CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);

        if ( pStdMib ) {

            if ( !pStdMib->GetDeviceDescription(pszPortDesc, dwDescLen)){
                dwRet = SUCCESS_DEVICE_UNKNOWN;
            }
            delete pStdMib;

        }
    } else {
        dwRet = ERROR_DEVICE_NOT_FOUND;
    }

    ExitCSection();

    return dwRet;
}   // ::GetDeviceDescription()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceStatus --
//      Error Codes:
//          Returns the mapped printer error code to the spooler error code

DWORD
CTcpMib::GetDeviceStatus( LPCSTR in  pHost,
                          LPCSTR    pCommunity,
                          DWORD     dwDevIndex )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceType()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceStatus();
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetDeviceStatus()


///////////////////////////////////////////////////////////////////////////////
//  GetJobStatus --
//      Error Codes:
//          Returns the mapped printer error code to the spooler error code

DWORD
CTcpMib::GetJobStatus( LPCSTR  in   pHost,
                       LPCSTR  in   pCommunity,
                       DWORD   in   dwDevIndex)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetJobStatus();
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetJobType()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceAddress -- gets the hardware address of the device
//      ERROR CODES:
//          NO_ERROR if successful
//          ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//          ERROR_INVALID_HANDLE        if can't build the variable bindings
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

DWORD
CTcpMib::GetDeviceHWAddress( LPCSTR  in  pHost,
                             LPCSTR  in  pCommunity,
                             DWORD   in  dwDevIndex,
                             DWORD   in  dwSize, // Size in characters of the HWAddress returned
                             LPTSTR  out psztHWAddress
                             )
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceAddress()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceHWAddress(psztHWAddress, dwSize);
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);

}   // ::GetDeviceAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetDeviceInfo -- gets the device description
//      ERROR CODES
//          NO_ERROR if successful
//          ERROR_NOT_ENOUGH_MEMORY     if memory allocation failes
//          ERROR_INVALID_HANDLE        if can't build the variable bindings
//              SNMP_ERRORSTATUS_TOOBIG if the packet returned is big
//              SNMP_ERRORSTATUS_NOSUCHNAME if the OID isn't supported
//              SNMP_ERRORSTATUS_BADVALUE
//              SNMP_ERRORSTATUS_READONLY
//              SNMP_ERRORSTATUS_GENERR
//              SNMP_MGMTAPI_TIMEOUT        -- set by GetLastError()
//              SNMP_MGMTAPI_SELECT_FDERRORS    -- set by GetLastError()

DWORD
CTcpMib::GetDeviceName( LPCSTR in   pHost,
                        LPCSTR in   pCommunity,
                        DWORD  in   dwDevIndex,
                        DWORD  in   dwSize,  // Size in characters of the description returned
                        LPTSTR out  psztDescription)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    // instantiate the CStdMib::GetDeviceInfo()
    CStdMib *pStdMib = new CStdMib(pHost, pCommunity, dwDevIndex, this);
    if ( pStdMib ) {

        dwRetCode = pStdMib->GetDeviceName(psztDescription, dwSize);
        delete pStdMib;
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

    ExitCSection();

    return (dwRetCode);
}   // ::GetDeviceAddress()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGet -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGet.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGet( LPCSTR                in  pHost,
                  LPCSTR                in  pCommunity,
                  DWORD                 in  dwDevIndex,
                  AsnObjectIdentifier   in  *pMibObjId,
                  RFC1157VarBindList    out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex, pMibObjId, pVarBindList);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Get(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);
}   // ::SnmpGet()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGet -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGet.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGet( LPCSTR                in      pHost,
                  LPCSTR                in      pCommunity,
                  DWORD                 in      dwDevIndex,
                  RFC1157VarBindList    inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Get(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpGet()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGetNext -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGetNext.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGetNext( LPCSTR                in  pHost,
                      LPCSTR                in  pCommunity,
                      DWORD                 in  dwDevIndex,
                      AsnObjectIdentifier   in  *pMibObjId,
                      RFC1157VarBindList    out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex,
                                         pMibObjId, pVarBindList);
    if( pSnmpMgr )   {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->GetNext(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpGetNext()


///////////////////////////////////////////////////////////////////////////////
//  SnmpGetNext -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpGetNext.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpGetNext( LPCSTR                in      pHost,
                      LPCSTR                in      pCommunity,
                      DWORD                 in      dwDevIndex,
                      RFC1157VarBindList    inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if ( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->GetNext(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);
}   // ::SnmpGetNext()


///////////////////////////////////////////////////////////////////////////////
//  SnmpWalk -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpWalk.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpWalk( LPCSTR               in  pHost,
                   LPCSTR               in  pCommunity,
                   DWORD                in  dwDevIndex,
                   AsnObjectIdentifier  in  *pMibObjId,
                   RFC1157VarBindList   out *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex,
                                         pMibObjId, pVarBindList);
    if( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Walk(pVarBindList)) != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }
    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpWalk()


///////////////////////////////////////////////////////////////////////////////
//  SnmpWalk -- given a set of OIDs & a buffer to get the results in, it returns
//  the results of the SnmpWalk.
//
//  Note: This calls directly into the SnmpMgr APIs

DWORD
CTcpMib::SnmpWalk( LPCSTR               in      pHost,
                   LPCSTR               in      pCommunity,
                   DWORD                in      dwDevIndex,
                   RFC1157VarBindList   inout   *pVarBindList)
{
    DWORD   dwRetCode = NO_ERROR;

    EnterCSection();

    CSnmpMgr    *pSnmpMgr = new CSnmpMgr(pHost, pCommunity, dwDevIndex);
    if( pSnmpMgr ) {

        if ( (dwRetCode = pSnmpMgr->GetLastError()) != SNMPAPI_NOERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

        if ( (dwRetCode = pSnmpMgr->Walk(pVarBindList))  != NO_ERROR ) {

            dwRetCode = ERROR_SNMPAPI_ERROR;
            goto cleanup;
        }

    } else {

        dwRetCode = ERROR_OUTOFMEMORY;
    }

cleanup:
    if ( pSnmpMgr )
        delete pSnmpMgr;

    ExitCSection();

    return (dwRetCode);

}   // ::SnmpWalk()



///////////////////////////////////////////////////////////////////////////////
//  SNMPToPrinterStatus -- Maps the received device error to the printer
//      error codes.
//      Return Values:
//          Spooler device error codes

DWORD
CTcpMib::SNMPToPrinterStatus( const DWORD in dwStatus)
{
    DWORD   dwRetCode = NO_ERROR;

    switch (dwStatus)
    {
        case ASYNCH_STATUS_UNKNOWN:
            dwRetCode = PRINTER_STATUS_NOT_AVAILABLE;
            break;
        case ASYNCH_PRINTER_ERROR:
            dwRetCode = PRINTER_STATUS_ERROR;
            break;
        case ASYNCH_DOOR_OPEN:
            dwRetCode = PRINTER_STATUS_DOOR_OPEN;
            break;
        case ASYNCH_WARMUP:
            dwRetCode = PRINTER_STATUS_WARMING_UP;
            break;
        case ASYNCH_RESET:
        case ASYNCH_INITIALIZING:
            dwRetCode = PRINTER_STATUS_INITIALIZING;
            break;
        case ASYNCH_OUTPUT_BIN_FULL:
            dwRetCode = PRINTER_STATUS_OUTPUT_BIN_FULL;
            break;
        case ASYNCH_PAPER_JAM:
            dwRetCode = PRINTER_STATUS_PAPER_JAM;
            break;
        case ASYNCH_TONER_GONE:
            dwRetCode = PRINTER_STATUS_NO_TONER;
            break;
        case ASYNCH_MANUAL_FEED:
            dwRetCode = PRINTER_STATUS_MANUAL_FEED;
            break;
        case ASYNCH_PAPER_OUT:
            dwRetCode = PRINTER_STATUS_PAPER_OUT;
            break;
        case ASYNCH_OFFLINE:
            dwRetCode = PRINTER_STATUS_OFFLINE;
            break;
        case ASYNCH_INTERVENTION:
            dwRetCode = PRINTER_STATUS_USER_INTERVENTION;
            break;
        case ASYNCH_TONER_LOW:
            dwRetCode = PRINTER_STATUS_TONER_LOW;
            break;
        case ASYNCH_PRINTING:
            dwRetCode = PRINTER_STATUS_PRINTING;
            break;
        case ASYNCH_BUSY:
            dwRetCode = PRINTER_STATUS_BUSY;
            break;
        case ASYNCH_ONLINE:
            dwRetCode = NO_ERROR;
            break;
        default:
            dwRetCode = PRINTER_STATUS_NOT_AVAILABLE;
    }

    return dwRetCode;

}   // SNMPToPrinterStatus()

///////////////////////////////////////////////////////////////////////////////
//  SNMPToPortStatus -- Maps the received device error to the printer
//      error codes.
//      Return Values:
//          Spooler device error codes

BOOL
CTcpMib::SNMPToPortStatus( const DWORD in dwStatus, PPORT_INFO_3 pPortInfo )
{
    DWORD   dwRetCode = NO_ERROR;

    pPortInfo->dwStatus = 0;
    pPortInfo->pszStatus = NULL;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;

    switch (dwStatus)
    {
        case ASYNCH_DOOR_OPEN:
            pPortInfo->dwStatus = PORT_STATUS_DOOR_OPEN;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_WARMUP:
            pPortInfo->dwStatus = PORT_STATUS_WARMING_UP;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_INFO;
            break;
        case ASYNCH_OUTPUT_BIN_FULL:
            pPortInfo->dwStatus = PORT_STATUS_OUTPUT_BIN_FULL;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_PAPER_JAM:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_JAM;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_TONER_GONE:
            pPortInfo->dwStatus = PORT_STATUS_NO_TONER;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_MANUAL_FEED:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_PROBLEM;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_PAPER_OUT:
            pPortInfo->dwStatus = PORT_STATUS_PAPER_OUT;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_PRINTER_ERROR:
        case ASYNCH_INTERVENTION:
        case ASYNCH_OFFLINE:
            pPortInfo->dwStatus = PORT_STATUS_OFFLINE;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_ERROR;
            break;
        case ASYNCH_TONER_LOW:
            pPortInfo->dwStatus = PORT_STATUS_TONER_LOW;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_WARNING;
            break;
        case ASYNCH_STATUS_UNKNOWN:
        case ASYNCH_POWERSAVE_MODE:
        case ASYNCH_RESET:
        case ASYNCH_INITIALIZING:
        case ASYNCH_PRINTING:
        case ASYNCH_BUSY:
        case ASYNCH_ONLINE:
        default:
            pPortInfo->dwStatus = 0;
            pPortInfo->dwSeverity = PORT_STATUS_TYPE_INFO;
            break;
    }

    return dwRetCode;

}   // ::SNMPStatusToPortStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cssocket.h ===
/*****************************************************************************
 *
 * $Workfile: CSSocket.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_CSSOCKET_H
#define INC_CSSOCKET_H

#define     SEND_TIMEOUT       15000   // 15 seconds


class CMemoryDebug;

class CStreamSocket
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
    CStreamSocket();
    ~CStreamSocket();

    INT         GetLastError(void)	 { return m_iLastError; };

    BOOL        Open();
    VOID        Close();
    DWORD       GetAckBeforeClose(DWORD dwSeconds);
    DWORD       PendingDataStatus(DWORD dwTimeout, LPDWORD pcbPending);
    BOOL        Connect(struct sockaddr_in * pRemoteAddr);
    BOOL        Bind();
    DWORD       Send(char far      *lpBuffer,
                     INT			iLength,
                     LPDWORD		pcbWritten);

    DWORD       ReceiveDataAvailable(IN      INT         iTimeout = 0);

    DWORD       Receive(char far   *lpBuffer,
                        INT			iBufSize,
                        INT			iFlags,
						INT			iTimeout,
                        LPDWORD		pcbRead);


	DWORD       Receive( );

	VOID        GetLocalAddress();
	VOID        GetRemoteAddress();
	
    BOOL        ResolveAddress(LPSTR    netperiph);
    BOOL        SetOptions();

private:
    DWORD       InternalSend(VOID);
    enum SOCKETSTATE {IDLE, CONNECTING, CONNECTED, LISTENING, WAITING_TO_CLOSE};

    //
    // cbBuf        : size of the buffer pointed by pBuf
    // cbData       : size of data in the buffer (could be less than cbBuf)
    // cbPending    : size of data in buffer sent with no confirmation yet
    //                (i.e. WSASend succesful but i/o is still pending)
    //
    DWORD           cbBuf, cbData, cbPending;
    WSAOVERLAPPED   WsaOverlapped;
    LPBYTE          pBuf;

    INT                     m_iLastError;		// Last error from Winsock call
    SOCKET                  m_socket;
    SOCKETSTATE	            m_iState;
    struct sockaddr_in      m_Paddr;
    struct sockaddr_in      m_localAddr;
#ifdef DEBUG
    DWORD                   m_dwTimeStart, m_dwTimeEnd;
    double                  m_TotalBytes;
#endif
};


#endif	// INC_CSSOCKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cluster.h ===
/*****************************************************************************
 *
 * $Workfile: cluster.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_CLUSTER_H
#define INC_CLUSTER_H

#include "regabc.h"
#include "portmgr.h"

class CMemoryDebug;

class CCluster : public CRegABC
#if defined _DEBUG || defined DEBUG
	, public CMemoryDebug
#endif
{
public:
	CCluster( HANDLE		hcKey,
			  HANDLE		hSpooler,
			  PMONITORREG	pMonitorReg);

	~CCluster();

	DWORD EnumeratePorts( CPortMgr *pPortMgr );

	DWORD SetPortMgrSettings(const DWORD  dStatusUpdateInterval,
							 const BOOL	  bStatusUpdateEnabled );

	DWORD GetPortMgrSettings(DWORD  *dStatusUpdateInterval,
							 BOOL   *bStatusUpdateEnabled );

	DWORD SetWorkingKey( LPCTSTR	lpKey);

	DWORD SetValue( LPCTSTR lpValueName,
					DWORD dwType, 
					CONST BYTE *lpData, 
					DWORD cbData ); 

	DWORD QueryValue(LPTSTR lpValueName, 
					 LPBYTE lpData, 
					 LPDWORD lpcbData ); 

	DWORD FreeWorkingKey();

	BOOL DeletePortEntry( LPTSTR in psztPortName);


private:
	// attributes

	PMONITORREG m_pMonitorReg;

	TCHAR	m_sztMonitorPorts[MAX_PATH];

	HANDLE		m_hcKey;
	HANDLE		m_hSpooler;
	HANDLE		m_hcWorkingKey;

    CRITICAL_SECTION	m_critSect;
};

#endif // INC_CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cssocket.cpp ===
/*****************************************************************************
 *
 * $Workfile: CSSocket.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "cssocket.h"



///////////////////////////////////////////////////////////////////////////////
//  global variables



///////////////////////////////////////////////////////////////////////////////
//  CStreamSocket::CStreamSocket()

CStreamSocket::
CStreamSocket(
    VOID
    ) : m_socket(INVALID_SOCKET), m_iState(IDLE), m_iLastError(NO_ERROR),
        cbBuf(0), cbData(0), cbPending(0), pBuf(NULL)
{
    ZeroMemory(&m_Paddr, sizeof(m_Paddr));
    ZeroMemory(&m_localAddr, sizeof(m_localAddr));
    ZeroMemory(&WsaOverlapped, sizeof(WsaOverlapped));
}   // CStreamSocket()


///////////////////////////////////////////////////////////////////////////////
//  CStreamSocket::~CStreamSocket()

CStreamSocket::
~CStreamSocket(
    VOID
    )
{

#ifdef DEBUG
    DWORD dwDiff;
    CHAR szBuf[512];

    m_dwTimeEnd = GetTickCount ();

    if (m_dwTimeEnd < m_dwTimeStart) {
        dwDiff = (m_dwTimeEnd - m_dwTimeStart + 0xffffffff) ;
    }
    else
        dwDiff = m_dwTimeEnd - m_dwTimeStart;

    // DBGMSG does not allow floating value, so we need to use sprintf instead

    sprintf (szBuf, "Job Data (before Close): %3.1f bytes,  %3.1f sec, %3.1f (KB /sec).\n",
             m_TotalBytes, dwDiff / 1000., (m_TotalBytes / dwDiff ));

    DBGMSG (DBG_PORT, ("%s", szBuf));

#endif

    Close();
}   // ~CStreamSocket()


///////////////////////////////////////////////////////////////////////////////
// Open
//  Error Codes:
//      TRUE if socket created, FALSE otherwise.

BOOL
CStreamSocket::
Open(
    VOID
    )
{
    int     iBufSize = 0;

    if ( m_socket != INVALID_SOCKET ) {

        _ASSERTE(m_socket == INVALID_SOCKET);
        return FALSE;
    }

    if ( (m_socket = WSASocket(PF_INET, SOCK_STREAM, 0, NULL,
                               0, WSA_FLAG_OVERLAPPED)) == INVALID_SOCKET ) {

        m_iLastError = WSAGetLastError();
        _RPT1(_CRT_WARN,
              "CSSOCKET -- Open(%d) error: can't create socket\n",
              m_iLastError);
        return FALSE;
    }

    //
    // Tell WinSock not to buffer data (i.e. buffer size of 0)
    //
    if ( setsockopt(m_socket, SOL_SOCKET, SO_SNDBUF,
                    (LPCSTR)&iBufSize, sizeof(iBufSize)) == SOCKET_ERROR ) {

        m_iLastError = WSAGetLastError();
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        return FALSE;
    }

    return TRUE;
}   // Open()


DWORD
CStreamSocket::
GetAckBeforeClose(
    DWORD   dwSeconds
    )
/*++

Description:
    Called to get the FIN from the remote host to make sure job has
    gone through ok.

Parameters:
    dwSeconds: how long the routine should wait for FIN from the remote host

Return values:
    NO_ERROR        : Received a FIN from the remote host
    WSAWOULBLOCK    : Timed out. Connection is ok, but did not get the FIN
                      in the specified time. Caller could reissue the
                      GetAckBeforeClose call again.
    Anything else   : An unexpected winsock error

--*/
{
    DWORD   dwRet = ERROR_SUCCESS, cbRead;
    time_t  dwStartTime, dwWaitTime;
    char    buf[100];

#ifdef DEBUG
    DWORD dwDiff;
    CHAR szBuf[512];

    m_dwTimeEnd = GetTickCount ();

    if (m_dwTimeEnd < m_dwTimeStart) {
        dwDiff = (m_dwTimeEnd - m_dwTimeStart + 0xffffffff) ;
    }
    else
        dwDiff = m_dwTimeEnd - m_dwTimeStart;

    // DBGMSG does not allow floating value, so we need to use sprintf instead

    sprintf (szBuf, "Job Data (before Ack): %3.1f bytes,  %3.1f sec, %3.1f (KB /sec).\n",
             m_TotalBytes, dwDiff / 1000., (m_TotalBytes / dwDiff ));

    DBGMSG (DBG_PORT, ("%s", szBuf));

#endif

    dwStartTime = time(NULL);

    //
    // We need to issue shutdown SD_SEND only once, the first time
    //
    if ( m_iState != WAITING_TO_CLOSE ) {

        if ( shutdown(m_socket, 1) != ERROR_SUCCESS ) {

            if ( (dwRet = m_iLastError = WSAGetLastError()) == NO_ERROR )
                dwRet = m_iLastError = STG_E_UNKNOWN;
            goto Done;
        }
        m_iState = WAITING_TO_CLOSE;
    }

    do {

        dwWaitTime = time(NULL) - dwStartTime;
        if ( static_cast<DWORD> (dwWaitTime) > dwSeconds )
            dwWaitTime = 0;
        else
            dwWaitTime = dwSeconds - dwWaitTime;

        dwRet = Receive(buf, sizeof(buf), 0,  static_cast<DWORD>(dwWaitTime), &cbRead);

    } while ( dwRet == NO_ERROR && cbRead > 0 );

Done:
    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  Close

VOID
CStreamSocket::
Close(
    VOID
    )
{
    if ( m_socket != INVALID_SOCKET ) {

        if ( closesocket(m_socket) == 0 ) {

            //
            // If we have pending data (i.e. in case of aborting job)
            // then event will be set
            //
            if ( cbPending )
                WaitForSingleObject(WsaOverlapped.hEvent, INFINITE);
        } else {

            //
            // Why would close fail ?
            //
            _ASSERTE(WSAGetLastError());
        }

        m_socket = INVALID_SOCKET;
    }

    if ( pBuf ) {

        LocalFree(pBuf);
        pBuf = NULL;
    }

    if ( WsaOverlapped.hEvent ) {

        WSACloseEvent(WsaOverlapped.hEvent);
        WsaOverlapped.hEvent = NULL;
    }
}   // Close()


///////////////////////////////////////////////////////////////////////////////
//  SetOptions -- sets the socket options (is not currently being used )
BOOL
CStreamSocket::
SetOptions(
    VOID
    )
{
#if 0
    LINGER ling;

    if( m_socket != INVALID_SOCKET )
    {
        ling.l_onoff = 1;
        ling.l_linger = 90;

        setsockopt( m_socket,
                    SOL_SOCKET, SO_LINGER, (LPSTR)&ling, sizeof( ling ) );
    }
#endif
    return TRUE;
}   // SetOptions()


///////////////////////////////////////////////////////////////////////////////
//  Connect
//      Error codes:
//          TRUE if connect succeeds, FALSE if fails
//      FIX: how to call the destructor

BOOL
CStreamSocket::
Connect(
    struct sockaddr_in * pRemoteAddr
    )
{

    //
    // open a socket (Makes sense to call when open fails? -- Muhunts )
    //


    if ( m_socket == INVALID_SOCKET && !Open() )
    {
            return FALSE;
    }

    if( m_socket == INVALID_SOCKET && !Bind() )
    {
        return FALSE;
    }

    if ( SOCKET_ERROR == connect(m_socket, (LPSOCKADDR)pRemoteAddr,
                                 sizeof(*pRemoteAddr)) ) {

        m_iLastError = WSAGetLastError();
        return FALSE;
    }
    m_iState = CONNECTED;


    return TRUE;
}   // Connect()


///////////////////////////////////////////////////////////////////////////////
//  Bind

BOOL
CStreamSocket::
Bind(
    VOID
    )
{
    memset (&m_localAddr, 0x00, sizeof(m_localAddr));

    m_localAddr.sin_family = AF_INET;
    m_localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    m_localAddr.sin_port = 0;

    if ( SOCKET_ERROR == bind(m_socket, (struct sockaddr *)&m_localAddr,
                              sizeof(m_localAddr)) ) {

        m_iLastError = WSAGetLastError();
        return FALSE;
    }

    return TRUE;

}   // Bind()


////////////////////////////////////////////////////////////////////////////////
//
// InternalSend
//      Send whatever is left in buffer
//
////////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
InternalSend(
    VOID
    )
{
    INT         iSendRet;
    DWORD       dwRet = NO_ERROR, dwSent;
    WSABUF      WsaBuf;

    //
    // Send as much data without blocking
    //
    while ( cbPending ) {

        WsaBuf.len   = cbPending;
        WsaBuf.buf   = (char far *)(pBuf + cbData - cbPending);

        iSendRet = WSASend(m_socket, &WsaBuf, 1, &dwSent, MSG_PARTIAL,
                           &WsaOverlapped, NULL);

        //
        // If return value is 0 data is already sent
        //
        if ( iSendRet == 0 ) {

            WSAResetEvent(WsaOverlapped.hEvent);
            cbPending -= dwSent;
        } else {

            if ( (dwRet = WSAGetLastError()) != WSA_IO_PENDING )
                m_iLastError = dwRet;

            break;
        }
    }

    if ( dwRet == WSA_IO_PENDING )
        dwRet = NO_ERROR;

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  Send -- sends the specified buffer to the host that was set previously
//      ERROR CODES:
//          NO_ERROR        ( No Error )    if send was successfull
//          WSAEWOULDBLOCK  if write socket is blocked
//          WSAECONNRESET   if connection was reset
//
//  MuhuntS: 5/26/99
//      I am changing tcpmon to use overlapped i/o with no winsock buffering
//      So caller should call PendingDataStatus to see if Send completed yet
//      Send call is just to schedule an I/O operation
///////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
Send(
    IN      char far   *lpBuffer,
    IN      INT         iLength,
    IN OUT  LPDWORD     pcbWritten)
{
    DWORD   dwRet = NO_ERROR, dwSent;
    INT     iSendRet;


    *pcbWritten = 0;

    _ASSERTE(cbPending == 0);

    cbData = cbPending = 0;

#ifdef DEBUG

    if (!pBuf) {
        // First send comes in

        DBGMSG (DBG_PORT, ("Get Connected \n"));

        m_TotalBytes = 0;
        m_dwTimeStart = GetTickCount ();
    }

#endif


    //
    // Once we allocate a buffer we do not free it till the end of job, or if
    // spooler gives us a bigger buffer
    //
    if ( pBuf && (INT)cbBuf < iLength ) {

        LocalFree(pBuf);
        pBuf = NULL;
        cbBuf = 0;
    }

    if ( !pBuf ) {

        if ( !(pBuf = (LPBYTE)LocalAlloc(LPTR, iLength)) ) {

            dwRet = ERROR_OUTOFMEMORY;
            goto Done;
        }

        cbBuf = iLength;
    }

    //
    // If we did not create event yet do so
    //
    if ( !WsaOverlapped.hEvent && !(WsaOverlapped.hEvent =WSACreateEvent()) ) {

        dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    cbData = cbPending = iLength;
    CopyMemory(pBuf, lpBuffer, iLength);

    if ( (dwRet = InternalSend()) == NO_ERROR )
        *pcbWritten = cbData;
    else {

        *pcbWritten = cbData - cbPending;
        cbData = cbPending = 0;
    }

#ifdef DEBUG
    m_TotalBytes += *pcbWritten;
#endif


Done:
    return dwRet;
}   // Send()


///////////////////////////////////////////////////////////////////////////////
//
// This routine will tell how much pending data is there in blocked I/O
// operations, waiting upto dwTimeout milliseconds
//
// Return value:
//      NO_ERROR:
//          If *pcbPending is 0 then either no pending I/O or all the issued
//          Sends are completed
//          If *pcbPending is not 0 then after the specified time we still have
//          so much data pending.
//      Others
//          There was an error with the last send.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
CStreamSocket::
PendingDataStatus(
    DWORD       dwTimeout,
    LPDWORD     pcbPending
    )
{
    DWORD   dwRet = NO_ERROR, dwSent, dwFlags = 0;

    if ( cbPending ) {

        if ( WAIT_OBJECT_0 == WaitForSingleObject(WsaOverlapped.hEvent,
                                                  dwTimeout) ) {

            WSAResetEvent(WsaOverlapped.hEvent);
            if ( WSAGetOverlappedResult(m_socket, &WsaOverlapped, &dwSent,
                                        FALSE, &dwFlags) ) {

                if ( cbPending >= dwSent ) {

                    cbPending -= dwSent;
                    if ( cbPending )
                        dwRet = InternalSend();
                } else {

                    //
                    // This should not happen. How could more data be sent
                    // then scheduled?
                    //
                    _ASSERTE(cbPending >= dwSent);
                    cbPending = 0;
                    dwRet = STG_E_UNKNOWN;
                }

            } else {

                if ( (dwRet = m_iLastError = WSAGetLastError()) == NO_ERROR )
                    dwRet = m_iLastError = STG_E_UNKNOWN;
            }

        } else
            *pcbPending = cbPending;
    }

    *pcbPending = cbPending;

    //
    // If we get error then clear all data pending info
    //
    if ( dwRet != NO_ERROR )
        cbData = cbPending = 0;

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
//  ReceiveDataAvailable -- checks if there is any data to receive
//      ERROR CODES:
//          NO_ERROR  ( No Error ) There are a least one byte to receive
//          WSAEWOULDBLOCK if no data is available
//          WSAECONNRESET   if connection was reset

DWORD
CStreamSocket::
ReceiveDataAvailable(
    IN      INT         iTimeout)
{
    DWORD   dwRetCode = NO_ERROR;
    fd_set  fdReadSet;
    struct  timeval timeOut;
    INT     selret;

    //
    // immediately return from select()
    //
    timeOut.tv_sec  = iTimeout;
    timeOut.tv_usec = 0;
    m_iLastError    = NO_ERROR;

    //
    // Check to see if any thing is available
    //

    FD_ZERO( (fd_set FAR *)&fdReadSet );
    FD_SET( m_socket, (fd_set FAR *)&fdReadSet );

    selret = select(0, &fdReadSet, NULL, NULL, &timeOut);

    if ( selret == SOCKET_ERROR )   {

        dwRetCode = m_iLastError = WSAGetLastError();
    }  else if ( !FD_ISSET( m_socket, &fdReadSet ) ) {

        dwRetCode = WSAEWOULDBLOCK;
    }

    return dwRetCode;

}   // ReceiveDataAvailable()


///////////////////////////////////////////////////////////////////////////////
//  Receive -- receives the specified buffer from the host that was set previously
//      ERROR CODES:
//          NO_ERROR  ( No Error ) if send was successfull
//          WSAEWOULDBLOCK if write socket is blocked
//          WSAECONNRESET   if connection was reset

DWORD
CStreamSocket::
Receive(
    IN      char far   *lpBuffer,
    IN      INT         iSize,
    IN      INT         iFlags,
    IN      INT         iTimeout,
    IN OUT  LPDWORD     pcbRead)
{
    INT     iRecvLength = 0;
    DWORD   dwRetCode = ReceiveDataAvailable (iTimeout);
    fd_set  fdReadSet;

    *pcbRead = 0;

    if (dwRetCode == NO_ERROR)
    {
        iRecvLength = recv(m_socket, lpBuffer, iSize, iFlags);

        if ( iRecvLength == SOCKET_ERROR )
            dwRetCode = m_iLastError = WSAGetLastError();
        else
            *pcbRead = iRecvLength;
    }

    return dwRetCode;

}   // Recv()

///////////////////////////////////////////////////////////////////////////////
//  Receive -- detects whether the connection closed or not. Used by select()
//      if the server closed the connection, recv() indicates either a gracefull
//      shutdown, or WSAECONNRESET
//      Error Codes:
//          NO_ERROR        if connection has shutdown gracefully
//          WSAECONNRESET   if connection is reset


DWORD
CStreamSocket::
Receive(
    VOID
    )
{
    DWORD   dwRetCode = NO_ERROR;
    CHAR    tempBuf[1024];

    if ( recv(m_socket, tempBuf, 1024, 0) != 0 ) {

        dwRetCode = m_iLastError = WSAGetLastError();
    }

    return dwRetCode;
}   // Receive()


///////////////////////////////////////////////////////////////////////////////
//  GetLocalAddress

VOID
CStreamSocket::
GetLocalAddress(
    VOID
    )
{

}   // GetLocalAddress()


///////////////////////////////////////////////////////////////////////////////
//  GetRemoteAddress

VOID
CStreamSocket::
GetRemoteAddress(
    VOID
    )
{

}   // GetRemoteAddress()


BOOL
CStreamSocket::
ResolveAddress(
    IN  LPSTR   netperiph
    )
/* host name or IP address of network periph */
{
    struct hostent  *h_info;        /* host information */

    //
    // Check for dotted decimal or hostname.
    //
    m_Paddr.sin_addr.s_addr = inet_addr(netperiph);
    if (( m_Paddr.sin_addr.s_addr ) ==  INADDR_NONE ) {

        //
        // The IP address is not in dotted decimal notation. Try to get the
        // network peripheral IP address by host name.
        //
        if ( (h_info = gethostbyname(netperiph)) != NULL ) {

            //
            // Copy the IP address to the address structure.
            //
            (void) memcpy(&(m_Paddr.sin_addr.s_addr), h_info->h_addr,
                          h_info->h_length);
        } else {

            return FALSE;
        }
    }

    m_Paddr.sin_family = AF_INET;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmib\tcpmib.h ===
/*****************************************************************************
 *
 * $Workfile: TcpMib.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_TCPMIB_H
#define INC_TCPMIB_H

#include "mibABC.h"
#include "winspool.h"
#define ERROR_SNMPAPI_ERROR                             15000           

#ifndef DllExport
#define DllExport       __declspec(dllexport)
#endif

class   CTcpMibABC;

#ifdef __cplusplus
extern "C" {
#endif
    //      return the pointer to the interface
    CTcpMibABC*     GetTcpMibPtr( void );

    ///////////////////////////////////////////////////////////////////////////////
    //  Ping return codes:
    //              NO_ERROR                        if ping is successfull
    //              DEVICE_NOT_FOUND        if device is not found
    DllExport       DWORD           Ping( LPCSTR    pHost );        

#ifdef __cplusplus
}
#endif


///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations/macros
// externs
extern int                      g_cntGlobalAlloc;
extern int                      g_csGlobalCount;

// macros to manupulate the RFC1157 variable bindings
#define RFC1157_VARBINDLIST_LEN(varBindList)    ( varBindList.len )             // returns the length of the varBind list
#define PRFC1157_VARBINDLIST_LEN(pVarBindList)  ( pVarBindList->len )           // returns the length of the varBind list

#define IS_ASN_INTEGER(varBindList, i)  ( ( varBindList.list[i].value.asnType == ASN_INTEGER ) ? TRUE : FALSE )
#define IS_ASN_OBJECTIDENTIFIER(varBindList, i) ( ( varBindList.list[i].value.asnType == ASN_OBJECTIDENTIFIER ) ? TRUE : FALSE )
#define IS_ASN_OCTETSTRING(varBindList, i)      ( ( varBindList.list[i].value.asnType == ASN_OCTETSTRING ) ? TRUE : FALSE )

#define GET_ASN_NUMBER(varBindList, i)  ( varBindList.list[i].value.asnValue.number )
#define GET_ASN_STRING_LEN(varBindList, i)      ( (varBindList).list[i].value.asnValue.string.length )
#define GET_ASN_OBJECT(varBindList, i)  ( varBindList.list[i].value.asnValue.object )
#define GET_ASN_OCTETSTRING(pDest, count, varBindList, i) ( GetAsnOctetString(pDest, count, &varBindList, i) )
#define GET_ASN_OCTETSTRING_CHAR( varBindList, i, x)    ( varBindList.list[i].value.asnValue.string.stream[x] )
#define GET_ASN_OID_NAME(varBindList, i)        ( varBindList.list[i].name )

#define PGET_ASN_OID_NAME(pVarBindList, i)      ( pVarBindList->list[i].name )
#define PGET_ASN_TYPE(pVarBindList, i)  ( pVarBindList->list[i].value.asnType )

// export the interface for CRawTcpInterface class
class DllExport CTcpMib : public CTcpMibABC             
#if defined _DEBUG || defined DEBUG
//      , public CMemoryDebug
#endif
{
public:
    CTcpMib();
    ~CTcpMib();

    BOOL   SupportsPrinterMib(LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              PBOOL         pbSupported);

    DWORD   GetDeviceDescription(LPCSTR        pHost,
                                 LPCSTR        pCommunity,
                                 DWORD         dwDevIndex,
                                 LPTSTR        pszPortDescription,
                                 DWORD         dwDescLen);
    DWORD   GetDeviceStatus ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex);
    DWORD   GetJobStatus    ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex);
    DWORD   GetDeviceHWAddress( LPCSTR      pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              DWORD         dwSize, // Size in characters of the dest HWAddress buffer
                              LPTSTR        psztHWAddress);
    DWORD   GetDeviceName   ( LPCSTR        pHost,
                              LPCSTR        pCommunity,
                              DWORD         dwDevIndex,
                              DWORD         dwSize, // Size in characters of the dest Description buffer
                              LPTSTR        psztDescription);
    DWORD   SnmpGet( LPCSTR                      pHost,
                     LPCSTR                          pCommunity,
                     DWORD                           dwDevIndex,
                     AsnObjectIdentifier *pMibObjId,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGet( LPCSTR                      pHost,
                     LPCSTR                          pCommunity,
                     DWORD                           dwDevIndex,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpWalk( LPCSTR                          pHost,
                      LPCSTR                          pCommunity,
                      DWORD                           dwDevIndex,
                      AsnObjectIdentifier *pMibObjId,
                      RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpWalk( LPCSTR                          pHost,
                      LPCSTR                          pCommunity,
                      DWORD                           dwDevIndex,
                      RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGetNext( LPCSTR                          pHost,
                         LPCSTR                          pCommunity,
                         DWORD                           dwDevIndex,
                     AsnObjectIdentifier *pMibObjId,
                     RFC1157VarBindList  *pVarBindList);
    DWORD   SnmpGetNext( LPCSTR                          pHost,
                         LPCSTR                          pCommunity,
                         DWORD                   dwDevIndex,
                     RFC1157VarBindList  *pVarBindList);

    BOOL SNMPToPortStatus( const DWORD in dwStatus, 
                                 PPORT_INFO_3 pPortInfo );

    DWORD SNMPToPrinterStatus( const DWORD in dwStatus);

private:        // methods
    void    EnterCSection();
    void    ExitCSection();

private:        // attributes
    CRITICAL_SECTION        m_critSect;

};      // class CTcpMib



#endif  // INC_DLLINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\csutils.cpp ===
/*****************************************************************************
 *
 * $Workfile: CSUtils.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "csutils.h"


///////////////////////////////////////////////////////////////////////////////
//  CSocketUtils::CSocketUtils

CSocketUtils::
CSocketUtils(
    VOID
    )
{

}       // ::CSocketUtils()


///////////////////////////////////////////////////////////////////////////////
//  CSocketUtils::~CSocketUtils

CSocketUtils::
~CSocketUtils(
    VOID
    )
{

}       // ::~CSocketUtils()


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- resolves the host name or the ip address of the peripheral
//              and fills the in_addr structure.
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN      const char         *pHost,
    IN      const USHORT        port,
    IN OUT  struct sockaddr_in *pAddr)
{
    struct hostent      *h_info;            /* host information */

    //
    // Check for dotted decimal or hostname.
    //
    if ( (pAddr->sin_addr.s_addr = inet_addr(pHost)) ==  INADDR_NONE ) {

    //
    // The IP address is not in dotted decimal notation. Try to get the
    // network peripheral IP address by host name.
    //
    if ( (h_info = gethostbyname(pHost)) != NULL ) {

        //
        // Copy the IP address to the address structure.
        ///
        (void) memcpy(&(pAddr->sin_addr.s_addr), h_info->h_addr,
              h_info->h_length);
    } else {

        return FALSE;
    }
    }

    pAddr->sin_family = AF_INET;
    pAddr->sin_port = htons(port);

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- resolves the host name or the ip address of the peripheral
//              and fills the the apporperiate host name or ipaddress field,  Note
//              if the address is in dotted notation it will be left in dotted notation
//              and only one strusture is filled.
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN      char   *pHost,
    IN      DWORD   dwHostNameBufferLength,
    IN OUT  char   *pHostName,
    IN      DWORD   dwIpAddressBufferLength,
    IN OUT  char   *pIPAddress
    )
{
    //
    // Check for dotted decimal or hostname.
    //
    //  This is not a very accurate check since
    //  and IP address can be 00000000001 which is
    //  also a valid hostname.
    //
    if ( strlen(pHost) >= dwIpAddressBufferLength || inet_addr(pHost) ==  INADDR_NONE ) {

        strncpy(pHostName, pHost, dwHostNameBufferLength);
        pHostName [dwHostNameBufferLength - 1] = 0;

        *pIPAddress = '\0';
    } else  { // it is a dotted notation

        strncpy(pIPAddress, pHost, dwIpAddressBufferLength);
        pIPAddress [dwIpAddressBufferLength - 1] = 0;
        *pHostName = '\0';
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//  ResolveAddress -- given the host name, resolves the IP address
//              Error codes:
//                      TRUE if successful, FALSE if failes

BOOL
CSocketUtils::
ResolveAddress(
    IN  LPSTR   pHostName,
    OUT LPSTR   pIPAddress
    )
{
    BOOL bRet = FALSE;
    struct hostent              *h_info;            /* host information */
    struct sockaddr_in  h_Addr;

    if ( (h_info = gethostbyname(pHostName)) != NULL ) {

        //
        // Copy the IP address to the address structure.
        //
        memcpy(&(h_Addr.sin_addr.s_addr), h_info->h_addr, h_info->h_length);

        if (inet_ntoa(h_Addr.sin_addr)) {
            strncpyn(pIPAddress, inet_ntoa(h_Addr.sin_addr), (strlen(inet_ntoa(h_Addr.sin_addr))+1) );
            bRet = TRUE;
        }

    } else {

        *pIPAddress = '\0';
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\cluster.cpp ===
/*****************************************************************************
 *
 * $Workfile: cluster.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#include "precomp.h"
#include "portmgr.h"
#include "cluster.h"

//////////////////////////////////////////////////////////////////////////////
// CCluster::CCluster()
//

CCluster::CCluster( HANDLE      IN hcKey,
                    HANDLE      IN hSpooler,
                    PMONITORREG IN pMonitorReg ) : 
                                            m_hcKey(hcKey),
                                            m_hSpooler(hSpooler),
                                            m_pMonitorReg(pMonitorReg),
                                            m_hcWorkingKey(NULL)
{
    lstrcpyn(m_sztMonitorPorts, PORTMONITOR_PORTS, SIZEOF_IN_CHAR( m_sztMonitorPorts));

    InitializeCriticalSection( &m_critSect );
}   // ::CCluster()


//////////////////////////////////////////////////////////////////////////////
// CCluster::~CCluster()
//      FIX: should the configuration be saved here?

CCluster::~CCluster()
{
    DeleteCriticalSection( &m_critSect );

    if( m_hcWorkingKey !=NULL ) {
        m_pMonitorReg->fpCloseKey(m_hcWorkingKey, m_hSpooler);
        m_hcWorkingKey = NULL;
    }
    m_pMonitorReg = NULL;
    m_hSpooler = NULL;
    m_hcKey = NULL;
}   // ::~CCluster


//////////////////////////////////////////////////////////////////////////////
// EnumeratePorts -- Enumerates the ports in the registry & adds it to the portList
//      Registry entries per port: IPAddress, MACAddress, HostName, PortNumber, ExPortNumber
//

DWORD 
CCluster::EnumeratePorts(CPortMgr *pPortMgr )
{
    DWORD   dwRetCode;
    HANDLE  hcKey = NULL;
    HANDLE  hcKeyPort = NULL;
    DWORD   dwSubkey = 0;
    TCHAR   szTemp[MAX_PATH];
    DWORD   dwSize = 0;
    DWORD   dwDisp = 0;
    DWORD   dwProtocol;
    DWORD   dwVersion;

    if ( m_pMonitorReg == NULL)
        return ERROR_INVALID_HANDLE;

    dwRetCode = m_pMonitorReg->fpCreateKey(m_hcKey, 
                                           m_sztMonitorPorts, 
                                           REG_OPTION_NON_VOLATILE, 
                                           KEY_ALL_ACCESS, 
                                           NULL, 
                                           &hcKey, 
                                           &dwDisp,
                                           m_hSpooler);

    if ( dwRetCode != ERROR_SUCCESS )
        return dwRetCode;

    do {

        dwSize = SIZEOF_IN_CHAR(szTemp);
        dwRetCode = m_pMonitorReg->fpEnumKey(hcKey, 
                                             dwSubkey, 
                                             szTemp, 
                                             &dwSize, 
                                             NULL,
                                             m_hSpooler);

        if ( dwRetCode == ERROR_NO_MORE_ITEMS ) {

            dwRetCode = ERROR_SUCCESS;
            break; // This is our exit out of the loop with no more ports
        }

        hcKeyPort = NULL;

        dwRetCode = m_pMonitorReg->fpOpenKey(hcKey, 
                                             szTemp, 
                                             KEY_ALL_ACCESS, 
                                             &hcKeyPort, 
                                             m_hSpooler);

        //
        // If we have one bad port entry in registry we should not stop there
        // and continue to enumerate other ports
        //
        if ( dwRetCode != ERROR_SUCCESS ) 
            goto NextPort;

        dwSize = sizeof(dwProtocol);        // get the protocol type
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKeyPort,
                                                PORTMONITOR_PORT_PROTOCOL, 
                                                NULL, 
                                                (LPBYTE)&dwProtocol,
                                                &dwSize,
                                                m_hSpooler);

        if ( dwRetCode != ERROR_SUCCESS )
            goto NextPort;

        dwSize = sizeof(dwVersion);     // get the version
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKeyPort, 
                                                PORTMONITOR_PORT_VERSION, 
                                                NULL, 
                                                (LPBYTE)&dwVersion, 
                                                &dwSize, 
                                                m_hSpooler);

        if ( dwRetCode != ERROR_SUCCESS )
            goto NextPort;

        //
        // create a new port
        //
        dwRetCode =  pPortMgr->CreatePortObj((LPTSTR)szTemp,    // port name
                                             dwProtocol,            // protocol type
                                             dwVersion);            // version number

        if ( dwRetCode != NO_ERROR ) {

            //
            // FIX EVENT message indicating bad port in registry.
            //
            EVENT_LOG1(EVENTLOG_WARNING_TYPE, dwRetCode, szTemp);
        }

NextPort:
        if ( hcKeyPort ) {

            m_pMonitorReg->fpCloseKey(hcKeyPort, m_hSpooler);
            hcKeyPort = NULL;
        }

        ++dwSubkey;
        dwRetCode = NO_ERROR;
    } while ( dwRetCode == NO_ERROR ); // Exit via break above
        
    m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);

    return dwRetCode;
}





//////////////////////////////////////////////////////////////////////////////
// DeletePortEntry -- deletes the given port entry from the registry

BOOL
CCluster::DeletePortEntry(LPTSTR in psztPortName)
{
    BOOL    bReturn = TRUE;
    HANDLE  hcKey = NULL;
    DWORD   dwDisp = 0;

    if( m_pMonitorReg == NULL)
    {
        return FALSE;
    }

    LONG lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if ( lRetCode == ERROR_SUCCESS) 
    {
        lRetCode = m_pMonitorReg->fpDeleteKey(hcKey, 
                                              psztPortName, 
                                              m_hSpooler);
        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
        if (lRetCode != ERROR_SUCCESS) 
        {
            bReturn = FALSE;
        }
    }
    else 
    {
        bReturn = FALSE;
    }

    return bReturn;

}   // ::DeletePortEntry()


//////////////////////////////////////////////////////////////////////////////
// GetPortMgrSettings -- Gets the port manager registry settings.
//      

DWORD 
CCluster::GetPortMgrSettings(DWORD inout *pdwStatusUpdateInterval,
                             BOOL  inout *pbStatusUpdateEnabled )
{
    LONG    lRetCode = ERROR_SUCCESS;
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwDisp = 0;
    DWORD   dwSize = 0;
    HANDLE  hcKey;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    // get current configuration settings from the registry
    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if (lRetCode == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKey, PORTMONITOR_STATUS_INT, NULL,
            (LPBYTE)pdwStatusUpdateInterval, &dwSize, m_hSpooler);
        if ( (dwRetCode != ERROR_SUCCESS) || (*pdwStatusUpdateInterval <= 0) )
        {
            *pdwStatusUpdateInterval = DEFAULT_STATUSUPDATE_INTERVAL;
            m_pMonitorReg->fpSetValue(hcKey, PORTMONITOR_STATUS_INT, REG_DWORD,
                (const LPBYTE)pdwStatusUpdateInterval, sizeof(DWORD), m_hSpooler);
        }
        dwSize = sizeof(BOOL);
        dwRetCode = m_pMonitorReg->fpQueryValue(hcKey, PORTMONITOR_STATUS_ENABLED, NULL,
            (LPBYTE)pbStatusUpdateEnabled, &dwSize, m_hSpooler);
        if ( (dwRetCode != ERROR_SUCCESS) || ((*pbStatusUpdateEnabled != FALSE) && (*pbStatusUpdateEnabled != TRUE )))
        {
            *pbStatusUpdateEnabled = DEFAULT_STATUSUPDATE_ENABLED;
            m_pMonitorReg->fpSetValue(hcKey, PORTMONITOR_STATUS_ENABLED, REG_DWORD,
                (const LPBYTE)pbStatusUpdateEnabled, sizeof(BOOL), m_hSpooler);
        }

        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
        dwRetCode = NO_ERROR;
    }

    return (dwRetCode);

}   // GetPortMgrSettings()


//////////////////////////////////////////////////////////////////////////////
//  SetPortMgrSettings -- Sets the port manager registry settings.
//  Error Codes:
//      NO_ERROR if successful
//      ERROR_ACCESS_DENIED if can't access the registry

DWORD
CCluster::SetPortMgrSettings( const DWORD in dwStatusUpdateInterval,
                              const BOOL  in bStatusUpdateEnabled )
{
    HKEY    hcKey = NULL;
    LONG    lRetCode = ERROR_SUCCESS;
    DWORD   dwDisp = 0;
    DWORD   dwRetCode = NO_ERROR;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    // update the internal values
    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey, 
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);

    if (lRetCode == ERROR_SUCCESS)
    {

        // Update registry values for port manager
        // Note: RegSetValueEx expects size in BYTES!
        lRetCode = m_pMonitorReg->fpSetValue(hcKey,
                                             PORTMONITOR_STATUS_INT, 
                                             REG_DWORD, 
                                             (const LPBYTE)&dwStatusUpdateInterval, 
                                             sizeof(dwStatusUpdateInterval), 
                                             m_hSpooler);
        lRetCode = m_pMonitorReg->fpSetValue(hcKey, 
                                             PORTMONITOR_STATUS_ENABLED, 
                                             REG_DWORD, 
                                             (const LPBYTE)&bStatusUpdateEnabled, 
                                             sizeof(bStatusUpdateEnabled), m_hSpooler);


        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
    }
    else
    {
        dwRetCode = ERROR_ACCESS_DENIED;
    }

    return (dwRetCode);

}   // ::SetPortMgrSettings()


//////////////////////////////////////////////////////////////////////////////
//  SetWorkingKey -- Opens the given entry @ the registry
//  Error codes:
//      NO_ERROR if no error
//      ERROR_ACCESS_DENIED if can't access the registry

DWORD 
CCluster::SetWorkingKey(LPCTSTR lpKey)
{
    DWORD   dwRetCode = NO_ERROR;
    LONG    lRetCode = ERROR_SUCCESS;
    HANDLE  hcKey = NULL;
    DWORD   dwDisp = 0;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }

    EnterCriticalSection( &m_critSect );

    lRetCode = m_pMonitorReg->fpCreateKey( m_hcKey,  
                                m_sztMonitorPorts, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hcKey, 
                                &dwDisp,
                                m_hSpooler);
    if (lRetCode == ERROR_SUCCESS) {
        if (lpKey)
        {
            lRetCode = m_pMonitorReg->fpCreateKey(hcKey,            // Create new key for port
                                        lpKey,
                                        REG_OPTION_NON_VOLATILE, 
                                        KEY_ALL_ACCESS, 
                                        NULL, 
                                        &m_hcWorkingKey, 
                                        &dwDisp,
                                        m_hSpooler);
        }
        else
        {
            m_hcWorkingKey = hcKey;
            hcKey = NULL;
        }
        
        if (lRetCode != ERROR_SUCCESS) {
            m_hcWorkingKey = NULL;
            dwRetCode = ERROR_ACCESS_DENIED;
        }
    } else {
        dwRetCode = ERROR_ACCESS_DENIED;
    }

    if( hcKey ) {
        m_pMonitorReg->fpCloseKey(hcKey, m_hSpooler);
    }

    if( m_hcWorkingKey == NULL ) {
        LeaveCriticalSection(&m_critSect);
    }


    return(dwRetCode);

}   // ::RegOpenPortEntry()

//////////////////////////////////////////////////////////////////////////////
//  QueryValue -- Queries the current working key for the requested value
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry
DWORD
CCluster::QueryValue(LPTSTR lpValueName, 
                     LPBYTE lpData, 
                     LPDWORD lpcbData )
{
    if( m_pMonitorReg == NULL)
    {
        return ERROR_INVALID_HANDLE;
    }

    if( m_hcWorkingKey != NULL ) {
        return( m_pMonitorReg->fpQueryValue(m_hcWorkingKey, 
                                            lpValueName, 
                                            NULL,
                                            (LPBYTE)lpData, 
                                            lpcbData,
                                            m_hSpooler));
    }
    return ERROR_BADKEY;
}

//////////////////////////////////////////////////////////////////////////////
//  SetValue -- Sets the value for the current 
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry

DWORD
CCluster::SetValue( LPCTSTR lpValueName,
                     DWORD dwType, 
                     CONST BYTE *lpData, 
                     DWORD cbData ) 
{
    if( m_pMonitorReg == NULL)
    {
        return ERROR_INVALID_HANDLE;
    }

    if( m_hcWorkingKey != NULL ) {
        return( m_pMonitorReg->fpSetValue(m_hcWorkingKey,
                                          lpValueName,
                                          dwType, 
                                          lpData, 
                                          cbData,
                                          m_hSpooler));
    } 
    return ERROR_BADKEY;
}

//////////////////////////////////////////////////////////////////////////////
//  FreeWorkingKey -- Frees the current working key
//  Error codes:
//      NO_ERROR if no error
//      ERROR_BADKEY if can't access the registry

DWORD 
CCluster::FreeWorkingKey()
{
    DWORD dwRetCode = NO_ERROR;

    if( m_pMonitorReg == NULL)
    {
        dwRetCode = ERROR_INVALID_HANDLE;
        return dwRetCode;
    }
    
    if( m_hcWorkingKey !=NULL ) {
        dwRetCode = m_pMonitorReg->fpCloseKey(m_hcWorkingKey, m_hSpooler);
        m_hcWorkingKey = NULL;
        LeaveCriticalSection(&m_critSect);
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\csutils.h ===
/*****************************************************************************
 *
 * $Workfile: CSUtils.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/CSUtils.h $
 *
 * 2     7/23/97 3:49p Binnur
 * changed the address resolution mechanism to update the IP address when
 * given a host name.
 *
 * 1     7/17/97 1:08p Dsnelson
 * New
 *
 * 2     7/14/97 2:25p Binnur
 * copyright statement
 *
 * 1     7/02/97 2:34p Binnur
 * Initial File
 *
 * 4     5/30/97 5:16p Binnur
 * inheriting from CMemoryDebug
 *
 * 3     5/13/97 5:02p Binnur
 * UI addport integration
 *
 * 2     4/21/97 11:50a Binnur
 * Prints successfully.. SetJob functionality is not implemented. It can
 * print to the same device over two different ports. Needs to change the
 * GlobalAlloc from fixed to moveable.
 *
 * 1     4/14/97 2:50p Binnur
 * Port Monitor include files.
 *
 *****************************************************************************/

#ifndef INC_CSUTILS_H
#define INC_CSUTILS_H

class CMemoryDebug;

class CSocketUtils
#if defined _DEBUG || defined DEBUG
: public CMemoryDebug
#endif
{
public:
	CSocketUtils();
	~CSocketUtils();

	BOOL	ResolveAddress( const char		*pHost,
							const USHORT	port,
							struct sockaddr_in *pAddr);
	BOOL	ResolveAddress( char   *pHost,
                            DWORD   dwHostNameBufferLength,
                            char   *pHostName,
                            DWORD   dwIpAddressBufferLength,
                            char   *pIPAddress);
	BOOL	ResolveAddress( LPSTR	pHostName,
							LPSTR   pIPAddress );

private:

};


#endif	// INC_CSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devabc.h ===
/*****************************************************************************
 *
 * $Workfile: devABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_DEVICEABC_H
#define INC_DEVICEABC_H


class CDeviceABC			
{
public:
	virtual	~CDeviceABC() { };

	virtual DWORD Read( LPBYTE	pBuffer,
				 		DWORD	cbBufSize,
                        INT     iTimeout,
					    LPDWORD pcbRead) = 0;

	virtual	DWORD Write( LPBYTE	pBuffer,
						 DWORD	cbBuf,
						 LPDWORD pcbWritten) = 0;
	virtual	DWORD	Connect() = 0;
	virtual	DWORD	Close() = 0;
    virtual DWORD   GetAckBeforeClose(DWORD dwTimeInSeconds) = 0;
    virtual DWORD   PendingDataStatus(DWORD dwTimeoutInMilliseconds,
                                      LPDWORD pcbPending) = 0;
    virtual DWORD   ReadDataAvailable () = 0;

	virtual DWORD	SetStatus( LPTSTR psztPortName ) = 0;

	virtual DWORD	GetJobStatus() = 0;




private:

};


#endif	// INC_DEVICEABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devstat.h ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved

Module Name:

    DevStat.h

Abstract:

    Status thread for TCP/IP Port Monitor

Author:
    Muhunthan Sivapragasam (MuhuntS)    25-Aug-98

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef INC_DEVSTAT_H
#define INC_DEVSTAT_H

#include        "portmgr.h"

class       CPortMgr;

//
// After telling status thread to terminate check every 0.1 seconds
//
#define     WAIT_FOR_THREAD_TIMEOUT 100


class
CDeviceStatus
#if defined _DEBUG || defined DEBUG
    : public CMemoryDebug
#endif
{
public:
    ~CDeviceStatus();

    static  CDeviceStatus      &gDeviceStatus();
    BOOL                        RunThread();
    VOID                        TerminateThread();
    BOOL                        RegisterPortMgr(CPortMgr *pPortMgr);
    VOID                        UnregisterPortMgr(CPortMgr *pPortMgr);

    BOOL                        SetStatusEvent();
    VOID                        SetStatusUpdateInterval(DWORD   dwVal);
    LONG                        GetStatusUpdateInterval(VOID)
                                    { return lUpdateInterval; }


private:
    CDeviceStatus();

    struct _PortMgrList {
        CPortMgr               *pPortMgr;
        struct  _PortMgrList   *pNext;
    }   *pPortMgrList;


    BOOL                bTerminate;
    LONG                lUpdateInterval;
    HANDLE              hStatusEvent;
    CRITICAL_SECTION    CS;
    CRITICAL_SECTION    PortListCS;

    static  VOID        StatusThread(CDeviceStatus *);
    VOID                EnterCS(VOID);
    VOID                LeaveCS(VOID);

    VOID                EnterPortListCS(VOID);
    VOID                LeavePortListCS(VOID);

    time_t              CheckAndUpdateAllPrinters(VOID);
    HANDLE              m_hThread;

};

#endif  // INC_DEVSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\jobabc.h ===
/*****************************************************************************
 *
 * $Workfile: jobABC.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 *****************************************************************************/

#ifndef INC_JOBABC_H
#define INC_JOBABC_H

class CJobABC			
{
public:
	virtual	~CJobABC() { };

	virtual	DWORD	Write(	 LPBYTE  pBuffer, 
							 DWORD	  cbBuf,
							 LPDWORD pcbWritten) = 0;
	virtual	DWORD	StartDoc() = 0;
	virtual	DWORD	EndDoc() = 0;


private:

};


#endif	// INC_JOBABC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\ipdata.h ===
/*****************************************************************************
 *
 * $Workfile: ipdata.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 ***************************************************************************** 
 *
 * $Log: /StdTcpMon/Common/ipdata.h $
 * 
 * 3     8/07/97 1:46p Dsnelson
 * Added LPR Printing
 * 
 * 2     8/04/97 12:16p Dsnelson
 * Added defines for types common to lpr and raw transport.
 * 
 * 
 *****************************************************************************/

#ifndef INC_IPDATA_H
#define INC_IPDATA_H
 
//	registry entries
#define	PORTMONITOR_HOSTNAME    TEXT("HostName")
#define	PORTMONITOR_IPADDR      TEXT("IPAddress")
#define	PORTMONITOR_HWADDR      TEXT("HWAddress")
#define PORTMONITOR_PORTNUM		TEXT("PortNumber")
#define PORTMONITOR_QUEUE		TEXT("Queue")
#define DOUBLESPOOL_ENABLED     TEXT("Double Spool")
#define SNMP_COMMUNITY			TEXT("SNMP Community")
#define SNMP_DEVICE_INDEX		TEXT("SNMP Index")
#define SNMP_ENABLED			TEXT("SNMP Enabled")

#endif //INC_IPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\devstat.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation
All rights reserved

Module Name:

    DevStat.cpp

Abstract:

    Status thread for TCP/IP Port Monitor

Author:
    Muhunthan Sivapragasam (MuhuntS)    25-Aug-98

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "devstat.h"


CDeviceStatus::
CDeviceStatus(
    VOID
    ) :
    pPortMgrList(NULL),
    hStatusEvent(NULL),
    bTerminate(FALSE)
{
    lUpdateInterval    = DEFAULT_STATUSUPDATE_INTERVAL * 60;
    InitializeCriticalSection(&CS);
    InitializeCriticalSection(&PortListCS);
}

CDeviceStatus::
~CDeviceStatus(
    VOID
    )
{
    //
    // This happens only on shutdown. Keep it simple
    //
    DeleteCriticalSection(&CS);
    DeleteCriticalSection(&PortListCS);
}


VOID
CDeviceStatus::
SetStatusUpdateInterval(
    DWORD   dwVal
    )
{
    EnterCS();

    lUpdateInterval = dwVal * 60;
    LeaveCS();
}



CDeviceStatus&
CDeviceStatus::
gDeviceStatus(
    VOID
    )
{
    static  CDeviceStatus   gDevStat;

    return gDevStat;
}


BOOL
CDeviceStatus::
RegisterPortMgr(
    CPortMgr *pPortMgr
    )
{
    BOOL    bRet = FALSE;
    struct _PortMgrList *pNew;

    if ( pNew = (struct _PortMgrList *) LocalAlloc(LPTR, sizeof(*pNew)) ) {

        EnterPortListCS();

        pNew->pNext     = pPortMgrList;
        pNew->pPortMgr  = pPortMgr;
        pPortMgrList    = pNew;

        LeavePortListCS();

        bRet            = TRUE;
    }

    return bRet;
}


VOID
CDeviceStatus::
UnregisterPortMgr(
    CPortMgr   *pPortMgr
    )
{
    BOOL    bRestartStatusThread = hStatusEvent != NULL;
    struct _PortMgrList *ptr, *prev = NULL;

    EnterCS();

    //
    // By terminating and restarting the status thread we make sure
    // there is no CPort object blocked on SNMP call which has reference
    // CPortMgr object which we are deleting now
    //
    if ( bRestartStatusThread )
        TerminateThread();

    EnterPortListCS ();

    for ( ptr = pPortMgrList ; ptr->pPortMgr != pPortMgr ; ptr = ptr->pNext )
        prev = ptr;

    _ASSERTE(ptr != NULL);

    if ( prev )
        prev->pNext = ptr->pNext;
    else
        pPortMgrList = ptr->pNext;

    LeavePortListCS ();

    LocalFree(ptr);

    if ( bRestartStatusThread )
        RunThread();

    LeaveCS();

}


BOOL
CDeviceStatus::
SetStatusEvent(
    VOID
    )
{
    BOOL    bRet = TRUE;

    if ( hStatusEvent ) {

        EnterCS();

        if ( hStatusEvent )
            bRet = SetEvent(hStatusEvent);

        LeaveCS();
    }

    return bRet;
}

time_t
CDeviceStatus::
CheckAndUpdateAllPrinters(
    VOID
    )
{
    LPSNMP_MGR_SESSION dummySnmpSession = SnmpMgrOpen ("127.0.0.1", "public", 0, 0);
    DBGMSG (DBG_INFO, ("CheckAndUpdateAllPrinters [START]\n"));

    struct _PortMgrList         *pList;
    time_t                      lUpdateTime, lSmallestUpdateTime = 60*60;
    CPort                       *pPort = NULL;

    EnterPortListCS();
    pList = pPortMgrList;
    LeavePortListCS();

    while (pList) {

        pList->pPortMgr->m_pPortList->IncRef ();

        TEnumManagedListImp *pEnum;
        if (pList->pPortMgr->m_pPortList->NewEnum (&pEnum)) {

            BOOL bRet = TRUE;

            while (bRet) {

                bRet = pEnum->Next (&pPort);
                if (bRet) {
                    lUpdateTime = pPort->NextUpdateTime();
                    if (lUpdateTime <= 0)
                    {
                        DWORD dwStatus = pPort->SetDeviceStatus();
                        DBGMSG (DBG_INFO, ("Port: %ws, errorStatus = %d\n", pPort-> GetName (), dwStatus));
                        lUpdateTime = pPort->NextUpdateTime();
                    }
                    if ( lSmallestUpdateTime > lUpdateTime )
                        lSmallestUpdateTime = lUpdateTime;

                    pPort->DecRef ();
                    pPort = NULL;

                    if (WaitForSingleObject( hStatusEvent, 0 ) == WAIT_OBJECT_0) {
                        if ( bTerminate )
                            break;  // We have been asked to terminate, abandon the main loop.
                    }

                }
            }

            pEnum->DecRef ();
        }

        pList->pPortMgr->m_pPortList->DecRef ();

        if (bTerminate) {
            break;
        }

        EnterPortListCS ();
        pList = pList->pNext;
        LeavePortListCS ();

    }
    if (dummySnmpSession)
    {
        SnmpMgrClose (dummySnmpSession);
    }
    DBGMSG (DBG_INFO, ("CheckAndUpdateAllPrinters [END]\n"));

    return lSmallestUpdateTime;
}


VOID
CDeviceStatus::
StatusThread(
    CDeviceStatus   *pDeviceStatus
    )
{
    time_t  lUpdateTime;
    DWORD   rc;

    while ( !pDeviceStatus->bTerminate ) {

        lUpdateTime = pDeviceStatus->CheckAndUpdateAllPrinters();

        if ( pDeviceStatus->bTerminate )
            break;

        WaitForSingleObject(pDeviceStatus->hStatusEvent, static_cast<DWORD> (lUpdateTime*1000));
    }

    CloseHandle(pDeviceStatus->hStatusEvent);
    pDeviceStatus->bTerminate = FALSE;
    pDeviceStatus->hStatusEvent = NULL;
}


BOOL
CDeviceStatus::
RunThread(
    VOID
    )
{
    HANDLE      hThread;
    DWORD       dwThreadId;

    EnterCS();

    //
    // If the thread is already running wake it up. So for clustering
    // we do SNMP for new ports too
    //
    //
    if ( hStatusEvent ) {

        SetEvent(hStatusEvent);
        goto Done;
    }

    if ( hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ) {
        hThread = CreateThread(NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)StatusThread,
                               (LPVOID)&gDeviceStatus(),
                               0,
                               &dwThreadId);

        if ( hThread ) {
            SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST);
            CloseHandle(hThread);
        } else {

            CloseHandle(hStatusEvent);
            hStatusEvent = NULL;
        }
    }

Done:
    LeaveCS();

    return hStatusEvent != NULL;
}


VOID
CDeviceStatus::
TerminateThread(
    VOID
    )
{

    EnterCS();

    bTerminate = TRUE;

    //
    // Wake up the status thread, and wait for it die.
    //
    SetEvent(hStatusEvent);

    while ( hStatusEvent )     // The background thread sets this to NULL when it is done
        Sleep(WAIT_FOR_THREAD_TIMEOUT);

    LeaveCS();
}


VOID
CDeviceStatus::
EnterCS(
    VOID
    )
{
    EnterCriticalSection(&CS);
}

VOID
CDeviceStatus::
LeaveCS(
    VOID
    )
{
    LeaveCriticalSection(&CS);
}

VOID
CDeviceStatus::EnterPortListCS(
    VOID)
{
    EnterCriticalSection(&PortListCS);
}

VOID
CDeviceStatus::LeavePortListCS(
    VOID)
{
    LeaveCriticalSection(&PortListCS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\event.h ===
/***************************************************************************
 * $Workfile: event.h $
 *
 * Copyright (C) 1993-1996 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho  83714
 *
 ***************************************************************************
 *
 * $Log: /StdTcpMon/TcpMon/event.h $
 * 
 * 2     7/14/97 2:27p Binnur
 * copyright statement
 * 
 * 1     7/02/97 2:19p Binnur
 * Initial File
 * 
 ***************************************************************************/

#ifndef _EVENT_H
#define _EVENT_H


#define	EVENT_TYPES_SUPPORTED		TEXT("TypesSupported")
#define	EVENT_MSG_FILE					TEXT("EventMessageFile")
#define	EVENT_LOG_APP_ROOT			TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog")

#define  LOG_APPLICATION				TEXT("Application")
#define  LOG_SYSTEM						TEXT("System")
#define  LOG_SECURITY					TEXT("Security")

#define EVENT_LOG0(err,id)                                  \
            if( 1 ) {                                       \
                EventLogAddMessage(err, (id), 0, NULL);		\
            } else

#define EVENT_LOG1(err,id,s0)										            \
            if( 1 ) {															   \
                LPTSTR apsz[1];													\
																							\
                apsz[0] = (s0);													\
                EventLogAddMessage(err, (id), 1, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG2(err,id,s0,s1)												   \
            if( 1 ) {																\
                LPTSTR apsz[2];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                EventLogAddMessage(err, (id), 2, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG3(err,id,s0,s1,s2)												\
            if( 1 ) {																\
                LPTSTR apsz[3];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                apsz[2] = (s2);													\
                EventLogAddMessage(err, (id), 3, (LPCTSTR *)apsz);	\
            } else

#define EVENT_LOG4(err,id,s0,s1,s2,s3)											\
            if( 1 ) {																\
                LPTSTR apsz[4];													\
																							\
                apsz[0] = (s0);													\
                apsz[1] = (s1);													\
                apsz[2] = (s2);													\
                apsz[3] = (s3);													\
                EventLogAddMessage(err, (id), 4, (LPCTSTR *)apsz);	\
            } else

#ifdef __cplusplus
extern "C" {
#endif

BOOL EventLogAddMessage
		(
		WORD		wType, 
		DWORD		dwID, 
		WORD		wStringCount, 
		LPCTSTR	*lpStrings
		);

BOOL EventLogOpen
		(
		LPTSTR lpAppName, 
		LPTSTR lpLogType,
		LPTSTR lpFileName
		);

void EventLogClose
		(
		void
		);

BOOL EventLogSetLevel
		(
		WORD wType
		);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\event.cpp ===
/*****************************************************************************
 *
 * $Workfile: event.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 * 
 * 
 ***************************************************************************/

#include "precomp.h"

HANDLE  hEventSource = NULL;
WORD        wLevel = EVENTLOG_ERROR_TYPE;

/***************************************************************************
 *
 * Function: EventLogAddMessage
 *
 * Author: Craig White
 *
 * Description:
 *     Adds the specified message to the event log.  The event log source
 *    must have already been specified in a previous call to EventLogOpen.
 *
 * Parameters:
 *    wType -
 *       The error level of the message to add.  The must be one of
 *       the following:
 *          EVENTLOG_ERROR_TYPE - Error message 
 *          EVENTLOG_WARNING_TYPE - Warning message
 *          EVENTLOG_INFORMATION_TYPE - Informational message
 *       A previous call to EventLogSetLevel will cause the messages
 *       to be filtered based on what level was set.  The default is
 *       to add all messages to the event log.
 *
 *    dwID -  
 *       The ID of the message that exists in the message file.  
 *       These values are defined in the message file.
 *
 *    wStringCount - 
 *       The number of strings passed in the lpString parameters.
 *       This must be 0 or greater.   
 *
 *    lpStrings - 
 *       An array of string pointers specifying the strings to include in
 *       the message.  This can be NULL if wStringCount is 0.
 *
 * Return Value:
 *    TRUE: The message was successfully added to the log.
 *    FALSE: The message could not be added.
 *
 ***************************************************************************/

BOOL
EventLogAddMessage(
    WORD        wType, 
    DWORD       dwID, 
    WORD        wStringCount, 
    LPCTSTR *lpStrings
    )

{

    BOOL        bLogEvent = FALSE;

    //
    //  A previous call to EventLogOpen was not done if this is NULL
    //
    if ( hEventSource == NULL ) {

        _ASSERTE(hEventSource != NULL);
        return FALSE;
    }

    //
    //  Check to see if message should be logged based on 
    //  set level
    //
    switch (wLevel) {

        case EVENTLOG_ERROR_TYPE:
            bLogEvent = TRUE;
            break;

        case EVENTLOG_WARNING_TYPE:
            bLogEvent = wType == EVENTLOG_ERROR_TYPE ||
                        wType == EVENTLOG_WARNING_TYPE;
            break;

        case EVENTLOG_INFORMATION_TYPE:
            bLogEvent = wType == EVENTLOG_ERROR_TYPE    ||
                        wType == EVENTLOG_WARNING_TYPE  ||
                        wType == EVENTLOG_INFORMATION_TYPE;
            break;

        default:
            _ASSERTE(FALSE);
            return FALSE;
    }
                     
    return bLogEvent ? ReportEvent(hEventSource, wType, 0, dwID, NULL,
                                   wStringCount,  0, (LPCTSTR *)lpStrings,
                                   NULL)
                     : TRUE;
}


/***************************************************************************
 *
 * Function: EventLogOpen
 *
 * Author: Craig White
 *
 * Description:
 *     Initializes the event log prior to adding messages.  All events go to
 *    specified event log type until a subsequent EventLogClose and 
 *    EventLogOpen are called.
 *
 * Parameters:
 *    lpAppName -
 *       The name of the service providing the event logging.
 *        
 *    lpLogType -
 *       The type of the event log to open.  Must be one of the following:
 *         LOG_APPLICATION - The application log 
 *         LOG_SYSTEM - The system log 
 *         LOG_SECURITY - The security log 
 *        
 *    lpFileName -  
 *       The complete path of the file that contains the messages.
 *
 * Return Value:
 *    TRUE: The event log was successfully opened.
 *    FALSE: The event log could not be opened.
 *
 ***************************************************************************/

BOOL
EventLogOpen(
    LPTSTR lpAppName, 
    LPTSTR lpLogType,
    LPTSTR lpFileName
    )

{
    TCHAR       szPathName[256];
    HKEY        hKey;
    DWORD       dwLen, dwKeyDisposition = 0;
    DWORD       dwMsgTypes = EVENTLOG_INFORMATION_TYPE | 
                             EVENTLOG_WARNING_TYPE | 
                             EVENTLOG_ERROR_TYPE;
    
    if ( !lpAppName || !lpFileName ||
         ( _tcsicmp(lpLogType, LOG_APPLICATION)     &&
           _tcsicmp(lpLogType, LOG_SECURITY)        &&
           _tcsicmp(lpLogType, LOG_SYSTEM) ) ) {

        _ASSERTE(FALSE);
        return FALSE;
    }

    //
    //  Event log was not closed from a previous open call
    //
    if ( hEventSource ) {

        _ASSERTE(hEventSource == NULL);
        return FALSE;
    }

    dwLen =  _tcslen(lpLogType) + _tcslen(lpAppName) + 3;

    if ( dwLen > SIZEOF_IN_CHAR(szPathName) ) {

        _ASSERTE(dwLen <= SIZEOF_IN_CHAR(szPathName));
        return FALSE;
    }

    StringCchPrintf (szPathName, COUNTOF (szPathName), TEXT("%s\\%s\\%s"), EVENT_LOG_APP_ROOT,
              lpLogType, lpAppName);

    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPathName, 0, lpAppName, 
                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                        &hKey, &dwKeyDisposition) != ERROR_SUCCESS )
        return FALSE;

    if ( RegSetValueEx(hKey, EVENT_TYPES_SUPPORTED, 0L,
                       REG_DWORD,  (LPBYTE)&dwMsgTypes,
                       sizeof(dwMsgTypes)) == ERROR_SUCCESS    &&
         RegSetValueEx(hKey, EVENT_MSG_FILE, 0L,
                       REG_SZ, (LPBYTE)lpFileName,
                       STRLENN_IN_BYTES(lpFileName)) == ERROR_SUCCESS ) {


        hEventSource = RegisterEventSource(NULL, lpAppName);
    }

    RegCloseKey(hKey);

    return hEventSource != NULL;

}


/***************************************************************************
 *
 * Function: EventLogClose
 *
 * Author: Craig White
 *
 * Description:
 *     Closes the event log after a prior call to EventLogOpen.
 *
 * Parameters: None
 *
 * Return Value: None
 *
 ***************************************************************************/

VOID
EventLogClose(
    VOID
    )
{
    //
    //  Cause an assert if the log was not previously opened
    //
    if ( !hEventSource ) {

        _ASSERTE(hEventSource != NULL );
    } else {

        DeregisterEventSource(hEventSource);
        hEventSource = NULL;
    }
}

/***************************************************************************
 *
 * Function: EventLogSetLevel
 *
 * Author: Craig White
 *
 * Description:
 *     Sets the level of messages to allow to go to the event log.
 *
 * Parameters:
 *    wType -
 *       The type of the level to limit messages to.  The results will be:
 *          EVENTLOG_ERROR_TYPE - Log only errors
 *          EVENTLOG_WARNING_TYPE - Log errors and warnings
 *          EVENTLOG_INFORMATION_TYPE - Log errors, warnings and information 
 *
 * Return Value:
 *    TRUE: The event log level was successfully set.
 *    FALSE: The event log level could not be set.
 *
 ***************************************************************************/

BOOL
EventLogSetLevel(
    WORD wType
    )

{
    if ( wType != EVENTLOG_ERROR_TYPE       && 
         wType != EVENTLOG_WARNING_TYPE     &&
         wType != EVENTLOG_INFORMATION_TYPE ) {

        _ASSERTE(wType == EVENTLOG_ERROR_TYPE       ||
                 wType == EVENTLOG_WARNING_TYPE     ||
                 wType == EVENTLOG_INFORMATION_TYPE);
        return FALSE;
    }

    wLevel = wType;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprifc.h ===
/*****************************************************************************
 *
 * $Workfile: LPRifc.h $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#ifndef INC_LPRIFC_H
#define INC_LPRIFC_H

#include "ipdata.h"
#include "lprdata.h"
#include "rawtcp.h"
#include "devstat.h"

#define	MAX_LPR_PORTS				1
#define LPR_PORT_1					515

///////////////////////////////////////////////////////////////////////////////
//  Global definitions/declerations

class	CPortRefABC;


// the interface for CLPRInterface class
class CLPRInterface : public CRawTcpInterface		
{
public:
	CLPRInterface(CPortMgr *pPortMgr);
	~CLPRInterface();

	DWORD	CreatePort( DWORD		IN		dwProtocolType,					// port related functions
						DWORD		IN		dwVersion,
						PPORT_DATA_1 IN		pData,
						CRegABC		IN		*pRegistry,
						CPortRefABC	IN OUT	**pPort );					
	DWORD	CreatePort( LPTSTR		IN		psztPortName,
						DWORD		IN		dwProtocolType,				
						DWORD		IN		dwVersion,
						CRegABC		IN		*pRegistry,
						CPortRefABC	IN OUT	**pPort );	
private:
    BOOL    GetRegistryEntry(LPTSTR		psztPortName,
							 DWORD	in	dwVersion,
                             CRegABC *pRegistry,
							 LPR_PORT_DATA_1	in	*pRegData1
							 );



};	// class CLPRInterface


#endif	// INC_LPRIFC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\monitors\tcpmon\tcpmon\lprjob.cpp ===
/*****************************************************************************
 *
 * $Workfile: lprjob.cpp $
 *
 * Copyright (C) 1997 Hewlett-Packard Company.
 * Copyright (C) 1997 Microsoft Corporation.
 * All rights reserved.
 *
 * 11311 Chinden Blvd.
 * Boise, Idaho 83714
 *
 *****************************************************************************/

#include "precomp.h"

#include "message.h"
#include "resource.h"
#include "lprport.h"
#include "rawdev.h"
#include "lprjob.h"

WCHAR       szDef[] = L"Default";

///////////////////////////////////////////////////////////////////////////////
//  CRawTcpJob::CRawTcpJob()
//      Called by CPort when StartDocPort is called

CLPRJob::
CLPRJob(
    IN  LPTSTR      psztPrinterName,
    IN  DWORD       jobId,
    IN  DWORD       level,
    IN  LPBYTE      pDocInfo,
    IN  BOOL        bSpoolFirst,
    IN  CTcpPort   *pParent
    ) : CTcpJob(psztPrinterName, jobId, level, pDocInfo, pParent, kLPRJob),
        m_hFile(INVALID_HANDLE_VALUE), m_dwFlags(0), m_dwJobSize(0),
        m_dwSizePrinted(0)
{
    if ( bSpoolFirst )
        m_dwFlags |= LPRJOB_SPOOL_FIRST;
}   // ::CLPRJob()


LPSTR
CLPRJob::
AllocateAnsiString(
    LPWSTR  pszUni
    )
/*++
        Allocate an ANSI string for the given unicode string. Memory is
        allocated, and caller is responsible for freeing it.
--*/
{
    DWORD   dwSize;
    LPSTR   pszRet = NULL;

    dwSize = (wcslen(pszUni) + 1) * sizeof(CHAR);

    if ( pszRet = (LPSTR) LocalAlloc(LPTR, dwSize) ) {

        UNICODE_TO_MBCS(pszRet, dwSize, pszUni, -1);
    }

    return pszRet;
}


BOOL
CLPRJob::
IsJobAborted(
    DWORD* pdwRet
    )
/*++
        Tells if the job should be aborted. A job should be aborted if it has
        been deleted or it needs to be restarted.

--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwNeeded;
    LPJOB_INFO_1    pJobInfo = NULL;

    dwNeeded = 0;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwNeeded);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) LocalAlloc(LPTR, dwNeeded))       ||
         !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded))
        goto Done;

    if ((pJobInfo->Status & JOB_STATUS_DELETING) ||
        (pJobInfo->Status & JOB_STATUS_DELETED) )
    {
        bRet = TRUE;
        *pdwRet = ERROR_PRINT_CANCELLED;
    }
    else if (pJobInfo->Status & JOB_STATUS_RESTART)
    {
        bRet = TRUE;
        *pdwRet = ERROR_SUCCESS;
    }

Done:
    if ( pJobInfo )
        LocalFree(pJobInfo);

    return bRet;
}


BOOL
CLPRJob::
UpdateJobStatus(
    DWORD   dwStatusId
    )
/*++
        Update job status with the spooler
--*/
{
    BOOL            bRet = FALSE;
    DWORD           dwSize;
    TCHAR           szStatus[100];
    LPJOB_INFO_1    pJobInfo1 = NULL;

    if ( dwStatusId     &&
         !LoadString(g_hInstance, dwStatusId,
                     szStatus, SIZEOF_IN_CHAR(szStatus)) )
        return FALSE;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwSize);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo1 = (LPJOB_INFO_1) LocalAlloc(LPTR, dwSize)) )
        goto Done;

    if ( !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo1, dwSize, &dwSize) )
        goto Done;

    pJobInfo1->Position = JOB_POSITION_UNSPECIFIED;
    pJobInfo1->pStatus  = dwStatusId ? szStatus : NULL;

    if ( bRet = SetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo1, 0) )
        m_dwFlags |= LPRJOB_STATUS_SET;

Done:
    if ( pJobInfo1 )
        LocalFree(pJobInfo1);

    return bRet;
}


DWORD
CLPRJob::
ReadLpdReply(
    DWORD dwTimeOut
    )
/*++
        Gets the acknowldgement from the LPD serve.
        Return value is the win32 error
--*/
{
    CHAR    szBuf[256];
    DWORD   dwRead, dwRet;

    if ( dwRet = (m_pParent->GetDevice())->Read((unsigned char *)szBuf,
                                                sizeof(szBuf),
                                                dwTimeOut,
                                                &dwRead) )
        goto Done;

    //
    // A 0 from the LPD server is an ACK, anything else is a NACK
    //
    if ( dwRead == 0 || szBuf[0] != '\0' )
        dwRet = CS_E_NETWORK_ERROR;

/*
    if ( dwRet )
        OutputDebugStringA("NACK\n");
    else
        OutputDebugStringA("ACK\n");
*/

Done:
    return dwRet;
}


HANDLE
CLPRJob::
CreateSpoolFile(
    )
/*++
        Generates a name for the spool file in the spool directory and
        creates the file.
--*/
{
    HANDLE      hFile = INVALID_HANDLE_VALUE, hToken = NULL;
    DWORD       dwType, dwNeeded;

    hToken = RevertToPrinterSelf();

    if ( GetPrinterData(m_hPrinter,
                        SPLREG_DEFAULT_SPOOL_DIRECTORY,
                        &dwType,
                        (LPBYTE)m_szFileName,
                        sizeof(m_szFileName),
                        &dwNeeded) != ERROR_SUCCESS                 ||
         !GetTempFileName(m_szFileName, TEXT("TcpSpl"), 0, m_szFileName) ) {

        goto Done;
    }

    hFile = CreateFile(m_szFileName,
                       GENERIC_READ|GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY
                                             | FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);
Done:

    //
    // The thread is not impersonating client if hToken == NULL
    //
    if (hToken && !ImpersonatePrinterClient(hToken)) {

        DBGMSG (DBG_PORT, ("ImpersionteFailed - %d\n", GetLastError ()));

        if (hFile != INVALID_HANDLE_VALUE) {
            // Close the file
            CloseHandle (hFile);
            hFile = INVALID_HANDLE_VALUE;
            DeleteFile (m_szFileName);
        }
    }

    return hFile;
}


DWORD
CLPRJob::
GetCFileAndName(
    LPSTR      *ppszCFileName,
    LPDWORD     pdwCFileNameLen,
    LPSTR      *ppszCFile,
    LPDWORD     pdwCFileLen
    )
/*++
        Generates the control file and its name.
        Memory is allocated, caller is responsible for freeing it.
--*/
{
    DWORD           dwRet, dwJobId, dwNeeded, dwLen;
    LPJOB_INFO_1    pJobInfo = NULL;
    LPSTR           pHostName = NULL, pUserName = NULL, pJobName = NULL;
    LPWSTR          psz;

    dwNeeded =  *pdwCFileNameLen = *pdwCFileLen = 0;

    GetJob(m_hPrinter, m_dJobId, 1, NULL, 0, &dwNeeded);

    if ( (dwRet = GetLastError()) != ERROR_INSUFFICIENT_BUFFER )
        goto Done;

    if ( !(pJobInfo = (LPJOB_INFO_1) LocalAlloc(LPTR, dwNeeded))       ||
         !GetJob(m_hPrinter, m_dJobId, 1, (LPBYTE)pJobInfo, dwNeeded, &dwNeeded) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    dwJobId = pJobInfo->JobId % 1000; // LPR used seq nos. why?

    //
    // Convert machine name to ANSI
    //
    if ( pJobInfo->pMachineName && *pJobInfo->pMachineName ) {

        psz = pJobInfo->pMachineName;
        while ( *psz == L'\\' )
            ++psz;

    } else {

        psz = szDef;
    }

    if ( !(pHostName = AllocateAnsiString(psz)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    //
    // Convert user name to ANSI
    //
    if ( pJobInfo->pUserName && *pJobInfo->pUserName )
        psz = pJobInfo->pUserName;
    else
        psz = szDef;

    if ( !(pUserName = AllocateAnsiString(psz)) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;

        goto Done;
    }

    //
    // Convert job name to ANSI if not NULL
    //
    if ( pJobInfo->pDocument && *pJobInfo->pDocument ) {

        if ( !(pJobName = AllocateAnsiString(pJobInfo->pDocument)) ) {

            if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
                dwRet = ERROR_OUTOFMEMORY;

            goto Done;
        }
    }

    //
    // Compute the length of the 2 fields
    //
    *pdwCFileNameLen    = 6 + strlen(pHostName);
    *pdwCFileLen        = 2 + strlen(pHostName) + 2 + strlen(pUserName)
                                                + 2 * (2 + *pdwCFileNameLen);

    if ( pJobName )
        *pdwCFileLen += 2 * (2 + strlen(pJobName));

    if ( !(*ppszCFile = (LPSTR) LocalAlloc(LPTR,
                                           (*pdwCFileLen + 1) * sizeof(CHAR)))  ||
         !(*ppszCFileName = (LPSTR) LocalAlloc(LPTR,
                                               (*pdwCFileNameLen + 1 ) * sizeof(CHAR))) ) {

        if ( (dwRet = GetLastError()) == ERROR_SUCCESS )
            dwRet = ERROR_OUTOFMEMORY;
        goto Done;
    }

    //
    // CFile name
    //
    StringCchPrintfA (*ppszCFileName, *pdwCFileNameLen + 1, "dfA%03d%s", dwJobId, pHostName);

    //
    // Cmd line which varies depending on pJobName being non-NULL
    //
    if ( pJobName )
        StringCchPrintfA (*ppszCFile, *pdwCFileLen + 1,
                "H%s\nP%s\nJ%s\nl%s\nU%s\nN%s\n",
                pHostName,
                pUserName,
                pJobName,
                *ppszCFileName,
                *ppszCFileName,
                pJobName);
    else
        StringCchPrintfA (*ppszCFile, *pdwCFileLen + 1,
                "H%s\nP%s\nl%s\nU%s\n",
                pHostName,
                pUserName,
                *ppszCFileName,
                *ppszCFileName);

    dwLen = strlen (*ppszCFile);
    (*ppszCFileName)[0] = 'c';

    dwRet = ERROR_SUCCESS;

Done:
    if ( pJobInfo )
        LocalFree(pJobInfo);

    if ( pHostName )
        LocalFree(pHostName);

    if ( pUserName )
        LocalFree(pUserName);

    if ( pJobName )
        LocalFree(pJobName);

    if ( dwRet != ERROR_SUCCESS ) {

        if ( *ppszCFile ) {

            LocalFree(*ppszCFile);
            *ppszCFile = NULL;
        }

        if ( *ppszCFileName ) {

            LocalFree(*ppszCFileName);
            *ppszCFileName = NULL;
        }
    }

    return dwRet;
}


DWORD
CLPRJob::
EstablishConnection(
    VOID
    )
{
    return CTcpJob::StartDoc();
}

DWORD
CLPRJob::
StartJob(
    VOID
    )
/*++
        Initiate the job by sending the control file header, control file,
        and the data file header.
--*/
{
    DWORD           dwRet, dwLen, dwDaemonCmdLen;
    DWORD           dwCFileNameLen, dwCFileLen, dwRead, dwWritten;
    LPSTR           pszCFile = NULL, pszCFileName = NULL,
                    pszHdr = NULL, pszQueue = NULL;

    if ( dwRet = GetCFileAndName(&pszCFileName, &dwCFileNameLen,
                                 &pszCFile, &dwCFileLen) )
        goto Done;

    if ( !(pszQueue = AllocateAnsiString(((CLPRPort *)m_pParent)->GetQueue())) ) {

        if ( (dwRet = GetL