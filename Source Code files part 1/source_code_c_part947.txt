
    NOTES:

    HISTORY:
	gregj	21-May-1991	Cloned from USER_ENUM

\**********************************************************/

APIERR GROUP_ENUM::CallAPI( BYTE ** ppbBuffer,
			    UINT * pcEntriesRead )
{
    /* NetUserGetGroups must be level 0, so: */
    UIASSERT( QueryInfoLevel() == 0 || _pszUserName == NULL);

    if (_pszUserName != NULL)
	return ::MNetUserGetGroups( QueryServer(),
				    _pszUserName,
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );
    else
	return ::MNetGroupEnum( QueryServer(),
			        QueryInfoLevel(),
			        ppbBuffer,
			        pcEntriesRead );

}  // GROUP_ENUM::CallAPI



/*****************************	GROUP0_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP0_ENUM::GROUP0_ENUM

    SYNOPSIS:	Constructor for level 0 group enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		pszUserName -	name of user to enumerate groups
				from, default is all groups in UAS

    HISTORY:
	gregj	21-May-1991	Cloned from USER0_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP0_ENUM::GROUP0_ENUM( const TCHAR * pszLocation,
			  const TCHAR * pszUserName )
  : GROUP_ENUM( pszLocation, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


GROUP0_ENUM::GROUP0_ENUM( LOCATION_TYPE locType,
			  const TCHAR  * pszUserName )
  : GROUP_ENUM( locType, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


GROUP0_ENUM::GROUP0_ENUM( const LOCATION & loc,
			  const TCHAR     * pszUserName )
  : GROUP_ENUM( loc, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


/*******************************************************************

    NAME:	GROUP0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID GROUP0_ENUM_OBJ :: SetBufferPtr( const struct group_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // GROUP0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( GROUP0, struct group_info_0 );



/*****************************	GROUP1_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP1_ENUM::GROUP1_ENUM

    SYNOPSIS:	Constructor for level 1 group enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	21-May-1991	Cloned from USER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP1_ENUM::GROUP1_ENUM( const TCHAR * pszLocation )
  : GROUP_ENUM( pszLocation, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM


GROUP1_ENUM::GROUP1_ENUM( LOCATION_TYPE locType )
  : GROUP_ENUM( locType, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM


GROUP1_ENUM::GROUP1_ENUM( const LOCATION & loc )
  : GROUP_ENUM( loc, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM



/*******************************************************************

    NAME:	GROUP1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID GROUP1_ENUM_OBJ :: SetBufferPtr( const struct group_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // GROUP1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( GROUP1, struct group_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\log\logmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    EVENTLOG.CXX

    This file contain miscellaneous classes used by the event log classes.

    FILE HISTORY:
        Yi-HsinS        12/31/91        Separated from eventlog.cxx
        Yi-HsinS        01/15/92        Use MSGID for type & Category
        Yi-HsinS        04/3/92         Use USHORT for type and
                                        NLS_STR for category
        Yi-HsinS        9/16/92         Use partial match for user names

*/

#include "pchlmobj.hxx"  // Precompiled header

/*******************************************************************

    NAME:           LOG_ENTRY_BASE::LOG_ENTRY_BASE

    SYNOPSIS:       Constructor

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    pszCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LOG_ENTRY_BASE::LOG_ENTRY_BASE( ULONG        ulRecordNum,
                                ULONG        ulTime,
                                USHORT       usType,
                                const TCHAR *pszCategory,
                                ULONG        ulEventID,
                                EVENT_LOG   *pEventLog )
    :  _ulRecordNum( ulRecordNum ),
       _ulTime( ulTime ),
       _usType( usType ),
       _nlsCategory( pszCategory ),
       _ulEventID( ulEventID ),
       _pEventLog( pEventLog )
{
    UIASSERT( pEventLog != NULL );

    if ( QueryError()  != NERR_Success )
        return;

    APIERR err;

    if ((err = _nlsCategory.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:           LOG_ENTRY_BASE::Set

    SYNOPSIS:       Set all the members in the class

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    pszCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/5/92          Created

********************************************************************/

APIERR LOG_ENTRY_BASE::Set( ULONG        ulRecordNum,
                            ULONG        ulTime,
                            USHORT       usType,
                            const TCHAR *pszCategory,
                            ULONG        ulEventID,
                            EVENT_LOG   *pEventLog )
{
    UIASSERT( pEventLog != NULL );

    _ulRecordNum = ulRecordNum;
    _ulTime = ulTime;
    _usType = usType;
    _nlsCategory = pszCategory;
    _ulEventID = ulEventID;
    _pEventLog = pEventLog;

    return  _nlsCategory.QueryError();
}

/*******************************************************************

    NAME:           LOG_ENTRY_BASE::~LOG_ENTRY_BASE

    SYNOPSIS:       Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:          We don't need to delete the _pEventLog. That
                    will be left to whoever that created the event log.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LOG_ENTRY_BASE::~LOG_ENTRY_BASE()
{
    _pEventLog = NULL;
}

/*******************************************************************

    NAME:           RAW_LOG_ENTRY::RAW_LOG_ENTRY

    SYNOPSIS:       Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/5/92          Created

********************************************************************/
static TCHAR *pszDefault = SZ("");   // Default string for ALIAS_STR
                                     // to prevent it from asserting out

RAW_LOG_ENTRY::RAW_LOG_ENTRY()
    :  LOG_ENTRY_BASE(),
       _nlsSource    ( pszDefault ),
       _nlsUser      ( pszDefault ),
       _nlsComputer  ( pszDefault )
{
    // Don't need to check errors for _nlsSource, _nlsUser, _nlsComputer
    // because they are ALIAS_STR
    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:           RAW_LOG_ENTRY::RAW_LOG_ENTRY

    SYNOPSIS:       Constructor

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    nlsCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pszSource    - Source that logged the event log entry
                    pszUser      - User in the event log entry
                    pszComputer  - Computer in the event log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

RAW_LOG_ENTRY::RAW_LOG_ENTRY( ULONG         ulRecordNum,
                              ULONG         ulTime,
                              USHORT        usType,
                              const TCHAR  *pszCategory,
                              ULONG         ulEventID,
                              const TCHAR  *pszSource,
                              const TCHAR  *pszUser,
                              const TCHAR  *pszComputer,
                              EVENT_LOG    *pEventLog )
    :  LOG_ENTRY_BASE( ulRecordNum, ulTime, usType, pszCategory,
                       ulEventID,   pEventLog ),
       _nlsSource    ( pszSource ),
       _nlsUser      ( pszUser ),
       _nlsComputer  ( pszComputer )
{

    // Don't need to check errors for _nlsSource, _nlsUser, _nlsComputer
    // because they are ALIAS_STR

    if ( QueryError() != NERR_Success )
        return;

}

/*******************************************************************

    NAME:           RAW_LOG_ENTRY::Set

    SYNOPSIS:       Set all the members in the class

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    pszCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pszSource    - Source that logged the event log entry
                    pszUser      - User in the event log entry
                    pszComputer  - Computer in the event log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/5/92          Created

********************************************************************/

APIERR RAW_LOG_ENTRY::Set( ULONG         ulRecordNum,
                           ULONG         ulTime,
                           USHORT        usType,
                           const TCHAR  *pszCategory,
                           ULONG         ulEventID,
                           const TCHAR  *pszSource,
                           const TCHAR  *pszUser,
                           const TCHAR  *pszComputer,
                           EVENT_LOG    *pEventLog )
{

    APIERR err = LOG_ENTRY_BASE::Set( ulRecordNum, ulTime, usType,
                                      pszCategory, ulEventID, pEventLog );

    if ( err == NERR_Success )
    {
        _nlsSource  = pszSource;
        _nlsUser    = pszUser;
        _nlsComputer= pszComputer;

        // Don't need to check errors for _nlsSource, _nlsUser, _nlsComputer
        // because they are ALIAS_STR
    }

    return err;

}


/*******************************************************************

    NAME:           RAW_LOG_ENTRY::QuerySource
                                   QueryUser
                                   QueryComputer

    SYNOPSIS:       Get the source, user or computer string

    ENTRY:

    EXIT:

    RETURNS:        Returns the pointer to the associated string

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

NLS_STR *RAW_LOG_ENTRY::QuerySource( VOID )
{
    return &_nlsSource;
}

NLS_STR *RAW_LOG_ENTRY::QueryUser( VOID )
{
    return &_nlsUser;
}

NLS_STR *RAW_LOG_ENTRY::QueryComputer( VOID )
{
    return &_nlsComputer;
}

/*******************************************************************

    NAME:           FORMATTED_LOG_ENTRY::FORMATTED_LOG_ENTRY

    SYNOPSIS:       Constructor

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    pszType      - Type string of the event log entry
                    pszCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pszSource    - Source that logged the event log entry
                    pszUser      - User in the event log entry
                    pszComputer  - Computer in the event log entry
                    pszDescription - Description contained in the log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

FORMATTED_LOG_ENTRY::FORMATTED_LOG_ENTRY( ULONG        ulRecordNum,
                                          ULONG        ulTime,
                                          USHORT       usType,
                                          const TCHAR *pszType,
                                          const TCHAR *pszCategory,
                                          ULONG        ulEventID,
                                          const TCHAR *pszSource,
                                          const TCHAR *pszUser,
                                          const TCHAR *pszComputer,
                                          const TCHAR *pszDescription,
                                          EVENT_LOG   *pEventLog )
    :  LOG_ENTRY_BASE( ulRecordNum, ulTime, usType, pszCategory,
                       ulEventID,   pEventLog ),
       _nlsType( pszType ),
       _nlsSource( pszSource ),
       _nlsUser( pszUser ),
       _nlsComputer( pszComputer ),
       _nlsDescription( pszDescription )
{

    if ( QueryError() )
        return;

    APIERR err;
    if (  (( err = _nlsType.QueryError() ) != NERR_Success )
       || (( err = _nlsSource.QueryError() ) != NERR_Success )
       || (( err = _nlsUser.QueryError() ) != NERR_Success )
       || (( err = _nlsComputer.QueryError() ) != NERR_Success )
       || (( err = _nlsDescription.QueryError() ) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:           FORMATTED_LOG_ENTRY::Set

    SYNOPSIS:       Set all the members in the class

    ENTRY:          ulRecordNum  - Record number of the eventlog entry
                    ulTime       - Time in the event log entry
                    usType       - Type of event log entry
                    pszType      - Type string of the event log entry
                    pszCategory  - Category of the event log entry
                    ulEventID    - ID of the event log entry
                    pszSource    - Source that logged the event log entry
                    pszUser      - User in the event log entry
                    pszComputer  - Computer in the event log entry
                    pszDescription - Description contained in the log entry
                    pEventLog    - Pointer to the event log that that this
                                   entry belongs to.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/5/92          Created

********************************************************************/

APIERR FORMATTED_LOG_ENTRY::Set( ULONG        ulRecordNum,
                                 ULONG        ulTime,
                                 USHORT       usType,
                                 const TCHAR *pszType,
                                 const TCHAR *pszCategory,
                                 ULONG        ulEventID,
                                 const TCHAR *pszSource,
                                 const TCHAR *pszUser,
                                 const TCHAR *pszComputer,
                                 const TCHAR *pszDescription,
                                 EVENT_LOG   *pEventLog )
{

    APIERR err = LOG_ENTRY_BASE::Set( ulRecordNum, ulTime, usType,
                                      pszCategory, ulEventID, pEventLog );

    if ( err == NERR_Success )
    {
        _nlsType = pszType;
        _nlsSource = pszSource;
        _nlsUser = pszUser;
        _nlsComputer = pszComputer;
        _nlsDescription = pszDescription;

        if (  (( err = _nlsType.QueryError() ) != NERR_Success )
           || (( err = _nlsSource.QueryError() ) != NERR_Success )
           || (( err = _nlsUser.QueryError() ) != NERR_Success )
           || (( err = _nlsComputer.QueryError() ) != NERR_Success )
           || (( err = _nlsDescription.QueryError() ) != NERR_Success )
           )
        {
            // Nothing to do, just want to set the err!
        }
    }

    return err;
}

/*******************************************************************

    NAME:           FORMATTED_LOG_ENTRY::QuerySource
                                         QueryUser
                                         QueryComputer

    SYNOPSIS:       Get the source, user or computer string

    ENTRY:

    EXIT:

    RETURNS:        Returns the pointer to the associated string

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

NLS_STR *FORMATTED_LOG_ENTRY::QuerySource( VOID )
{
    return &_nlsSource;
}

NLS_STR *FORMATTED_LOG_ENTRY::QueryUser( VOID )
{
    return &_nlsUser;
}

NLS_STR *FORMATTED_LOG_ENTRY::QueryComputer( VOID )
{
    return &_nlsComputer;
}

/*******************************************************************

    NAME:           EVENT_PATTERN_BASE::EVENT_PATTERN_BASE

    SYNOPSIS:       Constructor

    ENTRY:          usType       - Type to match in the event log entry
                    pszCategory  - Category to match in the event log entry
                    pszSource    - Source to match in the event log entry
                    pszUser      - User to match in the event log entry
                    pszComputer  - Computer to match in the event log entry
                    ulEventID    - Event ID to match in the event log entry

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

EVENT_PATTERN_BASE::EVENT_PATTERN_BASE( USHORT       usType,
                                        const TCHAR *pszCategory,
                                        const TCHAR *pszSource,
                                        const TCHAR *pszUser,
                                        const TCHAR *pszComputer,
                                        ULONG        ulEventID )
    : _usType       ( usType ),
      _nlsCategory  ( pszCategory ),
      _nlsSource    ( pszSource ),
      _nlsUser      ( pszUser ),
      _nlsComputer  ( pszComputer ),
      _ulEventID    ( ulEventID )
{
    if ( QueryError() )
        return;

    APIERR err;
    if (  ((err = _nlsCategory.QueryError() ) != NERR_Success )
       || ((err = _nlsSource.QueryError()) != NERR_Success )
       || ((err = _nlsUser.QueryError()) != NERR_Success )
       || ((err = _nlsComputer.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}


/*******************************************************************

    NAME:           EVENT_PATTERN_BASE::CheckForMatch

    SYNOPSIS:       Check to see if the log entry matches the pattern

    ENTRY:          pLogEntry - pointer to a log entry to match the
                                pattern

    EXIT:           pfMatch   - pointer to a BOOL which is TRUE if the log entry
                                matches the pattern, and FALSE otherwise.


    RETURN:         APIERR

    NOTES:          All string compares are case insensitive and user names
                    are matched partially.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR EVENT_PATTERN_BASE::CheckForMatch( BOOL *pfMatch,
                                          LOG_ENTRY_BASE *pLogEntry ) const
{
    UIASSERT( pfMatch != NULL );
    UIASSERT( pLogEntry != NULL );

    *pfMatch = FALSE;
    APIERR err = NERR_Success;

    if (  (  ( _nlsCategory.QueryTextLength() == 0 )
          || ( _nlsCategory._stricmp( *(pLogEntry->QueryCategory())) == 0))
       && (  ( _nlsSource.QueryTextLength() == 0 )
          || ( _nlsSource._stricmp( *(pLogEntry->QuerySource())) == 0))
       && (  ( _nlsComputer.QueryTextLength() == 0 )
          || !::I_MNetComputerNameCompare( _nlsComputer,
                                           *(pLogEntry->QueryComputer()) ))
       && (  ( _ulEventID == NUM_MATCH_ALL )
          || ( _ulEventID == pLogEntry->QueryDisplayEventID()))
       && ( _usType & pLogEntry->QueryType() )
       )
    {
        if ( _nlsUser.QueryTextLength() == 0 )
        {
            *pfMatch = TRUE;
        }
        else
        {
            NLS_STR nlsUser( *(pLogEntry->QueryUser()));
            NLS_STR nlsUserPat( _nlsUser );

            if (  ((err = nlsUser.QueryError()) == NERR_Success )
               && ((err = nlsUserPat.QueryError()) == NERR_Success )
               )
            {
                nlsUser._strupr();
                nlsUserPat._strupr();

                ISTR istr( nlsUser );
                if ( nlsUser.strstr( &istr, nlsUserPat ))
                {
                    *pfMatch = TRUE;
                }
            }
        }
    }

    return err;
}

/*******************************************************************

    NAME:           EVENT_FILTER_PATTERN::EVENT_FILTER_PATTERN

    SYNOPSIS:       Constructor

    ENTRY:          usType       - Type to match in the event log entry
                    pszCategory  - Category to match in the event log entry
                    pszSource    - Source to match in the event log entry
                    pszUser      - User to match in the event log entry
                    pszComputer  - Computer to match in the event log entry
                    ulEventID    - Event ID to match in the event log entry
                    ulFromTime   - Start range of time to match in the
                                   event log entry
                    ulThroughTime- Ending range of time to match in the
                                   event log entry

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

EVENT_FILTER_PATTERN::EVENT_FILTER_PATTERN( USHORT       usType,
                                            const TCHAR *pszCategory,
                                            const TCHAR *pszSource,
                                            const TCHAR *pszUser,
                                            const TCHAR *pszComputer,
                                            ULONG        ulEventID,
                                            ULONG        ulFromTime,
                                            ULONG        ulThroughTime )
    : EVENT_PATTERN_BASE( usType,  pszCategory, pszSource,
                          pszUser, pszComputer, ulEventID ),
      _ulFromTime   ( ulFromTime ),
      _ulThroughTime( ulThroughTime )
{
     if ( QueryError() != NERR_Success )
         return;
}


/*******************************************************************

    NAME:           EVENT_FILTER_PATTERN::CheckForMatch

    SYNOPSIS:       Check to see if the raw log entry matches the pattern

    ENTRY:          pRawLogEntry -  the raw log entry to match the
                                    pattern

    EXIT:           pfMatch - point to BOOL that is TRUE if the log entry
                              matches the pattern, FALSE otherwise

    RETURNS:        APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR EVENT_FILTER_PATTERN::CheckForMatch( BOOL *pfMatch,
                                            RAW_LOG_ENTRY *pRawLogEntry ) const
{

    UIASSERT( pfMatch != NULL );
    UIASSERT( pRawLogEntry != NULL );

    APIERR err = EVENT_PATTERN_BASE::CheckForMatch( pfMatch, pRawLogEntry );
    ULONG  ulTime = pRawLogEntry->QueryTime();

    if (  ( err == NERR_Success )
       && ( *pfMatch )
       && (  ( _ulThroughTime == NUM_MATCH_ALL )
          || ( ulTime <= _ulThroughTime )
          )
       && (  ( _ulFromTime == NUM_MATCH_ALL )
          || ( ulTime >= _ulFromTime )
          )
       )
    {
        *pfMatch = TRUE;
        return NERR_Success;
    }

    *pfMatch = FALSE;
    return err;
}

/*******************************************************************

    NAME:           EVENT_FIND_PATTERN::EVENT_FIND_PATTERN

    SYNOPSIS:       Constructor

    ENTRY:          usType       - Type to match in the event log entry
                    pszCategory  - Category to match in the event log entry
                    pszSource    - Source to match in the event log entry
                    pszUser      - User to match in the event log entry
                    pszComputer  - Computer to match in the event log entry
                    ulEventID    - Event ID to match in the event log entry
                    pszDescription - Description to match in the event log entry
                    evdir        - Direction of search (forward or backward).
                                   We don't need this in pattern matching.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

EVENT_FIND_PATTERN::EVENT_FIND_PATTERN( USHORT           usType,
                                        const TCHAR     *pszCategory,
                                        const TCHAR     *pszSource,
                                        const TCHAR     *pszUser,
                                        const TCHAR     *pszComputer,
                                        ULONG            ulEventID,
                                        const TCHAR     *pszDescription,
                                        EVLOG_DIRECTION  evdir )
    : EVENT_PATTERN_BASE( usType,  pszCategory, pszSource,
                          pszUser, pszComputer, ulEventID ),
      _nlsDescription( pszDescription ),
      _evdir  ( evdir )
{
     if ( QueryError() != NERR_Success )
         return;

     APIERR err;
     if ( (err = _nlsDescription.QueryError()) != NERR_Success )
     {
         ReportError( err );
         return;
     }

}


/*******************************************************************

    NAME:           EVENT_FIND_PATTERN::CheckForMatch

    SYNOPSIS:       Check to see if the raw log entry matches the pattern

    ENTRY:          pRawLogEntry - the raw log entry to be matched

    EXIT:           pfMatch - pointer to BOOL that is TRUE if the pattern
                              matches, FALSE otherwise.

    RETURNS:        APIERR

    NOTES:        (1) There are two variations of CheckForMatch(), one matching
                      the raw log entry ( to be used when some entries are
                      not cached) and the other for formatted log entry.
                  (2) All string compares are case insensitive and descriptions
                      are matched partially.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR EVENT_FIND_PATTERN::CheckForMatch( BOOL *pfMatch,
                                          RAW_LOG_ENTRY *pRawLogEntry ) const
{
    UIASSERT( pfMatch != NULL );
    UIASSERT( pRawLogEntry != NULL );

    APIERR err = EVENT_PATTERN_BASE::CheckForMatch( pfMatch, pRawLogEntry );

    if (( err == NERR_Success) && ( *pfMatch ) )
    {
        *pfMatch = FALSE;
        if ( _nlsDescription.QueryTextLength() == 0 )
        {
            *pfMatch = TRUE;
        }
        else
        {
            NLS_STR nlsDesc; // place to store the desc. of the log entry
            NLS_STR nlsDescPat = _nlsDescription; // the desc in the pattern

            if (  ((err = nlsDesc.QueryError()) == NERR_Success )
               && ((err = nlsDescPat.QueryError()) == NERR_Success )
               && ((err = (pRawLogEntry->QueryEventLog())
                          ->QueryCurrentEntryDesc( &nlsDesc ))
                   == NERR_Success )
               )
            {
                nlsDesc._strupr();
                nlsDescPat._strupr();

                ISTR istr( nlsDesc );
                if ( nlsDesc.strstr( &istr, nlsDescPat ) )
                {
                    *pfMatch = TRUE;
                }
            }
        }

    }

    return err;
}

/*******************************************************************

    NAME:           EVENT_FIND_PATTERN::CheckForMatch

    SYNOPSIS:       Check to see if the formatted log entry matches the pattern

    ENTRY:          pFmtLogEntry - the formatted log entry to be matched

    EXIT:           pfMatch - pointer to a BOOL that is TRUE if the log
                    entry matches the pattern, FALSE otherwise

    RETURNS:        APIERR

    NOTES:        (1) There are two variations of CheckForMatch(), one matching
                      the raw log entry ( to be used when some entries are
                      not cached) and the other the formatted log entry.
                  (2) All string compares are case insensitive and descriptions
                      are matched partially.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR EVENT_FIND_PATTERN::CheckForMatch( BOOL *pfMatch,
                                FORMATTED_LOG_ENTRY *pFmtLogEntry) const
{
    UIASSERT( pfMatch != NULL );
    UIASSERT( pFmtLogEntry != NULL );

    APIERR err = EVENT_PATTERN_BASE::CheckForMatch( pfMatch, pFmtLogEntry );

    if (( err == NERR_Success) && ( *pfMatch ) )
    {
        *pfMatch = FALSE;

        if ( _nlsDescription.QueryTextLength() == 0  )
        {
            *pfMatch = TRUE;
        }
        else
        {
            // The description in the log entry
            NLS_STR nlsDesc = *(pFmtLogEntry->QueryDescription());

            // The description in the pattern
            NLS_STR nlsDescPat = _nlsDescription;

            if (  ((err = nlsDesc.QueryError()) == NERR_Success )
               && ((err = nlsDescPat.QueryError()) == NERR_Success )
               )
            {

                // We don't have the description yet!
                if ( nlsDesc.QueryTextLength() == 0 )
                {
                    // Get the description
                    EVENT_LOG *pEventLog = pFmtLogEntry->QueryEventLog();

                    LOG_ENTRY_NUMBER logEntryNum(
                            pFmtLogEntry->QueryRecordNum(),
                            pEventLog->QueryDirection() );

                    if (  (( err = pEventLog->SeekLogEntry( logEntryNum ))
                           != NERR_Success )
                       || (( err = pEventLog->QueryCurrentEntryDesc( &nlsDesc ))
                           != NERR_Success )
                       || (( err = pFmtLogEntry->SetDescription( nlsDesc ))
                           != NERR_Success )
                       )
                    {
                       // Nothing to do
                    }
                }

                if ( err == NERR_Success )
                {
                    nlsDesc._strupr();
                    nlsDescPat._strupr();

                    ISTR istr( nlsDesc );
                    if ( nlsDesc.strstr( &istr, nlsDescPat ))
                    {
                        *pfMatch = TRUE;
                    }
                }
            }
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\pch\lmobjnew.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      JonN        24-Jul-1991     Created
 *      rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
 *      rustanl     26-Aug-1991     Changed [W_]CloneFrom parameter
 *                                  from * to &
 *      jonn    8/29/91         Added ChangeToNew()
 *      jonn    9/05/91         Changes related to IsOKState()
 *      jonn    9/17/91         Moved CHECK_OK / CHECK_VALID strings to static
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        change _pBuf from TCHAR * to BYTE *
 *      jonn    11/20/91        Fixed ResizeBuffer( 0 )
 *      jonn    5/08/92         Added ClearBuffer()
 *
 *      This file contains basic methods for the LM_OBJ root classes.
 */

#include "pchlmobj.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


/**********************************************************\

   NAME:        NEW_LM_OBJ::NEW_LM_OBJ

   SYNOPSIS:    constructor and destructor

   NOTES:       The BUFFER object must construct successfully

   HISTORY:
        JonN        12-Aug-1991     Created

\**********************************************************/

NEW_LM_OBJ::NEW_LM_OBJ( BOOL fValidate )
    : LM_OBJ_BASE( fValidate ),
      _pBuf( NULL )
{
    if ( QueryError() )
        return;
}

/*******************************************************************

    NAME:       NEW_LM_OBJ::~NEW_LM_OBJ

    SYNOPSIS:   destrcutor

    NOTES:      free up the memory

    HISTORY:
                terryk  17-Oct-91       Created

********************************************************************/

NEW_LM_OBJ::~NEW_LM_OBJ()
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::GetInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::GetInfo()
{
    if ( IsUnconstructed() || IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeValid();

    APIERR err = I_GetInfo();
    if (err != NERR_Success)
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteInfo()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_WriteInfo();
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::CreateNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::CreateNew()
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_CreateNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteNew()
{
    if ( !IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    APIERR err = I_WriteNew();
    if (err != NERR_Success)
        return err;

    MakeValid(); // the object is no longer new

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::Write

    SYNOPSIS:   This method calls either WriteInfo() or WriteNew()
                depending on the state of the object.

    HISTORY:
        JonN        13-Sep-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::Write()
{
    if ( IsNew() )
        return WriteNew();
    else
        return WriteInfo();
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::Delete( UINT uiForce )
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_Delete( uiForce );
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::ChangeToNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::ChangeToNew()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_ChangeToNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}


/**********************************************************\

    NAME:       NEW_LM_OBJ::QueryName

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

const TCHAR * NEW_LM_OBJ::QueryName() const
{
    UIASSERT( FALSE ); // not valid unless redefined
    return NULL;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_GetInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_GetInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_CreateNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_CreateNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_ChangeToNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_ChangeToNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Copies object, including base API buffer

    NOTES:      W_CloneFrom should copy all component objects at each
                level.  Every level which has component objects should
                define W_CloneFrom.  Every W_CloneFrom should start with a call
                to the predecessor W_CloneFrom.

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &
        terryk      14-Oct-1991     Use NT NetApi to allocate a new
                                    buffer. It may not work for some
                                    instance. BUGBUG
        JonN        31-Oct-1991     Enabled

\**********************************************************/

APIERR NEW_LM_OBJ::W_CloneFrom( const NEW_LM_OBJ & lmobj )
{
    UINT uBufSize = lmobj.QueryBufferSize();
    APIERR err = ResizeBuffer( uBufSize );
    if ( err != NERR_Success )
        return err;

    if ( uBufSize > 0 )
    {
        UIASSERT( _pBuf != NULL );
        ::memcpyf( (TCHAR *)_pBuf,
                   (const TCHAR *)lmobj.QueryBufferPtr(),
                   uBufSize );
    }

    _usState = lmobj._usState;

    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CreateNew

    SYNOPSIS:   initializes fields with accessors

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines the
                default values for its own private data members.  This
                is done in W_CreateNew(), where each level calls up to
                its parent.  Every level which has component objects should
                define W_CreateNew.  Every W_CreateNew should start with a call
                to the predecessor W_CreateNew.

    CAVEATS:    Note that NEW_LM_OBJ::W_CreateNew copies the API buffer but
                does not initialize the fields in the API buffer.  These
                fields need only be initialized if they have no accessors.
                Only the I_CreateNew method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_CreateNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_ChangeToNew

    SYNOPSIS:   Transforms object from VALID to NEW

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines
                whether its shadow members take different forms between
                the NEW and VALID states.  W_ChangeToNew changes the
                shadow members, but not the API buffer, from VALID to NEW.
                Only levels with component objects which are different
                between VALID and NEW must define W_ChangeToNew.  Every
                W_ChangeToNew should start with a call to the predecessor
                W_ChangeToNew.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_ChangeToNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::FixupPointer

    SYNOPSIS:   Fixes pointer inside a copied API buffer

    NOTES:      This is a utility routine for the use of CloneFrom() variants.
                When an API buffer is CloneFrom'd, some of its internal
                components may be pointers to strings inside the buffer.
                These pointers should be fixed-up to point into the new
                buffer, otherwise the cloned NEW_LM_OBJ points to a
                string in the old NEW_LM_OBJ and may break it the old
                one is freed.  Only pointers pointing within the old
                buffer need be fixed, NULL pointers  and pointers not
                pointing withing the old buffer can be left alone.
                Pointers which have a shadow NLS_STR can be left
                alone, Query() will use the NLS_STR and the API buffer
                will be fixed by the next WriteInfo/WriteNew.

    ENTRY:      *ppchar is the pointer to be fixed up.
                bufOld is the API buffer for the old NEW_LM_OBJ
                bufNew is the API buffer for the new NEW_LM_OBJ

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

                Also note that you must walk on eggshells to do the
                pointer addition/subtraction without C6 leaving off the
                upper word.

                The pointer is not necessarily either NULL or within the old
                buffer.  In some cases, an obscure pointer may or may
                not point within the buffer, depending on whether the
                object was created with GetInfo or CreateNew.  We must
                handle this case by leaving alone any pointers which are
                non-NULL but point outside the buffer.

                Also note that this will not work for pointers in API
                buffers other than the default API buffer.

    HISTORY:
        JonN        04-Aug-1991     Created

\**********************************************************/

VOID NEW_LM_OBJ::FixupPointer( TCHAR ** ppchar,
                   const NEW_LM_OBJ * plmobjOld
                 )
{
    ULONG_PTR ulCurrPtr = (ULONG_PTR)(*ppchar);

    // return if null pointer
    if ( ulCurrPtr == 0 )
        return;

    ULONG_PTR ulOld = (ULONG_PTR)plmobjOld->QueryBufferPtr();

    // the object size should never be equal to 0

    UIASSERT( plmobjOld->QueryBufferSize() != 0 );

    // return if not pointing in old buffer
    if  (    ( ulCurrPtr < ulOld )
          || ( ulCurrPtr >= ulOld + ((UINT)plmobjOld->QueryBufferSize()) )
        )
    {
        return;
    }

    // do not assume 2's complement math -- avoid overflow
    ULONG_PTR ulNew = (ULONG_PTR)QueryBufferPtr();
    if ( ulOld >= ulNew )
        *ppchar = (TCHAR *)(ulCurrPtr - (ulOld - ulNew));
    else
        *ppchar = (TCHAR *)(ulCurrPtr + (ulNew - ulOld));

}


/*******************************************************************

    NAME:       NEW_LM_OBJ::QueryBufferSize

    SYNOPSIS:   query the buffer size

    HISTORY:
                jonn    31-Oct-91       Created

********************************************************************/

UINT NEW_LM_OBJ::QueryBufferSize() const
{
    UINT uSize = 0;
    APIERR err = NERR_Success;
    if (_pBuf != NULL)
        err = ::MNetApiBufferSize( _pBuf, &uSize );
    if ( err != NERR_Success )
    {
        DBGEOL( "Failure in NEW_LM_OBJ::QueryBufferSize() " << err );
        ASSERT( FALSE );
        return 0;
    }
    return uSize;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::SetBufferPtr

    SYNOPSIS:   set the buffer pointer

    ENTRY:      TCHAR *pBuffer - new pointer

    NOTES:      remove the old buffer if necessary

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

VOID NEW_LM_OBJ::SetBufferPtr( BYTE * pBuffer )
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );

    _pBuf = pBuffer;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ResizeBuffer

    SYNOPSIS:   resize the current buffer and copy the old content to
                the new one

    ENTRY:      UINT cbSize - new buffer size

    RETURNS:    APIERR for buffer creation error

    NOTES:      MNetApiBufferAlloc returns NULL when asked to allocate a
                buffer of length 0.  To get around this, we allocate a
                buffer of length 1 where the requested size is 0.

    HISTORY:
                terryk  14-Oct-91       Created
                jonn    31-Oct-91       Enabled
                jonn    31-Oct-91       Allocate 1 where 0 requested

********************************************************************/

APIERR NEW_LM_OBJ::ResizeBuffer( UINT cbNewRequestedSize )
{
    if ( cbNewRequestedSize == 0 )
        cbNewRequestedSize = 1;

    BYTE * pTemp = ::MNetApiBufferAlloc( cbNewRequestedSize );
    if ( pTemp == NULL )
        return ( ERROR_NOT_ENOUGH_MEMORY );

    if ( _pBuf != NULL )
    {
        UINT uMinSize = QueryBufferSize();
        if ( uMinSize > cbNewRequestedSize )
            uMinSize = cbNewRequestedSize;

        ::memcpyf((TCHAR *) pTemp, (TCHAR *) _pBuf, uMinSize );
    }

    SetBufferPtr( pTemp );

    return NERR_Success;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ClearBuffer

    SYNOPSIS:   Set all bits in the current buffer to 0

    RETURNS:    APIERR for error

    HISTORY:
                jonn    08-May-92       Created

********************************************************************/

APIERR NEW_LM_OBJ::ClearBuffer()
{
    BYTE * pTemp = QueryBufferPtr();
    if ( pTemp == NULL )
    {
        UIASSERT( FALSE );
    }
    else
    {
        ::memsetf( (TCHAR *) pTemp, 0, QueryBufferSize() );
    }

    return NERR_Success;
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::LOC_LM_OBJ

   SYNOPSIS:    constructors

   NOTES:       The LOCATION object must construct successfully

   HISTORY:
        JonN        07-Aug-1991     Created

\**********************************************************/

VOID LOC_LM_OBJ::CtAux( VOID )
{
    if ( QueryError() )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
        ReportError( err );
}

LOC_LM_OBJ::LOC_LM_OBJ( const TCHAR * pszLocation, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(pszLocation)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( enum LOCATION_TYPE loctype, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loctype)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( const LOCATION & loc, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loc)
{
    CtAux();
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::W_CloneFrom

   SYNOPSIS:    Copies object

   NOTES:       see NEW_LM_OBJ::W_CloneFrom

   HISTORY:
        JonN        26-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &

\**********************************************************/

APIERR LOC_LM_OBJ::W_CloneFrom( const LOC_LM_OBJ & lmobj )
{
    APIERR err = NEW_LM_OBJ::W_CloneFrom( lmobj );
    if ( err != NERR_Success )
        return err;

    err = _loc.Set( lmobj._loc );
    if ( err != NERR_Success )
    {
        DBGEOL( "LOC_LM_OBJ::W_CloneFrom failed on LOCATION copy " << err );
        return err;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\bin\makefile.inc ===
COMBINE_SOURCELIBS=..\buffer\$(O)\buffer.lib  \
                   ..\misc\$(O)\misc.lib      \
                   ..\trace\$(O)\trace.lib    \
                   ..\system\$(O)\system.lib  \
                   ..\wintime\$(O)\wintime.lib \
                   ..\fsenum\$(O)\fsenum.lib \
                   ..\base\$(O)\base.lib \
                   ..\heap\$(O)\heap.lib \
                   ..\errmap\$(O)\errmap.lib \
                   ..\fmx\$(O)\fmx.lib

COMBINE_TARGETLIB=$(O)\uimisc.lib

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\base\base.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    base.cxx
    Implementation of the BASE class.

    FILE HISTORY:
	chuckc	    27-Feb-1992     created

*/


#include "lmui.hxx"
#include "base.hxx"

static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName

APIERR vlasterr ;

VOID BASE::_ReportError( APIERR errSet )
{
    vlasterr = _err  = errSet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\service\lmoaserv.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmoaserv.hxx
    APP_LM_SERVICE class definition


    FILE HISTORY:
	rustanl     09-Jun-1991     Created

*/


#define INCL_OS2
#define INCL_DOSERRORS
#define INCL_DOSSIGNALS
#define INCL_DOSPROCESS
#define INCL_DOSFILEMGR
#define INCL_NETERRORS
#include <lmui.hxx>

extern "C" 
{
    #include <netcons.h>
    #include <service.h>
    #include <message.h>

}

#include <uiassert.hxx>
#include <uitrace.hxx>

#include "lmoserv.hxx"


#define DEFAULT_STACK_SIZE (4096+512)	// This is what is used in the
					// LAN Man 2.0 Prog Ref.


/*******************************************************************

    NAME:	APP_LM_SERVICE::APP_LM_SERVICE

    SYNOPSIS:	APP_LM_SERVICE constructor

    ENTRY:	pszName -	Pointer to name of service

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APP_LM_SERVICE::APP_LM_SERVICE( const TCHAR * pszName )
    :	LM_SERVICE( pszName ),
	_hSemPause( 0L ),
	_bufApplicationThreadStack( DEFAULT_STACK_SIZE )
{
    if ( QueryError() != NERR_Success )
	return;

    if ( _bufApplicationThreadStack.QuerySize() != DEFAULT_STACK_SIZE )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

}  // APP_LM_SERVICE::APP_LM_SERVICE


/*******************************************************************

    NAME:	APP_LM_SERVICE::~APP_LM_SERVICE

    SYNOPSIS:	APP_LM_SERVICE destructor

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APP_LM_SERVICE::~APP_LM_SERVICE()
{
    // nothing else to do

}  // APP_LM_SERVICE::~APP_LM_SERVICE


/*******************************************************************

    NAME:	APP_LM_SERVICE::OnInstall

    SYNOPSIS:	Called when service is being installed

    RETURNS:	An API error code, which is NERR_Success on success

    NOTES:	This is a virtual method, defined in a parent class.
		It may be replaced by subclasses.

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APIERR APP_LM_SERVICE::OnInstall( void )
{
    /*	Spawn the application thread  */

    BYTE * pbStack = _bufApplicationThreadStack.QueryPtr() +
		     _bufApplicationThreadStack.QuerySize() -
		     sizeof( this );
    *((APP_LM_SERVICE * *)(pbStack)) = this;
    TID tid;
    APIERR err = DosCreateThread( (PFNTHREAD)&ApplicationThread,
				  &tid,
				  pbStack );
    if ( err != NERR_Success )
	return err;

    return NERR_Success;

}  // APP_LM_SERVICE::OnInstall


/*******************************************************************

    NAME:	APP_LM_SERVICE::OnPause

    SYNOPSIS:	Called when the service is paused

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void APP_LM_SERVICE::OnPause( void )
{
    DosSemSet( &_hSemPause );

    LM_SERVICE::OnPause();

}  // APP_LM_SERVICE::OnPause


/*******************************************************************

    NAME:	APP_LM_SERVICE::OnContinue

    SYNOPSIS:	Called when the service is continued

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void APP_LM_SERVICE::OnContinue( void )
{
    DosSemClear( &_hSemPause );

    LM_SERVICE::OnContinue();

}  // APP_LM_SERVICE::OnContinue


/*******************************************************************

    NAME:	APP_LM_SERVICE::ApplicationThread

    SYNOPSIS:	Calls virtual ServeOne for as long as the service
		is not paused, and is still running

    EXIT:	This method never exits, unless something fatal occurred,
		in which case it calls FatalExit

    NOTES:	This method is executed only by the application thread

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void APP_LM_SERVICE::ApplicationThread( void )
{
    while ( TRUE )
    {
	APIERR err = DosSemWait( &_hSemPause, SEM_INDEFINITE_WAIT );
	if ( err != NERR_Success )
	    FatalExit( err );

	err = ServeOne();
	if ( err != NERR_Success )
	    FatalExit( err );
    }

}  // APP_LM_SERVICE::ApplicationThread


/*******************************************************************

    NAME:	APP_LM_SERVICE::ServeOne

    SYNOPSIS:	Serves one service request

    RETURNS:	An API return code, which is NERR_Success on success.
		If the return code indicates anything but success,
		this method will never be called again.  Thus, the
		method should only use return codes other than
		success in cases where no more services could possibly
		be performed.

    NOTES:	This is a virtual method, which may be replaced by
		subclasses

    NOTES:	This method is executed only by the application thread

		Any initialization that a subclassed ServeOne method\
		may require should be done in a subclassed OnInstall
		method.  Note, that OnInstall must call down to
		its parent's OnInstall--otherwise, the application thread
		will never be started.

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APIERR APP_LM_SERVICE::ServeOne( void )
{
    //	This default implementation does nothing.  Rather than waiting
    //	forever on some dummy semaphore, this method waits a few seconds
    //	instead.  This allows for the loop in ApplicationThread to be
    //	exercised in test programs that don't replace this method.
    DosSleep( 10000L ); 	// wait 10 seconds
    return NERR_Success;

}  // APP_LM_SERVICE::ServeOne


MYSERV_SERVICE::MYSERV_SERVICE( void )
    :	APP_LM_SERVICE( SZ("MyServ") )
{
    // nothing else to do

}  // MYSERV_SERVICE::MYSERV_SERVICE



#define STR_MESSAGE SZ("This is a message from the MyServ service")

extern "C"
{
    int xxx = 0;
}

APIERR MYSERV_SERVICE::ServeOne( void )
{
#if 0
    APIERR err = NetMessageBufferSend( NULL,
				       SZ("RUSTANL0"),
				       STR_MESSAGE,
				       sizeof( STR_MESSAGE ));
#endif

    xxx++;

    //	Note, 'err' is not returned at this time
    return NERR_Success;

}  // MYSERV_SERVICE::ServeOne
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\log\lognt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    LOGNT.CXX
        This file contains the NT event log class

    FILE HISTORY:
        Yi-HsinS        12/15/91        Separated from eventlog.cxx
        terryk          12/20/91        Added WriteTextEntry
        Yi-HsinS        01/15/92        Added Backup, SeekOldestLogEntry,
                                        SeekNewestLogEntry, modified
                                        WriteTextEntry, and fixed I_Next.
        Yi-HsinS        02/25/92        Added helper methods to get the
                                        description of each log entry from
                                        the registry.
        Yi-HsinS        05/25/92        Got rid of all NTSTATUS
        Yi-HsinS        07/25/92        Optimize reading the registry
        Yi-HsinS        10/20/92        Add support for parameter message file
                                        and primary source
        Yi-HsinS        12/15/92        If category dll does not exist,
                                        print out default string instead of
                                        returning error.
        RaviR           01/10/95        Added code to retrieve Description
                                        for Cairo Alerts.
        RaviR           02/27/95        Added code to determine the source
                                        name for Cairo Alerts.
        JonN            6/22/00         WriteTextEntry no longer supported
*/

#include "pchlmobj.hxx"  // Precompiled header

#ifdef _CAIRO_
#define MODULE_CONTAINING_ALERTFUNCTIONS L"alertsys.dll"
#define WIN32_FROM_HRESULT(hr) (hr & 0x0000FFFF)
#endif // _CAIRO_


#define OPEN_BRACKET_CHAR            TCH('(')
#define SHARE_DRIVE_CHAR             TCH('$')
#define CLOSE_BRACKET_CHAR           TCH(')')
#define PATH_SEPARATOR_CHAR          TCH('\\')
#define QUALIFIED_ACCOUNT_SEPARATOR  TCH('\\')
#define PERIOD_CHAR                  TCH('.')
#define PERCENT_CHAR                 TCH('%')
#define RETURN_CHAR                  TCH('\r')
#define NEWLINE_CHAR                 TCH('\n')

#define EMPTY_STRING                 SZ("")
#define END_OF_LINE                  SZ("\r\n")
#define EVENTMSGFILE_SEPARATOR       SZ(",;")
#define COMMA_STRING                 SZ(", ")
#define TWO_PERCENT_STRING           SZ("%%")
#define SYSTEMROOT_PERCENT_STRING    SZ("%SystemRoot%")

//
// The following strings are key names in the registry
//
#define CURRENTVERSION_NODE          SZ("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define SYSTEMROOT_STRING            SZ("SystemRoot")
#define EVENTLOG_ROOT_NODE           SZ("System\\CurrentControlSet\\Services\\Eventlog\\")
#define PRIMARY_MODULE_STRING        SZ("PrimaryModule")
#define SOURCE_STRING                SZ("Sources")
#define EVENTS_FILE_KEY_NAME         SZ("EventMessageFile")
#define CATEGORY_FILE_KEY_NAME       SZ("CategoryMessageFile")
#define CATEGORY_COUNT_KEY_NAME      SZ("CategoryCount")
#define TYPE_MASK_KEY_NAME           SZ("TypesSupported")
#define PARAMETER_FILE_KEY_NAME      SZ("ParameterMessageFile")

//
// The default type mask if the source does not have any information in
// the registry.
//
#define DEFAULT_TYPE_MASK            EVENTLOG_INFORMATION_TYPE \
                                     | EVENTLOG_WARNING_TYPE   \
                                     | EVENTLOG_ERROR_TYPE \
                                     | EVENTLOG_AUDIT_SUCCESS \
                                     | EVENTLOG_AUDIT_FAILURE

/*******************************************************************

    NAME:        DLL_NAME_HANDLE_PAIR::DLL_NAME_HANDLE_PAIR

    SYNOPSIS:    Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

DLL_NAME_HANDLE_PAIR::DLL_NAME_HANDLE_PAIR()
    : _nlsName(),
      _handle( 0 )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _nlsName.QueryError() != NERR_Success )
    {
        ReportError( _nlsName.QueryError() );
        return;
    }
}

/*******************************************************************

    NAME:        DLL_NAME_HANDLE_PAIR::DLL_NAME_HANDLE_PAIR

    SYNOPSIS:    Constructor

    ENTRY:       pszName - Name of the Dll
                 handle  - Handle to the above Dll

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

DLL_NAME_HANDLE_PAIR::DLL_NAME_HANDLE_PAIR( const TCHAR *pszName, HMODULE handle)
    : _nlsName( pszName ),
      _handle ( handle )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _nlsName.QueryError() != NERR_Success )
    {
        ReportError( _nlsName.QueryError() );
        return;
    }
}

//
// An array of DLL_NAME_HANDLE_PAIR
//
DEFINE_ARRAY_OF( DLL_NAME_HANDLE_PAIR )

/*******************************************************************

    NAME:        DLL_HANDLE_CACHE_ARRAY::DLL_HANDLE_CACHE_ARRAY

    SYNOPSIS:    Constructor

    ENTRY:       cElem - Number of elements needed in the array

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

DLL_HANDLE_CACHE_ARRAY::DLL_HANDLE_CACHE_ARRAY( UINT cElem )
    : _aDllNameHandle( cElem ),
      _cNext( 0 ),
      _fFull( FALSE )
{
   if ( QueryError() != NERR_Success )
       return;
}

/*******************************************************************

    NAME:        DLL_HANDLE_CACHE_ARRAY::QueryHandle

    SYNOPSIS:    Get the handle of the dll

    ENTRY:       nls - Name of the dll

    EXIT:

    RETURNS:     Returns the handle to the dll. If the dll is not
                 cached in the array, then return 0.

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

HMODULE DLL_HANDLE_CACHE_ARRAY::QueryHandle( const NLS_STR &nls )
{

    for ( INT i = 0; i < QueryCount(); i++ )
    {
         if ( nls._stricmp( *(_aDllNameHandle[i].QueryName() ) ) == 0 )
             return _aDllNameHandle[i].QueryHandle();
    }

    return 0;
}

/*******************************************************************

    NAME:        DLL_HANDLE_CACHE_ARRAY::Cache

    SYNOPSIS:    Cache the name/handle of the dll

    ENTRY:       nls    - Name of the dll
                 handle - Handle of the above dll

    EXIT:

    RETURNS:

    NOTES:       If the array is full, we will free the dll
                 that has been cached the longest period of time
                 before adding the new dll/handle into the array.

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR DLL_HANDLE_CACHE_ARRAY::Cache( const NLS_STR &nls, HMODULE handle )
{
    if ( _fFull )
    {
        if ( !::FreeLibrary( _aDllNameHandle[ _cNext ].QueryHandle()))
            return ::GetLastError();
    }

    APIERR err = _aDllNameHandle[ _cNext++ ].Set( nls, handle );

    if ( _cNext == (UINT) QuerySize() )
    {
       _cNext = 0;
       _fFull = TRUE;
    }

    return err;
}

/*******************************************************************

    NAME:        SOURCE_INFO_ITEM::SOURCE_INFO_ITEM

    SYNOPSIS:    Constructor

    ENTRY:       pszSource          - Name of the source
                 usTypeMask         - Type mask supported by the source
                 pszCategoryDllName - Dll which contains the categories
                                      supported by the source
                 cCategoryCount     - Number of categories supported
                 pstrlstEventsDll   - String list of the dlls which
                                      contains the event ids supported
                                      by the source.
                 pszParameterMessageDllName - The Dll which contains strings
                                      for language dependent insertion
                                      strings.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

SOURCE_INFO_ITEM::SOURCE_INFO_ITEM( const TCHAR *pszSource,
                                    USHORT       usTypeMask,
                                    const TCHAR *pszCategoryDllName,
                                    USHORT       cCategoryCount,
                                    STRLIST     *pstrlstEventsDll,
                                    const TCHAR *pszParameterMessageDllName )
    : _fInitialized      ( FALSE ),
      _nlsSource         ( pszSource ),
      _usTypeMask        ( usTypeMask ),
      _nlsCategoryDllName( pszCategoryDllName ),
      _cCategoryCount    ( cCategoryCount ),
      _pstrlstCategory   ( NULL ),
      _pstrlstEventsDll  ( pstrlstEventsDll ),
      _nlsParameterMessageDllName( pszParameterMessageDllName )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsSource.QueryError()) != NERR_Success )
       || ((err = _nlsCategoryDllName.QueryError()) != NERR_Success )
       || ((err = _nlsParameterMessageDllName.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:        SOURCE_INFO_ITEM::~SOURCE_INFO_ITEM

    SYNOPSIS:    Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

SOURCE_INFO_ITEM::~SOURCE_INFO_ITEM()
{
    delete _pstrlstCategory;
    _pstrlstCategory = NULL;

    delete _pstrlstEventsDll;
    _pstrlstEventsDll = NULL;
}

/*******************************************************************

    NAME:        SOURCE_INFO_ITEM::Set

    SYNOPSIS:    Set related information of the source

    ENTRY:       usTypeMask         - Type mask supported by the source
                 pszCategoryDllName - Dll which contains the categories
                                      supported by the source
                 cCategoryCount     - Number of categories supported
                 pstrlstEventsDll   - String list of the dlls which
                                      contains the event ids supported
                                      by the source.
                 pszParameterMessageDllName - The Dll which contains strings
                                      for language dependent insertion
                                      strings.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR SOURCE_INFO_ITEM::Set(  USHORT       usTypeMask,
                               const TCHAR *pszCategoryDllName,
                               USHORT       cCategoryCount,
                               STRLIST     *pstrlstEventsDll,
                               const TCHAR *pszParameterMessageDllName )
{
    _fInitialized       = TRUE;
    _usTypeMask         = usTypeMask;
    _nlsCategoryDllName = pszCategoryDllName;
    _cCategoryCount     = cCategoryCount;
    _pstrlstEventsDll   = pstrlstEventsDll;
    _nlsParameterMessageDllName = pszParameterMessageDllName;

    APIERR err = _nlsCategoryDllName.QueryError();
    return ( err? err : _nlsParameterMessageDllName.QueryError());
}


/*******************************************************************

    NAME:        SOURCE_INFO_ITEM_PTR::Compare

    SYNOPSIS:    Compare the sources in the two SOURCE_INFO_ITEM_PTR

    ENTRY:       pptrSrcInfoItem - Pointer to the SOURCE_INFO_ITEM_PTR
                                   to compare this item with

    EXIT:

    RETURNS:     Returns the comparison of two source strings

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

INT SOURCE_INFO_ITEM_PTR::Compare(
    const SOURCE_INFO_ITEM_PTR * pptrSrcInfoItem ) const
{
    const NLS_STR *pnls1 = (this->QuerySourceItem())->QuerySource();
    const NLS_STR *pnls2 = (pptrSrcInfoItem->QuerySourceItem())->QuerySource();

    return pnls1->_stricmp( *pnls2 );
}

//
//  An array of SOURCE_INFO_ITEM
//
DEFINE_EXT_ARRAY_LIST_OF( SOURCE_INFO_ITEM_PTR )

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::LOG_REGISTRY_INFO

    SYNOPSIS:    Constructor

    ENTRY:       nlsServer - The server on which to read the registry
                 nlsModule - The name of the module which we need to
                             get the registry information for

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

LOG_REGISTRY_INFO::LOG_REGISTRY_INFO( const NLS_STR &nlsServer,
                                      const NLS_STR &nlsModule )
   : _nlsServer          ( nlsServer ),
     _nlsModule          ( nlsModule ),
     _aDllHandleCache    ( MAX_LIBRARY_OPENED ),
     _paSourceInfo       ( NULL ),
     _pstrlstSource      ( NULL ),
     _pRegKeyFocusModule ( NULL ),
     _iPrimarySource     ( (UINT) -1 ),
     _nlsRemoteSystemRoot( )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsServer.QueryError()) != NERR_Success )
       || ((err = _nlsModule.QueryError()) != NERR_Success )
       || ((err = _nlsRemoteSystemRoot.QueryError()) != NERR_Success )
       || ( _aDllHandleCache.QuerySize() != MAX_LIBRARY_OPENED )
       )
    {
        err = err? err : ERROR_NOT_ENOUGH_MEMORY;
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::~LOG_REGISTRY_INFO

    SYNOPSIS:    Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

LOG_REGISTRY_INFO::~LOG_REGISTRY_INFO()
{
    delete _paSourceInfo;
    _paSourceInfo = NULL;
    delete _pstrlstSource;
    _pstrlstSource = NULL;
    delete _pRegKeyFocusModule;
    _pRegKeyFocusModule = NULL;

    //
    //  Free all handles of dlls which are still opened
    //
    for ( INT i = 0; i < _aDllHandleCache.QueryCount(); i++ )
    {
        HMODULE handle = _aDllHandleCache[i].QueryHandle();
        if ( handle != 0 )
            ::FreeLibrary( handle );
    }
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::Init

    SYNOPSIS:    2nd stage constructor.
                 It initializes the string list of sources and
                 the array of SOURCE_INFO_ITEM.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::Init( VOID )
{

    //
    // If the following criteria is met, then the user has already
    // called Init() before, so we just return.
    //
    if ( ( _paSourceInfo != NULL ) && ( _pstrlstSource != NULL ) )
        return NERR_Success;

    APIERR err;
    do {   // Not a loop

        //
        //  Get the registry key of module on the server
        //
        if ((err = GetRegKeyModule( _nlsServer, &_pRegKeyFocusModule ))
               != NERR_Success )
        {
            break;
        }

        //
        //  Get the primary source
        //  ( We will ignore the return value from the registry read
        //    because the primary source is optional. )
        //
        NLS_STR nlsPrimarySource;
        if ((err = nlsPrimarySource.QueryError()) != NERR_Success )
            break;

        _pRegKeyFocusModule->QueryValue( PRIMARY_MODULE_STRING,
                                         &nlsPrimarySource );

        //
        //  Get the number of subkeys of the module, i.e., the number
        //  of sources under the module.
        //
        REG_KEY_INFO_STRUCT regKeyInfo;
        if ( (err = _pRegKeyFocusModule->QueryInfo( &regKeyInfo ))
             != NERR_Success )
        {
            break;
        }
        UINT cModules = (UINT) regKeyInfo.ulSubKeys;

        //
        //  Initialize the array to the size of the number of sources
        //
        _paSourceInfo = new SOURCE_INFO_ARRAY( cModules );
        if ( _paSourceInfo == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //  See if we can find the sources value under the module.
        //  If so, then use the value of the sources.
        //  If not, enumerate the registry keys under the module.
        err = _pRegKeyFocusModule->QueryValue( SOURCE_STRING,
                                               &_pstrlstSource );

        if ( err == NERR_Success )
        {
            UIASSERT( _pstrlstSource != NULL );
            UINT cElem = _pstrlstSource->QueryNumElem();

            if ( cElem > (UINT)_paSourceInfo->QueryCount() )
            {
                delete _paSourceInfo;
                _paSourceInfo = new SOURCE_INFO_ARRAY( cElem );
                if ( _paSourceInfo == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

            ITER_STRLIST istrlst( *_pstrlstSource );
            NLS_STR *pnls;
            while ( (pnls = istrlst.Next()) != NULL )
            {
                SOURCE_INFO_ITEM *pSrcInfoItem =
                    new SOURCE_INFO_ITEM( *pnls );
                if (  ( pSrcInfoItem == NULL )
                   || ( (err = pSrcInfoItem->QueryError()) != NERR_Success )
                   )
                {
                    err = err? err : ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //  The second argument is FALSE meaning that we will not
                //  destroy the SOURCE_INFO_ITEM contained in it. This is
                //  important since we need to keep the source item to
                //  be pointed by an item in the array.
                SOURCE_INFO_ITEM_PTR ptrSrcInfoItem( pSrcInfoItem, FALSE );
                if ( !_paSourceInfo->Add( ptrSrcInfoItem ) )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }
        else
        {

            //  Sources value cannot be found. Hence, enumerate the
            //  registry keys under the module.

            //
            //  Each item in *_pstrlstSource contains a pointer
            //  to the NLS_STR in SOURCE_INFO_ITEM. Hence, when we
            //  destroy the string list, we shouldn't destroy the
            //  strings contained in the string list.
            //  SOURCE_INFO_ITEM will destroy the NLS_STR when
            //  it gets destructed.
            //
            if ( (_pstrlstSource = new STRLIST( FALSE )) == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            //  Enumerate the subkeys of the module and add all source name
            //  into _paSourceInfo and _pstrlstSource.
            //
            REG_ENUM regEnum( *_pRegKeyFocusModule );
            if ( (err = regEnum.QueryError() ) != NERR_Success )
                break;

            for ( UINT i = 0; i < cModules; i++ )
            {
                if ((err = regEnum.NextSubKey( &regKeyInfo )) != NERR_Success )
                    break;

                SOURCE_INFO_ITEM *pSrcInfoItem =
                                 new SOURCE_INFO_ITEM( regKeyInfo.nlsName );
                if (  ( pSrcInfoItem == NULL )
                   || ( (err = pSrcInfoItem->QueryError()) != NERR_Success )
                   )
                {
                    err = err? err : ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //  The second argument is FALSE meaning that we will not
                //  destroy the SOURCE_INFO_ITEM contained in it. This is
                //  important since we need to keep the source item to
                //  be pointed by an item in the array.
                SOURCE_INFO_ITEM_PTR ptrSrcInfoItem( pSrcInfoItem, FALSE );
                if ( !_paSourceInfo->Add( ptrSrcInfoItem ) )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                // Add the source string to the string list
                if ( (err = _pstrlstSource->Add(
                            _paSourceInfo->QuerySource( i ))) != NERR_Success)
                {
                    break;
                }
            }
        }

        if ( err != NERR_Success )
            break;

        //
        // Sort the source info array if needed
        //
        if ( _paSourceInfo->QueryCount() > 1 )
            _paSourceInfo->Sort();

        //
        // Get the primary source and all its information
        //
        if ( nlsPrimarySource.QueryTextLength() > 0 )
        {
            _iPrimarySource = QuerySourceIndex( nlsPrimarySource );
            if ( _iPrimarySource >= 0 )
            {
                err = InitSource( _iPrimarySource );
                err = err? err : InitCategoryList( _iPrimarySource );
            }
        }

    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::GetRegKeyModule

    SYNOPSIS:    Get the module key on the server

    ENTRY:       pszServer - the server we want to read the
                             module key from

    EXIT:        *ppRegKeyModule - points to the resulting module key

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::GetRegKeyModule( const TCHAR *pszServer,
                                           REG_KEY **ppRegKeyModule )
{

    APIERR err = NERR_Success;
    ALIAS_STR nlsServer( pszServer );

    //
    // Get the HKEY_LOCAL_MACHINE of server
    //
    REG_KEY *pRegKeyMachine = NULL;
    if ( nlsServer.QueryTextLength() == 0 )
    {
        pRegKeyMachine = REG_KEY::QueryLocalMachine( KEY_READ );
    }
    else
    {
        pRegKeyMachine = new REG_KEY( HKEY_LOCAL_MACHINE,
                                      (TCHAR *) nlsServer.QueryPch(),
                                      KEY_READ );
    }

    if (  ( pRegKeyMachine == NULL )
       || ((err = pRegKeyMachine->QueryError() ) != NERR_Success )
       )
    {
        err = err? err : ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Get the module key
    //
    if ( err == NERR_Success )
    {

        NLS_STR nlsEventLogModule( EVENTLOG_ROOT_NODE );
        nlsEventLogModule.Append( _nlsModule );
        if ( (err = nlsEventLogModule.QueryError() ) == NERR_Success )
        {

            *ppRegKeyModule = new REG_KEY( *pRegKeyMachine,
                                           nlsEventLogModule,
                                           KEY_READ );

            if (  ( *ppRegKeyModule == NULL )
               || ((err = (*ppRegKeyModule)->QueryError() ) != NERR_Success )
               )
            {
                err = err? err :  ERROR_NOT_ENOUGH_MEMORY;
                delete *ppRegKeyModule;
                *ppRegKeyModule = NULL;
            }
        }
    }

    delete pRegKeyMachine;
    pRegKeyMachine = NULL;

    return err;

}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::QuerySourceIndex

    SYNOPSIS:    Get the index of the given source in the array

    ENTRY:       pszSource - The source we are looking for

    EXIT:

    RETURNS:     Returns the index into the array for the source.
                 -1 if the source is not found.

    NOTES:

    HISTORY:
        Yi-HsinS        10/15/92         Created

********************************************************************/

INT LOG_REGISTRY_INFO::QuerySourceIndex( const TCHAR *pszSource )
{
    SOURCE_INFO_ITEM srcInfoItem( pszSource );
    SOURCE_INFO_ITEM_PTR ptrSrcInfoItem( &srcInfoItem, FALSE );

    INT index = -1;
    if ( _paSourceInfo->QueryCount() > 0 )
        index = _paSourceInfo->BinarySearch( ptrSrcInfoItem );

    return index;
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::InitSource

    SYNOPSIS:    Get all the information under source in the registry
                 ( types supported, event msg dlls ... )

    ENTRY:       index - The item in the array which we
                         wanted to initialize

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::InitSource( INT index )
{

    APIERR err = NERR_Success;

    SOURCE_INFO_ITEM *pSrcInfoItem =
                     ((*_paSourceInfo)[ index ]).QuerySourceItem();

    //
    //  Return to caller if this item has already been initialized
    //
    if ( pSrcInfoItem->IsInitialized() )
        return NERR_Success;


    ALIAS_STR nlsEventsFileKeyName   ( EVENTS_FILE_KEY_NAME );
    ALIAS_STR nlsTypeMaskKeyName     ( TYPE_MASK_KEY_NAME );
    ALIAS_STR nlsCategoryCountKeyName( CATEGORY_COUNT_KEY_NAME );
    ALIAS_STR nlsCategoryFileKeyName ( CATEGORY_FILE_KEY_NAME );
    ALIAS_STR nlsParameterFileKeyName( PARAMETER_FILE_KEY_NAME );
    ALIAS_STR nlsSep                 ( EVENTMSGFILE_SEPARATOR );

    //
    //  Get the registry key of the source
    //
    REG_KEY *pRegKeyTemp = new REG_KEY( *_pRegKeyFocusModule,
                                        *( pSrcInfoItem->QuerySource()),
                                        KEY_READ );

    do {  // Not a loop

        if (  ( pRegKeyTemp == NULL )
           || ((err = pRegKeyTemp->QueryError()) != NERR_Success )
           )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        //  Set the default type mask
        //
        DWORD dwTypeMask;
        if ( PrimarySourceExist() && !IsPrimarySource(index) )
        {
            dwTypeMask = _paSourceInfo->QueryTypeMask( _iPrimarySource );
        }
        else
        {
            dwTypeMask = DEFAULT_TYPE_MASK;
        }

        NLS_STR nlsCategoryDllName;
        NLS_STR nlsParameterMessageDllName;
        STRLIST *pstrlstEventsDllName = NULL;
        DWORD   dwCategoryCount = 0;

        if (  ((err = nlsCategoryDllName.QueryError()) != NERR_Success )
           || ((err = nlsParameterMessageDllName.QueryError()) != NERR_Success )
           )
        {
            break;
        }

        //
        // Enumerate all the values under the source registry key
        //
        BUFFER buf( (MAX_PATH + 1) * sizeof( TCHAR) );
        REG_ENUM regValueEnum( *pRegKeyTemp );
        if (  ((err = regValueEnum.QueryError()) != NERR_Success )
           || ((err = buf.QueryError()) != NERR_Success )
           )
        {
            break;
        }

        REG_VALUE_INFO_STRUCT regValueInfo;
        regValueInfo.pwcData      = buf.QueryPtr();
        regValueInfo.ulDataLength = buf.QuerySize();

        while ( (err = regValueEnum.NextValue( &regValueInfo )) == NERR_Success)
        {
            TCHAR *pszStart = (TCHAR *) regValueInfo.pwcData;
            TCHAR *pszEnd   = (TCHAR *) ( regValueInfo.pwcData +
                                          regValueInfo.ulDataLengthOut );
            *pszEnd = 0;

            if ( regValueInfo.nlsValueName._stricmp( nlsEventsFileKeyName ) == 0)
            {
                pstrlstEventsDllName = new STRLIST( pszStart, nlsSep.QueryPch() );

                if ( pstrlstEventsDllName == NULL )
                    err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else if ( regValueInfo.nlsValueName._stricmp( nlsTypeMaskKeyName )
                      == 0 )
            {
                dwTypeMask = *( (LONG *) pszStart );
            }
            else if ( regValueInfo.nlsValueName._stricmp(
                      nlsCategoryCountKeyName) == 0 )
            {
                dwCategoryCount = *( (LONG *) pszStart );
            }
            else if ( regValueInfo.nlsValueName._stricmp(
                      nlsCategoryFileKeyName)  == 0 )
            {
                err = ExpandSystemRoot( pszStart, &nlsCategoryDllName );
            }
            else if ( regValueInfo.nlsValueName._stricmp(
                      nlsParameterFileKeyName) == 0 )
            {
                err = ExpandSystemRoot( pszStart, &nlsParameterMessageDllName );
            }

            if ( err != NERR_Success )
                break;
        }

        if ( ( err != NERR_Success ) && ( err != ERROR_NO_MORE_ITEMS ) )
            break;

        err = NERR_Success;

        //
        // Expand all system root in the dll paths contained in the string list
        //
        if ( pstrlstEventsDllName != NULL )
        {
            NLS_STR nlsTemp;
            if (( err = nlsTemp.QueryError()) != NERR_Success )
                break;

            ITER_STRLIST iterStrlst( *pstrlstEventsDllName );
            NLS_STR *pnls = NULL;
            while (  ((pnls = iterStrlst.Next() ) != NULL )
                  && ( err == NERR_Success )
                  )
            {
                if ((err = ExpandSystemRoot( *pnls, &nlsTemp )) != NERR_Success)
                    break;

                err = pnls->CopyFrom( nlsTemp );
            }

        }

        err = err? err : pSrcInfoItem->Set( (USHORT) dwTypeMask,
                                            nlsCategoryDllName,
                                            (USHORT) dwCategoryCount,
                                            pstrlstEventsDllName,
                                            nlsParameterMessageDllName );

        // Falls through if error occurred

    } while ( FALSE );

    delete pRegKeyTemp;
    pRegKeyTemp = NULL;

    return err;
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::InitCategoryList

    SYNOPSIS:    Initialize the categories associated with the source

    ENTRY:       index - The item in the array which we
                         wanted to initialize

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/15/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::InitCategoryList( INT index )
{
    APIERR err = NERR_Success;

    SOURCE_INFO_ITEM *pSrcInfoItem =
                     ((*_paSourceInfo)[ index ]).QuerySourceItem();

    STRLIST *pstrlst             = pSrcInfoItem->QueryCategoryList();
    const NLS_STR *pnlsCategoryDllName = pSrcInfoItem->QueryCategoryDllName();
    USHORT  cCategoryCount       = pSrcInfoItem->QueryCategoryCount();

    if (  ( pstrlst == NULL )
       && ( pnlsCategoryDllName->QueryTextLength() > 0 )
       && ( cCategoryCount > 0 )
       )
    {
        pstrlst = new STRLIST;

        do {  // Not a loop

            if ( pstrlst == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            HMODULE handle = ::LoadLibraryEx( *pnlsCategoryDllName,
                               NULL, LOAD_LIBRARY_AS_DATAFILE |
                                     DONT_RESOLVE_DLL_REFERENCES );

            //
            //  If we cannot successfully load the library and if
            //  we are pointing to a remote machine, try to use the
            //  information in the local registry instead.
            //
            if (  ( handle == 0 ) // error occurred
               && ( _nlsServer.QueryTextLength() != 0 ) // remote machine
               )
            {
                // Get the registry key on the local machine

                REG_KEY *pRegKey = NULL;
                NLS_STR nlsCategoryDllName;
                DWORD   dwCategoryCount;

                if ((err = nlsCategoryDllName.QueryError()) != NERR_Success )
                    break;

                err = GetRegKeyModule( EMPTY_STRING, &pRegKey);

                REG_KEY regKey( *pRegKey,
                                *( pSrcInfoItem->QuerySource()),
                                KEY_READ );

                err = err ? err : regKey.QueryError();

                err = err ? err
                          : regKey.QueryValue( CATEGORY_COUNT_KEY_NAME,
                                                 &dwCategoryCount );

                err = err ? err
                          : regKey.QueryValue( CATEGORY_FILE_KEY_NAME,
                                                 &nlsCategoryDllName,
                                                 0, NULL, TRUE );

                //
                // Load the library only if all the registry reads
                // succeeds. Otherwise, we just ignore the errors.
                //
                if ( err == NERR_Success )
                {
                    handle = ::LoadLibraryEx( nlsCategoryDllName,
                               NULL, LOAD_LIBRARY_AS_DATAFILE |
                                     DONT_RESOLVE_DLL_REFERENCES );
                    cCategoryCount = (USHORT) dwCategoryCount;
                }
                else
                {
                    err = NERR_Success;
                }

                delete pRegKey;
                pRegKey = NULL;
            }

            if ( err != NERR_Success )
                break;

            //
            //  Construct the list of categories. If we cannot load
            //  any message dlls, we will just contruct some default
            //  category strings using the categories ids.
            //
            NLS_STR *pnls = NULL;
            for ( INT i = (INT) cCategoryCount; i >= 1; i-- )
            {
                 if (  ((pnls = new NLS_STR() ) == NULL )
                    || (( err = pnls->QueryError()) != NERR_Success )
                    )
                 {
                     err = err ? err : ERROR_NOT_ENOUGH_MEMORY;
                     delete pnls;
                     break;
                 }

                 if ( handle != 0 )
                     err = RetrieveMessage( handle, i, pnls );

                 if (( handle == 0 ) || ( err != NERR_Success ))
                 {
                     // Make the default category name (i) if
                     // any error occurred or if we couldn't load
                     // the category dll.
                     // ERROR_MR_MID_NOT_FOUND
                     // ERROR_INVALID_PARAMETER
                     *pnls = EMPTY_STRING;
                     pnls->AppendChar( OPEN_BRACKET_CHAR );
                     pnls->Append( DEC_STR( i ) );
                     err = pnls->AppendChar( CLOSE_BRACKET_CHAR );
                 }
                 else
                 {
                     ISTR istr( *pnls );
                     istr += pnls->QueryTextLength() - 2;
                     if (  ( pnls->QueryChar( istr ) == RETURN_CHAR )
                        || ( pnls->QueryChar( ++istr ) == NEWLINE_CHAR )
                        )
                     {
                         pnls->DelSubStr(istr);
                     }
                 }

                 if ( err == NERR_Success )
                 {
                     err = pstrlst->Add( pnls );
                 }
                 else
                 {
                     delete pnls;
                     pnls = NULL;
                 }

                 if ( err != NERR_Success )
                     break;

            }

            // Falls through if error occurs

        } while ( FALSE );

        // Store the string list of categories in the array
        pSrcInfoItem->SetCategoryList( pstrlst );
    }

    return err;
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::ExpandSystemRoot

    SYNOPSIS:    Expand the system root in the path taking the computer
                 we are focusing on into account.

    ENTRY:       pszPath - The path that may contain "%SystemRoot%"

    EXIT:        pnls    - Points to the result string

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::ExpandSystemRoot( const TCHAR *pszPath, NLS_STR *pnls)
{
    APIERR err = NERR_Success;

    if ( _nlsServer.QueryTextLength() == 0 )   // Local Machine
    {
        TCHAR pszTemp[ MAX_PATH + 1];

        DWORD nCount = ::ExpandEnvironmentStrings( pszPath,
                                                   pszTemp,
                                                   MAX_PATH + 1 );

        UIASSERT( nCount <= MAX_PATH+1 );
        err = pnls->CopyFrom( pszTemp );
    }
    else  // Remote machine
    {
        do {  // Not a loop

            NLS_STR nlsLocal;
            if ( (err = nlsLocal.QueryError()) != NERR_Success )
                break;

            // Find the %SystemRoot% string. The string should always
            // be at the beginning of the path.

            ALIAS_STR nlsPath( pszPath );
            ALIAS_STR nlsSystemRoot( SYSTEMROOT_PERCENT_STRING );
            ISTR istrStart( nlsPath ), istrEnd( nlsPath );
            ++istrEnd;   // Got rid of the first "%"

            if ( nlsPath.strchr( &istrEnd, PERCENT_CHAR, istrEnd ) )
            {
                NLS_STR *pnlsTemp = nlsPath.QuerySubStr( istrStart, ++istrEnd);
                if ( pnlsTemp == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
                else if ( pnlsTemp->_stricmp( nlsSystemRoot ) == 0 )
                {
                    err = GetRemoteSystemRoot( &nlsLocal );
                    if ( err == NERR_Success )
                        err = nlsLocal.Append( nlsPath[ istrEnd ] );
                }
                else // no %SystemRoot% in the path
                {
                    err = nlsLocal.CopyFrom( pszPath );
                }

                delete pnlsTemp;
                pnlsTemp = NULL;

            }
            // The character % is not found. Hence, there is no
            // %SystemRoot% in it.
            else
            {
                err = nlsLocal.CopyFrom( pszPath );
            }

            if ( err != NERR_Success )
                break;

            //
            // The path we got above is relative to the remote computer.
            // Hence, we need to construct a UNC path for it.
            //
            ISTR istr( nlsLocal );
            TCHAR chDrive = nlsLocal.QueryChar( istr );

            UIASSERT(    (chDrive >= TCH('A') && chDrive <= TCH('Z'))
                      || (chDrive >= TCH('a') && chDrive <= TCH('z')) );

            pnls->CopyFrom  ( _nlsServer );
            pnls->AppendChar( PATH_SEPARATOR_CHAR );
            pnls->AppendChar( chDrive );
            pnls->AppendChar( SHARE_DRIVE_CHAR );
            // skip past "X:"
            pnls->Append( nlsLocal.QueryPch() + 2 );
            err = pnls->QueryError();

        } while ( FALSE );
    }

    return err;
}

/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::GetRemoteSystemRoot

    SYNOPSIS:    Get the system root of the remote computer
                 from its registry.

    ENTRY:

    EXIT:        pnls - Points to the path of the system root on
                        the remote computer

    RETURNS:

    NOTES:       This should only be called when we are focusing
                 on a remote computer. Otherwise, it will assert.

    HISTORY:
        Yi-HsinS        8/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::GetRemoteSystemRoot( NLS_STR *pnls )
{

    UIASSERT( _nlsServer.QueryTextLength() != 0 );

    if ( _nlsRemoteSystemRoot.QueryTextLength() != 0 )
        return pnls->CopyFrom( _nlsRemoteSystemRoot );

    //
    // We haven't read the remote system root yet, so read it!
    //

    APIERR err = NERR_Success;
    REG_KEY *pRegKeyMachine = new REG_KEY( HKEY_LOCAL_MACHINE,
                                           (TCHAR *) _nlsServer.QueryPch(),
                                           KEY_READ );
    REG_KEY *pRegKeyCurrentVersion = NULL;

    do {  // NOT a loop

        //
        // Get the HKEY_LOCAL_MACHINE of the remote machine
        //
        if (  ( pRegKeyMachine == NULL )
           || ((err = pRegKeyMachine->QueryError() ) != NERR_Success )
           )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Get the key containing System Root information
        //
        ALIAS_STR nlsCurrentVersion( CURRENTVERSION_NODE );
        pRegKeyCurrentVersion = new REG_KEY( *pRegKeyMachine,
                                             nlsCurrentVersion,
                                             KEY_READ );

        if (  ( pRegKeyCurrentVersion == NULL )
           || ((err =(pRegKeyCurrentVersion)->QueryError()) != NERR_Success)
           )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Get the system root information from the key
        //
        if ((err = pRegKeyCurrentVersion->QueryValue( SYSTEMROOT_STRING,
                   &_nlsRemoteSystemRoot )) != NERR_Success )
        {
            break;
        }

        err =  pnls->CopyFrom( _nlsRemoteSystemRoot );
    }
    while ( FALSE );

    delete pRegKeyCurrentVersion;
    delete pRegKeyMachine;
    return err;
}


/*******************************************************************

    NAME:        LOG_REGISTRY_INFO::GetLibHandle

    SYNOPSIS:    Get the handle of the given library

    ENTRY:       pszLibName - the name of the library

    EXIT:        pHandle    - points to the handle of the library

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::GetLibHandle( const TCHAR *pszLibName,
                                        HMODULE      *pHandle )
{
    APIERR err = NERR_Success;
    ALIAS_STR nlsLibName( pszLibName );

    do {  // Not a loop

        //
        //  See if we can find the library in the cache
        //
        for ( INT i = 0; i < _aDllHandleCache.QueryCount(); i++ )
        {
            if ( nlsLibName._stricmp( *(_aDllHandleCache[i].QueryName())) == 0 )
            {
                *pHandle = _aDllHandleCache[i].QueryHandle();
                return NERR_Success;
            }
        }

        //
        //  If we cannot find it in the cache, try to load it.
        //
        *pHandle = ::LoadLibraryEx( pszLibName,
                                    NULL, LOAD_LIBRARY_AS_DATAFILE |
                                          DONT_RESOLVE_DLL_REFERENCES );
        if ( *pHandle  == 0 )
        {
            err = ::GetLastError();
            break;
        }

        //
        //  Cache the handle we just got
        //
        _aDllHandleCache.Cache( pszLibName, *pHandle );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::RetrieveMessage

    SYNOPSIS:   The method that actually gets the string
                associated with the id in the dll handle.

    ENTRY:      handle - Handle of the dll
                nID    - The message id we are interested

    EXIT:       pnls   - The string associated with the ID

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        02/25/92        Created
        beng            05/10/92        No W version of FormatMessage yet
        YiHsinS         01/08/92        Use FormatMessageW

********************************************************************/

APIERR LOG_REGISTRY_INFO::RetrieveMessage( HMODULE   handle,
                                           ULONG    nID,
                                           NLS_STR *pnls )
{
    APIERR err;
    TCHAR *pszData = NULL;
    DWORD nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_HMODULE
                                  | FORMAT_MESSAGE_IGNORE_INSERTS
                                  | FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                  (LPVOID) handle,
                                  nID,
                                  0,      // BUGBUG LanguageId needed
                                  (LPTSTR) &pszData,
                                  1024,
                                  NULL );

    if ( nLen == 0 )
    {
        err = ::GetLastError();
    }
    else
    {
        err = pnls->CopyFrom( pszData );
        ::LocalFree( (VOID *) pszData );
    }

    return err;
}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::MapEventIDToString

    SYNOPSIS:   Get the string associated with (source, id)

    ENTRY:      pszSource - The given source
                ulEventID - The given event id

    EXIT:       *pnlsDesc - Points to the description

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::MapEventIDToString( const TCHAR *pszSource,
                                              ULONG        ulEventID,
                                              NLS_STR     *pnlsDesc )
{
    APIERR err = NERR_Success;
    STRLIST *pstrlstDllLocal = NULL;
    ALIAS_STR nlsSource( pszSource );

    INT index = QuerySourceIndex( pszSource );
    if ( index >= 0 )
    {

        if ( (err = InitSource( index )) != NERR_Success )
            return err;

        STRLIST *pstrlst = _paSourceInfo->QueryEventDllList( index );


        //
        // If the given source does not contain event dll list,
        // use the event dll list in the primary source if it exists.
        //
        if ( pstrlst == NULL )
        {
            if ( PrimarySourceExist() && !IsPrimarySource( index) )
            {
                pstrlst = _paSourceInfo->QueryEventDllList( _iPrimarySource );
                nlsSource = *(_paSourceInfo->QuerySource( _iPrimarySource ));
            }
        }

        //
        // No dlls to look for, just return message not found error.
        //
        if ( pstrlst == NULL )
            return ERROR_MR_MID_NOT_FOUND;

        //
        // Iterate through all dlls in the event dll list to find
        // the first dll that contains ulEventID. We will try to load
        // from the dll on the local machine if the remote one fails.
        //
        //   Example: ( we are focusing on a remote machine )
        //       Remote dll list:  dll1--> dll2--> dll3
        //       Local  dll list:  dll4--> dll5--> dll6
        //
        //   We will try to load ulEventID in this sequence:
        //       dll1-> dll4 -> dll2-> dll5-> dll3-> dll6
        //
        //   We will stop at the first dll that contains the id.
        //   (1) If this happens to be a local dll, then the remote dll will be
        //       replaced by the local one. If we found id in dll5, then
        //       the remote dll list will be modified to dll1--> dll5 --> dll3.
        //   (2) If both dll in the same position failed to load,
        //       then delete the dll. If both dll1 and dll4 failed to load,
        //       and we found the id in dll3, then the remote list becomes
        //                   dll2--> dll3
        //   (3) Also if the local list is shorter and the remote
        //       dll failed to load, we will also remote the dll name
        //       from the list.
        //
        ITER_STRLIST iterStrlst( *pstrlst );
        NLS_STR *pnlsLibName = NULL;
        HMODULE  handle = 0;
        INT     iNext = -1;

        // Flag indicating that an item has been removed from the list
        BOOL fRemoved = FALSE;

        // Flag indicating that we have finished iterating the local
        // event dll list or we have failed to get the local dll list
        BOOL fLocalListEnded = FALSE;

        do {

            iNext++;

            if ( !fRemoved )
            {
                pnlsLibName = iterStrlst.Next();
            }
            else
            {
                // The list has been altered.
                // Current node will point to the next node
                pnlsLibName = iterStrlst.QueryProp();
                fRemoved = FALSE;
            }

            // Cannot find the string in any dll...
            if ( pnlsLibName == NULL )
            {
                err = ERROR_MR_MID_NOT_FOUND;
                break;
            }

            err = GetLibHandle( *pnlsLibName, &handle );

            if ( err != NERR_Success )
            {
                if ( _nlsServer.QueryTextLength() == 0 )
                    continue;

                // Get the local dll list if we have not already done so.
                // We will ignore any error that occurred when we
                // are trying to get the local dll list.
                if ( !fLocalListEnded && ( pstrlstDllLocal == NULL ))
                {
                    REG_KEY *pRegKeyModuleLocal = NULL;

                    if ( (err = GetRegKeyModule( EMPTY_STRING,
                         &pRegKeyModuleLocal )) == NERR_Success )
                    {

                        REG_KEY    regKey( *pRegKeyModuleLocal,
                                           nlsSource, KEY_READ );
                        NLS_STR    nlsEventsDllName;
                        ALIAS_STR  nlsSep( EVENTMSGFILE_SEPARATOR );

                        err = regKey.QueryError();
                        err = err ? err : nlsEventsDllName.QueryError();

                        if (  ( err == NERR_Success )
                           && (( err = regKey.QueryValue( EVENTS_FILE_KEY_NAME,
                               &nlsEventsDllName, 0, NULL, TRUE ))
                               == NERR_Success )
                           )
                        {
                            // The value returned by QueryValue already has
                            // system root expanded.
                            pstrlstDllLocal = new STRLIST( nlsEventsDllName,
                                                           nlsSep );
                        }

                        if ( pstrlstDllLocal == NULL )
                            err = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    delete pRegKeyModuleLocal;
                    pRegKeyModuleLocal = NULL;

                    if ( err != NERR_Success )
                    {
                        fLocalListEnded = TRUE;
                        err = NERR_Success;
                    }
                }

                // Local computer has a shorter strlist or we failed to
                // get the local dll list, and the remote computer
                // failed to load the dll indicated,
                // then remove the dll from the strlst so that we don't
                // need to try it again next time.
                if ( fLocalListEnded )
                {
                    delete pstrlst->Remove( iterStrlst );
                    fRemoved = TRUE;
                    continue;
                }

                //
                // Find the dll in the local dll list in the same position
                //
                ITER_STRLIST iterDllLocal( *pstrlstDllLocal );
                NLS_STR *pnls;
                for ( INT i = 0; i <= iNext; i++ )
                {
                    pnls = iterDllLocal.Next();
                    if ( pnls == NULL )
                    {
                        fLocalListEnded = TRUE;
                        break;
                    }
                }

                //
                // (1) Local computer has a shorter strlist, and
                //     the remote computer fails to load the dll indicated
                // (2) Both the local and remote dll failed to load
                // then remove the dll from the strlst so that we don't
                // need to try it again next time.
                //
                if (  ( pnls == NULL )
                   || ((err = GetLibHandle( *pnls, &handle )) != NERR_Success )
                   )
                {
                    delete pstrlst->Remove( iterStrlst );
                    fRemoved = TRUE;
                    continue;
                }

                err = pnlsLibName->CopyFrom( *pnls );
            }

            if ( err != NERR_Success )
                break;

            err = RetrieveMessage( handle, ulEventID, pnlsDesc );

            //
            // We will try the next dll if RetrieveMessage returns
            // any error.
            //
            if ( err != NERR_Success )
            {
                // Try the next dll
                continue;
            }
            else
            {
                // Successfully retrieved a message
                break;
            }

        } while ( TRUE );
    }
    else
    {
        err = ERROR_MR_MID_NOT_FOUND;
    }

    delete pstrlstDllLocal;
    return err;
}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::MapCategoryToString

    SYNOPSIS:   Get the string associated with (source, category)

    ENTRY:      pszSource     - The given source
                usCategory    - The category to look for

    EXIT:       *pnlsCategory - Points to the retrieved category string

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::MapCategoryToString( const TCHAR *pszSource,
                                               USHORT       usCategory,
                                               NLS_STR     *pnlsCategory )
{
    BOOL fFound = FALSE;
    APIERR err = NERR_Success;

    // zero indicates no category.
    if ( usCategory == 0 )
    {
        err = pnlsCategory->Load( IDS_UI_NONE, NLS_BASE_DLL_HMOD );
    }
    else
    {
        // Get the string list of category supported by the source.
        // The first string in the list represents category 1,
        // the second string represents category 2, and so on
        STRLIST *pstrlst = NULL;
        err = GetSrcSupportedCategoryList( pszSource, &pstrlst );
        if ( (err == NERR_Success) && ( pstrlst != NULL ))
        {
            ITER_STRLIST  iterStrlst( *pstrlst );
            NLS_STR *pnls = NULL;

            for ( INT i = 1; i <= usCategory ; i++ )
            {
                pnls = iterStrlst.Next();
                if ( pnls == NULL )
                    break;
            }

            if ( pnls != NULL )
            {
                *pnlsCategory = *pnls;
                fFound = TRUE;
            }
        }

        // If we cannot find the category, then set it to the
        // default string "(usCategory)"
        if ( !fFound )
        {
            *pnlsCategory = EMPTY_STRING;
            pnlsCategory->AppendChar( OPEN_BRACKET_CHAR );
            pnlsCategory->Append( DEC_STR( usCategory ) );
            pnlsCategory->AppendChar( CLOSE_BRACKET_CHAR );
            err = pnlsCategory->QueryError();
        }
    }

    return err;
}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::SubstituteParameterID

    SYNOPSIS:   Find all language independent insertion strings in the
                description and substitute them with the appropriate
                strings.

    ENTRY:      pszSource - The given source
                pnlsDesc  - The description

    EXIT:       *pnlsDesc - The description with all languate independent
                            strings substituted

    RETURNS:    Error code

    NOTES:      All language independent insertion strings looks like
                %%number.

    HISTORY:
        Yi-HsinS        10/20/92                Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::SubstituteParameterID( const TCHAR *pszSource,
                                                 NLS_STR     *pnlsDesc )
{
    APIERR err;

    NLS_STR nlsParameter;
    if ((err = nlsParameter.QueryError()) != NERR_Success )
        return err;

    ALIAS_STR nlsPercent( TWO_PERCENT_STRING );
    INT nStart = 0;

    while ( err == NERR_Success )
    {
        TRACEEOL( nStart << ":" << *pnlsDesc );

        ISTR istrBeginOfString( *pnlsDesc );
        ISTR istrStart( *pnlsDesc );
        ISTR istrCurrent( *pnlsDesc );

        istrStart += nStart;

        if ( !pnlsDesc->strstr( &istrCurrent, nlsPercent, istrStart ) )
            break;

        // We have found "%%", so get the number after it.
        ISTR istrNext( istrCurrent );
        istrNext += nlsPercent.QueryTextLength();

        WCHAR chNext = pnlsDesc->QueryChar( istrNext );
        ULONG nID = 0;
        BOOL fDigit = FALSE;

        while ( chNext <= TCH('9') && chNext >= TCH('0') )
        {
            fDigit = TRUE;
            nID = nID * 10 + (chNext - TCH('0'));
            ++istrNext;
            chNext = pnlsDesc->QueryChar( istrNext );
        }

        // If there is no number after the "%%", start from the
        // second % position and search for the next "%%"
        if ( !fDigit )
        {
            nStart = istrNext - istrBeginOfString;
            nStart = nStart - nlsPercent.QueryTextLength() + 1;
        }
        else
        {
            // Get the string associated with nID and
            // replace the "%%nID" in the string
            err = MapParameterToString( pszSource, nID, &nlsParameter );

            if ( err != NERR_Success )
                err = nlsParameter.CopyFrom( EMPTY_STRING );

            if ( err == NERR_Success )
            {
                nStart = istrCurrent - istrBeginOfString;
                nStart += nlsParameter.QueryTextLength();

                pnlsDesc->ReplSubStr( nlsParameter, istrCurrent, istrNext );
            }
        }
    }

    return err;

}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::MapParameterToString

    SYNOPSIS:   Get the message string associated with
                ( source, nParameterMessageID )

    ENTRY:      pszSource            - The source
                nParameterMessageID  - The parameter message id

    EXIT:       pnlsMessage          - Points the to message retrieved

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        10/20/92        Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::MapParameterToString( const TCHAR *pszSource,
                                                ULONG nParameterMessageID,
                                                NLS_STR *pnlsMessage )
{
    APIERR err = NERR_Success;

    INT index = QuerySourceIndex( pszSource );
    if ( index >= 0 )
    {
        if ( (err = InitSource( index )) != NERR_Success )
            return err;

        NLS_STR * pnlsParameterDllName =
                (NLS_STR *) _paSourceInfo->QueryParameterMessageDllName( index );

        if ( pnlsParameterDllName->QueryTextLength() != 0 )
        {
            HMODULE handle = 0;
            err =  GetLibHandle( *pnlsParameterDllName, &handle );

            if (  ( handle == 0 ) // failed to load the library
               && ( _nlsServer.QueryTextLength() != 0 )
               )
            {
                // Since it fails to load, we will replace the
                // *pnlsParameterDllName with the one on the local computer
                // if everything goes well in loading the library.
                REG_KEY *pRegKey = NULL;
                err = pnlsParameterDllName->CopyFrom( EMPTY_STRING );
                err = err ? err : GetRegKeyModule( EMPTY_STRING, &pRegKey );

                if ( err == NERR_Success )
                {
                    REG_KEY regKey( *pRegKey, ALIAS_STR( pszSource), KEY_READ );

                    err = regKey.QueryError();

                    err = err ? err
                              : regKey.QueryValue( PARAMETER_FILE_KEY_NAME,
                                                     pnlsParameterDllName,
                                                     0, NULL, TRUE );

                    if ( err == NERR_Success )
                        err = GetLibHandle( *pnlsParameterDllName, &handle );
                }

                delete pRegKey;
                pRegKey = NULL;
            }

            if ( handle == 0 )
            {
                // Since it fails to load, we don't need to try it again
                // next time. Set the name to empty string.
                err = pnlsParameterDllName->CopyFrom( EMPTY_STRING );
            }
            else
            {
                err = RetrieveMessage(handle, nParameterMessageID, pnlsMessage);

                if ( err == NERR_Success )
                    return err;
            }
        }

        //
        // We will only reach this point if the given source does not
        // have a parameter message file or we have failed to load from
        // the parameter message file associated with the source.
        // Hence, we will try the primary source if it exists.
        //
        if ( PrimarySourceExist() && !IsPrimarySource(index) )
        {
            err = MapParameterToString(
                              *( _paSourceInfo->QuerySource( _iPrimarySource )),
                              nParameterMessageID,
                              pnlsMessage );
        }
    }

    return err;
}


/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::GetSrcSupportedTypeMask

    SYNOPSIS:   Get the type mask supported by the source

    ENTRY:      pszSource    - The source we are interested in

    EXIT:       *pusTypeMask - Points to the type mask
                               supported by the source

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::GetSrcSupportedTypeMask( const TCHAR *pszSource,
                                                   USHORT *pusTypeMask )
{

    *pusTypeMask = DEFAULT_TYPE_MASK;
    APIERR err = NERR_Success;

    INT index = QuerySourceIndex( pszSource );
    if ( index >= 0 )
    {
        if ( (err = InitSource( index )) != NERR_Success )
            return err;

        *pusTypeMask = _paSourceInfo->QueryTypeMask( index );
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:       LOG_REGISTRY_INFO::GetSrcSupportedCategoryList

    SYNOPSIS:   Get the list of categories supported by the source

    ENTRY:      pszSource         - The source we are interested in

    EXIT:       *ppstrlstCategory - Points to the string list of categories
                                    supported by the source

    RETURNS:    Error code

    NOTES:

    HISTORY:
        Yi-HsinS        2/25/92         Created

********************************************************************/

APIERR LOG_REGISTRY_INFO::GetSrcSupportedCategoryList( const TCHAR *pszSource,
                                                   STRLIST **ppstrlstCategory )
{
    APIERR err = NERR_Success;

    *ppstrlstCategory = NULL;

    INT index = QuerySourceIndex( pszSource );
    if ( index >= 0 )
    {
        if ( (err = InitSource( index )) != NERR_Success )
            return err;

        const NLS_STR *pnlsCategoryDllName =
                _paSourceInfo->QueryCategoryDllName( index );

        //
        // If the source does not have information in the registry about
        // the category dlls, use the category information in the primary
        // source if there is one.
        if ( pnlsCategoryDllName->QueryTextLength() == 0 )
        {
            if ( PrimarySourceExist() && !IsPrimarySource( index ) )
            {
                *ppstrlstCategory
                     = _paSourceInfo->QueryCategoryList( _iPrimarySource );
            }
        }
        else
        {
            if ( ( err = InitCategoryList( index ) ) == NERR_Success )
                *ppstrlstCategory =
                      _paSourceInfo->QueryCategoryList( index );
        }
    }

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::NT_EVENT_LOG

    SYNOPSIS:    Constructor

    ENTRY:       pszServer - The server the log file is on
                 evdir     - The direction of reading the log
                 pszModule - The module to read
                             ( System, Security, Application or backup file)
                 pszRegistryModule - The branch in registry to read
                             ( System, Security or Application )

    EXIT:

    RETURNS:

    NOTES:   If pszModule != pszRegistryModule, then we
             are trying to read a backup log file.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

NT_EVENT_LOG::NT_EVENT_LOG( const TCHAR *pszServer,
                            EVLOG_DIRECTION evdir,
                            const TCHAR *pszModule,
                            const TCHAR *pszRegistryModule )
    :  EVENT_LOG  ( pszServer, evdir, pszModule ),
       _buf       ( BIG_BUF_DEFAULT_SIZE ),
       _pEL       ( NULL ),
       _cbOffset  ( 0 ),
       _cbReturned( 0 ),
       _iStrings  ( 0 ),
       _ulRecSeek ( 0 ),
       _fBackup   ( pszModule != pszRegistryModule ),
       _logRegistryInfo( pszServer, pszRegistryModule ),
       _lsaPolicy ( pszServer ),
       _lsatnm    (),
       _lsardm    (),
       _nlsAccountDomain()
#ifdef _CAIRO_
     , _hinstanceSysmgmt(NULL)
     , _pAsGetAlertDescription(NULL)
     , _pAsGetAlertSourceName(NULL)
#endif // _CAIRO_
{
    if ( QueryError() != NERR_Success )
        return;


    LSA_ACCT_DOM_INFO_MEM lsaadim;
    APIERR err;
    if (  ((err = _buf.QueryError() ) != NERR_Success )
       || ((err = _logRegistryInfo.QueryError() ) != NERR_Success )
       || ((err = _lsaPolicy.QueryError() ) != NERR_Success )
       || ((err = _lsatnm.QueryError() ) != NERR_Success )
       || ((err = _lsardm.QueryError() ) != NERR_Success )
       || ((err = _nlsAccountDomain.QueryError() ) != NERR_Success )
       || ((err = lsaadim.QueryError() ) != NERR_Success )
       || ((err = _lsaPolicy.GetAccountDomain( &lsaadim )) != NERR_Success )
       || ((err = lsaadim.QueryName( &_nlsAccountDomain )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:        NT_EVENT_LOG::~NT_EVENT_LOG

    SYNOPSIS:    Virtual destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

NT_EVENT_LOG::~NT_EVENT_LOG()
{
    _pEL = NULL;

#ifdef _CAIRO_
    if (_hinstanceSysmgmt != NULL)
    {
        ::FreeLibrary(_hinstanceSysmgmt);
    }

    _pAsGetAlertDescription = NULL;
    _pAsGetAlertSourceName = NULL;
#endif // _CAIRO_

}

/*******************************************************************


    NAME:        NT_EVENT_LOG::QueryPos

    SYNOPSIS:    Retrieve the position of the current log entry

    ENTRY:

    EXIT:        plogEntryNum - pointer to the place to store the
                                position

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::QueryPos( LOG_ENTRY_NUMBER *plogEntryNum )
{
    UIASSERT( plogEntryNum != NULL );
    UIASSERT( _pEL != NULL );

    plogEntryNum->SetRecordNum( _pEL->RecordNumber );
    plogEntryNum->SetDirection( _evdir );
    return plogEntryNum->QueryError();
}

/*******************************************************************


    NAME:        NT_EVENT_LOG::SeekOldestLogEntry

    SYNOPSIS:    Get the oldest log entry in the log into the buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR NT_EVENT_LOG::SeekOldestLogEntry( VOID )
{
    UIASSERT( IsOpened() );

    // Get the oldest record number in the log
    ULONG ulOldestRecord;
    if ( !::GetOldestEventLogRecord( _handle, (DWORD *) &ulOldestRecord ) )
    {
        return ::GetLastError();
    }

    LOG_ENTRY_NUMBER logEntryNum( ulOldestRecord, _evdir );
    return SeekLogEntry( logEntryNum );
}

/*******************************************************************


    NAME:        NT_EVENT_LOG::SeekNewestLogEntry

    SYNOPSIS:    Get the newest log entry in the log into the buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR NT_EVENT_LOG::SeekNewestLogEntry( VOID )
{
    UIASSERT( IsOpened() );

    // Remember the original direction
    EVLOG_DIRECTION evdirOld = _evdir;

    // Set the position to read the last log entry
    APIERR err = Close();
    SetDirection( EVLOG_BACK );

    if (  ( err != NERR_Success )
       || (( err = Open() ) != NERR_Success )
       )
    {
        return err;
    }

    BOOL fContinue;
    // Don't need to worry about fContinue of I_Next because
    // we are not using it as an iterator.
    err = I_Next( &fContinue, SMALL_BUF_DEFAULT_SIZE );

    // Set the direction back to the original direction
    SetDirection( evdirOld );

    return err;
}

/*******************************************************************


    NAME:        NT_EVENT_LOG::QueryNumberOfEntries

    SYNOPSIS:    Get the number of entries in the log

    ENTRY:

    EXIT:        *pcEntries - The number of entries in the log

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR NT_EVENT_LOG::QueryNumberOfEntries( ULONG *pcEntries )
{
    UIASSERT( IsOpened() );

    if ( !::GetNumberOfEventLogRecords( _handle, (DWORD *) pcEntries ))
    {
        return ::GetLastError();
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:        NT_EVENT_LOG::I_Open

    SYNOPSIS:    Helper method that actually opens a handle
                 to the event log

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::I_Open( VOID )
{

    if ( !IsBackup() )
    {
        _handle = ::OpenEventLog( (TCHAR *) _nlsServer.QueryPch(),
                                  (TCHAR *) _nlsModule.QueryPch() );
    }
    else
    {
        _handle = ::OpenBackupEventLog( (TCHAR *) _nlsServer.QueryPch(),
                                        (TCHAR *) _nlsModule.QueryPch() );
    }

    APIERR err = _handle? NERR_Success : ( ::GetLastError() );

    // We read the registry information only after we
    // successfully opened the log for reading
    if ( err == NERR_Success )
        err = _logRegistryInfo.Init();

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::I_Close

    SYNOPSIS:    Helper method that actually closes a handle
                 to the event log

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::I_Close( VOID )
{
    if ( _handle == 0 )
    {
        return NERR_Success;
    }

    return( ::CloseEventLog( _handle ) ? NERR_Success : ( ::GetLastError()) );
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::Clear

    SYNOPSIS:    Clear the event log

    ENTRY:       pszBackupFile - optional backup file name

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::Clear( const TCHAR *pszBackupFile  )
{
    UIASSERT( IsOpened() );

    APIERR err = ( ::ClearEventLog( _handle , (TCHAR *) pszBackupFile )
                   ? NERR_Success : (::GetLastError()));

    if ( err == NERR_Success )
        Reset();

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::Backup

    SYNOPSIS:    Back up the event log without clearing the log file

    ENTRY:       pszBackupFile -  backup file name

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/7/91          Created

********************************************************************/

APIERR NT_EVENT_LOG::Backup( const TCHAR *pszBackupFile  )
{
    UIASSERT( IsOpened() );

    if ( ::BackupEventLog( _handle, (TCHAR *) pszBackupFile ) )
    {
        return NERR_Success;
    } else {
        APIERR err = ::GetLastError();
        return err;
    }
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::Reset

    SYNOPSIS:    Reset the log

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

VOID NT_EVENT_LOG::Reset( VOID )
{
    EVENT_LOG::Reset();

    _pEL        = NULL;
    _cbOffset   = 0;
    _cbReturned = 0;
    _iStrings   = 0;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::SetPos

    SYNOPSIS:    Prepare all internal variables to get the requested log
                 entry in the next read

    ENTRY:       logEntryNum -  The requested record position
                 fForceRead  -  If TRUE, we will always read from the log.
                                Else we will only read if the entry is not
                                in the buffer already
    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

VOID NT_EVENT_LOG::SetPos( const LOG_ENTRY_NUMBER &logEntryNum, BOOL fForceRead)
{

    BOOL fRead = fForceRead;   // Flag indicating whether we need to read or not

    if ( !fRead )
    {
        // Try to see if the requested log number is in the buffer already
        // Direction is not interesting in seek read under NT.
        // The record numbers are absolute numbers.
        fRead = TRUE;

        EVENTLOGRECORD *pELStart = (EVENTLOGRECORD *) _buf.QueryPtr();
        ULONG ulRecCount = pELStart->RecordNumber;

        _ulRecSeek = logEntryNum.QueryRecordNum();

        if (  (_evdir == EVLOG_FWD  && _ulRecSeek >= ulRecCount )
           || (_evdir == EVLOG_BACK && _ulRecSeek <= ulRecCount )
           )
        {
            _cbOffset = 0;
            _cCountUsers = (UINT) -1;

            while ( _cbOffset < _cbReturned )
            {

                if ( ulRecCount == _ulRecSeek )
                {
                    fRead = FALSE;
                    break;
                }
                else
                {
                    _cbOffset += pELStart->Length;
                    if (pELStart->UserSidLength != 0 )
                        _cCountUsers++;

                    pELStart = (EVENTLOGRECORD *)
                               ( (ULONG_PTR) _buf.QueryPtr() + _cbOffset );
                    ulRecCount = pELStart->RecordNumber;
                }

            }
        }
    }

    if ( fRead )
    {
        _cbOffset = _cbReturned;
        _evdir = logEntryNum.QueryDirection();
        _ulRecSeek = logEntryNum.QueryRecordNum();
    }

}

/*******************************************************************

    NAME:        NT_EVENT_LOG::I_Next

    SYNOPSIS:    Helper method that actually reads the next log
                 entry if it's not already in the buffer

    ENTRY:       ulBufferSize - Buffer size used to call the eventlog APIs

    EXIT:        *pfContinue  - TRUE if we have not reached end of log,
                                FALSE otherwise.

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::I_Next( BOOL *pfContinue, ULONG ulBufferSize )
{

    APIERR err = NERR_Success;

    _pEL = NULL;
    _iStrings = 0;

    if ( _cbOffset >= _cbReturned )
    {
        _cbOffset = 0;
        _cCountUsers = (UINT) -1;

        while (  !(  ::ReadEventLog( _handle,
                                     (
                                       ( IsSeek()? EVENTLOG_SEEK_READ :
                                                   EVENTLOG_SEQUENTIAL_READ )
                                     | ( _evdir == EVLOG_FWD ?
                                               EVENTLOG_FORWARDS_READ :
                                               EVENTLOG_BACKWARDS_READ)
                                     ),
                                     _ulRecSeek,
                                     (TCHAR FAR *) _buf.QueryPtr(),
                                     ulBufferSize,
                                     (DWORD *) &_cbReturned,
                                     (DWORD *) &_cbMinBytesNeeded
                                   ) ))
        {
            err = ::GetLastError();

            DBGEOL( SZ("NT READ Error:") << err );

            switch ( err )
            {
                case ERROR_HANDLE_EOF:
                {
                     // If we are doing seek read, we don't want
                     // to map it to success.
                     if ( IsSeek() )
                     {
                         _cbReturned = 0;
                     }
                     else
                     {
                         // Reached the end of log file
                         err = NERR_Success;
                     }
                     *pfContinue = FALSE;
                     return err;   // reached the end of log file
                }

                case ERROR_INSUFFICIENT_BUFFER:
                {
                    err = NERR_Success;
                    if ( _cbMinBytesNeeded > _buf.QuerySize() )
                    {
                        err = _buf.Resize( (UINT) _cbMinBytesNeeded );
                    }
                    ulBufferSize = _cbMinBytesNeeded;

                    // If we have successfully resize the buffer,
                    // we will try to call ReadEventLog again.
                    if ( err == NERR_Success )
                        break;
                    // else falls through
                }

                default:
                {
                    // All other errors
                    _cbReturned = 0 ;
                    *pfContinue = FALSE;
                    return err;
                }
            }
        }

        SetSeekFlag( FALSE );

        //
        // After reading successfully, translate the user name
        // in all the log entries in the buffer for later use.
        //
        UINT  cCount = 0;
        ULONG cbOffset =  0;
        EVENTLOGRECORD *p = NULL;

        // Count the number of sids
        do
        {
           p = (EVENTLOGRECORD *) ((ULONG_PTR) _buf.QueryPtr() + cbOffset) ;

           if ( p->UserSidLength != 0 )
               cCount++;

           cbOffset +=  p->Length;

        } while ( cbOffset < _cbReturned );

        if ( cCount > 0 )
        {

            PSID *ppsids = new PSID[ cCount ];

            if ( ppsids == NULL )
                return ERROR_NOT_ENOUGH_MEMORY;

            cCount = 0;
            cbOffset =  0;

            while ( cbOffset < _cbReturned )
            {
                p = (EVENTLOGRECORD *) ((ULONG_PTR) _buf.QueryPtr() + cbOffset) ;
                if ( p->UserSidLength != 0 )
                    ppsids[ cCount++ ] = (PSID) (((BYTE *) p)+p->UserSidOffset);
                cbOffset +=  p->Length;
            }

            err = _lsaPolicy.TranslateSidsToNames( ppsids, cCount,
                                                   &_lsatnm, &_lsardm );
            delete [ cCount ] ppsids;
        }

        if ( err != NERR_Success )
            return err;

        DBGEOL( SZ("NT EVENT RETURNED:") << _cbReturned );
    }

    _pEL = (EVENTLOGRECORD *) ( (ULONG_PTR) _buf.QueryPtr() + _cbOffset) ;
    if ( _pEL->UserSidLength != 0 )
        _cCountUsers++;

    if ( _cbReturned - _cbOffset < _pEL->Length )
    {
        // Report the same error that NET CMD does (cf. AUDERR.C)
        _cbOffset = _cbReturned ;
        *pfContinue = FALSE;
        return IDS_UI_LOG_RECORD_CORRUPT;
    }

    _cbOffset +=  _pEL->Length;
    *pfContinue = TRUE;
    return NERR_Success;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::NextString

    SYNOPSIS:    Return the next string associated with current
                 log entry

    ENTRY:

    EXIT:        pfContinue   - pointer to a BOOL which is TRUE
                                if there are more strings to read

                 *ppnlsString - pointer to string returned


    RETURNS:     APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::NextString( BOOL *pfContinue, NLS_STR **ppnlsString )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    _iStrings++;
    if ( _iStrings > (UINT) _pEL->NumStrings )
    {
        *pfContinue = FALSE;
        return NERR_Success;
    }

    BYTE *pszStr = ((BYTE *) _pEL) + _pEL->StringOffset;
    BYTE *pszEnd = ((BYTE *) _pEL) + _pEL->DataOffset ;

    for ( UINT i = 1; i < _iStrings; i++ )
    {
         pszStr += (::strlenf( (TCHAR *) pszStr ) + 1 ) * sizeof( TCHAR );
         if ( pszStr >= pszEnd )
         {
             *pfContinue = FALSE;
             return IDS_UI_LOG_RECORD_CORRUPT;
         }
     }

    *ppnlsString = new NLS_STR( (TCHAR *) pszStr );

    APIERR err = ( *ppnlsString? (*ppnlsString)->QueryError()
                               : (APIERR) ERROR_NOT_ENOUGH_MEMORY );

    if ( err != NERR_Success )
    {
        delete *ppnlsString;
        *ppnlsString = NULL;
        *pfContinue = FALSE;
        return err;
    }

    *pfContinue = TRUE;
    return NERR_Success;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::GetProcAddressOfAlertFuctions

    SYNOPSIS:    Helper function to the GetProcAddress of the Cairo
                 Alert functions "AsGetAlertDescription" &
                 "AsGetAlertSourceName"

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        RaviR        02/27/95        Created

********************************************************************/

APIERR NT_EVENT_LOG::GetProcAddressOfAlertFuctions( VOID )
{
#ifdef _CAIRO_

    //
    //  We don't statically link to sysmgmt.dll because we don't want
    //  to add to the size of netui1.dll.
    //
    if (_hinstanceSysmgmt == NULL)
    {
        _hinstanceSysmgmt = ::LoadLibrary( MODULE_CONTAINING_ALERTFUNCTIONS );
        if (_hinstanceSysmgmt == NULL)
        {
            return ::GetLastError();
        }

    }

    //
    //  Get the address of AsGetAlertDescription() function.
    //
    //  The AsGetAlertDescription routine retrieves the desciption
    //  associated with a Cairo Alert.
    //
    if (_pAsGetAlertDescription == NULL)
    {
        _pAsGetAlertDescription =
            (PASGETALERTDESCRIPTION)GetProcAddress( (HMODULE)_hinstanceSysmgmt,
                                                    "AsGetAlertDescription");

        if (_pAsGetAlertDescription == NULL)
        {
            return ::GetLastError();
        }
    }

    //
    //  Get the address of AsGetAlertSourceName() function.
    //
    //  The AsGetAlertSourceName routine retrieves the source name
    //  associated with a Cairo Alert.
    //
    if (_pAsGetAlertSourceName == NULL)
    {
        _pAsGetAlertSourceName =
            (PASGETALERTSOURCENAME)GetProcAddress( (HMODULE)_hinstanceSysmgmt,
                                                   "AsGetAlertSourceName");
        if (_pAsGetAlertSourceName == NULL)
        {
            return ::GetLastError();
        }
    }

#endif // _CAIRO_

    return NERR_Success;
}


/*******************************************************************

    NAME:        NT_EVENT_LOG::QueryCurrentEntryDesc

    SYNOPSIS:    Helper function for constructing the Description
                 for the given log entry

    ENTRY:

    EXIT:        *pnlsDesc - Contains the resulting description

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::QueryCurrentEntryDesc( NLS_STR *pnlsDesc )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );
    UIASSERT( pnlsDesc != NULL );

    APIERR err = NERR_Success;

    if ( (err = pnlsDesc->CopyFrom( EMPTY_STRING )) != NERR_Success )
        return err;

    TCHAR *pszSource = (TCHAR *) ( ((BYTE *) _pEL) + sizeof (*_pEL));


#ifdef _CAIRO_

    //
    //  The given log entry is a Cairo Alert, if the source name for
    //  this event in the event log is "AS".
    //

    if (::strcmpf(pszSource, SZ("AS")) == 0)
    {
        //
        //  Get the address of AsGetAlertDescription() function.
        //
        //  The AsGetAlertDescription routine retrieves the desciption
        //  associated with a Cairo Alert.
        //

        if (_pAsGetAlertDescription == NULL)
        {
            err = GetProcAddressOfAlertFuctions();
        }

        //
        //  Call the Alert system supplied API AsGetAlertDescription
        //  to get the description.
        //

        if (err == NERR_Success)
        {
            LPBYTE pData = NULL;
            LPWSTR pszDescr = NULL;

            ULONG  cbDataLength = this->QueryCurrentEntryData(&pData);

            LONG hresult = _pAsGetAlertDescription(
                            cbDataLength, pData, &pszDescr);

            err = WIN32_FROM_HRESULT(hresult);

            if (err == NERR_Success)
            {
                err = pnlsDesc->CopyFrom(pszDescr);

                ::LocalFree(pszDescr);
            }
        }

        if (err != NERR_Success)
        {
            // reset err to ERROR_MR_MID_NOT_FOUND so that behaviour
            // is exactly the same as for Daytona.
            err = ERROR_MR_MID_NOT_FOUND;
        }
    }
    else
    {
#endif // _CAIRO_

        err = _logRegistryInfo.MapEventIDToString( pszSource,
                                                   _pEL->EventID,
                                                   pnlsDesc );
#ifdef _CAIRO_
    }
#endif // _CAIRO_

    // Start reading from the first string again.
    // Reset the string enumerator
    _iStrings = 0;

    if ( err == ERROR_MR_MID_NOT_FOUND )
    {
        // We couldn't find the description for the event id,
        // so just use the default description with the strings
        // contained in the entry.

        pnlsDesc->Load( IDS_UI_DEFAULT_DESC, NLS_BASE_DLL_HMOD );

        // Get rid of the first 16 bits of NTSTATUS
        pnlsDesc->InsertParams( pszSource,
                                DEC_STR( _pEL->EventID & 0x0000FFFF));

        if ( (err = pnlsDesc->QueryError()) == NERR_Success )
        {

            BOOL fContinue;
            NLS_STR *pnlsTemp = NULL;
            for ( INT i = 0; i < _pEL->NumStrings; i++ )
            {
                 if ( i != 0 )
                     err = pnlsDesc->Append( COMMA_STRING );

                 if (  ( err != NERR_Success )
                    || ( (err = NextString( &fContinue, &pnlsTemp ))
                         != NERR_Success )
                    || ( (err = pnlsDesc->Append( *pnlsTemp )) != NERR_Success)
                    || ( !fContinue )
                    )
                 {
                     break;
                 }
                 delete pnlsTemp;
                 pnlsTemp = NULL;
            }

            delete pnlsTemp;
            pnlsTemp = NULL;
            err = err? err : pnlsDesc->AppendChar( PERIOD_CHAR );
        }
    }
    else if ( ( pnlsDesc->QueryTextLength() > 0) && ( err == NERR_Success))
    {

        // We have found the description, so insert the strings into
        // the description.

        if ( _pEL->NumStrings != 0 )
        {
            NLS_STR *apnlsParams[ MAX_INSERT_PARAMS + 1 ];
            apnlsParams[0] = NULL;

            NLS_STR *pnlsTemp;
            BOOL fContinue;

            if ( _pEL->NumStrings > MAX_INSERT_PARAMS )
                _pEL->NumStrings = MAX_INSERT_PARAMS;

            BOOL fInsert = FALSE;
            for ( INT i = 0; i < _pEL->NumStrings; i++ )
            {
                 if ( (err = NextString( &fContinue, &pnlsTemp ))
                     != NERR_Success )
                     break;

                 if ( !fContinue )
                     break;

                 fInsert = TRUE;
                 apnlsParams[i] = pnlsTemp;
            }

            apnlsParams[i] = NULL;

            if ( ( err == NERR_Success ) && fInsert )
            {
                err = pnlsDesc->InsertParams( (const NLS_STR * *) apnlsParams );
            }

            // Do some clean up!
            for ( i = 0; apnlsParams[i] != NULL; i++ )
                 delete apnlsParams[i];

            // Check and substitute all language independent insertion strings
            err = err? err : _logRegistryInfo.SubstituteParameterID( pszSource,
                                                                     pnlsDesc );

        }

    }

    return err;

}



/*******************************************************************

    NAME:        NT_EVENT_LOG::QueryCurrentEntryData

    SYNOPSIS:    Get the raw data of the current log entry

    ENTRY:

    EXIT:        *ppbData - Points to the raw data retrieved

    RETURNS:     The number of bytes the raw data contains

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

ULONG NT_EVENT_LOG::QueryCurrentEntryData( BYTE **ppDataOut )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    ULONG uiRawDataLen = _pEL->DataLength;
    if ( uiRawDataLen != 0 )
        *ppDataOut = ( BYTE *) _pEL + _pEL->DataOffset;

    return _pEL->DataLength;

}

/*******************************************************************

    NAME:        NT_EVENT_LOG::QueryCurrentEntryTime

    SYNOPSIS:    Get the time of the current log entry

    ENTRY:

    EXIT:

    RETURNS:     Return the time in ULONG

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

ULONG NT_EVENT_LOG::QueryCurrentEntryTime( VOID )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    return _pEL->TimeWritten;
}

/*******************************************************************

    NAME:           NT_EVENT_LOG::QueryCurrentEntryCategory

    SYNOPSIS:       Get the category of the current log entry

    ENTRY:

    EXIT:           *pnlsCategory - The category string

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::QueryCurrentEntryCategory( NLS_STR *pnlsCategory )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );
    UIASSERT( pnlsCategory != NULL );

    TCHAR *pszSource = (TCHAR *) ( ((BYTE *) _pEL) + sizeof (*_pEL));

    APIERR err  = _logRegistryInfo.MapCategoryToString( pszSource,
                                                        _pEL->EventCategory,
                                                        pnlsCategory );

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::QueryCurrentEntryTypeString

    SYNOPSIS:    Get the type string of the type of the current entry

    ENTRY:

    EXIT:        pnlsType - The type string

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/8/92        Created

********************************************************************/

struct LogTypeEntry {
USHORT usType;
MSGID  msgidType;
} LogTypeTable[] = { { EVENTLOG_SUCCESS,          IDS_UI_NONE },
                     { EVENTLOG_ERROR_TYPE,       IDS_UI_ERROR },
                     { EVENTLOG_WARNING_TYPE,     IDS_UI_WARNING },
                     { EVENTLOG_INFORMATION_TYPE, IDS_UI_INFORMATION },
                     { EVENTLOG_AUDIT_SUCCESS,    IDS_UI_AUDIT_SUCCESS },
                     { EVENTLOG_AUDIT_FAILURE,    IDS_UI_AUDIT_FAILURE }
                   };

#define TYPE_TABLE_SIZE ( sizeof( LogTypeTable)/sizeof( struct LogTypeEntry))

APIERR NT_EVENT_LOG::QueryCurrentEntryTypeString( NLS_STR *pnlsType )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );
    UIASSERT( pnlsType != NULL );

    USHORT usType = _pEL->EventType;

    for ( UINT i = 0; i < TYPE_TABLE_SIZE; i++ )
    {
        if ( usType == LogTypeTable[i].usType )
        {
            return pnlsType->Load( LogTypeTable[i].msgidType, NLS_BASE_DLL_HMOD );
        }
    }

    return pnlsType->Load( IDS_UI_NA, NLS_BASE_DLL_HMOD );
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::QueryCurrentEntryUser

    SYNOPSIS:    Get the user name contained in the current log entry

    ENTRY:

    EXIT:        pnlsUser - The name of the user

    RETURNS:

    NOTES:       If there is no SID in the current log entry,
                 then a default string will be returned

    HISTORY:
        Yi-HsinS        4/8/92        Created

********************************************************************/

APIERR NT_EVENT_LOG::QueryCurrentEntryUser( NLS_STR *pnlsUser )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );
    UIASSERT( pnlsUser != NULL );

    APIERR err = NERR_Success;

    *pnlsUser = EMPTY_STRING;

    if ( _pEL->UserSidLength != 0 )
    {
        LONG nDomainIndex = _lsatnm.QueryDomainIndex( _cCountUsers );

        //
        // We'll just use the user name if the domain cannot be found.
        //
        if ( nDomainIndex < 0 )
        {
            err = _lsatnm.QueryName( _cCountUsers, pnlsUser );
        }
        else
        {
            switch ( _lsatnm.QueryUse( _cCountUsers ) )
            {
                case SidTypeDeletedAccount:
                case SidTypeUnknown:
                case SidTypeInvalid:
                    err = _lsatnm.QueryName( _cCountUsers, pnlsUser );
                    break;

                default:
                    // See if we need to append the domain name
                    if ((err = _lsardm.QueryName( nDomainIndex, pnlsUser ))
                        == NERR_Success )
                    {
                        if ( pnlsUser->_stricmp( _nlsAccountDomain ) == 0 )
                            err = pnlsUser->CopyFrom( EMPTY_STRING );
                        else if ( pnlsUser->QueryTextLength() != 0 )
                            err = pnlsUser->AppendChar( QUALIFIED_ACCOUNT_SEPARATOR );
                    }

                    // Append the user name
                    if ( err == NERR_Success )
                    {
                        NLS_STR nlsUser;
                        if (  ((err = nlsUser.QueryError()) == NERR_Success)
                           && ((err = _lsatnm.QueryName( _cCountUsers,&nlsUser))
                               == NERR_Success )
                           )
                        {
                            err = pnlsUser->Append( nlsUser );
                        }
                    }
                    break;
            }
        }
    }
    else
    {
        // Load the default string
        err = pnlsUser->Load( IDS_UI_NA, NLS_BASE_DLL_HMOD );
    }

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::CreateCurrentFormatEntry

    SYNOPSIS:    Helper function for constructing the  FORMATTED_LOG_ENTRY
                 to be displayed

    ENTRY:

    EXIT:        *ppFmtLogEntry - Points the newly constructed
                                  FORMATTED_LOG_ENTRY

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::CreateCurrentFormatEntry( FORMATTED_LOG_ENTRY **ppFmtLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    APIERR err = NERR_Success;

    // Get the source name and the computer name
    TCHAR *pszSource   = (TCHAR *) ( ((BYTE *) _pEL) + sizeof (*_pEL));
    TCHAR *pszComputer = pszSource + ( ::strlenf( pszSource ) + 1);

    NLS_STR nlsUser;
    NLS_STR nlsType;
    NLS_STR nlsCategory;
    if (  ((err = nlsUser.QueryError()) == NERR_Success )
       && ((err = QueryCurrentEntryUser( &nlsUser )) == NERR_Success )
       && ((err = nlsCategory.QueryError()) == NERR_Success )
       && ((err = QueryCurrentEntryCategory( &nlsCategory)) == NERR_Success )
       && ((err = nlsType.QueryError()) == NERR_Success )
       && ((err = QueryCurrentEntryTypeString( &nlsType )) == NERR_Success )
       )
    {

#ifdef _CAIRO_

        //
        //  The given log entry is a Cairo Alert, if the source name for
        //  this event in the event log is "AS".
        //

        LPWSTR pszSrcName = NULL;

        if (::strcmpf(pszSource, SZ("AS")) == 0)
        {
            //
            //  Get the address of AsGetAlertSourceName() function.
            //
            //  The AsGetAlertSourceName routine retrieves the source name
            //  associated with a Cairo Alert.
            //

            if (_pAsGetAlertSourceName == NULL)
            {
                err = GetProcAddressOfAlertFuctions();
            }

            //
            //  Call the Alert system supplied API AsGetAlertSourceName
            //  to get the source name associated with a Cairo.
            //

            if (err == NERR_Success)
            {
                LPBYTE pData = NULL;

                ULONG  cbDataLength = this->QueryCurrentEntryData(&pData);


                LONG hresult = _pAsGetAlertSourceName(
                                                cbDataLength,
                                                pData,
                                                &pszSrcName );

                err = WIN32_FROM_HRESULT(hresult);

                if (err != NERR_Success)
                {
                    //pszSrcName = NULL;
                    pszSrcName = L"Unknown";
                }
            }
        }

#endif // _CAIRO_

        *ppFmtLogEntry = new FORMATTED_LOG_ENTRY( _pEL->RecordNumber,
                                                  _pEL->TimeWritten,
                                                  _pEL->EventType,
                                                  nlsType,
                                                  nlsCategory,
                                                  _pEL->EventID,
#ifdef _CAIRO_  // is cairo
                           (pszSrcName != NULL) ? pszSrcName : pszSource,
#else  // not cairo
                                                  pszSource,
#endif
                                                  nlsUser,
                                                  pszComputer,
                                                  NULL, // delayed until needed
                                                  this );

#ifdef _CAIRO_
        if (pszSrcName != NULL)
        {
            ::LocalFree(pszSrcName);
        }
#endif // _CAIRO_

        err = ( ( *ppFmtLogEntry == NULL )
                ? (APIERR) ERROR_NOT_ENOUGH_MEMORY
                : (*ppFmtLogEntry)->QueryError());

        if ( err != NERR_Success )
        {
            delete *ppFmtLogEntry;
            *ppFmtLogEntry = NULL;
        }
    }

    return err;

}

/*******************************************************************

    NAME:           NT_EVENT_LOG::CreateCurrentRawEntry

    SYNOPSIS:       Helper function for constructing the RAW_LOG_ENTRY
                    to be used mainly when filtering the log
    ENTRY:

    EXIT:           pRawLogEntry - Points to the raw log entry that
                                   contains the information about the
                                   current entry

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR NT_EVENT_LOG::CreateCurrentRawEntry( RAW_LOG_ENTRY *pRawLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    APIERR err = NERR_Success;

    // Get the source name and computer name
    TCHAR *pszSource   = (TCHAR *) ( ((BYTE *) _pEL) + sizeof (*_pEL));
    TCHAR *pszComputer = pszSource + ( ::strlenf( pszSource ) + 1);

    NLS_STR nlsCategory;
    NLS_STR nlsUser;
    if (  ((err = nlsUser.QueryError()) == NERR_Success )
       && ((err = QueryCurrentEntryUser( &nlsUser )) == NERR_Success )
       && ((err = nlsCategory.QueryError()) == NERR_Success )
       && ((err = QueryCurrentEntryCategory( &nlsCategory)) == NERR_Success )
       )
    {

        err = pRawLogEntry->Set( _pEL->RecordNumber,
                                 _pEL->TimeWritten,
                                 _pEL->EventType,
                                 nlsCategory,
                                 _pEL->EventID,
                                 pszSource,
                                 nlsUser,
                                 pszComputer,
                                 this
                               );
    }

    return err;
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::WriteTextEntry

    SYNOPSIS:    Write the specified log entry to a file as normal text

    ENTRY:       ulFileHandle - file handle
                 intlprof     - international profile information
                 chSeparator  - character to separate the different info
                                in each entry

    EXIT:

    RETURNS:     APIERR - in case of error occurs

    HISTORY:
        terryk          20-Dec-1991     Created
        Yi-HsinS        4-Feb-1992      Added chSeparator
        beng            05-Mar-1992     Remove wsprintf call
        JonN            6/22/00         WriteTextEntry no longer supported

********************************************************************/

APIERR NT_EVENT_LOG::WriteTextEntry( ULONG         ulFileHandle,
                                     INTL_PROFILE &intlprof,
                                     TCHAR         chSeparator )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
/*
    UIASSERT( IsOpened() );
    UIASSERT( _pEL != NULL );

    APIERR err = NERR_Success;

    FORMATTED_LOG_ENTRY * pfle;
    if ( ( err  = CreateCurrentFormatEntry( & pfle )) != NERR_Success )
    {
        return err;
    }

    UIASSERT( pfle != NULL );

    NLS_STR nlsStr;   // Initialize to empty string
    NLS_STR nlsTime;
    NLS_STR nlsDate;

    if ((( err = nlsStr.QueryError()) != NERR_Success )  ||
        (( err = nlsTime.QueryError()) != NERR_Success ) ||
        (( err = nlsDate.QueryError()) != NERR_Success ))
    {
        return err;
    }

    WIN_TIME winTime( pfle->QueryTime() );

    if (  (( err = winTime.QueryError()) != NERR_Success)
       || (( err = intlprof.QueryTimeString(winTime, &nlsTime)) != NERR_Success)
       || (( err = intlprof.QueryShortDateString( winTime, &nlsDate ))
           != NERR_Success )
       )
    {
        return err;
    }

    nlsStr.strcat( nlsDate );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( nlsTime );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QuerySource()) );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryTypeString()) );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryCategory()) );
    nlsStr.AppendChar( chSeparator );

    DEC_STR nlsID( pfle->QueryDisplayEventID() ); // ctor check deferred

    nlsStr.strcat( nlsID );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryUser()) );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryComputer()) );
    nlsStr.AppendChar( chSeparator );

    NLS_STR *pnls = pfle->QueryDescription();

    if ( pnls->QueryTextLength() == 0 )
    {
        NLS_STR nlsDesc;

        err = nlsDesc.QueryError()? nlsDesc.QueryError()
                                  : QueryCurrentEntryDesc( &nlsDesc );
        nlsStr.strcat( nlsDesc );
    }
    else
    {
        nlsStr.strcat( *pnls );
    }

    nlsStr.strcat( ALIAS_STR( END_OF_LINE) );

    delete pfle;
    pfle = NULL;

    if ((err = nlsStr.QueryError()) != NERR_Success )
        return err;

    BUFFER buf((nlsStr.QueryTextLength() + 1) * sizeof(WORD));
    if (  ((err = buf.QueryError()) != NERR_Success )
       || ((err = nlsStr.MapCopyTo( (CHAR *) buf.QueryPtr(), buf.QuerySize()))
           != NERR_Success )
       )
    {
        return err;
    }

    return ::FileWriteLineAnsi( ulFileHandle, (CHAR *) buf.QueryPtr(),
                               ::strlen((CONST CHAR *)buf.QueryPtr()) ); // don't need to copy '\0'
*/
}

/*******************************************************************

    NAME:           NT_EVENT_LOG::QuerySrcSupportedTypeMask

    SYNOPSIS:       Query the type mask supported by the source

    ENTRY:          nlsSource    - The source name

    EXIT:           *pusTypeMask - The type mask supported by the source

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/9/92       Created

********************************************************************/

APIERR NT_EVENT_LOG::QuerySrcSupportedTypeMask( const NLS_STR &nlsSource,
                                                USHORT        *pusTypeMask )
{
    return _logRegistryInfo.GetSrcSupportedTypeMask( nlsSource, pusTypeMask );
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::QuerySrcSupportedCategoryList

    SYNOPSIS:    Query the category list supported by the source

    ENTRY:       nlsSource          - The source name

    EXIT:        *ppstrCategoryList - Points to a string list of categories
                                      supported by the source

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/9/92       Created

********************************************************************/

APIERR NT_EVENT_LOG::QuerySrcSupportedCategoryList( const NLS_STR &nlsSource,
                                                    STRLIST **ppstrlstCategory )
{
    return  _logRegistryInfo.GetSrcSupportedCategoryList( nlsSource,
                                                          ppstrlstCategory );
}

/*******************************************************************

    NAME:        NT_EVENT_LOG::QuerySourceList

    SYNOPSIS:    Query the sources supported in the current module

    ENTRY:

    EXIT:

    RETURNS:     Returns the string list containing all sources in
                 the current module

    NOTES:

    HISTORY:
        Yi-HsinS        3/9/92       Created

********************************************************************/

STRLIST *NT_EVENT_LOG::QuerySourceList( VOID )
{
    return  _logRegistryInfo.GetSourceList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\service\lmoserv.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmoserv.hxx
    LM_SERVICE class definition


    FILE HISTORY:
	rustanl     03-Jun-1991     Created

*/


#define INCL_OS2
#define INCL_DOSERRORS
#define INCL_DOSSIGNALS
#define INCL_DOSPROCESS
#define INCL_DOSFILEMGR
#define INCL_NETERRORS
#include <lmui.hxx>

extern "C" 
{
    #include <netcons.h>
    #include <service.h>
    #include <errlog.h>

    #include <netlib.h>

}

#include <uiassert.hxx>
#include <uitrace.hxx>

#include "lmoserv.hxx"




LM_SERVICE * LM_SERVICE::_pservThis = NULL;


/*******************************************************************

    NAME:	LM_SERVICE::LM_SERVICE

    SYNOPSIS:	LM_SERVICE constructor

    ENTRY:	pszName -	Pointer to name of service (see notes below)

    NOTES:
	BUGBUG.  The name of the service is currently not used anywhere.

    HISTORY:
	rustanl     03-Jun-1991     Created

********************************************************************/

LM_SERVICE::LM_SERVICE( const TCHAR * pszName )
    :	BASE(),
	_nlsName( pszName ),
	_fSigStarted( FALSE ),
	_usStatus( SERVICE_UNINSTALLED |
		   SERVICE_NOT_UNINSTALLABLE |
		   SERVICE_NOT_PAUSABLE ),
	_pid( NULL )
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsName.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    PIDINFO pidinfo;
    err = DosGetPID( &pidinfo );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("DosGetPID failed from LM_SERVICE constructor\r\n") );
	ReportError( err );
	return;
    }
    _pid = pidinfo.pid;

    if ( _pservThis != NULL )
    {
	UIDEBUG( SZ("At most one LM_SERIVCE object can exist at one time\r\n") );
	ReportError( ERROR_GEN_FAILURE );
	return;
    }
    _pservThis = this;

}  // LM_SERVICE::LM_SERVICE


/*******************************************************************

    NAME:	LM_SERVICE::~LM_SERVICE

    SYNOPSIS:	LM_SERVICE destructor

    NOTES:
	BUGBUG.  If Start is ever successfully called on a LM_SERVICE
	object, the destructor won't actually ever get called.

    HISTORY:
	rustanl     03-Jun-1991     Created

********************************************************************/

LM_SERVICE::~LM_SERVICE()
{
    _pservThis = NULL;

}  // LM_SERVICE:


/*******************************************************************

    NAME:	LM_SERVICE::Serve

    SYNOPSIS:	This method starts the service

    RETURNS:	An API error code indicating the success of starting
		the service.  It is NERR_Success on success.

    HISTORY:
	rustanl     03-Jun-1991     Created

********************************************************************/

APIERR LM_SERVICE::Serve( void )
{
    /*	Set status to 'install pending' */

    APIERR err = SetStatus( SERVICE_INSTALL_PENDING |
			    SERVICE_NOT_UNINSTALLABLE |
			    SERVICE_NOT_PAUSABLE );
    if ( err != NERR_Success )
	return err;


    /*	Install signal handler	*/

    PFNSIGHANDLER pnPrevHandler;
    USHORT fsPrevAction;
    err = DosSetSigHandler( LmoSignalHandler,
			    &pnPrevHandler,
			    &fsPrevAction,
			    SIGA_ACCEPT,
			    SERVICE_RCV_SIG_FLAG );
    if ( err != NERR_Success )
	return err;

    _fSigStarted = TRUE;

    err = SetStatus( SERVICE_INSTALL_PENDING |
		     SERVICE_UNINSTALLABLE |
		     SERVICE_PAUSABLE );
    if ( err != NERR_Success )
    {
	//  BUGBUG.  Does anything need to be unwound at this time?
	return err;
    }


    /*	Set the interrupt handlers */

    err = SetInterruptHandlers();
    if ( err != NERR_Success )
	return err;


    /*	Close out the standard file handles  */

    err = CloseFileHandles();
    if ( err != NERR_Success )
	return err;


    /*	Install the service specific components */

    err = OnInstall();
    if ( err != NERR_Success )
    {
	//  BUGBUG.  Anything that needs to be unwound here first?
	return err;
    }


    /*	Notify LAN Manager that the service is installed  */

    err = SetStatus( SERVICE_INSTALLED |
		     SERVICE_UNINSTALLABLE |
		     SERVICE_PAUSABLE );
    if ( err != NERR_Success )
    {
	//  BUGBUG.  Anything that needs to be unwound here first?
	return err;
    }

    return WaitForever();

}  // LM_SERVICE::Serve


/*******************************************************************

    NAME:	LM_SERVICE::SetInterruptHandlers

    SYNOPSIS:	Sets the interrupt handlers (such as ctrl-C)

    RETURNS:	An API return code, which is NERR_Success on success

    HISTORY:
	rustanl     09-Jun-1991     Created from LM_SERVICE::Start

********************************************************************/

APIERR LM_SERVICE::SetInterruptHandlers( void )
{
    /*	Ignore Ctrl-C, BREAK signal, KILL signal.  Flags B and C
     *	should cause errors.
     */

    PFNSIGHANDLER pnPrevHandler;
    USHORT fsPrevAction;
    APIERR err;
    if ( ( err = DosSetSigHandler( NULL,
				   &pnPrevHandler,
				   &fsPrevAction,
				   SIGA_IGNORE,
				   SIG_CTRLC )) 	!= NERR_Success ||
	 ( err = DosSetSigHandler( NULL,
				   &pnPrevHandler,
				   &fsPrevAction,
				   SIGA_IGNORE,
				   SIG_CTRLBREAK ))	!= NERR_Success ||
	 ( err = DosSetSigHandler( NULL,
				   &pnPrevHandler,
				   &fsPrevAction,
				   SIGA_IGNORE,
				   SIG_KILLPROCESS ))	!= NERR_Success ||
	 ( err = DosSetSigHandler( NULL,
				   &pnPrevHandler,
				   &fsPrevAction,
				   SIGA_IGNORE,
				   SIG_PFLG_B ))   != NERR_Success ||
	 ( err = DosSetSigHandler( NULL,
				   &pnPrevHandler,
				   &fsPrevAction,
				   SIGA_IGNORE,
				   SIG_PFLG_C ))   != NERR_Success )
    {
	//  fall through
    }

    return err;

}  // LM_SERVICE::SetInterruptHandlers


/*******************************************************************

    NAME:	LM_SERVICE::CloseFileHandles

    SYNOPSIS:	Redirects stdin, stdout, and stderr to the NULL device.

    RETURNS:	An API error code, which is NERR_Success on success.

    NOTES:	This function is taken virtually verbatim from the
		LAN Manager 2.0 Programmer's Reference.

    HISTORY:
	rustanl     03-Jun-1991     Created from the LM Prog Ref

********************************************************************/

APIERR LM_SERVICE::CloseFileHandles( void )
{
    USHORT usAction;
    HFILE hFileNul;
    APIERR err = DosOpen( SZ("NUL"),
			  &hFileNul,
			  &usAction,
			  0L,
			  FILE_NORMAL,
			  FILE_OPEN,
			  OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYNONE,
			  0L );
    if ( err != NERR_Success )
	return err;

    //	Reroute stdin, stderr, and stderr to NUL

    for ( HFILE hNewHandle = 0;
	  hNewHandle < 3 && err == NERR_Success;
	  hNewHandle++ )
    {
	//  Skip the duplicating operation if the handle already points
	//  to NUL.  This is what the LAN Man Prog Ref example does.
	//  BUGBUG.  Is it not a really bad idea to pass the address of
	//  hNewHandle to DosDupHandle, since that variable controls
	//  the termination of this loop.
	if ( hFileNul != hNewHandle )
	    err = DosDupHandle( hFileNul, &hNewHandle );
    }

    if ( hFileNul > 2 )
    {
	REQUIRE( DosClose( hFileNul ) == NERR_Success );
    }

    return NERR_Success;

}  // LM_SERVICE::CloseFileHandles


/*******************************************************************

    NAME:	LM_SERVICE::WaitForever

    SYNOPSIS:	Waits indefinitely on a dummy semaphore

    EXIT:	This method never exits under normal circumstances

    RETURNS:	Normally doesn't return at all.  If an error occurs,
		this function returns with an API return code.

    HISTORY:
	rustanl     03-Jun-1991     Created

********************************************************************/

APIERR LM_SERVICE::WaitForever( void )
{
    ULONG hSemDummy = 0L;

    APIERR err = DosSemSet( &hSemDummy );
    if ( err != NERR_Success )
	return err;

    do
    {
	err = DosSemWait( &hSemDummy, SEM_INDEFINITE_WAIT );
    }
    while ( err == ERROR_INTERRUPT );

    return err;

}  // LM_SERVICE::WaitForever


/*******************************************************************

    NAME:	LM_SERVICE::SetStatusAux

    SYNOPSIS:	Notifies LAN Man of the status of the service using
		the given status

    ENTRY:	usStatus -	    Status to report to LAN Man

    RETURNS:	An API error code, which is NERR_Success on success

    HISTORY:
	rustanl     09-Jun-1991     Created from old LM_SERVICE::SetStatus

********************************************************************/

APIERR LM_SERVICE::SetStatusAux( USHORT usStatus )
{
    service_status ss;
    ss.svcs_status = usStatus;
    ss.svcs_code = SERVICE_UIC_NORMAL;
    ss.svcs_pid = _pid;
    ss.svcs_text[ 0 ] = TCH('\0');

    APIERR err = NetServiceStatus( (char *)&ss, sizeof( ss ));
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("LM_SERVICE::SetStatusAux failed calling Net API\r\n") );
    }
    return err;

}  // LM_SERVICE::SetStatusAux


/*******************************************************************

    NAME:	LM_SERVICE::SetStatus

    SYNOPSIS:	Sets the status of the service, and notifies LAN Man
		of that status

    ENTRY:	usStatus -	    The new status of the service

    RETURNS:	An API error code, which is NERR_Success on success

    HISTORY:
	rustanl     04-Jun-1991     Created

********************************************************************/

APIERR LM_SERVICE::SetStatus( USHORT usStatus )
{
    _usStatus = usStatus;
    return SetStatusAux( _usStatus );

}  // LM_SERVICE::SetStatus


/*******************************************************************

    NAME:	LM_SERVICE::ReportCurrentStatus

    SYNOPSIS:	Notifies LAN Man of the current status of the service

    RETURNS:	An API error code, which is NERR_Success on success

    NOTES:
	BUGBUG.  What can the caller to do if this call fails?

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APIERR LM_SERVICE::ReportCurrentStatus( void )
{
    return SetStatusAux( _usStatus );

}  // LM_SERVICE::ReportCurrentStatus


/*******************************************************************

    NAME:	LmoSignalHandler

    SYNOPSIS:	This is the service signal handler.  It calls the
		SignalHandler method for the object

    ENTRY:	usSigArg and usSigNum -     As defined by OS/2

    RETURNS:	Nothing

    NOTES:
	Unfortunately, the OS/2 signal handler parameters don't
	allow for any unique identification.  If it did, then a
	pointer to the corresponding LM_SERVICE object would be found
	using some mapping from that unique identification.  But
	since this is not the case, the global LM_SERVICE::_pservThis
	is used instead.  This adds the limitation that there must
	be exactly one LM_SERVICE object at the time this method is
	called, and there must never be more than one LM_SERVICE
	object per application.  This is normally not much of a
	problem for LAN Man services.

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void /* FAR PASCAL */ LmoSignalHandler( USHORT usSigArg,
					USHORT usSigNum  )
{
    if ( LM_SERVICE::_pservThis != NULL )
	LM_SERVICE::_pservThis->SignalHandler( usSigArg, usSigNum  );

}  // LmoSignalHandler


/*******************************************************************

    NAME:	LM_SERVICE::SignalHandler

    SYNOPSIS:	This method processes incoming signals and dispatches
		them to the appropriate virtuals

    ENTRY:	usSigArg, usSigNum -	As defined by OS/2

    RETURNS:	Nothing

    HISTORY:
	rustanl     03-Jun-1991     Created from LAN Man 2.0 Prog Ref
				    example

********************************************************************/

void LM_SERVICE::SignalHandler( USHORT usSigArg, USHORT usSigNum  )
{
    //	Compute the function code
    BYTE bOpCode = (UCHAR)(usSigArg & 0xFF);

    switch ( bOpCode )
    {
    case SERVICE_CTRL_UNINSTALL:
	PerformUninstall();	// this causes a call to virtual OnUninstall
	DosExit( EXIT_PROCESS, 0 );
	break;

    case SERVICE_CTRL_PAUSE:
	OnPause();
	break;

    case SERVICE_CTRL_CONTINUE:
	OnContinue();
	break;

    default:
	if ( OnOther( bOpCode ))
	    break;	    // opcode handled in OnOther
	// all unhandled signals are supposed to be handled as 'interrogate',
	// so fall through

    case SERVICE_CTRL_INTERROGATE:
	OnInterrogate();
	break;

    }


    /*	Reenable signal handling.  This signal handler accepts the
     *	next signal raised on usSigNum.
     */

    APIERR err = DosSetSigHandler( 0, 0, 0, SIGA_ACKNOWLEDGE, usSigNum );
    //	BUGBUG.  What to do with 'err'?

}  // LM_SERVICE::SignalHandler


/*******************************************************************

    NAME:	LM_SERVICE::PerformUninstall

    SYNOPSIS:	Handles exiting the service.  This includes calling
		virtual OnUninstall.

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::PerformUninstall( void )
{
    if ( ! _fSigStarted )
	return;     // nothing to do

    APIERR err = SetStatus( SERVICE_UNINSTALL_PENDING |
			    SERVICE_UNINSTALLABLE |
			    SERVICE_NOT_PAUSABLE );
    //	BUGBUG.  What to do with 'err'?


    /*	Call virtual OnUninstall which will uninstall any service specific
     *	components
     */

    OnUninstall();


    //	Notify LAN Manager that the service is uninstalled
    err = SetStatus( SERVICE_UNINSTALLED |
		     SERVICE_UNINSTALLABLE |
		     SERVICE_NOT_PAUSABLE );
    //	BUGBUG.  What to do with 'err'?

}  // LM_SERVICE::PerformUninstall


/*******************************************************************

    NAME:	LM_SERVICE::OnInstall

    SYNOPSIS:	Called when service is being installed

    RETURNS:	An API error code, which is NERR_Success on success

    NOTES:	This is a virtual method, which may be replaced by subclasses

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

APIERR LM_SERVICE::OnInstall( void )
{
    return NERR_Success;

}  // LM_SERVICE::OnInstall


/*******************************************************************

    NAME:	LM_SERVICE::OnUninstall

    SYNOPSIS:	Called when service is being uninstalled

    RETURNS:	Nothing

    NOTES:	This is a virtual method, which may be replaced by subclasses

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::OnUninstall( void )
{
    //	do nothing

}  // LM_SERVICE::OnUninstall


/*******************************************************************

    NAME:	LM_SERVICE::OnPause

    SYNOPSIS:	Called when the service is paused

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::OnPause( void )
{
    APIERR err = SetStatus( SERVICE_INSTALLED |
			    LM20_SERVICE_PAUSED |
			    SERVICE_UNINSTALLABLE |
			    SERVICE_PAUSABLE );
    //	Hope that 'err' is success

}  // LM_SERVICE::OnPause


/*******************************************************************

    NAME:	LM_SERVICE::OnContinue

    SYNOPSIS:	Called when the service is continued

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::OnContinue( void )
{
    APIERR err = SetStatus( SERVICE_INSTALLED |
			    LM20_SERVICE_ACTIVE |
			    SERVICE_UNINSTALLABLE |
			    SERVICE_PAUSABLE );
    //	Hope that 'err' is success

}  // LM_SERVICE::OnContinue


/*******************************************************************

    NAME:	LM_SERVICE::OnInterrogate

    SYNOPSIS:	Called when the service is being interrogated

    RETURNS:	Nothing

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::OnInterrogate( void )
{
    APIERR err = ReportCurrentStatus();
    //	Hope that 'err' is success

}  // LM_SERVICE::OnInterrogate


/*******************************************************************

    NAME:	LM_SERVICE::OnOther

    SYNOPSIS:	Called when the service is being manipulated in some
		service-specific way

    ENTRY:	bOpCode -	The service-defined code indicating
				what task to perform

    RETURNS:	TRUE if the given opcode was handled
		FALSE otherwise

    NOTES:	If this method returns FALSE, the LM_SERVICE class will
		call OnInterrogate instead.  This is in line with the
		guidelines in the LAN Man 2.0 Prog Ref.

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

BOOL LM_SERVICE::OnOther( BYTE bOpCode )
{
    //	This base class does not handle any other signals
    UNREFERENCED( bOpCode );
    return FALSE;

}  // LM_SERVICE::OnOther


/*******************************************************************

    NAME:	LM_SERVICE::FatalExit

    SYNOPSIS:	Terminates the application, logging the error that
		occurred

    ENTRY:	err -		The error code that forced the service
				into fatal-exiting

    EXIT:	Never exits

    NOTES:	This method should only be called when there is no
		other feasible alternative

    HISTORY:
	rustanl     09-Jun-1991     Created

********************************************************************/

void LM_SERVICE::FatalExit( APIERR err )
{
    TCHAR szLogMsg[ 80 ];
    nsprintf( szLogMsg, SZ("Error %d occurred"), err );

    //	No reason to check the NetErrorLogWrite error code, since nothing
    //	can be done if it indicates a failure, anyway.
    NetErrorLogWrite( NULL,			// MBZ
		      err,			// error that occurred
		      _nlsName.QueryPch(),	// service name
		      NULL, 0,			// raw data pointer and size
		      szLogMsg, 		// error string pointer
		      1,			// number of error strings
		      NULL );			// MBZ

    PerformUninstall();

    DosExit( EXIT_PROCESS, err );   // exit all theads

}  // LM_SERVICE::FatalExit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\buffer\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
*/


#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include "uiassert.hxx"
#include "uibuffer.hxx"


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0),
    _hMem(0)
{
    if ( cbRequested == 0 )
        return;

    // Ignore return value - this reports error itself
    GetNewStorage(cbRequested);
}


/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb, _hMem

    RETURNS:    NERR_Success on success; APIERR otherwise

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

APIERR BUFFER::GetNewStorage( UINT cbRequested )
{
    UIASSERT(_hMem == 0);

    _hMem = ::GlobalAlloc( GMEM_MOVEABLE, (ULONG)cbRequested );
    if ( _hMem == 0 )
    {
#if defined(WIN32)
        APIERR err = ::GetLastError();
#else
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
#endif
        ReportError(err);
        return err;
    }

    _pb = (BYTE *) ::GlobalLock( _hMem );
    UIASSERT( _pb != NULL );

    _cb = cbRequested;
    return NERR_Success;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb, _hMem changed

    RETURNS:    NERR_Success on success; APIERR otherwise

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

APIERR BUFFER::ReallocStorage( UINT cbNewRequested )
{
    REQUIRE( ! ::GlobalUnlock( _hMem ));
    HANDLE hNewMem = ::GlobalReAlloc( _hMem, cbNewRequested, GMEM_MOVEABLE );
    if (hNewMem == 0)
    {
# if defined(WIN32)
        APIERR err = ::GetLastError();
# else
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
# endif
        _pb = (BYTE *) ::GlobalLock( _hMem );
        UIASSERT( _pb != NULL );
        return err;
    }
    _hMem = hNewMem;
    _pb = (BYTE *) ::GlobalLock( _hMem );

    UIASSERT( _pb != NULL );
    _cb = cbNewRequested;

    return NERR_Success;
}


/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BUFFER::~BUFFER()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
        return;

    REQUIRE( ! ::GlobalUnlock( _hMem ) );
    REQUIRE(   ::GlobalFree( _hMem ) == 0 );

#if defined(DEBUG)
    _hMem = 0;
    _pb = NULL;
    _cb = 0;
#endif
}


/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
    UIASSERT(( _pb == NULL && _cb == 0 ) ||
             ( _pb != NULL && _cb != 0 ));
}


/*******************************************************************

    NAME:       BUFFER::QueryActualSize

    SYNOPSIS:   Returns the actual size of the allocated memory block.
                (Private.)

    RETURNS:    Size, in bytes, or 0 on error (OS/2 only),

    NOTES:      Error handling is the client's responsibility.
                Called from Resize, FillOut, and Trim.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added.
        beng        20-Jun-1991     Size made UINT; Win32 work added.
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

UINT BUFFER::QueryActualSize()
{
    // It means nothing to call this on a zero-alloc'd buffer.
    //
    UIASSERT( _hMem != 0 );

    ULONG_PTR cbActual = ::GlobalSize( _hMem );

    if (cbActual == 0)
    {
#if defined(WIN32)
        ReportError(::GetLastError());
#else
        // Either discarded segment or else invalid handle.
        // This is just a number, meaning nothing.
        //
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
#endif
    }

    // Under Win16, clients will never request >64K of data
    //
    UIASSERT((sizeof(UINT)>=sizeof(ULONG)) || (cbActual <= 0x10000));

    // Safe under Win16 by assertion above; safe under Win32
    // since there sizeof(UINT) == sizeof(ULONG).
    //

    return (UINT)cbActual;
}


/*******************************************************************

    NAME:       BUFFER::QueryPtr

    SYNOPSIS:   Return a pointer to the beginning of the buffer

    RETURNS:    Returns a pointer to the first byte in the allocated
                buffer, or NULL if the buffer size is 0.

    NOTES:

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

BYTE * BUFFER::QueryPtr() const
{
#if defined(DEBUG)
    VerifyState();
#endif

    return _pb;
}


/*******************************************************************

    NAME:       BUFFER::QuerySize

    SYNOPSIS:   Return the requested size of the buffer

    RETURNS:    The current size of the buffer, in bytes.

    CAVEATS:    The size returned is that requested by the client,
                not the "actual" size of the internal buffer.
                Use FillOut to make these two sizes the same.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

UINT BUFFER::QuerySize() const
{
#if defined(DEBUG)
    VerifyState();
#endif

    return _cb;
}


/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size

    EXIT:
        _cb and _pb changed; possibly _hMem resized

        This function will only ReportError if the resize
        forces the object's first allocation.  Other alloc
        (i.e. realloc) failures just cause a direct error
        return.

    RETURNS:
        NERR_Success if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        !0 if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

APIERR BUFFER::Resize( UINT cbNewRequested )
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( cbNewRequested == 0 )
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        _pb = NULL;
        _cb = 0;

        // N.B. _hMem is not modified
        //
        return NERR_Success;
    }

    if ( _hMem == 0 )
    {
        /*
         * There is no memory handle.  Previous size of buffer
         * must have been 0.
         *
         * The new memory request is allocated.
         */
        return GetNewStorage( cbNewRequested );
    }
    else if (cbNewRequested <= QueryActualSize())
    {
        /*
         * The requested memory is no more than the currently allocated
         * memory block.
         *
         * Use that already allocated block (changing the size as
         * recorded).
         */
        _cb = cbNewRequested;
        if (_pb == NULL)
        {
            // Was resized to 0 once upon a time.
            // Regenerate pointer member.
            //
            _pb = (BYTE *) ::GlobalLock( _hMem );
            UIASSERT( _pb != NULL );
        }
        return NERR_Success;
    }

    /*
     * The requested memory exceeds the currently allocated memory.
     * A reallocation is in order.
     */
    return ReallocStorage(cbNewRequested);
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
    {
        /*
         * No memory is allocated.
         */
        UIASSERT( _pb == NULL && _cb == 0 );
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        UIASSERT( _pb == NULL );

        REQUIRE( ! ::GlobalUnlock( _hMem ));
        REQUIRE(   ::GlobalFree( _hMem ) == NULL );

        _hMem = NULL;
        return;
    }

    UIASSERT(QueryActualSize() >= _cb);
    if ( QueryActualSize() - _cb < 16 )
    {
        /*
         * A resize would "save" less than a paragraph of memory.
         * Not worth the effort.
         *
         * BUGBUG - what does "paragraph" mean under MIPS?
         */
        return;
    }

    /*
     * The potential optimization is at least one paragraph.
     * A reallocation is in order.
     *
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    REQUIRE( NERR_Success == ReallocStorage(_cb) );
}


/*******************************************************************

    NAME:       BUFFER::FillOut

    SYNOPSIS:   Changes the requested size to the actual buffer size.

    NOTES:
        This method is not defined when QueryPtr returns NULL.

        This method provides a very inexpensive way of possibly increasing
        the size of the buffer.  It is intended to be used when optimization
        is key.

        Note that Resize will not reallocate the buffer if the requested
        size is no more than the actual size.  Hence, Resize attempts to
        minimize the cost its operation.  That optimization is, under
        normal circumstances, all that is needed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header (standard format) added
        beng        24-Jun-1991     Sizes in UINTS

********************************************************************/

VOID BUFFER::FillOut()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
    {
        // Nothing to do
        //
        UIASSERT( _pb == NULL && _cb == 0 );
        return;
    }

    UINT cbSize = QueryActualSize();
    if ( cbSize == 0L )
    {
        // an error occurred, since we know the actual size cannot be 0
        //
        return;
    }

    UIASSERT( _cb <= cbSize );

    _cb = cbSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fmx\fmx.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    fmx.cxx
    This file contains wrappers around the calls to File Manager via
    the File Manager Extensions.

    FILE HISTORY:
        rustanl     30-Apr-1991     Created

*/


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#include "lmui.hxx"


extern "C"
{
    #include <wfext.h>
    #include <dos.h>
}

#include "string.hxx"
#include "uiassert.hxx"

#include "fmx.hxx"


/*******************************************************************

    NAME:       FMX::FMX

    SYNOPSIS:   Constructs an FMX object

    ENTRY:      hwnd -  File Man's hwnd

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

FMX::FMX( HWND hwnd )
    :   _hwnd( hwnd )
{
    // nothing else to do

}  // FMX::FMX


/*******************************************************************

    NAME:       FMX::Command

    SYNOPSIS:   Sends a message to File Manager

    ENTRY:      uiMsg -     message ID
                wParam -    wParam
                lParam -    lParam

    RETURNS:    ULONG value returned by message usMsg

    HISTORY:
        rustanl     30-Apr-1991     Created
        DavidHov    27-Oct-1993     Change to lazy-load USER32.DLL

********************************************************************/

typedef LRESULT WINAPI FN_SendMessageW ( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) ;
#define USER32_DLL_NAME SZ("user32.dll")
#define SEND_MSG_API_NAME "SendMessageW"


ULONG_PTR FMX::Command ( UINT uiMsg, UINT wParam, LPARAM lParam ) const
{
    static HMODULE hUser32 = NULL ;
    static FN_SendMessageW * pfSendMsg = NULL ;

    if ( pfSendMsg == NULL )
    {
        if ( hUser32 = ::LoadLibrary( USER32_DLL_NAME ) )
        {
            pfSendMsg = (FN_SendMessageW *) ::GetProcAddress( hUser32,
                                                             SEND_MSG_API_NAME ) ;
        }
        if ( pfSendMsg == NULL )
            return ERROR_INVALID_FUNCTION ;
    }

    return (ULONG_PTR) (*pfSendMsg) ( _hwnd, uiMsg, wParam, lParam );

}  // FMX::Command


/*******************************************************************

    NAME:       FMX::QueryFocus

    SYNOPSIS:   Returns what in FM has the focus

    RETURNS:    What has focus in FM, namely:
                    FMFOCUS_DIR (1)
                    FMFOCUS_TREE (2)
                    FMFOCUS_DRIVES (3)
                    FMFOCUS_SEARCH (4)

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

UINT FMX::QueryFocus( void ) const
{
    return (UINT)Command( FM_GETFOCUS );

}  // FMX::QueryFocus


/*******************************************************************

    NAME:       FMX::QuerySelCount

    SYNOPSIS:   Returns the count of selected items in File Man

    RETURNS:    That count

    NOTES:      This method always uses FM_GETSELCOUNTLFN.  There is
                also another message, FM_GETSELCOUNT, which could be
                used, but it doesn't count LFN files.

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

UINT FMX::QuerySelCount( void ) const
{
    return (UINT)( QueryFocus() == FMFOCUS_TREE ? 1 :
						 Command( FM_GETSELCOUNTLFN )) ;

}  // FMX::QuerySelCount


/*******************************************************************

    NAME:       FMX::QuerySelection

    SYNOPSIS:   Retrieves information about a selected file

    ENTRY:      iSel        index into the selected items
                pselinfo    pointer to FMS_GETFILESEL structure that
                            this call will fill in

    EXIT:       pselinfo    buffer pointed to by this pointer will be
                            filled in

    NOTES:	fAnsi is not required under win32 since we will map
		everything from the ANSI/OEM charset to UNICODE which
		doesn't have the problems of ANSI/OEM.

    HISTORY:
        rustanl     03-May-1991     Created
        yi-hsins    04-Oct-1991     Modified to return APIERR
	beng	    06-Apr-1992     Unicode version
	JohnL	    12-May-1992     Ansified for ANSI/Unicode interface

********************************************************************/

APIERR FMX::QuerySelection( INT iSel, FMS_GETFILESEL * pselinfo, BOOL fAnsi )
{

    APIERR err = NERR_Success ;

#ifdef WIN32
    UNREFERENCED( fAnsi ) ;

    Command( FM_GETFILESELLFN, iSel, (ULONG_PTR)pselinfo );

#else // WIN16

    Command( FM_GETFILESELLFN, iSel, (ULONG)pselinfo );
    if ( fAnsi )
    {
	::OemToAnsi( pselinfo->szName, pselinfo->szName);
    }
#endif

    return err ;

}  // FMX::QuerySelection


/*******************************************************************

    NAME:       FMX::QueryDriveInfo

    SYNOPSIS:   Retrieves info about the currently selected drive

    ENTRY:      pdriveinfo      Pointer to FMS_GETDRIVEINFO structure
                                that will be filled on exit

    EXIT:       pdriveinfo      Will contain info on exit

    HISTORY:
        rustanl     03-May-1991     Created
	yi-hsins    04-Oct-1991     Modified to return APIERR
	JohnL	    12-May-1992     Ansified for ANSI/Unicode interface

********************************************************************/

APIERR FMX::QueryDriveInfo( FMS_GETDRIVEINFO * pdriveinfo )
{
    APIERR err = NERR_Success ;

    Command( FM_GETDRIVEINFO, 0, (ULONG_PTR)pdriveinfo );

    return err ;

}  // FMX::QueryDriveInfo


/*******************************************************************

    NAME:       FMX::Refresh

    SYNOPSIS:   Refreshes File Man's window

    HISTORY:
        rustanl     03-May-1991     Created

********************************************************************/

void FMX::Refresh( void )
{
    Command( FM_REFRESH_WINDOWS );

}  // FMX::Refresh


/*******************************************************************

    NAME:       FMX::Reload

    SYNOPSIS:   Causes File Man to reload the File Man extensions

    HISTORY:
        rustanl     03-May-1991     Created

********************************************************************/

void FMX::Reload( void )
{
    Command( FM_RELOAD_EXTENSIONS );

}  // FMX::Reload

/*******************************************************************

    NAME:	FMX::IsHeterogeneousSelection

    SYNOPSIS:	Determines if the selection contains a combination of files
		or dirs.

    ENTRY:	pfIsHomogeneousSelFiles - Will be set to TRUE if FALSE is
		    returned the homogenous selection is all files.  Set to
		    FALSE if FALSE is returned and the selection is all
		    directories.

    RETURNS:	TRUE will be returned if the selection contains a mix of
		files and dirs.

    NOTES:

    HISTORY:
	Johnl	03-Nov-1992	Created

********************************************************************/

BOOL FMX::IsHeterogeneousSelection( BOOL * pfIsHomogeneousSelFiles )
{
    UINT cSelectedItems = QuerySelCount() ;

    if ( QueryFocus() == FMFOCUS_TREE )
    {
	if ( pfIsHomogeneousSelFiles != NULL )
	    *pfIsHomogeneousSelFiles = FALSE ;
	return FALSE ;
    }

    if ( pfIsHomogeneousSelFiles != NULL )
	*pfIsHomogeneousSelFiles = TRUE ;

    BOOL fFoundFile = FALSE ;
    BOOL fFoundDir  = FALSE ;
    for ( UINT i = 0 ; i < cSelectedItems ; i++ )
    {
	FMS_GETFILESEL selinfo ;
	Command( FM_GETFILESELLFN, i, (ULONG_PTR)&selinfo );

	//
	//  If this selection is a directory and we previously found a file,
	//  then we have a hetergeneous selection, or vice versa.
	//
	if ( selinfo.bAttr & _A_SUBDIR )
	{
	    if ( fFoundFile )
		return TRUE ;

	    fFoundDir = TRUE ;
	}
	else
	{
	    if ( fFoundDir )
		return TRUE ;

	    fFoundFile = TRUE ;
	}
    }

    //
    //	At this point we know we have a homogeneous selection, but is it
    //	a file or directory?
    //

    if ( pfIsHomogeneousSelFiles != NULL )
	*pfIsHomogeneousSelFiles = fFoundFile ;

    return FALSE ;
}

/*******************************************************************

    NAME:       GetSelItem

    SYNOPSIS:   Get the selected item name - could be a file or
                directory. If it's a file, get the directory the
                file is in if the fGetDirOnly flag is set.

    ENTRY:      hwnd  - hwnd of the parent window
                fGetDirOnly - TRUE if interested only in a directory
                    (i.e., strip filenames).  Also indicates multiple
                    selections should not be allowed.

    EXIT:       nlsSelItem - the name of the selected item name
                pfIsFile - Set to TRUE if the item is a file, FALSE if
                    the item is a directory

    RETURNS:

    NOTES:      If fGetDirOnly is FALSE and multiple files/directories
                exist, then ERROR_NOT_SUPPORTED will be returned (this
                shouldn't happen).

    HISTORY:
        Yi-HsinS        8/25/91         Created
        JohnL           1/21/92         Enhanced for connection use

********************************************************************/

APIERR GetSelItem( HWND     hwnd,
                   NLS_STR *pnlsSelItem,
                   BOOL     fGetDirOnly,
                   BOOL    *pfIsFile )
{
    APIERR err = NERR_Success;

    if ( pfIsFile != NULL )
        *pfIsFile = FALSE ;

    FMX fmx( hwnd );

    switch ( fmx.QueryFocus() )
    {
        case FMFOCUS_DIR:
        case FMFOCUS_SEARCH:
        {
            UINT uiSelCount = fmx.QuerySelCount() ;
            if (  uiSelCount > 0 )
            {

                if ( (uiSelCount > 1) && !fGetDirOnly )
                {
                    err = ERROR_NOT_SUPPORTED ;
                    break ;
                }

                FMS_GETFILESEL selinfo;

                // If multiple files are selected, get the info.
                // on the first file, i.e. use the first file as the
                // selected file.
                if ( err = fmx.QuerySelection(0, &selinfo ) )
                    break ;

                *pnlsSelItem = selinfo.szName ;
                if ( err = pnlsSelItem->QueryError() )
                    break ;

                /* Set the pfIsFile flag if we can return files and
                 * the selection is a file.
                 */
                if ( !fGetDirOnly && (pfIsFile != NULL) )
                    *pfIsFile = !(selinfo.bAttr & _A_SUBDIR) ;

                //
                // If selected item is a file, use the directory of the file
                // if requested
                //
                if ( fGetDirOnly                      &&
                     !( selinfo.bAttr & _A_SUBDIR ) )
                {
                    ISTR istrSelItem( *pnlsSelItem );
		    REQUIRE( pnlsSelItem->strrchr( &istrSelItem, TCH('\\') ));
                    pnlsSelItem->DelSubStr( istrSelItem );
		    REQUIRE( pnlsSelItem->strchr( &istrSelItem, TCH(':') ));

                    // Put the '\' back if the name is a device x:
                    if ( istrSelItem.IsLastPos() )
                    {
			err = pnlsSelItem->AppendChar( TCH('\\'));
                    }
                }
                break;
            }
            // else no files are selected in the FILE window
            // fall through to FMFOCUS_TREE to get driveinfo
        }

        case FMFOCUS_TREE:
        {
            FMS_GETDRIVEINFO driveinfo;
            if ( err = fmx.QueryDriveInfo( &driveinfo ) )
                break ;

            *pnlsSelItem = driveinfo.szPath;
            err = pnlsSelItem->QueryError() ;
            break;
        }

        case FMFOCUS_DRIVES:
        default:
            ASSERTSZ(FALSE, "Invalid Focus!");
            break;
    }

    return err;
}

/*******************************************************************

    NAME:       GetSelItem

    SYNOPSIS:   Get the nth selected item - could be a file or
                directory.

    ENTRY:      hwnd  - hwnd of the parent window
                iSelection - Retrieves the ith selection

    EXIT:       nlsSelItem - the name of the selected item name
                pfIsFile - Set to TRUE if the item is a file, FALSE if
                    the item is a directory

    RETURNS:

    NOTES:

    HISTORY:
        JohnL   13-Feb-1992     Ripped off from GetSelItem above.

********************************************************************/

APIERR GetSelItem( HWND     hwnd,
                   UINT     iSelection,
                   NLS_STR *pnlsSelItem,
                   BOOL    *pfIsFile )
{
    APIERR err = NERR_Success;

    if ( pfIsFile != NULL )
        *pfIsFile = FALSE ;

    FMX fmx( hwnd );
    switch ( fmx.QueryFocus() )
    {
        case FMFOCUS_DIR:
        case FMFOCUS_SEARCH:
        {
            UINT uiSelCount = fmx.QuerySelCount() ;
            if (  uiSelCount > 0 )
            {
                FMS_GETFILESEL selinfo;

                if ( uiSelCount <= iSelection )
                {
                    err = ERROR_INVALID_PARAMETER ;
                    break ;
                }

                if ( err = fmx.QuerySelection(iSelection, &selinfo ) )
                    break ;

                *pnlsSelItem = selinfo.szName ;
                if ( err = pnlsSelItem->QueryError() )
                    break ;

                /* Set the pfIsFile flag if we can return files and
                 * the selection is a file.
                 */
                if ((pfIsFile != NULL) )
                    *pfIsFile = !(selinfo.bAttr & _A_SUBDIR) ;

                break;
            }
            // else no files are selected in the FILE window
            // fall through to FMFOCUS_TREE to get driveinfo
        }

        case FMFOCUS_TREE:
        {
            /* Only one thing is selected
             */
            if ( iSelection > 0 )
            {
                err = ERROR_INVALID_PARAMETER ;
                break ;
            }

            FMS_GETDRIVEINFO driveinfo;
            if ( err = fmx.QueryDriveInfo( &driveinfo ) )
                break ;

            *pnlsSelItem = driveinfo.szPath;
            err = pnlsSelItem->QueryError() ;
            break;
        }

        case FMFOCUS_DRIVES:
        default:
            ASSERTSZ( FALSE, "Invalid Focus!");
            break;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\errmap\errmap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    errmap.cxx
    Implementation of the ERRMAP class.

    FILE HISTORY:
        ThomasPa    02-Mar-1992     Created

*/


#include "ntincl.hxx"

#define INCL_NETCONS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

extern "C"
{
    #include <ntstatus.h>
    #include "netlibnt.h"       // for NetpNtStatusToApiStatus()
}


#include "errmap.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif


typedef struct _MAPENTRY {
        NTSTATUS ntstatus;
        APIERR apierr;
} MAPENTRY;

MAPENTRY amapentryUIMapTable[] =
{
   { STATUS_MORE_ENTRIES,    ERROR_MORE_DATA     },
   { STATUS_NO_MORE_ENTRIES, NO_ERROR }
};




/*******************************************************************

    NAME:       ERRMAP::MapNTStatus

    SYNOPSIS:   Static method for mappint NTSTATUS codes to APIERRs

    ENTRY:      ntstatus - NTSTATUS to be mapped
                pfMapped - pointer to boolean set to TRUE if NTSTATUS
                           is mapped. default is NULL.
                apierrDefReturn - if non-zero, this indicates the APIERR
                           code to return if the input NTSTATUS cannot
                           be mapped.  Default is 0 (return unmapped
                           NTSTATUS).


    EXIT:       mapped APIERR
                pfMapped - TRUE if the NTSTATUS was mapped.

    RETURNS:

    NOTES:

    HISTORY:
        Thomaspa        02-Mar-1992     Created
        Thomaspa        30-Mar-1992     Code review changes

********************************************************************/

APIERR ERRMAP::MapNTStatus( NTSTATUS ntstatus,
                            BOOL * pfMapped,
                            APIERR apierrDefReturn )
{
    INT i;
    APIERR apierr;

    ASSERT( sizeof(NTSTATUS) == sizeof(APIERR) );

    if (pfMapped != NULL)       // Assume it will be mapped.
        *pfMapped = TRUE;

    // First check if this is an ntstatus we explicitly want
    // to map (e.g. STATUS_MORE_ENTRIES)

    for ( i = 0;
          i < sizeof(amapentryUIMapTable)/sizeof(amapentryUIMapTable[0]);
          i++ )
    {
        if (ntstatus == amapentryUIMapTable[i].ntstatus)
        {
            return amapentryUIMapTable[i].apierr;
        }
    }

    // Now flatten any non-error ntstatus to NERR_Success
    if ( NT_SUCCESS( ntstatus ) )
    {
        return NERR_Success;
    }

    // Finally, give NetpNtStatusToApiStatus() a chance
    apierr = (APIERR)NetpNtStatusToApiStatus( ntstatus );

    // These errors may be returned by the above API if it doesn't have
    // a mapping for the ntstatus
    if ( apierr != NERR_InternalError &&
	apierr != ERROR_RING2SEG_MUST_BE_MOVABLE )
    {
        return apierr;
    }

    // No mapping was done,

    if ( apierrDefReturn != 0 )
    {
        return apierrDefReturn;
    }
    else
    {
        if (pfMapped != NULL)
            *pfMapped = FALSE;
        return (APIERR)ntstatus;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fsenum\fsenmlfn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmLFN.cxx

    This file contains the implementation of WINNET_LFN_FS_ENUM
    These are used for traversing files and directories
    on a volume when under Win16 and the volume supports long filenames.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
//#define INCL_OS2
#define INCL_WINDOWS
#include "lmui.hxx"

#include "fsenum.hxx"

extern "C"
{
    #define LFN
    #include "winnet.h"
}

/*************************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class WINNET_LFN_DIR_BLOCK : public DIR_BLOCK
{
friend class WINNET_LFN_FS_ENUM ;

private:
    UINT   _hdir ;

    /* Note: the _achFileNamePad must immediately follow the _ffbuff2
     * structure.
     */
    struct FILEFINDBUF2 _ffbuff2 ;
    BYTE		_achFileNamePad[ 260 ] ;    // Can we get the manifiest?

public:
    WINNET_LFN_DIR_BLOCK()
    {  /* Nothing else to do */ }

    virtual ~WINNET_LFN_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

WINNET_LFN_DIR_BLOCK::~WINNET_LFN_DIR_BLOCK()
{
    LFNFindClose( _hdir ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT WINNET_LFN_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff2.attr ;
}

/*******************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * WINNET_LFN_DIR_BLOCK::QueryFileName( void )
{
    return (const TCHAR *) _ffbuff2.achName ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::WINNET_LFN_FS_ENUM

    SYNOPSIS:	Constructor for a WINNET LFN File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

WINNET_LFN_FS_ENUM::WINNET_LFN_FS_ENUM ( const TCHAR * pszPath,
					     const TCHAR * pszMask,
					     enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

WINNET_LFN_FS_ENUM::~WINNET_LFN_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls LFNFindFirst

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR WINNET_LFN_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    UINT uiSearchCount = 1 ;
    WINNET_LFN_DIR_BLOCK * pOS2DirBlock = (WINNET_LFN_DIR_BLOCK *) pDirBlock ;
    return LFNFindFirst( (char *) nlsSearchPath.QueryPch(),
			   (WORD) uiSearchAttr,
			  (int *) &uiSearchCount,
			  (int *) &(pOS2DirBlock->_hdir),
				  sizeof( pOS2DirBlock->_ffbuff2 ) +
				      sizeof( pOS2DirBlock->_achFileNamePad ),
				  &(pOS2DirBlock->_ffbuff2) ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls LFNFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR WINNET_LFN_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr	)
{
    UINT uiSearchCount = 1 ;
    WINNET_LFN_DIR_BLOCK * pOS2DirBlock = (WINNET_LFN_DIR_BLOCK *) pDirBlock ;
    return LFNFindNext(  pOS2DirBlock->_hdir,
			 (int *) &uiSearchCount,
			 sizeof( pOS2DirBlock->_ffbuff2 ) +
			   sizeof( pOS2DirBlock->_achFileNamePad ),
			 &(pOS2DirBlock->_ffbuff2) ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created WINNET_LFN_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * WINNET_LFN_FS_ENUM::CreateDirBlock( void )
{
    return new WINNET_LFN_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fsenum\fsenmos2.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmOS2.cxx

    This file contains the implementation of OS2_FS_ENUM
    These are used for traversing files and directories
    on a volume under OS/2.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_OS2
#include "lmui.hxx"

#include "fsenum.hxx"

/*************************************************************************

    NAME:	OS2_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2, HDIR

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class OS2_DIR_BLOCK : public DIR_BLOCK
{
friend class OS2_FS_ENUM ;

private:
    struct FILEFINDBUF2 _ffbuff2 ;
    HDIR  _hdir ;

public:
    OS2_DIR_BLOCK() : _hdir( HDIR_CREATE )
    {  /* Nothing else to do */ }

    virtual ~OS2_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

OS2_DIR_BLOCK::~OS2_DIR_BLOCK()
{
    DosFindClose( _hdir ) ;
}

/*******************************************************************

    NAME:	OS2_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT OS2_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff2.attrFile ;
}

/*******************************************************************

    NAME:	OS2_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * OS2_DIR_BLOCK::QueryFileName( void )
{
    return _ffbuff2.achName ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::OS2_FS_ENUM

    SYNOPSIS:	Constructor for an OS/2 File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

OS2_FS_ENUM::OS2_FS_ENUM ( const TCHAR * pszPath,
			       const TCHAR * pszMask,
			       enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

OS2_FS_ENUM::~OS2_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	OS2_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls DosFindFirst2

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR OS2_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    USHORT usSearchCount = 1 ;
    OS2_DIR_BLOCK * pOS2DirBlock = (OS2_DIR_BLOCK *) pDirBlock ;
    return DosFindFirst2( (PSZ) nlsSearchPath.QueryPch(),
			   &(pOS2DirBlock->_hdir),
			   (USHORT) uiSearchAttr,
			   (PVOID)  &(pOS2DirBlock->_ffbuff2),
			   sizeof( pOS2DirBlock->_ffbuff2 ),
			   &usSearchCount,
			   FIL_QUERYEASIZE,
			   0L ) ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR OS2_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    USHORT usSearchCount = 1 ;
    OS2_DIR_BLOCK * pOS2DirBlock = (OS2_DIR_BLOCK *) pDirBlock ;
    return DosFindNext(  pOS2DirBlock->_hdir,
			 (PFILEFINDBUF)  &(pOS2DirBlock->_ffbuff2),
			 sizeof( pOS2DirBlock->_ffbuff2 ),
			 &usSearchCount ) ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created OS2_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * OS2_FS_ENUM::CreateDirBlock( void )
{
    return new OS2_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fsenum\fsenmw32.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmW32.cxx

    This file contains the implementation of W32_FS_ENUM
    These are used for traversing files and directories
    on a volume under 32 bit windows (uses the Win32 APIs).



    FILE HISTORY:
	Johnl	04-Oct-1991	Created
	Johnl	10-Mar-1992	Did implementation

*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#include "fsenum.hxx"

/*************************************************************************

    NAME:	W32_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2, HDIR

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class W32_DIR_BLOCK : public DIR_BLOCK
{
friend class W32_FS_ENUM ;

private:
    WIN32_FIND_DATA _win32FindData ;
    HANDLE _hDir ;

public:
    W32_DIR_BLOCK()
    {
        //
        //  Initialize the file name to NULL in case a FindNext fails the
        //  user can still call QueryFileName to find out which directory
        //  the enumeration failed on
        //
        _win32FindData.cFileName[0] = '\0' ;
    }

    virtual ~W32_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

W32_DIR_BLOCK::~W32_DIR_BLOCK()
{
    ::FindClose( _hDir ) ;
}

/*******************************************************************

    NAME:	W32_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT W32_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _win32FindData.dwFileAttributes ;
}

/*******************************************************************

    NAME:	W32_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * W32_DIR_BLOCK::QueryFileName( void )
{
    return _win32FindData.cFileName ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::W32_FS_ENUM

    SYNOPSIS:	Constructor for an Win32 File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created
	Johnl	26-Oct-1992	Added nMaxDepth

********************************************************************/

W32_FS_ENUM::W32_FS_ENUM ( const TCHAR * pszPath,
			   const TCHAR * pszMask,
			   enum FILE_TYPE filtypeInclude,
			   BOOL fDepthFirst,
			   UINT nMaxDepth )
    : FS_ENUM( pszPath, pszMask, filtypeInclude, fDepthFirst, nMaxDepth )
{
    if ( QueryError() )
	return ;
}

W32_FS_ENUM::~W32_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	W32_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls FindFirstFile

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR W32_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
			       const NLS_STR & nlsSearchPath,
			       UINT uiSearchAttr )
{
    APIERR err = NERR_Success ;

    W32_DIR_BLOCK * pW32DirBlock = (W32_DIR_BLOCK *) pDirBlock ;
    pW32DirBlock->_hDir = ::FindFirstFile( (LPTSTR) nlsSearchPath.QueryPch(),
					     &(pW32DirBlock->_win32FindData) ) ;

    if ( INVALID_HANDLE_VALUE == pW32DirBlock->_hDir )
	err = ::GetLastError() ;

    return err ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR W32_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    W32_DIR_BLOCK * pW32DirBlock = (W32_DIR_BLOCK *) pDirBlock ;
    if ( !::FindNextFile(  pW32DirBlock->_hDir,
			   &(pW32DirBlock->_win32FindData) ))
    {
	return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created W32_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * W32_FS_ENUM::CreateDirBlock( void )
{
    return new W32_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fsenum\fsenmdos.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmDOS.cxx

    This file contains the implementation of DOS_FS_ENUM
    These are used for traversing files and directories
    on a volume under OS/2.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_OS2
#include "lmui.hxx"

#include "uiassert.hxx"

#include "fsenum.hxx"

extern "C"
{
    #include <errno.h>
    #include <io.h>
}

/*************************************************************************

    NAME:	DOS_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the DOS File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	find_t

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class DOS_DIR_BLOCK : public DIR_BLOCK
{
friend class DOS_FS_ENUM ;

private:
    struct find_t _ffbuff ;

public:
    DOS_DIR_BLOCK()
    {  /* Nothing else to do */ }

    virtual ~DOS_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;
} ;

DOS_DIR_BLOCK::~DOS_DIR_BLOCK()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	DOS_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT DOS_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff.attrib ;
}

/*******************************************************************

    NAME:	DOS_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * DOS_DIR_BLOCK::QueryFileName( void )
{
    return _ffbuff.name ;
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::DOS_FS_ENUM

    SYNOPSIS:	Constructor for an DOS File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DOS_FS_ENUM::DOS_FS_ENUM ( const TCHAR * pszPath,
			       const TCHAR * pszMask,
			       enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

DOS_FS_ENUM::~DOS_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	DOS_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls DosFindFirst2

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR DOS_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    DOS_DIR_BLOCK * pDOSDirBlock = (DOS_DIR_BLOCK *) pDirBlock ;
    return _dos_findfirst( nlsSearchPath.QueryPch(),
			   (unsigned) uiSearchAttr,
			   &(pDOSDirBlock->_ffbuff) );
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR DOS_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    UNREFERENCED( uiSearchAttr ) ;

    DOS_DIR_BLOCK * pDOSDirBlock = (DOS_DIR_BLOCK *) pDirBlock ;
    return _dos_findnext( &(pDOSDirBlock->_ffbuff) );
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created DOS_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * DOS_FS_ENUM::CreateDirBlock( void )
{
    return new DOS_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\fsenum\fsenum.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnum.cxx

    This file contains the implementation of FS_ENUM file/directory enumerator.
    These are used for traversing files and directories This exists only under the Win32 uimisc libraries

    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include "lmui.hxx"

#include "uiassert.hxx"
#include "uitrace.hxx"
#include "fsenum.hxx"

DEFINE_SLIST_OF( DIR_BLOCK )


/*******************************************************************

    NAME:	DIR_BLOCK::DIR_BLOCK

    SYNOPSIS:	Constructor for the DIR_BLOCK

    ENTRY:

    EXIT:	The count is initialized to -1.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK::DIR_BLOCK()
    : _fHasFindFirstBeenCalled( FALSE ),
      _fBreadthFirstDoDirs    ( FALSE ),
      _strlistIter( _strlistBreadthFirstDirs )
{
    if ( QueryError() )
	return ;
}

DIR_BLOCK::~DIR_BLOCK()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	FS_ENUM::FS_ENUM

    SYNOPSIS:	Constructor for FS_ENUM class

    ENTRY:	pszOrgPath - Base path to start enumerating from (should be
		    directory name).  A '\\' will be appended if it does
		    not end in one.

		pszMask - Search mask

		filtypInclude - Indicates if we should include files, dirs
		    or both.


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * FS_ENUM :: _pszAllFilesMask = SZ("*.*");

FS_ENUM::FS_ENUM( const TCHAR * pszOrgPath,
		      const TCHAR * pszMask,
		      enum FILE_TYPE filtypeInclude,
		      BOOL  fDepthFirst,
		      UINT  nMaxDepth )
    : _cTotalFiles	   ( 0 ),
      _filtypInclude	   ( filtypeInclude ),
      _nlsMask		   ( pszMask ),
      _nlsPath		   ( pszOrgPath ),	// These are ALIAS_STRs
      _nlsDot		   ( SZ(".") ),
      _nlsDotDot	   ( SZ("..") ),
      _errLastError	   ( NERR_Success ),
      _pCurrentDirBlock    ( NULL ),
      _slStackOfDirBlocks  (),
      _fDepthFirst	   ( fDepthFirst ),
      _nMaxDepth	   ( nMaxDepth ),
      _nCurrentDepth	   ( 0 )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( err = _nlsPath.QueryError() )
    {
	ReportError( err ) ;
	return ;
    }

    /* If the path doesn't end in a '\\', then append one.
     */
    ISTR istrLastSlash( _nlsPath ) ;
    if ( _nlsPath.strrchr( &istrLastSlash, TCH('\\') ) )
    {
	if ( !istrLastSlash.IsLastPos() )
	    err = _nlsPath.AppendChar( TCH('\\') ) ;
    }
    else
	err = _nlsPath.AppendChar( TCH('\\') ) ;

    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}

FS_ENUM::~FS_ENUM()
{
    TRACEEOL("FS_ENUM: Traversed " << _cTotalFiles << " files and dirs") ;
    delete _pCurrentDirBlock ;
    _pCurrentDirBlock = NULL ;
}

/*******************************************************************

    NAME:	FS_ENUM::Next( void )

    SYNOPSIS:	Does a depth first or breadth first enumeration

    NOTES:

    HISTORY:
	Johnl	10-Sep-1992	Created

********************************************************************/

BOOL FS_ENUM::Next( void )
{
    if ( _fDepthFirst )
	return NextDepthFirst() ;
    else
	return NextBreadthFirst() ;
}

/*******************************************************************

    NAME:	FS_ENUM::NextDepthFirst

    SYNOPSIS:	Attempts to retrieve the next file in this enumeration
		in a depth first fashion

    ENTRY:

    RETURNS:	TRUE if successful, FALSE if an error occurred or there are
		no more files to retrieve.

    NOTES:	The "." and ".." entries are filtered out

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::NextDepthFirst( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentDirBlock() == NULL )
    {
	/* Very first Next() since this object was instantiated, so we need
	 * to prime the pump.
	 */
	if ( err = PushDir() )
	    ReportLastError( err ) ;
    }

    BOOL fRepeat = TRUE ;
    while ( err == NERR_Success && fRepeat )
    {
	if ( !QueryCurrentDirBlock()->HasFindFirstBeenCalled() )
	{
	    NLS_STR nlsSearchPath( _nlsPath ) ;
	    nlsSearchPath += _nlsMask ;
	    if ( err = nlsSearchPath.QueryError() )
		break ;

	    err = FindFirst( QueryCurrentDirBlock(),
			     nlsSearchPath,
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	    if ( err == NERR_Success )
		QueryCurrentDirBlock()->SetFindFirstFlag( TRUE ) ;

	    /* Map a file not found error to a no more files error (NTFS
	     * may return file not found if the directory is empty).
	     */
	    if ( err == ERROR_FILE_NOT_FOUND )
	    {
		err = ERROR_NO_MORE_FILES ;
            }
            else if ( err )
            {
                //
                //  Try and recover by discarding the failing directory
                //
                (void) PopDir() ;
                break ;
            }
	}
	else
	{
	    err = FindNext(  QueryCurrentDirBlock(),
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	}

	if ( !err &&
	     QueryCurrentDirBlock()->IsDir() &&
	     ::strcmpf( _nlsDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     ::strcmpf( _nlsDotDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     QueryCurrentDepth() < QueryMaxDepth() )
	{
	    if ( err = PushDir() )
		break ;

	    /* We have a fresh DIR_BLOCK, so initialize it with a FindFirst
	     */
	    continue ;
	}

	//
	// Restore the containing directory and return that to the user
	//

        if ( err )
	{
	    err = PopDir() ;
        }

	if ( err == NERR_Success )
	{
	    ALIAS_STR nlsDirName( QueryCurrentDirBlock()->QueryFileName() ) ;

	    /* We don't include the "." and ".." entries in the directory
	     * listing.
	     */
	    if (  nlsDirName != _nlsDot &&
		  nlsDirName != _nlsDotDot &&
		  ShouldThisFileBeIncluded( QueryCurrentDirBlock()->QueryAttr()) )
	    {
		/* We have found what we were looking for
		 */
		fRepeat = FALSE ;
		_cTotalFiles++ ;
	    }
	}
    }

    if ( err )
	ReportLastError( err ) ;

    return (err == NERR_Success) ;
}

/*******************************************************************

    NAME:	FS_ENUM::NextBreadthFirst

    SYNOPSIS:	Attempts to retrieve the next file in this enumeration
		in a Breadth first fashion

    ENTRY:

    RETURNS:	TRUE if successful, FALSE if an error occurred or there are
		no more files to retrieve.

    NOTES:	The "." and ".." entries are filtered out

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::NextBreadthFirst( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentDirBlock() == NULL )
    {
	/* Very first Next() since this object was instantiated, so we need
	 * to prime the pump.
	 */
	if ( err = PushDir() )
	    ReportLastError( err ) ;
    }

    BOOL fRepeat = TRUE ;
    while ( err == NERR_Success && fRepeat )
    {
	/* Check to see if we are working on our queued list of directories
	 * in the current directory
	 */
	if ( QueryCurrentDirBlock()->DoBreadthFirstDirs() )
	{
	    NLS_STR * pnlsDirName = QueryCurrentDirBlock()->
						    QueryDirsIter()->Next() ;
	    if ( pnlsDirName != NULL &&
		 QueryCurrentDepth() < QueryMaxDepth())
	    {
		err = PushDir( *pnlsDirName ) ;
	    }
	    else
	    {
		/* This one is all used up, get rid of it and get a new one
		 */
		err = PopDir() ;
		continue ;
	    }

	}

	if ( !QueryCurrentDirBlock()->HasFindFirstBeenCalled() )
	{
	    NLS_STR nlsSearchPath( _nlsPath ) ;
	    nlsSearchPath += _nlsMask ;
	    if ( err = nlsSearchPath.QueryError() )
		break ;

	    err = FindFirst( QueryCurrentDirBlock(),
			     nlsSearchPath,
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	    if ( err == NERR_Success )
		QueryCurrentDirBlock()->SetFindFirstFlag( TRUE ) ;

	    /* Map a file not found error to a no more files error (NTFS
	     * may return file not found if the directory is empty).
	     */
	    if ( err == ERROR_FILE_NOT_FOUND )
	    {
		err = ERROR_NO_MORE_FILES ;
	    }
	}
	else
	{
	    err = FindNext(  QueryCurrentDirBlock(),
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	}

	/* If the current item is a directory, store it away and we will
	 * get back to it.
	 */
	if ( !err &&
	     QueryCurrentDirBlock()->IsDir() &&
	     ::strcmpf( _nlsDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     ::strcmpf( _nlsDotDot, QueryCurrentDirBlock()->QueryFileName()) )
	{
	    /* Save away this directory name in the dirlist.  We will come
	     * back to it after we go through everything in this directory.
	     */
	    NLS_STR * pnlsDir = new NLS_STR(
				     QueryCurrentDirBlock()->QueryFileName() ) ;
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( pnlsDir == NULL ||
		 (err = pnlsDir->QueryError()) ||
		 (err = QueryCurrentDirBlock()->QueryDirs()->Add( pnlsDir )) )
	    {
		/* Fall through
		 */
	    }
	}

	if ( err == NERR_Success )
	{
	    ALIAS_STR nlsDirName( QueryCurrentDirBlock()->QueryFileName() ) ;

	    /* We don't include the "." and ".." entries in the directory
	     * listing.
	     */
	    if (  nlsDirName != _nlsDot &&
		  nlsDirName != _nlsDotDot &&
		  ShouldThisFileBeIncluded( QueryCurrentDirBlock()->QueryAttr()) )
	    {
		/* We have found what we were looking for
		 */
		fRepeat = FALSE ;
		_cTotalFiles++ ;
	    }
	}
	else if ( err == ERROR_NO_MORE_FILES )
	{
	    /* Now that we have traversed the directory, traverse the queued
	     * up dirs in this dir block
	     */
	    QueryCurrentDirBlock()->SetDoBreadthFirstDirs( TRUE ) ;
	    QueryCurrentDirBlock()->QueryDirsIter()->Reset() ;
	    err = NERR_Success ;
	}
    }

    if ( err )
	ReportLastError( err ) ;

    return (err == NERR_Success) ;
}


/*******************************************************************

    NAME:	FS_ENUM::PushDir

    SYNOPSIS:	We are about to plunge one level deeper in the directory
		tree, so save the current directory information and
		create a new DIR_BLOCK.

    ENTRY:	pszNewDir - Optional dir to use for new directory.  If NULL,
		  then current directory is used

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	If there is no current DIR_BLOCK, then this method will
		allocate one and do nothing else.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::PushDir( const TCHAR * pszNewDir )
{
    APIERR err = NERR_Success ;

    /* Save the current DIR_BLOCK if one exists
     */
    if ( QueryCurrentDirBlock() != NULL )
    {
	err = _slStackOfDirBlocks.Add( QueryCurrentDirBlock() ) ;
    }

    if ( err == NERR_Success )
    {
	DIR_BLOCK * pDirBlock = CreateDirBlock() ;
	if ( pDirBlock == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	}
	else if ( err = pDirBlock->QueryError() )
	{
	    delete pDirBlock ;
	}
	else
	{
	    if ( QueryCurrentDirBlock() != NULL )
	    {
		if ( pszNewDir == NULL )
		{
		    pszNewDir = QueryCurrentDirBlock()->QueryFileName() ;
		}

		ALIAS_STR nlsFileName( pszNewDir ) ;
		if ( (err = _nlsPath.Append( nlsFileName )) ||
		     (err = _nlsPath.AppendChar(TCH('\\')) ) )
		{
		    delete pDirBlock ;
		    return err ;
		}
	    }

	    SetCurrentDirBlock( pDirBlock ) ;
	    _nCurrentDepth++ ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	FS_ENUM::PopDir

    SYNOPSIS:	We have enumerated all of the items in the current
		directory, so delete the current DIR_BLOCK and get
		the previous one.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::PopDir( void )
{
    APIERR err = NERR_Success ;

    /* If there aren't any DIR_BLOCKs to pop, or we already popped the last
     * one, then notify the caller, otherwise, set the current dir block.
     */

    if ( QueryCurrentDirBlock() == NULL || _slStackOfDirBlocks.QueryNumElem() == 0 )
    {
	err = ERROR_NO_MORE_FILES ;
    }
    else
    {
	/* Take off the last directory component of the path
	 *   i.e., X:\A\B\C\ ==> X:\A\B\
	 */
	ISTR istrSep( _nlsPath ) ;
	REQUIRE( _nlsPath.strrchr( &istrSep, TCH('\\') ) ) ;
	UIASSERT( istrSep.IsLastPos() ) ;
	_nlsPath.DelSubStr( istrSep ) ;
	istrSep.Reset() ;
	REQUIRE( _nlsPath.strrchr( &istrSep, TCH('\\') ) ) ;
	++istrSep ;
	_nlsPath.DelSubStr( istrSep ) ;

	DIR_BLOCK * pAboutToBeDeleteDirBlock = QueryCurrentDirBlock() ;
	delete pAboutToBeDeleteDirBlock ;

	ITER_SL_OF( DIR_BLOCK ) itersldirblock( _slStackOfDirBlocks ) ;
	itersldirblock.Next() ;
	SetCurrentDirBlock( _slStackOfDirBlocks.Remove( itersldirblock ) ) ;
	UIASSERT(  QueryCurrentDirBlock() != NULL ) ;
	_nCurrentDepth-- ;
    }

    return err ;
}

/*******************************************************************

    NAME:	FS_ENUM::QueryName

    SYNOPSIS:	Returns the qualified name of the current file.  The name
		will be based on the path that was passed in to
		the FS_ENUM constructor.

    ENTRY:	pnlsQualifiedName - pointer to NLS_STR that will receive
		    the string

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::QueryName( NLS_STR * pnlsQualifiedName ) const
{
    *pnlsQualifiedName = _nlsPath ;
    ALIAS_STR nlsFileName( QueryCurrentDirBlock()->QueryFileName() ) ;
    *pnlsQualifiedName += nlsFileName ;

    //
    //  If the path ends in a slash, then remove the trailing slash
    //
    ISTR istr1( *pnlsQualifiedName ) ;
    if ( pnlsQualifiedName->strrchr( &istr1, TCH('\\')) )
    {
        ISTR istr2( istr1 ) ;
        ++istr1;
        if ( pnlsQualifiedName->QueryChar( istr1 ) == TCH('\0') )
        {
            pnlsQualifiedName->DelSubStr( istr2 ) ;
        }
    }
    return pnlsQualifiedName->QueryError() ;
}


/*******************************************************************

    NAME:	FS_ENUM::ShouldThisFileBeIncluded

    SYNOPSIS:	Based on the attributes and what the current client
		requested, determine whether this file/dir should be
		returned to the user (i.e., filter unwanted files/dirs).

    ENTRY:	uiAttr - Attribute mask of the file/dir in question

    EXIT:

    RETURNS:	Returns TRUE if this file/dir should be returned to the user,
		FALSE otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::ShouldThisFileBeIncluded( UINT uiAttr ) const
{
    BOOL fRet = FALSE ;

    if ( _filtypInclude == FILTYP_ALL_FILES )
	fRet = TRUE ;
    else if ( uiAttr & _A_SUBDIR )
    {
	fRet = ( _filtypInclude == FILTYP_DIRS ) ;
    }
    else
    {
	fRet = ( _filtypInclude == FILTYP_FILES ) ;
    }

    return fRet ;
}

/*******************************************************************

    NAME:	FS_ENUM::QuerySearchAttr

    SYNOPSIS:	Returns the attribute mask we pass to the findfirst/next
		methods based on what the client wanted

    RETURNS:	Attribute mask that is to be passed to FindFirst.

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT FS_ENUM::QuerySearchAttr( void ) const
{   return ( _filtypInclude==FILTYP_ALL_FILES ? _A_NORMAL | _A_SUBDIR :
	     _filtypInclude==FILTYP_DIRS ? _A_SUBDIR :
	     _filtypInclude==FILTYP_FILES? _A_NORMAL | _A_SUBDIR : 0 ) ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\heap\heapbase.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    HEAPBASE.CXX
    Base classes for both Global and ONE_SHOT_HEAPs.

    Abstract classes for heap operations.  The LOCAL_HEAP classes
    create objects whose memory is allocated from LocalAlloc.
    The BASE_HEAP object is a LOCAL_HEAP which contains a handle
    (selector) for a BUFFER object.


    FILE HISTORY:
	DavidHov    2-25-91	    Created
	beng	    01-May-1991     Uses lmui.hxx

*/

#ifdef WINDOWS

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "locheap2.h"   // Local heap C/ASM routines
}

#include "uiassert.hxx"
#include "heap.hxx"

long LOCAL_HEAP_OBJ::_cLocalFreeErrors = 0 ;


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::QueryBlockSize

    SYNOPSIS:	LOCAL_HEAP_OBJ is a base class for things which
		are allocated from the DS-relative local heap.
		LOCAL_HEAP_OBJ::Size returns the size of a block

    ENTRY:	Pointer to block in question

    EXIT:	Size of block or zero if it could not be converted
		to a handle.

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

USHORT LOCAL_HEAP_OBJ::QueryBlockSize( VOID * pbBlock )
{
    HANDLE hMem = LocalHandle( LOWORD( pbBlock ) ) ;
    return hMem ? LocalSize( hMem ) : 0 ;
}


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::operator new

    SYNOPSIS:	Allocate memory on the local heap.

    ENTRY:	Requires the size of block to be allocated.

    EXIT:	Returns VOID pointer to block allocated.

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

VOID * LOCAL_HEAP_OBJ::operator new( size_t cb )
{
    HANDLE hMem = LocalAlloc( LMEM_FIXED, (USHORT) cb) ;
    if ( hMem )
    {
       return (VOID *) LocalLock( hMem ) ;
    }
    else
    {
       return NULL ;
    }
}


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::operator delete

    SYNOPSIS:	Delete a block allocated on the local heap.

    ENTRY:	Pointer to block

    EXIT:	Nothing

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

VOID LOCAL_HEAP_OBJ::operator delete( VOID * pbBlock )
{
    if ( pbBlock == NULL )
      return ;

    HANDLE hMem = LocalHandle( LOWORD( pbBlock ) ) ;
    if (   hMem == NULL
	 || (LocalUnlock( hMem ) != 0)
	 || (LocalFree( hMem ) != NULL) )
    {
      _cLocalFreeErrors++ ;
    }
}


/**********************************************************************

    NAME:	BASE_HEAP::BASE_HEAP

    SYNOPSIS:	Default constructor for an empty BASE_HEAP.
		Used by MEM_MASTER to represent the DS-relative heap.

    ENTRY:

    EXIT:

    NOTES:
	This constructor is used only for MEM_MASTER,
	and exploits the fact that a BUFFER of zero
	length can be created.	Such a BUFFER has no
	global block associated with it.


    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::BASE_HEAP ( )
    : BUFFER( 0 )
{
    ;
}


/**********************************************************************

    NAME:	BASE_HEAP::BASE_HEAP

    SYNOPSIS:	This constructor is used to create all
		SUB_HEAPs and GIANT_HEAPs.

    ENTRY:	Requires the size of the initial allocation

    EXIT:	Nothing

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::BASE_HEAP ( USHORT cbInitialAllocSize )
     : BUFFER( cbInitialAllocSize )
{
    ;
}


/**********************************************************************

    NAME:	BASE_HEAP::~BASE_HEAP

    SYNOPSIS:	Standard deconstructor.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::~BASE_HEAP ()
{
    ;
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\heap\heapbig.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    HEAPBIG.CXX
    Main methods for Global Heap

       Notes on HEAP classes:
       ----------------------

	The Global Heap memory manager supports the allocation
	of smaller items from several heaps.  This is done by
	chaining a lists of such heaps together.  The heap objects
	themselves are allocated from local heap memory; the
	objects they create are allocated from global memory.

        This code depends upon the BUFFER routines for allocation
        of global memory.  All objects allocated herein must
        come from the local heap, so there is a virtual base
        class called LOCAL_HEAP_OBJ from which all the other
        classes inherit.

	A SUB_HEAP is a single heap object, limited to a 64K
	segment.  Its size is permanently constrained to that
	of its initial allocation, since all objects allocated
	in it are locked. (This could be changed to use BUFFER::Resize.)
        A SUB_HEAP is a BUFFER and a LOCAL_HEAP_OBJ.  That is,
        its instantiation allocates a small block of memory using
        LocalAlloc, and a large block of memory using GlobalAlloc.

	A GIANT_HEAP is a SUB_HEAP which can be extended to include
	more SUB_HEAPs, each of which is identified as being "owned"
	by the GIANT_HEAP. The GIANT_HEAP is "owned" by itself.

	A MEM_MASTER is a GIANT_HEAP which represents the local
	DS-based heap.	It cannot be extended.	There can only be
	one instance of MEM_MASTER, and it is globally available
	through _pmmInstance.  MEM_MASTER allocates through
        the latest created GIANT_HEAP.  Its static constructor creates
        a single GIANT_HEAP, which is all that most programs should
        ever need.

	The primary purpose of this program is to override the
	global "new" and "delete" operators to allocate from a
	GIANT_HEAP. The GIANT_HEAP in use is called the "focus" of
	MEM_MASTER.

	Only after a GIANT_HEAP has been created does allocation
	move outside the boundaries of the Windows DS.	The "focus"
	is automatically set to the base SUB_HEAP of the new GIANT_HEAP.

	The linked list of SUB_HEAPs might look like this:


	SUB_HEAP ---->SUB_HEAP----->SUB_HEAP----->SUB_HEAP----->SUB_HEAP
	GIANT_HEAP    GIANT_HEAP		  GIANT_HEAP	   ^
	MEM_MASTER	   ^			     ^		   |
	 ^ |		   |			     |		   |
	 | >---------------+-------------------------+-------------^
	 |  pointer to     |                         |
	 |  "focussed"	   |			     >--GIANT_HEAP
	 |  SUB_HEAP	   |				allocated by
	 |		   |				user
	 >--GIANT_HEAP	   >--GIANT_HEAP
	    representing      using Global
	    DS heap	      memory, allocated by MEM_MASTER's
			      static constructor


	Maintenance of the linked list and the focus pointer
	is automatic in class SUB_HEAP.

	When focus is set to a SUB_HEAP of a GIANT_HEAP other than
	MEM_MASTER (the normal case), allocation requests are routed
	to the GIANT_HEAP by ::new. It follows the chain of SUB_HEAPs,
	checking every SUB_HEAP it owns for one which has never
	denied a request for the amount of memory being sought.
	If it doesn't find such a SUB_HEAP, it allocates a new one.
	Maintenance of the "_cbLargestFailed" field in a SUB_HEAP is
	automatic, and is reset upon deallocation of a block larger
	than or equal to "_cbLargestFailed".

	In this same situation (focus is on a normal GIANT_HEAP),
	requests from ::delete are routed first to MEM_MASTER, which
	searches every SUB_HEAP for the SUB_HEAP whose selector matches
	the selector of the block about to be deallocated.  If
	it doesn't find one, it increments "_lcDeallocErrors".  The
	same thing happens if the caller should use GIANT_HEAP::Free(),
	but this is not a common case.

	These data structures have provisions for multiple GIANT_HEAPs;
	this is primarily to support the notion of "one-shot" heaps
	and other, possibly less expensive, allocation techniques.

	Debugging code and memory leak detection can also be done with
	GIANT_HEAPs.  If an outer "shell" program is using the normal
	GIANT_HEAP and is about to call a large separate phase, it can
	allocate a separate GIANT_HEAP.  All allocations in the new
	phase will automatically occur there, and upon return, the
	new GIANT_HEAP should be entirely empty.  If not, there was
	a leak during the phase.  Future enhancments could include
	discarding of entire SUB_HEAPs or even GIANT_HEAPs to protect
	programs from memory leaks or simplify error handling.


    USAGE IN DLLs and EXEs

	Due to the peculiar restrictions placed by Windows on memory
	management, there are two modes of initializing the MEM_MASTER
	object: DLL and non-DLL.  In non-DLL mode, everything is done
	as documented aboved and as one would reasonably expect.

	In DLL mode, the MEM_MASTER::InitForDll() routine is called.
	This routines allocates a parameterizable number of SUB_HEAPs
	of minimum size.  Because SUB_HEAPs are based on LocalAlloc
	behavior, they are automatically grown by Windows to the limits
	of the segment size within the operational mode.

	The reason for the preallocation is that DLLs are called with
	task identity of the calling task.  Therefore, new GlobalAlloc
	calls (done during BUFFER object construction) unfortunately
	belong to the calling task, and will be deallocated when the
	calling task terminates.  This behavior would be catastrophic for
	MEM_MASTER.

	The MEM_MASTER::InitForDll() routine is intended to be called
	during LIBENTRY processing of such DLLs as LANMAN.DRV.	In this
	special case, LANMAN.DRV is called by the Windows shell; memory
	is thus owned by the shell, which persists until Windows is
	terminated.


    REAL MODE WARNING!

	All sophistication is suppressed in real mode. GlobalAlloc
	and GlobalFree are used.  Only ::new and ::delete are supported.

    FILE HISTORY:
	DavidHov 01-Apr-1991	Created

	Johnl	27-Mar-1991	Changed Realmode GlobalAlloc flag from
				GMEM_FIXED to GMEM_MOVEABLE (was failing under
				real mode).
	ChuckC  31-Mar-1991     Added temporary GMEM_NODISCARD to above fix!
	ChuckC  12-Apr-1991     Made GlobalAlloc in real mode as _fmalloc does.
				FIXED and NODISCARD!

	DavidHov 28-Apr-1991	Modifications from code review

	KeithMo	08-Nov-1991	Added WIN32 support.

	DavidHov  1-14-92	Change SUB_HEAP destructor to NOT
				call Unlink() for invalid SUB_HEAPs. When
				system ran entirely out of memory,  attempt
				to unlink caused page fault.

				Added the ability to walk heaps through
				the Walk() members.  If HEAPDEBUG is
				defined, Walk() is functional.	This
				capability requires TOOLHELP.DLL.

   */

#if defined( WINDOWS ) && !defined( WIN32 )

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif


extern "C"
{
    #include "locheap2.h"	// Local heap C/ASM routines
}

#include "heap.hxx"
//  #define HEAPDEBUG		//  Uncomment to activate Walk() members
#include "heapdbg.hxx"

#ifdef HEAPDEBUG
extern "C"
{
    #include <toolhelp.h>	//   Win 3.1 SDK defs for TOOLHELP.DLL
}
#endif


#define MAXUSHORT ((USHORT) 65535)

#define HEAP_INIT_ALLOC_EXE 16000    /*  Heaps grow automatically   */
#define HEAP_INIT_ALLOC_DLL 500
#define HEAP_RESIZE_ALLOC   1000

MEM_MASTER * SUB_HEAP::_pmmInstance = NULL ;

BOOL fHeapRealMode = FALSE ;


/*******************************************************************

    NAME:	SUB_HEAP::SUB_HEAP

    SYNOPSIS:	SUB_HEAP default constructor

    NOTES:
	Used by MEM_MASTER only to describe data segment.
	Parameterless constructor is only possible for DS.
	BUFFER class supports construction of a zero-length
	buffer.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP::SUB_HEAP()
   : BASE_HEAP(),
   _cBlksOut( 0 ),
   _cbLargestFailed( MAXUSHORT ),
   _pOwner( NULL ),
   _lcDeallocErrors( 0 )
{
    _type = SHt_DS ;
    LockSegment( MAXUSHORT ) ;	// Lock data segment
    Init();
}


/*******************************************************************

    NAME:	SUB_HEAP::SUB_HEAP

    SYNOPSIS:	Normal SUB_HEAP constructor

    ENTRY:	USHORT -- amount of initial allocation for
			  SUB_HEAP BUFFER object.

    EXIT:

    RETURNS:

    NOTES:
	This is the normal SUB_HEAP constructor used
	for every SUB_HEAP except the initial MEM_MASTER.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP::SUB_HEAP( USHORT cbInitialAllocSize )
    : BASE_HEAP( cbInitialAllocSize ),
    _cBlksOut( 0 ),
    _cbLargestFailed( MAXUSHORT ),
    _pOwner( NULL ),
    _lcDeallocErrors( 0 )
{
    if (   QuerySize() >= cbInitialAllocSize
	&& DoLocalInit( QuerySel(), (USHORT) QuerySize() ) )
    {
       _type = SHt_Normal ;
       Init();
    }
    else
    {
       _type = SHt_Invalid ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::Init

    SYNOPSIS:	Common initialization for a SUB_HEAP
		Initialize the instance variables.  The owner pointer
		is set to self by default.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Init()
{
   Link();
}


/*******************************************************************

    NAME:	SUB_HEAP::Link

    SYNOPSIS:	Inserted the SUB_HEAP onto the linked list
		whose anchor is pointed to by _pmmInstance.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	If _pmmInstance is NULL, this is the construction
	of MEM_MASTER.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Link()
{
    //	Control linkage onto the _pmmInstance list.  Note
    //	that this may be the initialization of MEM_MASTER.

    if ( _pmmInstance != NULL )
    {
       _pBack = _pmmInstance->_pBack ;
       _pFwd = _pmmInstance ;
       _pFwd->_pBack = this ;
       _pBack->_pFwd = this ;
       _pmmInstance->SetFocus( this ) ;
    }
    else
    {  // MEM_MASTER initialization
       _pFwd = _pBack = this ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::Unlink

    SYNOPSIS:	Remove the SUB_HEAP from the linked list attached
		to MEM_MASTER.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Unlink()
{
    SUB_HEAP * pSub ;

    _pFwd->_pBack = _pBack ;
    _pBack->_pFwd = _pFwd ;
    _pBack = _pFwd = this ;

    //	Check to see if this is the focussed SUB_HEAP. If so,
    //	refocus MEM_MASTER to another SUB_HEAP or GIANT_HEAP
    //	(including, possibly, itself).

    if ( _pmmInstance->GetSubFocus() == this )
    {
	if (   _pOwner == NULL	 //  Construction failure
	    || (pSub = _pOwner->QueryLatest()) == NULL )
	{
	   pSub = _pmmInstance->_pBack ;
	}
	_pmmInstance->SetFocus( pSub ) ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::~SUB_HEAP

    SYNOPSIS:	SUB_HEAP Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	There is a single SHt_DS type SUB_HEAP, namely,
	MEM_MASTER. The others are normal.  Normal
	SUB_HEAPs are deallocated by their BUFFER
	destructors.

    HISTORY:
	davidhov    01-Apr-1991     Created
	DavidHov    01-18-92	    Changed to not call Unlink()
				    unless sucessfully constructed.

********************************************************************/

SUB_HEAP::~SUB_HEAP()
{
    switch ( _type )
    {
    case SHt_DS:
	UnlockSegment( MAXUSHORT ) ; // Unlock DS (see constructor)
    case SHt_Normal:
	Unlink();		     // Delink this SUB_HEAP
    case SHt_Invalid:
	break ; 		     // Didn't construct-- do nothing
    default:
	UIASSERT( ! "Invalid memory heap destroyed" ) ;
	break ;
    }
    _type = SHt_Invalid ;
}


/*******************************************************************

    NAME:	SUB_HEAP::QueryOwner

    SYNOPSIS:	Return a pointer to the owning GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:	GIANT_HEAP * --> owner of this SUB_HEAP.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP * SUB_HEAP::QueryOwner()
{
    return _pOwner ;
}


/*******************************************************************

    NAME:	SUB_HEAP::Alloc

    SYNOPSIS:	Allocate memory in a SUB_HEAP

    ENTRY:	Amount of memory to allocate and flags.

    EXIT:	NULL if failure

    RETURNS:	BYTE * --> memory allocated

    NOTES:
	Flags are passed to DoLocalAlloc, but they
	are unused anywhere.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * SUB_HEAP::Alloc( USHORT cbBytes, USHORT fsFlags )
{
   BYTE * lpsResult = NULL ;
   HANDLE hand ;

   switch ( _type )
   {
   case SHt_DS:
      lpsResult = (BYTE *) LOCAL_HEAP_OBJ::operator new( cbBytes ) ;
      break ;
   case SHt_Normal:
      hand = DoLocalAlloc( QuerySel(), fsFlags, cbBytes ) ;
      if ( hand )
      {
	  lpsResult = (BYTE *) DoLocalLock( QuerySel(), hand ) ;
      }
      break ;
   default:
   case SHt_Invalid:
      UIASSERT( ! SZ("Attempt to allocate from invalid heap") );
      return NULL ;
      break ;
   }

   if ( lpsResult ) {
       _cBlksOut++ ;
   }
   else
   {
       if ( cbBytes < _cbLargestFailed )
	   _cbLargestFailed = cbBytes ;
   }
   return lpsResult ;
}


/*******************************************************************

    NAME:	SUB_HEAP::QueryBlockSize

    SYNOPSIS:	Returns the size of a previously allocated block

    ENTRY:	BYTE * --> block

    EXIT:	USHORT size of block or zero if block does not
		belong to this SUB_HEAP.

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT SUB_HEAP::QueryBlockSize( BYTE * pbBlock )
{
    HANDLE hMem ;
    USHORT cbSize ;

    switch ( _type )
    {
    case SHt_DS:
       cbSize = LOCAL_HEAP_OBJ::QueryBlockSize( pbBlock ) ;
       break ;
    case SHt_Normal:
       hMem = DoLocalHandle( QuerySel(), LOWORD( pbBlock ) ) ;
       if ( hMem )
       {
	  cbSize = hMem ? DoLocalSize( QuerySel(), hMem ) : 0 ;
       }
       break ;
    default:
    case SHt_Invalid:
       UIASSERT( ! SZ("Attempt to QuerySize on invalid block") );
       cbSize = 0 ;
       break ;
    }
    return cbSize ;
}


/*******************************************************************

    NAME:	SUB_HEAP::Free

    SYNOPSIS:	Release memory allocated in this SUB_HEAP

    ENTRY:	BYTE * --> memory block

    EXIT:

    RETURNS:	TRUE if block belonged to this heap.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL SUB_HEAP::Free( BYTE * pbBlock )
{
    HANDLE hand ;
    BOOL fResult ;

    switch ( _type )
    {
    case SHt_DS:
	fResult = TRUE ;
	LOCAL_HEAP_OBJ::operator delete( pbBlock ) ;
	break ;
    case SHt_Normal:
	hand = DoLocalHandle( QuerySel(), LOWORD( pbBlock ) ) ;
	if ( fResult = (hand != NULL) )
	{
	   DoLocalUnlock( QuerySel(), hand );
	   hand = DoLocalFree( QuerySel(), hand ) ;
	}
	break ;
    case SHt_Invalid:
    default:
	UIASSERT( ! SZ("Attempt to Free invalid block") );
	return FALSE ;
	break ;
    }

    if ( fResult )
    {
	_cbLargestFailed = MAXUSHORT ;
	_cBlksOut-- ;
    }
    else
    {
	_lcDeallocErrors++ ;
    }
    return fResult ;
}


/*******************************************************************

    NAME:	SUB_HEAP::CalcDeallocErrors

    SYNOPSIS:	Calculate (return) number of deallocation errors

    ENTRY:

    EXIT:

    RETURNS:	ULONG number of deallocation errors against this
		SUB_HEAP

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG SUB_HEAP::CalcDeallocErrors()
{
    return _lcDeallocErrors ;
}

/*******************************************************************

    NAME:	SUB_HEAP::Walk

    SYNOPSIS:	DEBUGGING:  Walk the heap using the TOOLHELP routines.

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	BOOL TRUE if heap is in good condition.

    NOTES:	If HEAPDEBUG is not set, will always return TRUE.

    HISTORY:

********************************************************************/
BOOL SUB_HEAP :: Walk ()
{
    BOOL fResult = TRUE ;

#ifdef HEAPDEBUG

    LOCALENTRY leHeap, lePrior ;
    LOCALINFO  liHeap ;
    union {
	HEAPTAG * phtNext ;
	struct {
	    USHORT offs, seg ;
	} addr ;
    } up ;
    int cItems ;

    //	Initialize the data structures.
    liHeap.dwSize = sizeof liHeap ;
    leHeap.dwSize = sizeof leHeap ;

    //	Get basic information about the heap
    fResult = ::LocalInfo( & liHeap, QuerySel() ) ;

    if ( ! fResult ) return FALSE ;

    //	Walk across every item
    BOOL fNext = ::LocalFirst( & leHeap, QuerySel() ) ;

    for ( cItems = 1 ; fNext ; cItems++ )
    {
	up.addr.offs = leHeap.wAddress ;
	up.addr.seg = QuerySel() ;
	//  HEAPTAG * up.phtNext is now valid.
	lePrior = leHeap ; // Save last descriptor.
	fNext = ::LocalNext( & leHeap ) ;
    }

#endif

    return fResult ;
}

/*******************************************************************

    NAME:	GIANT_HEAP::GIANT_HEAP

    SYNOPSIS:	Implicit constructor for a GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Implicit private constructor : used by
	MEM_MASTER only.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::GIANT_HEAP()
    : _cbInitAlloc( 0 ),
    _fsBehave( 0 ),	//  No fancy behavior for DS default GIANT_HEAP
    _cExpandErrors( 0 )
{
    _pOwner = this ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::GIANT_HEAP

    SYNOPSIS:	Normal GIANT_HEAP constructor

    ENTRY:	USHORT size to use for initial allocation of
		SUB_HEAPs

    EXIT:

    RETURNS:

    NOTES:
	Public constructor.  Default behavior is set to
	extend (add new SUB_HEAPs) when necessary and resize
	(downsize) SUB_HEAPs when empty.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::GIANT_HEAP( USHORT cbInitialAllocation )
    : SUB_HEAP( cbInitialAllocation )
{
    _pOwner = this ;
    _cbInitAlloc = cbInitialAllocation ;
    _fsBehave = GHbExtend | GHbResize ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::~GIANT_HEAP

    SYNOPSIS:	Destroy a GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Release all the SUB_HEAPs but this one; internal
	BUFFER object will be automatically deconstructed
	at exit (via ~SUB_HEAP).

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::~GIANT_HEAP()
{
    SUB_HEAP * pSheap ;
    SUB_HEAP * pSnext ;

    //	Deconstruct all of our SUB_HEAPS

    for ( pSnext = _pFwd ;
	  pSnext != _pmmInstance ; )
    {
	pSheap = pSnext ;
	pSnext = pSnext->_pFwd ;
	if ( pSheap->_pOwner == this )
	{
	    delete pSheap ;
	}
    }
}


/*******************************************************************

    NAME:	GIANT_HEAP::GrowAndAlloc

    SYNOPSIS:	Add another SUB_HEAP to the ensemble.

    ENTRY:	USHORT count of bytes to be added;
		USHORT allocation flags (unused)

    EXIT:	NULL if error

    RETURNS:	BYTE * --> memory allocated

    NOTES:
	This routine creates another SUB_HEAP owned
	by this GIANT_HEAP.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * GIANT_HEAP::GrowAndAlloc( USHORT cbBytes, USHORT fsFlags )
{
    // See if the requested size is larger than the previous
    // initial allocation.  If so, change initial allocation.

    if ( _cbInitAlloc > cbBytes )
       cbBytes = _cbInitAlloc ;

    // Create a new SUB_HEAP...

    SUB_HEAP * pSub = new SUB_HEAP( cbBytes ) ;
    if ( pSub == NULL || pSub->_type == SHt_Invalid )
    {
      _cExpandErrors++ ;
      if ( pSub ) {
	 delete pSub ;
      }
      return NULL ;
    }

    pSub->_pOwner = this ;
    return pSub->Alloc( cbBytes, fsFlags ) ;

}


/*******************************************************************

    NAME:	GIANT_HEAP::SetBehavior

    SYNOPSIS:	Control the behavior of a GIANT_HEAP

    ENTRY:	USHORT flag to adjust
		BOOL, set ON if TRUE

    EXIT:

    RETURNS:	BOOL, original value of behavior flag.

    NOTES:
	There are three behavior variables:

	    GHbExtend : allow extensions (new SUB_HEAPs)
	    GHbDelete : delete SUB_HEAPS when empty
	    GHbResize : resize the directory to a small
			value when empty.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL GIANT_HEAP::SetBehavior( USHORT fFlag, BOOL fOnOff )
{
    BOOL fResult = (_fsBehave & fFlag) > 0 ;
    _fsBehave &= ~ fFlag ;
    if ( fOnOff ) {
	_fsBehave |= fFlag ;
    }
    return fResult ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::QueryLatest

    SYNOPSIS:	Return a pointer to the latest SUB_HEAP

    ENTRY:

    EXIT:

    RETURNS:	SUB_HEAP * --> newest SUB_HEAP in the ensemble

    NOTES:
	Return a pointer to the newest SUB_HEAP associated with this
	GIANT_HEAP.  Note that when called by SUB_HEAP deconstructor,
	"this" GIANT_HEAP may not be in the linked list any longer.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP * GIANT_HEAP::QueryLatest()
{
   SUB_HEAP * pSnext ;
   for ( pSnext = _pmmInstance->_pBack ;
	 pSnext != _pmmInstance && pSnext->_pOwner != this ;
	 pSnext = pSnext->_pBack )
	;

   return (pSnext != _pmmInstance) ? pSnext : NULL ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::Alloc

    SYNOPSIS:	Allocate memory in a GIANT_HEAP

    ENTRY:

    EXIT:	NULL if no memory

    RETURNS:	BYTE * --> new memory

    NOTES:
	Searches the link list to its end trying
	to locate a SUB_HEAP which has never denied an
	allocation of this size.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * GIANT_HEAP::Alloc( USHORT cbBytes, USHORT fsFlags )
{
    //	Find a likely SUB_HEAP from which to allocate.	If none is found,
    //	add another. Note that we may be MEM_MASTER.

    SUB_HEAP * pSub = this ;
    BYTE * pbBlock = NULL ;

    do
    {
       // The qualification SUB_HEAP:: below is necessary; otherwise
       // Alloc() would be a recursive call back to this routine in
       // the case of the base GIANT_HEAP/SUB_HEAP.

	if ( pSub->_pOwner == this && pSub->_cbLargestFailed >= cbBytes )
	{
	   pbBlock = pSub->SUB_HEAP::Alloc( cbBytes, fsFlags ) ;
	}
	if ( pbBlock )
	{
	  break ;
	}
	pSub = pSub->_pFwd ;
    }
    while ( pSub != _pmmInstance ) ;

    if ( (pbBlock == NULL) && (_fsBehave & GHbExtend) )
    {
	pbBlock = GrowAndAlloc( cbBytes, fsFlags );
    }

    return pbBlock ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::Free

    SYNOPSIS:	Release memory allocated by GIANT_HEAP::Alloc

    ENTRY:	BYTE * --> memory block

    EXIT:

    RETURNS:	TRUE if memory block belonged to a SUB_HEAP of
		this GIANT_HEAP.

    NOTES:
	Search the SUB_HEAPs of this GIANT_HEAP for the
	owner of this block, then give it to the SUB_HEAP
	for disposal.  Accumulate any error totals into
	our SUB_HEAP variables.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL GIANT_HEAP::Free( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    BOOL fFound = FALSE ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    do {
       if ( pSnext->_pOwner == this
	    && selBlock == pSnext->QuerySel() )
       {
	  fFound = TRUE ;
	  break ;
       }
       pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    // If found, give it to owning SUB_HEAP to be freed.
    // The qualification SUB_HEAP:: is necessary; otherwise Free()
    // would be a recursive call back to this routine in the case
    // of the base GIANT_HEAP itself.

    if ( fFound )
    {
       pSnext->SUB_HEAP::Free( pbBlock ) ;
       if ( pSnext->_cBlksOut == 0 )
       {
	  if (	(_fsBehave & GHbDelete)
	      && pSnext != this )
	  {
	      _lcDeallocErrors += pSnext->CalcDeallocErrors() ;
	      delete pSnext ;
	  }
	  else if ( _fsBehave & GHbResize )
	  {
	     //  Attempt to resize.  If Resize or LocalInit fails,
	     //  delete the degenerate subheap.

	     if (     pSnext->Resize( HEAP_RESIZE_ALLOC ) != 0
		  ||  (! DoLocalInit( pSnext->QuerySel(),
				 (USHORT) pSnext->QuerySize() ) ) )
		 delete pSnext ;
	  }
       }
       return TRUE ;

    }
    else
	return FALSE ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::CalcDeallocErrors

    SYNOPSIS:	Walk thru the SUB_HEAPs and tally the deallocation
		failures

    ENTRY:

    EXIT:	ULONG count of all deallocation failures

    RETURNS:

    NOTES:
	Iterate through the ensemble and total the errors
	The GIANT_HEAP variable _lcDeallocErrors has accumulated
	all the errors from deleted SUB_HEAPs.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG GIANT_HEAP::CalcDeallocErrors()
{
    SUB_HEAP * pSnext = this ;
    ULONG cTotalErrors = 0 ;

    do
    {
	cTotalErrors += pSnext->_lcDeallocErrors ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    return cTotalErrors ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::QueryTotalBlocks

    SYNOPSIS:	Walk thru the SUB_HEAPs, tallying outstanding
		blocks.

    ENTRY:

    EXIT:	ULONG count of blocks active

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG GIANT_HEAP::QueryTotalBlocks()
{
    SUB_HEAP * pSnext = this ;
    ULONG cTotalBlocks = 0 ;

    do
    {
	cTotalBlocks += pSnext->_cBlksOut ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    return cTotalBlocks ;

}


/*******************************************************************

    NAME:	MEM_MASTER::MEM_MASTER

    SYNOPSIS:	Create MEM_MASTER

    ENTRY:	USHORT initial allocation size for default
		GIANT_HEAP

    EXIT:

    RETURNS:

    NOTES:
	Initialize MEM_MASTER and create the first (and
	probably only) GIANT_HEAP if the initial allocation
	size is non-zero.  N.B. _pmmInstance is initialized
	here because the allocation of a GIANT_HEAP relies
	on this value being set.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

MEM_MASTER::MEM_MASTER( USHORT cbInitAlloc )
    : GIANT_HEAP()
{
    GIANT_HEAP * pGheap ;

    UIASSERT( _pmmInstance == NULL ) ;

    _pmmInstance = this ;
    _pFocus = this ;

    if ( cbInitAlloc )
    {
	if ( pGheap = new GIANT_HEAP( cbInitAlloc ) )
	{
	    _pFocus = pGheap ;
	}
    }
}


/*******************************************************************

    NAME:	MEM_MASTER::Init

    SYNOPSIS:	(static) Construct and initialize MEM_MASTER

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Initialization for a normal EXE. If real mode,
	just set the flag and exit.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Init()
{
    ::fHeapRealMode = (GetWinFlags() & WF_PMODE) == 0 ;

    if ( ::fHeapRealMode )
	return TRUE ;

    new MEM_MASTER( (USHORT) HEAP_INIT_ALLOC_EXE ) ;

    // Construction of MEM_MASTER loads _pmmInstance.

    if ( _pmmInstance == NULL )
    {
	UIASSERT( ! SZ("Global heap construction failure") );
    }

    return _pmmInstance != NULL ;

}


/*******************************************************************

    NAME:	MEM_MASTER::InitForDll

    SYNOPSIS:	(static) Construct and initialize MEM_MASTER
		for operation in a DLL.

    ENTRY:

    EXIT:	TRUE if initialization was successful.

    RETURNS:

    NOTES:
	Initialization for a DLL.  Preallocate the
	requested number of SUB_HEAPs.	This is only
	guaranteed to work so long as the original
	app loaded the DLL remains alive!

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::InitForDll( int cPreallocHeaps )
{
    ::fHeapRealMode = (GetWinFlags() & WF_PMODE) == 0 ;
    if ( ::fHeapRealMode )
      return TRUE ;

    new MEM_MASTER( HEAP_INIT_ALLOC_DLL ) ;

    // Construction of MEM_MASTER loads _pmmInstance.

    if ( _pmmInstance == NULL )
    {
	UIASSERT( ! SZ("Global heap construction failure") );
	return FALSE ;
    }

    GIANT_HEAP * pGheap = _pmmInstance->GetGiantFocus() ;

    pGheap->SetDeleteOnEmpty( FALSE ) ;
    pGheap->SetExtendOnFull( FALSE ) ;
    pGheap->SetResizeOnEmpty( TRUE ) ;

    //	Force the GIANT_HEAP to create the requested number
    //	of preallocated SUB_HEAPs.  Remember that it is also
    //	a SUB_HEAP; that's why the count starts at 1.

    for ( int i = 1 ; i < cPreallocHeaps ; i++ ) {
	 BYTE * lpsTemp = pGheap->GrowAndAlloc( HEAP_INIT_ALLOC_DLL / 4 ) ;
	 if ( lpsTemp == NULL )
	 {
	   break ;
	 }
	 pGheap->Free( lpsTemp ) ;
    }

    return TRUE ;

}


/*******************************************************************

    NAME:	MEM_MASTER::Term

    SYNOPSIS:	Destroy MEM_MASTER, release hostages

    ENTRY:

    EXIT:	TRUE if all blocks/heaps deallocated properly

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Term()
{
    ULONG cResidue ;

    if ( ::fHeapRealMode )
    {
	return TRUE ;
    }

    if ( _pmmInstance == NULL )
    {
	return FALSE ;	 /*  Never initialized or init failed  */
    }

    if ( cResidue = _pmmInstance->QueryTotalBlocks() )
	HeapResidueIter() ;

    delete _pmmInstance ;
    _pmmInstance = NULL ;

    return cResidue == 0 ;

}


/*******************************************************************

    NAME:	MEM_MASTER::~MEM_MASTER

    SYNOPSIS:	Desctructor for MEM_MASTER.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Iterates through GIANT_HEAPs wielding death at
	every step.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

MEM_MASTER::~MEM_MASTER()
{
    //	Deconstruct all of the (other) GIANT/SUB_HEAPS

    while ( this->_pFwd != this )
    {
	UIASSERT( this->_pFwd->_pOwner == this->_pFwd ) ;
        delete (GIANT_HEAP *) this->_pFwd ;
    }
}


/*******************************************************************

    NAME:	MEM_MASTER::Alloc

    SYNOPSIS:	Allocate memory from MEM_MASTER

    ENTRY:	USHORT count of bytes desired;
		USHORT flags (unused)

    EXIT:	BYTE * --> memory allocated

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * MEM_MASTER::Alloc ( USHORT cbBytes, USHORT fsFlags )
{
    BYTE * lpsResult = NULL ;

    UIASSERT( !::fHeapRealMode );

    //	Allocate from the GIANT_HEAP which as focus.  Note that a SUB_HEAP
    //	may currently have focus, so dereference through it.
    //	Due to virtualization, the qualification GIANT_HEAP:: is necessary.

    if ( _pFocus )
    {
       lpsResult = _pFocus->_pOwner->GIANT_HEAP::Alloc( cbBytes, fsFlags ) ;
    }
    return lpsResult ;

}


/*******************************************************************

    NAME:	MEM_MASTER::Free

    SYNOPSIS:	Release a block of memory.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Search all the GIANT_HEAPs for the owner of
	this block. If found, pass it on; otherwise,
	return FALSE.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Free( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    BOOL fFound = FALSE ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    UIASSERT( !::fHeapRealMode );

    do
    {
       if ( selBlock == pSnext->QuerySel() ) {
	  return pSnext->_pOwner->GIANT_HEAP::Free( pbBlock ) ;
       }
       pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;

    return FALSE ;

}


/*******************************************************************

    NAME:	MEM_MASTER::QueryBlockSize

    SYNOPSIS:	Given a pointer to a block, return its size.

    ENTRY:

    EXIT:	zero if block was not allocated by MEM_MASTER.

    RETURNS:	USHORT size of block

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT MEM_MASTER::QueryBlockSize( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    UIASSERT( !::fHeapRealMode );

    do
    {
      if ( selBlock == pSnext->QuerySel() )
	 return pSnext->QueryBlockSize( pbBlock ) ;
    }
    while ( (pSnext = pSnext->_pFwd) != this ) ;

    return 0 ;

}


/*******************************************************************

    NAME:	MEM_MASTER::GrowAndAlloc

    SYNOPSIS:	Null method; MEM_MASTER itself cannot grow.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * MEM_MASTER::GrowAndAlloc( USHORT cbBytes, USHORT fsFlags )
{
    UNREFERENCED( cbBytes ) ;
    UNREFERENCED( fsFlags ) ;
    return NULL ;
}


/*******************************************************************

    NAME:	MEM_MASTER::SetFocus

    SYNOPSIS:	Set allocation focus on the SUB_HEAP given.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Creation of a GIANT_HEAP automatically sets the
	focus to it; destruction set the focus to the
	nearest other GIANT_HEAP.  This routine can be
	used to switch from a newly allocated GIANT_HEAP
	to an earlier one; even to MEM_MASTER, in which
	case allocation would be done with LocalAlloc!

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::SetFocus( SUB_HEAP * pSubHeap )
{
    _pFocus = pSubHeap ;
    return TRUE ;
}


/*******************************************************************

    NAME:	MEM_MASTER::GetGiantFocus

    SYNOPSIS:	Return a pointer to the GIANT_HEAP which has focus

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP * MEM_MASTER::GetGiantFocus()
{
    return _pFocus->_pOwner ;
}


/*******************************************************************

    NAME:	MEM_MASTER::GetSubFocus

    SYNOPSIS:	Return a pointer to the focused SUB_HEAP.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP * MEM_MASTER::GetSubFocus()
{
    return _pFocus ;
}


/*******************************************************************

    NAME:	MEM_MASTER::QueryTotalHeaps

    SYNOPSIS:	Return the number of heaps alive.

    ENTRY:

    EXIT:

    RETURNS:	USHORT count of all heaps.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT MEM_MASTER::QueryTotalHeaps()
{
    SUB_HEAP * pSnext = this ;
    int cHeaps = 0 ;

    do
    {
	cHeaps++ ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;
    return cHeaps ;
}


/*******************************************************************

    NAME:	MEM_MASTER::QueryTotalBlocks

    SYNOPSIS:	Return the total number of all blocks outstanding

    ENTRY:

    EXIT:

    RETURNS:	ULONG count of blocks.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG MEM_MASTER::QueryTotalBlocks()
{
    SUB_HEAP * pSnext = this ;
    ULONG cBlocks = 0 ;

    do
    {
	cBlocks += pSnext->_cBlksOut ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;

    return cBlocks ;
}



BOOL MEM_MASTER :: Walk ()
{
    BOOL fResult = TRUE ;

#ifdef HEAPDEBUG
    SUB_HEAP * pshNext ;
    for ( pshNext = this->_pFwd ;	//  Skip the DS-based heap
	  fResult && pshNext != this ;
	  pshNext = pshNext->_pFwd )
    {
       fResult = pshNext->Walk() ;
    }

#endif
    return fResult ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\heap\heapif.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/
/*
    HEAPIF.CXX:  ALLOC_BASE operators new and delete.

    All NETUI objects virtually inherit from ALLOC_BASE, which
    consists of only an "operator new" and an "operator delete".

    These routines allow debug builds to track memory leaks and
    report them to the debugger via ::OutputDebugString().

    In free or retail builds, the operators directly call
    ::malloc() and ::free().

    FILE HISTORY:
        DavidHov   10/26/93     Created to replace older version
                                of HEAPIF.CXX.

 */

#include "ntincl.hxx"

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"

#include "uiassert.hxx"
#include "uitrace.hxx"

extern "C"
{
    #include <stdlib.h>
    #include <malloc.h>
}

  //  Mark each block to trap bogus pointers quickly.

#define HEAPTAG_SIGNATURE   0xFEEDBAAC

struct HEAPTAG ;                //  Forward declaration

#if defined(DEBUG)

#  define HEAPDEBUG             //  Debugging only

#  include "heapdbg.hxx"        //  Include the preamble definition

  extern HEAPTAG * pHeapBase ;  //  Anchor of linked list of alloc'd blocks
                                //  see HEAPRES.CXX

  //  Semaphore used to control access to "pHeapBase" in
  //  multi-threaded applications.

  static HANDLE hHeapTrackSema4 = NULL ;

#  define NETUI_HEAP_NEW    NetuiHeapNew
#  define NETUI_HEAP_DELETE NetuiHeapDelete

#else

#  undef HEAPDEBUG              //  Force heap debugging off if non-debug

#  define NETUI_HEAP_NEW    ::malloc
#  define NETUI_HEAP_DELETE ::free

#endif


#if defined(DEBUG)
//
//    NetuiHeapNew and NetuiHeapDelete:   Special
//      heap monitoring functions used as the basis for BASE
//      and LM_OBJ.  If HEAPDEBUG is defined, items are link-listed
//      together. along with size, signature and stack back-trace
//      information.
//
void * NetuiHeapNew ( size_t cb )
{
    void * pvResult ;

#ifdef HEAPDEBUG
    cb += sizeof (struct HEAPTAG) ;
#endif

    pvResult = (void *) ::malloc( cb );

#ifdef HEAPDEBUG
    if ( pvResult )
    {
	if ( hHeapTrackSema4 == NULL )
	{
	    //
	    //	Initialize if necessary
	    //
	    hHeapTrackSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ) ;
	    if ( hHeapTrackSema4 == NULL )
	    {
		//
		// Hmmm, Something is really wrong if we can't create a simple
		// semaphore
		//
		UIASSERT( FALSE ) ;
	    }
	}

	//
	//  We should never have to wait this long
	//
	switch ( ::WaitForSingleObject( hHeapTrackSema4, 30000 ) )
	{
	case 0:
	    break ;

	default:
	    UIASSERT( FALSE ) ;
	} ;


        HEAPTAG * pht = (HEAPTAG *) pvResult ;
        pht->_uSignature = HEAPTAG_SIGNATURE ;
        pht->_usSize = cb - sizeof (struct HEAPTAG) ;

#if i386 && !FPO
        ULONG hash;

        pht->_cFrames =
                (UINT)::RtlCaptureStackBackTrace( 1,
                                                  RESIDUE_STACK_BACKTRACE_DEPTH,
                                                  pht->_pvRetAddr,
                                                  &hash );
#else
        pht->_cFrames = 0;
#endif
        pht->Init() ;
        if ( pHeapBase )
           pht->Link( pHeapBase ) ;
        else
           pHeapBase = pht ;
	pvResult = (void *) ((char *) pvResult + sizeof (struct HEAPTAG)) ;

	REQUIRE( ::ReleaseSemaphore( hHeapTrackSema4, 1, NULL )) ;
    }
#endif

    return pvResult ;

}   // new


void NetuiHeapDelete ( void * p )
{
    if( p != NULL )
    {
#ifdef HEAPDEBUG

        p = (void *) ((char *) p - sizeof (struct HEAPTAG)) ;
        HEAPTAG * pht = (HEAPTAG *) p ;

        if ( pht->_uSignature != HEAPTAG_SIGNATURE )
        {
           ::OutputDebugString(SZ("Bogus pointer passed to operator delete"));
           ::DebugBreak() ;
        }

        if ( pht == pHeapBase )
        {
            if ( (pHeapBase = pht->_phtLeft) == pht )
                pHeapBase = NULL ;
        }
        pht->Unlink() ;

#endif

        ::free( p );
    }

}   // delete

#endif


void * ALLOC_BASE :: operator new ( size_t cbSize )
{
    return NETUI_HEAP_NEW( cbSize ) ;
}

void * ALLOC_BASE :: operator new ( size_t cbSize, void * p )
{
    (void)cbSize;
    return p ;
}

void ALLOC_BASE :: operator delete ( void * p )
{
    NETUI_HEAP_DELETE( p ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\heap\heapres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    HEAPRES.CXX
    Heap residue output routine.

    The function in this file iterates over the unfree blocks
    from "operator new" and formats them onto the debug output stream.

    FILE HISTORY:
        DavidHov    11/21/91    Created
        beng        25-Mar-1992 Updated for Win32
        KeithMo     21-Apr-1992 Added multi-level stack backtrace.
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        KeithMo     12-Aug-1992 Robustified stack backtrace a bit,
                                also enabled HEAPDEBUG for MIPS.
 */

#include <stdio.h>

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
#  define HEAPDEBUG
#else
#  undef HEAPDEBUG
#endif

#include "heapdbg.hxx"

struct HEAPTAG * pHeapBase = 0 ;     //  Anchor of linked list of alloc'd blocks


    //  Define macro to avoid bringing in USER32.DLL through ::wsprintfW

#define WSPRINTF ::swprintf


VOID HeapResidueIter( UINT cMaxResidueBlocksToDump,
                      BOOL fBreakIfResidue )
{
#ifdef HEAPDEBUG   //  If heap debugging is desired

    const TCHAR * pszMsg = SZ("NETUI heap residue: Hdr = %p, Blk = %p, Size = %lX\n");
    TCHAR         achBuffer[100];
    HEAPTAG     * pht = pHeapBase;
    UINT          cBlocks = 0;

    if( pht == NULL )
    {
        //
        //  No residual heap blocks.  This is good.
        //

        return;
    }

    //
    //  Dump the residual blocks, with stack traces.
    //

    while( pht != NULL )
    {
        if( cBlocks < cMaxResidueBlocksToDump )
        {
            WSPRINTF( achBuffer,
                        pszMsg,
                        pht,
                        (PCHAR)pht + sizeof(HEAPTAG),
                        pht->_usSize );
            ::OutputDebugString( achBuffer );

            UINT cFrames = pht->_cFrames;
            TCHAR * pszStackMsg = SZ("        Stack =");

            if( cFrames > RESIDUE_STACK_BACKTRACE_DEPTH )
            {
                ::OutputDebugString( SZ("_cFrames exceeds RESIDUE_STACK_BACKTRACE_DEPTH,") );
                ::OutputDebugString( SZ(" possible invalid or corrupt heap block!\n") );
            }
            else
            {
                for( UINT i = 0 ; i < cFrames ; i++ )
                {
                    if( ( i % 5 ) == 0 )
                    {
                        ::OutputDebugString( pszStackMsg );
                        pszStackMsg = SZ("\n               ");
                    }

                    WSPRINTF( achBuffer,
                                SZ(" [%p]"),
                                pht->_pvRetAddr[i] );
                    ::OutputDebugString( achBuffer );
                }
            }

            ::OutputDebugString( SZ("\n") );
        }

        cBlocks++;

        if ( (pht = pht->_phtRight) == pHeapBase )
            pht = NULL;
    }

    if( ( cMaxResidueBlocksToDump > 0 ) &&
        ( cBlocks > cMaxResidueBlocksToDump ) )
    {
        //
        //  Tell the user how many remaining residual blocks exist.
        //

        WSPRINTF( achBuffer,
                    SZ("%u residue blocks remaining\n"),
                    cBlocks - cMaxResidueBlocksToDump );
        ::OutputDebugString( achBuffer );
    }

    if( fBreakIfResidue )
    {
        //
        //  Break into the debugger.  If we didn't dump any residual
        //  blocks, then dump the first one so the user can invoke
        //  !netui.heapres to get stack traces with symbols.
        //

        if( cMaxResidueBlocksToDump == 0 )
        {
            WSPRINTF( achBuffer,
                        pszMsg,
                        pHeapBase,
                        (PCHAR)pHeapBase + sizeof(HEAPTAG),
                        pHeapBase->_usSize );
            ::OutputDebugString( achBuffer );
        }

        WSPRINTF( achBuffer,
                    SZ("Execute '!netui.heapres %p' to get stack symbols\n"),
                    pHeapBase );
        ::OutputDebugString( achBuffer );

        ::DebugBreak();
    }

#endif // HEAPDEBUG

}   // HeapResidueIter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\loclheap\locheap2.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  01/24/91  Created
 */

/*********
LOCHEAP2.C
*********/

/****************************************************************************

    MODULE: LocHeap2.c

    PURPOSE: Local-heap management helper routines

    FUNCTIONS:

    COMMENTS: see $(UI)\common\h\locheap2.c

    FILE HISTORY:

    jonn	24-Jan-1991	Created
    jonn	21-Mar-1991	Code review changes from 2/20/91 (attended
				by JonN, RustanL, ?)

****************************************************************************/


/*************
end LOCHEAP2.C
*************/


#ifndef WINDOWS
#error "Only use these APIs under Windows!"
#endif



#define NOGDICAPMASKS
#define NOSOUND
#define NOMINMAX
#include <windows.h>
#undef ERROR_NOT_SUPPORTED
#undef ERROR_NET_WRITE_FAULT
#undef ERROR_VC_DISCONNECTED

#include <locheap2.h>



// Note that variables accessed between "push DS" and "pop DS" must be
//   on the stack.



BOOL DoLocalInit(WORD wHeapDS, WORD wBytes)
{
     BOOL fResult ;
_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        fResult = LocalInit(wHeapDS, 0, wBytes-1);

_asm {
     pop DS
     }
     return fResult ;
}


HANDLE DoLocalAlloc(WORD wHeapDS, WORD wFlags, WORD wBytes)
{
    HANDLE handleReturn;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        handleReturn = LocalAlloc(wFlags, wBytes);

_asm {
     pop DS
     }

    return handleReturn;
}

HANDLE DoLocalFree(WORD wHeapDS, HANDLE handleFree)
{
    HANDLE handleReturn;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        handleReturn = LocalFree(handleFree);

_asm {
     pop DS
     }

    return handleReturn;
}

LPSTR DoLocalLock(WORD wHeapDS, HANDLE handleLocal)
{
    NPSTR np;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        np = LocalLock(handleLocal);

_asm {
     pop DS
     }

    return (LPSTR) MAKELONG(np, wHeapDS);

    // note: global segment is not unlocked
}

VOID DoLocalUnlock(WORD wHeapDS, HANDLE handleLocal)
{
_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        LocalUnlock(handleLocal);

_asm {
     pop DS
     }
}

HANDLE DoLocalHandle(WORD wHeapDS, WORD wMem)
{
    HANDLE hMem ;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

	hMem = LocalHandle(wMem);

_asm {
     pop DS
     }

    return hMem ;
}


WORD DoLocalSize(WORD wHeapDS, HANDLE handleLocal)
{
    WORD size ;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

	size = LocalSize(handleLocal);

_asm {
     pop DS
     }

    return size ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\loclheap\loclheap.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE HISTORY:
 *  01/24/91  Created
 *  03/22/91  Coderev changes (2/20, JonN, RustanL, ?)
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
LOCLHEAP.CXX
***********/

/****************************************************************************

    MODULE: LoclHeap.cxx

    PURPOSE: Local-heap management routines

    FUNCTIONS:

    COMMENTS:

****************************************************************************/


PRELIM CDD FOR LOCAL HEAP MANAGER

Glossary:
SZ("local heap") -- an explicitly created heap containing zero or more
        heap elements.
SZ("heap element") -- a block of memory allocated in a specific local heap.

The local heap manager allows applications to set up local heaps.  These
heaps are created by calling GlobalAlloc() to get the memory for the
entire heap, LocalInit() to set up the new segment as a local heap, 
and Local* calls to _access the heap.  Naturally, DS will have to be
explicitly set to the heap segment for each of the Local* calls;  the
local heap manager will deal with setting DS, as well as
saving/restoring the old DS.

The local heap is never explicitly locked;  instead, it is locked
whenever any of the heap elements is locked.  This is implemented by
GlobalLock-ing the heap every time a heap element is locked, and
GLobalUnlock-ing it when any heap element is unlocked.  The local heap
is locked once for every locked heap element.  This allows unlocked
heap elements to move within a local heap, and allows the local heap
to move when all of its heap elemnts are unlocked.  I rely on Windows
to maintain the lock count on the global heap.

It will be possible to create multiple local heaps, or to create local
heaps as global objects.

A DOS variant of the local heap manager will stub out the local heap calls,
map the heap element allocation/deallocation to new() and free(), and
stub out the heap element lock/unlock calls by storing the far pointer
in the instance variables.


/***************
end LOCLHEAP.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#define NOGDICAPMASKS
#define NOSOUND
#define NOMINMAX
#define INCL_WINDOWS
#include <lmui.hxx>

extern "C" 
{
    #include <stdlib.h>

#ifdef WINDOWS
    #include "locheap2.h"
#endif

}

#include <loclheap.hxx>



/**********************************************************\

   NAME:       HEAP_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::Init()
{

    _handle = 0;

}


/**********************************************************\

   NAME:       HEAP_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      zero-length heaps not allowed (cannot pass LocalInit API)
      it is an error to Init a local heap twice.  Local heaps cannot be resized.

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL HEAP_HANDLE::Init(WORD wBytes, WORD wFlags)
{

#ifdef WINDOWS

    LPSTR lp;

    if (wBytes == 0)
    {
        _handle = 0;
        return FALSE;
    }

    _handle = GlobalAlloc( wFlags, (DWORD) wBytes );
    if (_handle == 0)
        return FALSE;

    lp = GlobalLock(_handle);

    {
        DoLocalInit(HIWORD(lp), wBytes);
    }

    GlobalUnlock(_handle);

#else

    (void) wFlags;
    (void) wBytes;

    _handle = 0xffff;

#endif // WINDOWS

    return TRUE;

}


/**********************************************************\

   NAME:       HEAP_HANDLE::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::Free()
{

#ifdef WINDOWS

    if (_handle != 0)
    {
	GlobalFree(_handle);
        _handle = 0;
    }

#else

    _handle = 0;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       HEAP_HANDLE::IsNull

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL HEAP_HANDLE::IsNull()
{

    return (_handle == 0);
}


/**********************************************************\

   NAME:       HEAP_HANDLE::operator=

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      copies handle, not heap

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::operator=( const HEAP_HANDLE& source )
{

    _handle = source._handle;

}




/**********************************************************\

   NAME:       ELEMENT_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Init()
{

#ifdef WINDOWS

    _win._globalHandle = 0;
    _win._localHandle  = 0;

#else

    _os2._lpstr = NULL;

#endif // WINDOWS

}


BOOL ELEMENT_HANDLE::Init(const HEAP_HANDLE &heap, WORD wBytes, WORD wFlags)
{

#ifdef WINDOWS

    _win._globalHandle = heap._handle;

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return FALSE;

    {
	_win._localHandle = DoLocalAlloc(HIWORD(lp), wFlags, wBytes);
    }

    GlobalUnlock(_win._globalHandle);

    return (_win._localHandle != NULL);

#else

    (void) heap;
    (void) wFlags;

    _os2._lpstr = (LPSTR) malloc((unsigned)wBytes);

    return (_os2._lpstr != NULL);

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Free()
{

    if (IsNull())
	return;

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return;

    {
        _win._localHandle = DoLocalFree(HIWORD(lp), _win._localHandle);
    }

    GlobalUnlock(_win._globalHandle);

    _win._globalHandle = 0;
    _win._localHandle  = 0;

#else

    free((void *)_os2._lpstr);
    _os2._lpstr = NULL;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Lock

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

LPSTR ELEMENT_HANDLE::Lock()
{

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return NULL;

    {
	return DoLocalLock(HIWORD(lp), _win._localHandle);
    }

    // note: global segment is not unlocked

#else

    return _os2._lpstr;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Unlock

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Unlock()
{

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return;

    {
	DoLocalUnlock(HIWORD(lp), _win._localHandle);
    }

    GlobalUnlock(_win._globalHandle);
    GlobalUnlock(_win._globalHandle);

    // note: global segment is unlocked twice

#endif // WINDOWS

}

/**********************************************************\

   NAME:       ELEMENT_HANDLE::IsNull

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL ELEMENT_HANDLE::IsNull()
{

#ifdef WINDOWS

    return (_win._localHandle == 0);

#else

    return (_os2._lpstr == NULL);

#endif // WINDOWS
}


// copies handle, not element
/**********************************************************\

   NAME:       ELEMENT_HANDLE::operator=

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::operator=( const ELEMENT_HANDLE& source )
{

#ifdef WINDOWS

    _win._localHandle =  source._win._localHandle;
    _win._globalHandle = source._win._globalHandle;

#else

    _os2._lpstr = source._os2._lpstr;

#endif // WINDOWS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\heap\heapones.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    heapones.cxx
    ONE_SHOT_HEAP and ONE_SHOT_ITEM classes

    These classes support the allocation/deallocation of "quicky" items
    which have a short, scoped lifetime.

    FILE HISTORY:
        DavidHov    2-25-91     Created
        beng        24-Dec-1991 Heaps revisited: made safe for multiple
                                clients; made more lightweight
*/

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include "base.hxx"
#include "uibuffer.hxx"
#include "heapones.hxx"


// How many bytes can a buffer hold, max?
//
#define CB_MAX_BUFFER (UINT)(-1)


/**********************************************************************

    NAME:       ONE_SHOT_HEAP::ONE_SHOT_HEAP

    SYNOPSIS:   Ctor for one-shot heap

    ENTRY:      Requires the initial allocation size, plus whether
                the heap supports auto-resizing (dangerous on Win32).

                Note that BUFFER objects of zero bytes are allowed and
                will create sucessfully.

    EXIT:       Object created.

    NOTES:      On failure, reports an error.

    HISTORY:
        davidhov    ??-???-1991 Created
        beng        24-Dec-1991 Simplification
        beng        19-Mar-1992 Optional resizing

**********************************************************************/

ONE_SHOT_HEAP::ONE_SHOT_HEAP ( UINT cbInitialAllocSize, BOOL fAutoResize )
    : BUFFER( cbInitialAllocSize ),
    _cbUsed( 0 ),
    _fAutoResize(fAutoResize)
{
    // nothing doing
}


/**********************************************************************

    NAME:       ONE_SHOT_HEAP::Alloc

    SYNOPSIS:   Allocate memory in a ONE_SHOT_HEAP.  This is done
                by maintaining a "high water mark" and moving it
                upwards, reallocating when necessary.  Reallocation
                attempts try to resize to 1.5 times the current
                size.

    ENTRY:      Number of bytes desired.

    EXIT:       Buffer possibly resized; high-water mark moved.

    RETURNS:    Pointer to the data allocated, or NULL if failed.

    HISTORY:
        davidhov    ??-???-1991 Created
        beng        15-Jul-1991 BUFFER::Resize changed return type
        beng        24-Dec-1991 Grand simplification of one-shot heaps
        beng        19-Mar-1992 Resize only if allowed

**********************************************************************/

BYTE * ONE_SHOT_HEAP::Alloc( UINT cbBytes )
{
    BYTE * pbResult = NULL;
    UINT cbRemaining = QuerySize() - _cbUsed;

    if ( cbRemaining < cbBytes )
    {
        if (_fAutoResize)
        {
            UINT cbSize = QuerySize();

            if (cbSize == CB_MAX_BUFFER)    // check if already maxed
                return NULL;

            UINT cbResize = cbSize + (cbSize / 2);

            if (cbResize < cbSize)          // check for overflow
                cbResize = CB_MAX_BUFFER;

            if ( Resize( cbResize ) != 0 )  // try to grow buffer
                return NULL;
        }
        else
        {
            // Auto-resizing has been forbidden.  Try to stretch
            // the last couple of bytes without growing the buffer.

            FillOut();
        }

        cbRemaining = QuerySize() - _cbUsed;
    }

    if ( cbRemaining >= cbBytes )
    {
        pbResult = (BYTE *) (QueryPtr() + _cbUsed);
        _cbUsed += cbBytes;
    }

    return pbResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\misc\timestmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    timestmp.cxx
    Implementation of time stamp function, QueryCurrentTimeStamp

    FILE HISTORY:
	rustanl     09-Apr-1991     Created

*/


#ifdef WINDOWS

#define INCL_WINDOWS
#include "lmui.hxx"

#else

#include "lmui.hxx"

extern "C"
{
    #include <time.h>
}

#endif	// WINDOWS


#include "uiassert.hxx"
#include "uimisc.hxx"


/*******************************************************************

    NAME:	    QueryCurrentTimeStamp

    SYNOPSIS:	    This function returns a time stamp measured
		    in seconds from some arbitrary point.

    RETURNS:	    The current time stamp

    NOTES:	    If the caller needs better granularity than seconds,
		    a new method needs to be invented.

		    Under Windows, the returned time corresponds to
		    the number of seconds from that the system
		    was started.  Under DOS and OS/2, the time corresponds
		    to the number of seconds elapsed since 00:00:00
		    Greenwich mean time (GMT), January 1, 1970, according to
		    the system clock (adjusted according to the time
		    zone system variable).

    HISTORY:
	rustanl     09-Apr-1991     Created

********************************************************************/

ULONG QueryCurrentTimeStamp()
{

#ifdef WINDOWS

    //	GetCurrentTime returns the time in milliseconds.
    return ( ::GetCurrentTime() / 1000 );

#else

    return ::time( NULL );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\misc\loadres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    loadres.cxx
    Implementation of the LoadResourceString function.

    The Windows version of this method loads the resource string from
    the strings in the resource file of the calling module.

    The OS/2 version should call DosGetMessage to get the string from some
    message file.  The LoadResourceString function needs to be able to
    determine which message file to load the string from.


    CAVEATS:

        CODEWORK.  The OS/2 version is not implemented.  It should be, if
        anyone needs it.

        BUGBUG.  This method may return ERROR_MR_MID_NOT_FOUND (for
        the curious, MR_MID is not Mr. Mid, but Message Resource Message
        ID).  Doing a Helpmsg from the OS/2 prompt shows that this
        error needs insert strings.  This means that the caller of this
        method needs to know about this before calling, say, MsgPopup
        to report the error to the user, so as to fill in the %1 and %2.
        Normally, OS/2 and LAN Man error codes don't require insert strings.
        If this error value does, it should probably be chagned later on.


    FILE HISTORY:
        RustanL     31-Jan-1991 Created.  Added Windows version.

*/

#ifdef WINDOWS

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#include "blt.hxx"      // for QueryInst function

#else

#define INCL_DOSERRORS
#include "lmui.hxx"

#endif  // WINDOWS


#include "uiassert.hxx"
#include "uimisc.hxx"


/*******************************************************************

    NAME:       LoadResourceString

    SYNOPSIS:   Loads a resource string (duuuuuuh)

    ENTRY:
        msgid       - number identifying the string to be loaded
        pszBuffer   - Pointer to buffer which receives the loaded string
        cbBufSize   - size of the given buffer

    EXIT:
        Buffer contains string, if successful

    RETURNS:
        Error value.  May be one of the following:
            NERR_Success            Success
            ERROR_MR_MID_NOT_FOUND  Could not find the requested message

    NOTES:

    HISTORY:
        RustanL     31-Jan-1991 Created
        beng        21-May-1991 Removed reference to ::vhInst
        beng        07-Oct-1991 LoadR.S. uses contemporary typedefs
        beng        05-May-1992 API changes (cb->cch in LoadString)

********************************************************************/

APIERR LoadResourceString( MSGID msgid, TCHAR * pszBuffer, UINT cbBufSize )
{
#if defined(WINDOWS)

    // The BLT Windowing system offers the QueryInst function
    // to return a handle to the current instance.

    INT nLen = ::LoadString( ::QueryInst(), msgid, pszBuffer,
                             cbBufSize/sizeof(TCHAR) );

    // Assume that no actual string will have length 0.

    if ( nLen == 0 )
    {
        return ERROR_MR_MID_NOT_FOUND;
    }

    return NERR_Success;

#else

    UNREFERENCED(msgid);
    UNREFERENCED(cbBufSize);
    UNREFERENCED(pszBuffer);

    UIASSERT( FALSE ); // Not implemented
    return ERROR_NOT_SUPPORTED;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\system\chkdrv.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  History:
 *      ChuckC      11-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Add WIN32BUGBUG
 *      Yi-HsinS    12-Nov-1991     Added CheckLocalDrive for NT
 *      beng        29-Mar-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif

#ifndef _WIN32
}
#endif


/*
 * check if a drive "X:" is valid. Assumes that
 * the drive letter has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
#ifdef OS2
APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{
    USHORT usDrive, usDummy ;
    APIERR err;
    ULONG  ulMap ;

    usDrive = pszDeviceName[0] - TCH('A') ;   // assume pszDeviceName is canon-ed

    // get drive map
    err = DosQCurDisk(&usDummy, &ulMap);
    if (err != NERR_Success)
        return(err) ;

    // check if the drive is present
    if ( (ulMap >> usDrive) & 0x1L )
        return (NERR_Success) ;

    // its not there
    return(ERROR_INVALID_DRIVE);
}

#elif defined(WIN32)

#include "string.hxx"

DLL_BASED
APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{

    NLS_STR nls( pszDeviceName );
    nls.AppendChar(TCH('\\'));

    if ( nls.QueryError() != NERR_Success )
        return ERROR_NOT_ENOUGH_MEMORY;

    DWORD uiDriveType = GetDriveType( (TCHAR *) nls.QueryPch() );

    switch ( uiDriveType )
    {
        case 0:
        case 1:
        case DRIVE_REMOTE:
             return ERROR_INVALID_DRIVE;

        default:   // Removable, Fixed, Ram Drive, CD-Rom
             return NERR_Success;
    }

}

#else // WINDOWS 16 bits

APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{
    USHORT usDrive ;
    union REGS inregs, outregs;

    usDrive = pszDeviceName[0] - TCH('A') ;   // assume pszDeviceName is canon-ed

    // Call IOCTL: check if block device is either a local drive or
    // a remote drive.
    inregs.x.ax = 0x4409 ;
    inregs.h.bl = usDrive + 1 ;
    intdos( &inregs, &outregs );

    if ( outregs.x.cflag )     /* if error, we know it's an invalid drive */
        return(ERROR_INVALID_DRIVE) ;
    else
        return(NERR_Success) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\system\chklpt.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * CHKLPT:      Check if an LPT device is valid.
 * History:
 *      ChuckC      11-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Win32 Conversion
 *      terryk      18-Nov-1991     add UNREFERENCED macro
 *      beng        01-Apr-1992     Remove odious PSZ type
 */

// NOTE - Win/NT support only currently

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"
#include "uisys.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
#ifndef _WIN32
}
#endif

/*
 * check if a LPTx is valid. Assumes that
 * the dev name has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
DLL_BASED
APIERR CheckLocalLpt(const TCHAR * pszDeviceName)
{
    UNREFERENCED(pszDeviceName);
#ifdef OS2
    return (ERROR_INVALID_DRIVE) ;      // BUGBUG - read OS2SYS.INI
#else
    /* under Win/DOS we cannot easily check, we allow it
       BUGBUG - better check under NT */
    return (NERR_Success) ;
#endif
}


/*
 * check if a COMx is valid. Assumes that
 * the dev name has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
DLL_BASED
APIERR CheckLocalComm(const TCHAR * pszDeviceName)
{
    UNREFERENCED(pszDeviceName);
#ifdef OS2
    return (ERROR_INVALID_DRIVE) ;      // BUGBUG - read OS2SYS.INI
#else
    /* under Win/DOS we cannot easily check, we allow it
       BUGBUG - better check under NT */
    return (NERR_Success) ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\misc\lmuidbcs.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmuidbcs.cxx
    Implementation of DBCS test function, NETUI_IsDBCS

    FILE HISTORY:
	jonn        11-Sep-1995     Created

*/


#define INCL_WINDOWS
#include "lmui.hxx"

extern "C"
{
    #include <lmuidbcs.h>
    VOID NETUI_InitIsDBCS();
}

// Indicates whether we are running in a DBCS locale
BOOL _global_NETUI0_IsDBCS = FALSE;


/*******************************************************************

    NAME:	    NETUI_InitIsDBCS

    SYNOPSIS:	    This function must be called in initialization.

    NOTE:           This is only called by dll3\dll0\init.cxx.  See
                    that module before modifying parameters.

    HISTORY:
	jonn        12-Sep-1995     Created

********************************************************************/

VOID NETUI_InitIsDBCS()
{
    LANGID langid = PRIMARYLANGID(::GetThreadLocale());
    _global_NETUI0_IsDBCS =
            (   langid == LANG_CHINESE
             || langid == LANG_JAPANESE
             || langid == LANG_KOREAN );
}


/*******************************************************************

    NAME:	    NETUI_IsDBCS

    SYNOPSIS:	    This function determines whether the calling thread
                    is in a DBCS locale.

    HISTORY:
	jonn        11-Sep-1995     Created

********************************************************************/

BOOL NETUI_IsDBCS()
{
    return _global_NETUI0_IsDBCS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\system\chkunav.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * CHKUNAV:     check unavailable device
 * History:
 *      ChuckC      3-Feb-1991      Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Add WIN32BUGBUG
 *      beng        01-Apr-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"
    #include <lmuse.h>

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
#ifndef _WIN32
}
#endif

#include "uisys.hxx"

#include "uibuffer.hxx"
#include "string.hxx"

#if defined(WINDOWS) && !defined(WIN32)
#include "winprof.hxx"
#endif

/*
 * check unavail device. Return NERR_Success if pszDevice is unavail,
 * pszRemote will be overwritten with remote name if successful, sType
 * with the device type. They will be "" and 0 respectively id call fails.
 */
DLL_BASED
APIERR CheckUnavailDevice(const TCHAR * pszDevice, TCHAR * pszRemote, INT *psType)
{
    if (!pszDevice || !pszRemote || !psType)
        return(ERROR_INVALID_PARAMETER) ;
    *pszRemote = TCH('\0') ;
    *psType = 0 ;

#if defined(WINDOWS) && !defined(WIN32)
    // WIN32BUGBUG

    if ( !(GetWinFlags() & WF_PMODE) )
    {
       /*
        * if not prot mode, just say no
        */
        return(ERROR_INVALID_DRIVE) ;
    }

    /*
     * in the Win case, we are Winnet specific. This is the
     * only planned use of Profile.
     */
    NLS_STR strDrive(pszDevice) ;
    NLS_STR strRemote ;
    if (PROFILE::Query(strDrive, strRemote, (INT *)psType, NULL) == 0)
    {
        ::strcpyf((TCHAR *)pszRemote,strRemote.QueryPch()) ;
        return(NERR_Success) ;
    }
    return(ERROR_INVALID_DRIVE) ;
#else
    return(ERROR_INVALID_FUNCTION) ;    // currently no support outside wIn
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\skeleton\skeleton.h ===
#define IDM_ABOUT       100
#define IDM_RUN_TEST    200

#define ID_APPICON      1
#define ID_APPMENU      1
#define ID_APPACCEL     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xassert\xassert.h ===
#define IDM_RUN_TEST1	201
#define IDM_RUN_TEST2	202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xfsenum\xfsenum.h ===
#define IDM_ABOUT	100
#define IDM_RUN_TEST	200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\skeleton\skeleton.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    skeleton.cxx
    Generic unit test: main application module

    This is a skeleton for string unit tests, allowing them to
    be written in a host-env independent fashion.

    FILE HISTORY:
        johnl       12-Nov-1990 Created
        beng        01-May-1991 Added workaround for C7 bug
        beng        27-Jun-1991 Win and OS2 tests merged
                                (used BUFFER as a template)
        beng        06-Jul-1991 Frame and test partitioned
        beng        14-Oct-1991 Uses APPLICATION
        beng        28-Feb-1992 Works for the console in general
        beng        16-Mar-1992 Changes to cdebug
        beng        13-Aug-1992 Dllization of BLT
*/

// #define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "skeleton.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <uirsrc.h>
    #include <uimsg.h>

    #include "skeleton.h"
}

#if defined(WINDOWS)
# if !defined(USE_CONSOLE)
#  define INCL_BLT_CONTROL
#  define INCL_BLT_CLIENT
# endif
# define INCL_BLT_APP
# include <blt.hxx>
#endif

#if !defined(WINDOWS) || defined(USE_CONSOLE)
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include "skeleton.hxx"


#if defined(WINDOWS) && !defined(USE_CONSOLE)

const TCHAR *const szMainWindowTitle = SZ("Unit Test");


class TEST_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    TEST_WND();
};


class TEST_APP: public APPLICATION
{
private:
    TEST_WND  _wndApp;
    ACCELTABLE _accel;

public:
    TEST_APP( HANDLE hInstance, INT nCmdShow, UINT, UINT, UINT, UINT );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


TEST_APP::TEST_APP( HANDLE hInst, INT nCmdShow,
                    UINT w, UINT x, UINT y, UINT z )
    : APPLICATION( hInst, nCmdShow, w, x, y, z ),
      _accel( ID_APPACCEL ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL TEST_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


TEST_WND::TEST_WND()
    : APP_WINDOW(szMainWindowTitle, ID_APPICON, ID_APPMENU )
{
    if (QueryError())
        return;

    // ...
}


BOOL TEST_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
        ::MessageBox(QueryHwnd(),
            SZ("Test results will be written to debug terminal.  Bogus, huh?"),
            SZ("Note"), MB_OK);

        ::RunTest();
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( TEST_APP, IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                           IDS_UI_APP_BASE, IDS_UI_APP_LAST )

#elif defined(WINDOWS) && defined(USE_CONSOLE)

// Win32, with console support


class TEST_APP: public APPLICATION
{
private:
    OUTPUT_TO_STDERR _out;
    DBGSTREAM        _dbg;
    DBGSTREAM *      _pdbgSave;

public:
    TEST_APP( HANDLE hInstance, INT nCmdShow, UINT, UINT, UINT, UINT );
    ~TEST_APP();

    // Redefinitions
    //
    virtual INT Run();
};


TEST_APP::TEST_APP( HANDLE hInst, INT nCmdShow,
                    UINT w, UINT x, UINT y, UINT z )
    : APPLICATION( hInst, nCmdShow, w, x, y, z ),
      _out(),
      _dbg(&_out),
      _pdbgSave( &(DBGSTREAM::QueryCurrent()) )
{
    if (QueryError())
        return;

    // Point cdebug to stderr instead of aux
    //
    DBGSTREAM::SetCurrent(&_dbg);
}


TEST_APP::~TEST_APP()
{
    // Restore original stream

    DBGSTREAM::SetCurrent(_pdbgSave);
}


INT TEST_APP::Run()
{
    // Never mind the message loop... this is a console app.
    // Hope this works.
    //
    ::RunTest();
    return 0;
}


SET_ROOT_OBJECT( TEST_APP, IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                           IDS_UI_APP_BASE, IDS_UI_APP_LAST )


#else // OS2, or DOS, or some such env


INT main()
{
    OUTPUT_TO_STDOUT out;
    DBGSTREAM dbg(&out);
    DBGSTREAM::SetCurrent(&dbg);

    ::RunTest();

    DBGSTREAM::SetCurrent(NULL);
    return 0;
}


#endif // WINDOWS -vs- OS2 unit test skeletons
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xlog\xlog.h ===
#define IDC_LIST 100
#define SLE_SERVER 101

#define IDM_AUDIT_FORMAT 102
#define IDM_ERROR_FORMAT 103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xbuffer\xbuffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xbuffer.cxx
    BUFFER unit test: main application module

    FILE HISTORY:
        beng        02-Jan-1991 Created
        beng        03-Feb-1991 Modified to use lmui.hxx et al
        beng        14-Feb-1991 Added BLT
        beng        14-Mar-1991 Removed obsolete vhInst;
                                included about.cxx,hxx
        beng        01-Apr-1991 Uses new BLT APPSTART
        beng        10-May-1991 Updated with standalone client window
        beng        14-May-1991 ... and with App window
        beng        25-Jun-1991 BUFFER unit test made
        beng        14-Oct-1991 Uses APPLICATION
        beng        16-Mar-1992 NT version
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xbuffer.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <uiassert.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <dbgstr.hxx>

#include "skeleton.hxx"


class BUFFERTEST // test
{
private:
    UINT           _cpbuf;
    BUFFER **const _apbuf;

public:
    BUFFERTEST(UINT cbuf = 5, UINT cbSize = 2048);
    ~BUFFERTEST();

    VOID Tattle() const;
    BOOL Double() const;
    VOID TrimAll() const;
    VOID FillOut() const;
    BOOL Increase( UINT cbAddition ) const;
};


VOID RunTest()
{
    BUFFERTEST test(5, 4096);

    test.Tattle();
    test.Double();
    test.Tattle();
    test.Double();
    test.Tattle();
    test.FillOut();
    test.Tattle();
    test.TrimAll();
    test.Tattle();
    test.Increase(544);
    test.Tattle();
    test.Double();
    test.Tattle();
    test.FillOut();
    test.Tattle();
    test.Double(); // would fail on Win16
    test.Tattle();
}


BUFFERTEST::BUFFERTEST( UINT cbufUsed, UINT cbSize ) :
    _cpbuf(cbufUsed),
    _apbuf(new BUFFER*[cbufUsed])
{
    if (!_apbuf)
    {
        // The first alloc failed.  Zap _cpbuf for the destructor.
        //
        _cpbuf = 0;
        cdebug << SZ("Test failed to setup") << dbgEOL;
        return;
    }

    cdebug << SZ("Starting BUFFER test...") << dbgEOL;

    UINT ipbuf = 0;

    while (ipbuf < _cpbuf)
    {
        BUFFER * pbufNew = new BUFFER(cbSize);
        if (!pbufNew)
        {
            cdebug << SZ("Buffer failed to allocate") << dbgEOL;
        }
        else if (!*pbufNew)
        {
            cdebug << SZ("Buffer failed with ") << pbufNew->QueryError() << dbgEOL;
        }
        else
        {
            cdebug << SZ("Buffer ") << ipbuf << SZ(" successfully built") << dbgEOL;
        }

        // I want the element set to something, even NULL,
        // so as to simplify cleanup

        _apbuf[ipbuf++] = pbufNew;
    }
}


BUFFERTEST::~BUFFERTEST()
{
    UINT ipbuf = _cpbuf;

    while (ipbuf > 0)
    {
        delete _apbuf[--ipbuf];
    }

    delete [_cpbuf] _apbuf;

    cdebug << SZ("End of BUFFER test") << dbgEOL;
}


DBGSTREAM& operator<<(DBGSTREAM &out, const BYTE *pb)
{
#if defined(WIN32)
    HEX_STR nlsHex((ULONG)pb);

    out << SZ("0x") << nlsHex.QueryPch();
#else
    HEX_STR nlsHigh( HIWORD((ULONG)pb), 4 );
    HEX_STR nlsLow( LOWORD((ULONG)pb), 4 );

    out << nlsHigh.QueryPch() << SZ(":") << nlsLow.QueryPch();
#endif

    return out;
}


VOID BUFFERTEST::Tattle() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        cdebug << SZ("Buffer ") << ipbuf
               << SZ(" has size ") << _apbuf[ipbuf]->QuerySize()
               << SZ(" and addr ") << _apbuf[ipbuf]->QueryPtr()
               << dbgEOL;
    }
}


BOOL BUFFERTEST::Double() const
{
    const UINT cbMax = UINT(-1);

    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        UINT cbCurrent = _apbuf[ipbuf]->QuerySize();

        if (cbCurrent > cbMax/2)
            break;

        if (_apbuf[ipbuf]->Resize(cbCurrent*2))
        {
            cdebug << SZ("Buffer ") << ipbuf
                   << SZ("failed a resize to ") << cbCurrent*2
                   << dbgEOL;
            return FALSE;
        }
    }

    return TRUE;
}


VOID BUFFERTEST::TrimAll() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        _apbuf[ipbuf]->Trim();
    }
}


VOID BUFFERTEST::FillOut() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        _apbuf[ipbuf]->FillOut();
    }
}


BOOL BUFFERTEST::Increase(UINT cbAddition) const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        if (_apbuf[ipbuf]->Resize( _apbuf[ipbuf]->QuerySize() + cbAddition ))
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xlog\xlog.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    xlog.cxx
    Test application for event log classes
    For WINDOWS only.

    FILE HISTORY:
	Yi-HsinS    29-Oct-1991     Created
	Yi-HsinS    31-Dec-1991     Include loglm.hxx

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETLIB
#define INCL_NETAUDIT
#define INCL_NETERRORLOG
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#include <blt.hxx>

#include <string.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>

#include <logmisc.hxx>
#include <eventlog.hxx>
#include <loglm.hxx>

extern "C" 
{
    #include "xlog.h"
    #include "stdlib.h"
}

const TCHAR szIconResource[] = SZ("FooIcon");
const TCHAR szMenuResource[] = SZ("FooMenu");
const TCHAR szMainWindowTitle[] = SZ("Event Log Test Application");

class LOGLBI: public LBI
{
private:
    FORMATTED_LOG_ENTRY *_pLogEntry;
    static UINT _adxColumns[6];

protected:
    void Paint( BLT_LISTBOX *plb, HDC hdc, const RECT *prect, 
		GUILTT_INFO *pGUILTT ) const;

    INT Compare( const LBI *plbi ) const;

public:
    LOGLBI( FORMATTED_LOG_ENTRY  *pLogEntry );
    ~LOGLBI();
};

UINT LOGLBI::_adxColumns[] = { 100, 50, 50, 90, 60, COL_WIDTH_AWAP };

class FOO_WND: public APP_WINDOW
{
private:
    BLT_LISTBOX _listbox;

protected:
    virtual BOOL OnResize( const SIZE_EVENT & );

    // Redefinitions
    virtual BOOL OnMenuCommand( MID mid );

public:
    FOO_WND();
    ~FOO_WND();
};


class FOO_APP: public APPLICATION
{
private:
    FOO_WND _wndApp;

public:
    FOO_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
};


class PROMPT_SERVER : public DIALOG_WINDOW
{
private:
    SLE _sleServer;

public:
    PROMPT_SERVER( HWND hwndParent );
    APIERR QueryServer( NLS_STR *pnlsServer )
    {    return _sleServer.QueryText( pnlsServer ); } 

};

/**********************************************************************/

PROMPT_SERVER::PROMPT_SERVER( HWND hwndParent )
    : DIALOG_WINDOW( SZ("PROMPT_SERVER"), hwndParent ),
      _sleServer( this, SLE_SERVER )
{
     if ( QueryError() != NERR_Success )
	 return;
}

/**********************************************************************/

FOO_WND::FOO_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource ),
      _listbox(this, IDC_LIST,
	       XYPOINT(40, 40), XYDIMENSION(100, 200),
	       WS_CHILD|WS_VSCROLL|WS_HSCROLL|WS_BORDER|
	       LBS_OWNERDRAWFIXED|LBS_EXTENDEDSEL|LBS_NOTIFY|
	       LBS_WANTKEYBOARDINPUT )
{
    if (QueryError())
      return;

    if (!_listbox)
    {
	// Control has already reported the error into the window
	return;
    }

    _listbox.SetPos(XYPOINT(0, 0));
    _listbox.SetSize(QuerySize());

}

FOO_WND::~FOO_WND()
{
    _listbox.Show(FALSE);
}

BOOL FOO_WND::OnMenuCommand( MID mid )
{
    APIERR err;

    switch (mid)
    {
        case IDM_AUDIT_FORMAT:
        case IDM_ERROR_FORMAT:
	{
            _listbox.DeleteAllItems();
            _listbox.Show( FALSE );

	    PROMPT_SERVER dlg( QueryRobustHwnd() );
            if ( ( err = dlg.QueryError()) != NERR_Success )
            {
		MsgPopup( this, err );
                return TRUE;
            }

	    dlg.Process();

	    NLS_STR nlsServer;
	    if ( ( err = dlg.QueryServer( &nlsServer )) != NERR_Success )
            {
		MsgPopup( this, err );
                return TRUE;
            }

            EVENT_LOG *pLog;
	    if ( mid == IDM_AUDIT_FORMAT )
            {
		pLog = new LM_AUDIT_LOG( nlsServer );
	    }
	    else    // IDM_ERROR_FORMAT
	    {
		pLog = new LM_ERROR_LOG( nlsServer );
	    }

            err = pLog ? pLog->QueryError() : (APIERR) ERROR_NOT_ENOUGH_MEMORY;

            if (  (err != NERR_Success ) 
               || (( err = pLog->Open()) != NERR_Success )
               )
            {
		MsgPopup( this, err );
                return TRUE;
            }


            FORMATTED_LOG_ENTRY *pLogEntry;
	    LOG_ENTRY_NUMBER logEntryNum;

            INT j = 0;

            
            while ( j < 20 && pLog->Next() )
            {
		pLog->QueryPos( &logEntryNum );

                if ( (err = pLog->CreateCurrntFormatEntry( &pLogEntry )) != NERR_Success )
		    break;

	        LOGLBI *plbi = new LOGLBI( pLogEntry );
		if ( plbi == NULL )
		{
		    err = ERROR_NOT_ENOUGH_MEMORY;
		    break;
                }

        	_listbox.AddItem( plbi );
		j++;

		if ( j == 10 )
                {
                    logEntryNum.SetRecordNum( 5 );
	            logEntryNum.SetDirection( EVLOG_BACK );
		    pLog->SetPos( logEntryNum );
                }
            }

            if ( err == NERR_Success )
	    {
		if ( j == 20 )   // There are at least twenty items in the log
		{
		    logEntryNum.SetRecordNum(17);
		    logEntryNum.SetDirection(EVLOG_BACK);
		    if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		    {
			pLog->CreateCurrntFormatEntry( &pLogEntry );
			LOGLBI *plbi = new LOGLBI( pLogEntry );
			_listbox.AddItem( plbi );
		    }
		}

		logEntryNum.SetRecordNum(0);
		logEntryNum.SetDirection(EVLOG_BACK);
		if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		{
		    pLog->CreateCurrntFormatEntry( &pLogEntry );
		    LOGLBI *plbi = new LOGLBI( pLogEntry );
		    _listbox.AddItem( plbi );
		}

		logEntryNum.SetRecordNum(0);
		logEntryNum.SetDirection(EVLOG_FWD);
		if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		{
		    pLog->CreateCurrntFormatEntry( &pLogEntry );
		    LOGLBI *plbi = new LOGLBI( pLogEntry );
		    _listbox.AddItem( plbi );
		}
            }

            err = err? err : pLog->QueryLastError();
	    if ( err != NERR_Success )
		MsgPopup( this, err );
            else
                _listbox.Show();

            if ( (err = pLog->Close()) != NERR_Success )
		MsgPopup( this, err );

            delete pLog;
	    return TRUE;
        }

    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


BOOL FOO_WND::OnResize( const SIZE_EVENT & event )
{
    _listbox.SetSize(XYDIMENSION(event.QueryWidth(), event.QueryHeight()));
    return APP_WINDOW::OnResize(event);
}

/**********************************************************************/

FOO_APP::FOO_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _wndApp()
{
    if (QueryError())
	return;

    if (!_wndApp)
    {
	ReportError(_wndApp.QueryError());
	return;
    }

    _wndApp.Show();
    _wndApp.RepaintNow();
}

/**********************************************************************/

LOGLBI::LOGLBI( FORMATTED_LOG_ENTRY *pLogEntry ) 
    : _pLogEntry( pLogEntry )
{
    if ( QueryError() != NERR_Success )
	return;
}

LOGLBI::~LOGLBI()
{
    delete _pLogEntry;
}

VOID LOGLBI::Paint( BLT_LISTBOX * plb, HDC hdc, const RECT * prect,
		    GUILTT_INFO * pGUILTT ) const
{
    TCHAR pszTime[20];

    UIDEBUG(SZ("Record Num: "));
    UIDEBUGNUM( _pLogEntry->QueryRecordNum() );
    UIDEBUG(SZ(" Type: "));
    UIDEBUGNUM( _pLogEntry->QueryType() );
    UIDEBUG(SZ(" Event ID: "));
    UIDEBUGNUM( _pLogEntry->QueryEventID() );
    UIDEBUG(SZ("\n\r"));

    STR_DTE  dteTime( _ltoa( _pLogEntry->QueryTime(), pszTime, 10) );
    STR_DTE  dteType( *(_pLogEntry->QueryTypeString()) );
    STR_DTE  dteSource( *(_pLogEntry->QuerySource()) );
    STR_DTE  dteUser( *( _pLogEntry->QueryUser()) );
    STR_DTE  dteSubType( *( _pLogEntry->QuerySubTypeString()) );
    STR_DTE  dteDesc( *( _pLogEntry->QueryDescription()) );

    DISPLAY_TABLE dtab( 6, LOGLBI::_adxColumns );
    dtab[0] = &dteTime;
    dtab[1] = &dteType;
    dtab[2] = &dteSubType;
    dtab[3] = &dteSource;
    dtab[4] = &dteUser;
    dtab[5] = &dteDesc;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


INT LOGLBI::Compare( const LBI * plbi ) const
{
    // Don't need to compare
    UNREFERENCED( plbi );
    return 0;
}


SET_ROOT_OBJECT( FOO_APP )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xassert\xassert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xassert0.cxx
    First test for ASSERT

    Since my code never fails, ASSERT needs a test so that somebody
    runs it...

    This runs under Windows only.

    FILE HISTORY:
        beng        06-Aug-1991 Created
        beng        17-Sep-1991 Added _FILENAME_DEFINED_ONCE

*/


#define DEBUG

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#include <lmui.hxx>

extern "C"
{
    #include "xassert.h"
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>

#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#include <blt.hxx>

#include <string.hxx>

#include <dbgstr.hxx>


const TCHAR *const szIconResource = SZ("FooIcon");
const TCHAR *const szMenuResource = SZ("FooMenu");
const TCHAR *const szAccelResource = SZ("FooAccel");

const TCHAR *const szMainWindowTitle = SZ("Assertion test");


VOID RunTest1( HWND hwndParent );
VOID RunTest2( HWND hwndParent );


class FOO_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    FOO_WND();
};


class FOO_APP: public APPLICATION
{
private:
    ACCELTABLE _accel;
    FOO_WND    _wndApp;

public:
    FOO_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


FOO_WND::FOO_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
        return;
}


BOOL FOO_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST1:
        ::RunTest1(QueryHwnd());
        return TRUE;
    case IDM_RUN_TEST2:
        ::RunTest2(QueryHwnd());
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


FOO_APP::FOO_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _accel( szAccelResource ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL FOO_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


VOID RunTest1( HWND hWnd )
{
    ASSERT(FALSE);
}


VOID RunTest2( HWND hWnd )
{
    ASSERTSZ(FALSE, "Pop goes the gangrenous weasel.");
}



SET_ROOT_OBJECT( FOO_APP )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xfsenum\xfsenum.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    xfsenum.cxx
    FS_ENUM unit test: main application module

    FILE HISTORY:
	Johnl	22-Oct-1991	Templated from Ben's xBuffer unit test

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xfsenum.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>

extern "C"
{
    #include "xfsenum.h"
}

#if defined(WINDOWS)
# define INCL_BLT_CLIENT
# define INCL_BLT_APP
# include <blt.hxx>
#else
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <string.hxx>
#include <fsenum.hxx>
#include <dbgstr.hxx>

APIERR Traverse( FS_ENUM * pFileEnum, DBGSTREAM * pMyDebug ) ;

#if defined(WINDOWS)

const TCHAR szIconResource[] = SZ("XfsenumIcon");
const TCHAR szMenuResource[] = SZ("XfsenumMenu");

const TCHAR szMainWindowTitle[] = SZ("Class FS_ENUM Test");


VOID RunTest( HWND hwndParent );


class XFS_ENUM_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    XFS_ENUM_WND();
};


class XFS_ENUM_APP: public APPLICATION
{
private:
    XFS_ENUM_WND  _wndApp;

public:
    XFS_ENUM_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
};


XFS_ENUM_APP::XFS_ENUM_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _wndApp()
{
    if (QueryError())
	return;

    if (!_wndApp)
    {
	ReportError(_wndApp.QueryError());
	return;
    }

    _wndApp.ShowFirst();
}


XFS_ENUM_WND::XFS_ENUM_WND()
    : APP_WINDOW( szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
	return;

    // ...
}


BOOL XFS_ENUM_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
	::RunTest(QueryHwnd());
	return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( XFS_ENUM_APP )


#else // OS2

#include <globinit.hxx>

OUTPUT_TO_STDERR _out;
DBGSTREAM _debug(&_out);

VOID RunTest();

INT main()
{
    GlobalObjCt();  // construct debug-stream
    ::RunTest();
    GlobalObjDt();  // destroy debug-stream

    return 0;
}

#endif // WINDOWS -vs- OS2 unit test skeletons


#if !defined(DEBUG)
#error This test requires the debugging BLT because I am lazy
#endif


class FS_ENUMTEST // test
{
private:
#ifdef WINDOWS
#ifdef WIN32

    W32_FS_ENUM _fsenum1 ;
    W32_FS_ENUM _fsenum2 ;
    W32_FS_ENUM _fsenum3 ;

#else

    DOS_FS_ENUM   _fsenum1 ;
    DOS_FS_ENUM   _fsenum2 ;
    DOS_FS_ENUM   _fsenum3 ;

    WINNET_LFN_FS_ENUM	 _fsenum4 ;
    WINNET_LFN_FS_ENUM	 _fsenum5 ;
    WINNET_LFN_FS_ENUM	 _fsenum6 ;

#endif // WIN32
#else

    OS2_FS_ENUM   _fsenum1 ;
    OS2_FS_ENUM   _fsenum2 ;
    OS2_FS_ENUM   _fsenum3 ;

#endif //WINDOWS


public:
    FS_ENUMTEST();
    ~FS_ENUMTEST();

    APIERR GO( void ) ;
};


#if defined(WINDOWS)
VOID RunTest( HWND hWnd )
{
    ::MessageBox(hWnd,
	SZ("Test results will be written to debug terminal.  Bogus, huh?\nDrive E: should be redirected to an LFN drive."),
	SZ("Note"), MB_OK);

#else // OS2
VOID RunTest()
{

#endif

    FS_ENUMTEST test ;

    test.GO() ;
}


FS_ENUMTEST::FS_ENUMTEST( )
    : _fsenum1( SZ("C:\\") ),
      _fsenum2( SZ("C:\\"), SZ("*.*"), FILTYP_FILES ),
      _fsenum3( SZ("C:\\"), SZ("*.*"), FILTYP_DIRS )
#if defined(WINDOWS) && !defined( WIN32 )
      ,
      _fsenum4( SZ("E:\\") ),
      _fsenum5( SZ("E:\\"), SZ("*.*"), FILTYP_FILES ),
      _fsenum6( SZ("E:\\"), SZ("*.*"), FILTYP_DIRS )
#endif
{
    cdebug << SZ("Starting FS_ENUM test...") << dbgEOL;

    APIERR err ;
    if ( ( err = _fsenum1.QueryError()) ||
	 ( err = _fsenum2.QueryError()) ||
	 ( err = _fsenum3.QueryError())   )
    {
	cdebug << SZ("Error constructing fsenum objects, code: ") << err << dbgEOL ;
    }

#if defined(WINDOWS) && !defined( WIN32 )
    //UINT iType ;
    //if ( LFNVolumeType( 4, (int *)&iType )== NERR_Success &&
    //	   iType == VOLUME_LONGNAMES  )
    {
	//cdebug << "LFNVolumeType has identified volume E: as a long file name volume" << dbgEOL ;

	if ( ( err = _fsenum4.QueryError()) ||
	     ( err = _fsenum5.QueryError()) ||
	     ( err = _fsenum6.QueryError())   )
	{
	    cdebug << SZ("Error constructing fsenum objects, code: ") << err << dbgEOL ;
	}
    }
    //else
    //	  cdebug << "LFNVolumeType has identified volume E: as not supporting long file names, abortting." << dbgEOL ;
#endif

}

APIERR FS_ENUMTEST::GO( void )
{
    APIERR err ;
    if ( ( err = Traverse( &_fsenum1, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum2, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum3, &cdebug ) )   )
    {
	cdebug << SZ("Error code ") << err << SZ(" occurred while testing.") << dbgEOL ;
	return err ;
    }

#if defined(WINDOWS) && !defined(WIN32)
    if ( ( err = Traverse( &_fsenum4, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum5, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum6, &cdebug ) )   )
    {
	cdebug << SZ("Error code ") << err << SZ(" occurred while testing.") << dbgEOL ;
	return err ;
    }
#endif
}

FS_ENUMTEST::~FS_ENUMTEST()
{
    cdebug << SZ("End of FS_ENUM test") << dbgEOL;
}



APIERR Traverse( FS_ENUM * pFileEnum, DBGSTREAM * pMyDebug )
{
    NLS_STR nlsName ;
    while ( pFileEnum->Next() )
    {
	APIERR err = pFileEnum->QueryName( &nlsName ) ;
	*pMyDebug << (const TCHAR *)(pFileEnum->QueryAttr() & _A_SUBDIR ? SZ("[") : SZ("\t")) << nlsName <<
	       (const TCHAR *)(pFileEnum->QueryAttr() & _A_SUBDIR ? SZ("]") : SZ("")) << dbgEOL ;
    }

    if ( pFileEnum->QueryLastError() != ERROR_NO_MORE_FILES )
	return pFileEnum->QueryLastError() ;

    *pMyDebug << SZ("******************************Done************************") << dbgEOL ;

    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xoneshot\xoneshot.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xoneshot.cxx
    ONESHOT unit test: main application module

    FILE HISTORY:
        beng        28-Dec-1991 ONESHOT unit test hacked from BUFFER
        beng        16-Mar-1992 Use generic unit test skeleton
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xoneshot.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <base.hxx>
#include <uiassert.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <dbgstr.hxx>

#include <heapones.hxx>

#include "skeleton.hxx"


DBGSTREAM& operator<<(DBGSTREAM &out, const BYTE *pb)
{
#if defined(WIN32)
    HEX_STR nlsHex((ULONG)pb);

    out << SZ("0x") << nlsHex.QueryPch();
#else
    HEX_STR nlsHigh( HIWORD((ULONG)pb), 4 );
    HEX_STR nlsLow( LOWORD((ULONG)pb), 4 );

    out << nlsHigh.QueryPch() << SZ(":") << nlsLow.QueryPch();
#endif

    return out;
}


DECLARE_ONE_SHOT_OF(STUPID);
DEFINE_ONE_SHOT_OF(STUPID);

class STUPID: public BASE, public ONE_SHOT_OF(STUPID)
{
friend DBGSTREAM& operator<<(DBGSTREAM &out, const STUPID *pstupid);

private:
    UINT    _n;
    STUPID* _pstupidNext;    // next stupid along the pike
    BYTE    _abGarbage[666]; // nice and big and irregular

public:
    STUPID(UINT n);
    ~STUPID();

    VOID SetNext(STUPID *);
    STUPID * QueryNext() const;
};


STUPID::STUPID(UINT n)
    : _n(n),
      _pstupidNext(NULL)
{
    // zzz
}

STUPID::~STUPID()
{
    // zzz
}

VOID STUPID::SetNext( STUPID * pstupid )
{
    _pstupidNext = pstupid;
}

STUPID * STUPID::QueryNext() const
{
    return _pstupidNext;
}

DBGSTREAM& operator<<(DBGSTREAM &out, const STUPID *pstupid)
{
    out << SZ("Stupid #") << pstupid->_n
        << SZ(", next = ") << (const BYTE *)pstupid->_pstupidNext;

    return out;
}


class TEST: public BASE // test object allocs
{
private:
    ONE_SHOT_HEAP _osh;
    STUPID * _pstupidHead;
    STUPID * _pstupidTail;

    VOID Remember( STUPID * pstupid );
    VOID DeleteAll();
    VOID DescribeHeap() const;
    VOID DumpChain() const;

public:
    TEST(UINT cbHeap);
    ~TEST();

    VOID Run(UINT cIters = 0); // 0 = run to exhaustion
};


VOID RunTest()
{
    TEST test(8192);
    ASSERT(!!test);

    test.Run(12);
    test.Run(24);

    TEST test2(16384);
    ASSERT(!!test2);

    test2.Run(24);
    test2.Run(36);
    test2.Run(48);
}


TEST::TEST( UINT cbHeap )
    : _osh(cbHeap),
      _pstupidHead(NULL),
      _pstupidTail(NULL)
{
    if (!_osh)
    {
        APIERR err = _osh.QueryError();
        DBGEOL(SZ("Heap failed to construct - error ") << err);
        ReportError(err);
    }
}


TEST::~TEST()
{
    ASSERT(_pstupidHead == NULL);
    ASSERT(_pstupidTail == NULL);
}


VOID TEST::Run(UINT cIters)
{
    DBGEOL(SZ("Starting a test run of ") << cIters << SZ(" (attempted) stupids"));

    ONE_SHOT_OF(STUPID)::SetHeap(&_osh);

    STUPID * pstupid;
    UINT     iIter = 0;

    while ((pstupid = new STUPID(iIter++)) != NULL)
    {
        Remember(pstupid);

        if (cIters != 0 && iIter == cIters)
            break;
    }

    DumpChain();
    DescribeHeap();
    DeleteAll();
    DumpChain();

    ONE_SHOT_OF(STUPID)::SetHeap(NULL);
}


VOID TEST::Remember(STUPID * pstupid)
{
    if (_pstupidHead == NULL)
        _pstupidHead = pstupid;
    if (_pstupidTail != NULL)
        _pstupidTail->SetNext(pstupid);

    _pstupidTail = pstupid;
}


VOID TEST::DeleteAll()
{
    DBGOUT(SZ("Deleting all stupids..."));
    STUPID * pstupid = _pstupidHead;

    while (pstupid != NULL)
    {
        STUPID * pstupidPrev = pstupid;
        pstupid = pstupid->QueryNext();
        delete pstupidPrev;
    }

    _pstupidHead = _pstupidTail = NULL;
    DBGEOL(SZ(" successfully deleted all stupids"));
}


VOID TEST::DumpChain() const
{
    DBGOUT(SZ("Dumping current chain of stupids: "));

    UINT c = 0;
    for (STUPID * pstupid = _pstupidHead;
         pstupid != NULL;
         pstupid = pstupid->QueryNext(), ++c)
    {
        DBGOUT(pstupid << SZ("... "));
    }
    DBGOUT(dbgEOL);
    DBGEOL(SZ("Dumped a total of ") << c << SZ(" stupids"));
}


VOID TEST::DescribeHeap() const
{
    DBGOUT(SZ("Buffer has size ") << _osh.QuerySize());
    DBGOUT(SZ(" and addr ") << _osh.QueryPtr() << dbgEOL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\trace\cstreams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    cstreams.cxx
    Implementation for debugging streams - console versions

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Console streams
*/


#include "lmui.hxx"

extern "C"
{
    #include <stdio.h>
}

#define USE_CONSOLE
#include "dbgstr.hxx"


/*******************************************************************

    NAME:       OUTPUT_TO_STDERR::Render

    SYNOPSIS:   Render output onto the stdio "stderr" stream

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        08-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_STDERR::Render(const TCHAR *psz)
{
#if defined(UNICODE)
    // Has to convert WCHAR to CHAR
    ::fprintf(stderr, "%ws", psz);
#else
    ::fputs(psz, stderr);
#endif
}

VOID OUTPUT_TO_STDERR::Render(const TCHAR *psz, UINT cch)
{
    Render(psz); UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDERR::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the stdio "stderr" stream

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_STDERR::EndOfLine()
{
    Render(SZ("\n"), 1);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDOUT::Render

    SYNOPSIS:   Render output onto the stdio "stdout" stream

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        08-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_STDOUT::Render(const TCHAR *psz)
{
#if defined(UNICODE)
    ::fprintf(stdout, "%ws", psz);
#else
    ::fputs(psz, stdout);
#endif
}

VOID OUTPUT_TO_STDOUT::Render(const TCHAR *psz, UINT cch)
{
    Render(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDOUT::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the stdio "stdout" stream

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_STDOUT::EndOfLine()
{
    Render(SZ("\n"), 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\test\xtime\xtime.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xtime.cxx
    First test for INTL_PROFILE and WIN_TIME

    This runs under Windows only.

    FILE HISTORY:
        terryk      29-Aug-1991 Created
        terryk      16-Oct-1991 Add QueryDurationStr test case
        beng        09-Mar-1992 Hack to run under console
        beng        16-Mar-1992 Use generic unit test skeleton
        beng        13-Aug-1992 USE_CONSOLE broken
*/

// #define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xtime.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

#include "skeleton.hxx"


const TCHAR * SzBool( BOOL f )
{
    static TCHAR *const szTrue = SZ("TRUE");
    static TCHAR *const szFalse = SZ("FALSE");

    return ((f) ? szTrue : szFalse);
}


VOID RunTest()
{
    INTL_PROFILE intlprof;

    NLS_STR nlsSep;
    if ( intlprof.QueryTimeSeparator( &nlsSep ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Time separator.");
    }
    ISTR istrSep( nlsSep );
    DBGEOL( "Time Separator = " << (TCHAR)( nlsSep.QueryChar( istrSep )) );

    NLS_STR nlsStr;
    if ( intlprof.QueryAMStr( &nlsStr ) != NERR_Success )
    {
        DBGEOL( " **Cannot get AM separator." );
    }
    DBGEOL( "AM String = " << nlsStr.QueryPch() );

    if ( intlprof.QueryPMStr( &nlsStr ) != NERR_Success )
    {
        DBGEOL( " **Cannot get PM separator." );
    }
    DBGEOL( "PM String = " << nlsStr.QueryPch() );

    DBGEOL( "24 Hour ? "           << SzBool( intlprof.Is24Hour() ) );
    DBGEOL( "Hour Leading zero ? " << SzBool( intlprof.IsHourLZero() ) );

    if ( intlprof.QueryDateSeparator( &nlsSep ) != NERR_Success )
    {
        DBGEOL( " **Cannot get Date separator." );
    }
    istrSep.Reset();
    DBGEOL( "Time Separator = " << (TCHAR)(nlsSep.QueryChar( istrSep )) );

    DBGEOL( "Is Year Century ? "       << SzBool( intlprof.IsYrCentury() ) );
    DBGEOL( "Is Month Leading zero ? " << SzBool( intlprof.IsMonthLZero() ) );
    DBGEOL( "Is Day Leading zero ? "   << SzBool( intlprof.IsDayLZero() ) );

    DBGEOL( "Year Position? "  << intlprof.QueryYearPos() );
    DBGEOL( "Month Position? " << intlprof.QueryMonthPos() );
    DBGEOL( "Day Position? "   << intlprof.QueryDayPos() );

    WIN_TIME wTime;
    DBGEOL( "Current time is " << wTime.QueryTime() );

    if (intlprof.QueryTimeString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Time string" );
    }
    DBGEOL("Time String = "     << nlsStr.QueryPch() );

    if (intlprof.QueryLongDateString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Long Date string." );
    }
    DBGEOL("Long Day String = " << nlsStr.QueryPch() );

    if (intlprof.QueryShortDateString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get short day string." );
    }
    DBGEOL("Short date String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 10, 20, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 0, 20, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 0, 5, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\trace\streams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    streams.cxx
    Implementation for debugging streams.  See dbgstr.hxx for def'ns.

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Separated console and window streams
        beng        05-Mar-1992 Hacked for Unicode
        beng        16-Mar-1992 cdebug changes
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf()
*/


#if defined(WINDOWS)
# define INCL_WINDOWS
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "dbgstr.hxx"

extern "C"
{
    #include <string.h>
}

// Stream used by cdebug.  See the header file.
//
DBGSTREAM * DBGSTREAM::_pdbgCurrentGlobal = 0;

#if defined(UNICODE)
  #define SPRINTF ::swprintf
  #define SPRINT_WCHAR  SZ("%c")
  #define SPRINT_TCHAR  SPRINT_WCHAR
  #define SPRINT_CHAR   SZ("%hC")
#else
  #define SPRINTF ::sprintf
  #define SPRINT_CHAR   SZ("%c")
  #deifne SPRINT_TCHAR  SPRINT_CHAR
  #define SPRINT_WCHAR  SZ("%hC")
#endif

/*******************************************************************

    NAME:       DBGSTREAM::DBGSTREAM

    SYNOPSIS:   Constructor

    ENTRY:      pout - pointer to OUTPUTSINK to use

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

DBGSTREAM::DBGSTREAM(OUTPUTSINK * pout)
    : _pout(pout)
{
    ;
}


/*******************************************************************

    NAME:       DBGSTREAM::~DBGSTREAM

    SYNOPSIS:   Destructor

    NOTES:
        Does nothing.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

DBGSTREAM::~DBGSTREAM()
{
    ;
}


/*******************************************************************

    NAME:       DBGSTREAM::SetSink

    SYNOPSIS:   Changes the output sink associated with a stream

    ENTRY:      pout - points to new output sink

    EXIT:       stream will now write to that sink

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID DBGSTREAM::SetSink(OUTPUTSINK * pout)
{
    _pout = pout;
}


/*******************************************************************

    NAME:       DBGSTREAM::QueryCurrent

    SYNOPSIS:   Returns the current global debug stream

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Implementation outlined

********************************************************************/

DBGSTREAM & DBGSTREAM::QueryCurrent()
{
    return *_pdbgCurrentGlobal;
}


/*******************************************************************

    NAME:       DBGSTREAM::SetCurrent

    SYNOPSIS:   Determine the current global debug stream

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Implementation outlined

********************************************************************/

VOID DBGSTREAM::SetCurrent(DBGSTREAM * pdbg)
{
    _pdbgCurrentGlobal = pdbg;
}


/*******************************************************************

    NAME:       DBGSTREAM::operator<<

    SYNOPSIS:   Stream output operator

    ENTRY:      Takes some datum to render onto the output stream

    EXIT:       The stream has it

    HISTORY:
        beng        25-Oct-1991 Implementations outlined
        beng        08-Mar-1992 Fix SHORT, LONG on Win32
        beng        25-Mar-1992 Use StringPrintf on Win32
        beng        29-Mar-1992 Add simple CHAR output on Unicode;
                                fix TCHAR-USHORT conflict
        jonn        02-May-1992 StringPrintf() -> wsprintf()

********************************************************************/

DBGSTREAM& DBGSTREAM::operator<<(TCHAR c)
{
    TCHAR sz[2];
    SPRINTF(sz, SPRINT_TCHAR, c);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(const TCHAR* psz)
{
    _pout->Render(psz);
    return *this;
}

#if defined(UNICODE)
DBGSTREAM& DBGSTREAM::operator<<(CHAR c)
{
    TCHAR sz[2];
    SPRINTF(sz, SPRINT_CHAR, c);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(const CHAR* psz)
{
    TCHAR * pchTmp = new TCHAR[ ::strlen(psz)+1 ];
    if (pchTmp != NULL)
    {
        SPRINTF(pchTmp, SZ("%hs"), psz);
        _pout->Render(pchTmp);
        delete pchTmp;
    }
    return *this;
}
#endif

DBGSTREAM& DBGSTREAM::operator<<(INT n)
{
    TCHAR sz[1+CCH_INT+1];
    SPRINTF(sz, SZ("%d"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(UINT n)
{
    TCHAR sz[CCH_INT+1];
    SPRINTF(sz, SZ("%u"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(SHORT n)
{
    TCHAR sz[1+CCH_SHORT+1];
    SPRINTF(sz, SZ("%d"), (int) n );
    _pout->Render(sz);
    return *this;
}

#if !defined(UNICODE)
DBGSTREAM& DBGSTREAM::operator<<(USHORT n)
{
    TCHAR sz[CCH_SHORT+1];
    SPRINTF(sz, SZ("%u"), (UINT)n);
    _pout->Render(sz);
    return *this;
}
#endif

DBGSTREAM& DBGSTREAM::operator<<(LONG n)
{
    TCHAR sz[1+CCH_LONG+1];
    SPRINTF(sz, SZ("%ld"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(ULONG n)
{
    TCHAR sz[CCH_LONG+1];
    SPRINTF(sz, SZ("%lu"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(INT64 n)
{
    TCHAR sz[1+CCH_INT64+1];
    SPRINTF(sz, SZ("%I64d"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(UINT64 n)
{
    TCHAR sz[CCH_INT64+1];
    SPRINTF(sz, SZ("%I64u"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(DBGSTR_SPECIAL dbgSpecial)
{
    if (dbgSpecial == dbgEOL)
        _pout->EndOfLine();
    return *this;
}


/*******************************************************************

    NAME:       OUTPUT_TO_NUL::Render

    SYNOPSIS:   Discard its input (i.e. send its output to "nul")

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_NUL::Render(const TCHAR *psz)
{
    UNREFERENCED(psz);
}

VOID OUTPUT_TO_NUL::Render(const TCHAR *psz, UINT cch)
{
    UNREFERENCED(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_NUL::EndOfLine

    SYNOPSIS:   Pretend to render an EOL sequence.

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_NUL::EndOfLine()
{
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\trace\uiassert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uiassert.cxx
    Environment specific stuff for the UIASSERT & REQUIRE macro

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        johnl       17-Oct-1990 Created
        johnl       18-Oct-1990 Added OutputDebugString
        beng        30-Apr-1991 Made a 'C' file
        beng        05-Aug-1991 Withdrew expressions; reprototyped
                                all functions
        beng        17-Sep-1991 Withdrew additional consistency checks
        beng        26-Sep-1991 Withdrew nprintf calls
        beng        16-Oct-1991 Made a 'C++' file once again
        KeithMo     12-Nov-1991 Added abort/retry/ignore logic.
        jonn        09-Dec-1991 FatalAppExit() defn from new windows.h
        beng        05-Mar-1992 Hacked for Unicode
        beng        25-Mar-1992 All "filename" args are now SBCS
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf() and lazy-load
                                USER32.DLL for performance reasons.
*/

#if defined(WINDOWS)
# define INCL_WINDOWS
#elif defined(OS2)
# define INCL_OS2
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "uiassert.hxx"
#include "dbgstr.hxx"

#if defined(WINDOWS)

// Detail can be CHAR[] - it's used only as an arg to StringPrintf,
// which will convert it as necessary

static CHAR  szDetail[] = "\n\nPress:\n[Abort] to abort the app\n[Retry] to debug the app\n[Ignore] to continue";

// These two must be TCHAR, since they go to public APIs
// BUGBUG - cfront failing makes static TCHAR[] unavailable

#define SZ_MB_CAPTION  "ASSERTION FAILED"
#define SZ_FAE         "ASSERTION FAILURE IN APP"


//  Static data items used to lazy-load USER32.DLL.  This is done
//  only because NETUI0.DLL should not reference USER32 or GDI32 directly
//  if possible.

#define USER32_DLL_NAME SZ("user32.dll")
#define MSG_BOX_API_NAME "MessageBoxA"
typedef int WINAPI FN_MessageBoxA ( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType );


VOID UIAssertCommand( const CHAR * pszMessage )
{
    static FN_MessageBoxA * pfMsgBox = NULL ;
    static HMODULE hUser32 = NULL ;

    INT  nRes;

    if ( pfMsgBox == NULL )
    {
        if ( hUser32 = ::LoadLibrary( USER32_DLL_NAME ) )
        {
            pfMsgBox = (FN_MessageBoxA *) ::GetProcAddress( hUser32, MSG_BOX_API_NAME ) ;
        }
    }

    if ( pfMsgBox )
    {
        nRes = (*pfMsgBox) ( NULL,
                             (CHAR *)pszMessage,
                             SZ_MB_CAPTION,
                             MB_TASKMODAL | MB_ICONSTOP | MB_ABORTRETRYIGNORE );
    }
    else
    {
        //  Give debugging indication of assertion failure.

        DBGEOL( "NETUI ASSERT: Could not lazy-load USER32.DLL for assertion: "
                << pszMessage
                << "; aborting application" ) ;

        nRes = IDABORT ;
    }


    switch( nRes )
    {
    case IDRETRY:
        ::DebugBreak();
        return;

    case IDIGNORE:
        return;

    case IDABORT:
    default:
        ::FatalAppExitA( 0, SZ_FAE );
        break;
    }
}

static CHAR *const szFmt0 = "File %.64s, Line %u%s";
static CHAR *const szFmt1 = "%.60s: File %.64s, Line %u%s";

// BUGBUG - the following #define's are used because cfront's failing
// to support something simple like:  TCHAR szFmt0[] = SZ("foobar");
// forces the initialization to be done to a pointer.  Doing a sizeof()
// on the pointer wouldn't be very interesting.

#define SIZEOFSZFMT0 22
#define SIZEOFSZFMT1 29

DLL_BASED
VOID UIAssertHlp( const CHAR* pszFileName, UINT nLine )
{
    CHAR szBuff[SIZEOFSZFMT0+60+64+sizeof(szDetail)];

    ::sprintf(szBuff, szFmt0, pszFileName, nLine, szDetail);

    ::UIAssertCommand( szBuff );
}


DLL_BASED
VOID UIAssertHlp( const CHAR* pszMessage,
                  const CHAR* pszFileName, UINT nLine )
{
    CHAR szBuff[SIZEOFSZFMT1+60+64+sizeof(szDetail)];

    ::sprintf(szBuff, szFmt1, pszMessage, pszFileName, nLine, szDetail);

    ::UIAssertCommand( szBuff );
}


#else // OS2 -------------------------------------------------------

extern "C"
{
    #include <stdio.h>
    #include <process.h>    // abort
}

VOID UIAssertHlp( const CHAR* pszFileName, UINT nLine )
{
    ::printf(SZ("\nAssertion failed: File: %s, Line: %u\n"),
              pszFileName, nLine );
    ::abort();
}


VOID UIAssertHlp( const CHAR* pszMessage,
                  const CHAR* pszFileName, UINT nLine )
{
    ::printf(SZ("\nAssertion failed: %s, File: %s, Line: %u\n"),
              pszMessage, pszFileName, nLine );
    ::abort();
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\trace\uitrace.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uitrace.cxx
    Environment specific stuff for the UITRACE and UIDEBUG macros
    See header file or CDD for information.

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        Johnl        2-Jan-1991 Created
        beng        30-Apr-1991 Made a 'C' file
        beng        25-Sep-1991 Synchronize with changed .hxx file
        beng        25-Sep-1991 Withdrew bogus UIDEBUGNLS (never built)
        beng        26-Sep-1991 Withdrew nprintf calls
        beng        16-Oct-1991 Made a 'C++' file once again
        beng        05-Mar-1992 Hacked for Unicode
        beng        25-Mar-1992 Use winuser StringPrintf routine
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf()
*/

#if defined(WINDOWS)
# define INCL_WINDOWS
#elif defined(OS2)
# define INCL_OS2
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "uitrace.hxx"


#if defined(WINDOWS)

#if defined(UNICODE)
  #define SPRINTF ::swprintf
#else
  #define SPRINTF ::sprintf
#endif


VOID UITraceHlp( const TCHAR * psz )
{
    ::OutputDebugString((TCHAR *)psz);
}

VOID UITraceHlp( LONG n )
{
    TCHAR achBuf[30];

    SPRINTF( achBuf, TEXT("%ld"), n );
    ::OutputDebugString( achBuf );
}


#else // OS2 ------------------------------------------------------

extern "C"
{
    #include <stdio.h>
}

VOID UITraceHlp( const TCHAR * psz )
{
    ::fprintf( stderr, psz );
}

VOID UITraceHlp( LONG n )
{
    ::fprintf( stderr, SZ("%ld"), n );
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\trace\wstreams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wstreams.cxx
    Implementation for debugging streams - Windowing versions

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Split into c, wstreams
*/


#define INCL_WINDOWS
#include "lmui.hxx"

#include "blt.hxx"

#include "dbgstr.hxx"


/*******************************************************************

    NAME:       OUTPUT_TO_AUX::Render

    SYNOPSIS:   Render output onto the aux comm port

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the comm port

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        05-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_AUX::Render(const TCHAR *psz)
{
    ::OutputDebugString((TCHAR*)psz);
}

VOID OUTPUT_TO_AUX::Render(const TCHAR *psz, UINT cch)
{
    Render(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_AUX::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the aux comm port

    EXIT:
        Chars have been sent to the comm port

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_AUX::EndOfLine()
{
    Render(SZ("\r\n"), 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\wcsaux\wcsrev.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcsrev.c
    Wide-character strrev

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <wchar.h>

wchar_t * _wcsrev(wchar_t * pszArg)
{
    wchar_t *pszStart = pszArg;
    wchar_t *pszLeft = pszArg;
    wchar_t ch;

    while (*pszArg++)                 /* find end of pszArg */
        ;
    pszArg -= 2;

    while (pszLeft < pszArg)
    {
        ch = *pszLeft;
        *pszLeft++ = *pszArg;
        *pszArg-- = ch;
    }

    return pszStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\wcsaux\wcslwr.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcslwr.c
    Wide-character strlwr

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <windows.h>
#include <wchar.h>

wchar_t * _wcslwr(wchar_t * pszArg)
{
    return CharLowerW(pszArg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\h\mnetp.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    mnetp.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
	KeithMo	    13-Oct-1991	Created from DanHi's private port1632.h.

*/


#ifndef _MNETP_H_
#define _MNETP_H_


#include "mnet.h"


#endif	// _MNETP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\wcsaux\wcsupr.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcsupr.c
    Wide-character strupr

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <windows.h>
#include <wchar.h>

wchar_t * _wcsupr(wchar_t * pszArg)
{
    return CharUpperW(pszArg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\machinep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    machinep.h

Abstract:

    This is the include file that defines detect of machine type.

     This file is only included from following files

    Now only Japanese version is interested in this.

Author:

Revision History:

--*/

#ifndef _MACHINEP_ID_
#define _MACHINEP_ID_

#if defined(FE_SB) && defined(_X86_)

//
// Registry Key
//

//
// UNICODE
//

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_W      \
        L"Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   \
        L"Identifier"

#define FUJITSU_FMR_NAME_W    L"FUJITSU FMR-"
#define NEC_PC98_NAME_W       L"NEC PC-98"

//
// ANSI
//

#define REGISTRY_HARDWARE_DESCRIPTION_A \
        "\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_A      \
        "Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_A   \
        "Identifier"

#define FUJITSU_FMR_NAME_A    "FUJITSU FMR-"
#define NEC_PC98_NAME_A       "NEC PC-98"

//
// Automatic
//

#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_HARDWARE_SYSTEM      \
        TEXT("Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")

//
// These definition are only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

//
// User mode ( Win32 API )
//

ULONG RegGetMachineIdentifierValue( PULONG Value );

#endif // defined(DBCS) && defined(i386)
#endif // _MACHINE_ID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\devenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * DEVENUM:     Enumerate devices.
 * History:
 *      ChuckC      21-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Comment out winprof.hxx
 *                                  Add WIN32BUGBUG
 *      terryk      08-Nov-1991     Fix EnumNetDevice WIN32 problem
 *      terryk      18-Nov-1991     move the endif location to remove
 *                                  warning message
 *      beng        29-Mar-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_NETUSE
#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

extern "C"
{

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
    #include "mnet.h"
#if defined(FE_SB) && defined(i386) // for NEC PC98
    #include "lmuidbcs.h"
    #include "machinep.h"
#endif
}

#include "uisys.hxx"

#include "uibuffer.hxx"
#include "string.hxx"

#if defined(WINDOWS)
#include "winprof.hxx"
#endif

// forward declare
ULONG MapDrive(const TCHAR * pszDev) ;
ULONG MapComm(const TCHAR * pszDev) ;
ULONG MapLPT(const TCHAR * pszDev) ;
DLL_BASED
ULONG EnumNetDevices(INT sType) ;
DLL_BASED
ULONG EnumUnavailDevices(INT sType) ;


//
// Now only Japanese version is interested in.
// source code from machine.lib in NT3.51J.
//
#if defined(FE_SB) && defined(i386)

ULONG 
RegGetMachineIdentifierValue(
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Arguments:

    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    LONG   lRet;
    HKEY   hKey;
    DWORD  dwType;
    TCHAR  tchData[100];
    PTCHAR ptchData = tchData;
    DWORD  dwData = sizeof(tchData);
    int    cchCompareF, cchCompareN;
    LCID   lcid;

    //
    // Set default as PC/AT
    //

    *Value = MACHINEID_MS_PCAT;

    //
    // Open registry key
    //

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,       // hRootKey
                         REGISTRY_HARDWARE_SYSTEM, // SubKey
                         0,                        // Reserved
                         KEY_READ,                 // Read Op.
                         &hKey );                  // hKey

    if( lRet != ERROR_SUCCESS ) return( lRet );

    //
    // Read registry key
    //

ReTryRead:

    lRet = RegQueryValueEx( hKey,                        // kKey
                            REGISTRY_MACHINE_IDENTIFIER, // ValueName
                            NULL,                        // Reserved
                            &dwType,                     // Data Type
                            (LPBYTE)ptchData,            // Data buffer
                            &dwData );                   // Data buffer size

    if( lRet != ERROR_SUCCESS ) {

        if( lRet != ERROR_MORE_DATA ) goto Exit1;

        //
        // the Buffer is too small to store the data, we retry with
        // large buffer.
        //

        dwData += 2;

        ptchData = (PTCHAR)LocalAlloc( LMEM_FIXED , dwData );

        if( ptchData == NULL ) {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit1;
        }

        goto ReTryRead;
    }

    //
    // Determine platform.
    //

    lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
                     SORT_DEFAULT                                    );

    cchCompareF = lstrlen( FUJITSU_FMR_NAME );
    cchCompareN = lstrlen( NEC_PC98_NAME );

    if( CompareString( lcid,             // Locale id
                       NORM_IGNORECASE,  // Ignoare case
                       ptchData,         // String A.
                       cchCompareF,      // length of string A to compare
                       FUJITSU_FMR_NAME, // String B.
                       cchCompareF )     // length of string B to compare
        == 2                             // String A == String B
      ) {

        //
        // Fujitsu FMR Series.
        //

        *Value = MACHINEID_FUJITSU_FMR;

    } else if( CompareString( lcid,             // Locale id
                              NORM_IGNORECASE,  // Igonre case
                              ptchData,         // String A.
                              cchCompareN,      // length of string A to compare
                              NEC_PC98_NAME,    // String B.
                              cchCompareN )     // length of string B to compare
               == 2                             // String A == String B
             ) {

        //
        // NEC PC-9800 Seriss
        //

        *Value = MACHINEID_NEC_PC98;

    } else {

        //
        // Standard PC/AT comapatibles
        //

        *Value = MACHINEID_MS_PCAT;

    }

Exit1:

    RegCloseKey( hKey );

    return( lRet );

}

#endif // defined(FE_SB) && defined(i386)

/**************************** Local Devices **************************/


/*
    BUGBUG BUGBUG  EnumAllDrives does not return A: or B:, since this
    method is currently used only by User Manager's HomedirDrive
    dropdown.  The name EnumAllDrives is misleading and should be
    changed.
*/

/*---------------- OS-independent -----------------*/

/*
 * cycle thru the drives, and return mask of all valid drive designations
 */
ULONG EnumAllDrives()
{
    ULONG  ulMask, ulMap = 0L ;
    TCHAR  szDrive[3] ;

    // get drive map
    ulMap = 0L ;                // We don't have A:, B:
    *szDrive = TCH('\0') ;

#if defined(FE_SB) && defined(i386)
    //
    // Now only Japanese version interested in it.
    //
    DWORD gdwMachineId = MACHINEID_MS_PCAT;
    if ( NETUI_IsDBCS() )
    {
        RegGetMachineIdentifierValue( &gdwMachineId );
    }
    //
    // Add A: and B: if the running platform is NEC PC98.
    //
    if ( ISNECPC98(gdwMachineId) )
    {
        ::strcpyf(szDrive, SZ("A:")) ;
        ulMask = 0x01L ;
    }
    else
    {
#endif // defined(FE_SB) && defined(i386)
    ::strcpyf(szDrive, SZ("C:")) ;
    ulMask = 0x04L ;
#if defined(FE_SB) && defined(i386) // for NEC PC98
    }
#endif // defined(FE_SB) && defined(i386)
    do
    {
        ulMap |= ulMask ;
        ulMask <<= 1 ;
        ++*szDrive ;
    } while (*szDrive <= TCH('Z')) ;

    return ( ulMap ) ;
}

ULONG EnumAllLPTs()
{
    return EnumLocalLPTs();
}

ULONG EnumAllComms()
{
    return EnumLocalComms();
}


#if defined(OS2)

/*---------------- OS2 specific -----------------*/

/*
 * return drive map as obtained via DosQCurDisk()
 */
ULONG EnumLocalDrives()
{
    USHORT usDummy ;
    APIERR err;
    ULONG  ulMap ;

    // get drive map
    err = DosQCurDisk(&usDummy, &ulMap);
    if (err != NERR_Success)
        return(0L) ;

    return ( ulMap ) ;
}

/*
 * under OS2 we have LPT1 to LPT9
 */
ULONG EnumLocalLPTs()
{
    return( 0x01FFL ) ;
}

/*
 * under OS2 we have COM1 to COM9
 */
ULONG EnumLocalComms()
{
    return( 0x01FFL ) ;
}

#elif defined(WINDOWS)

/*---------------- Win specific -----------------*/


/*
 * under Windows we have LPT1 to LPT3, LPT1.OS2 and LPT2.OS2
 */
ULONG EnumLocalLPTs()
{
    return( 0x0607L ) ;
}

/*
 * under windows we have COM1 to COM3
 */
ULONG EnumLocalComms()
{
    return( 0x0007L ) ;
}

#else           // must be DOS

/*---------------- DOS specific -----------------*/


/*
 * we have LPT1 to LPT3
 */
ULONG EnumLocalLPTs()
{
    return( 0x0007L ) ;
}

/*
 * we have COM1 to COM3
 */
ULONG EnumLocalComms()
{
    return( 0x0007L ) ;
}

#endif

#ifndef OS2

/*---------------- WIN/DOS specific -----------------*/

/*
 * cycle thru the drives, seeing which is valid, and return mask of valid ones
 */
DLL_BASED
ULONG EnumLocalDrives()
{
    ULONG  ulMask, ulMap = 0L ;
    TCHAR  szDrive[3] ;

    // get drive map
    ulMap = 3L ;                // always have A:, B:
    *szDrive = TCH('\0') ;
    ::strcpyf(szDrive, SZ("C:")) ;
    ulMask = 0x04L ;
    do
    {
        if (CheckLocalDrive(szDrive) == NERR_Success)
            ulMap |= ulMask ;
        ulMask <<= 1 ;
        ++*szDrive ;
    } while (*szDrive <= TCH('Z')) ;

    return ( ulMap ) ;
}

#endif

/**************************** Redirected Devices **************************/

DLL_BASED
ULONG EnumNetDrives()
{
    return(EnumNetDevices(USE_DISKDEV)) ;
}

DLL_BASED
ULONG EnumNetLPTs()
{
    return(EnumNetDevices(USE_SPOOLDEV)) ;
}

DLL_BASED
ULONG EnumNetComms()
{
    return(EnumNetDevices(USE_CHARDEV)) ;
}

/*
 * actual worker routine, enumerates all redirected devices
 * as spec by sType.
 */
DLL_BASED
ULONG EnumNetDevices(INT sType)
{
    ULONG ulMap ;
    BYTE *pbBuffer = NULL;
    struct use_info_0 * pUseInfo0 ;
    UINT usEntriesRead ;
    APIERR err;

    // call net use enum to get all redirections
    err = ::MNetUseEnum((TCHAR *)NULL,
                     0,
                     &pbBuffer,
                     &usEntriesRead) ;

    if (err != NERR_Success)
    {
        // if still error, none
        return(0L) ;
    }

    ulMap = 0L ;
    pUseInfo0 = (struct use_info_0 *) pbBuffer ;
    while (usEntriesRead--)
    {
        if (pUseInfo0->ui0_local[0])
        {
            if (sType == USE_SPOOLDEV &&
                !::strnicmpf(SZ("LPT"),pUseInfo0->ui0_local,3))
                    ulMap |= MapLPT((const TCHAR *)pUseInfo0->ui0_local) ;
            else if (sType == USE_CHARDEV &&
                !::strnicmpf(SZ("COM"),pUseInfo0->ui0_local,3))
                    ulMap |= MapComm((const TCHAR *)pUseInfo0->ui0_local) ;
            else if (sType == USE_DISKDEV &&
                pUseInfo0->ui0_local[1] == TCH(':'))
                    ulMap |= MapDrive((const TCHAR *)pUseInfo0->ui0_local) ;
        }
        pUseInfo0++ ;
    }

    ::MNetApiBufferFree( &pbBuffer );

    return(ulMap) ;
}

/**************************** Unavailable Devices **************************/

// BUGBUG - No OS2 or DOS support currently, this is only used by winnet.

DLL_BASED
ULONG EnumUnavailDrives()
{
    return(EnumUnavailDevices(USE_DISKDEV)) ;
}

DLL_BASED
ULONG EnumUnavailLPTs()
{
    return(EnumUnavailDevices(USE_SPOOLDEV)) ;
}

DLL_BASED
ULONG EnumUnavailComms()
{
    return(EnumUnavailDevices(USE_CHARDEV)) ;
}

/*
 * enumerate unavail device
 */
DLL_BASED
ULONG EnumUnavailDevices(INT sType)
{
#if defined(WINDOWS)

#if defined(WIN32)
    // BIG BUGBUG
    //WIN32BUGBUG
    //WIN32BUGBUG
    //WIN32BUGBUG
    return(0L);
#else

    /*
     * in the Win case, we are Winnet specific. This is the
     * only planned use of Profile.
     */
    ULONG ulMap ;
    APIERR err ;
    TCHAR * pszDevList ;
    BUFFER buffer((DEVLEN + 1) * 46 + 1) ; // BUGBUG UNICODE
    // 46 handles worst case of a:-z:, lpt1-1pt9, com1-com9

    err = PROFILE::Enum(&buffer);
    if (err != NERR_Success )
    {
        // if cannot enum, say there is none
        return(0L) ;
    }

    ulMap = 0L ;
    pszDevList = (TCHAR *) buffer.QueryPtr();

    /*
     * we know pszDevList is now a NULL NULL list of devices
     */
    while (pszDevList && *pszDevList)
    {
        USHORT usLen ;

        usLen = ::strlenf((LPSTR)pszDevList) ;
        {
            if (sType == USE_DISKDEV &&
                *(pszDevList+1) == TCH(':'))
                    ulMap |= MapDrive(pszDevList) ;
            else if (sType == USE_SPOOLDEV &&
                !::strncmpf(SZ("LPT"),(LPSTR)pszDevList,3))
                    ulMap |= MapLPT(pszDevList) ;
            else if (sType == USE_CHARDEV &&
                !::strncmpf(SZ("COM"),(LPSTR)pszDevList,3))
                    ulMap |= MapComm(pszDevList) ;
        }
        pszDevList += (usLen + 1) ;
    }

    return(ulMap) ;
# endif // WIN32
#endif // WINDOWS
}

/**************************** Worker Routines **************************/

/*
 * map LPTx to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapLPT(const TCHAR * pszDev)
{
    if (!::strcmpf((TCHAR FAR *)pszDev, SZ("LPT1.OS2")))
        return( 0x0200L ) ;
    else if (!::strcmpf((TCHAR FAR *)pszDev, SZ("LPT2.OS2")))
        return( 0x0400L ) ;
    return( 1L << (pszDev[3]-TCH('1')) ) ;
}

/*
 * map COMx to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapComm(const TCHAR * pszDev)
{
    return( 1L << (pszDev[3]-TCH('1')) ) ;
}

/*
 * map X: to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapDrive(const TCHAR * pszDev)
{
    return( 1L << (pszDev[0]-TCH('A')) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\wintime\ctime.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ctime.cxx
    WIN_TIME class source file.

    FILE HISTORY:
        terryk  27-Aug-91       Created
        terryk  13-Sep-91       Code review changes. Attend: beng
                                davidbul o-simop
        terryk  20-Nov-91       change _ptmTime to _tmTime
        terryk  06-Dec-91       Normalize bug fixed

*/

#include "ntincl.hxx"

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include "uiassert.hxx"
#include "uitrace.hxx"
#include "ctime.hxx"


/*******************************************************************

    NAME:       WIN_TIME::WIN_TIME

    SYNOPSIS:   constrcutor for WIN_TIME object

    ENTRY:      if no parameter is specified, set the object to current
                time. Otherwise, set the object to the specified time.
                BOOL fStoreAsGMT is specified the presentation method in local
                time or GMT time.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

WIN_TIME::WIN_TIME( BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    _fileTime.dwLowDateTime = 0;
    _fileTime.dwHighDateTime = 0;

    _sysTime.wYear = 0;
    _sysTime.wMonth = 0;
    _sysTime.wDay = 0;
    _sysTime.wDayOfWeek = 0;
    _sysTime.wHour = 0;
    _sysTime.wMinute = 0;
    _sysTime.wSecond = 0;
    _sysTime.wMilliseconds = 0;
}

WIN_TIME::WIN_TIME( ULONG tTimeGMT, BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    APIERR err;
    if ( (err = SetTime( tTimeGMT )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

/*
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG) _sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );
*/
}

WIN_TIME::WIN_TIME( FILETIME fileTimeGMT, BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    APIERR err;
    if ( (err = SetTime( fileTimeGMT )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

/*
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG)_sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );
*/
}

/*******************************************************************

    NAME:       WIN_TIME::SetCurrentTime

    SYNOPSIS:   set the time object to the current time
                ONLY CALL THIS WHEN _fStoreAsGMT IS TRUE!

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetCurrentTime()
{
    if ( _fStoreAsGMT )
        GetSystemTime( &_sysTime );
    else
        GetLocalTime( &_sysTime );

    APIERR err = NERR_Success;
    if ( !SystemTimeToFileTime( &_sysTime, &_fileTime ) )
        err = ::GetLastError();

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTime

    SYNOPSIS:   set the time object to the specified time

    ENTRY:      ULONG tTimeGMT - the time to be set.
                                 ( number of seconds since 1970 )

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTime( ULONG tTimeGMT )
{
    APIERR err = NERR_Success;

    LARGE_INTEGER tmpTime;

    ::RtlSecondsSince1970ToTime( tTimeGMT, &tmpTime ); // can't fail
    _fileTime.dwLowDateTime = tmpTime.LowPart;
    _fileTime.dwHighDateTime = tmpTime.HighPart;

    if ( !_fStoreAsGMT )
    {
        FILETIME fileTime = _fileTime;
        if ( !FileTimeToLocalFileTime( &fileTime, &_fileTime ))
            err = ::GetLastError();
    }

    if ( err == NERR_Success )
    {
        if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
        {
                err = ::GetLastError();
        }
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTime

    SYNOPSIS:   set the time object to the specified GMT time

    ENTRY:      FILETIME fileTimeGMT - the GMT time to be set.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTime( FILETIME fileTimeGMT )
{
    APIERR err = NERR_Success;

    if ( _fStoreAsGMT )
    {
        _fileTime = fileTimeGMT;
    }
    else
    {
        if ( !FileTimeToLocalFileTime( &fileTimeGMT, &_fileTime ))
            return ::GetLastError();
    }

    if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTimeLocal

    SYNOPSIS:   set the time object to the specified time

    ENTRY:      ULONG tTimeLocal - the time to be set.
                                   ( number of seconds since 1970 )

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTimeLocal( ULONG tTimeLocal )
{
    APIERR err = NERR_Success;

    FILETIME fileTimeLocal;
    LARGE_INTEGER tmpTime;

    ::RtlSecondsSince1970ToTime( tTimeLocal, &tmpTime ); // can't fail
    fileTimeLocal.dwLowDateTime = tmpTime.LowPart;
    fileTimeLocal.dwHighDateTime = tmpTime.HighPart;

    return SetTimeLocal( fileTimeLocal );
}

/*******************************************************************

    NAME:       WIN_TIME::SetTimeLocal

    SYNOPSIS:   set the time object to the specified local time

    ENTRY:      FILETIME fileTimeLocal - the local time to be set.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTimeLocal( FILETIME fileTimeLocal )
{
    APIERR err = NERR_Success;

    if ( !_fStoreAsGMT )
    {
        _fileTime = fileTimeLocal;
    }
    else
    {
        if ( !LocalFileTimeToFileTime( &fileTimeLocal, &_fileTime ))
            return ::GetLastError();
    }

    if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetGMT

    SYNOPSIS:   Set the time present method

    ENTRY:      BOOL fStoreAsGMT - TRUE for gmt time
                                   FALSE for local time

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetGMT( BOOL fStoreAsGMT )
{
    APIERR err = NERR_Success;

    if ( fStoreAsGMT != _fStoreAsGMT )
    {
        _fStoreAsGMT = fStoreAsGMT;

        FILETIME fileTime = _fileTime;
        if ( _fStoreAsGMT )
        {
            if ( !LocalFileTimeToFileTime( &fileTime, &_fileTime ))
                err = ::GetLastError();

        }
        else
        {
            if ( !FileTimeToLocalFileTime( &fileTime, &_fileTime ))
                err = ::GetLastError();
        }
    }

    if ( err == NERR_Success )
    {
        if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
            err = ::GetLastError();
    }

    return err;
}


/*******************************************************************

    NAME:       WIN_TIME::Normalize

    SYNOPSIS:   Use after the SetXXX methods. It will set the day of
                week and year day appropriately.

    RETURNS:    TRUE - success
                FALSE - failure

    HISTORY:
                terryk  27-Aug-91       Created
                terryk  05-Dec-91       If it is GMT, subtract the time
                                        zone different and set time again

********************************************************************/

APIERR WIN_TIME::Normalize()
{
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG) _sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );

    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );

    if ( !SystemTimeToFileTime( &_sysTime, &_fileTime ) )
        return ::GetLastError();

    return NERR_Success;
}

APIERR WIN_TIME::QueryTime( ULONG *ptTimeGMT ) const
{
    UIASSERT( ptTimeGMT != NULL );

    APIERR err = NERR_Success;

    FILETIME fileTime;
    if ( !_fStoreAsGMT )
    {
        if ( !LocalFileTimeToFileTime( (FILETIME *) &_fileTime, &fileTime ))
            err = ::GetLastError();
    }
    else
    {
        fileTime = _fileTime;
    }

    if ( err == NERR_Success )
    {
        LARGE_INTEGER tmpTime;

        tmpTime.LowPart = fileTime.dwLowDateTime;
        tmpTime.HighPart = fileTime.dwHighDateTime;

        if ( !RtlTimeToSecondsSince1970( &tmpTime, ptTimeGMT ))
            err = ERROR_GEN_FAILURE; // best we can do

    }

    return err;
}

APIERR WIN_TIME::QueryFileTime( FILETIME *pfileTimeGMT ) const
{
    UIASSERT( pfileTimeGMT != NULL );

    APIERR err = NERR_Success;

    if ( !_fStoreAsGMT )
    {
        if ( !LocalFileTimeToFileTime( (FILETIME *) &_fileTime, pfileTimeGMT ))
            err = ::GetLastError();
    }
    else
    {
        *pfileTimeGMT = _fileTime;
    }

    return err;
}

APIERR WIN_TIME::QueryTimeLocal( ULONG *ptTimeLocal ) const
{
    UIASSERT( ptTimeLocal != NULL );

    FILETIME fileTime;

    APIERR err = QueryFileTimeLocal( &fileTime );

    if ( err == NERR_Success )
    {
        LARGE_INTEGER tmpTime;

        //
        // JonN 7/10/95 Corrected bug here; this previously read
        // _fileTime, which meant we were returning GMT time if the
        // WIN_TIME object was set for GMT.
        //
        tmpTime.LowPart = fileTime.dwLowDateTime;
        tmpTime.HighPart = fileTime.dwHighDateTime;

        if ( !RtlTimeToSecondsSince1970( &tmpTime, ptTimeLocal ))
            err = ERROR_GEN_FAILURE; // best we can do

    }

    return err;
}

APIERR WIN_TIME::QueryFileTimeLocal( FILETIME *pfileTimeLocal ) const
{
    UIASSERT( pfileTimeLocal != NULL );

    APIERR err = NERR_Success;

    if ( _fStoreAsGMT )
    {
        if ( !FileTimeToLocalFileTime( (FILETIME *) &_fileTime, pfileTimeLocal ))
            err = ::GetLastError();
    }
    else
    {
        *pfileTimeLocal = _fileTime;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\misc\wintime\intlprof.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    intlprof.cxx
    Source file for international profile information class.

    This module contains functions for managing time and date strings
    using internationalization.

    The functions in this module assume that all WIN.INI international
    settings are valid.  If the settings are not there (which is the
    case until a change is made through control panel) defaults are
    used.

    If the WIN.INI strings (such as the sLongDate string) is invalid
    in someway (i.e. it was NOT written by Control Panel) this code
    will probably break.

    FILE HISTORY:
        Jonn        02/25/91    Obtained from CharlKin
        DavidHov    ???         modified for use in WinPopup
        terryk      27-Aug-91   Change it to C++ class
        terryk      13-Sep-91   Code review change. Attend: davidbul
                                o-simop beng
        terryk      07-Oct-91   add QueryDurationStr() function
        terryk      31-Oct-91   add 1 to QueryMonth() in
                                QueryShortDateString
        beng        05-Mar-1992 Hacked/rewritten extensively
                                (Unicode, size issues)
        jonn        23-Mar-1992 NETUI\common\xlate on path
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_DOSERRORS
#include "lmui.hxx"

extern "C"
{
    #include <time.h>
    #include "wintimrc.h"
    #include "lmuidbcs.h"
}

#include "string.hxx"
#include "strnumer.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "ctime.hxx"
#include "intlprof.hxx"

#include "blt.hxx"
#include "dbgstr.hxx"


// BUGBUG - are the following CCHSIZE values adequate?
// Are such limits even appropriate?

#define SZDEF_LONGDATE  SZ("ddd', 'MMMM' 'dd', 'yyyy")
#define CCHSIZE_LONGDATE    34

#define SZDEF_SHORTDATE SZ("MM/dd/yy")
#define CCHSIZE_SHORTDATE   11

#define LWRD TCH('d')
#define LWRY TCH('y')
#define UPRM TCH('M')

#define CCHSIZE_SEPARATOR  3
#define CCHSIZE_AMPM       5


/*******************************************************************

    NAME:       INTL_PROFILE::INTL_PROFILE

    SYNOPSIS:   constructor - get the information from the win.ini file

    HISTORY:
                terryk  28-Aug-91       Created

********************************************************************/

INTL_PROFILE::INTL_PROFILE()
    : _f24Hour( FALSE ),
    _fHourLZero( FALSE ),
    _fYrCentury( FALSE ),
    _fMonthLZero( FALSE ),
    _fDayLZero( FALSE ),
    _nYearPos( 1 ),
    _nMonthPos( 2 ),
    _nDayPos( 3 ),
    _nlsLongDate( SZDEF_LONGDATE ),
    _nlsShortDate( SZDEF_SHORTDATE ),
    _nlsTimeSep( SZ(":") ),
    _nlsDateSep( SZ("/") ),
    _nlsAMStr( SZ("AM") ),
    _nlsPMStr( SZ("PM") ),
    _fTimePrefix( FALSE )
{
    APIERR err;
    if ((( err = _nlsLongDate.QueryError() ) != NERR_Success ) ||
        (( err = _nlsShortDate.QueryError() ) != NERR_Success ) ||
        (( err = _nlsTimeSep.QueryError() ) != NERR_Success ) ||
        (( err = _nlsDateSep.QueryError() ) != NERR_Success ) ||
        (( err = _nlsAMStr.QueryError() ) != NERR_Success ) ||
        (( err = _nlsPMStr.QueryError() ) != NERR_Success ))
    {
        ReportError( err );
        ASSERT( FALSE );
        return;
    }

    // Since we only have 1 copy of the object anyway, it is okay to make
    // all the shareable strings to local member variables.
    //
    // In an international setting "Sunday" may not be abbrieviated
    // as "Sun".
    //

    for (INT i = 0 ; i <= 6 ; i++)
    {
        if ((( err =  _nlsWDay[i].Load( IDS_SUNDAY + i, NLS_BASE_DLL_HMOD )) != NERR_Success ) ||
            (( err = _nlsShortWDay[i].Load( IDS_SUNDAY_SHORT + i, NLS_BASE_DLL_HMOD )) != NERR_Success ))
        {
            ReportError( err );
            ASSERT( FALSE );
            return;
        }
    }

    for (i = 0 ; i <= 11 ; i++)
    {
        if ((( err = _nlsMonth[i].Load( IDS_JANUARY + i, NLS_BASE_DLL_HMOD )) != NERR_Success) ||
            (( err = _nlsShortMonth[i].Load( IDS_JANUARY_SHORT + i, NLS_BASE_DLL_HMOD ))
                != NERR_Success))
        {
            ReportError( err );
            ASSERT( FALSE );
            return;
        }
    }

    // Get the latest information
    err = Refresh();
    if ( err != NERR_Success )
    {
        ReportError( err );
        ASSERT( FALSE );
        return;
    }
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryDateSeparator

    SYNOPSIS:   return the date string in win.ini

    ENTRY:      NLS_STR * pnlsSep - pointer to a string buffer

    RETURNS:    NERR_Success if succeed, FALSE otherwise. If succeed,
                pnlsSep will set to the separator string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryDateSeparator( NLS_STR * pnlsSep ) const
{
    UIASSERT( pnlsSep != NULL );
    *pnlsSep = _nlsDateSep;
    return pnlsSep->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryDurationStr

    SYNOPSIS:   return a string
                        X day   if X is less than 2
                        X days  if X is bigger than 2

    ENTRY:      INT cDay - the X value in the string
                INT cHour - the hour value
                INT cMin - the minute value
                INT cSec - the second value
                NLS_STR *pnlsStr - the resultant string

    RETURNS:    APIERR of the string operation

    HISTORY:
        terryk  8-Oct-91        Created
        beng    05-Mar-1992     Rewrote to remove wsprintf

********************************************************************/

APIERR INTL_PROFILE::QueryDurationStr( INT cDay, INT cHour, INT cMin,
                                       INT cSec, NLS_STR *pnlsStr ) const
{
    UIASSERT( pnlsStr != NULL );

    if ( cDay <= 0 )
    {
        // Format a mess of strings.  Delay errcheck until Append calls

        DEC_STR nlsHour(cHour, IsHourLZero() ? 2 : 1);
        DEC_STR nlsMinute(cMin, 2);
        DEC_STR nlsSecond(cSec, 2);

        NLS_STR nlsFormat(40); // avoid repeated reallocs

        APIERR err;
        if (   ((err = nlsFormat.Append(nlsHour)) != NERR_Success)
            || ((err = nlsFormat.Append(_nlsTimeSep)) != NERR_Success)
            || ((err = nlsFormat.Append(nlsMinute)) != NERR_Success)
            || ((err = nlsFormat.Append(_nlsTimeSep)) != NERR_Success)
            || ((err = nlsFormat.Append(nlsSecond)) != NERR_Success) )
        {
            return err;
        }

        *pnlsStr = nlsFormat;
    }
    else
    {
        DEC_STR nlsDay(cDay);
        DEC_STR nlsHour(cHour);
        DEC_STR nlsMinute(cMin);

        APIERR err;
        if (   ((err = nlsDay.QueryError()) != NERR_Success)
            || ((err = nlsHour.QueryError()) != NERR_Success)
            || ((err = nlsMinute.QueryError()) != NERR_Success)
            || ((err = pnlsStr->Load( IDS_SESSION_DURATION, NLS_BASE_DLL_HMOD )) != NERR_Success)
            || ((err = pnlsStr->InsertParams( nlsDay, nlsHour, nlsMinute ))
                != NERR_Success) )
        {
            return err;
        }
    }

    return pnlsStr->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryTimeSeparator

    SYNOPSIS:   return the time string in win.ini

    ENTRY:      NLS_STR * pnlsSep - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsSep
                will set to the separator string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryTimeSeparator( NLS_STR * pnlsSep ) const
{
    UIASSERT( pnlsSep != NULL );
    *pnlsSep = _nlsTimeSep;
    return pnlsSep->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryAMStr

    SYNOPSIS:   return the AM string in win.ini

    ENTRY:      NLS_STR * pnlsAM - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsAM
                will set to the AM string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryAMStr( NLS_STR * pnlsAM ) const
{
    UIASSERT( pnlsAM );
    *pnlsAM = _nlsAMStr;
    return pnlsAM->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryPMStr

    SYNOPSIS:   return the PM string in win.ini

    ENTRY:      NLS_STR * pnlsPM - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsPM
                will set to the PM string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryPMStr( NLS_STR * pnlsPM ) const
{
    UIASSERT( pnlsPM != NULL );
    *pnlsPM = _nlsPMStr;
    return pnlsPM->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryTimeString

    SYNOPSIS:   get the time string of the given time

    ENTRY:      WIN_TIME & winTime - the specified time object
                NLS_STR * pnlsTime - returned string

    RETURNS:    NERR_Success if succeed. Otherwise failure.

    HISTORY:
        terryk  27-Aug-91       Created
        beng    05-Mar-1992     Rewrote to remove wsprintf

********************************************************************/

APIERR INTL_PROFILE::QueryTimeString( const WIN_TIME & winTime,
                                      NLS_STR * pnlsTime ) const
{
    UIASSERT( pnlsTime != NULL );

    INT cHour = winTime.QueryHour();
    INT cMinute = winTime.QueryMinute();
    INT cSecond = winTime.QuerySecond();

    INT nHourDisplay = Is24Hour() ? cHour
                                  : ((cHour % 12) ? (cHour % 12) : 12) ;

    NLS_STR nlsFormat;
    APIERR err = QueryDurationStr(0, nHourDisplay, cMinute, cSecond,
                                  &nlsFormat);
    if (err != NERR_Success)
    {
        return err;
    }

    if (!Is24Hour())
    {
        const NLS_STR & nlsSuffix = *((cHour < 12) ? &_nlsAMStr : &_nlsPMStr);

        if( NETUI_IsDBCS() && IsTimePrefix() )
        {
            NLS_STR nlsFormat2;
            nlsFormat2.Append( nlsSuffix );
            err = nlsFormat2.AppendChar(TCH(' '));
            err = nlsFormat2.Append(nlsFormat);
            *pnlsTime = nlsFormat2;
        }
        else
        {
            err = nlsFormat.AppendChar(TCH(' '));
            err = nlsFormat.Append(nlsSuffix);
        }				
    }

    if ( Is24Hour() || !NETUI_IsDBCS() || !IsTimePrefix() )
        *pnlsTime = nlsFormat;

    return pnlsTime->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryShortDateString

    SYNOPSIS:   get the short format of date string

    ENTRY:      WIN_TIME & winTime - time object
                NLS_STR *pnlsDate - the result string

    RETURNS:    APIERR err - NERR_Success if succeed

    NOTE:       According to the international handbook. sShortDate only
                accepts the format specified M, MM, d, dd, yy, and yyyy.
                Therefore, we only need to check for IsMonthLZero and
                IsDayLZero and IsYrCentury.

    HISTORY:
        terryk  29-Aug-91       Created
        beng    05-Mar-1992     Rewritten for Unicode

********************************************************************/

APIERR INTL_PROFILE::QueryShortDateString( const WIN_TIME & winTime,
                                           NLS_STR *pnlsDate ) const
{
    INT nYear = winTime.QueryYear();
    if ( !IsYrCentury() )
        nYear %= 100;

    // ctors will be checked in Append statements below

    DEC_STR nlsYear(nYear,                   IsYrCentury() ? 4 : 2);
    DEC_STR nlsMonth(winTime.QueryMonth(),     IsMonthLZero() ? 2 : 1);
    DEC_STR nlsDay(winTime.QueryDay(),         IsDayLZero() ? 2 : 1);

    ASSERT(QueryYearPos() != QueryMonthPos());
    ASSERT(QueryYearPos() != QueryDayPos());
    ASSERT(QueryDayPos() != QueryMonthPos());

    NLS_STR * pnlsFields[3];
    pnlsFields[QueryYearPos()-1] = &nlsYear;
    pnlsFields[QueryMonthPos()-1] = &nlsMonth;
    pnlsFields[QueryDayPos()-1] = &nlsDay;

    NLS_STR nlsFormat(40); // avoid repeated reallocs

    APIERR err;
    if (   ((err = nlsFormat.Append(*pnlsFields[0])) != NERR_Success)
        || ((err = nlsFormat.Append(_nlsDateSep)) != NERR_Success)
        || ((err = nlsFormat.Append(*pnlsFields[1])) != NERR_Success)
        || ((err = nlsFormat.Append(_nlsDateSep)) != NERR_Success)
        || ((err = nlsFormat.Append(*pnlsFields[2])) != NERR_Success) )
    {
        return err;
    }

    *pnlsDate = nlsFormat;
    return pnlsDate->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::ScanLongDate

    SYNOPSIS:   Preprocess long-date picture string

    ENTRY:      NLS_STR * pnlsResults - repository for results

    EXIT:       String has all picture descriptions replaced with
                %x insert-params codes, and all quotes and separators
                processed correctly.

    RETURNS:    APIERR err. NERR_Success if succeed.

    NOTE:
        This is a private member function.

    HISTORY:
        beng    07-Mar-1992     Created

********************************************************************/

APIERR INTL_PROFILE::ScanLongDate( NLS_STR * pnlsResults ) const
{
    // Tables of insert-strings corresponding to the key-substrings.

    static const TCHAR * apszMCodes[] = {SZ("%1"), SZ("%2"),
                                         SZ("%3"), SZ("%4")};
    static const TCHAR * apszDCodes[] = {SZ("%5"), SZ("%6"),
                                         SZ("%7"), SZ("%8")};
    static const TCHAR * apszYCodes[] = {NULL,     SZ("%9"),
                                         NULL,     SZ("%10")};

    NLS_STR nlsProcessed(60);   // Accumulated results.  The allocation count
                                // is just a guess to minimize allocs
    ISTR istrSrc(_nlsLongDate); // Index into above
    BOOL fBeginSep = TRUE;      // If next character could begin a separator

    APIERR err;
    WCHAR wchNext;
    while ((wchNext = _nlsLongDate.QueryChar(istrSrc)) != 0)
    {
        ++istrSrc;

        switch (wchNext)
        {
        case TCH('\''):
            // Quote - either within unquoted separator or else
            // beginning a quoted separator.

            if (!fBeginSep)
            {
                // A quote in the middle of an unquoted separator
                // means "emit next literal character."

                err = nlsProcessed.AppendChar(_nlsLongDate.QueryChar(istrSrc));
                if (err != NERR_Success)
                    return err;
                ++istrSrc;
            }
            else
            {
                // Match quoted separator.  Within a quoted separator,
                // two quotes becomes a single quote char.

                BOOL fEscapeNextQuote = FALSE;
                for (;;)
                {
                    wchNext = _nlsLongDate.QueryChar(istrSrc);

                    if (wchNext == TCH('\''))
                    {
                        ++istrSrc;
                        if (fEscapeNextQuote)
                        {
                            // Reset the flag, then fall out so quote
                            // is appended to output
                            fEscapeNextQuote = FALSE;
                        }
                        else
                        {
                            // Set the flag, then go get another character
                            // right away
                            fEscapeNextQuote = TRUE;
                            continue;
                        }
                    }
                    else if (fEscapeNextQuote)
                    {
                        // Last character wasn't a quote.
                        // We're done.
                        break;
                    }
                    else if (wchNext == 0)
                    {
                        // Hit a null when looking for closing quote

                        DBGEOL(SZ("Syntax error in sLongDate - unmatched quotes"));
                        return ERROR_GEN_FAILURE;
                    }
                    else
                    {
                        ++istrSrc;
                    }

                    err = nlsProcessed.AppendChar(wchNext);
                    if (err != NERR_Success)
                        return err;
                }
            }
            break;

        case TCH('M'):
        case TCH('d'):
        case TCH('y'):
            {
                // Match any of the recognized date key-strings, and replace
                // it with the appropriate insertion-string.

                WCHAR wchLast = wchNext;
                UINT iWhich = 0;

                while ((wchNext = _nlsLongDate.QueryChar(istrSrc)) == wchLast)
                {
                    ++istrSrc;
                    if (++iWhich == 3) // All types have a max length of 4.
                        break;
                }

                const TCHAR ** ppszCodes =
                    (wchLast == TCH('M') ? apszMCodes
                                        : (wchLast == TCH('d') ? apszDCodes
                                                              : apszYCodes));
                const TCHAR * pszCode = ppszCodes[iWhich];
                if (pszCode == NULL)
                {
                    // See table.  Probably an odd number of "y" chars.
                    DBGEOL(SZ("Syntax error in sLongDate - unknown key"));
                    return ERROR_GEN_FAILURE;
                }
                err = nlsProcessed.Append(ALIAS_STR(pszCode));
                if (err != NERR_Success)
                    return err;

                // WARNING: GROSS HACK
                // Since the codes use NLS_STR::InsertParams to insert the
                // appropriate versions, if the next character is a decimal
                // digit it will confuse the simpleminded inserter.  In that
                // rare case I append a space to the insert-code.  This will
                // give an extra space in the output, where presumably the
                // originator wanted the format value to run right into the
                // next number.  I'm going to walk way out on a limb here
                // and say that it'll never happen in my lifetime....

                wchNext = _nlsLongDate.QueryChar(istrSrc); // peek ahead
                if (wchNext >= TCH('0') && wchNext <= TCH('9'))
                {
                    err = nlsProcessed.AppendChar(TCH(' '));
                    if (err != NERR_Success)
                        return err;
                }
            }
            fBeginSep = TRUE;
            break;

        default:
            // Some character in an unquoted separator.

            err = nlsProcessed.AppendChar(wchNext);
            if (err != NERR_Success)
                return err;
            fBeginSep = FALSE;
            break;
        }
    }

    *pnlsResults = nlsProcessed;
    return pnlsResults->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryLongDateString

    SYNOPSIS:   get the date string in Long format according to WIN.INI
                format

    ENTRY:      WIN_TIME & winTime - current time/date object
                NLS_STR *nlsDate - the resultant string

    RETURNS:    APIERR err. NERR_Success if succeed.

    HISTORY:
        terryk  29-Aug-91       Created
        beng    07-Mar-1992     Rewrote (Unicode fixes, size)

********************************************************************/

APIERR INTL_PROFILE::QueryLongDateString( const WIN_TIME & winTime,
                                          NLS_STR *pnlsDate) const
{
    // First, generate a version of sLongDate with each format-entry
    // replaced with an insert-strings parameter, and with the superfluous
    // quotes removed.

    // CODEWORK - perform this at Refresh time, or else cache the results.

    NLS_STR nlsFormat(60); // just a guess to minimize reallocs

    APIERR err = ScanLongDate(&nlsFormat);
    if (err != NERR_Success)
        return err;

    // We now have the sLongDate broken down into insert-params format,
    // with a given parameter number for each kind of format entry.
    // Passing the appropriate value for each format, call Insert.

    // Defer checking all ctors until within InsertParams

    UINT nMonth = winTime.QueryMonth();
    DEC_STR nlsMonth0(nMonth);
    DEC_STR nlsMonth1(nMonth, 2);
    const NLS_STR * pnlsMonth2 = &(_nlsShortMonth[nMonth-1]);
    const NLS_STR * pnlsMonth3 = &(_nlsMonth[nMonth-1]);

    UINT nDay = winTime.QueryDay();
    DEC_STR nlsDay0(nDay);
    DEC_STR nlsDay1(nDay, 2);
    UINT nDayOfWeek = winTime.QueryDayOfWeek();
    const NLS_STR * pnlsDay2 = &(_nlsShortWDay[nDayOfWeek]);
    const NLS_STR * pnlsDay3 = &(_nlsWDay[nDayOfWeek]);

    UINT nYear = winTime.QueryYear();
    DEC_STR nlsYear0(nYear % 100, 2);
    DEC_STR nlsYear1(nYear, 4);

    const NLS_STR * apnlsParms[11];
    apnlsParms[0] = &nlsMonth0;
    apnlsParms[1] = &nlsMonth1;
    apnlsParms[2] = pnlsMonth2;
    apnlsParms[3] = pnlsMonth3;
    apnlsParms[4] = &nlsDay0;
    apnlsParms[5] = &nlsDay1;
    apnlsParms[6] = pnlsDay2;
    apnlsParms[7] = pnlsDay3;
    apnlsParms[8] = &nlsYear0;
    apnlsParms[9] = &nlsYear1;
    apnlsParms[10] = NULL;

    err = nlsFormat.InsertParams(apnlsParms);
    if (err != NERR_Success)
        return err;

    *pnlsDate = nlsFormat;
    return pnlsDate->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::Refresh

    SYNOPSIS:   get the latest information from win.ini

    HISTORY:
        terryk      29-Aug-91   Created
        beng        29-Mar-1992 Work around cfront wchar_t shortcoming

********************************************************************/

APIERR INTL_PROFILE::Refresh()
{
    static TCHAR *const pszIntl = SZ("intl");

    _f24Hour = ::GetProfileInt( pszIntl, SZ("iTime"), 0 ) == 1;
    if ( NETUI_IsDBCS() )
    {
        _fTimePrefix = ::GetProfileInt( pszIntl, SZ("iTimePrefix"), 0 ) == 1;
    }
    _fHourLZero = ::GetProfileInt( pszIntl, SZ("iTLzero"), 1 ) == 1;

    TCHAR szTempStr[100];

    ::GetProfileString( pszIntl, SZ("sDate"), SZ("/"), szTempStr,
                        CCHSIZE_SEPARATOR );
    _nlsDateSep = szTempStr;
    APIERR err = _nlsDateSep.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sTime"), SZ(":"), szTempStr,
                        CCHSIZE_SEPARATOR );
    _nlsTimeSep = szTempStr;
    err = _nlsTimeSep.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("s1159"), SZ("AM"), szTempStr,
                        CCHSIZE_AMPM );
    _nlsAMStr = szTempStr;
    err = _nlsAMStr.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("s2359"), SZ("PM"), szTempStr,
                        CCHSIZE_AMPM );
    _nlsPMStr = szTempStr;
    err = _nlsPMStr.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sShortDate"), SZDEF_SHORTDATE, szTempStr,
                        CCHSIZE_SHORTDATE );
    _nlsShortDate = szTempStr;
    err = _nlsShortDate.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sLongDate"), SZDEF_LONGDATE, szTempStr,
                        CCHSIZE_LONGDATE ) ;
    _nlsLongDate = szTempStr;
    err = _nlsLongDate.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

   //
   // first find out if there's supposed to be a leading 0 on the day
   //
   ISTR istrDay1( _nlsShortDate );
   ISTR istrMonth1( _nlsShortDate );
   ISTR istrYear1( _nlsShortDate );

   if ( _nlsShortDate.strchr( & istrDay1, LWRD ))
   {
      ISTR istrDay2 = istrDay1;
      ++istrDay2 ;
      if ( _nlsShortDate.QueryChar( istrDay2 ) == LWRD )
         _fDayLZero = TRUE ;
   }

   //
   // month?
   //
   if ( _nlsShortDate.strchr( & istrMonth1, UPRM ))
   {
      ISTR istrMonth2 = istrMonth1;
      ++istrMonth2 ;
      if ( _nlsShortDate.QueryChar( istrMonth2 ) == UPRM )
         _fMonthLZero = TRUE ;
   }

    //
    // Does year have the century?
    //
    if ( _nlsShortDate.strchr( & istrYear1, LWRY ))
    {
        ISTR istrYear2 = istrYear1;
        ++istrYear2;
        {
            if ( _nlsShortDate.QueryChar( istrYear2 ) == LWRY )
            {
                ++istrYear2 ;
                if ( _nlsShortDate.QueryChar( istrYear2 ) == LWRY )
                {
                    _fYrCentury = TRUE ;
                }
            }
            else
            {
                UIDEBUG( SZ("Profile information incorrect.") );
            }
        }
    }


   // find out the position for short date string

   if ( istrYear1 < istrMonth1 )
   {
       if ( istrMonth1 < istrDay1 )
       {
            _nYearPos = 1;
            _nMonthPos = 2;
            _nDayPos = 3;
       }
       else if ( istrDay1 < istrYear1 )
       {
            _nYearPos = 2;
            _nMonthPos = 3;
            _nDayPos = 1;
       }
       else
       {
            _nYearPos = 1;
            _nMonthPos = 3;
            _nDayPos = 2;
       }
   }
   else
   {
       if ( istrYear1 < istrDay1 )
       {
            _nYearPos = 2;
            _nMonthPos = 1;
            _nDayPos = 3;
       }
       else if ( istrDay1 < istrMonth1 )
       {
            _nYearPos = 3;
            _nMonthPos = 2;
            _nDayPos = 1;
       }
       else
       {
            _nYearPos = 3;
            _nMonthPos = 1;
            _nDayPos = 2;
       }
   }

   return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\msystem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSYSTEM.C

Abstract:

    32 bit version of mapping routines for Base API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    09-Oct-1991     JohnRo
        Fixed bug #3215 - bogus messages when setting time.

    26-Feb-1992     JonN
        Copied from NetCmd for temporary ANSI <-> UNICODE hack

    03-Sep-1993     JonN
        Removed unused functions (all but MAllocMem and MFreeMem)
--*/

//
// INCLUDES
//

#include <windows.h>

#include <string.h>
#include <lmcons.h>
#include <stdio.h>
#include <malloc.h>
#include <lmapibuf.h>
#include "declspec.h"
#include "port1632.h"


//
// Replacement for DosAllocSeg
//

WORD
MAllocMem(
    DWORD Size,
    LPBYTE * pBuffer
    )
{

    NetapipBufferAllocate(Size, (LPVOID *) pBuffer);

    return(0);

}

//
// Frees up memory allocated with MAllocMem
//

WORD
MFreeMem(
    LPBYTE Buffer
    )
{
   return(LOWORD(NetApiBufferFree(Buffer)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\mgroup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MGROUP.C

Abstract:

    Contains mapping functions to present netcmd with versions
    of the Net32 APIs which use ASCII instead of Unicode.

    This module maps the NetGroup APIs.

Author:

    Ben Goetter     (beng)  22-Aug-1991

Environment:

    User Mode - Win32

Revision History:

    22-Aug-1991     beng
        Created
    09-Oct-1991     W-ShankN
        Streamlined parameter handling, descriptor strings.
    26-Feb-1992     JonN
        Copied from NetCmd for temporary ANSI <-> UNICODE hack

--*/

// Following turns off everything until the world pulls together again.
//
// #ifdef DISABLE_ALL_MAPI
// #define DISABLE_ACCESS_MAPI
// #endif

//
// INCLUDES
//

#include <windef.h>

#include <time.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>

#include <lmcons.h>
#include <lmaccess.h>   // NetGroup APIs.
#include <lmerr.h>      // NERR_

#include "remdef.h"     // REM structure descriptor strings

#include "port1632.h"   // includes maccess.h

// These declarations will save some space.

static const LPSTR pszDesc_group_info_0         = REM32_group_info_0;
static const LPSTR pszDesc_group_info_1         = REM32_group_info_1;
static const LPSTR pszDesc_group_info_1_setinfo = REM32_group_info_1_setinfo;
static const LPSTR pszDesc_group_users_info_0   = REM32_group_users_info_0;

WORD
MNetGroupAdd(
    LPSTR        pszServer,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    LPWSTR       pwszServer = NULL;
    MXSAVELIST * pmxsavlst;
    CHAR *       pszDesc;

    UNREFERENCED_PARAMETER(cbBuffer);

    if (!(nLevel == 0 || nLevel == 1))
        return ERROR_INVALID_LEVEL;

    pszDesc = (nLevel == 0) ? pszDesc_group_info_0 : pszDesc_group_info_1;

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    nErr = MxMapClientBuffer(pbBuffer, &pmxsavlst, 1, pszDesc);
    if (nErr)
    {
        MxFreeUnicode(pwszServer);
        return (WORD)nErr;
    }

    nRes = NetGroupAdd(pwszServer, nLevel, pbBuffer, NULL);

    MxRestoreClientBuffer(pbBuffer, pmxsavlst);
    pmxsavlst = NULL;
    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupAddUser(
    LPSTR   pszServer,
    LPSTR   pszGroupName,
    LPSTR   pszUserName )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[3];

    nErr = MxMapParameters(3, apwsz, pszServer,
                                     pszGroupName,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupAddUser(apwsz[0], apwsz[1], apwsz[2]);

    MxFreeUnicodeVector(apwsz, 3);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupDel(
    LPSTR   pszServer,
    LPSTR   pszGroupName )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszGroupName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupDel(apwsz[0], apwsz[1]);

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupDelUser(
    LPSTR   pszServer,
    LPSTR   pszGroupName,
    LPSTR   pszUserName )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[3];

    nErr = MxMapParameters(3, apwsz, pszServer,
                                     pszGroupName,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupDelUser(apwsz[0], apwsz[1], apwsz[2]);

    MxFreeUnicodeVector(apwsz, 3);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupEnum(
    LPSTR   pszServer,
    DWORD   nLevel,
    LPBYTE *ppbBuffer,
    DWORD * pcEntriesRead )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD   cTotalAvail;

    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  pwszServer = NULL;

    if (!(nLevel == 0 || nLevel == 1))
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupEnum(pwszServer, nLevel,
                        ppbBuffer, MAXPREFERREDLENGTH,
                        pcEntriesRead, &cTotalAvail, NULL);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        CHAR * pszDesc = (nLevel == 0)
                         ? pszDesc_group_info_0
                         : pszDesc_group_info_1;
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, *pcEntriesRead, pszDesc);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicode(pwszServer);
            return (WORD)nErr;
        }
    }

    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupGetInfo(
    LPSTR   pszServer,
    LPSTR   pszGroupName,
    DWORD   nLevel,
    LPBYTE *ppbBuffer )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    if (!(nLevel == 0 || nLevel == 1))
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszGroupName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupGetInfo(apwsz[0], apwsz[1], nLevel, ppbBuffer);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        CHAR * pszDesc = (nLevel == 0)
                         ? pszDesc_group_info_0
                         : pszDesc_group_info_1;
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, 1, pszDesc);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicodeVector(apwsz, 2);
            return (WORD)nErr;
        }
    }

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupSetInfo(
    LPSTR        pszServer,
    LPSTR        pszGroupName,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer,
    DWORD        nParmNum )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    UINT         nFieldInfo;
    MXSAVELIST * pmxsavlst;
    LPWSTR       apwsz[2];
    DWORD        nLevelNew;

    UNREFERENCED_PARAMETER(cbBuffer);

    if (nLevel != 1)
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszGroupName);
    if (nErr)
        return (WORD)nErr;

    // NOTE - The current handling (the strategy in the next comment) doesn't
    //        work. Rap expects a 16-bit field no. Normally this is equal
    //        to the parmnum we get. But not in this
    //        API.

    // For GroupSetInfo on the Win32 side, parmnum is equal to
    // fieldinfo number.  Hallelujah!  (This isn't the case on
    // the Win16 side.  Lucky us.)

    nFieldInfo = nParmNum;
    if (nFieldInfo == GROUP_COMMENT_PARMNUM)
        nFieldInfo--;

    nErr = MxMapSetinfoBuffer(&pbBuffer, &pmxsavlst,
                              pszDesc_group_info_1_setinfo,
                              pszDesc_group_info_1, nFieldInfo);
    if (nErr)
    {
        MxFreeUnicodeVector(apwsz, 2);
        return (WORD)nErr;
    }

    nLevelNew = MxCalcNewInfoFromOldParm(nLevel, nParmNum);
    nRes = NetGroupSetInfo(apwsz[0], apwsz[1], nLevelNew, pbBuffer, NULL);

    nErr = MxRestoreSetinfoBuffer(&pbBuffer, pmxsavlst,
                                  pszDesc_group_info_1_setinfo, nFieldInfo);
    if (nErr)   // big trouble - restore may not have worked.
    {
        MxFreeUnicodeVector(apwsz,2);
        return (WORD)nErr;
    }
    pmxsavlst = NULL;
    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupGetUsers(
    LPSTR   pszServer,
    LPSTR   pszGroupName,
    DWORD   nLevel,
    LPBYTE *ppbBuffer,
    DWORD * pcEntriesRead )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD   cTotalAvail;

    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    if (nLevel != 0)
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszGroupName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetGroupGetUsers(apwsz[0], apwsz[1], nLevel,
                            ppbBuffer, MAXPREFERREDLENGTH,
                            pcEntriesRead, &cTotalAvail, NULL);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, *pcEntriesRead,
                                  pszDesc_group_users_info_0);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicodeVector(apwsz, 2);
            return (WORD)nErr;
        }
    }

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetGroupSetUsers(
    LPSTR        pszServer,
    LPSTR        pszGroupName,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer,
    DWORD        cEntries )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    MXSAVELIST * pmxsavlst;
    LPWSTR       apwsz[2];

    UNREFERENCED_PARAMETER(cbBuffer);

    if (nLevel != 0)
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszGroupName);
    if (nErr)
        return (WORD)nErr;

    nErr = MxMapClientBuffer(pbBuffer, &pmxsavlst,
                             cEntries, pszDesc_group_users_info_0);
    if (nErr)
    {
        MxFreeUnicodeVector(apwsz, 2);
        return (WORD)nErr;
    }

    nRes = NetGroupSetUsers(apwsz[0], apwsz[1], nLevel, pbBuffer, cEntries);

    MxRestoreClientBuffer(pbBuffer, pmxsavlst);
    pmxsavlst = NULL;
    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\msystem.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msystem.h

Abstract:

    Prototypes functions encapsulating OS function. This essentially covers
    everything that is not in NET***.

Author:

    Dan Hinsley (danhi) 10-Mar-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

Notes:


Revision History:

    26-Aug-1991 beng
	Separated from port1632.h

--*/

//
// various memory allocation routines
//

PCHAR
MGetBuffer(
    WORD usSize
    );

WORD
MAllocMem(
    DWORD Size,
    LPBYTE * ppBuffer
    );

WORD
MReallocMem(
    DWORD Size,
    LPBYTE * ppBuffer
    );

WORD
MFreeMem(
    LPBYTE pBuffer
    );

VOID
MSleep(
    DWORD Time
    );

/*** Time support */

typedef struct _DATETIME {        /* date */
        UCHAR        hours;
        UCHAR        minutes;
        UCHAR        seconds;
        UCHAR        hundredths;
        UCHAR        day;
        UCHAR        month;
        WORD        year;
        SHORT        timezone;
        UCHAR        weekday;
} DATETIME;
typedef DATETIME FAR *PDATETIME;


WORD
MGetDateTime(
    PDATETIME pDateTime
    );

WORD
MSetDateTime(
    PDATETIME pDateTime
    );

WORD
DosInsMessage(
    LPSTR * ppVTable,
    WORD VCount,
    LPSTR Message,
    WORD MessageLength,
    LPBYTE pBuffer,
    WORD BufferLength,
    PWORD pMessageLength);

WORD
DosPutMessage(
    unsigned int hf,
    WORD us,
    PCHAR pch);

WORD
DosQHandType(
    HFILE hf,
    PWORD pus1,
    PWORD pus2);

WORD 
MTimeToSecsSince1970(
    PLARGE_INTEGER time,
    PULONG seconds) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\msamqdi.c ===
//
//
//	This file is strictly TEMPORARY until JimK gets the
//	SamQueryDisplayInformation() API into the public build.
//
//	This file was last copied to this directory
//	(from \NT\PRIVATE\NEWSAM\CLIENT\TEMP.C) on 10-Mar-1992.
//
//


/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    temp.c

Abstract:

    This file contains temporary SAM rpc wrapper routines.

Author:

    Jim Kelly    (JimK)  14-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <rpc.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>

extern BYTE FAR * MNetApiBufferAlloc( UINT cbBuffer );	//-ckm
	
typedef struct _SAMP_TEMP_USER_STRINGS {
    ULONG  Rid;
    WCHAR  LogonName[14];
    WCHAR  FullName[24];
    WCHAR  AdminComment[24];
} SAMP_TEMP_USER_STRINGS, *PSAMP_TEMP_USER_STRINGS;


#define SAMP_TEMP_USER_COUNT (40)
#define SAMP_TEMP_USER1      (25)
#define SAMP_TEMP_USER2      (15)


typedef struct _SAMP_TEMP_MACHINE_STRINGS {
    ULONG  Rid;
    WCHAR  Machine[14];
    WCHAR  Comment[24];
} SAMP_TEMP_MACHINE_STRINGS, *PSAMP_TEMP_MACHINE_STRINGS;


#define SAMP_TEMP_MACHINE_COUNT (40)
#define SAMP_TEMP_MACHINE1      (16)
#define SAMP_TEMP_MACHINE2      (24)


SAMP_TEMP_USER_STRINGS DummyUsers[SAMP_TEMP_USER_COUNT] = {

      {1031, L"Abba"          , L"Abb Abb"              , L"Admin Comment Field"},
      {1021, L"Acea"          , L"Ace Abb"              , L"Value Admin Comment"},
      {1526, L"beverlyE"      , L"Beverly Eng"          , L"Field Value Admin"},
      {1743, L"BorisB"        , L"Boris Borsch"         , L"Comment Field Value"},
      {1734, L"BruceK"        , L"Bruce Kane"           , L"Comment Field Value"},
      {1289, L"BullS"         , L"Bull Shiite"          , L"Comment Field Value"},
      {1830, L"CallieW"       , L"Callie Wilson"        , L"Comment Field Value"},
      {1628, L"CarrieT"       , L"Carrie Tibbits"       , L"Comment Field Value"},
      {1943, L"ChrisR"        , L"Christopher Robin"    , L"40 acre woods"},
      {1538, L"CorneliaG"     , L"Cornelia Gutierrez"   , L"Comment Field Value"},
      {1563, L"CoryA"         , L"Cory Ander"           , L"Comment Field Value"},
      {1758, L"DanielJ"       , L"Daniel John"          , L"Comment Field Value"},
      {1249, L"Dory"          , L"Dory"                 , L"Comment Field Value"},
      {1957, L"EltonJ"        , L"Elton John"           , L"Comment Field Value"},
      {1555, L"HarrisonF"     , L"Harrison Ford"        , L"Comment Field Value"},
      {1795, L"HarryB"        , L"Harry Belafonte"      , L"Comment Field Value"},
      {1458, L"IngridB"       , L"Ingrid Bergman"       , L"Comment Field Value"},
      {1672, L"Ingris"        , L"Ingris"               , L"Comment Field Value"},
      {1571, L"JenniferB"     , L"Jennifer Black"       , L"Comment Field Value"},
      {1986, L"JoyceG"        , L"Joyce Gerace"         , L"Comment Field Value"},
      {1267, L"KristinM"      , L"Kristin McKay"        , L"Comment Field Value"},
      {1321, L"LeahD"         , L"Leah Dootson"         , L"The Lovely Miss D"},
      {2021, L"LisaP"         , L"Lisa Perazzoli"       , L"Wild On Skis"},
      {1212, L"MeganB"        , L"Megan Bombeck"        , L"M1"},
      {2758, L"MelisaB"       , L"Melisa Bombeck"       , L"M3"},
      {2789, L"MichaelB"      , L"Michael Bombeck"      , L"M2"},
      {2682, L"PanelopiP"     , L"Panelopi Pitstop"     , L"Comment Field Value"},
      {2438, L"Prudence"      , L"Prudence Peackock"    , L"Comment Field Value"},
      {2648, L"QwertyU"       , L"Qwerty Uiop"          , L"Comment Field Value"},
      {2681, L"ReaddyE"       , L"Readdy Eddy"          , L""},
      {2456, L"SovietA"       , L"Soviet Union - NOT"   , L"Soviet Union Aint"},
      {1753, L"TAAAA"         , L"TTT   AAAA"           , L"Comment Field Value"},
      {1357, L"TBBB"          , L"Ingris"               , L"Comment Field Value"},
      {1951, L"TCCCCC"        , L"Jennifer Black"       , L"Comment Field Value"},
      {1159, L"TCAAAAAA"      , L"Joyce Gerace"         , L"Comment Field Value"},
      {1654, L"Ulga"          , L"Ulga Bulga"           , L"Comment Field Value"},
      {1456, L"UnixY"         , L"Unix Yuck"            , L"Unix - why ask why?"},
      {1852, L"Vera"          , L"Vera Pensicola"       , L""},
      {1258, L"WinP"          , L"Winnie The Pooh"      , L"Comment Field Value"},
      {2821, L"Zoro"          , L"Zoro"                 , L"The sign of the Z"}
};





SAMP_TEMP_MACHINE_STRINGS DummyMachines[SAMP_TEMP_MACHINE_COUNT] = {

      {1031, L"abba$"          , L"Admin Comment Field"},
      {1021, L"Acea$"          , L"Value Admin Comment"},
      {1526, L"beverlyE$"      , L"Field Value Admin"},
      {1743, L"BorisB$"        , L"Comment Field Value"},
      {1734, L"BruceK$"        , L"Comment Field Value"},
      {1289, L"BullS$"         , L"Comment Field Value"},
      {1830, L"CallieW$"       , L"Comment Field Value"},
      {1628, L"CarrieT$"       , L"Comment Field Value"},
      {1943, L"ChrisR$"        , L"40 acre woods Server"},
      {1538, L"CorneliaG$"     , L"Comment Field Value"},
      {1563, L"CoryA$"         , L"Comment Field Value"},
      {1758, L"DanielJ$"       , L"Comment Field Value"},
      {1249, L"Dory$"          , L"Comment Field Value"},
      {1957, L"EltonJ$"        , L"Comment Field Value"},
      {1555, L"HarrisonF$"     , L"Comment Field Value"},
      {1795, L"HarryB$"        , L"Comment Field Value"},
      {1458, L"IngridB$"       , L"Comment Field Value"},
      {1672, L"Ingris$"        , L"Comment Field Value"},
      {1571, L"JenniferB$"     , L"Comment Field Value"},
      {1986, L"JoyceG$"        , L"Comment Field Value"},
      {1267, L"KristinM$"      , L"Comment Field Value"},
      {1321, L"LeahD$"         , L"The Lovely Miss D's"},
      {2021, L"LisaP$"         , L"Wild On Skis Server"},
      {1212, L"MeganB$"        , L"M1 Machine"},
      {2758, L"MelisaB$"       , L"M3 Machine"},
      {2789, L"MichaelB$"      , L"M2 Machine"},
      {2682, L"PanelopiP$"     , L"Comment Field Value"},
      {2438, L"Prudence$"      , L"Comment Field Value"},
      {2648, L"QwertyU$"       , L"Comment Field Value"},
      {2681, L"ReaddyE$"       , L"Ready Eddy Computer"},
      {2456, L"SovietA$"       , L"Soviet Union Aint"},
      {1753, L"TAAAA$"         , L"Comment Field Value"},
      {1357, L"TBBB$"          , L"Comment Field Value"},
      {1951, L"TCCCCC$"        , L"Comment Field Value"},
      {1159, L"TCAAAAAA$"      , L"Comment Field Value"},
      {1654, L"Ulga$"          , L"Comment Field Value"},
      {1456, L"UnixY$"         , L"Unix - why ask why?"},
      {1852, L"Vera$"          , L"Vera tissue"},
      {1258, L"WinP$"          , L"Comment Field Value"},
      {2821, L"Zoro$"          , L"The sign of the Z"}
};




NTSTATUS
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    );



NTSTATUS
SampBuildDummyAccounts(
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
    )

{
    ULONG AccountCount, Account1, Account2;
    ULONG i, j, BeginIndex, EndIndex;
    ULONG ReturnStructSize, ArrayLength, StringLengths;
    PCHAR NextByte;
    UNICODE_STRING Us;



    ASSERT (SAMP_TEMP_USER1 != 0);
    ASSERT (SAMP_TEMP_USER2 != 0);
    ASSERT (SAMP_TEMP_MACHINE1 != 0);
    ASSERT (SAMP_TEMP_MACHINE2 != 0);

    if (DisplayInformation == DomainDisplayUser) {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_USER);
        Account1 = SAMP_TEMP_USER1;
        Account2 = SAMP_TEMP_USER2;
        AccountCount = SAMP_TEMP_USER_COUNT;

    } else {

        ReturnStructSize = sizeof(DOMAIN_DISPLAY_MACHINE);
        Account1 = SAMP_TEMP_MACHINE1;
        Account2 = SAMP_TEMP_MACHINE2;
        AccountCount = SAMP_TEMP_MACHINE_COUNT;

    }



    //
    // Build up a number of dummy accounts in a single buffer.
    //


    if (Index < Account1) {

        //
        // Give the first group of accounts
        //

        ArrayLength  = ReturnStructSize * Account1;
        BeginIndex = 0;
        EndIndex   = Account1;


    } else if (Index < Account2 ) {
	
        //
        // Give the second group of accounts
        //

        ArrayLength  = ReturnStructSize * Account2;
        BeginIndex = Account1;
        EndIndex   = AccountCount;

    } else {

	//
	// User tried to index off the end of our list!
	//
	
	(*TotalAvailable) = 6*1024;        // A lie, but just a little lie.
	(*TotalReturned) = 0;
	(*ReturnedEntryCount) = 0;

	return STATUS_SUCCESS;
    }



    //
    // Figure out how large a buffer is needed.
    //

    StringLengths = 0;
    for (i=BeginIndex; i<EndIndex; i++) {

        if (DisplayInformation == DomainDisplayUser) {

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            StringLengths += Us.Length;

        } else {

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            StringLengths += Us.Length;
            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            StringLengths += Us.Length;

        }

    }
//-ckm    (*SortedBuffer) = MIDL_user_allocate( ArrayLength + StringLengths );
    (*SortedBuffer) = (PVOID)MNetApiBufferAlloc( ArrayLength + StringLengths );
    ASSERT(SortedBuffer != NULL);


    //
    // First free byte in the return buffer
    //

    NextByte = (PCHAR)((ULONG)(*SortedBuffer) + (ULONG)ArrayLength);


    //
    // Now copy the structures

    if (DisplayInformation == DomainDisplayUser) {

        PDOMAIN_DISPLAY_USER r;
        r = (PDOMAIN_DISPLAY_USER)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {

            r[j].AccountControl = USER_NORMAL_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyUsers[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].LogonName);
            r[j].LogonName.MaximumLength = Us.Length;
            r[j].LogonName.Length = Us.Length;
            r[j].LogonName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].LogonName.Length);
            NextByte += r[j].LogonName.Length;

            //
            // copy the full name
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].FullName);
            r[j].FullName.MaximumLength = Us.Length;
            r[j].FullName.Length = Us.Length;
            r[j].FullName.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].FullName.Length);
            NextByte += r[j].FullName.Length;

            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyUsers[i].AdminComment);
            r[j].AdminComment.MaximumLength = Us.Length;
            r[j].AdminComment.Length = Us.Length;
            r[j].AdminComment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].AdminComment.Length);
            NextByte += r[j].AdminComment.Length;

            j++;

        }

    } else {

        PDOMAIN_DISPLAY_MACHINE r;
        r = (PDOMAIN_DISPLAY_MACHINE)(*SortedBuffer);

        j=0;
        for (i=BeginIndex; i<EndIndex; i++) {


            r[j].AccountControl = USER_WORKSTATION_TRUST_ACCOUNT;
            r[j].Index = i;
            r[j].Rid = DummyMachines[i].Rid;


            //
            // copy the logon name
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Machine);
            r[j].Machine.MaximumLength = Us.Length;
            r[j].Machine.Length = Us.Length;
            r[j].Machine.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Machine.Length);
            NextByte += r[j].Machine.Length;


            //
            // copy the admin comment
            //

            RtlInitUnicodeString( &Us, DummyMachines[i].Comment);
            r[j].Comment.MaximumLength = Us.Length;
            r[j].Comment.Length = Us.Length;
            r[j].Comment.Buffer = (PWSTR)NextByte;
            RtlMoveMemory(NextByte, Us.Buffer, r[j].Comment.Length);
            NextByte += r[j].Comment.Length;

            j++;

        }


    }

    (*TotalAvailable) = 6*1024;        // A lie, but just a little lie.
    (*TotalReturned) = ArrayLength + StringLengths;
    (*ReturnedEntryCount) = EndIndex - BeginIndex;

    return ( Index < Account1 ) ? STATUS_MORE_ENTRIES
				: STATUS_SUCCESS;
    
}



NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)

    The netui listboxes all contain similar information.  That is:

      o  AccountControl, the bits that identify the account type,
         eg, HOME, REMOTE, SERVER, WORKSTATION, etc.

      o  Logon name (machine name for computers)

      o  Full name (not used for computers)

      o  Comment (admin comment for users)

    SAM maintains this data locally in two sorted indexed cached
    lists identified by infolevels.

      o DomainDisplayUser:       HOME and REMOTE user accounts only

      o  DomainDisplayMachine:   SERVER and WORKSTATION accounts only

    Note that trust accounts, groups, and aliases are not in either of
    these lists.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.

    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    SortedBuffer - Receives a pointer to a buffer containing a sorted
        list of the requested information.  This buffer is allocated
        by this routine and contains the following structure:


            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.





--*/
{



//    if ((DisplayInformation != DomainDisplayUser) &&
//        (DisplayInformation != DomainDisplayMachine) ) {
//        return( STATUS_INVALID_INFO_CLASS );
//
//    }



    return SampBuildDummyAccounts( DisplayInformation,
				   Index,
				   TotalAvailable,
				   TotalReturned,
				   ReturnedEntryCount,
				   SortedBuffer );

    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(PreferredMaximumLength);

}


NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.


--*/
{

    (*Index) = 0;

    return(STATUS_SUCCESS);


    DBG_UNREFERENCED_PARAMETER(DomainHandle);
    DBG_UNREFERENCED_PARAMETER(DisplayInformation);
    DBG_UNREFERENCED_PARAMETER(Prefix);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\mbcs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MBCS.C

Abstract:

    Contains mapping functions which transform Unicode strings
    (used by the NT Net APIs) into MBCS strings (used by the
    command-line interface program).

    Scheme for MBCS-Unicode mapping layer for Netcmd.

    The Netcmd assembles its structures using a variant of infostructs
    wherein s/LPWSTR/LPSTR.  (It actually redefines LPWSTR, WCHAR and
    friends to use single-byte characters.)  It then invokes Netapi
    through Mnet, the mapping layer.

    Mnet generates LPWSTR strings for each explicit LPSTR string parm
    passed to Netapi.  It will deallocate these strings before returning
    to the client.

    Mnet also handles strings imbedded within infostructs.  For outgoing
    structs (NetXAdd, various forms of Set and SetInfo), Mnet scans
    the struct's REM description, replacing each found REM_ASCIZ item
    with a pointer to a generated LPWSTR string; once the Netapi returns,
    Mnet will restore the original LPSTR pointers within the munged struct
    (in case the client code uses the submitted struct elsewhere),
    deallocating the generated LPWSTR temporaries.

    For incoming structs (GetInfo, Enum) Mnet operates slightly
    differently, performing no mapping on the struct itself until
    Netapi returns with the goods.  It then scans through the struct,
    again locating REM_ASCIZ fields in the description; however,
    instead of replacing the LPWSTR pointers with pointers to generated
    LPSTR temporaries, it overwrites the wide-character data with its
    own MBCS mapping.  This will always have enough space for a safe
    conversion, since the MBCS version will always occupy no more storage
    than the Unicode version.  When Mnet returns to its client, the
    client will see MBCS strings where Netapi placed Unicode strings.
    (Remember that the client is using a variant infostruct definition.)

Author:

    Ben Goetter     (beng)  26-Aug-1991

Environment:

    User Mode - Win32

Revision History:

    26-Aug-1991     beng
        Created
    03-Oct-1991     JohnRo
        Fixed MIPS build error.
    08-Oct-1991     W-ShankN
        Added AsciifyRpcBufferAux, plus fixes.
    17-Apr-1992     beng
        Bugfix in MxMapClientBuffer
    07-May-1992     beng
        Use official wchar.h header file

--*/


//
// INCLUDES
//

#include <windows.h>

#include <time.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>
#include <stdarg.h>
#include <wchar.h>      // wcslen, for wide-char strings

#include "declspec.h"

#include <lmcons.h>
#include <lmerr.h>      // NERR_

#include "remtypes.h"
#include "rap.h"
#include "netdebug.h"   // NetpAssert().
#include "netlib.h"     // NetpMemoryFree

#include "msystem.h"
#include "mbcs.h"


/*
 *  MxAllocUnicode
 *  Given a MBCS string, allocate a new Unicode translation of that string
 *
 *  IN
 *      pszAscii        - pointer to original MBCS string
 *      ppwszUnicode    - pointer to cell to hold new Unicode string addr
 *  OUT
 *      ppwszUnicode    - contains new Unicode string
 *
 *  RETURNS
 *      Error code, 0 if successful.
 *
 *  The client must free the allocated string with MxFreeUnicode.
 */

UINT
MxAllocUnicode(
    LPSTR    pszAscii,
    LPWSTR * ppwszUnicode )
{
    WORD     err;
    INT      errNlsApi;
    BYTE *   pbAlloc;
    INT      cbAscii;

    if (pszAscii == NULL)
    {
        *ppwszUnicode = NULL;
        return NERR_Success;
    }

    // Calculate size of Unicode string.

    cbAscii = strlen(pszAscii)+1;
    err = MAllocMem(sizeof(WCHAR) * cbAscii, &pbAlloc);
    if (err)
        return err;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    errNlsApi = MultiByteToWideChar(CP_ACP, // use default codepage (thx julie)
                                    MB_PRECOMPOSED,
                                    pszAscii,
                                    cbAscii,
                                    *ppwszUnicode,
                                    cbAscii);
    if (errNlsApi == 0)
    {
        *ppwszUnicode = NULL;
        MFreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return NERR_Success;
}


UINT
MxAllocUnicodeVector(
    LPSTR * ppszAscii,
    LPWSTR* ppwszUnicode,
    UINT    cpwszUnicode )
{
    UINT    err;
    UINT    i;

    for (i = 0; i < cpwszUnicode; ++i)
    {
        err = MxAllocUnicode(ppszAscii[i], ppwszUnicode+i);
        if (err)
        {
            MxFreeUnicodeVector(ppwszUnicode,i);
            return err;
        }
    }

    return NERR_Success;
}

/*
 *  MxUnicodeBufferSizeDBCS
 *
 *  IN
 *      pszAscii : Ansi string
 *      cbAscii  : byte count of ansi string
 *
 *  RETURNS
 *      byte count of translated unicode string
 *
 */
UINT MxUnicodeBufferSizeDBCS( LPSTR pszAscii, UINT cbAscii )
{
    INT      result;

    result = MultiByteToWideChar(CP_OEMCP,
                                 MB_PRECOMPOSED,
                                 pszAscii,
                                 cbAscii,
                                 NULL,
                                 0);
   if ( result )
       return ( result * 2 );
   else
       return 0;
}

/*
 *  MxAllocUnicodeBuffer
 *  Given a MBCS buffer, translate it into a new Unicode buffer.
 *
 *  IN
 *      pbAscii         - pointer to original MBCS buffer
 *      ppwchUnicode    - pointer to cell to hold new Unicode buffer addr
 *      cbAscii         - size of original MBCS buffer
 *  OUT
 *      ppwchUnicode    - contains new Unicode buffer
 *
 *  RETURNS
 *      Error code, 0 if successful.
 *
 *  The client must free the allocated string with MxFreeUnicodeBuffer.
 *  To find the new buffer size, use MxUnicodeBufferSize(cbAscii).
 */

UINT
MxAllocUnicodeBuffer(
    LPBYTE  pbAscii,
    LPWCH*  ppwchUnicode,
    UINT    cbAscii )
{
    WORD     err;
    INT      errNlsApi;
    LPBYTE   pbAlloc;
    INT      cbUnicode;

    if (pbAscii == NULL || cbAscii == 0)
    {
        *ppwchUnicode = (LPWCH)pbAscii;
        return NERR_Success;
    }

    cbUnicode = MxUnicodeBufferSizeDBCS(pbAscii, cbAscii);

    err = MAllocMem(cbUnicode, &pbAlloc);
    if (err)
        return err;

    *ppwchUnicode = (LPWSTR)pbAlloc;

    errNlsApi = MultiByteToWideChar(CP_ACP,
                                    MB_PRECOMPOSED,
                                    pbAscii,
                                    cbAscii,
                                    *ppwchUnicode,
                                    cbUnicode / sizeof(WCHAR));
    if (errNlsApi == 0)
    {
        *ppwchUnicode = NULL;
        MFreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return NERR_Success;
}

/*
 *  MxFreeUnicode
 *  Deallocates a Unicode string alloc'd by MxAllocUnicode (q.v.).
 *
 *  IN
 *      pwszUnicode - pointer to the alloc'd string
 *  OUT
 *      pwszUnicode - invalid pointer - string has been freed
 */

VOID
MxFreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        MFreeMem((LPBYTE)pwszUnicode);
}


VOID
MxFreeUnicodeVector(
    LPWSTR * ppwsz,
    UINT     cpwsz )
{
    while (cpwsz-- > 0)
        MxFreeUnicode(*ppwsz++);
}


UINT
MxAsciifyInplace( LPWSTR pwszUnicode )
{
    BOOL  fUsedDefault;
    UINT  cwUnicode;
    UINT  cbAscii;
    BYTE *pbAllocTemp;
    WORD  err;
    INT   errNlsApi;

    if (pwszUnicode == NULL)  // Nothing doing!
        return NERR_Success;

    // Temp space needed for conversion.

    cwUnicode = wcslen(pwszUnicode)+1;
    cbAscii = 2 * sizeof(CHAR) * cwUnicode; // A Unichar might expand
                                            // into a multibyte sequence.
    err = MAllocMem(cbAscii, &pbAllocTemp);
    if (err || !pbAllocTemp) // JonN 01/23/00: PREFIX bug 444889
        return (err) ? err : (UINT)ERROR_NOT_ENOUGH_MEMORY;

    errNlsApi = WideCharToMultiByte(CP_ACP,    // use default codepage (thx julie)
                                    0,
                                    pwszUnicode,
                                    cwUnicode,
                                    pbAllocTemp,
                                    cbAscii,
                                    NULL,      // use system default char
                                    &fUsedDefault);
    if (errNlsApi == 0)
    {
        MFreeMem(pbAllocTemp);
        return ( (UINT)GetLastError() );
    }

    // Copy the converted string back into the original caller's buffer

    strcpy((CHAR*)pwszUnicode, pbAllocTemp);
    MFreeMem(pbAllocTemp);

    return NERR_Success;
}

/*
 *  MxMapParameters
 *
 *  Passed an arbitrary number of ASCIZ string parameters, maps
 *  them to Unicode for submission to Netapi. New space is allocated
 *  (if possible) for the Unicode strings, and the routine returns
 *  pointer to these strings in an array of LPWSTR's provided by the
 *  caller.
 *
 *  IN
 *      cParam       - Count of parameters provided.
 *      ...          - Variable number of string parameters
 *
 *  OUT
 *      ppwszUnicode - Pointers to newly allocated Unicode strings.
 *
 *  RETURNS
 *      Error code, 0 if successful
 *
 *  Upon return from Netapi, call MxFreeUnicodeVector to free the Unicode
 *  strings.
 */

UINT
MxMapParameters( UINT cParam, LPWSTR* ppwszUnicode, ... )
{
    va_list ppszAscii;
    LPSTR pszParam;
    UINT iParam;
    UINT err;

    va_start(ppszAscii, ppwszUnicode);
    for ( iParam = 0; iParam < cParam; iParam++ )
    {
        pszParam = va_arg(ppszAscii, LPSTR);
        err = MxAllocUnicode(pszParam, ppwszUnicode + iParam);
        if (err)
        {
            MxFreeUnicodeVector(ppwszUnicode,iParam);
            va_end(ppszAscii);
            return err;
        }
    }

    va_end(ppszAscii);
    return NERR_Success;
}

/*
 *  MxMapClientBuffer
 *  Given a client buffer, map each ASCIZ string to Unicode for
 *  submission to Netapi, saving the original arguments away for
 *  later restoration.
 *
 *  IN
 *      pbInput     - client buffer
 *      ppmxsavlst  - points to a pointer to MXSAVELIST structure to
 *                    instantiate (alloc'ing a MXSAVELIST in the process)
 *      cRecords    - the number of records in the client's buffer
 *      pszDesc     - The REM dope vector describing buffer
 *
 *  OUT
 *      pbInput     - munged
 *      ppmxsavlst  - instantiated with a pointer to a structure
 *                    containing all replaced strings (possibly none).
 *
 *  RETURNS
 *      Error code, 0 if successful
 *
 *  Upon return from Netapi, call MxRestoreClientBuffer to
 *  restore the client's original pointers.
 */

UINT
MxMapClientBuffer(
    BYTE *        pbInput,
    MXSAVELIST ** ppmxsavlst,
    UINT          cRecords,
    CHAR *        pszDesc )
{
    UINT          cmxsav;
    UINT          cmxsavrec;
    UINT          imxsavrec;
    UINT          ibRec;
    CHAR *        pch;
    UINT          err;
    UINT          off;
    UINT          cbRecordSize;
    MXSAVELIST *  pmxsavlst;
    MXSAVEARG *   pmxsav;

    // First, determine the number of args this needs to save

    for (cmxsavrec = 0, pch = strchr(pszDesc, REM_ASCIZ);
         pch != NULL;
         ++cmxsavrec, pch = strchr(pch+1, REM_ASCIZ))
        ;
    cmxsav = cmxsavrec * cRecords;

    // Get the vector of saveargs (may be 0)

    err = MxAllocSaveargs(cmxsav, &pmxsavlst);
    if (err)
        return err;

    *ppmxsavlst = pmxsavlst;

    // Locate, save, then replace each consecutive arg.

    // Compare this scanning loop with that of AsciifyRpcBuffer.
    // Since clients frequently call MapClientBuffer with cRecords
    // set to 1, this lets such calls skip scanning trailing fields
    // in a record once it processes the last asciz argument.

    // If cRecords > 1, then the first time around, the record size
    // is saved. On further passes, non-string data at the end of
    // each record is not scanned.

    off = 0;
    ibRec = 0;
    cbRecordSize = 0;
    imxsavrec = cmxsavrec;
    pch = pszDesc;
    pmxsav = pmxsavlst->pmxsav;
    while (cmxsav > 0) // (now this becomes the count of remaining args)
    {
        if (imxsavrec == 0 && (cbRecordSize != 0 || *pch == 0))
        {
            // Buffer contains multiple records, and is starting
            // a new record.

            NetpAssert(cRecords > 1);

            // If unknown, remember the size of a complete record,
            // so we can skip during future passes.

            if (cbRecordSize == 0)
                cbRecordSize = off;

            // Done with all strings in this entry; skip over any
            // data at the end.

            ibRec += cbRecordSize;
            off = ibRec;

            // Rewind record descriptor to beginning

            imxsavrec = cmxsavrec;
            pch = pszDesc;
        }

        if (*pch == REM_ASCIZ)
        {
            LPWSTR pwszConverted;
            err = MxAllocUnicode( *((LPSTR*)(pbInput+off)), &pwszConverted );
            if (err)
            {
                // Ran out of memory at a most awkward time...

                // Patch count of saved args for the unwind.
                //
                pmxsavlst->cmxsav -= cmxsav;

                // Unwind and return.
                //
                MxRestoreClientBuffer(pbInput, pmxsavlst);
                *ppmxsavlst = NULL;
                return err;
            }

            pmxsav->offThis = off;
            pmxsav->pszOriginal = *((LPSTR*)(pbInput+off));

            *((LPWSTR*)(pbInput+off)) = pwszConverted;

            ++pmxsav;
            --cmxsav;
            --imxsavrec;
        }

        // Skip to the next field

        off += RapGetFieldSize(pch, &pch, Both);
        ++pch;
    }

    return NERR_Success;
}


/*
 *  MxMapClientBufferAux
 *  Given a client buffer, map each ASCIZ string to Unicode for
 *  submission to Netapi, saving the original arguments away for
 *  later restoration.  This version handles those lanman structs
 *  which are followed by "auxiliary" structures: e.g. access_info_1.
 *
 *  IN
 *      pbInput     - client buffer
 *      pszDesc     - The REM dope vector describing buffer
 *      pbInputAux  - pointer to start of aux data in buffer
 *      cRecordsAux - the number of auxiliary records in the
 *                    client's buffer.  This routine assumes only
 *                    one primary structure.
 *      pszDescAux  - describes auxiliary structure
 *      ppmxsavlst  - points to a pointer to MXSAVELIST structure to
 *                    instantiate (alloc'ing a MXSAVELIST in the process)
 *
 *  OUT
 *      pbInput     - munged
 *      ppmxsavlst  - instantiated with a pointer to a structure
 *                    containing all replaced strings (possibly none).
 *
 *  RETURNS
 *      Error code, 0 if successful
 *
 *  Upon return from Netapi, call MxRestoreClientBuffer to
 *  restore the client's original pointers.
 */

UINT
MxMapClientBufferAux(
    BYTE *        pbInput,
    CHAR *        pszDesc,
    BYTE *        pbInputAux,
    UINT          cRecordsAux,
    CHAR *        pszDescAux,
    MXSAVELIST ** ppmxsavlst )
{
    UINT          err;
    MXSAVELIST *  pmxsavlstMain;
    MXSAVELIST *  pmxsavlstAux;
    MXSAVELIST *  pmxsavlstTotal;

    err = MxMapClientBuffer(pbInput, &pmxsavlstMain,
                            1, pszDesc);
    if (err)
    {
        *ppmxsavlst = NULL;
        return err;
    }

    err = MxMapClientBuffer(pbInputAux, &pmxsavlstAux,
                            cRecordsAux, pszDescAux);
    if (err)
    {
        MxRestoreClientBuffer(pbInput, pmxsavlstMain);
        *ppmxsavlst = NULL;
        return err;
    }

    // N.b. Join-saveargs *replaces* the first and second savearg vectors
    // with one composite vector if it succeeds.  On failure, it leaves
    // the original vectors around for proper cleanup.

    err = MxJoinSaveargs(pmxsavlstMain, pmxsavlstAux,
                         (ULONG)(pbInputAux-pbInput), &pmxsavlstTotal);
    if (err)
    {
        MxRestoreClientBuffer(pbInputAux, pmxsavlstAux);
        MxRestoreClientBuffer(pbInput, pmxsavlstMain);
        *ppmxsavlst = NULL;
        return err;
    }

    *ppmxsavlst = pmxsavlstTotal;
    return NERR_Success;
}


/*
 *  MxRestoreClientBuffer
 *  Given a mapped buffer and a list of saved args, restore that
 *  buffer to its original state.
 *
 *  IN
 *      pbBuffer    - points to munged client buffer
 *      pmxsavlst   - points to saved args
 *  OUT
 *      pbBuffer    - restored
 *      pmxsavlst   - invalid pointer - structure has been freed
 *
 */

VOID
MxRestoreClientBuffer(
    BYTE *       pbBuffer,
    MXSAVELIST * pmxsavlst )
{
    UINT         imxsav;
    UINT         imxsavLim = pmxsavlst->cmxsav;
    MXSAVEARG *  pmxsav = pmxsavlst->pmxsav;

    for (imxsav = 0; imxsav < imxsavLim; ++imxsav, ++pmxsav)
    {
        UINT off = pmxsav->offThis;
        MxFreeUnicode( *((LPWSTR*)(pbBuffer+off)) );
        *((LPSTR*)(pbBuffer+off)) = pmxsav->pszOriginal;
    }

    MxFreeSaveargs(pmxsavlst);
}


/*
 *  MxAsciifyRpcBuffer
 *  Convert a buffer returned by Netapi into ASCII (actually MBCS) for
 *  apps such as netcmd.
 *
 *  IN
 *      pbInput - buffer full of fun, courtesy of the Netapi
 *      cRecords- the number of entries Netapi claims to have returned
 *      pszDesc - REM-format description of the data buffer
 *  OUT
 *      pbInput - extensively munged.  All Unicode strings have been
 *                overwritten with their MBCS equivalents.
 *
 *  RETURNS
 *      0 on success; otherwise, error cascaded back from Winnls.
 */

UINT
MxAsciifyRpcBuffer(
    BYTE *  pbInput,
    DWORD   cRecords,
    CHAR *  pszDesc )
{
    UINT    off;
    UINT    iRecord;

    // Step through each record returned by the Enum (1 only, if GetInfo)

    for (off = 0, iRecord = 0; iRecord < cRecords; ++iRecord)
    {
        // Examine each field in the record

        // CODEWORK: where cRecords > 1, this could cache a single
        // set of relative offsets and reuse them for each subsequent
        // record.

        CHAR * pch;
        for (pch = pszDesc; *pch != 0; pch++ ) {
            if (*pch == REM_ASCIZ)
            {
                UINT err;
                err = MxAsciifyInplace( *((LPWSTR*)(pbInput+off)) );
                if (err)
                {
                    // WINNLS error at a most inconvenient time.
                    //
                    return err;
                }
            }
            off += RapGetFieldSize(pch, &pch, Both);
        }
    }

    return NERR_Success;
}

/*
 *  MxAsciifyRpcBufferAux
 *
 *  Convert a buffer returned by Netapi into ASCII (actually MBCS) for
 *  apps such as netcmd. This version handles those lanman structs
 *  which are followed by "auxiliary" structures: e.g. access_info_1.
 *
 *  IN
 *      pbInput     - buffer full of fun, courtesy of the Netapi
 *      pszDesc     - REM-format description of the data buffer
 *      pbInputAux  - pointer to start of aux data in buffer
 *      cRecordsAux - the number of auxiliary records in the
 *                    client's buffer.  This routine assumes only
 *                    one primary structure.
 *      pszDescAux  - describes auxiliary structure
 *  OUT
 *      pbInput     - extensively munged.  All Unicode strings have been
 *                    overwritten with their MBCS equivalents.
 *
 *  RETURNS
 *      0 on success; otherwise, error cascaded back from Winnls.
 */

UINT
MxAsciifyRpcBufferAux(
    BYTE *  pbInput,
    CHAR *  pszDesc,
    BYTE *  pbInputAux,
    DWORD   cRecordsAux,
    CHAR *  pszDescAux )
{
    UINT err;

    err = MxAsciifyRpcBuffer(pbInput, 1, pszDesc);
    if (err)
    {
        return err;
    }

    err = MxAsciifyRpcBuffer(pbInputAux, cRecordsAux, pszDescAux);
    if (err)
    {
        // We're in trouble
        return err;
    }

    return NERR_Success;

}

/*
 *  MxAsciifyRpcEnumBufferAux
 *
 *  Convert a buffer returned by Netapi into ASCII (actually MBCS) for
 *  apps such as netcmd. This version handles buffers with multiple
 *  lanman struct records, each followed by an arbitrary number of"auxiliary"
 *  structures: e.g. access_info_1.
 *
 *  IN
 *      pbInput     - buffer full of fun, courtesy of the Netapi
 *      cRecords    - the number of entries Netapi claims to have returned
 *      pszDesc     - REM-format description of the data buffer
 *      pszDescAux  - describes auxiliary structure
 *  OUT
 *      pbInput     - extensively munged.  All Unicode strings have been
 *                    overwritten with their MBCS equivalents.
 *
 *  RETURNS
 *      0 on success; otherwise, error cascaded back from Winnls.
 */

UINT
MxAsciifyRpcEnumBufferAux(
    BYTE *  pbInput,
    DWORD   cRecords,
    CHAR *  pszDesc,
    CHAR *  pszDescAux )
{
    UINT err;
    UINT offcRecordsAux;
    UINT cbRecordSize;
    UINT cbRecordSizeAux;
    UINT i;
    CHAR * pch;

    // Examine main descriptor to find total size of a record, and
    // a relative offset to the descriptor data.

    offcRecordsAux = 0;
    cbRecordSize = 0;
    for ( pch = pszDesc; *pch != '\0';  pch++ )
    {
        if ( *pch == REM_AUX_NUM_DWORD )
        {
            offcRecordsAux = cbRecordSize;
        }
        cbRecordSize += RapGetFieldSize( pch, &pch, Both );
    }

    // Examine auxiliary descriptor to find total size of an auxiliary
    // record.

    cbRecordSizeAux = 0;
    for ( pch = pszDescAux; *pch != '\0'; pch++ ) {
           cbRecordSizeAux += RapGetFieldSize( pch, &pch, Both );
    }

    for ( i = 0; i < cRecords; i++ )
    {
        err = MxAsciifyRpcBufferAux(pbInput, pszDesc, pbInput+cbRecordSize,
                  *((DWORD*)(pbInput+offcRecordsAux)), pszDescAux);
        if (err)
        {
            // We're in trouble
            return err;
        }

        pbInput += (cbRecordSize
                    + *((DWORD*)(pbInput+offcRecordsAux)) * cbRecordSizeAux);
    }

    return NERR_Success;

}


UINT
MxAllocSaveargs(
    UINT         cmxsav,
    MXSAVELIST **ppmxsavlstSet )
{
    WORD         err;
    BYTE *       pbAlloc;

    err = MAllocMem(sizeof(MXSAVELIST), &pbAlloc);
    if (err)
        return err;

    *ppmxsavlstSet = (MXSAVELIST *)pbAlloc;

    err = MAllocMem((sizeof(MXSAVEARG)*cmxsav), &pbAlloc);
    if (err)
    {
        MFreeMem( (LPBYTE)*ppmxsavlstSet );
        *ppmxsavlstSet = NULL;
        return err;
    }

    (*ppmxsavlstSet)->pmxsav = (MXSAVEARG *)pbAlloc;
    (*ppmxsavlstSet)->cmxsav = cmxsav;
    return NERR_Success;
}


VOID
MxFreeSaveargs( MXSAVELIST * pmxsavlst )
{
    if (pmxsavlst != NULL)
    {
        if (pmxsavlst->pmxsav != NULL)
            MFreeMem((LPBYTE)(pmxsavlst->pmxsav));

        MFreeMem((LPBYTE)pmxsavlst);
    }
}


/*
 *  MxJoinSaveargs
 *  Take two savearg vectors - one from a primary struct, one from
 *  its auxiliaries - and compile a single vector, with all offsets
 *  calculated from the original
 *
 * ...tbw
 */

UINT
MxJoinSaveargs(
    MXSAVELIST * pmxsavlstMain,
    MXSAVELIST * pmxsavlstAux,
    UINT         dbFixupAux,
    MXSAVELIST **ppmxsavlstOut )
{
    UINT         err;
    MXSAVELIST * pmxsavlstNew;
    MXSAVEARG *  pmxsav;
    UINT         cmxsav;

    err = MxAllocSaveargs(pmxsavlstMain->cmxsav + pmxsavlstAux->cmxsav,
                          &pmxsavlstNew);
    if (err)
    {
        *ppmxsavlstOut = NULL;
        return err;
    }

    // Quickly copy old vectors into composite new vector

    memcpy(pmxsavlstNew->pmxsav,
           pmxsavlstMain->pmxsav,
           pmxsavlstMain->cmxsav * sizeof(MXSAVEARG));
    memcpy(pmxsavlstNew->pmxsav + pmxsavlstMain->cmxsav,
           pmxsavlstAux->pmxsav,
           pmxsavlstAux->cmxsav * sizeof(MXSAVEARG));

    // Fix up auxiliary vector offsets to express relative to origin

    for (pmxsav = pmxsavlstNew->pmxsav + pmxsavlstMain->cmxsav,
         cmxsav = pmxsavlstAux->cmxsav;
         cmxsav > 0;
         --cmxsav, ++pmxsav)
    {
        pmxsav->offThis += dbFixupAux;
    }

    MxFreeSaveargs(pmxsavlstMain);
    MxFreeSaveargs(pmxsavlstAux);

    *ppmxsavlstOut = pmxsavlstNew;

    return NERR_Success;
}


/*
 *  MxCalcNewInfoFromOldParm
 *  Given the old-style infolevel and parmnum, calc the new infolevel.
 *
 *  IN
 *      nOldInfo    - old infolevel
 *      nOldParm    - old parmnum
 *
 *  RETURNS
 *      New infolevel
 *
 *  This routine has nothing to do with MBCS, yeah, yeah...
 */

UINT
MxCalcNewInfoFromOldParm( UINT nOldInfo, UINT nOldParm )
{
    return (nOldParm > 0)
           ? (nOldParm + PARMNUM_BASE_INFOLEVEL)
           : nOldInfo;
}


/*
 *  MxMapSetinfoBuffer
 *  Given a client buffer intended for a Netapi SetInfo call, map each
 *  ASCIZ string therein to Unicode for submission to Netapi, saving the
 *  original arguments away for later restoration.
 *
 *  IN
 *      ppbInput    - points to a pointer to client buffer
 *      pmxsavlst   - points to a pointer to MXSAVELIST structure to
 *                    instantiate (alloc'ing a MXSAVELIST in the process)
 *      pszDesc     - A special version of the REM descriptor, with info
 *                    about supported fields.
 *      pszRealDesc - The REM descriptor.
 *      nField      - the fieldinfo number (NOT the "parmnum") of the attr
 *                    to setinfo - 0 for "all parms."  These differ due to
 *                    historical accident.
 *                    NOTE - if REM strings are used, the fieldinfo should
 *                           correspond to a 16-bit parmnum, not a field no.
 *
 *  OUT
 *      pbInput     - munged, or buffer address possibly changed
 *      ppmxsavlst  - instantiated with a pointer to a structure
 *                    containing all replaced strings (possibly none).
 *
 *  RETURNS
 *      Error code, 0 if successful
 *
 *  Upon return from Netapi, call MxRestoreSetinfoBuffer to
 *  restore the client's original pointers.
 *
 *  nField had well better agree with pszDesc.
 *  There's no good way to check this.
 */

UINT
MxMapSetinfoBuffer(
    BYTE * *      ppbInput,
    MXSAVELIST ** ppmxsavlst,
    CHAR *        pszDesc,
    CHAR *        pszRealDesc,
    UINT          nField )
{
    UINT          nRes;
    CHAR *        pszDescNew;

    // If no sub-parameter given, pass the parms through to the
    // usual mapper.

    if (nField == 0)
        return MxMapClientBuffer(*ppbInput, ppmxsavlst, 1, pszRealDesc);

    // Must build a tiny descriptor string for the single field
    // being setinfo'd.

    pszDescNew = RapParmNumDescriptor(pszDesc, nField, Both, TRUE);
    if (pszDescNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    if ((*pszDescNew == REM_UNSUPPORTED_FIELD)||(*pszDescNew == REM_IGNORE))
    {
        NetpMemoryFree(pszDescNew);         // Free the string
        return ERROR_INVALID_PARAMETER;
    }

    // Data for a string is inline, not referenced by a pointer in structure.
    if (*pszDescNew == REM_ASCIZ)
    {
        nRes = MxMapClientBuffer((BYTE *)ppbInput, ppmxsavlst, 1, pszDescNew);
    }
    else
    {
        nRes = MxMapClientBuffer(*ppbInput, ppmxsavlst, 1, pszDescNew);
    }

    NetpMemoryFree(pszDescNew); // Rap uses the Netp allocator
    return nRes;
}


UINT
MxRestoreSetinfoBuffer(
    BYTE * *      ppbBuffer,
    MXSAVELIST *  pmxsavlst,
    CHAR *        pszDesc,
    UINT          nField )
{
    CHAR *        pszDescNew;

    // If no sub-parameter given, pass the parms through to the
    // usual restoration function.

    if (nField == 0)
    {
        MxRestoreClientBuffer(*ppbBuffer, pmxsavlst);
        return NERR_Success;
    }

    // Must build a tiny descriptor string for the single field
    // being setinfo'd.

    pszDescNew = RapParmNumDescriptor(pszDesc, nField, Both, TRUE);
    if (pszDescNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    // If the buffer has been converted already, assume field no. is correct.
    NetpAssert (*pszDescNew != REM_UNSUPPORTED_FIELD);

    // Data for a string is inline, not referenced by a pointer in structure.
    if (*pszDescNew == REM_ASCIZ)
    {
        MxRestoreClientBuffer((BYTE *)ppbBuffer, pmxsavlst);
    }
    else
    {
        MxRestoreClientBuffer(*ppbBuffer, pmxsavlst);
    }

    NetpMemoryFree(pszDescNew); // Rap uses the Netp allocator
    return NERR_Success;
}

/*
 *  MxMapStringsToTStrings
 *
 *  This routine is used by code which is completely portable between
 *  Ascii and Unicode, rather than Unicode only. Given an arbitrary
 *  number of ASCII strings, they will be mapped to the portable TSTRING
 *  type. If this is UNICODE, memory will be allocated.
 *
 *  IN
 *      cStrings     - Count of strings provided.
 *      ...          - 2*cParam parameters of the form :
 *                          LPSTR pszSource, LPTSTR * pptszDest
 *
 *  OUT
 *      ...          - Each of the pptsz's above will have pointers to the
 *                     portable strings.
 *
 *  RETURNS
 *      Error code, 0 if successful
 *
 *  Upon return from Netapi, call MxFreeTStrings. If this is in UNICODE,
 *  the allocated strings will be freed.
 */

UINT
MxMapStringsToTStrings( UINT cStrings, ... )
{
    va_list pParam;
    LPSTR pszParamIn;
    LPTSTR * pptszParamOut;
    UINT iString;
    UINT err;

    va_start(pParam, cStrings);
    for ( iString = 0; iString < cStrings; iString++ )
    {
        pszParamIn = va_arg(pParam, LPSTR);
        pptszParamOut = va_arg(pParam, LPTSTR *);
        err = MxAllocTString(pszParamIn, pptszParamOut);
        if (err)
        {
            // Long way to rewind
            va_end(pParam);
            va_start(pParam, cStrings);
            for (; iString > 0; iString--)
            {
                pszParamIn = va_arg(pParam, LPSTR);
                pptszParamOut = va_arg(pParam, LPTSTR *);
                MxFreeTString(*pptszParamOut);
            }
            va_end(pParam);
            return err;
        }
    }

    va_end(pParam);
    return NERR_Success;
}

UINT
MxFreeTStrings( UINT cStrings, ... )
{
    va_list pptszParam;
    LPTSTR ptszParam;
    UINT iString;

    va_start(pptszParam, cStrings);
    for ( iString = 0; iString < cStrings; iString++ )
    {
        ptszParam = va_arg(pptszParam, LPTSTR);
        MxFreeTString(ptszParam);
    }

    va_end(pptszParam);
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\pcanon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pcanon.c
    mapping layer for canonicalization API.

    FILE HISTORY:
        KeithMo     14-Oct-1991 Created.
        JonN        01-Jun-1992 Enabled LM2X_COMPATIBLE for I_MNetName* only
        JonN        20-Jul-1992 Really enabled LM2X_COMPATIBLE for I_MNetName* only
        Yi-HsinS    25-Aug-1992 Added NAMETYPE_COMMENT to I_MNetNameValidate
        KeithMo     08-Feb-1993 Added I_MNetComputerNameCompare API.

   The LM2X_COMPATIBLE flag causes names to be canonicalized according
   to LM2X-compatible rules.  The "LM2X compatibility flag" is stuck
   TRUE for Product One.  This flag is not implemented for paths.

*/

#define INCL_NET
#define INCL_DOSERRORS
#define INCL_ICANON
#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"

extern "C"
{
    #include "mnetp.h"
    #include <winerror.h>

} // extern "C"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include "uiassert.hxx"
#include "dbgstr.hxx"  // for cdebug


#define WHACK TCH('\\')

#define IS_LM2X_COMPATIBLE(nametype) ( (nametype==NAMETYPE_SERVICE || nametype==NAMETYPE_MESSAGE) ? 0 : LM2X_COMPATIBLE )



APIERR I_MNetNameCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        UINT               NameType,
        ULONG              flFlags )
{
#if defined(DEBUG) && defined(TRACE)
    APIERR err =
#else  // TRACE
    return
#endif // TRACE

          I_NetNameCanonicalize( (TCHAR *)pszServer,
                          (TCHAR *)pszPath,
                                  pszOutput,
                                  cbOutput,
                                  NameType,
                                  flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
    if ( err != NERR_Success ) {
       TRACEEOL( SZ("I_NetNameCanonicalize( ")
              << pszServer
              << SZ(", ")
              << pszPath
              << SZ(", pszOutput, ")
              << cbOutput
              << SZ(", ")
              << NameType
              << SZ(", ")
              << (flFlags | IS_LM2X_COMPATIBLE(NameType))
              << SZ(" ) returned ")
              << err );
    }
    return err;
#endif // TRACE

}   // I_MNetNameCanonicalize


APIERR I_MNetNameCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        UINT               NameType,
        ULONG              flFlags )
{
#if defined(DEBUG) && defined(TRACE)
    APIERR err =
#else  // TRACE
    return
#endif // TRACE
           I_NetNameCompare( (TCHAR *)pszServer,
                             (TCHAR *)pszPath1,
                             (TCHAR *)pszPath2,
                             NameType,
                             flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
    if ( err != NERR_Success ) {
       TRACEEOL( "I_NetNameCompare( "
              << (const TCHAR *) pszServer
              << ", "
              << (const TCHAR *) pszPath1
              << ", "
              << (const TCHAR *) pszPath2
              << ", "
              << NameType
              << ", "
              << (flFlags | IS_LM2X_COMPATIBLE(NameType))
              << " ) returned "
              << err )
    }
    return err;
#endif // TRACE

}   // I_MNetNameCompare


APIERR I_MNetNameValidate(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszName,
        UINT               NameType,
        ULONG              flFlags )
{

    switch (NameType)
    {
        case NAMETYPE_COMMENT:
        {
            APIERR err = NERR_Success;
            if ( pszName != NULL )
            {
                UINT nMaxLen = IS_LM2X_COMPATIBLE(NameType) == LM2X_COMPATIBLE?
                               LM20_MAXCOMMENTSZ : MAXCOMMENTSZ;
                if ( ::strlenf( pszName )  >  nMaxLen )
                    err = ERROR_INVALID_PARAMETER;
            }
            return err;
        }

        default:
#if defined(DEBUG) && defined(TRACE)
        {
            APIERR err =
#else  // TRACE
            return
#endif // TRACE
                I_NetNameValidate( (TCHAR *)pszServer,
                                   (TCHAR *)pszName,
                                   NameType,
                                   flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
            if ( err != NERR_Success ) {
                 TRACEEOL( "I_NetNameValidate( "
                           << (const TCHAR *) pszServer
                           << ", "
                           << (const TCHAR *) pszName
                           << ", "
                           << NameType
                           << ", "
                           << (flFlags | IS_LM2X_COMPATIBLE(NameType))
                           << " ) returned "
                           << err )
            }
            return err;
        }
#endif // TRACE
    }

}   // I_MNetNameValidate


APIERR I_MNetPathCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        const TCHAR FAR  * pszPrefix,
        ULONG FAR        * pflPathType,
        ULONG              flFlags )
{
    return I_NetPathCanonicalize( (TCHAR *)pszServer,
                                  (TCHAR *)pszPath,
                                  pszOutput,
                                  cbOutput,
                                  (TCHAR *)pszPrefix,
                                  pflPathType,
                                  flFlags );

}   // I_MNetPathCanonicalize


APIERR I_MNetPathCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        ULONG              flPathType,
        ULONG              flFlags )
{
    return I_NetPathCompare( (TCHAR *)pszServer,
                             (TCHAR *)pszPath1,
                             (TCHAR *)pszPath2,
                             flPathType,
                             flFlags );

}   // I_MNetPathCompare


APIERR I_MNetPathType(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        ULONG FAR        * pflPathType,
        ULONG              flFlags )
{
    return I_NetPathType( (TCHAR *)pszServer,
                          (TCHAR *)pszPath,
                          pflPathType,
                          flFlags );

}   // I_MNetPathType


//
//  The I_MNetComputerNameCompare API is a little unusual.  It may
//  be used to compare computer <-> computer, computer <-> domain,
//  or domain <-> domain.  To achieve this, it will skip past the
//  leading backslashes (if present) before calling through to the
//  I_NetNameCompare API.  Since the backslashes will not be present,
//  the names will most closely resemble domain names, thus the
//  NAMETYPE_DOMAIN is used as the NameType parameter.
//
//  Also, unlike the other [I_]MNet* API, this one returns an INT
//  instead of the usual APIERR.  In theory this could be used as
//  a collating value.  Unfortunately, since the I_NetNameCompare
//  API is non-locale-sensitive, the collating value is useless.  For
//  now, the return value should be treated as follows:
//
//       0 - names match
//      !0 - names don't match
//

INT I_MNetComputerNameCompare(
        const TCHAR FAR  * pszComputer1,
        const TCHAR FAR  * pszComputer2 )
{
    //
    //  Handle NULL/empty computer names first to make the
    //  remaining code a little simpler.
    //

    if( ( pszComputer1 == NULL ) || ( *pszComputer1 == TCH('\0') ) )
    {
        return ( pszComputer2 == NULL ) || ( *pszComputer2 == TCH('\0') ) ?  0
                                                                          : -1;
    }

    if( ( pszComputer2 == NULL ) || ( *pszComputer2 == TCH('\0') ) )
    {
        return ( pszComputer1 == NULL ) || ( *pszComputer1 == TCH('\0') ) ?  0
                                                                          :  1;
    }

    //
    //  At this point both computer names should be non-NULL
    //

    if( ( pszComputer1 == NULL ) || ( pszComputer2 == NULL ) )
    {
        UIASSERT( FALSE );
        return -1;
    }

    //
    //  Skip the leading backslashes if present.  Note that the first
    //  leading backslash implies the existence of a second backslash.
    //  We assert out if this second backslash is not present.
    //

    if( *pszComputer1 == WHACK )
    {
        pszComputer1++;

        if( *pszComputer1 == WHACK )
        {
            pszComputer1++;
        }
    }

    if( *pszComputer2 == WHACK )
    {
        pszComputer2++;

        if( *pszComputer2 == WHACK )
        {
            pszComputer2++;
        }
    }

    //
    //  The computer names should *not* be starting with backslashes.
    //  If they are, somebody gave us a malformed computer name.
    //

    UIASSERT( ( *pszComputer1 != WHACK ) && ( *pszComputer2 != WHACK ) );

    //
    //  Compare the two names as domains (since they're backslash-less).
    //

    APIERR err = I_NetNameCompare( NULL,
                                   (TCHAR *)pszComputer1,
                                   (TCHAR *)pszComputer2,
                                   NAMETYPE_COMPUTER,
                                   LM2X_COMPATIBLE );

    //
    //  Unfortunately, the I_NetNameCompare overloads the meaning
    //  of the return value.  It may be a Win32 error code (ERROR_*),
    //  a network error code (NERR_*) or the result of a string compare
    //  function (<0, 0, >0).  Thus, the result may be non-zero even
    //  the strings DO indeed match.
    //

    return (INT)err;

}   // I_MNetComputerNameCompare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\netslow.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    netslow.c

Abstract:

    IsSlowTransport will test whether a net connection is through RAS or not.

Notes:

    CODEWORK
    Because of the global variable, IsSlowTransport is not reentrant.
    No single LMUICMN1 client (e.g. no single app) should call this from
    multiple threads.

Author:

    KeithMo

Revision History:

    Congpa You (CongpaY) 11- March-1993

--*/

#include "pchmn32.h"

/*****************************************************************************

    constants

*****************************************************************************/
#define MAXWAITTIME       1200            // milliseconds



/*****************************************************************************

    globals

*****************************************************************************/
APIERR errThread;



/*****************************************************************************

    prototypes

*****************************************************************************/

APIERR IsSlowTransport( const TCHAR * pszServer,
                                BOOL  * pfSlowTransport );

void SlowTransportWorkerThread( LPVOID pParam );

APIERR SetupSession( const TCHAR * pszServer );

APIERR SetupNullSession( const TCHAR * pszServer );

APIERR SetupNormalSession( const TCHAR * pszServer );

APIERR DestroySession( const TCHAR * pszServer );


/*****************************************************************************

    IsSlowTransport

    CAVEAT:  THIS CALL MAY LEAVE A SESSION TO THE SERVER IF A SLOW TRANSPORT
             IS DETECTED BECAUSE THE WORKER THREAD MAY STILL BE MAKING API
             CALLS AFTER THE TIMEOUT CAUSING THE NETUSEDEL(with NOFORCE) TO
             BE INEFFECTUAL.

*****************************************************************************/
APIERR IsSlowTransport( const TCHAR FAR * pszServer,
                        BOOL FAR        * pfSlowTransport )
{
    APIERR           err = NERR_Success;
    BOOL             fSessionSetup=FALSE;
    DWORD            resWait;
    DWORD            idThread;
    HANDLE           hThread;

    *pfSlowTransport = FALSE;

    // return immediately if pszServer is NULL
    if (pszServer == NULL || *pszServer == 0)
    {
        *pfSlowTransport = FALSE;
        return(NERR_Success);
    }

    //
    //  Initialize.
    //

    err              = NERR_Success;
    errThread        = NERR_Success;

    //
    // Set up the session.
    //
    err = SetupNormalSession (pszServer);

    if (err == NERR_Success)
    {
        fSessionSetup = TRUE;
    }
    else if (err == ERROR_SESSION_CREDENTIAL_CONFLICT)
    {
        err = NERR_Success;
    }
    else
    {
        err = SetupNullSession (pszServer);
        if (err != NERR_Success)
            return(err);
        fSessionSetup = TRUE;
    }

    do  // false loop
    {
        //
        //  Create the worker thread.
        //

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SlowTransportWorkerThread,
                                (LPVOID)pszServer,
                                0,
                                &idThread );

        if( hThread == NULL )
        {
            err = (APIERR) GetLastError();
            break;
        }

        //
        //  Wait for either the thread to complete or a timeout.
        //

        resWait = WaitForSingleObject( hThread, MAXWAITTIME );

        CloseHandle( hThread );
        hThread = NULL;

        //
        //  Interpret the results.
        //

        if( resWait == -1 )
        {
            err = (APIERR)GetLastError();
            break;
        }

        switch (resWait)
        {

        case WAIT_TIMEOUT:
            *pfSlowTransport = TRUE;
            break;

        case WAIT_OBJECT_0:
            if (errThread == NERR_Success)
            {
                *pfSlowTransport = FALSE;
            }
            break;

        default:
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

    } while ( FALSE );

    //
    //  Destroy the session if we managed to create one.
    //

    if (fSessionSetup)
    {
        DestroySession( pszServer );
    }

    return ( (err != NERR_Success) ? err : errThread );

}   // IsSlowTransport


/*****************************************************************************

    SetupSession

*****************************************************************************/
APIERR SetupSession( const TCHAR * pszServer )
{
    APIERR           err;
    WKSTA_INFO_100 * pwki100       = NULL;

    //
    //  Connect to the target server.
    //

    err = SetupNullSession( pszServer );

    if( err == NERR_Success ) //  NULL session established.
    {
        BOOL fIsDownlevel = FALSE;

        //
        //  Determine target type.
        //

        err = NetWkstaGetInfo( (LPTSTR)pszServer,
                               100,
                               (LPBYTE *)&pwki100 );

        if( ( err == ERROR_ACCESS_DENIED ) ||
            ( ( err == NERR_Success ) &&
              ( pwki100->wki100_platform_id == SV_PLATFORM_ID_OS2 ) ) )
        {
            //
            //  The target is downlevel.
            //

            fIsDownlevel = TRUE;
        }

        if( ( err != NERR_Success ) || fIsDownlevel )
        {
            //
            //  Either we cannot talk to the server, or it's
            //  downelevel, so blow away the NULL session.
            //

            DestroySession( pszServer );
        }

        if( fIsDownlevel )
        {
            //
            //  It's a downlevel server.  There aren't many useful
            //  API we can remote to a downlevel server over a NULL
            //  session, (and we just blew away the NULL session
            //  anyway) so try a "normal" session.
            //

            err = SetupNormalSession( pszServer );
        }

        if( pwki100 != NULL )
        {
            NetApiBufferFree( (LPVOID)pwki100 );
        }
    }

    return(err);
}

/*****************************************************************************

    SlowTransportWorkerThread

*****************************************************************************/
void SlowTransportWorkerThread( LPVOID pParam )
{
    INT i;
    WKSTA_INFO_101 * pwksta_info_101 = NULL;

    for (i = 0; i < 3; i++)
    {
        errThread = (APIERR) NetWkstaGetInfo ((LPTSTR) pParam,
                                              100,
                                              (LPBYTE *) &pwksta_info_101);

        if( pwksta_info_101 != NULL )
        {
            NetApiBufferFree( (LPVOID)pwksta_info_101 );
        }

        if (errThread != NERR_Success)
        {
            return;
        }
    }
}   // SlowTransportWorkerThread


/*****************************************************************************

    SetupNullSession

*****************************************************************************/
APIERR SetupNullSession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];
    USE_INFO_2       ui2;

    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    ui2.ui2_local      = NULL;
    ui2.ui2_remote     = (LPTSTR)szShare;
    ui2.ui2_password   = (LPTSTR)L"";
    ui2.ui2_asg_type   = USE_IPC;
    ui2.ui2_username   = (LPTSTR)L"";
    ui2.ui2_domainname = (LPTSTR)L"";

    err = NetUseAdd( NULL,
                     2,
                     (LPBYTE)&ui2,
                     NULL );

    return err;

}   // SetupNullSession



/*****************************************************************************

    SetupNormalSession

*****************************************************************************/
APIERR SetupNormalSession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];
    USE_INFO_1       ui1;

    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    ui1.ui1_local      = NULL;
    ui1.ui1_remote     = (LPTSTR)szShare;
    ui1.ui1_password   = NULL;
    ui1.ui1_asg_type   = USE_IPC;

    err = NetUseAdd( NULL,
                     1,
                     (LPBYTE)&ui1,
                     NULL );

    return err;

}   // SetupNormalSession



/*****************************************************************************

    DestroySession

*****************************************************************************/
APIERR DestroySession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];

    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    err = NetUseDel( NULL,
                     (LPTSTR)szShare,
                     USE_NOFORCE );

    return err;

}   // DestroySession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\mnet32\muser.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MUSER.C

Abstract:

    Contains mapping functions to present netcmd with versions
    of the Net32 APIs which use ASCII instead of Unicode.

    This module maps the NetUser APIs.

Author:

    Ben Goetter     (beng)  22-Aug-1991

Environment:

    User Mode - Win32

Revision History:

    22-Aug-1991     beng
        Created
    09-Oct-1991     W-ShankN
        Streamlined parameter handling, descriptor strings.
    26-Feb-1992     JonN
        Copied from NetCmd for temporary ANSI <-> UNICODE hack
    28-Apr-1992     JonN
        Enabled USER_INFO_3
    05-May-1992     JonN
        MIPS build fix

--*/

// Following turns off everything until the world pulls together again.
//
// #ifdef DISABLE_ALL_MAPI
// #define DISABLE_ACCESS_MAPI
// #endif

//
// INCLUDES
//

#ifndef DEBUG
#include <windef.h>
#else
#include <windows.h>    // OutputDebugString
#endif // DEBUG

#include <time.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>

#include <lm.h>
#include <lmerr.h>      // NERR_
#include "remdef.h"     // REM structure descriptor strings

#include "port1632.h"   // includes maccess.h

// These declarations will save some space.

static const LPSTR pszDesc_user_info_0  = REM32_user_info_0;
static const LPSTR pszDesc_user_info_1  = REM32_user_info_1_NOCRYPT;
static const LPSTR pszDesc_user_info_1_setinfo
                                        = REM32_user_info_1_setinfo_NOCRYPT;
static const LPSTR pszDesc_user_info_2  = REM32_user_info_2_NOCRYPT;
static const LPSTR pszDesc_user_info_2_setinfo
                                        = REM32_user_info_2_setinfo_NOCRYPT;

/*
 * NOTE JONN 4/28/92:  We define these here since they are not present
 * in net\inc\remdef.h.  Should they be there instead?
 *
 * NOTE JONN 4/30/92:  Note that the second field has been changed from
 * 'Q' to 'z'.  The API inists that the password be translated to UNICODE!
 */
static const LPSTR pszDesc_user_info_3  = "zQzDDzzDzDzzzzDDDDDb21DDzDDDDzz";
static const LPSTR pszDesc_user_info_3_setinfo
                                        = "QQzQDzzDzDzzzzQQDDDB21DDzDDDDzz";

static const LPSTR pszDesc_user_info_10 = REM32_user_info_10;
static const LPSTR pszDesc_user_info_11 = REM32_user_info_11;
static const LPSTR pszDesc_group_info_0 = REM32_group_info_0;
static const LPSTR pszDesc_user_modals_info_0
                                        = REM32_user_modals_info_0;
static const LPSTR pszDesc_user_modals_info_0_setinfo
                                        = REM32_user_modals_info_0_setinfo;
static const LPSTR pszDesc_user_modals_info_1
                                        = REM32_user_modals_info_1;
static const LPSTR pszDesc_user_modals_info_1_setinfo
                                        = REM32_user_modals_info_1_setinfo;

WORD
MNetUserAdd(
    LPSTR        pszServer,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    LPWSTR       pwszServer = NULL;
    MXSAVELIST * pmxsavlst;
    CHAR *       pszDesc;
#ifdef DEBUG
    TCHAR achDebug[75];
    DWORD param;
#endif // DEBUG

    UNREFERENCED_PARAMETER(cbBuffer);

    switch (nLevel) {
    case 1:
        pszDesc = pszDesc_user_info_1;
        break;
    case 2:
        pszDesc = pszDesc_user_info_2;
        break;
    case 3:
        pszDesc = pszDesc_user_info_3;
        break;
    default:
        return ERROR_INVALID_LEVEL;
    }

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    nErr = MxMapClientBuffer(pbBuffer, &pmxsavlst, 1, pszDesc);
    if (nErr)
    {
        MxFreeUnicode(pwszServer);
        return (WORD)nErr;
    }

#ifndef DEBUG
    nRes = NetUserAdd(pwszServer, nLevel, pbBuffer, NULL);
#else
    nRes = NetUserAdd(pwszServer, nLevel, pbBuffer, &param);
    if ( nRes == ERROR_INVALID_PARAMETER ) {
       wsprintf(achDebug,"NetUserAdd: parameter in error is %d\n\r", param);
       OutputDebugString( achDebug );
    }
#endif // DEBUG

    MxRestoreClientBuffer(pbBuffer, pmxsavlst);
    pmxsavlst = NULL;
    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserDel(
    LPSTR   pszServer,
    LPSTR   pszUserName )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserDel(apwsz[0], apwsz[1]);

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserEnum(
    LPSTR   pszServer,
    DWORD   nLevel,
    LPBYTE *ppbBuffer,
    DWORD * pcEntriesRead )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD   cTotalAvail;

    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  pwszServer = NULL;

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserEnum(pwszServer, nLevel,
                       UF_NORMAL_ACCOUNT | UF_TEMP_DUPLICATE_ACCOUNT,
                       ppbBuffer, MAXPREFERREDLENGTH,
                       pcEntriesRead, &cTotalAvail, NULL);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        CHAR * pszDesc;
        switch (nLevel)
        {
        case 0:
        default:
            pszDesc = pszDesc_user_info_0;
            break;
        case 1:
            pszDesc = pszDesc_user_info_1;
            break;
        case 2:
            pszDesc = pszDesc_user_info_2;
            break;
        case 10:
            pszDesc = pszDesc_user_info_10;
            break;
        case 11:
            pszDesc = pszDesc_user_info_11;
            break;
        }
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, *pcEntriesRead, pszDesc);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicode(pwszServer);
            return (WORD)nErr;
        }
    }

    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserGetInfo(
    LPSTR   pszServer,
    LPSTR   pszUserName,
    DWORD   nLevel,
    LPBYTE *ppbBuffer )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserGetInfo(apwsz[0], apwsz[1], nLevel, ppbBuffer);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        CHAR * pszDesc;
        switch (nLevel)
        {
        case 0:
        default:
            pszDesc = pszDesc_user_info_0;
            break;
        case 1:
            pszDesc = pszDesc_user_info_1;
            break;
        case 2:
            pszDesc = pszDesc_user_info_2;
            break;
        case 3:
            pszDesc = pszDesc_user_info_3;
            break;
        case 10:
            pszDesc = pszDesc_user_info_10;
            break;
        case 11:
            pszDesc = pszDesc_user_info_11;
            break;
        }
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, 1, pszDesc);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicodeVector(apwsz, 2);
            return (WORD)nErr;
        }
    }

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserSetInfo(
    LPSTR        pszServer,
    LPSTR        pszUserName,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer,
    DWORD        nParmNum )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    MXSAVELIST * pmxsavlst;
    LPWSTR       apwsz[2];
    DWORD        nLevelNew;
    CHAR *       pszDesc;
    CHAR *       pszRealDesc;
    DWORD        nFieldInfo;
#ifdef DEBUG
    DWORD param;
    TCHAR achDebug[75];
#endif // DEBUG

    UNREFERENCED_PARAMETER(cbBuffer);

    switch (nLevel) {
    case 0:
	pszDesc = pszDesc_user_info_0;
	pszRealDesc = pszDesc_user_info_0;
	break;
    case 1:
        pszDesc = pszDesc_user_info_1_setinfo;
        pszRealDesc = pszDesc_user_info_1;
        break;
    case 2:
        pszDesc = pszDesc_user_info_2_setinfo;
        pszRealDesc = pszDesc_user_info_2;
        break;
    case 3:
        pszDesc = pszDesc_user_info_3_setinfo;
        pszRealDesc = pszDesc_user_info_3;
        break;
    default:
        return ERROR_INVALID_LEVEL;
    }

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    // NOTE:  I don't think this is necessary. The descriptor string
    //        should handle this.

    // Old UserSetInfo structures had a pad field immediately following
    // the username; so adjust Win32 fieldinfo index to reflect actual
    // offset.

    nFieldInfo = nParmNum;
    // if (nFieldInfo > USER_NAME_PARMNUM)
    //    --nFieldInfo;

    nErr = MxMapSetinfoBuffer(&pbBuffer, &pmxsavlst, pszDesc,
                              pszRealDesc, nFieldInfo);
    if (nErr)
    {
        MxFreeUnicodeVector(apwsz, 2);
        return (WORD)nErr;
    }

    nLevelNew = MxCalcNewInfoFromOldParm(nLevel, nParmNum);
#ifndef DEBUG
    nRes = NetUserSetInfo(apwsz[0], apwsz[1], nLevelNew, pbBuffer, NULL);
#else
    nRes = NetUserSetInfo(apwsz[0], apwsz[1], nLevelNew, pbBuffer, &param);
    if ( nRes == ERROR_INVALID_PARAMETER ) {
       wsprintf(achDebug,"NetUserSetInfo: parameter in error is %d\n\r", param);
       OutputDebugString( achDebug );
    }
#endif // DEBUG

    nErr = MxRestoreSetinfoBuffer(&pbBuffer, pmxsavlst, pszDesc, nFieldInfo);
    if (nErr)   // big trouble - restore may not have worked.
    {
        MxFreeUnicodeVector(apwsz, 2);
        return (WORD)nErr;
    }
    pmxsavlst = NULL;
    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserGetGroups(
    LPSTR   pszServer,
    LPSTR   pszUserName,
    DWORD   nLevel,
    LPBYTE *ppbBuffer,
    DWORD * pcEntriesRead )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    DWORD   cTotalAvail;

    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[2];

    if (nLevel != 0)
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserGetGroups(apwsz[0], apwsz[1], nLevel,
                            ppbBuffer, MAXPREFERREDLENGTH,
                            pcEntriesRead, &cTotalAvail);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, *pcEntriesRead,
                                  pszDesc_group_info_0);
        if (nErr)
        {
            // So close... yet so far.
            MxFreeUnicodeVector(apwsz, 2);
            return (WORD)nErr;
        }
    }

    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserSetGroups(
    LPSTR        pszServer,
    LPSTR        pszUserName,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer,
    DWORD        cEntries )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    MXSAVELIST * pmxsavlst;
    LPWSTR       apwsz[2];

    UNREFERENCED_PARAMETER(cbBuffer);

    if (nLevel != 0)
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(2, apwsz, pszServer,
                                     pszUserName);
    if (nErr)
        return (WORD)nErr;

    nErr = MxMapClientBuffer(pbBuffer, &pmxsavlst,
                             cEntries, pszDesc_group_info_0);
    if (nErr)
    {
        MxFreeUnicodeVector(apwsz, 2);
        return (WORD)nErr;
    }

    nRes = NetUserSetGroups(apwsz[0], apwsz[1], nLevel, pbBuffer, cEntries);

    MxRestoreClientBuffer(pbBuffer, pmxsavlst);
    pmxsavlst = NULL;
    MxFreeUnicodeVector(apwsz, 2);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserModalsGet(
    LPSTR   pszServer,
    DWORD   nLevel,
    LPBYTE *ppbBuffer )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  pwszServer = NULL;

    // Assumption needed for AsciifyRpcBuffer

    if (!(nLevel == 0 || nLevel == 1))
        return ERROR_INVALID_LEVEL;

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserModalsGet(pwszServer, nLevel, ppbBuffer);

    if (nRes == NERR_Success || nRes == ERROR_MORE_DATA)
    {
        CHAR * pszDesc = (nLevel == 0)
                         ? pszDesc_user_modals_info_0
                         : pszDesc_user_modals_info_1;
        nErr = MxAsciifyRpcBuffer(*ppbBuffer, 1, pszDesc);
        if (nErr)
        {
            MxFreeUnicode(pwszServer);
            return (WORD)nErr;
        }
    }

    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserModalsSet(
    LPSTR        pszServer,
    DWORD        nLevel,
    LPBYTE       pbBuffer,
    DWORD        cbBuffer,
    DWORD        nParmNum )
{
#if defined(DISABLE_ACCESS_MAPI)
    return ERROR_NOT_SUPPORTED;
#else
    UINT         nErr;  // error from mapping
    DWORD        nRes;  // return from Netapi
    LPWSTR       pwszServer = NULL;
    UINT         nFieldInfo;
    DWORD        nLevelNew;
    CHAR *       pszDesc;
    CHAR *       pszRealDesc;
    MXSAVELIST * pmxsavlst;

    UNREFERENCED_PARAMETER(cbBuffer);

    if (!(nLevel == 0 || nLevel == 1))
        return ERROR_INVALID_LEVEL;

    pszDesc = (nLevel == 0) ? pszDesc_user_modals_info_0_setinfo
                            : pszDesc_user_modals_info_1_setinfo;
    pszRealDesc = (nLevel == 0) ? pszDesc_user_modals_info_0
                                : pszDesc_user_modals_info_1;

    nErr = MxMapParameters(1, &pwszServer, pszServer);
    if (nErr)
        return (WORD)nErr;

    // For UserModalsSet, which is really a SetInfo API in disguise,
    // parmnum given == fieldnum for level 0. However, level 1, the
    // fieldnums start at 1 while the parmnums start at 6.

    nFieldInfo = nParmNum;
    if (((nLevel == 1)&&(nParmNum > 5)) || ((nLevel == 2)&&(nParmNum < 6)))
    {
        MxFreeUnicode(pwszServer);
        return ERROR_INVALID_PARAMETER;
    }
    if (nLevel == 2)
        nFieldInfo -= 5;

    nErr = MxMapSetinfoBuffer(&pbBuffer, &pmxsavlst, pszDesc,
                              pszRealDesc, nFieldInfo);
    if (nErr)
    {
        MxFreeUnicode(pwszServer);
        return (WORD)nErr;
    }

    nLevelNew = MxCalcNewInfoFromOldParm(nLevel, nParmNum);
    nRes = NetUserModalsSet(pwszServer, nLevelNew, pbBuffer, NULL);

    nErr = MxRestoreSetinfoBuffer(&pbBuffer, pmxsavlst, pszDesc, nFieldInfo);
    if (nErr)   // big trouble - restore may not have worked.
    {
        MxFreeUnicode(pwszServer);
        return (WORD)nErr;
    }
    pmxsavlst = NULL;
    MxFreeUnicode(pwszServer);

    return LOWORD(nRes);
#endif
}


WORD
MNetUserPasswordSet(
    LPSTR   pszServer,
    LPSTR   pszUserName,
    LPSTR   pszPasswordOld,
    LPSTR   pszPasswordNew )
{
#if 0
    UINT    nErr;  // error from mapping
    DWORD   nRes;  // return from Netapi
    LPWSTR  apwsz[4];

    nErr = MxMapParameters(4, pszServer,
                              pszUserName,
                              pszPasswordOld,
                              pszPasswordNew);
    if (nErr)
        return (WORD)nErr;

    nRes = NetUserPasswordSet(apwsz[0], apwsz[1], apwsz[2], apwsz[3]);

    MxFreeUnicodeVector(apwsz, 4);

    return LOWORD(nRes);
#else
    return ERROR_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\palert.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    palert.c
    mapping layer for NetAlert API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetAlertRaise(
	const TCHAR FAR	 * pszEvent,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	ULONG		   ulTimeout )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( ulTimeout );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertRaise


APIERR MNetAlertStart(
	const TCHAR FAR	 * pszEvent,
	const TCHAR FAR	 * pszRecipient,
	UINT		   cbMaxData )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pszRecipient );
    UNREFERENCED( cbMaxData );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertStart


APIERR MNetAlertStop(
    const TCHAR FAR   * pszEvent,
    const TCHAR FAR   * pszRecipient )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pszRecipient );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertStop

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\paudit.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    paudit.c
    mapping layer for NetAudit API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	KeithMo		30-Oct-1991	Added auditing support.
*/

#include "pchmn32.h"

APIERR MNetAuditClear(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBackupFile,
	TCHAR FAR	 * pszService )
{
    return (APIERR)NetAuditClear( (TCHAR *)pszServer,
    				  (TCHAR *)pszBackupFile,
				  pszService );

}   // MNetAuditClear


APIERR MNetAuditRead(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	HLOG FAR	 * phAuditLog,
	ULONG		   ulOffset,
	UINT FAR	 * pReserved2,
	ULONG		   ulReserved3,
	ULONG		   flOffset,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    return (APIERR)NetAuditRead( (TCHAR *)pszServer,
    				 (TCHAR *)pszService,
				 phAuditLog,
				 (DWORD)ulOffset,
				 (LPDWORD)pReserved2,
				 (DWORD)ulReserved3,
				 (DWORD)flOffset,
				 ppbBuffer,
				 (DWORD)ulMaxPreferred,
				 (LPDWORD)pcbReturned,
				 (LPDWORD)pcbTotalAvail );

}   // MNetAuditRead


APIERR MNetAuditWrite(
	UINT		   Type,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	TCHAR FAR	 * pszService,
	TCHAR FAR	 * pszReserved )
{
    return (APIERR)NetAuditWrite( (DWORD)Type,
				  pbBuffer,
				  (DWORD)cbBuffer,
				  pszService,
				  (LPBYTE)pszReserved );

}   // MNetAuditWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pbios.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pbios.c
    mapping layer for NetBios API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetBiosOpen(
	TCHAR FAR	 * pszDevName,
	TCHAR FAR	 * pszReserved,
	UINT		   OpenOpt,
	UINT FAR	 * phDevName )
{

    UNREFERENCED( pszDevName );
    UNREFERENCED( pszReserved );
    UNREFERENCED( OpenOpt );
    UNREFERENCED( phDevName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosOpen


APIERR MNetBiosClose(
	UINT		   hDevName,
	UINT		   Reserved )
{
    UNREFERENCED( hDevName );
    UNREFERENCED( Reserved );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosClose


APIERR MNetBiosEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosEnum


APIERR MNetBiosGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetBiosName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszNetBiosName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosGetInfo


APIERR MNetBiosSubmit(
	UINT		   hDevName,
	UINT		   NcbOpt,
	struct ncb FAR	 * pNCB )
{
    UNREFERENCED( hDevName );
    UNREFERENCED( NcbOpt );
    UNREFERENCED( pNCB );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosSubmit

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pchar.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pchar.c
    mapping layer for NetChar API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

//
//  CODEWORK!
//
//  Remove the following #define when we finally
//  get NetCharDev*() API support in NT.
//

#define	CHARDEV_NOT_SUPPORTED


APIERR MNetCharDevControl(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDevName,
	UINT		   OpCode )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevControl( (TCHAR *)pszServer,
				      (TCHAR *)pszDevName,
				      OpCode );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevControl


#if 0

APIERR MNetCharDevEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetCharDevEnum

#endif


APIERR MNetCharDevGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDevName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevGetInfo( (TCHAR *)pszServer,
    				      (TCHAR *)pszDevName,
				      Level,
				      ppbBuffer );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevGetInfo


APIERR MNetCharDevQEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszUserName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    *pcEntriesRead = 0;

    return NERR_Success;		// CODEWORK!  UNAVAILABLE IN PRODUCT 1

}   // MNetCharDevQEnum


APIERR MNetCharDevQGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQGetInfo( (TCHAR *)pszServer,
    				       (TCHAR *)pszQueueName,
				       (TCHAR *)pszUserName,
				       Level,
				       ppbBuffer );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQGetInfo


APIERR MNetCharDevQSetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetCharDevQSetInfo( (TCHAR *)pszServer,
				       (TCHAR *)pszQueueName,
				       Level,
				       pbBuffer,
				       NULL );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQSetInfo


APIERR MNetCharDevQPurge(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQPurge( (TCHAR *)pszServer,
				     (TCHAR *)pszQueueName );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQPurge


APIERR MNetCharDevQPurgeSelf(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	const TCHAR FAR	 * pszComputerName )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQPurgeSelf( (TCHAR *)pszServer,
					 (TCHAR *)pszQueueName,
					 (TCHAR *)pszComputerName );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQPurgeSelf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\paccess.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    paccess.c
    mapping layer for NetAccess API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

// Do this until we get the real Net access stubs
#define NOT_IMPLEMENTED 0

APIERR MNetAccessAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetAccessAdd( (TCHAR *)pszServer,
				 Level,
				 pbBuffer,
				 NULL );
#endif
}   // MNetAccessAdd


APIERR MNetAccessCheck(
	TCHAR FAR	 * pszReserved,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszResource,
	UINT		   Operation,
	UINT FAR	 * pResult )
{
    return ERROR_NOT_SUPPORTED ;
#if 0
    This api is not supported on NT.  It is never used so it will remain
    as being unsupported.

    return (APIERR)NetAccessCheck( pszReserved,
				   pszUserName,
				   pszResource,
				   Operation,
				   (LPDWORD)pResult );
#endif
}   // MNetAccessCheck


APIERR MNetAccessDel(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessDel( (TCHAR *)pszServer,
				 pszResource );
#endif
}   // MNetAccessDel


APIERR MNetAccessEnum(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszBasePath,
	UINT		   fRecursive,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD	cTotalAvail;

    return (APIERR)NetAccessEnum( (TCHAR *)pszServer,
    				  pszBasePath,
				  fRecursive,
				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalAvail,
				  NULL );
#endif
}   // MNetAccessEnum


APIERR MNetAccessGetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessGetInfo( (TCHAR *)pszServer,
				     pszResource,
				     Level,
				     ppbBuffer );
#endif
}   // MNetAccessGetInfo


APIERR MNetAccessSetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetAccessSetInfo( (TCHAR *)pszServer,
				     pszResource,
				     Level,
				     pbBuffer,
				     NULL );
#endif
}   // MNetAccessSetInfo


APIERR MNetAccessGetUserPerms(
	TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUgName,
	TCHAR FAR	 * pszResource,
	UINT FAR	 * pPerms )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessGetUserPerms( (TCHAR *)pszServer,
					  pszUgName,
					  pszResource,
					  (LPDWORD)pPerms );
#endif
}   // MNetAccessGetUserPerms
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pchmn32.h ===
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETREPL
#define INCL_WINDOWS

#include <nt.h>
#include <ntrtl.h>
#include <ntsam.h>
#include <nturtl.h>

#include "lmui.hxx"
#include <lm.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <malloc.h>
#include "mnetp.h"
#include "netdebug.h"
#include "netlib.h"	
#include "rap.h"
#include "remdef.h"
#include "remtypes.h"
#include <rpc.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "tstr.h"	
#include <wchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pconnect.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pconnect.c
    mapping layer for NetConnect API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetConnectionEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQualifier,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetConnectionEnum( (TCHAR *)pszServer,
    				      (TCHAR *)pszQualifier,
				      Level,
				      ppbBuffer,
				      MAXPREFERREDLENGTH,
				      (LPDWORD)pcEntriesRead,
				      &cTotalAvail,
				      NULL );

}   // MNetConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\perror.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    perror.c
    mapping layer for NetError API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	KeithMo		30-Oct-1991	Added error log support.
*/

#include "pchmn32.h"

APIERR MNetErrorLogClear(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBackupFile,
	TCHAR FAR	 * pszReserved )
{
    return (APIERR)NetErrorLogClear( (TCHAR *)pszServer,
    				     (TCHAR *)pszBackupFile,
				     (LPBYTE)pszReserved );

}   // MNetErrorLogClear


APIERR MNetErrorLogRead(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszReserved1,
	HLOG       FAR	 * phErrorLog,
	ULONG	 	   ulOffset,
	UINT FAR	 * pReserved2,
	ULONG		   ulReserved3,
	ULONG		   flOffset,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    return (APIERR)NetErrorLogRead( (TCHAR *)pszServer,
    				    (TCHAR *)pszReserved1,
				    phErrorLog,
				    (DWORD)ulOffset,
				    (LPDWORD)pReserved2,
				    (DWORD)ulReserved3,
				    (DWORD)flOffset,
				    ppbBuffer,
				    (DWORD)ulMaxPreferred,
				    (LPDWORD)pcbReturned,
				    (LPDWORD)pcbTotalAvail );

}   // MNetErrorLogRead


APIERR MNetErrorLogWrite(
	TCHAR FAR	 * pszReserved1,
	UINT		   Code,
	const TCHAR FAR	 * pszComponent,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	const TCHAR FAR	 * pszStrBuf,
	UINT		   cStrBuf,
	TCHAR FAR	 * pszReserved2 )
{
    return (APIERR)NetErrorLogWrite( (LPBYTE)pszReserved1,
    				     (DWORD)Code,
				     (TCHAR *)pszComponent,
				     pbBuffer,
				     (DWORD)cbBuffer,
				     (LPBYTE)pszStrBuf,
				     (DWORD)cStrBuf,
				     (LPBYTE)pszReserved2 );

}   // MNetErrorLogWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pfile.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pfile.c
    mapping layer for NetFile API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetFileClose(
	const TCHAR FAR	 * pszServer,
	ULONG		   ulFileId )
{
    return (APIERR)NetFileClose( (TCHAR *)pszServer,
				 ulFileId );

}   // MNetFileClose


APIERR MNetFileEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBasePath,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcEntriesRead,
	UINT FAR	 * pcTotalAvail,
	VOID FAR	 * pResumeKey )
{
    return (APIERR)NetFileEnum( (TCHAR *)pszServer,
    				(TCHAR *)pszBasePath,
				(TCHAR *)pszUserName,
				Level,
				ppbBuffer,
				ulMaxPreferred,
				(LPDWORD)pcEntriesRead,
				(LPDWORD)pcTotalAvail,
				pResumeKey );

}   // MNetFileEnum


APIERR MNetFileGetInfo(
	const TCHAR FAR	 * pszServer,
	ULONG		   ulFileId,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetFileGetInfo( (TCHAR *)pszServer,
    				   ulFileId,
				   Level,
				   ppbBuffer );

}   // MNetFileGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pget.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pget.c
    mapping layer for NetGetDCName

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	JonN		21-Oct-1991	Zapped until NetGetDCName works
	KeithMo		22-Oct-1991	Fixed the zap.
        DavidHov        15 Apr 92       Created 1st-cut UNICODE version using
                                        remnants of MBCS.C
	ChuckC		06-Aug-1992	removed Unicode stuff that is no
					longer needed.

*/

#include "pchmn32.h"


APIERR MNetGetDCName(
 	 const TCHAR FAR	 * pszServer,
    const TCHAR FAR	 * pszDomain,
	 BYTE FAR	** ppbBuffer )
{
    APIERR err = 0 ;

    err = (APIERR) NetGetDCName( (TCHAR *)pszServer,
    		                        (TCHAR *)pszDomain,
				                     ppbBuffer );
    return err ;

}   // MNetGetDCName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pconfig.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pconfig.c
    mapping layer for NetConfig API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
        KeithMo         04-Jun-1992     Sync with revised NetConfigXxx API.

*/

#include "pchmn32.h"

APIERR MNetConfigGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszParameter,
        BYTE FAR        ** ppbBuffer )
{
    UNREFERENCED( pszReserved );

    return (APIERR)NetConfigGet( (LPTSTR)pszServer,
                                 (LPTSTR)pszComponent,
                                 (LPTSTR)pszParameter,
                                 (LPBYTE *)ppbBuffer );

}   // MNetConfigGet


APIERR MNetConfigGetAll(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        BYTE FAR        ** ppbBuffer)
{
    UNREFERENCED( pszReserved );

    return (APIERR)NetConfigGetAll( (LPTSTR)pszServer,
                                    (LPTSTR)pszComponent,
                                    (LPBYTE *)ppbBuffer );

}   // MNetConfigGetAll


APIERR MNetConfigSet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszKey,
        const TCHAR FAR  * pszData )
{
    CONFIG_INFO_0 cfgi0;

    cfgi0.cfgi0_key  = (LPTSTR)pszKey;
    cfgi0.cfgi0_data = (LPTSTR)pszData;

    return (APIERR)NetConfigSet( (LPTSTR)pszServer,
                                 NULL,
                                 (LPTSTR)pszComponent,
                                 0,
                                 0,
                                 (LPBYTE)&cfgi0,
                                 0 );

}   // MNetConfigSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pfreebuf.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pfreebuf.c
    mapping layer for Memory allocation API (unique to mapping layer)

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"


//////////////////////////////////////////////////////////////////////////////
//
//				Public Functions
//
//////////////////////////////////////////////////////////////////////////////


//
//  Allocate an API buffer.
//

BYTE FAR * MNetApiBufferAlloc(
	UINT		   cbBuffer )
{
    BYTE FAR * pbBuffer;

    if( NetapipBufferAllocate( cbBuffer, (LPVOID *)&pbBuffer ) != NERR_Success )
    {
    	return NULL;
    }

    return pbBuffer;

}   // MNetpAlloc


//
//  Free the API buffer.
//

VOID MNetApiBufferFree(
	BYTE FAR	** ppbBuffer )
{
    if( ( ppbBuffer != NULL ) && ( *ppbBuffer != NULL ) )
    {
	NetApiBufferFree( (VOID *)*ppbBuffer );
	*ppbBuffer = NULL;
    }

}   // MNetApiBufferFree


//**************************************************************************//
//									    //
//		    WARNING!!       DANGER!!!       WARNING!!		    //
//									    //
//  The following two routines are highly dependent on the implementation   //
//  of the NT Net API buffer routines (see \nt\private\net\api\apibuff.c).  //
//  These routines are written as such just as a temporary hack, until	    //
//  DanHi gives us official support for these functions we so desparately   //
//  need.								    //
//									    //
//	-- KeithMo, 28-Oct-1991						    //
//									    //
//		    WARNING!!       DANGER!!!       WARNING!!		    //
//									    //
//**************************************************************************//

//
//  Reallocate an API buffer.
//

APIERR MNetApiBufferReAlloc(
	BYTE FAR	** ppbBuffer,
	UINT		   cbBuffer )
{
    BYTE FAR * pbBuffer;

    pbBuffer = (BYTE FAR *)LocalReAlloc( (HANDLE)*ppbBuffer, cbBuffer, LMEM_MOVEABLE );

    if( pbBuffer == NULL )
    {
    	return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppbBuffer = pbBuffer;

    return NERR_Success;

}   // MNetApiBufferReAlloc


//
//  Retrieve the size of an API buffer.
//

APIERR MNetApiBufferSize(
	BYTE FAR	 * pbBuffer,
	UINT FAR	 * pcbBuffer )
{
    UINT cb;

    cb = (UINT)LocalSize( (HANDLE)pbBuffer );

    if( cb == 0 )
    {
    	return ERROR_INVALID_PARAMETER;
    }

    *pcbBuffer = cb;

    return NERR_Success;

}   // MNetApiBufferSize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\phandle.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    phandle.c
    mapping layer for NetHandle API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"
#if 0

APIERR MNetHandleGetInfo(
	UINT		   hHandle,
	UINT	 	   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( hHandle );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetHandleGetInfo


APIERR MNetHandleSetInfo(
	UINT		   hHandle,
	UINT	 	   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( hHandle );
    UNREFERENCED( Level );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( ParmNum );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetHandleSetInfo
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pprint.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pprint.c
    mapping layer for Printing API

    FILE HISTORY:
        KeithMo         14-Oct-1991     Created.

*/

#include "pchmn32.h"

APIERR MDosPrintQEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );

    *ppbBuffer     = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;                // CODEWORK!  UNAVAILBLE IN PRODUCT 1

}   // MDosPrintQEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\plogon.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    plogon.c
    mapping layer for NetLogon API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
        KeithMo         30-Apr-1992     Added I_MNetLogonControl.
        ChuckC          06-Aug-1992     Removed #ifdef Unicode stuff

*/

#include "pchmn32.h"

APIERR MNetLogonEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    // this is no longer supported in NETAPI32
    return ERROR_NOT_SUPPORTED;

}   // MNetLogonEnum


APIERR I_MNetLogonControl(
        const TCHAR FAR  * pszServer,
        ULONG              FunctionCode,
        ULONG              Level,
        BYTE FAR        ** ppbBuffer )
{
    return (APIERR)I_NetLogonControl( (LPWSTR)pszServer,
                                      (DWORD)FunctionCode,
                                      (DWORD)Level,
                                      (LPBYTE *)ppbBuffer );

}   // I_MNetLogonControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pgroup.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pgroup.c
    mapping layer for NetGroup API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
   JonN     27-May-1992    Removed ANSI<->UNICODE hack

*/

#include "pchmn32.h"

/* #define NOT_IMPLEMENTED 1   Removed JonN 5/27/92 */

APIERR MNetGroupAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer )
{

#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetGroupAdd( (TCHAR *)pszServer,
                                Level,
                                pbBuffer,
                                NULL );
#endif
}   // MNetGroupAdd


APIERR MNetGroupDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupDel( (TCHAR *)pszServer,
                                pszGroupName );
#endif
}   // MNetGroupDel


APIERR MNetGroupEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD cTotalAvail;

    return (APIERR)NetGroupEnum( (TCHAR *)pszServer,
                                 Level,
                                 ppbBuffer,
                                 MAXPREFERREDLENGTH,
                                 (LPDWORD)pcEntriesRead,
                                 &cTotalAvail,
                                 NULL );
#endif
}   // MNetGroupEnum


APIERR MNetGroupAddUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupAddUser( (TCHAR *)pszServer,
                                    pszGroupName,
                                    pszUserName );
#endif
}   // MNetGroupAddUser


APIERR MNetGroupDelUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupDelUser( (TCHAR *)pszServer,
                                    pszGroupName,
                                    pszUserName );
#endif
}   // MNetGroupDelUser


APIERR MNetGroupGetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD cTotalAvail;

    return (APIERR)NetGroupGetUsers( (TCHAR *)pszServer,
                                     (TCHAR *)pszGroupName,
                                     Level,
                                     ppbBuffer,
                                     MAXPREFERREDLENGTH,
                                     (LPDWORD)pcEntriesRead,
                                     &cTotalAvail,
                                     NULL );
#endif
}   // MNetGroupGetUsers


APIERR MNetGroupSetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetGroupSetUsers( (TCHAR *)pszServer,
                                     (TCHAR *)pszGroupName,
                                     Level,
                                     pbBuffer,
                                     cEntries );
#endif
}   // MNetGroupSetUsers


APIERR MNetGroupGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR       FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupGetInfo( (TCHAR *)pszServer,
                                    pszGroupName,
                                    Level,
                                    ppbBuffer );
#endif
}   // MNetGroupGetInfo


APIERR MNetGroupSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
        return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetGroupSetInfo( (TCHAR *)pszServer,
                                    pszGroupName,
                                    Level,
                                    pbBuffer,
                                    NULL );
#endif
}   // MNetGroupSetInfo


APIERR MNetLocalGroupAddMember(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        PSID               psidMember )
{
    return (APIERR)NetLocalGroupAddMember( (TCHAR *)pszServer,
                                           (TCHAR *)pszGroupName,
                                           psidMember );

}   // MNetLocalGroupAddMember
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pmessage.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pmessage.c
    mapping layer for NetMessage API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetMessageBufferSend(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszRecipient,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    return (APIERR)NetMessageBufferSend( (TCHAR *)pszServer,
					 pszRecipient,
					 NULL,
					 pbBuffer,
					 cbBuffer );

}   // MNetMessageBufferSend


#if 0

APIERR MNetMessageFileSend(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszRecipient,
	TCHAR FAR	 * pszFileSpec )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszRecipient );
    UNREFERENCED( pszFileSpec );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageFileSend


APIERR MNetMessageLogFileGet(
	const TCHAR FAR	 * pszServer,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pfEnabled )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pfEnabled );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageLogFileGet


APIERR MNetMessageLogFileSet(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszFileSpec,
	UINT		   fEnabled )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszFileSpec );
    UNREFERENCED( fEnabled );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageLogFileSet


APIERR MNetMessageNameAdd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   fFwdAction )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( fFwdAction );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameAdd


APIERR MNetMessageNameDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   fFwdAction )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( fFwdAction );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameDel


APIERR MNetMessageNameEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameEnum


APIERR MNetMessageNameGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameGetInfo


APIERR MNetMessageNameFwd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	const TCHAR FAR	 * pszForwardName,
	UINT		   fDelFwdName )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( pszForwardName );
    UNREFERENCED( fDelFwdName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameFwd


APIERR MNetMessageNameUnFwd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameUnFwd

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\premote.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    premote.c
    mapping layer for NetRemote API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetRemoteCopy(
	const TCHAR FAR	 * pszSourcePath,
	const TCHAR FAR	 * pszDestPath,
	const TCHAR FAR	 * pszSourcePasswd,
	const TCHAR FAR	 * pszDestPasswd,
	UINT		   fOpen,
	UINT		   fCopy,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszSourcePath );
    UNREFERENCED( pszDestPath );
    UNREFERENCED( pszSourcePasswd );
    UNREFERENCED( pszDestPasswd );
    UNREFERENCED( fOpen );
    UNREFERENCED( fCopy );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetRemoteCopy

APIERR MNetRemoteMove(
	const TCHAR FAR	 * pszSourcePath,
	const TCHAR FAR	 * pszDestPath,
	const TCHAR FAR	 * pszSourcePasswd,
	const TCHAR FAR	 * pszDestPasswd,
	UINT		   fOpen,
	UINT		   fCopy,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszSourcePath );
    UNREFERENCED( pszDestPath );
    UNREFERENCED( pszSourcePasswd );
    UNREFERENCED( pszDestPasswd );
    UNREFERENCED( fOpen );
    UNREFERENCED( fCopy );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetRemoteMove

#endif

APIERR MNetRemoteTOD(
	const TCHAR FAR	 * pszServer,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetRemoteTOD( (TCHAR *)pszServer,
    				 ppbBuffer );

}   // MNetRemoteTOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pserver.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pserver.c
    mapping layer for NetServer API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetServerAdminCommand(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszCommand,
	UINT FAR	 * pResult,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszCommand );
    UNREFERENCED( pResult );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( pcbReturned );
    UNREFERENCED( pcbTotalAvail );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetServerAdminCommand
#endif


APIERR MNetServerDiskEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalEntries;
    return (APIERR)NetServerDiskEnum( (TCHAR *)pszServer,
    				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalEntries,
				  NULL );

}   // MNetServerDiskEnum


APIERR MNetServerEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead,
	ULONG		   flServerType,
	TCHAR FAR	 * pszDomain )
{
    DWORD cTotalAvail;

    return (APIERR)NetServerEnum( (TCHAR *)pszServer,
    				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalAvail,
				  flServerType,
				  pszDomain,
				  NULL );

}   // MNetServerEnum


APIERR MNetServerGetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetServerGetInfo( (TCHAR *)pszServer,
    				     Level,
				     ppbBuffer );

}   // MNetServerGetInfo


APIERR MNetServerSetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    // mapping layer does not do  this right now, since UI never uses it.
    if( ParmNum != PARMNUM_ALL )	
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetServerSetInfo( (TCHAR *)pszServer,
    				     Level,
				     pbBuffer,
				     NULL );

}   // MNetServerSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pservice.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pservice.c
    mapping layer for NetService API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
        chuckc          19-Mar-1993     Added code to properly pass
                                        argv[], argc to new APIs.

*/

#include "pchmn32.h"

//
// forward declare
//
DWORD MakeArgvArgc(TCHAR *pszNullNull, TCHAR **ppszArgv, INT *pArgc)  ;
void  FreeArgv(TCHAR **ppszArgv, INT Argc)  ;


APIERR MNetServiceControl(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	UINT		   OpCode,
	UINT		   Arg,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetServiceControl( (TCHAR *)pszServer,
    		                      (TCHAR *)pszService,
				      OpCode,
				      Arg,
				      ppbBuffer );


}   // MNetServiceControl


APIERR MNetServiceEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetServiceEnum( (TCHAR *)pszServer,
    				   Level,
				   ppbBuffer,
				   MAXPREFERREDLENGTH,
				   (LPDWORD)pcEntriesRead,
				   &cTotalAvail,
				   NULL );

}   // MNetServiceEnum


APIERR MNetServiceGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{

    return (APIERR)NetServiceGetInfo( (TCHAR *)pszServer,
    		 		      (TCHAR *)pszService,
				      Level,
				      ppbBuffer );

}   // MNetServiceGetInfo

//
// this is the number of separate arguments. 128 should be plenty
//
#define MAX_SERVICE_INSTALL_ARGS 128

APIERR MNetServiceInstall(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	const TCHAR FAR	 * pszCmdArgs,
	BYTE FAR	** ppbBuffer )
{

    TCHAR *apszMyArgv[MAX_SERVICE_INSTALL_ARGS] ;
    int   nArgc = MAX_SERVICE_INSTALL_ARGS ;
    APIERR err ;

    *ppbBuffer = NULL ;

    //
    // convert a NULL NULL string to the argv, argc style needed by new APIs
    //
    if (err = MakeArgvArgc((TCHAR *)pszCmdArgs, apszMyArgv, &nArgc))
        return err ;

    //
    // call the real API
    //
    err = NetServiceInstall( (TCHAR *)pszServer,
    			     (TCHAR *)pszService,
		             nArgc,
                             apszMyArgv,
                             ppbBuffer );

    //
    // cleanup any memory we allocated
    //
    FreeArgv(apszMyArgv, nArgc) ;

    return err ;

}   // MNetServiceInstall

/*******************************************************************

    NAME:       MakeArgvArgc

    SYNOPSIS:   converts a null null string to argv, argc format.
                memory is allocated for each substring. original
                string is not modified. caller is responsible for
                calling FreeArgv() when done.

    ENTRY:      pszNullNull - null null string, eg: foo\0bar\0\0
                ppszArgv    - used to return array of newly allocated pointers
                pArgc       - used to return number of strings. on entry will
                              contain the number of pointers ppszArgv can hold.

    RETURNS:    NERR_Sucess if successful, error otherwise

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
DWORD MakeArgvArgc(TCHAR *pszNullNull, TCHAR **ppszArgv, INT *pArgc)
{
     int iMax = *pArgc ;
     int iCount ;

     //
     // initialize the return array
     //
     for (iCount = 0; iCount < iMax; iCount++)
         ppszArgv[iCount] = NULL ;

     //
     // the trivial case
     //
     if (pszNullNull == NULL)
     {
         *pArgc = 0 ;
         return NERR_Success ;
     }

     //
     // go thru the null null string
     //
     iCount = 0;
     while (*pszNullNull && (iCount < iMax))
     {
         int i = STRLEN(pszNullNull) ;
         TCHAR *pszTmp = (TCHAR *) NetpMemoryAllocate( (i+1) * sizeof(TCHAR) ) ;

         if (!pszTmp)
         {
             FreeArgv(ppszArgv, iCount) ;
             return(ERROR_NOT_ENOUGH_MEMORY) ;
         }

         STRCPY(pszTmp,pszNullNull) ;
         ppszArgv[iCount] = pszTmp ;

         pszNullNull += i+1 ;
         iCount++ ;
    }

    //
    // we terminated because we ran out of space
    //
    if (iCount >= iMax && *pszNullNull)
    {
         FreeArgv(ppszArgv, iCount) ;
         return(NERR_BufTooSmall) ;
    }

    *pArgc = iCount ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       FreeArgv

    SYNOPSIS:   frees all the strings within the array

    ENTRY:      ppszArgv    - array of pointers
                Argc        - number of strings

    RETURNS:    none

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
void  FreeArgv(TCHAR **ppszArgv, INT Argc)
{
    while (Argc--)
    {
        NetpMemoryFree(ppszArgv[Argc]) ;
        ppszArgv[Argc] = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\psession.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    psession.c
    mapping layer for NetSession API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetSessionDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        const TCHAR FAR  * pszUserName )
{
    return (APIERR)NetSessionDel( (TCHAR *)pszServer,
                                  (TCHAR *)pszClientName,
                                  (TCHAR *)pszUserName );

}   // MNetSessionDel


APIERR MNetSessionEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetSessionEnum( (TCHAR *)pszServer,
                                   NULL,
                                   NULL,
                                   Level,
                                   ppbBuffer,
                                   MAXPREFERREDLENGTH,
                                   (LPDWORD)pcEntriesRead,
                                   &cTotalAvail,
                                   NULL );

}   // MNetSessionEnum


APIERR MNetSessionGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
    DWORD cTotalEntries;
    DWORD cEntriesRead;
    DWORD err;

    err = NetSessionEnum( (TCHAR *)pszServer,
                          (TCHAR *)pszClientName,
                          NULL,
                          Level,
                          ppbBuffer,
                          MAXPREFERREDLENGTH,
                          &cEntriesRead,
                          &cTotalEntries,
                          NULL );

    if( ( err == NERR_Success ) && ( cEntriesRead == 0 ) )
    {
        return NERR_ClientNameNotFound;
    }
    else
    {
        return (APIERR)err;
    }

}   // MNetSessionGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pwksta.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pwksta.c
    mapping layer for NetWksta API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetWkstaGetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    APIERR err;

    err = (APIERR)NetWkstaGetInfo( (TCHAR *)pszServer,
    				   Level,
				   ppbBuffer );

    return err;

}   // MNetWkstaGetInfo


APIERR MNetWkstaSetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetWkstaSetInfo( (TCHAR *)pszServer,
    				    Level,
				    pbBuffer,
				    NULL );

}   // MNetWkstaSetInfo


APIERR MNetWkstaSetUID(
	TCHAR FAR	 * pszReserved,
	TCHAR FAR	 * pszDomain,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszPassword,
	TCHAR FAR	 * pszParms,
	UINT		   LogoffForce,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT FAR	 * pcbTotalAvail )
{
    return ERROR_NOT_SUPPORTED;	    	// WE REALLY NEED THIS ONE!

}   // MNetWkstaSetUID


APIERR MNetWkstaUserEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    APIERR err;
    DWORD  cTotalAvail;

    if( Level != 1 )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    err = (APIERR)NetWkstaUserEnum( (TCHAR *)pszServer,
    				    (DWORD)Level,
				    ppbBuffer,
				    MAXPREFERREDLENGTH,
				    (LPDWORD)pcEntriesRead,
				    &cTotalAvail,
				    NULL );

    return err;

}   // MNetWkstaUserEnum


APIERR MNetWkstaUserGetInfo(
	const TCHAR FAR	 * pszReserved,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    APIERR err;

    err = (APIERR)NetWkstaUserGetInfo( (TCHAR *)pszReserved,
    				   Level,
				   ppbBuffer );

    return err;

}   // MNetWkstaUserGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\puser.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    puser.c
    mapping layer for NetUser API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
   JonN     27-May-1992    Removed ANSI<->UNICODE hack

*/

#include "pchmn32.h"

APIERR MNetUserAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUserAdd( (TCHAR *)pszServer,
    			       Level,
			       pbBuffer,
			       NULL );

}   // MNetUserAdd


APIERR MNetUserDel(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName )
{
    return (APIERR)NetUserDel( (TCHAR *)pszServer,
    			       pszUserName );

}   // MNetUserDel


APIERR MNetUserEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	UINT		   Filter,
	BYTE FAR	** ppbBuffer,
        ULONG              ulMaxPreferred,
	UINT FAR	 * pcEntriesRead,
        UINT FAR         * pcTotalEntries,
        VOID FAR         * pResumeKey )
{

    return (APIERR)NetUserEnum( (TCHAR *)pszServer,
    		                Level,
                                Filter,
				ppbBuffer,
				ulMaxPreferred,
				pcEntriesRead,
				pcTotalEntries,
				pResumeKey );

}   // MNetUserEnum


APIERR MNetUserGetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUserGetInfo( (TCHAR *)pszServer,
    				   pszUserName,
				   Level,
				   ppbBuffer );

}   // MNetUserGetInfo


APIERR MNetUserSetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	UINT	        Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetUserSetInfo( (TCHAR *)pszServer,
				   pszUserName,
				   Level,
				   pbBuffer,
				   NULL );

}   // MNetUserSetInfo


APIERR MNetUserPasswordSet(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszOldPassword,
	TCHAR FAR	 * pszNewPassword )
{
    return ERROR_NOT_SUPPORTED;		// WE REALLY NEED THIS ONE!

}   // MNetUserPasswordSet


APIERR MNetUserGetGroups(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetUserGetGroups( (TCHAR *)pszServer,
    				     (TCHAR *)pszUserName,
				     Level,
				     ppbBuffer,
				     MAXPREFERREDLENGTH,
				     pcEntriesRead,
				     &cTotalAvail );

}   // MNetUserGetGroups


APIERR MNetUserSetGroups(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   cEntries )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUserSetGroups( (TCHAR *)pszServer,
				     (TCHAR *)pszUserName,
				     Level,
				     pbBuffer,
				     cEntries );

}   // MNetUserSetGroups


APIERR MNetUserModalsGet(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUserModalsGet( (TCHAR *)pszServer,
    				     Level,
				     ppbBuffer );

}   // MNetUserModalsGet


APIERR MNetUserModalsSet(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetUserModalsSet( (TCHAR *)pszServer,
				     Level,
				     pbBuffer,
				     NULL );
}   // MNetUserModalsSet


#if 0

APIERR MNetUserValidate(
	TCHAR FAR	 * pszReserved1,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT		   Reserved2 )
{
    UNREFERENCED( Reserved2 );

    return (APIERR)NetUserValidate( pszReserved1,
    				    Level,
				    ppbBuffer );

}   // MNetUserValidate

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\puse.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    puse.c
    mapping layer for NetUse API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetUseAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUseAdd( (TCHAR *)pszServer,
    			      Level,
			      pbBuffer,
			      NULL );

}   // MNetUseAdd


APIERR MNetUseDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDeviceName,
	UINT		   Force )
{
    return (APIERR)NetUseDel( (TCHAR *)pszServer,
    			      (TCHAR *)pszDeviceName,
			      Force );

}   // MNetUseDel


APIERR MNetUseEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetUseEnum( (TCHAR *)pszServer,
    			       Level,
			       ppbBuffer,
			       MAXPREFERREDLENGTH,
			       (LPDWORD)pcEntriesRead,
			       &cTotalAvail,
			       NULL );

}   // MNetUseEnum


APIERR MNetUseGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUseName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUseGetInfo( (TCHAR *)pszServer,
    				  (TCHAR *)pszUseName,
				  Level,
				  ppbBuffer );

}   // MNetUseGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pstatist.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pstatist.c
    mapping layer for NetStatistic API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetStatisticsClear(
	const TCHAR FAR	 * pszServer )
{
    UNREFERENCED( pszServer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetStatisticsClear


APIERR MNetStatisticsGet(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	ULONG	 	   ulReserved,
	UINT		   Level,
	ULONG		   flOptions,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszService );
    UNREFERENCED( ulReserved );
    UNREFERENCED( Level );
    UNREFERENCED( flOptions );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetStatisticsGet

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\pch\prepl.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    prepl.c
    mapping layer for NetReplXxx API.

    FILE HISTORY:
        KeithMo         25-Feb-1992     Created.

*/

#include "pchmn32.h"
#pragma hdrstop

//
//  If the following symbol is #defined, then no actual
//  replicator APIs will be referenced.  Everything will
//  be faked better than Meg Ryan in "When Harry Met Sally".
//

// #define FAKE_REPLICATOR_API


#ifdef FAKE_REPLICATOR_API
REPL_INFO_0 FakeReplInfo0 =
            {
                REPL_ROLE_BOTH,
                SZ("D:\\REPL\\EXPORT"),
                SZ("NTPROJECT"),
                SZ("D:\\REPL\\IMPORT"),
                SZ("NTPROJECT"),
                SZ("LogonUser"),
                0,
                0,
                0,
                0
            };

REPL_EDIR_INFO_2 FakeReplEdirInfo2 =
                 {
                     SZ("EXPORTED"),
                     REPL_INTEGRITY_TREE,
                     REPL_EXTENT_TREE,
                     0,
                     0
                 };

REPL_IDIR_INFO_1 FakeReplIdirInfo1 =
                 {
                     SZ("IMPORTED"),
                     REPL_STATE_OK,
                     SZ("MyMaster"),
                     0,
                     0,
                     0
                 };
#endif



APIERR MNetReplGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    REPL_INFO_0 * pInfo;

    *ppbBuffer = MNetApiBufferAlloc( sizeof(REPL_INFO_0) );

    if( *ppbBuffer == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pInfo = (REPL_INFO_0 * )*ppbBuffer;

    pInfo->rp0_role             = FakeReplInfo0.rp0_role;
    pInfo->rp0_exportpath       = FakeReplInfo0.rp0_exportpath;
    pInfo->rp0_exportlist       = FakeReplInfo0.rp0_exportlist;
    pInfo->rp0_importpath       = FakeReplInfo0.rp0_importpath;
    pInfo->rp0_importlist       = FakeReplInfo0.rp0_importlist;
    pInfo->rp0_logonusername    = FakeReplInfo0.rp0_logonusername;
    pInfo->rp0_interval         = FakeReplInfo0.rp0_interval;
    pInfo->rp0_pulse            = FakeReplInfo0.rp0_pulse;
    pInfo->rp0_guardtime        = FakeReplInfo0.rp0_guardtime;
    pInfo->rp0_random           = FakeReplInfo0.rp0_random;

    return NERR_Success;
#else
    return (APIERR)NetReplGetInfo( (LPTSTR)pszServer,
                                   (DWORD)Level,
                                   (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplGetInfo


APIERR MNetReplSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplSetInfo( (LPTSTR)pszServer,
                                   (DWORD)Level,
                                   (LPBYTE)pbBuffer,
                                   NULL );
#endif

}   // MNetReplSetInfo


APIERR MNetReplExportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirAdd( (LPTSTR)pszServer,
                                        (DWORD)Level,
                                        (LPBYTE)pbBuffer,
                                        NULL );
#endif

}   // MNetReplExportDirAdd


APIERR MNetReplExportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirDel( (LPTSTR)pszServer,
                                        (LPTSTR)pszDirectory );
#endif

}   // MNetReplExportDirDel


APIERR MNetReplExportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#ifdef FAKE_REPLICATOR_API
    *ppbBuffer = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;
#else
    DWORD cTotalAvailable;

    return (APIERR)NetReplExportDirEnum( (LPTSTR)pszServer,
                                         (DWORD)Level,
                                         (LPBYTE *)ppbBuffer,
                                         MAXPREFERREDLENGTH,
                                         (LPDWORD)pcEntriesRead,
                                         &cTotalAvailable,
                                         NULL );
#endif

}   // MNetReplExportDirEnum


APIERR MNetReplExportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirGetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplExportDirGetInfo


APIERR MNetReplExportDirSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirSetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE)pbBuffer,
                                            NULL );
#endif

}   // MNetReplExportDirSetInfo


APIERR MNetReplExportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirLock( (LPTSTR)pszServer,
                                         (LPTSTR)pszDirectory );
#endif

}   // MNetReplExportDirLock


APIERR MNetReplExportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirUnlock( (LPTSTR)pszServer,
                                           (LPTSTR)pszDirectory,
                                           (DWORD)Force );
#endif

}   // MNetReplExportDirUnlock


APIERR MNetReplImportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirAdd( (LPTSTR)pszServer,
                                        (DWORD)Level,
                                        (LPBYTE)pbBuffer,
                                        NULL );
#endif

}   // MNetReplImportDirAdd


APIERR MNetReplImportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirDel( (LPTSTR)pszServer,
                                        (LPTSTR)pszDirectory );
#endif

}   // MNetReplImportDirDel


APIERR MNetReplImportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#ifdef FAKE_REPLICATOR_API
    *ppbBuffer = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;
#else
    DWORD cTotalAvailable;

    return (APIERR)NetReplImportDirEnum( (LPTSTR)pszServer,
                                         (DWORD)Level,
                                         (LPBYTE *)ppbBuffer,
                                         MAXPREFERREDLENGTH,
                                         (LPDWORD)pcEntriesRead,
                                         &cTotalAvailable,
                                         NULL );
#endif

}   // MNetReplImportDirEnum


APIERR MNetReplImportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirGetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplImportDirGetInfo


APIERR MNetReplImportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirLock( (LPTSTR)pszServer,
                                         (LPTSTR)pszDirectory );
#endif

}   // MNetReplImportDirLock


APIERR MNetReplImportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirUnlock( (LPTSTR)pszServer,
                                           (LPTSTR)pszDirectory,
                                           (DWORD)Force );
#endif

}   // MNetReplImportDirUnlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\test\test.c ===
#include <nt.h>
#include <ntrtl.h>
#include <rpc.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <stdio.h>

#include <msamqdi.h>


char * MapUnicodeToAnsiPoorly( PUNICODE_STRING punicode );


int main( int cArgs, char * pArgs[] )
{
    NTSTATUS err;
    ULONG    cbTotalAvailable;
    ULONG    cbTotalReturned;
    ULONG    cReturnedEntries;
    PVOID    pBuffer;
	
    err = SamQueryDisplayInformation( NULL,
				      ( cArgs > 1 )
				          ? DomainDisplayUser
				          : DomainDisplayMachine,
				      0L,
				      65535L,
				      &cbTotalAvailable,
				      &cbTotalReturned,
				      &cReturnedEntries,
				      &pBuffer );

    if( err != 0 )
    {
	fprintf( stderr,
		 "SamQueryDisplayInformation returned %lu (%08lX)\n",
		 (ULONG)err,
		 (ULONG)err );

	return 1;
    }

    printf( "%lu bytes available\n", cbTotalAvailable );
    printf( "%lu bytes returned\n", cbTotalReturned );
    printf( "%lu entries returned\n", cReturnedEntries );
    printf( "\n" );
	
    if( cArgs > 1 )
    {
	DOMAIN_DISPLAY_USER * pddu = (DOMAIN_DISPLAY_USER *)pBuffer;
	
	while( cReturnedEntries-- )
	{
	    printf( "Index          = %lu\n",
		    pddu->Index );
		    
	    printf( "Rid            = %lu\n",
		    pddu->Rid );
		    
	    printf( "AccountControl = %lu\n",
		    pddu->AccountControl );
		    
	    printf( "LogonName      = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->LogonName ) );
		    
	    printf( "AdminComment   = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->AdminComment ) );

	    printf( "FullName       = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->FullName ) );
		    
	    printf( "\n" );

	    pddu++;
	}
    }
    else
    {
	DOMAIN_DISPLAY_MACHINE * pddm = (DOMAIN_DISPLAY_MACHINE *)pBuffer;

	while( cReturnedEntries-- )
	{
	    printf( "Index          = %lu\n",
		    pddm->Index );
		    
	    printf( "Rid            = %lu\n",
		    pddm->Rid );
		    
	    printf( "AccountControl = %lu\n",
		    pddm->AccountControl );
		    
	    printf( "Machine        = %s\n",
		    MapUnicodeToAnsiPoorly( &pddm->Machine ) );
		    
	    printf( "Comment        = %s\n",
		    MapUnicodeToAnsiPoorly( &pddm->Comment ) );
		    
	    printf( "\n" );

	    pddm++;
	}
    }
    
    return 0;
    
}   // main


char * MapUnicodeToAnsiPoorly( PUNICODE_STRING punicode )
{
    char        * psz = (char *)punicode->Buffer;
    WCHAR	* pwc = punicode->Buffer;
    USHORT	  cb  = punicode->Length;

    if( cb == 0 )
    {
	return "";
    }

    while( ( cb > 0 ) && ( *pwc != L'\0' ) )
    {
	*psz++ = (char)*pwc++;
	cb -= sizeof(WCHAR);
    }
    
    *psz = '\0';

    return (char *)punicode->Buffer;
	
}   // MapUnicodeToAnsiPoorly


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\mnet32\netslow\pshare.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pshare.c
    mapping layer for NetShare API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	JonN		21-Oct-1991	Disabled NetShareCheck for now
        Yi-HsinS        20-Nov-1992	Added MNetShareDelSticky and
					MNetShareEnumSticky

*/

#include "pchmn32.h"

APIERR MNetShareAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetShareAdd( (TCHAR *)pszServer,
				Level,
				pbBuffer,
				NULL );

}   // MNetShareAdd



APIERR MNetShareCheck(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDeviceName,
	UINT FAR	 * pType )
{
    return (APIERR)NetShareCheck( (TCHAR *)pszServer,
				  (TCHAR *)pszDeviceName,
				  (LPDWORD) pType );

}   // MNetShareCheck


APIERR MNetShareDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Reserved )
{
    return (APIERR)NetShareDel( (TCHAR *)pszServer,
				(TCHAR *)pszNetName,
				Reserved );

}   // MNetShareDel

APIERR MNetShareDelSticky(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Reserved )
{
    return (APIERR)NetShareDelSticky( (TCHAR *)pszServer,
				      (TCHAR *)pszNetName,
				      Reserved );

}   // MNetShareDelSticky

APIERR MNetShareEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetShareEnum( (TCHAR *)pszServer,
				 Level,
				 ppbBuffer,
				 MAXPREFERREDLENGTH,
				 (LPDWORD)pcEntriesRead,
				 &cTotalAvail,
				 NULL );

}   // MNetShareEnum

APIERR MNetShareEnumSticky(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetShareEnumSticky( (TCHAR *)pszServer,
				 Level,
				 ppbBuffer,
				 MAXPREFERREDLENGTH,
				 (LPDWORD)pcEntriesRead,
				 &cTotalAvail,
				 NULL );

}   // MNetShareEnumSticky

APIERR MNetShareGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetShareGetInfo( (TCHAR *)pszServer,
    				    (TCHAR *)pszNetName,
				    Level,
				    ppbBuffer );

}   // MNetShareGetInfo


APIERR MNetShareSetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    // mapping layer does not do  this right now, since UI never uses it.
    if( ParmNum != PARMNUM_ALL )	
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetShareSetInfo( (TCHAR *)pszServer,
    				    (TCHAR *)pszNetName,
				    Level,
				    pbBuffer,
				    NULL );

}   // MNetShareSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\global.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/29/90  split from profile.cxx
 *  01/27/91  updated to remove CFGFILE
 */

#ifdef CODESPEC
/*START CODESPEC*/

/*********
GLOBAL.CXX
*********/

/****************************************************************************

    MODULE: Global.cxx

    PURPOSE: Global structures for the profile primitives

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

/*************
end GLOBAL.CXX
*************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */

PRFHEAP_HANDLE hGlobalHeap;

const char  ::chPathSeparator = TCH('\\');
const char  ::chUnderscore    = TCH('_');



/* internal manifests */


/* functions: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\initfree.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  01/27/91  created while removing CFGFILE
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
INITFREE.CXX
***********/

/****************************************************************************

    MODULE: InitFree.cxx

    PURPOSE: Initializes and frees user profile module

    FUNCTIONS:

	see uiprof.h

    COMMENTS:

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */



/*START CODESPEC*/

/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileInit(
	)
/*END CODESPEC*/
{
    if (!(hGlobalHeap.Init()))
	return ERROR_NOT_ENOUGH_MEMORY;

    return NO_ERROR;
}


/*START CODESPEC*/

/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileFree(
	)
/*END CODESPEC*/
{
    if (!(hGlobalHeap.IsNull()))
	hGlobalHeap.Free();

    return NO_ERROR;
}
/*START CODESPEC*/

/***************
end INITFREE.CXX
***************/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\general.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/14/90  created
 *  01/27/91  removed CFGFILE
 *  02/02/91  removed fLocal flag
 *  05/09/91  All input now canonicalized
 *  11/08/91  terryk WIN32 conversion
 */

#ifdef CODESPEC
/*START CODESPEC*/

/**********
GENERAL.CXX
**********/

/****************************************************************************

    MODULE: General.cxx

    PURPOSE: Internal subroutines for profile file manipulation

    FUNCTIONS:

        CanonUsername
        CanonDeviceName
        CanonRemoteName
        BuildProfileFilePath
        UnbuildProfileEntry

    COMMENTS:

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"         /* headers and internal routines */

extern "C" {
#include "uilmini.h"              /* LMI_PARM values */
}



/* internal manifests */



/* internal global strings */
char  szGlobalUsername[UNLEN+1] = SZ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0");
BOOL  fGlobalNameLoaded = FALSE;

const char ::szLocalFile[]  =  PROFILE_DEFAULTFILE;
#define LEN_szLocalFile (sizeof(::szLocalFile)-1)

// CODEWORK should not be using strtokf()
static char szDelimiters[] = SZ("(,)"); // delimiters for use in strtokf()




/* functions: */


// associates cpszUsername with cached profile
VOID StoreUsername(CPSZ cpszCanonUsername)
{
    ::fGlobalNameLoaded = TRUE;

    if ((cpszCanonUsername == NULL) || (cpszCanonUsername[0] == TCH('\0')))
    {
        ::szGlobalUsername[0] = TCH('\0');
    }
    else
    {
        strcpyf(::szGlobalUsername, (PCH)cpszCanonUsername);
    }
}


// confirms cpszUsername matches username associated with cached profile
BOOL ConfirmUsername(CPSZ cpszUsername)
{
    if (!::fGlobalNameLoaded)
        return FALSE;

    if ((cpszUsername == NULL) || (cpszUsername[0] == TCH('\0')))
        return ( ::szGlobalUsername[0] == TCH('\0') );

    char szCanonUsername[UNLEN+1];

    if ( NO_ERROR != CanonUsername( cpszUsername,
                (PSZ)szCanonUsername, sizeof(szCanonUsername) ) )
    {
        return FALSE;
    }

    return !strcmpf( ::szGlobalUsername, szCanonUsername );
}


/*START CODESPEC*/
// validate/canonicalize cpszUsername
//
// error returns NERR_BadUsername
USHORT CanonUsername(
    CPSZ   cpszUsername,
    PSZ    pszCanonBuffer,
    USHORT usCanonBufferSize
    )
/*END CODESPEC*/
{
    if ((cpszUsername == NULL)
        || ::I_MNetNameCanonicalize(NULL,cpszUsername,
            pszCanonBuffer,usCanonBufferSize,NAMETYPE_USER,0L))
    {
        return NERR_BadUsername;
    }

    return NO_ERROR;
}


/*START CODESPEC*/
// validate/canonicalize cpszDeviceName
//
// error returns NERR_InvalidDevice
//
// a call to I_NetPathType is contained in I_NetPathCanonicalize
//
USHORT CanonDeviceName(
    CPSZ   cpszDeviceName,
    PSZ    pszCanonBuffer,
    USHORT usCanonBufferSize
    )
/*END CODESPEC*/
{
    ULONG flPathType = 0;

    if ((cpszDeviceName == NULL)
        || ::I_MNetPathCanonicalize(NULL,cpszDeviceName,
                pszCanonBuffer,usCanonBufferSize,(CPSZ)NULL,&flPathType,0L)
        || (!(flPathType & ITYPE_DEVICE)))
    {
        return NERR_InvalidDevice;
    }

    return NO_ERROR;
}


/*START CODESPEC*/
// validate/canonicalize cpszRemoteName
//
// error returns ERROR_BAD_NET_NAME
//
// Will accept \\a\b and \\a\b\c\d\e
//
// Will eventually be different between LM21 and LM30
//
// a call to I_NetPathType is contained in I_NetPathCanonicalize
//
USHORT CanonRemoteName(
    CPSZ   cpszRemoteName,
    PSZ    pszCanonBuffer,
    USHORT usCanonBufferSize
    )
/*END CODESPEC*/
{
    ULONG flPathType = 0;

    if (cpszRemoteName == NULL)
        return ERROR_BAD_NET_NAME;

    // is it an alias name?
    if ( NO_ERROR == ::I_MNetNameCanonicalize( NULL, cpszRemoteName,
                pszCanonBuffer, usCanonBufferSize,
                NAMETYPE_SHARE, 0L ) )
        return NO_ERROR;

    // is it a UNC resource?
    if (( NO_ERROR == ::I_MNetPathCanonicalize(NULL,cpszRemoteName,
                pszCanonBuffer,usCanonBufferSize,(CPSZ)NULL,&flPathType,0L))
        && ( flPathType == ITYPE_UNC ))
    {
        return NO_ERROR;
    }

    return ERROR_BAD_NET_NAME;
}


/*START CODESPEC*/
// returns complete path of the file in pszPathBuffer
// cpszLanroot may be absolute or relative
//
// The filename will be <cpszHomedir>\<PROFILE_DEFAULTFILE>
//
// error returns ERROR_INSUFFICIENT_BUFFER
// error returns ERROR_BAD_NETPATH
//
USHORT BuildProfileFilePath(
    CPSZ   cpszLanroot,
    PSZ    pszPathBuffer,
    USHORT usPathBufferSize
    )
/*END CODESPEC*/
{
    USHORT usError;
    ULONG  flPathType = 0;
    int    icCanonHomedirPathLen;

    /* validate/canonicalize cpszLanroot */
    usError = ::I_MNetPathCanonicalize(NULL,cpszLanroot,
            pszPathBuffer,usPathBufferSize,
            NULL,&flPathType,0x0);
    if (usError)
        return ERROR_BAD_NETPATH;

    icCanonHomedirPathLen = strlenf((char *)pszPathBuffer);

    /* form pathname from cpszLanroot and ::szLocalFile */
    if (        icCanonHomedirPathLen
                +1   // path separator
                +LEN_szLocalFile
                + 1  // include null terminator
            > usPathBufferSize)
        return ERROR_INSUFFICIENT_BUFFER;
    pszPathBuffer += icCanonHomedirPathLen;
    *(pszPathBuffer++) = ::chPathSeparator;
    strcpyf((char *)pszPathBuffer,::szLocalFile);

    return NO_ERROR;
}



/*START CODESPEC*/
//
// UnbuildProfileEntry converts
//   cpszValue == "\\\\server\\share(S,?) into
//   pszBuffer == "\\\\server\\share", *psAsgType == USE_SPOOLDEV,
//   and *pusResType == DEFAULT_RESTYPE (see profilei.hxx).
//
// UnbuildProfileEntry always sets *psAsgType to DEFAULT_ASGTYPE or
// *pusResType to DEFAULT_RESTYPE (see profilei.hxx for the value of
// these manifests) when it does not find or recognize the AsgType
// and/or ResType tokens in cpszValue.
//
// error returns ERROR_BAD_NET_NAME
//
USHORT UnbuildProfileEntry(
    PSZ     pszBuffer,
    USHORT  usBufferSize,
    short * psAsgType,
    unsigned short *pusResType,
    CPSZ    cpszValue
    )
/*END CODESPEC*/
{
    char szTemp[30]; // plenty long enough for the trailer, really 4 would do
    char szRemoteName[RMLEN+1]; // non-canonicalized remote name
                // RMLEN assumed longer than aliasname length
                // will have to be longer for LM30


    pszBuffer[0] = TCH('\0');
    if (psAsgType)
        *psAsgType = DEFAULT_ASGTYPE;
    if (pusResType)
        *pusResType = DEFAULT_RESTYPE;

    char *pTrailer = strrchrf((char *)cpszValue,TCH('(')); // CODEWORK character
    int cbStrLen;
    if (pTrailer == NULL)
        cbStrLen = strlenf(cpszValue)-2; // strip trailing /r/n
    else
        cbStrLen = (USHORT) (pTrailer - (char *)cpszValue);

    if ( (cbStrLen <= 0) || (cbStrLen+1 > sizeof(szRemoteName)) )
        return ERROR_BAD_NET_NAME;
    strncpyf(szRemoteName,(char *)cpszValue,cbStrLen);
    szRemoteName[cbStrLen] = TCH('\0');

    APIERR err = CanonRemoteName(szRemoteName,
            (char *)pszBuffer,usBufferSize);
    if ( err != NO_ERROR )
        return ERROR_BAD_NET_NAME;

    if ( pTrailer == NULL )
        return NO_ERROR;

    pTrailer++;

    if (strlenf(pTrailer)+1 > sizeof(szTemp))
        return NO_ERROR;
    strcpyf(szTemp, pTrailer);

    char *pToken = strtokf(szTemp,szDelimiters);
    if (pToken == NULL)
        return NO_ERROR;
    if (psAsgType)
        *psAsgType = DoUnMapAsgType(*pToken);

    pToken = strtokf(NULL,szDelimiters);
    if (pToken == NULL)
        return NO_ERROR;
    if (pusResType)
        *pusResType = DoUnMapResType(*pToken);

    return NO_ERROR;
}


#ifdef CODESPEC
/*START CODESPEC*/

short DoUnMapAsgType(TCHAR cSearch);
TCHAR  DoMapAsgType(short sSearch);

These internal routines convert between short and char according to
the specified mapping table.  They are used by UnbuildProfileEntry()
to convert between the values of ui1_asg_type and the characters which
are stored in the user profile to represent those values.

/*END CODESPEC*/
#endif // CODESPEC


/*
 * for use by UserProfile APIs
 */

// BUGBUG Cannot be completed until use_info_2 struct finalized

short DoUnMapAsgType(TCHAR cSearch)
{
    switch (cSearch)
    {
    case ASG_WILDCARD_CHAR: return USE_WILDCARD;
    case ASG_DISKDEV_CHAR:  return USE_DISKDEV;
    case ASG_SPOOLDEV_CHAR: return USE_SPOOLDEV;
    case ASG_CHARDEV_CHAR:  return USE_CHARDEV;
    case ASG_IPC_CHAR:      return USE_IPC;
    }

    return DEFAULT_ASGTYPE;
}

TCHAR DoMapAsgType(short sSearch)
{
    switch (sSearch)
    {
    case USE_WILDCARD: return ASG_WILDCARD_CHAR;
    case USE_DISKDEV:  return ASG_DISKDEV_CHAR;
    case USE_SPOOLDEV: return ASG_SPOOLDEV_CHAR;
    case USE_CHARDEV:  return ASG_CHARDEV_CHAR;
    case USE_IPC:      return ASG_IPC_CHAR;
    }

    return DEFAULT_ASG_RES_CHAR;
}

unsigned short DoUnMapResType(TCHAR cSearch)
{
    (void) cSearch;
    return DEFAULT_RESTYPE;
}

TCHAR DoMapResType(unsigned short usSearch)
{
    (void) usSearch;
    return DEFAULT_ASG_RES_CHAR;
}



/*
 * for use by UserPreference APIs
 */

/*
 * the KeyValue function maps a KEY as defined in UIPROF.H to the
 * string defined in LMINI.H. Returns NULL if it is unknown to us.
 * This function is only used in this module.
 */

/*
 * BUGBUG This is only for temporary use.  LM30 will use a completely
 * different mechanism to store these values.
 */
TCHAR *KeyValue( USHORT usKey )
{
    switch (usKey)
    {
    case USERPREF_AUTOLOGON :
        return(LMI_PARM_N_AUTOLOGON) ;

    case USERPREF_AUTORESTORE :
        return(LMI_PARM_N_AUTORESTORE) ;

    case USERPREF_SAVECONNECTIONS :
        return(LMI_PARM_N_SAVECONNECTIONS) ;

    case USERPREF_USERNAME :
        return(LMI_PARM_N_USERNAME) ;

    case USERPREF_CONFIRMATION :
        return(SZ("confirmation")) ;

    case USERPREF_ADMINMENUS :
        return(SZ("adminmenus")) ;

    default:
        return(NULL) ;  // if cannot find, return NULL
    }
}


/*START CODESPEC*/

/**************
end GENERAL.CXX
**************/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\enum.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/03/90  split from profile.cxx
 */

#ifdef CODESPEC
/*START CODESPEC*/

/*******
ENUM.CXX
*******/

/****************************************************************************

    MODULE: Enum.cxx

    PURPOSE: Lists all connections from the cached profile

    FUNCTIONS:

	see uiprof.h

    COMMENTS:

BUGBUG Should use NNSTR when this becomes available

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */


/*START CODESPEC*/
/*
 * Returns a list of all devices with connections in the cached profile;
 * devicenames in this list will be separated by null characters, with two
 * null characters at the end.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * ERROR_INSUFFICIENT_BUFFER
 *
 */
USHORT UserProfileEnum(
	CPSZ  cpszUsername,
	PSZ   pszBuffer,     // returns NULL-NULL list of device names
	USHORT usBufferSize  // length of above buffer
	)
/*END CODESPEC*/
{
    if (!ConfirmUsername(cpszUsername))
	return ERROR_GEN_FAILURE;

    return ::hGlobalHeap.Enum(pszBuffer, usBufferSize);
}
/*START CODESPEC*/

/***********
end ENUM.CXX
***********/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\nthack.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/


/*
 *  FILE STATUS:
 *  10/30/91  created
 *  06-Apr-1992 beng Unicode pass (nuke CPSZ, PSZ)
 */

/*********
NTHACK.CXX
*********/

/****************************************************************************

    MODULE: NTHack.cxx

    PURPOSE: Stubs out all profile functionality

    FUNCTIONS:

        see uiprof.h

    COMMENTS:

****************************************************************************/


#include "profilei.hxx"         /* headers and internal routines */


/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileInit(
        )
{
    return NO_ERROR;
}


/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileFree(
        )
{
    return NO_ERROR;
}


/*
 * Returns information about one connection in the cached profile.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * NERR_UseNotFound
 *
 *      see \\iceberg2\lm30spec\src\docs\funcspec\lm30dfs.doc for
 *      details on the new use_info_2 data structure for LM30
 */
USHORT UserProfileQuery(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        TCHAR *    pszBuffer,    // returns UNC, alias or domain name
        USHORT usBufferSize, // length of above buffer
        short *psAsgType,    // *psAsgType set to asg_type; ignored if NULL
        unsigned short *pusResType   // *pusResType set to res_type; ignored if NULL
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszDeviceName );
    UNREFERENCED( pszBuffer );
    UNREFERENCED( usBufferSize );
    UNREFERENCED( psAsgType );
    UNREFERENCED( pusResType );
    return NERR_UseNotFound;
}


/*
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * ERROR_NOT_ENOUGH_MEMORY
 */
/*
 * UserProfileQuery does not canonicalize pszCanonRemoteName, the caller
 * is expected to already have done so.
 *
 * The user is expected to ensure that usResType corresponds to
 * the type of the remote resource, and that device pszDeviceName
 * can be connected to a resource of that type.
 */
USHORT UserProfileSet(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        const TCHAR *   pszRemoteName,
        short  sAsgType,     // as ui2_asg_type
        unsigned short usResType     // as ui2_res_type
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszDeviceName );
    UNREFERENCED( pszRemoteName );
    UNREFERENCED( sAsgType );
    UNREFERENCED( usResType );
    return NO_ERROR;
}


/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_FILE_NOT_FOUND
 */
USHORT UserProfileRead(
        const TCHAR *  pszUsername, // uncache cached profile if this is NULL
        const TCHAR *  pszHomedir
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszHomedir );
    return NO_ERROR;
}


/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_WRITE_FAULT
 */
USHORT UserProfileWrite(
        const TCHAR *   pszUsername,
        const TCHAR *   pszHomedir
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszHomedir );
    return NO_ERROR;
}


/*
 * Returns a list of all devices with connections in the cached profile;
 * devicenames in this list will be separated by null characters, with two
 * null characters at the end.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * ERROR_INSUFFICIENT_BUFFER
 *
 */
USHORT UserProfileEnum(
        const TCHAR *  pszUsername,
        TCHAR *   pszBuffer,     // returns NULL-NULL list of device names
        USHORT usBufferSize  // length of above buffer
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszBuffer );
    UNREFERENCED( usBufferSize );
    if ( usBufferSize < 2*sizeof(TCHAR) )
        return ERROR_INSUFFICIENT_BUFFER;

    pszBuffer[0] = TCH('\0');
    pszBuffer[1] = TCH('\0');

    return NO_ERROR;
}


/*******************************************************************

    NAME:       UserPreferenceQuery

    SYNOPSIS:   Queries a saved user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to buffer to receive string
                cbLen    - size of buffer

    EXIT:       if NERR_Success, pchValue will contain value in
                LAMMAN.INI corresponding to the key.
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM or NERR_BufTooSmall.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQuery( USHORT     usKey,
                            TCHAR FAR * pchValue,
                            USHORT     cbLen)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pchValue );
    UNREFERENCED( cbLen );
    return NERR_CfgCompNotFound;

}


/*******************************************************************

    NAME:       UserPreferenceSet

    SYNOPSIS:   Saves a user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to null terminated string
                            containing value to be saved.

    EXIT:       if NERR_Success, the value in LAMMAN.INI corresponding
                to the key will be the string pointed to by pchValue.

                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSet( USHORT     usKey,
                          TCHAR FAR * pchValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pchValue );
    return NO_ERROR;
}


/*******************************************************************

    NAME:       UserPreferenceQueryBool

    SYNOPSIS:   Queries a boolean user preference

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pfValue  - pointer to BOOL that will receive value

    EXIT:       if NERR_Success, pfValue will contain TRUE if
                the value in LAMMAN.INI corresponding to the key
                is "YES" or "yes", and FALSE if "NO" or "no".
                If neither, we assume the user made an error since the
                value stored was not YES/NO.

                Also returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQueryBool( USHORT     usKey,
                                BOOL FAR * pfValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pfValue );
    return NERR_CfgCompNotFound;
}

/*******************************************************************

    NAME:       UserPreferenceSetBool

    SYNOPSIS:   Sets a user boolean preference flag

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - TRUE or FALSE, the value to be saved

    EXIT:       if NERR_Success, the LAMMAN.INI value corresponding to
                the key will be set to "yes" or "no".
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSetBool( USHORT     usKey,
                              BOOL       fValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( fValue );
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\fileheap.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE HISTORY:
 *  01/25/91  created
 *  05/09/91  All input now canonicalized
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
FILEHEAP.CXX
***********/

/****************************************************************************

    MODULE: FileHeap.cxx

    PURPOSE: PROFILE_FILE and PRFHEAP_HANDLE primitives

    FUNCTIONS:

    COMMENTS:

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC


#define PROFILE_HEAP_SIZE 2048
#define MAX_PROFILE_LINE   256


#include "profilei.hxx"		/* headers and internal routines */

extern "C" {
    #include <errno.h>
    #include <stdio.h>
}

#include "uibuffer.hxx"
#include "uisys.hxx"            /* File APIs */



/* global data structures: */



/* internal manifests */



/* functions: */


/**********************************************************\

   NAME:       PROFILE_FILE::OpenRead

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PROFILE_FILE::OpenRead(const char *filename)
{
    return FileOpenRead(&_ulFile, (CPSZ)filename);
}

/**********************************************************\

   NAME:       PROFILE_FILE::OpenWrite

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PROFILE_FILE::OpenWrite(const char *filename)
{
    return FileOpenWrite(&_ulFile, (CPSZ)filename);
}


/**********************************************************\

   NAME:       PROFILE_FILE::Close

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

VOID PROFILE_FILE::Close()
{
    (void) FileClose(_ulFile);
}


/**********************************************************\

   NAME:       PROFILE_FILE::Read

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      NOTE:  Currently, if a line is too long, the remainder of the line
         will be read as the next line.  Also, the end-of-line termination
         is not stripped off.  Will return ERROR_INSUFFICIENT_BUFFER to
         indicate EOF as well as a line longer than nBufferLen.

   HISTORY:
   01/25/91  created

\**********************************************************/

BOOL PROFILE_FILE::Read(char *pBuffer, int nBufferLen)
{
    return ( NO_ERROR == 
	   FileReadLine( _ulFile, (PSZ)pBuffer, (USHORT)nBufferLen ) );
}


/**********************************************************\

   NAME:       PROFILE_FILE::Write

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      NOTE:  Write assumes that the end-of-line termination is still
      present.

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PROFILE_FILE::Write(char *pString)
{
    return FileWriteLine( _ulFile, (CPSZ)pString );
}




/**********************************************************\

   NAME:       PRFELEMENT::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created
   05/09/91  All input now canonicalized

\**********************************************************/

VOID PRFELEMENT::Init()
{
    _szCanonDeviceName[0] = TCH('\0');
    _elhCanonRemoteName.Init();
    _sAsgType = DEFAULT_ASGTYPE;
    _usResType = DEFAULT_RESTYPE;
}


BOOL PRFELEMENT::Init(
	PRFHEAP_HANDLE& heap,
	char *pCanonDeviceName,
	char *pCanonRemoteName,
	short sAsgType,
	unsigned short usResType
	)
{
    if (!_elhCanonRemoteName.Init(heap._localheap, strlenf(pCanonRemoteName)+1))
	return FALSE;

    char *pNewRemoteName = _elhCanonRemoteName.Lock();

        strcpyf(pNewRemoteName, pCanonRemoteName);

    _elhCanonRemoteName.Unlock();

    strncpyf(_szCanonDeviceName,pCanonDeviceName,DEVLEN+1);
    _szCanonDeviceName[DEVLEN] = TCH('\0');
    _sAsgType = sAsgType;
    _usResType = usResType;
	
    return TRUE;
}


/**********************************************************\

   NAME:       PRFELEMENT::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

VOID PRFELEMENT::Free()
{
    _szCanonDeviceName[0] = TCH('\0');
    if (!(_elhCanonRemoteName.IsNull()))
        _elhCanonRemoteName.Free();
}




/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created
   05/09/91  All input now canonicalized

\**********************************************************/

BOOL PRFHEAP_HANDLE::Init()
{
    PRFELEMENT *pPrfElementList;
    int iElement;

    if (!(_localheap.Init( PROFILE_HEAP_SIZE )))
	return FALSE;

    if (!(_elementlist.Init( this->_localheap, sizeof(PRFELEMENT_LIST)) ))
	return FALSE;

    pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
	return FALSE;

        for (iElement = 0; iElement < PRF_MAX_DEVICES; iElement++)
	{
	    pPrfElementList[iElement].Init();
	}

    _elementlist.Unlock();

    return TRUE;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

VOID PRFHEAP_HANDLE::Free()
{
    Clear();

    _elementlist.Free();

    _localheap.Free();
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Clear

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

VOID PRFHEAP_HANDLE::Clear()
{
    PRFELEMENT *pPrfElementList;
    int iElement;

    pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList != NULL)
    {

        for (iElement = 0; iElement < PRF_MAX_DEVICES; iElement++)
	{
	    pPrfElementList[iElement].Free();
	}

    }

    _elementlist.Unlock();
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Read

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      The parsing simply interprets everything before the first '='
      as the device name, and everything after as the profile entry.
      We ignore the line if it is invalid for any reason.

   HISTORY:
   01/25/91  created
   05/09/91  All input now canonicalized

\**********************************************************/

USHORT PRFHEAP_HANDLE::Read(
	CPSZ  cpszFilename
	)
{
    BUFFER pLineBuf(MAX_PROFILE_LINE);
    USHORT usReturn = NO_ERROR;

    if (pLineBuf.QuerySize() < MAX_PROFILE_LINE)
	return ERROR_NOT_ENOUGH_MEMORY;

    char *pDeviceName = (char *)pLineBuf.QueryPtr();

    Clear();

    PRFELEMENT *pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        PROFILE_FILE profilefile;
        usReturn = profilefile.OpenRead((char *)cpszFilename);
        switch ( usReturn )
	{
	case NO_ERROR:
	    int iElement = 0;
	    while (   profilefile.Read( pDeviceName, MAX_PROFILE_LINE )
		   && usReturn == NO_ERROR
		   && iElement < PRF_MAX_DEVICES
		  )
	    {
		char szCanonDeviceName[DEVLEN+1];
		char szCanonRemoteName[RMLEN+1]; // CODEWORK LM30
	        char *pProfileEntry = strchrf(pDeviceName,TCH('=')); // CODEWORK constant
		// skip entries with null profile entry
	        if ( pProfileEntry == NULL )
	            continue;

	        *pProfileEntry = TCH('\0');
	        pProfileEntry++;

		// skip entries with invalid device name
		if (NO_ERROR != CanonDeviceName(
					pDeviceName,
					(PSZ)szCanonDeviceName,
					sizeof(szCanonDeviceName)
					))
		{
		    continue;
		}

		short sAsgType;
		unsigned short usResType;

		// Translate entry into components
	        if (NO_ERROR != UnbuildProfileEntry(
			(PSZ)szCanonRemoteName, sizeof(szCanonRemoteName),
		        &sAsgType, &usResType, pProfileEntry))
		{
		    continue;
		}

	        if (!((pPrfElementList[iElement++]).Init(
		        *this, (PSZ)szCanonDeviceName, (PSZ)szCanonRemoteName,
			sAsgType, usResType)))
	        {
	            usReturn = ERROR_NOT_ENOUGH_MEMORY;
		    break;
	        }
	    }

            (void) profilefile.Close();
	    break;

	/*
	 * It is not considered an error if the file does not exist.
	 */
	case ERROR_FILE_NOT_FOUND:
	    usReturn = NO_ERROR;
	    break;

	default:
	    break;

	} // switch

    }

    _elementlist.Unlock();

    return usReturn;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Write

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PRFHEAP_HANDLE::Write(
	CPSZ  cpszFilename
	)
{
    PROFILE_FILE profilefile;
    USHORT usReturn = NO_ERROR;

    usReturn = profilefile.OpenWrite((char *)cpszFilename);
    if (usReturn != NO_ERROR)
	return usReturn;

    PRFELEMENT *pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        int iElement;
        for (iElement = 0;
	     (usReturn == NO_ERROR) && (iElement < PRF_MAX_DEVICES);
	     iElement++)
	{
	    if ((pPrfElementList[iElement]._szCanonDeviceName)[0] == TCH('\0'))
		continue;

	    char buf[8];
	    strcpyf( buf, SZ("(_,_)\r\n") ); // CODEWORK char constants
	    buf[1] = DoMapAsgType(pPrfElementList[iElement]._sAsgType);
	    buf[3] = DoMapResType(pPrfElementList[iElement]._usResType);

	    char *pProfileEntry = (pPrfElementList[iElement]._elhCanonRemoteName).Lock();

		if  (
	        	   profilefile.Write(
		        	pPrfElementList[iElement]._szCanonDeviceName)
	        	|| profilefile.Write(SZ("=")) // CODEWORK char constant
	        	|| profilefile.Write(pProfileEntry)
	        	|| profilefile.Write( buf )
		    )
		{
		    usReturn = ERROR_WRITE_FAULT;
		}

	    (pPrfElementList[iElement]._elhCanonRemoteName).Unlock();

	}

    }

    _elementlist.Unlock();

    (void) profilefile.Close();

    return usReturn;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Query

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created
   05/09/91  All input now canonicalized

\**********************************************************/

USHORT PRFHEAP_HANDLE::Query(
	CPSZ   cpszCanonDeviceName,
	PSZ    pszBuffer,      // returns UNC, alias or domain name
	USHORT usBufferSize,   // length of above buffer
	short *psAsgType,      // as ui1_asg_type / ui2_asg_type
                               // ignored if pszDeviceName==NULL
	unsigned short *pusResType     // ignore / as ui2_res_type
                               // ignored if pszDeviceName==NULL
	)
{
    BUFFER pLineBuf(MAX_PROFILE_LINE);
    PRFELEMENT *pPrfElementList;
    int iElement;
    USHORT usReturn = NERR_UseNotFound;
    char *pDeviceName;

    if (pLineBuf.QuerySize() < MAX_PROFILE_LINE)
	return FALSE;

    pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {

        for (iElement = 0;  iElement < PRF_MAX_DEVICES; iElement++)
	{
	    pDeviceName = pPrfElementList[iElement]._szCanonDeviceName;
	    if (pDeviceName[0] == TCH('\0'))
		continue;

	    if (strcmpf(pDeviceName,(char *)cpszCanonDeviceName))
		continue;

	    PSZ pszCanonRemoteName =
		    (PSZ) (pPrfElementList[iElement]._elhCanonRemoteName).Lock();
	    
	        if ( strlenf(pszCanonRemoteName)+1 > usBufferSize )
		    return ERROR_INSUFFICIENT_BUFFER;
		strcpyf( (char *)pszBuffer, pszCanonRemoteName );
		if ( psAsgType != NULL )
		    *psAsgType = pPrfElementList[iElement]._sAsgType;
		if ( pusResType != NULL )
		    *pusResType = pPrfElementList[iElement]._usResType;


	    (pPrfElementList[iElement]._elhCanonRemoteName).Unlock();

	    usReturn = NO_ERROR;
            break;
	}

    }

    _elementlist.Unlock();

    return usReturn;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Enum

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PRFHEAP_HANDLE::Enum(
	PSZ    pszBuffer,       // returns NULL-NULL list of device names
	USHORT usBufferSize     // length of above buffer
	)
{
    PRFELEMENT *pPrfElementList;
    int iElement;
    USHORT usReturn = NO_ERROR;
    char *pDeviceName;
    int nDevnameLength;

    pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {

        for (iElement = 0;
	     (usReturn == NO_ERROR) && (iElement < PRF_MAX_DEVICES);
	     iElement++)
	{
	    pDeviceName = pPrfElementList[iElement]._szCanonDeviceName;
	    if (pDeviceName[0] == TCH('\0'))
		continue;

	    nDevnameLength = strlenf(pDeviceName)+1;
	    if (nDevnameLength > usBufferSize)
	    {
		usReturn = ERROR_INSUFFICIENT_BUFFER;
		break;
	    }

	    strcpyf((char *)pszBuffer, pDeviceName);

	    pszBuffer += nDevnameLength;
	    usBufferSize -= nDevnameLength;

	}

    }

    _elementlist.Unlock();

    if (usBufferSize == 0)
	return ERROR_INSUFFICIENT_BUFFER;
    *pszBuffer = TCH('\0');

    return usReturn;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::Set

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

USHORT PRFHEAP_HANDLE::Set(
	CPSZ   cpszCanonDeviceName,
	CPSZ   cpszCanonRemoteName,
	short  sAsgType,     // as ui2_asg_type
	unsigned short usResType     // as ui2_res_type
	)
{
    USHORT usReturn = NO_ERROR;
    BOOL fFound = FALSE;
    PRFELEMENT *pPrfElementList, *pPrfElement;
    PRFELEMENT *pFreePrfElement = NULL;
    int iElement;

    pPrfElementList = (PRFELEMENT *)_elementlist.Lock();
    if (pPrfElementList == NULL)
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        for (iElement = 0; iElement < PRF_MAX_DEVICES; iElement++)
	{
	    pPrfElement = &(pPrfElementList[iElement]);
	    if ((pPrfElement->_szCanonDeviceName)[0] == TCH('\0'))
	    {
		if (pFreePrfElement == NULL)
		    pFreePrfElement = pPrfElement;
		continue;
	    }

	    if (strcmpf((char *)cpszCanonDeviceName,
			pPrfElement->_szCanonDeviceName))
		continue;

	    pPrfElement->Free();
	 
	    fFound = TRUE;
	    break;
	}

	if ((!fFound) && (pFreePrfElement != NULL))
	{
	    pPrfElement = pFreePrfElement;
	    fFound = TRUE;
	}
    }

// At this point, the old element (if any) has been removed.  fFound
// indicates whether there is a place to insert a new element;  if so,
// that place is pPrfElement.

    // treat empty string the same as null string
    if ((cpszCanonRemoteName != NULL) && (cpszCanonRemoteName[0] == TCH('\0')))
	cpszCanonRemoteName = NULL;

    if ((!fFound) && (cpszCanonRemoteName != NULL))
    {
	usReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if (fFound && (cpszCanonRemoteName != NULL))
    {
        BUFFER pLineBuf(MAX_PROFILE_LINE);

        if (pLineBuf.QuerySize() < MAX_PROFILE_LINE)
	{
	    usReturn = ERROR_NOT_ENOUGH_MEMORY;
	}
	else
	{
	    if (usReturn == NO_ERROR)
	    {
	        if (!(pPrfElement->Init(
		        *this,
		        (char *)cpszCanonDeviceName,
		        (char *)cpszCanonRemoteName,
			sAsgType,
			usResType)))
	        {
	            usReturn = ERROR_NOT_ENOUGH_MEMORY;
	        }
	    }
	}
    }

    _elementlist.Unlock();

    return usReturn;
}

/**********************************************************\

   NAME:       PRFHEAP_HANDLE::IsNull

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/25/91  created

\**********************************************************/

BOOL PRFHEAP_HANDLE::IsNull()
{
    return _localheap.IsNull() || _elementlist.IsNull();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\query.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/03/90  split from profile.cxx
 *  01/27/91  removed CFGFILE
 */

#ifdef CODESPEC
/*START CODESPEC*/

/********
QUERY.CXX
********/

/****************************************************************************

    MODULE: Query.cxx

    PURPOSE: Returns one connection from the cached profile

    FUNCTIONS:

	see uiprof.h

    COMMENTS:

	see \\iceberg2\lm30spec\src\docs\funcspec\lm30dfs.doc for
	details on the new use_info_2 data structure for LM30

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */


/*START CODESPEC*/
/*
 * Returns information about one connection in the cached profile.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * NERR_UseNotFound
 *
 *	see \\iceberg2\lm30spec\src\docs\funcspec\lm30dfs.doc for
 *	details on the new use_info_2 data structure for LM30
 */
USHORT UserProfileQuery(
	CPSZ   cpszUsername,
	CPSZ   cpszDeviceName,
	PSZ    pszBuffer,    // returns UNC, alias or domain name
	USHORT usBufferSize, // length of above buffer
	short *psAsgType,    // *psAsgType set to asg_type; ignored if NULL
	unsigned short *pusResType   // *pusResType set to res_type; ignored if NULL
	)
/*END CODESPEC*/
{
    char       szCanonDeviceName[DEVLEN+1]; // canonicalized cpszDeviceName
    USHORT     usError;

    if (!ConfirmUsername(cpszUsername))
	return ERROR_GEN_FAILURE;

    usError = CanonDeviceName(cpszDeviceName,
	(PSZ)szCanonDeviceName,sizeof(szCanonDeviceName));
    if (usError)
	return NERR_InvalidDevice;

    return ::hGlobalHeap.Query(
	    (CPSZ)szCanonDeviceName,
	    pszBuffer,
	    usBufferSize,
	    psAsgType,
	    pusResType);
}
/*START CODESPEC*/

/************
end QUERY.CXX
************/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\set.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/29/90  split from profile.cxx
 *  01/27/91  removed CFGFILE
 *  05/09/91  All input now canonicalized
 */

#ifdef CODESPEC
/*START CODESPEC*/

/******
SET.CXX
******/

/****************************************************************************

    MODULE: Set.cxx

    PURPOSE: Changes cached profile entries

    FUNCTIONS:

	UserProfileSet

    COMMENTS:

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */


/*START CODESPEC*/
/*
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * ERROR_NOT_ENOUGH_MEMORY
 */
/*
 * UserProfileQuery does not canonicalize cpszCanonRemoteName, the caller
 * is expected to already have done so.
 *
 * The user is expected to ensure that usResType corresponds to
 * the type of the remote resource, and that device cpszDeviceName
 * can be connected to a resource of that type.
 */
USHORT UserProfileSet(
	CPSZ   cpszUsername,
	CPSZ   cpszDeviceName,
	CPSZ   cpszRemoteName,
	short  sAsgType,     // as ui2_asg_type
	unsigned short usResType     // as ui2_res_type
	)
/*END CODESPEC*/
{
    USHORT     usError;
    char       szCanonDeviceName[DEVLEN+1]; // canonicalized cpszDeviceName
    char       szCanonRemoteName[RMLEN+1]; // CODEWORK LM30

    if (!ConfirmUsername(cpszUsername))
	return ERROR_GEN_FAILURE;

    usError = CanonDeviceName(cpszDeviceName,
	    (PSZ)szCanonDeviceName,sizeof(szCanonDeviceName));
    if (usError != NO_ERROR)
	return NERR_InvalidDevice;

    if ( cpszRemoteName == (CPSZ)NULL )
    {
        return ::hGlobalHeap.Set(
		    (CPSZ)szCanonDeviceName,
		    (CPSZ)NULL,
		    sAsgType,
		    usResType
		    );
    }

    usError = CanonRemoteName(cpszRemoteName,
	    (PSZ)szCanonRemoteName,sizeof(szCanonRemoteName));
    if (usError != NO_ERROR)
	return ERROR_BAD_NET_NAME;

    return ::hGlobalHeap.Set(
		(CPSZ)szCanonDeviceName,
		(CPSZ)szCanonRemoteName,
		sAsgType,
		usResType
		);
}
/*START CODESPEC*/

/**********
end SET.CXX
**********/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\read.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/03/90  split from profile.cxx
 *  01/27/91  removed CFGFILE
 */

#ifdef CODESPEC
/*START CODESPEC*/

/*******
READ.CXX
*******/

/****************************************************************************

    MODULE: Read.cxx

    PURPOSE: Reads and caches user profile

    FUNCTIONS:

	see uiprof.h

    COMMENTS:

	There is always a cached profile after this call with non-null
	cpszUsername, even after an error return.  The only exception is
	some unusual cases after ERROR_NOT_ENOUGH_MEMORY.

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */


/*START CODESPEC*/
/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_FILE_NOT_FOUND
 */
USHORT UserProfileRead(
	CPSZ  cpszUsername, // uncache cached profile if this is NULL
	CPSZ  cpszHomedir
	)
/*END CODESPEC*/
{
    char szCanonUsername[UNLEN+1]; // canonicalized cpszUsername
    char szPath[MAXPATHLEN];       // path+filename of profile file
    USHORT usError;

// did user ask to forget profile?  If so, clear the profile.
    if ((cpszUsername == NULL) || (cpszUsername[0] == TCH('\0')))
    {
        StoreUsername((CPSZ)NULL);
        ::hGlobalHeap.Clear();
	return NO_ERROR;
    }

    usError = CanonUsername(cpszUsername,
	(PSZ)szCanonUsername,sizeof(szCanonUsername));
    if (usError)
	return NERR_BadUsername;

    usError = BuildProfileFilePath(cpszHomedir,
	        (PSZ)szPath, sizeof(szPath));
    if (usError)
	return ERROR_BAD_NETPATH;

    StoreUsername((CPSZ)szCanonUsername);

    usError = ::hGlobalHeap.Read((CPSZ)szPath);
    if (usError)
	return ERROR_FILE_NOT_FOUND;
    
    return NO_ERROR;
}
/*START CODESPEC*/

/***********
end READ.CXX
***********/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\write.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  02/02/91  created
 */

#ifdef CODESPEC
/*START CODESPEC*/

/********
WRITE.CXX
********/

/****************************************************************************

    MODULE: Write.cxx

    PURPOSE: Writes cached profile to permanent storage

    FUNCTIONS:

	UserProfileWrite

    COMMENTS:

****************************************************************************/

/*END CODESPEC*/
#endif // CODESPEC



#include "profilei.hxx"		/* headers and internal routines */



/* global data structures: */



/* internal manifests */



/* functions: */


/*START CODESPEC*/
/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_WRITE_FAULT
 */
USHORT UserProfileWrite(
	CPSZ   cpszUsername,
	CPSZ   cpszHomedir
	)
/*END CODESPEC*/
{
    USHORT     usError;
    char       szPath[MAXPATHLEN];   // path+filename of profile file
    char       szCanonUsername[UNLEN+1]; // canonicalized cpszUsername

    usError = CanonUsername(cpszUsername,
	    (PSZ)szCanonUsername,sizeof(szCanonUsername));
    if (usError != NO_ERROR)
	return NERR_BadUsername;

    usError = BuildProfileFilePath(cpszHomedir,
	    (PSZ)szPath,sizeof(szPath));
    if (usError != NO_ERROR)
	return ERROR_BAD_NETPATH;

    usError = ::hGlobalHeap.Write((CPSZ)szPath);
    if (usError != NO_ERROR)
	return ERROR_WRITE_FAULT;
    
    return NO_ERROR;
}
/*START CODESPEC*/

/**********
end SET.CXX
**********/
/*END CODESPEC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\test\heapstat.cxx ===
#define NO_TEST_VARS
#include "test.hxx"

// copied from $(UI)\COMMON\SRC\CFGFILE\TEST

/* Reports on the status returned by _heapwalk, _heapset, or _heapchk */

int heapstat( int status )
{
int usRetCode = 1;

#ifdef DEBUGShowHeapStat
    printf( SZ("Heap status: ") );
#endif

    switch( status )
    {
        case _HEAPOK:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - heap is fine\n") );
#endif
            break;
        case _HEAPEMPTY:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - empty heap\n") );
#endif
            break;
        case _HEAPEND:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - end of heap\n") );
#endif
            break;
        case _HEAPBADPTR:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad pointer to heap\n") );
#endif
	    usRetCode = 0;
            break;
        case _HEAPBADBEGIN:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad start of heap\n") );
#endif
	    usRetCode = 0;
            break;
        case _HEAPBADNODE:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad node in heap\n") );
#endif
	    usRetCode = 0;
            break;
    }

    return( usRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\test\test1.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/02/90  created
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST1.CXX
********/

/****************************************************************************

    MODULE: Test1.cxx

    PURPOSE: One stage of tests for user profile APIs

    FUNCTIONS:

	see profilei.h

    COMMENTS:

****************************************************************************/

/************
end TEST1.CXX
************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */



/* functions: */


int main(int argc, char **argv)
{
    int i;

    (void) argc;
    (void) argv;


    CHECKHEAP


    printf(SZ("Starting UserProfile tests\n"));

    TestOne_UserProfileInit();



// this sequence is intended to test the cpszUsername functionality

// test calling UserProfileQuery/Enum/Set before UserProfileRead
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm1"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm2"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileRead((CPSZ)NULL,(CPSZ)szHomedir1);

// test calling UserProfileQuery/Enum/Set after UserProfileRead(NULL)
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm3"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm4"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileRead((CPSZ)USERNAME,(CPSZ)szHomedir1);

// test calling UserProfileQuery/Enum/Set after UserProfileRead(USERNAME)
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm5"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm6"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)DIFFERENT_USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm7"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);



    TestOne_UserProfileRead((CPSZ)USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("x:"),MAXPATHLEN);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("lpt1"),MAXPATHLEN);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\foo\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);



    TestOne_UserProfileRead((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("x:"),MAXPATHLEN);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("lpt1"),MAXPATHLEN);

    TestOne_UserProfileSet(
	(CPSZ)DIFFERENT_USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\foo\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);

    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);

    TestOne_UserProfileWrite((CPSZ)NULL,(CPSZ)szHomedir2);

    TestOne_UserProfileWrite((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileRead((CPSZ)USERNAME, (CPSZ)szHomedir3);

    TestOne_UserProfileRead((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);



    // szHomedir3/<PROFILE_DEFAULTFILE> is read-only
    TestOne_UserProfileRead((CPSZ)USERNAME, (CPSZ)szHomedir3);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\different\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("r:"),
	(CPSZ)SZ("\\\\delete\\me"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("s:"),
	(CPSZ)SZ("\\\\save\\me"),
	USE_DISKDEV,
	0);

// test profile entry deletion
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("r:"),
	(CPSZ)NULL,
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);

    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileWrite((CPSZ)USERNAME,(CPSZ)szHomedir3);
    TestOne_UserProfileWrite((CPSZ)USERNAME,(CPSZ)szHomedir3);






    TestOne_UserProfileFree();


    // test repeated Init/Free
    printf(SZ("Starting Init/Free test\n"));
    for (i = 0; i < 20; i++)
    {
        TestOne_UserProfileInit();
        TestOne_UserProfileFree();
        CHECKHEAP
    }
    printf(SZ("Finished Init/Free test\n"));

    printf(SZ("Finished UserProfile tests\n"));



#ifdef STICKY


// Sticky tests

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickyGetBool((CPSZ)SZ("username"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("username"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("username"),(CPSZ)SZ("imauser"));

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickyGetBool((CPSZ)SZ("username"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("username"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("username"),NULL);

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickySetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickySetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("flag"),(CPSZ)SZ("other"));

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

#endif // STICKY


    CHECKHEAP

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\profile\sticky.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *      01/09/91  jonn, created
 *      3/4/91    chuckc, added meat. See UIPROF.H for headers.
 *      3/27/91   chuckc, code review changes from 3/26/91
 *                (gregj,chuckc,jonn,ericch)
 */


#include "profilei.hxx"         /* headers and internal routines */

extern "C" {
#include "uilmini.h"
#include <lmconfig.h>
}

/*
 * GENERAL note:
 *      this module is to be used for user preferences.
 *      currently, all such values are saved in LANMAN.INI,
 *      but this may not always be the case.
 *      the user should therefore only use these APIs and
 *      not assume the underlying mechanisms.
 */



/*******************************************************************

    NAME:       UserPreferenceQuery

    SYNOPSIS:   Queries a saved user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to buffer to receive string
                cbLen    - size of buffer

    EXIT:       if NERR_Success, pchValue will contain value in
                LAMMAN.INI corresponding to the key.
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM or NERR_BufTooSmall.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQuery( USHORT     usKey,
                            TCHAR FAR * pchValue,
                            USHORT     cbLen)
{
    USHORT  usErr, usParmLen;
    TCHAR FAR *pchKeyValue;

    /*
     * if bad pointer or key not known then bag out
     */
    if ( (pchValue == NULL) || !(pchKeyValue = KeyValue(usKey)) )
        return(ERROR_INVALID_PARAMETER) ;

    /*
     * call out to NETAPI and return the its results
     */
    usErr = NetConfigGet2(NULL, NULL, LMI_COMP_NIF, pchKeyValue,
                          pchValue, cbLen, &usParmLen);

    return(usErr) ;

}


/*******************************************************************

    NAME:       UserPreferenceSet

    SYNOPSIS:   Saves a user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to null terminated string
                            containing value to be saved.

    EXIT:       if NERR_Success, the value in LAMMAN.INI corresponding
                to the key will be the string pointed to by pchValue.

                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSet( USHORT     usKey,
                          TCHAR FAR * pchValue)
{
    TCHAR *pchKeyValue;
    USHORT usErr ;
    config_info_0 ConfigInfo0 ;

    /*
     * if not known then it is invalid.
     * we also bag out if string is null or too long.
     */
    if ( !(pchKeyValue = KeyValue(usKey)) )
        return(ERROR_INVALID_PARAMETER) ;

    if ( !pchValue || strlenf(pchValue) >= USERPREF_MAX )
        return(ERROR_INVALID_PARAMETER) ;

    /*
     * setup the NETAPI data structure
     */
    ConfigInfo0.Key = pchKeyValue ;
    ConfigInfo0.Data = (TCHAR *)pchValue ;

    /*
     * Call out to API, and return its return value
     */
    usErr = NetConfigSet (NULL, NULL, LMI_COMP_NIF,
                0, 0, (TCHAR *) &ConfigInfo0,
                sizeof(ConfigInfo0), 0L);
    return(usErr) ;
}


/*******************************************************************

    NAME:       UserPreferenceQueryBool

    SYNOPSIS:   Queries a boolean user preference

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pfValue  - pointer to BOOL that will receive value

    EXIT:       if NERR_Success, pfValue will contain TRUE if
                the value in LAMMAN.INI corresponding to the key
                is "YES" or "yes", and FALSE if "NO" or "no".
                If neither, we assume the user made an error since the
                value stored was not YES/NO.

                Also returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQueryBool( USHORT     usKey,
                                BOOL FAR * pfValue)
{
    USHORT usErr ;
    TCHAR szBuf[USERPREF_MAX] ;

    /*
     * check for bad pointer
     */
    if (pfValue == NULL)
        return(ERROR_INVALID_PARAMETER);

    /*
     * let UserPreferenceQuery do the work.
     */
    usErr = UserPreferenceQuery(usKey, szBuf, sizeof(szBuf)) ;

    if (usErr == NERR_Success)
    {
        /*
         * if we got the value then see if YES or NO.
         * if neither then the string was not BOOL
         * and hence error invalid parameter.
         */
        if (stricmpf(USERPREF_NO,szBuf) == 0)
            *pfValue = FALSE ;
        else if (stricmpf(USERPREF_YES,szBuf) == 0)
            *pfValue = TRUE ;
        else
            return(ERROR_INVALID_PARAMETER) ;
    }
    return(usErr) ;
}

/*******************************************************************

    NAME:       UserPreferenceSetBool

    SYNOPSIS:   Sets a user boolean preference flag

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - TRUE or FALSE, the value to be saved

    EXIT:       if NERR_Success, the LAMMAN.INI value corresponding to
                the key will be set to "yes" or "no".
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSetBool( USHORT     usKey,
                              BOOL       fValue)
{
    USHORT usErr ;

    /*
     * let UserPreferenceSet do the work.
     */
    usErr = UserPreferenceSet(usKey,
                              fValue ? USERPREF_YES : USERPREF_NO) ;
    return(usErr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\test\testprim.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/14/90  created
 *  12/02/90  moved out TestUserProfilePrimitives()
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
TESTPRIM.CXX
***********/

/****************************************************************************

    MODULE: TestPrim.cxx

    PURPOSE: Primitives for tests for user profile APIs

    FUNCTIONS:

	see profilei.h

    COMMENTS:

****************************************************************************/

/***************
end TESTPRIM.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */
char szHomedir1[] = SZ("homedir1");
char szHomedir2[] = SZ("homedir2");
char szHomedir3[] = SZ("homedir3");



/* functions: */

// USHORT UserProfileInit(
// 	);

VOID TestOne_UserProfileInit(
	)
{
    USHORT usError;

    usError = UserProfileInit(
	);
    printf(SZ("UserProfileInit() = %d\n"),
	    usError);
}

// USHORT UserProfileFree(
// 	);

VOID TestOne_UserProfileFree(
	)
{
    USHORT usError;

    usError = UserProfileFree(
	);
    printf(SZ("UserProfileFree() = %d\n"),
	    usError);
}

// USHORT UserProfileRead(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszLanroot
// 	);

VOID TestOne_UserProfileRead(
	CPSZ  cpszUsername,
	CPSZ  cpszLanroot
	)
{
    USHORT usError;

    usError = UserProfileRead(
	cpszUsername,
	cpszLanroot
	);
    printf(SZ("UserProfileRead(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszUsername,
	    cpszLanroot,
	    usError);
}

// USHORT UserProfileWrite(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszLanroot
// 	);

VOID TestOne_UserProfileWrite(
	CPSZ  cpszUsername,
	CPSZ  cpszLanroot
	)
{
    USHORT usError;

    usError = UserProfileWrite(
	cpszUsername,
	cpszLanroot
	);
    printf(SZ("UserProfileWrite(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszUsername,
	    cpszLanroot,
	    usError);
}

// USHORT UserProfileQuery(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszCanonDeviceName,
// 	PSZ   pszBuffer,     // returns UNC, alias or domain name
// 	USHORT usBufferSize, // length of above buffer
// 	short *psAsgType,    // as ui2_asg_type
//                              // ignored if cpszCanonDeviceName==NULL
// 	unsigned short *pusResType   // as ui2_res_type
//                              // ignored if cpszCanonDeviceName==NULL
// 	)

VOID TestOne_UserProfileQuery(
	CPSZ  cpszUsername,
	CPSZ  cpszCanonDeviceName,
	USHORT usBufferSize // maximum MAXPATHLEN
	)
{
    char szBuffer[MAXPATHLEN];
    PSZ pszBuffer = (PSZ)szBuffer;
    USHORT usError;
    short  sAsgType;
    unsigned short usResType;

    usError = UserProfileQuery(cpszUsername,cpszCanonDeviceName,
	    pszBuffer,usBufferSize,
	    &sAsgType, &usResType);
    printf(SZ("UserProfileQuery(\"%Fs\",\"%Fs\",buf,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    cpszCanonDeviceName,usBufferSize,usError);
    if (!usError)
    {
	printf(SZ("\tbuf = %Fs, sAsgType = %d, usResType = %d\n"),
		pszBuffer,sAsgType,usResType);
    }
}

// USHORT UserProfileEnum(
// 	CPSZ   cpszUsername,
// 	PSZ    pszBuffer,       // returns NULL-NULL list of device names
// 	USHORT usBufferSize     // length of above buffer
// 	);

VOID TestOne_UserProfileEnum(
	CPSZ   cpszUsername,
	USHORT usBufferSize // maximum MAXPATHLEN
	)
{
    char szBuffer[MAXPATHLEN];
    PSZ pszBuffer = (PSZ)szBuffer;
    USHORT usError;

    usError = UserProfileEnum(cpszUsername,pszBuffer,usBufferSize);
    printf(SZ("UserProfileEnum(\"%Fs\",buf,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    usBufferSize,usError);
    if (!usError)
    {
	printf(SZ("\tDevice list:\n"));
	while (*pszBuffer != TCH('\0'))
	{
	    printf(SZ("\tDevice = \"%Fs\"\n"),pszBuffer);
	    pszBuffer += strlenf((char *)pszBuffer)+1;
	}
	printf(SZ("\tEnd device list\n"));
    }
}


// USHORT UserProfileSet(
//	CPSZ   cpszUsername,
// 	CPSZ   cpszCanonDeviceName,
// 	CPSZ   cpszCanonRemoteName,
// 	short  sAsgType,     // as ui2_asg_type
// 	unsigned short usResType     // as ui2_res_type
// 	);

VOID TestOne_UserProfileSet(
	CPSZ   cpszUsername,
	CPSZ   cpszCanonDeviceName,
	CPSZ   cpszCanonRemoteName,
	short  sAsgType,
	unsigned short usResType
	)
{
    USHORT usError;

    usError = UserProfileSet(
	cpszUsername,
	cpszCanonDeviceName,
	cpszCanonRemoteName,
	sAsgType,
	usResType);
    printf(SZ("UserProfileSet(\"%Fs\",\"%Fs\",\"%Fs\",%d,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    cpszCanonDeviceName,
	    cpszCanonRemoteName,
	    sAsgType,
	    usResType,
	    usError);
}


#ifdef STICKY


// USHORT StickySetBool(   CPSZ      cpszKeyName,
// 		        BOOL      fValue
// 			);

VOID TestOne_StickySetBool(   CPSZ      cpszKeyName,
			        BOOL      fValue
				)
{
    USHORT usError = StickySetBool(cpszKeyName, fValue);

    printf(SZ("StickySetBool(\"%Fs\",%Fs) = %d\n"),
	    cpszKeyName,
	    (fValue) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"),
	    usError);
}

// USHORT StickySetString( CPSZ      cpszKeyName,
// 		        CPSZ      cpszValue
// 			);

VOID TestOne_StickySetString( CPSZ      cpszKeyName,
			        CPSZ      cpszValue
				)
{
    USHORT usError = StickySetString(
		cpszKeyName, cpszValue);

    printf(SZ("StickySetString(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszKeyName,
	    (cpszValue)?cpszValue:(CPSZ)SZ("<NULL>"),
	    usError);
}

// USHORT StickyGetBool(   CPSZ      cpszKeyName,
// 			BOOL      fDefault,
// 		        BOOL *    pfValue
// 			);

VOID TestOne_StickyGetBool(   CPSZ      cpszKeyName,
				BOOL      fDefault
				)
{
    BOOL fValue;
    USHORT usError = StickyGetBool(
	    cpszKeyName, fDefault, &fValue);

    printf(SZ("StickyGetBool(\"%Fs\",%Fs) = %d\n"),
	    cpszKeyName,
	    (fDefault) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"),
	    usError);
    if (!usError)
    {
	printf(SZ("\tfValue = %Fs\n"),
		(fValue) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"));
    }
}

// USHORT StickyGetString( CPSZ      cpszKeyName,
// 		        PSZ       pszValue,
// 			USHORT    cbLen
// 			);

VOID TestOne_StickyGetString( CPSZ      cpszKeyName
				)
{
    char szValue[100]; // BUGBUG size
    USHORT usError = StickyGetString(
	    cpszKeyName, (PSZ)szValue, sizeof(szValue));

    printf(SZ("StickyGetString(\"%Fs\") = %d\n"),
	    cpszKeyName,
	    usError);
    if (!usError)
    {
	printf(SZ("\tszValue = %Fs\n"),
		(CPSZ)szValue);
    }
}


#endif // STICKY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\test\testtime.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/02/90  created
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
TESTTIME.CXX
***********/

/****************************************************************************

    MODULE: TestTime.cxx

    PURPOSE: Timer tests for user profile APIs

    FUNCTIONS:

	This test tests the time cost of 80 calls to UserProfileRead,
	UserProfileSet, UserProfileWrite.

	Preliminary results indicate a time cost of approx. 7 seconds.
	Actual calls will average over 0.1 seconds, since the 7 seconds
	has the advantage of disk caching;  however, this does
	demonstrate that the calculation overhead is less than 0.1
	seconds.

	Subsequent to the switch away from CFGFILE, results indicate
	time costs of 3-4 seconds for this test.

    COMMENTS:

****************************************************************************/

/***************
end TESTTIME.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */

USHORT DoReadSetWrite(
    CPSZ cpszUsername,
    CPSZ cpszLanroot,
    CPSZ cpszDeviceName,
    CPSZ cpszRemoteName,
    short sAsgType,
    unsigned short usResType
    )
{
    USHORT usError;

    usError = UserProfileRead(cpszUsername, cpszLanroot);
    if (usError != NO_ERROR)
	return usError;

    usError = UserProfileSet(cpszUsername, cpszDeviceName, cpszRemoteName, sAsgType, usResType);
    if (usError != NO_ERROR)
	return usError;

    usError = UserProfileWrite(cpszUsername, cpszLanroot);
    if (usError != NO_ERROR)
	return usError;
}


/* functions: */


int main(int argc, char **argv)
{
    USHORT usError;
    INT    i;
    (void) argc;
    (void) argv;

    CHECKHEAP

    usError = UserProfileInit();
    if (usError)
    {
	printf(SZ("1: Error %d -- timer test aborted\n"),usError);
    }

    for (i = 0; i < 20; i++)
    {
        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSERNAME"),(CPSZ)SZ("homedir1"),
	    (CPSZ)SZ("j:"),(CPSZ)SZ("\\newserv\share"),USE_DISKDEV,0);
        if (usError)
        {
	    printf(SZ("2: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSERNAME"),(CPSZ)SZ("homedir1"),
	    (CPSZ)SZ("j:"),(CPSZ)NULL,0,0);
        if (usError)
        {
	    printf(SZ("3: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSER2NAME"),(CPSZ)SZ("homedir2"),
	    (CPSZ)SZ("j:"),(CPSZ)SZ("\\newserv\share"),USE_DISKDEV,0);
        if (usError)
        {
	    printf(SZ("4: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSER2NAME"),(CPSZ)SZ("homedir2"),
	    (CPSZ)SZ("j:"),(CPSZ)NULL,0,0);
        if (usError)
        {
	    printf(SZ("5: Error %d -- timer test aborted\n"),usError);
        }
    }

    usError = UserProfileFree();
    if (usError)
    {
	printf(SZ("6: Error %d -- timer test aborted\n"),usError);
    }

    CHECKHEAP

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\profile\test\tstintrn.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/14/90  created
 *  02/02/91  updated to changed API
 */

#ifdef CODESPEC
/*START CODESPEC*/

/*******
TEST.CXX
*******/

/****************************************************************************

    MODULE: Test.cxx

    PURPOSE: Tests for internal subroutines

    FUNCTIONS:

	see profilei.h

    COMMENTS:

	These tests are currently unusuable due to the problems detailed
	in test.hxx.

****************************************************************************/

/***********
end TEST.CXX
***********/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */



/* functions: */


int main(int argc, char **argv)
{
    (void) argc;
    (void) argv;

    CHECKHEAP
    Test_CanonUsername();
    Test_CanonDeviceName();
    Test_BuildProfileFilePath();
    Test_BuildProfileEntry();
    Test_UnbuildProfileEntry();
    CHECKHEAP

    return 0;
}


#ifndef BUGBUG
// BUGBUG hack for DOS environment
_setargv()
{
}
_setenvp()
{
}
#endif // BUGBUG


// USHORT CanonUsername(
//     CPSZ   pszUsername,
//     PSZ    pszCanonBuffer,
//     USHORT usCanonBufferSize
//     );

VOID TestOne_CanonUsername(CPSZ cpszUsername)
{
    char szCanonBuffer[UNLEN+1];
    USHORT usError;

    usError = CanonUsername(cpszUsername,
	    (PSZ)szCanonBuffer,sizeof(szCanonBuffer));
    if (usError)
	sprintf(szCanonBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("CanonUsername(\"%s\") = \"%s\"\n"),
	    (cpszUsername==NULL) ? SZ("<NULL>") : (char *)cpszUsername,
	    szCanonBuffer);
}

VOID Test_CanonUsername()
{
    TestOne_CanonUsername((CPSZ)NULL);
    TestOne_CanonUsername((CPSZ)SZ("FooBarIsMyName"));
    TestOne_CanonUsername((CPSZ)SZ("*&^$^%(*%&^"));
    TestOne_CanonUsername((CPSZ)SZ("Hello there!!!"));
    TestOne_CanonUsername((CPSZ)SZ("ThisNameIsMuchTooLongToBeAUsername"));
}

// USHORT CanonDeviceName(
//     CPSZ   cpszDeviceName,
//     PSZ    pszCanonBuffer,
//     USHORT usCanonBufferSize
//     );

VOID TestOne_CanonDeviceName(CPSZ cpszDeviceName)
{
    char szCanonBuffer[UNLEN+1]; // left extra space for error msg
    USHORT usError;

    usError = CanonDeviceName(cpszDeviceName,
	    (PSZ)szCanonBuffer,DEVLEN+1);
		  // left extra space in szCanonBuffer for error msg

    if (usError)
	sprintf(szCanonBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("CanonDeviceName(\"%s\") = \"%s\"\n"),
	    (cpszDeviceName==NULL) ? SZ("<NULL>") : (char *)cpszDeviceName,
	    szCanonBuffer);
}

VOID Test_CanonDeviceName()
{
    TestOne_CanonDeviceName((CPSZ)SZ("lpt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("LPT1"));
    TestOne_CanonDeviceName((CPSZ)SZ("lPt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\lpt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("lpt1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("LpT1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("com1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("CoM1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("COM1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("CON:"));
    TestOne_CanonDeviceName((CPSZ)SZ("con:"));
    TestOne_CanonDeviceName((CPSZ)SZ("con"));
    TestOne_CanonDeviceName((CPSZ)SZ("NUL"));
    TestOne_CanonDeviceName((CPSZ)SZ("nul"));
    TestOne_CanonDeviceName((CPSZ)SZ("NUL:"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\DEV\\NUL"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\DEV\\NUL:"));
    TestOne_CanonDeviceName((CPSZ)SZ("D:"));
    TestOne_CanonDeviceName((CPSZ)SZ("d:"));
    TestOne_CanonDeviceName((CPSZ)SZ("d"));
    TestOne_CanonDeviceName((CPSZ)SZ("z:"));
    TestOne_CanonDeviceName((CPSZ)SZ("1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\d"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\d:"));
    TestOne_CanonDeviceName((CPSZ)SZ("ThisNameIsMuchTooLongToBeADeviceName"));
    TestOne_CanonDeviceName((CPSZ)SZ("a"));
    TestOne_CanonDeviceName((CPSZ)SZ("aa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaaaa"));
}


// USHORT BuildProfileFilePath(
//     CPSZ   cpszLanroot,
//     PSZ    pszPathBuffer,
//     USHORT usPathBufferSize
//     );

VOID TestOne_BuildProfileFilePath(
     CPSZ   cpszLanroot)
{
    char szPathBuffer[MAXPATHLEN];
    USHORT usError;

    usError = BuildProfileFilePath(cpszLanroot,
	    (PSZ)szPathBuffer,sizeof(szPathBuffer));
    if (usError)
	sprintf(szPathBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("BuildProfileFilePath(\"%s\") = \"%s\"\n"),
	    (cpszLanroot==NULL) ? SZ("<NULL>") : (char *)cpszLanroot,
            szPathBuffer);
}

VOID Test_BuildProfileFilePath()
{
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\foo"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\VERY_LONG_DIR_NAME"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\thispathismuchtoolong\\_asdfasdfasdfsdafsdafsadfasdfasdfsadfsadfsadfsdafsdafsdafsadf\\sadfsdafsadfsadfsdfsdfasdfsdafsdafasdfsdafsadfsad\\fsadfadfsadfsdfsadfsadfasdfasdfasdfsadfsafsdafasd\\fsadfsadfsdafsdafsadfasdfasdfasdfsadfsadfasdfsadf\\asdfasdfsadfasdfasdfsadfasdfsadfsadfsadfsadfsadfa\\sdfasdfsadf"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("relative\\path"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("badpath%!#$%\5\12\200"));
}

VOID TestOne_BuildProfileEntry(
    CPSZ   cpszRemoteName,
    short  sAsgType,
    unsigned short usResType,
    USHORT usBufferSize // not greater than MAXPATHLEN
    )
{
    char szBuffer[MAXPATHLEN];
    USHORT usError;

    usError = BuildProfileEntry(
	cpszRemoteName,
	sAsgType,
	usResType,
	(PSZ)szBuffer,
	usBufferSize
	);
    if (usError)
	sprintf(szBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("BuildProfileEntry(\"%s\",%d,%d,buf,%d) = \"%s\"\n"),
	(char *)cpszRemoteName,sAsgType,usResType,usBufferSize,szBuffer);
    if (!usError)
        TestOne_UnbuildProfileEntry(MAXPATHLEN,(PSZ)szBuffer);
}

VOID Test_BuildProfileEntry()
{
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\foo\\bar"),USE_DISKDEV,0,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("DSresourcename"),USE_DISKDEV,0,1);
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\thisisaverylong\\printresourcename"),USE_SPOOLDEV,0,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("printeralias"),USE_SPOOLDEV,50,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\unknown\\resource"),50,0,MAXPATHLEN);
}

VOID TestOne_UnbuildProfileEntry(
    USHORT  usBufferSize, // not greater than MAXPATHLEN
    CPSZ    cpszValue
    )
{
    char szBuffer[MAXPATHLEN];
    short  sAsgType;
    unsigned short usResType;
    USHORT usError;

    usError = UnbuildProfileEntry(
	(PSZ)szBuffer,
	usBufferSize,
	&sAsgType,
	&usResType,
	cpszValue
	);
    printf(SZ("UnbuildProfileEntry(buf,%d,\"%s\") = %d\n"),
	    usBufferSize,(char *)cpszValue,usError);
    if (!usError)
	printf(SZ("\tszBuffer = \"%s\", sAsgType = %d, usResType = %d\n"),
		(char *)szBuffer, sAsgType, usResType);
}

VOID Test_UnbuildProfileEntry()
{
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring"));
    TestOne_UnbuildProfileEntry(1,(CPSZ)SZ("generalstring"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV,NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring SPOOLDEV,NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV,NONE"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring("));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring ,SPOOLDEV)NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring ,SPOOLDEV))NONE"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(((SPOOLDEV,NONE)"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\reg\reg\regval.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    REGVAL.CXX

       Win32 Registry class implementation
       Value handline member functions.

    FILE HISTORY:
	DavidHov    4/25/92	Created
        DavidHov    6/1/92      Reworked for UNICODE and
                                title removal; incomplete.
	terryk	    11/4/92	Added QueryValue for Binary data

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"
#include "string.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "uatom.hxx"			    //	Atom Management defs

#include "regkey.hxx"			    //	Registry defs

const int RM_MAXVALUENUM   = 10 ;         //  Default numeric value length
const int RM_MAXVALUESTR   = 300 ;        //  Default string value length
const int RM_MAXVALUEBIN   = 300 ;        //  Default Binary value length

const int cchPad = 2 ;                    //  Length to pad strings

/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueString

    SYNOPSIS:   Worker function for all string query functions

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If the incoming type is REG_EXPAND_SZ and the
                underlying queried type is also, the value is expanded.
                A REG_SZ is also accepted in this case.
                Otherwise, it's a type mismatch.

    HISTORY:    DavidHov  5/1/92   Created
                DavidHov  5/17/92  Added REG_EXPAND_SZ support.

********************************************************************/

APIERR REG_KEY :: QueryKeyValueString
   ( const TCHAR * pszValueName, 	//  Name of value
     TCHAR * * ppszResult,		//  Location to store result
     NLS_STR * pnlsResult,              //  or, NLS_STR to update
     DWORD * pdwTitle,                  //  location to receive title index
     LONG cchMaxSize,                   //  Maximum size allowed
     LONG * pcchSize,                   //  Size of result (no terminator)
     DWORD dwType )                     //  Value type expected
{
    APIERR err = 0 ;
    TCHAR achValueData[ RM_MAXVALUESTR ] ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    INT cchLen = 0,
        cchBufferSize = 0 ;
    TCHAR * pszResult = NULL,
          * pszBuffer = NULL,
          * pszEos = NULL,
          * pszSource = NULL ;

    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    if ( pnlsResult != NULL && ppszResult != NULL )
    {
        err = ERROR_INVALID_PARAMETER ;
    }
    else
    if ( rviStruct.nlsValueName.QueryError() )
    {
        err = rviStruct.nlsValueName.QueryError() ;
    }
    else
    if ( cchMaxSize == 0 )   //  Unknown size?
    {
        //  Query the key to determine the largest possible length necessary

        REG_KEY_INFO_STRUCT rkiStruct ;
        if (    rkiStruct.nlsName.QueryError()
             || rkiStruct.nlsClass.QueryError()  )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        else
        if ( (err = QueryInfo( & rkiStruct )) == 0 )
        {
             cchBufferSize = rkiStruct.ulMaxValueLen / sizeof (TCHAR) ;
        }
    }
    else
    if ( cchMaxSize > sizeof achValueData )
    {
        //  Known size, but it's larger than the automatic array

        cchBufferSize = cchMaxSize ;

    } //  else, value will fit into automatic array

    if ( err )
        return err ;

    if ( cchBufferSize )
    {
        //  We need to allocate a buffer

        pszBuffer = new TCHAR [cchBufferSize + cchPad] ;
        if ( pszBuffer == NULL )
        {
           return ERROR_NOT_ENOUGH_MEMORY ;
        }

        //  Store the BYTE pointer and BYTE count of the buffer

        rviStruct.pwcData      = (BYTE *) pszBuffer ;
        rviStruct.ulDataLength = cchBufferSize * sizeof (TCHAR) ;
    }
    else  //  Use the automatic array for temporary storage.
    {
        rviStruct.pwcData      = (BYTE *) achValueData ;
        rviStruct.ulDataLength = ((sizeof achValueData) - cchPad) * sizeof (TCHAR) ;
    }

    if ( (err = QueryValue( & rviStruct )) == 0 )
    {
        //  Zero-terminate the value data.

        pszSource = (TCHAR *) rviStruct.pwcData ;
        pszEos = (TCHAR *) (rviStruct.pwcData+rviStruct.ulDataLengthOut) ;
	*pszEos = 0 ;
        cchLen = (INT)(pszEos - pszSource) ;
        if ( pcchSize )
            *pcchSize = cchLen ;

        //  If it wasn't the requested type, give an error.  Handle
        //  the special case of a request for a REG_EXPAND_SZ but
        //  a REG_SZ result.

        if (    (rviStruct.ulType != dwType)
             && ( !(rviStruct.ulType == REG_SZ && dwType == REG_EXPAND_SZ) ) )
        {
            err = ERROR_INVALID_PARAMETER ;
        }
    }

    //  Expand REG_MULTI_SZ if necessary.

    if ( err == 0 && rviStruct.ulType == REG_EXPAND_SZ )
    {
        DWORD cchExpand,
              cchExpanded = cchLen * 2 ;
        TCHAR * pszExpanded = NULL ;
        do
        {
            delete pszExpanded ;

            pszExpanded = new TCHAR [cchExpand = cchExpanded] ;

            if ( pszExpanded == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                break ;
            }
            cchExpanded = ::ExpandEnvironmentStrings( pszSource,
                                                      pszExpanded,
                                                      cchExpand ) ;
        }
        while ( cchExpanded > cchExpand ) ;

        // Replace the older buffer, if any, with the new one, if any.

        delete pszBuffer ;
        pszBuffer = pszSource = pszExpanded ;
    }

    if ( err == 0 )
    {
        if ( ppszResult )
        {
            //   They want TCHAR output.  See if we've already allocated
            //     a buffer; if so, use it, otherwise make one.

            if ( pszBuffer )
            {
                *ppszResult = pszBuffer ;
                pszBuffer = NULL ;  // Suppress deletion of buffer
            }
            else
            if ( (pszResult = new TCHAR [cchLen + cchPad]) != NULL )
	    {
	        ::strcpyf( pszResult, pszSource ) ;
                *ppszResult = pszResult ;
	    }
	    else
	    {
                err = ERROR_NOT_ENOUGH_MEMORY ;
	    }
        }
        else
        {
            //  They want NLS_STR output

            *pnlsResult = pszSource ;
            err = pnlsResult->QueryError() ;
        }
    }

    delete pszBuffer ;

    return err ;
}


/*******************************************************************

    NAME:       REG_KEY::SetKeyValueString

    SYNOPSIS:   Worker function for value string handling

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If lcbSize == 0, compute the length of the string
                using ::strlenf().

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueString
   ( const TCHAR * pszValueName,        //  Name of value
     const TCHAR * pszValue,		//  Data to be applied
     DWORD dwTitle,                     //  Title index (optional)
     LONG lcbSize,                      //  Size of string
     DWORD dwType )                     //  Type
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) pszValue ;
    rviStruct.ulDataLength = lcbSize == 0
                           ? (::strlenf( pszValue ) + 1)
                           : lcbSize ;
    rviStruct.ulDataLength *= sizeof (TCHAR) ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = dwType ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}

/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueBinary

    SYNOPSIS:   Worker function for all binary query functions

		If "*ppbResult" is non-NULL, this value is used
		for the result buffer; its size is assumed to be
		"cbMaxSize".

    		If "cbMaxSize" is zero, key is queried to find 
		largest value.

    ENTRY:

    EXIT:

    RETURNS:	APIERR

    HISTORY:    DavidHov  5/1/92   Created
                DavidHov  5/17/92  Added REG_EXPAND_SZ support.
		terryk	  11/4/92  Changed it to QueryKeyValueBinary

********************************************************************/

APIERR REG_KEY :: QueryKeyValueBinary
   ( const TCHAR * pszValueName, 	//  Name of value
     BYTE * * ppbResult,		//  Location to store result
     LONG * pcbSize,                    //  Size of result (no terminator)
     LONG cbMaxSize,                    //  Maximum size allowed
     DWORD * pdwTitle,                  //  location to receive title index
     DWORD dwType )                     //  Value type expected
{
    APIERR err = 0 ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    INT  cbBufferSize = 0 ;
    BYTE * pbBuffer = NULL;

    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    do
    {
    	if ( ppbResult == NULL )
    	{
	    err = ERROR_INVALID_PARAMETER ;
	    break ;
    	}
    
        if ( err = rviStruct.nlsValueName.QueryError() )
        {
	    break; 
    	}
    
    	if ( (cbBufferSize = cbMaxSize) == 0 )    // Unknown size?
    	{
            //  Query the key to determine the largest possible length necessary

            REG_KEY_INFO_STRUCT rkiStruct ;
            if (    rkiStruct.nlsName.QueryError()
                 || rkiStruct.nlsClass.QueryError()  )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }
            else
            if ( (err = QueryInfo( & rkiStruct )) == 0 )
            {
                 cbBufferSize = rkiStruct.ulMaxValueLen ;
            }
    	    if ( err )
                break ;
        }

    	//  See if we need to allocate a buffer.  Use the size given by the user 
    	//  if present.

    	if ( *ppbResult )    //  Does the pointer point somewhere?
    	{
            pbBuffer = *ppbResult ;   //  Pick up user's pointer.
    	}
    	else  //  We have to allocate a buffer
        if ( (pbBuffer = new BYTE [cbBufferSize]) == NULL )
	{
            err = ERROR_NOT_ENOUGH_MEMORY ;
	    break ;
    	}

        //  Store the BYTE pointer and BYTE count of the buffer

	rviStruct.pwcData      = pbBuffer ;
	rviStruct.ulDataLength = cbBufferSize * sizeof (BYTE) ;

	if ( err = QueryValue( & rviStruct ) )
	{
	    break ;
	}

        if ( rviStruct.ulType != dwType )
        {
	    err = ERROR_INVALID_PARAMETER ;
	    break ;
        }	
        if ( *ppbResult == NULL ) 
	{
	    //  Give the caller the allocated buffer.
	    *ppbResult = pbBuffer ;
	}

	//  Report eh size read.
	*pcbSize = rviStruct.ulDataLengthOut ;
    }
    while ( FALSE ) ;

    if ( err && pbBuffer != *ppbResult ) 
    {
    	delete pbBuffer ;
    }

    return err ;
}


/*******************************************************************

    NAME:       REG_KEY::SetKeyValueBinary

    SYNOPSIS:   Worker function for value binary handling

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueBinary
   ( const TCHAR * pszValueName,        //  Name of value
     const BYTE * pbValue,		//  Data to be applied
     LONG lcbSize,                      //  Size of binary
     DWORD dwTitle,                     //  Title index (optional)
     DWORD dwType )                     //  Type
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) pbValue ;
    rviStruct.ulDataLength =  lcbSize ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = dwType ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}
/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueLong

    SYNOPSIS:   Worker function for REG_DWORD handling

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR REG_KEY :: QueryKeyValueLong
   ( const TCHAR * pszValueName, 	//  Name of value
     LONG * pnResult,    		//  Location to store result
     DWORD * pdwTitle )                 //  location to receive title index
{
    APIERR err ;
    BYTE abValueData[ RM_MAXVALUENUM ] ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    TCHAR * pszResult = NULL ;

    rviStruct.pwcData      = abValueData ;
    rviStruct.ulDataLength = sizeof abValueData ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    if ( rviStruct.nlsValueName.QueryError() )
    {
        err = rviStruct.nlsValueName.QueryError() ;
    }
    else
    if ( (err = QueryValue( & rviStruct )) == 0 )
    {
        if ( rviStruct.ulType != REG_DWORD )
        {
            err = ERROR_INVALID_PARAMETER ;
        }
        else
        {
            *pnResult = *( (LONG *) abValueData ) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:       REG_KEY::SetKeyValueLong

    SYNOPSIS:   Worker function for REG_DWORD value setting

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueLong
   ( const TCHAR * pszValueName, 	//  Name of value
     LONG nNewValue,       		//  Data to be applied
     DWORD dwTitle )                    //  Title index (optional)
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) & nNewValue ;
    rviStruct.ulDataLength = sizeof nNewValue ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = REG_DWORD ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}


/*******************************************************************

    NAME:       REG_KEY::QueryValue

    SYNOPSIS:   Query a single string value from the
                Registry.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If "fExpandSz" is TRUE, then a REG_EXPAND_SZ is
                is allowed, and if found, expanded; REG_SZ will
                also suffice.

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    NLS_STR * pnlsValue,
    ULONG cchMax,
    DWORD * pdwTitle,
    BOOL fExpandSz )
{
    LONG cchSize ;

    return QueryKeyValueString( pszValueName,
                                NULL,
                                pnlsValue,
                                NULL,
                                cchMax ? cchMax : RM_MAXVALUESTR,
                                & cchSize,
                                fExpandSz ? REG_EXPAND_SZ : REG_SZ );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const NLS_STR * pnlsValue,
    const DWORD * pdwTitle,
    BOOL fExpandSz )
{
    return SetKeyValueString( pszValueName,
                              pnlsValue->QueryPch(),
                              NULL,
                              0,
                              fExpandSz ? REG_EXPAND_SZ
                                        : REG_SZ ) ;
}

/*******************************************************************

    NAME:       REG_KEY::QueryValue

    SYNOPSIS:   Query Binary value from the
                Registry.

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    BYTE ** ppbByte,
    LONG *pcbSize,
    LONG cbMax,
    DWORD * pdwTitle )
{
    return QueryKeyValueBinary( pszValueName,
                                ppbByte,
                                pcbSize,
                                cbMax,
                                pdwTitle,
				REG_BINARY );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const BYTE * pByte,
    const LONG cbByte,
    const DWORD * pdwTitle )
{
    return SetKeyValueBinary( pszValueName,
                              pByte,
			      cbByte,
                              NULL,
                              REG_BINARY ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    TCHAR * * ppchValue,
    ULONG cchMax,
    DWORD * pdwTitle,
    BOOL fExpandSz )
{

    LONG cchSize ;

    return QueryKeyValueString( pszValueName,
                                ppchValue,
                                NULL,
                                NULL,
                                cchMax ? cchMax : RM_MAXVALUESTR,
                                & cchSize,
                                fExpandSz ? REG_EXPAND_SZ
                                          : REG_SZ );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const TCHAR * pchValue,
    ULONG cchLen,   // BUGBUG: this parameter should be removed
    const DWORD * pdwTitle,
    BOOL fExpandSz )
{
    return SetKeyValueString( pszValueName,
                              pchValue,
                              NULL,
                              0,
                              fExpandSz ? REG_EXPAND_SZ
                                        : REG_SZ ) ;
}


/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
// Query/Set numeric values

APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    DWORD * pdwValue,
    DWORD * pdwTitle )
{
    return QueryKeyValueLong( pszValueName,
                              (LONG *) pdwValue,
                              NULL ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    DWORD dwValue,
    const DWORD * pdwTitle )
{
    return SetKeyValueLong( pszValueName,
                            dwValue,
                            NULL ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    STRLIST * * ppStrList,
    DWORD * pdwTitle  )
{
    APIERR err = 0 ;
    TCHAR * pszResult = NULL,
          * pszNext = NULL,
          * pszLast = NULL ;
    LONG cchLen, cchNext ;
    STRLIST * pStrList = NULL ;

    do
    {
        pStrList = new STRLIST ;
        if ( pStrList == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        err = QueryKeyValueString( pszValueName,
                                   & pszResult,
                                   NULL,
                                   NULL,
                                   0,  // Ask key for size of largest item
                                   & cchLen,
                                   REG_MULTI_SZ ) ;
        if ( err )
            break ;

        for ( pszLast = pszNext = pszResult, cchNext = 0 ;
              err == 0 && cchNext < cchLen ;
              cchNext++, pszNext++ )
        {
            // BUGBUG:  It appears that there's an extra delimiter
            //   on the returned data, resulting in a bogus final
            //   zero-length string.  For now, skip it...

            if ( *pszNext == 0 && pszLast < pszNext )
            {
                NLS_STR * pnlsNext = new NLS_STR( pszLast ) ;
                if ( pnlsNext == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY ;
                }
                else
                if ( (err = pnlsNext->QueryError()) == 0 )
                {
                     err = pStrList->Append( pnlsNext ) ;
                }
            }
            if ( *pszNext == 0 )
            {
                pszLast = pszNext + 1 ;
            }
        }
    }
    while ( FALSE ) ;

    if ( err == 0 )
    {
        *ppStrList = pStrList ;
    }
    else
    {
        delete pStrList ;
    }

    delete pszResult ;

    return err ;
}


#ifndef UNICODE
extern "C"
{

LONG emptyMultiSz ( HKEY hKey, const CHAR * pszValueName )
{
    BYTE bData [2] ;

    return ::RegSetValueExA( hKey,
                             pszValueName,
                             0,
                             REG_MULTI_SZ,
                             bData,
                             0 );
}

}

#endif

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const STRLIST * pStrList,
    const DWORD * pdwTitle )
{
    LONG cchLen ;
    INT cStrs ;
    NLS_STR * pnlsNext ;
    TCHAR * pchBuffer = NULL ;
    APIERR err ;

    {
        ITER_STRLIST istrList( *((STRLIST *) pStrList) ) ;
        for ( cStrs = 0, cchLen = 0 ; pnlsNext = istrList.Next() ; cStrs++ )
        {
            cchLen += pnlsNext->QueryTextLength() + 1 ;
        }
    }

#ifndef UNICODE
    if ( cStrs == 0 )
    {
        return emptyMultiSz( _hKey, pszValueName ) ;
    }
#endif

    pchBuffer = new TCHAR [cchLen+cchPad] ;

    if ( pchBuffer == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        ITER_STRLIST istrList( *((STRLIST *) pStrList) ) ;
        TCHAR * pchNext = pchBuffer ;

        for ( ; pnlsNext = istrList.Next() ; )
        {
            ::strcpyf( pchNext, pnlsNext->QueryPch() ) ;
            pchNext += pnlsNext->QueryTextLength() ;
            *pchNext++ = 0 ;
        }

        *pchNext++ = 0 ;
        *pchNext = 0 ;

        err = SetKeyValueString( pszValueName,
                                 pchBuffer,
                                 0,
                                 cchLen+1,
                                 REG_MULTI_SZ ) ;
    }

    delete pchBuffer ;

    return err ;
}

// End of REGVAL.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\format.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    format.cxx
    Formatted string classes - implementations

    FILE HISTORY:
        beng        25-Feb-1992 Created

*/
#include "pchstr.hxx"  // Precompiled header



#if 0 // BUGBUG UNICODE - broken, pending runtime support
/*************************************************************************

    NAME:       SPRINTF_ALLOC_STR

    SYNOPSIS:   Wrapper class for sprintf-style formatting

    INTERFACE:  Sprintf() - formats into the string

    PARENT:     ALLOC_STR

    CAVEATS:
        Every string of this class is an owner-alloc-str.  The client
        is responsible for making sure that the string has enough storage
        for the formatting requested.

    HISTORY:
        beng        25-Feb-1992 Created

**************************************************************************/

class SPRINTF_ALLOC_STR: public ALLOC_STR
{
public:
    SPRINTF_ALLOC_STR( TCHAR * pchStorage, UINT cbStorage )
        : ALLOC_STR(pchStorage, cbStorage) {}
    VOID Sprintf( const TCHAR * pszDescription, ... );
};

/* This macro automatically creates the necessary stack storage */

#define STACK_FMT_STR( name, len )                      \
    TCHAR _tmp##name[ len+1 ] ;                         \
    SPRINTF_ALLOC_STR name( _tmp##name, sizeof(_tmp##name) );


/*******************************************************************

    NAME:       SPRINTF_ALLOC_STR::Sprintf

    SYNOPSIS:   Sprintf-style formatter for client-alloc string

    ENTRY:      pszDesc - descriptor string
                ...     - whatever

    EXIT:       String has been formatted

    CAVEATS:
        The string had better be large enough to contain the results.

        BUGBUG - This is TOTALLY broken under Unicode!


    HISTORY:
        beng        23-Jul-1991 Daydreamed (as NLS_STR member)
        beng        27-Feb-1992 Created

********************************************************************/

VOID SPRINTF_ALLOC_STR::Sprintf( const TCHAR * pszDesc, ... )
{
    INT cbWritten;
    va_list v;

    // BUGBUG UNICODE - this is totally broken under Unicode!  vsprintf
    // always formats 8-bit-char strings.  Need support from the crt.
    // BUGBUG - should munge pszDesc to change %s into %ws as appropriate;
    // ditto %c/%wc.
    // BUGBUG - this should use the "vsnprintf" form, checking against
    // the total allocated data, and return an error on overflow.

    va_start(v, pszDesc);
    cbWritten = ::vsprintf(QueryData(), pszDesc, v);
    va_end(v);
    ASSERT(cbWritten != -1); // error
    ASSERT(cbWritten <= QueryAllocSize());
    SetTextLength( ::strlenf(QueryData()) );
    IncVers();
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\reg\reg\regtree.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    REGTREE.CXX

       Win32 Registry class implementation

       Registry key sub-tree copying and manipulation.


    FILE HISTORY:
	DavidHov    12/2/91	Created

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS

#include "lmui.hxx"
#include "base.hxx"
#include "string.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "uatom.hxx"			    //	Atom Management defs

#include "regkey.hxx"			    //	Registry defs

extern "C"
{
   #include <string.h>
}


/*******************************************************************

    NAME:	REG_KEY::Copy

    SYNOPSIS:	Copy the given REG_KEY as a child of this key,
		including all subkeys and values.

    ENTRY:	"this"		Destination (parent) key object.
		regNode 	Source key object.

    EXIT:	"this" now has new sub-key and all subordinate items.

    RETURNS:	APIERR

    NOTES:

    HISTORY:

	    DavidHov  12/2/91  Created

       BUGBUG: Should partial sub-trees be deleted if an error occurs?

********************************************************************/
#define VALUEEXTRASIZE 100

APIERR REG_KEY :: Copy ( REG_KEY & regNode )
{
    REG_KEY_INFO_STRUCT rni ;
    REG_KEY_CREATE_STRUCT rnc ;
    REG_VALUE_INFO_STRUCT rvi ;
    REG_ENUM regEnum( regNode ) ;
    BYTE * pbValueData = NULL ;
    APIERR errIter,
	   err ;
    REG_KEY * pRnNew = NULL,
	    * pRnSub = NULL ;

    LONG cbMaxValue ;
    err = regNode.QueryInfo( & rni ) ;
    if ( err )
	return err ;

    cbMaxValue = rni.ulMaxValueLen + VALUEEXTRASIZE ;
    pbValueData = new BYTE [ cbMaxValue ] ;

    if ( pbValueData == NULL )
        return ERROR_NOT_ENOUGH_MEMORY ;

    //	First, create the new REG_KEY.

    rnc.dwTitleIndex = rni.ulTitleIndex ;
    rnc.ulOptions = 0 ;
    rnc.nlsClass = rni.nlsClass ;
    rnc.regSam = 0 ;
    rnc.pSecAttr = NULL ;
    rnc.ulDisposition = 0 ;

    pRnNew = new REG_KEY( *this, rni.nlsName, & rnc ) ;

    if ( pRnNew == NULL )
    {
        delete pbValueData ;
	return ERROR_NOT_ENOUGH_MEMORY ;
    }
    if ( err = pRnNew->QueryError() )
    {
        delete pRnNew ;
	return err ;
    }

    //	Next, copy all value items to the new node.

    rvi.pwcData = pbValueData ;
    rvi.ulDataLength = cbMaxValue ;

    err = errIter = 0 ;
    while ( (errIter = regEnum.NextValue( & rvi )) == NERR_Success )
    {
	rvi.ulDataLength = rvi.ulDataLengthOut ;
	if ( err = pRnNew->SetValue( & rvi ) )
	    break ;
        rvi.ulDataLength = cbMaxValue ;
    }

    // BUGBUG:	Check for iteration errors other than 'finished'.

    if ( err == 0 )
    {
        //  Finally, recursively copy the subkeys.

        regEnum.Reset() ;

        err = errIter = 0  ;

        while ( (errIter = regEnum.NextSubKey( & rni )) == NERR_Success )
        {
      	    //  Open the subkey.

	    pRnSub = new REG_KEY( regNode, rni.nlsName );

	    if ( pRnSub == NULL )
            {
                err =  ERROR_NOT_ENOUGH_MEMORY ;
            }
            else
	    if ( (err = pRnSub->QueryError()) == 0 )
            {
  	        //  Recurse
                err = pRnNew->Copy( *pRnSub ) ;
            }

            //  Delete the subkey object and continue

            delete pRnSub ;

	    if ( err )
	        break ;
        }
    }

    delete pRnNew ;
    delete pbValueData ;

    return err ;
}

/*******************************************************************

    NAME:       REG_KEY::DeleteTree

    SYNOPSIS:   Delete a Registry node and all its descendants.

    ENTRY:      Nothing

    EXIT:       Nothing

    RETURNS:    APIERR

    NOTES:      This routine does a depth-first descent of
                a key's sub-keys, deleting when it reaches a leaf.

    CAVEATS:    The keys will be in an indeterminate state after
                an error.

                BUGBUG:  This used to be fully recursive, but it
                seems that the Registry gives an error if the upper
                key has an enumeration outstanding (0xCFFFFFFF).
                Stay tuned for more details.

    HISTORY:    DavidHov   2/6/92   Created

********************************************************************/
const INT MAX_SUB_KEYS = 300 ;

APIERR REG_KEY :: DeleteTree ()
{
    REG_ENUM regEnum( *this ) ;
    REG_KEY_INFO_STRUCT rni ;
    APIERR errEnum = 0,
           err = 0 ;
    REG_KEY * prnChild ;
    NLS_STR anlsSubKey [ MAX_SUB_KEYS ] ;
    INT iSubKey, i ;

    //  Enumerate the subkeys, building the array of subkey names

    for ( iSubKey = 0 ; (errEnum = regEnum.NextSubKey( & rni )) == 0 ; )
    {
        anlsSubKey[iSubKey++] = rni.nlsName ;
        if (   iSubKey >= MAX_SUB_KEYS
            || anlsSubKey[iSubKey-1].QueryError() != NERR_Success )
        {
            DBGEOL(   "REG_KEY::DeleteTree: breaking out, iSubKey = "
                   << (DWORD)iSubKey << ", error = "
                   << anlsSubKey[iSubKey-1].QueryError() );
            break;
        }
    }

    //  Walk the array, deleting all subkeys.

    for ( i = 0 ; i < iSubKey ; i++ )
    {
        prnChild = new REG_KEY( *this, anlsSubKey[i] ) ;
        if ( prnChild == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }
        if ( err = prnChild->QueryError() )
            break ;

        //  Recurse; note that DeleteTree() deletes the key itself
        err = prnChild->DeleteTree() ;

        delete prnChild ;

        if ( err )
            break ;
    }

    //  If successful so far, delete this key.

    if ( err == 0 )
    {
        err = Delete() ;
    }

    return err ;
}

//  End of REGTREE.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\pch\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    string.cxx
    NLS/DBCS-aware string class: essential core methods

    This file contains those routines which every client of
    the string classes will always need.

    Most of the implementation has been exploded into other files,
    so that an app linking to string doesn't end up dragging the
    entire string runtime library along with it.

    FILE HISTORY:
        beng        23-Oct-1990 Created
        johnl       11-Dec-1990 Remodeled beyond all recognizable form
        beng        18-Jan-1991 Most methods relocated into other files
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
        KeithMo     16-Nov-1992 Performance tuning.

*/

#include "pchstr.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


#ifndef min
inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}
#endif

//
//  The global empty string.
//

static TCHAR EmptyString;

TCHAR * NLS_STR::_pszEmptyString = &EmptyString;


/*******************************************************************

    NAME:       NLS_STR::NLS_STR

    SYNOPSIS:   Constructor for NLS_STR

    ENTRY:      NLS_STR takes many (too many) ctor forms.

    EXIT:       String constructed

    NOTES:
        The default constructor creates an empty string.

    HISTORY:
        beng        23-Oct-1990 Created
        beng        26-Apr-1991 Replaced 'CB' and USHORT with INT
        beng        22-Jul-1991 Uses member-init ctor forms
        beng        14-Nov-1991 Unicode fixes
        beng        21-Nov-1991 Removed some ctor forms

********************************************************************/

NLS_STR::NLS_STR()
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if ( !Alloc(0) )
        return;

    *_pchData = TCH('\0');
    InitializeVers();
}


NLS_STR::NLS_STR( UINT cchInitLen )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (!Alloc(cchInitLen))
        return;

    *_pchData = TCH('\0');
    InitializeVers();
}


NLS_STR::NLS_STR( const TCHAR * pchInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (pchInit == NULL)
    {
        if (!Alloc(0))
            return;

        *_pchData = TCH('\0');
    }
    else
    {
        UINT cchSource = ::strlenf( pchInit );

        if ( !Alloc(cchSource) )
            return;

        ::strcpyf( _pchData, pchInit );

        _cchLen = cchSource;
    }

    InitializeVers();
}


NLS_STR::NLS_STR( const NLS_STR & nlsInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    UIASSERT( nlsInit.QueryError() == NERR_Success );

    if (!Alloc( nlsInit.QueryTextLength() ) )
        return;

    ::memcpy( _pchData, nlsInit.QueryPch(), nlsInit.QueryTextSize() );

    _cchLen = nlsInit.QueryTextLength();

    InitializeVers();
}


#ifdef UNICODE
NLS_STR::NLS_STR( const WCHAR * pchInit, USHORT cchInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (pchInit == NULL)
    {
        if (!Alloc(0))
            return;

        *_pchData = TCH('\0');
    }
    else
    {
        if ( !Alloc(cchInit) )
            return;

        ::memcpyf( _pchData, pchInit, cchInit * sizeof(WCHAR) );

        _pchData[ cchInit ] = TCH('\0');

        _cchLen = cchInit;
    }

    InitializeVers();
}
#endif


NLS_STR::NLS_STR( TCHAR * pchInit, UINT cbSize, BOOL fClear )
    : _pchData(pchInit),
      _cbData(cbSize),
      _cchLen(0),
      _fOwnerAlloc(TRUE)
{
    ASSERT( pchInit != NULL );

    if ( fClear )
    {
        ASSERT(cbSize > 0); // must have given the size
        *_pchData = TCH('\0');
    }
    else
    {
        _cchLen = ::strlenf( pchInit );
        if (cbSize == 0)
            _cbData = (_cchLen + 1) * sizeof(TCHAR);

    }

    InitializeVers();
}


/*******************************************************************

    NAME:       NLS_STR::~NLS_STR

    SYNOPSIS:   Destructor for NLS_STR

    ENTRY:

    EXIT:       Storage deallocated, if not owner-alloc

    HISTORY:
        beng        23-Oct-1990     Created
        beng        22-Jul-1991     Zeroes only in debug version

********************************************************************/

NLS_STR::~NLS_STR()
{
    if( !IsOwnerAlloc() && ( _pchData != NLS_STR::_pszEmptyString ) )
        delete _pchData;

#if defined(NLS_DEBUG)
    _pchData = NULL;
    _cchLen  = 0;
    _cbData = 0;
#endif
}


/*******************************************************************

    NAME:       NLS_STR::Alloc

    SYNOPSIS:   Common code for constructors.

    ENTRY:
        cch     - number of chars desired in string

    EXIT:
        Returns TRUE if successful:

            _pchData points to allocated storage of "cb" bytes.
            _cbData set to cb.
            Allocated storage set to 0xF2 in debug version

        Returns FALSE upon allocation failure.

    NOTES:
        This is a private member function.

        If Alloc fails, it calls ReportError.

    HISTORY:
        beng        23-Oct-1990 Created
        johnl       11-Dec-1990 Updated as per code review
        beng        26-Apr-1991 Changed USHORT parm to INT
        beng        14-Nov-1991 Takes TCHAR, less term, as argument.

********************************************************************/

BOOL NLS_STR::Alloc( UINT cch )
{
    //
    //  Adjust for terminator
    //

    cch += 1;
    ASSERT(cch != 0); // wraparound

    if( cch == 1 )
    {
        //
        //  We special case empty strings to avoid thrashing
        //  the heap.
        //

        _pchData = NLS_STR::_pszEmptyString;
    }
    else
    {
        _pchData = new TCHAR[cch];

        if (_pchData == NULL)
        {
            //
            // For now, assume not enough memory.
            //

            ReportError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

#ifdef NLS_DEBUG
        ::memset(_pchData, 0xf2, cch*sizeof(TCHAR));
#endif
    }

    _cbData = cch*sizeof(TCHAR);

    return TRUE;
}


/*******************************************************************

    NAME:       NLS_STR::Realloc

    SYNOPSIS:   Reallocate an NLS_STR to the passed count of TCHAR, copying
                the current contents to the reallocated string.

    ENTRY:
        cch  - number of TCHAR desired in string storage

    EXIT:
        Returns TRUE if successful:

            _pchData points to allocated storage of "cb" bytes.
            _cbData set to cb.
            Old storage is copied

        Returns FALSE upon allocation failure, the string is preserved

    NOTES:
        This is a private member function.

        Unline Alloc, Realloc does *not* ReportError when it fails.

        A string will never be downsized (i.e., realloc can only be used
        to increase the size of a string).  If a request comes in to make
        the string smaller, it will be ignored, and TRUE will be returned.

        Realloc on an owneralloced string succeeds so long as the
        request falls within the original allocation.

        We grow the allocation to 25% more than was requested.  In this
        way we avoid poor performance when we build a long string
        through concatenation (e.g. User Browser MLE).

    HISTORY:
        johnl       11-Nov-1990 Created
        beng        26-Apr-1991 Changed USHORT parm to INT
        beng        14-Nov-1991 Takes TCHAR, less term, as argument.
        beng        20-Nov-1991 Permit on owneralloc.
        jonn        06-Oct-1994 Leave extra room when string grows

********************************************************************/

BOOL NLS_STR::Realloc( UINT cch )
{
    // Adjust for terminating NUL-char.

    cch += 1;
    ASSERT(cch != 0); // wraparound

    if ( cch*sizeof(TCHAR) <= QueryAllocSize() )
        return TRUE;

    // If owneralloced, and insufficient existing storage, must fail.

    if (IsOwnerAlloc())
        return FALSE;

    //
    // EXPERIMENTAL -- may confuse clients which expect string to grow
    // to exact size requested
    //
    cch += (cch/4);

    TCHAR * pchNewMem = new TCHAR[cch];

    if (pchNewMem == NULL)
        return FALSE;

    ::memcpy( pchNewMem, _pchData, min( (cch-1)*sizeof(TCHAR),
                                          QueryAllocSize() ) );

    if( _pchData != NLS_STR::_pszEmptyString )
        delete _pchData;

    _pchData = pchNewMem;
    _cbData = cch*sizeof(TCHAR);
    *( _pchData + cch - 1 ) = TCH('\0');

    return TRUE;
}


/*******************************************************************

    NAME:       NLS_STR::Reset

    SYNOPSIS:   Attempts to clear the error state of the string

    ENTRY:      String is in error state

    EXIT:       If recoverable, string is correct again

    RETURNS:    TRUE if successful; FALSE otherwise

    NOTES:
        An operation on a string may fail, if this occurs, the error
        flag is set and you can't use the string until the flag
        is cleared.  By calling Reset, you can clear the flag,
        thus allowing you to get access to the string again.  The
        string will be in a consistent state.  Reset will return
        FALSE if the string couldn't be restored (for example, after
        construction failure).

    HISTORY:
        Johnl       12-Dec-1990     Created
        beng        30-Mar-1992     Use BASE::ResetError

********************************************************************/

BOOL NLS_STR::Reset()
{
    UIASSERT( QueryError() ) ;  // Make sure an error exists

    if ( QueryError() == ERROR_NOT_ENOUGH_MEMORY && _pchData != NULL )
    {
        ResetError();
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       ISTR::ISTR

    SYNOPSIS:   ISTR constructors

    HISTORY:
        johnl       20-Nov-1990 Created
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

ISTR::ISTR( const ISTR& istr )
{
    _ichString = istr._ichString;
    _pnls = istr._pnls;
#ifdef NLS_DEBUG
    _nVersion = istr._nVersion;
#endif
}

ISTR::ISTR( const NLS_STR& nls )
{
    _ichString = 0;
    _pnls = &nls;
#ifdef NLS_DEBUG
    _nVersion = nls.QueryVersion();
#endif
}


/*******************************************************************

    NAME:       ISTR::operator=

    SYNOPSIS:   Assignment operator for the ISTR class

    HISTORY:
        Johnl       20-Nov-1990 Created
        beng        20-Nov-1991 Unicode fixes

********************************************************************/

ISTR& ISTR::operator=( const ISTR& istr )
{
    _ichString = istr._ichString;
    _pnls = istr._pnls;
#ifdef NLS_DEBUG
    _nVersion = istr._nVersion;
#endif
    return *this;
}


/*******************************************************************

    NAME:       ALLOC_STR::ALLOC_STR

    SYNOPSIS:   Constructor for owner-alloc string

    ENTRY:      pchBuffer - pointer to buffer to hold the string
                cbBuffer  - number of bytes available in buffer
                pszInit   - string with which to initialize the
                            buffer.  May be the same as pchBuffer,
                            in which case cbBuffer may be passed
                            as 0 (it will calc it itself).

    EXIT:       String constructed

    NOTES:
        This version lies outline.  See the class def'n for others.

    HISTORY:
        beng        21-Nov-1991 Created

********************************************************************/

ALLOC_STR::ALLOC_STR( TCHAR * pchBuffer, UINT cbBuffer, const TCHAR * pszInit )
    : NLS_STR(pchBuffer, cbBuffer, (pchBuffer != pszInit))
{
    if (QueryError())
        return;

    if (pszInit == NULL)
    {
        ReportError(ERROR_INVALID_PARAMETER);
        return;
    }

    if (pchBuffer != pszInit)
    {
        *this = pszInit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\formnum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    formnum.cxx
    Formatted string classes, numeric formatting - implementations

    FILE HISTORY:
        beng        25-Feb-1992 Created

*/

#include "pchstr.hxx"  // Precompiled header



/* Static member of NUM_NLS_STR class */

TCHAR NUM_NLS_STR::_chThousandSep = 0;


/*******************************************************************

    NAME:       DEC_STR::DEC_STR

    SYNOPSIS:   Constructor for DEC_STR

    ENTRY:      nValue      - value to represent
                cchDigitPad - minimum number of digits

    EXIT:       String constructed and formatted as decimal number

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

DEC_STR::DEC_STR( ULONG nValue, UINT cchDigitPad )
    : NLS_STR( CCH_INT )
{
    if (QueryError() != NERR_Success)
        return;

    // Assemble decimal representation into szTemp, reversed,
    // then reverse in-place into correct format.
    //
    // This code deliberately eschews ultoa; while the mod/div saves
    // nothing, the digit calc is simpler, and anyway this scheme
    // allows a nice in-place digit padding.
    //
    // REVIEW: check code size, reconsider ultoa usage

    TCHAR szTemp[CCH_INT+1];
    {
        UINT ich = 0;
        do
        {
            UINT nDigitValue = (UINT)(nValue % 10);
            nValue /= 10;
            szTemp[ich++] = (TCHAR)nDigitValue + TCH('0');
        }
        while (nValue > 0);

        while (ich < cchDigitPad)
        {
            szTemp[ich++] = TCH('0'); // pad to required number of digits
        }

        szTemp[ich] = 0;
        ::strrevf(szTemp);
    }

    // Now copy szTemp into the string

    {
        *(NLS_STR*)this = szTemp;

        APIERR err = QueryError();
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
    }
}


/*******************************************************************

    NAME:       HEX_STR::HEX_STR

    SYNOPSIS:   Constructor for HEX_STR

    ENTRY:      nValue      - value to represent
                cchDigitPad - minimum number of digits

    EXIT:       String constructed and formatted as hex number

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

HEX_STR::HEX_STR( ULONG nValue, UINT cchDigitPad )
    : NLS_STR( CCH_INT ) // plenty big, since hex more compact than dec
{
    if (QueryError() != NERR_Success)
        return;

    // Assemble hex representation into szTemp, reversed,
    // then reverse in-place into correct format
    //
    // This code deliberately eschews ultoa, since div and mod 16
    // optimize so very nicely.

    TCHAR szTemp[CCH_INT+1];
    {
        UINT ich = 0;
        do
        {
            UINT nDigitValue = (UINT)(nValue % 16);
            nValue /= 16;

            if (nDigitValue > 9)
            {
                szTemp[ich++] = (TCHAR)nDigitValue - 10 + TCH('a');
            }
            else
            {
                szTemp[ich++] = (TCHAR)nDigitValue + TCH('0');
            }
        }
        while (nValue > 0);

        while (ich < cchDigitPad)
        {
            szTemp[ich++] = TCH('0'); // pad to required number of digits
        }

        szTemp[ich] = 0;
        ::strrevf(szTemp);
    }

    // Now copy szTemp into the string

    {
        *(NLS_STR*)this = szTemp;

        APIERR err = QueryError();
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
    }
}


/*******************************************************************

    NAME:       NUM_NLS_STR::NUM_NLS_STR

    SYNOPSIS:   Constructor for NUM_NLS_STR

    ENTRY:      nValue - value to represent

    EXIT:       String constructed and formatted

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

NUM_NLS_STR::NUM_NLS_STR( ULONG nValue )
    : DEC_STR( nValue )
{
    const UINT cchDigitsPerThousand = 3;

    if (QueryError() != NERR_Success)
        return;

    UINT cchNumber = QueryTextLength();
    if (cchNumber < 4) // too short to need commas
        return;

    // Init package as necessary (i.e. fetch comma char)

    if (_chThousandSep == 0)
    {
        Init();
    }

    // Build comma string to insert into numeric string

    APIERR err;
    TCHAR_STR nlsComma(_chThousandSep);
    if ((err = nlsComma.QueryError()) != NERR_Success)
    {
        ReportError(err);
        return;
    }

    // Calc offset of first comma, and total number of commas needed

    UINT ichFirstComma = cchNumber % cchDigitsPerThousand;
    if (ichFirstComma == 0)
        ichFirstComma = cchDigitsPerThousand;

    UINT cchCommas = (cchNumber - ichFirstComma) / cchDigitsPerThousand;

    // Run through string, inserting commas at appropriate intervals

    ISTR istr(*this);
    istr += ichFirstComma;
    while (cchCommas-- > 0)
    {
        if (!InsertStr( (const ALIAS_STR &) nlsComma, istr))
        {
            // Error reported; bail out
            return;
        }
        istr += (cchDigitsPerThousand+1); // additional one to skip comma
    }
}


/*******************************************************************

    NAME:       NUM_NLS_STR::Init

    SYNOPSIS:   Package initialization for NUM_NLS_STR

    EXIT:       Thousands-separator-char loaded

    NOTES:
        Class autoinits self.  Client should call this public member
        function should client receive WM_WININICHANGED.

    HISTORY:
        beng        25-Feb-1992 Created
        beng        05-May-1992 API changes

********************************************************************/

VOID NUM_NLS_STR::Init()
{
#if defined(WINDOWS)
    TCHAR szBuf[ 1 + 1 ] = { TEXT('\0'), TEXT('\0') }; // JonN 01/23/00: PREFIX bug 444887
    ::GetProfileString( SZ("intl"), SZ("sThousand"), SZ(","), szBuf, 1+1 );

    _chThousandSep = szBuf[ 0 ];
#else
    _chThousandSep = TCH(',');
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\reg\reg\regkey.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    REGKEY.CXX

       Win32 Registry class implementation


    CODEWORK ISSUES:

	1) WINREG.H should specify input TCHAR * parameters as
	   'const'; this would numerous cases where I had
           to cast the naturally occuring (const TCHAR *) to
           (TCHAR *) to please the compiler.

    FILE HISTORY:
	DavidHov    9/11/91	Created
	DavidHov   28-Jan-92	Converted to use Win32 APIs
        DavidHov   29-Feb-92    Added default security descriptor
        DavidHov    9-Mar-92    Eliminated internal dependence on HTOM
        DavidHov   16-May-92    CODEWORK:  Blocked usage of Titles per
                                DaveGi's mail.
        DavidHov   18-Oct-92    Removed internal tree, numerous
                                other related simplifications.

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"
#include "string.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "uatom.hxx"			    //	Atom Management defs

#include "regkey.hxx"			    //	Registry defs

#define PATHSEPARATOR	TCH('\\')	    //	Mais oui, c'est UNICODE!
#define PATHSEPSTRING	SZ("\\")
#define UNCSEPARATOR    SZ("\\\\")          //  UNC name indicator
#define PATHMAX 	MAX_PATH	    //	Registry limits are the
#define REGNAMEMAX	MAX_PATH	    //	  same as NTFS

   //  Names used as symbolic top-of-tree for textual reporting
#define REG_NAME_CURRENT_USER	 SZ("User")
#define REG_NAME_LOCAL_MACHINE	 SZ("Machine")

#define REG_CLASS_UNKNOWN	 SZ("ClassUnknown")  // Default class name
#define REG_DEFAULT_SAM_ACCESS	 MAXIMUM_ALLOWED     // Default access
#define REG_DEFAULT_TYPE	 REG_SZ 	     // Default value type

#define REG_TITLE_VALUE_RESERVED (0)        //  The only allowed title value

/*******************************************************************
 *    Default SecurityDescriptor and handling functions            *
 *******************************************************************/

static
LPSECURITY_ATTRIBUTES initSecurityAttributes
    ( LPSECURITY_ATTRIBUTES pSecAttr )
{
    static SECURITY_DESCRIPTOR defaultSecurityDescriptor ;
    static BOOL fInit = FALSE ;

    if ( ! fInit )
    {
        InitializeSecurityDescriptor( & defaultSecurityDescriptor, 1 );
        fInit = TRUE ;
    }

    pSecAttr->nLength              = sizeof( SECURITY_ATTRIBUTES );
    pSecAttr->lpSecurityDescriptor = & defaultSecurityDescriptor ;
    pSecAttr->bInheritHandle       = FALSE ;
    return pSecAttr ;
}

/*******************************************************************

    NAME:	REG_KEY::HandlePrefix

    SYNOPSIS:   Extract the optional machine name and
                top level name token from a REG_KEY name string.

    ENTRY:	const NLS_STR &       full name of key

    EXIT:       HKEY * pHkey          location to store static handle
                NLS_STR *             location to store machine name
                                      or "" (empty string)
                NLS_STR *             location to store remainder
                                      of string after prefix

    RETURNS:	BOOL            TRUE if prefix matched.

    NOTES:

    HISTORY:
	        DavidHov   10-Oct-92  Created
********************************************************************/
BOOL REG_KEY :: HandlePrefix (
    const NLS_STR & nlsKeyName,
    HKEY * pHkey,
    NLS_STR * pnlsMachineName,
    NLS_STR * pnlsRemainder )
{
    NLS_STR nlsUnc( UNCSEPARATOR ) ;
    const TCHAR * pszTemp ;
    const TCHAR * pszRemainder ;
    INT cKeyName, cchTemp ;

    static struct {
        const TCHAR * pszKeyName ;
        HKEY hKey ;
    } keyNames [] =
    {
        { REG_NAME_LOCAL_MACHINE, HKEY_LOCAL_MACHINE },
        { REG_NAME_CURRENT_USER,  HKEY_CURRENT_USER  },
        { NULL,                   NULL               }
    };

    //  Copy the given string into both result areas.  This
    //  is by far the easiest way to use the somewhat obscure
    //  NLS_STR "primitives".

    *pHkey = NULL ;

    if ( pnlsMachineName->CopyFrom( nlsKeyName ) )
        return FALSE ;
    if ( pnlsRemainder->CopyFrom( nlsKeyName ) )
        return FALSE ;

    ISTR isName( *pnlsMachineName ),
         isPos( *pnlsMachineName ) ;

    //  See if the name begins with UNC

    isName += nlsUnc.QueryTextLength() ;

    if ( pnlsMachineName->strncmp( nlsUnc, isName ) == 0 )
    {
        //  Find the trailing delmiter of the machine name;
        //  remove the remaining characters.

        if ( ! pnlsMachineName->strchr( & isPos, PATHSEPARATOR, isName ) )
            return FALSE ;
        pnlsMachineName->DelSubStr( isPos ) ;

        //  Remove the UNC name and the separator from the remainder string

        ISTR is1( *pnlsRemainder ),
             is2( *pnlsRemainder ) ;

        is2 += pnlsMachineName->QueryTextLength() + 1 ;
        pnlsRemainder->DelSubStr( is1, is2 ) ;
    }
    else
    {
        //  It's not UNC; zap the output machine name.

        pnlsMachineName->CopyFrom( SZ("") );
    }

    //  Loop through the table trying to match the head
    //  of the remainder string with one of the static
    //  names.

    pszRemainder = pnlsRemainder->QueryPch() ;

    for ( cKeyName = 0 ;
          pszTemp = keyNames[cKeyName].pszKeyName ;
          cKeyName++ )
    {
        cchTemp = ::strlenf( pszTemp ) ;

        //  If the strings match and it's either end-of-string or the
        //  next character is a '\', then this is a hit.

        if (    (::strncmpf( pszTemp, pszRemainder, cchTemp ) == 0)
             && (   (cchTemp == (INT)pnlsRemainder->QueryTextLength())
                 || (*(pszRemainder + cchTemp) == PATHSEPARATOR)) )
        {
             break ;
        }
    }
    if ( keyNames[cKeyName].pszKeyName == NULL )
        return FALSE ;

    ISTR isRem( *pnlsRemainder ),
         isRemEnd( *pnlsRemainder ) ;

    isRemEnd += cchTemp ;

    // If there's a delimiter, remove it also.

    if ( ! isRemEnd.IsLastPos() )
        ++isRemEnd;

    pnlsRemainder->DelSubStr( isRem, isRemEnd ) ;
    *pHkey = keyNames[cKeyName].hKey ;

    return TRUE ;
}


/*******************************************************************

    NAME:	REG_KEY_CREATE_STRUCT
                REG_KEY_INFO_STRUCT
                REG_VALUE_INFO_STRUCT

    SYNOPSIS:	Simple constuctors for data items with imbedded
                NLS_STRs.

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	Nothing         Use QueryError()

    NOTES:

    HISTORY:
	        DavidHov   10-Oct-92  Created
********************************************************************/
REG_KEY_CREATE_STRUCT :: REG_KEY_CREATE_STRUCT ()
{
    if ( nlsClass.QueryError() )
    {
        ReportError( nlsClass.QueryError() ) ;
    }
}

REG_KEY_INFO_STRUCT :: REG_KEY_INFO_STRUCT ()
{
    APIERR err ;

    if ( (err = nlsClass.QueryError()) == 0 )
    {
        err = nlsName.QueryError() ;
    }

    if ( err )
    {
        ReportError( err ) ;
    }
}

REG_VALUE_INFO_STRUCT :: REG_VALUE_INFO_STRUCT ()
{
    if ( nlsValueName.QueryError() )
    {
        ReportError( nlsValueName.QueryError() ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::NameChild

    SYNOPSIS:   Create the full name of this child node by
                appending the sub-key name onto the name of the
                parent.

    ENTRY:	REG_KEY * pRkChild         descendent REG_KEY
                NLS_STR & nlsSubKey        partial (sub) key name

    EXIT:       pRkChild->_nlsKeyName updated

    RETURNS:    APIERR if string copy/append operation fails

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
APIERR REG_KEY :: NameChild (
    REG_KEY * pRkChild,
    const NLS_STR & nlsSubKey ) const
{
    APIERR err = pRkChild->_nlsKeyName.CopyFrom( _nlsKeyName ) ;

    if ( err == 0 )
    {
        err = pRkChild->_nlsKeyName.Append( PATHSEPSTRING ) ;
    }

    if ( err == 0 )
    {
        err = pRkChild->_nlsKeyName.Append( nlsSubKey ) ;
    }
    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::LeafKeyName

    SYNOPSIS:   Return a pointer to the final segment of a key name

    ENTRY:	nothing

    EXIT:       nothing

    RETURNS:    const TCHAR * --> first character beyond last '\'
                                in full key name.

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
const TCHAR * REG_KEY :: LeafKeyName () const
{
    ISTR isName( _nlsKeyName ) ;
    const TCHAR * pchBeyondLastSlash = _nlsKeyName.QueryPch() ;

    if ( _nlsKeyName.strrchr( & isName, PATHSEPARATOR ) )
    {
        ++isName;
        pchBeyondLastSlash = _nlsKeyName.QueryPch( isName ) ;
    }
    return pchBeyondLastSlash ;
}

/*******************************************************************

    NAME:	REG_KEY::ParentName

    SYNOPSIS:   Construct the name of this key's parent key

    ENTRY:	NLS_STR *       pointer to string to store into

    EXIT:       string updated

    RETURNS:    APIERR if string search opreation fails

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
APIERR REG_KEY :: ParentName ( NLS_STR * pnlsParentName ) const
{
    ISTR isStart( *pnlsParentName ) ;
    APIERR err ;

    do  // Pseudo-loop
    {
        if ( err = pnlsParentName->CopyFrom( _nlsKeyName ) )
            break ;

        if ( ! pnlsParentName->strrchr( & isStart, PATHSEPARATOR ) )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }
        pnlsParentName->DelSubStr( isStart ) ;

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::OpenParent

    SYNOPSIS:   Construct a REG_KEY representing the parent
                of this key.

    ENTRY:	REGSAM rsDesired        access desired

    EXIT:       nothing

    RETURNS:    REG_KEY *  --> newly created key or NULL

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
REG_KEY * REG_KEY :: OpenParent ( REGSAM rsDesired )
{
    NLS_STR nlsParentName ;
    REG_KEY * pRkParent = NULL ;

    if ( (_lApiErr = ParentName( & nlsParentName )) == 0 )
    {
        pRkParent = new REG_KEY( nlsParentName, rsDesired ) ;
        _lApiErr = pRkParent == NULL
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pRkParent->QueryError() ;
    }

    if ( _lApiErr )
    {
        delete pRkParent ;
        pRkParent = NULL ;
    }
    return pRkParent ;
}

/*******************************************************************

    NAME:	REG_KEY::OpenChild

    SYNOPSIS:	PRIVATE.   Open a node in the Regsitry.

    ENTRY:      HKEY   hkParent         HKEY of parent key
                REGSAM rsDesired	Desired access to registry key
		DWORD  dwOptions	RegOpenKey options.

    EXIT:	Nothing

    RETURNS:	TRUE if successful; see _lApiErr otherwise.

    NOTES:      _nlsKeyName is still just the subordinate key name,
                not the full key name; the caller must do this

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: OpenChild (
    REG_KEY * pRkChild,
    const NLS_STR & nlsSubKey,
    REGSAM rsDesired,
    DWORD dwOptions )
{
    APIERR err = ::RegOpenKeyEx( *this,
                               (TCHAR *) nlsSubKey.QueryPch(),
			       dwOptions,
			       rsDesired,
			       & pRkChild->_hKey ) ;
    if ( err == 0 )
    {
        err = NameChild( pRkChild, nlsSubKey ) ;
    }
    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::CreateChild

    SYNOPSIS:	Create a child node for this node.  (private)

    ENTRY:      REG_KEY * pRkNew             REG_KEY a'borning
		REG_KEY_CREATE_STRUCT *      ptr to auxillary creation
					        structure

    EXIT:	pRkNew fields updated

    RETURNS:	APIERR

    NOTES:      _nlsKeyName is still just the subordinate key name,
                not the full key name; the caller must do this

                APIERR is not stored into parent node, since
		it's not really a parental fault.

    HISTORY:
		DavidHov   9/20/91    Created
                DavidHov  10/18/92    Modified

********************************************************************/
APIERR REG_KEY :: CreateChild
    ( REG_KEY * pRkNew,
      const NLS_STR & nlsSubKey,
      REG_KEY_CREATE_STRUCT * prncStruct ) const
{
    SECURITY_ATTRIBUTES secAttr ;
    SECURITY_ATTRIBUTES * pSecAttr ;
    APIERR err ;
    const TCHAR * pszClassName ;

    //  Create a default SECURITY_ATTRIBUTES if none is specified

    pSecAttr = prncStruct->pSecAttr != NULL
             ? prncStruct->pSecAttr
             : initSecurityAttributes( & secAttr ) ;

    //  Default the security if unspecified

    if ( prncStruct->regSam == 0 )
	prncStruct->regSam = REG_DEFAULT_SAM_ACCESS ;

    //  Default the class name if unspecified

    pszClassName = prncStruct->nlsClass.QueryTextLength() > 0
                 ? prncStruct->nlsClass.QueryPch()
                 : REG_CLASS_UNKNOWN ;

    //  Create the key

    err = ::RegCreateKeyEx( *this,
			    (TCHAR *) nlsSubKey.QueryPch(),
                            REG_TITLE_VALUE_RESERVED,
			    (TCHAR *) pszClassName,
			    prncStruct->ulOptions,
			    prncStruct->regSam,
			    pSecAttr,
			    & pRkNew->_hKey,
			    & prncStruct->ulDisposition ) ;

    if ( err == 0 )
    {
        //  Give the child a name.

        err = NameChild( pRkNew, nlsSubKey ) ;
    }
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::Close

    SYNOPSIS:	Close the underlying handle. (private)

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	APIERR	from  RegCloseKey()  operation

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Close ()
{
    _lApiErr = 0 ;

    if (    _hKey != NULL
         && _hKey != HKEY_CURRENT_USER
         && _hKey != HKEY_LOCAL_MACHINE )
    {
	_lApiErr = ::RegCloseKey( _hKey ) ;
	_hKey = NULL ;
    }
    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor using only an HKEY.

    ENTRY:	hKey	           either HKEY_CURRENT_USER
			               or HKEY_LOCAL_MACHINE
                const NLS_STR *    optional subkey name
                rsDesired          optional access mask

    EXIT:

    RETURNS:

    NOTES:	This routine is used to create REG_KEYs representing
		the primary Registry access points; i.e., those
		represented by statically defined handles.

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: REG_KEY (
    HKEY hKey,
    REGSAM rsDesired )
    : _lApiErr( 0 ),
      _amMask( rsDesired ),
      _hKey( hKey )
{
    const TCHAR * pszKeyName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    if ( hKey == HKEY_LOCAL_MACHINE )
    {
	pszKeyName = REG_NAME_LOCAL_MACHINE ;
    }
    else
    if ( hKey == HKEY_CURRENT_USER )
    {
        pszKeyName = REG_NAME_CURRENT_USER ;
    }
    else
    {
	 UIASSERT( ! SZ("Invalid attempt to create static REG_KEY") ) ;
	 _lApiErr = ERROR_INVALID_PARAMETER ;
    }

    //  See if the HKEY given was one of the allowable ones

    if ( _lApiErr == 0 )
    {
        _lApiErr = _nlsKeyName.CopyFrom( pszKeyName ) ;
    }

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Standard constructor of a REG_KEY.  Using a currently
		opened REG_KEY (such as REG_KEY_LOCAL_MACHINE), open
		a subkey of that node.

    ENTRY:	regNode     reference to extant REG_KEY

	        nlsSubKey   name of subkey to open

		amMask	    special Registry access mask bits;
			    default 0

		poaAttr     pointer to object attributes structure
			    default NULL

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: REG_KEY (
    REG_KEY & regNode,
    const NLS_STR & nlsSubKey,
    REGSAM amMask )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( amMask )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = regNode.OpenChild( this, nlsSubKey, amMask ) ;

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor which creates a new sub-key


    ENTRY:	regNode     reference to extant REG_KEY

		nlsSubKey   name of sub-key

		prcCreate   pointer to REG_KEY_CREATE_STRUCT
			    with all the other parameters.

    EXIT:	Nothing

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY :: REG_KEY (
    REG_KEY & regNode,
    const NLS_STR & nlsSubKey,
    REG_KEY_CREATE_STRUCT * prcCreate )
    : _lApiErr( 0 ),
      _hKey( NULL )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = regNode.CreateChild( this, nlsSubKey, prcCreate ) ;

    if ( _lApiErr  )
    {
	ReportError( _lApiErr ) ;
    }
}


/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor of a key on another machine.

    ENTRY:	hKey		   one of HKEY_LOCAL_MACHINE or
				   HKEY_CURRENT_USER
		pszMachineName	   name of remote machine:
                                   MUST BE IN UNC FORM!, \\MACHINENAME

    EXIT:

    RETURNS:

    NOTES:      This constructor should not be used to address the local
                machine.

                This constructor is used to begin access to the
		Registry on a remote machine.  Only the given static
		HKEYs can be used to create the first REG_KEY; after
		that, the created REG_KEY can be used to access
		any other points within the remote Registry.

    HISTORY:
		DavidHov   9/20/91    Created
		JonN       5/06/92    Implemented
                DavidHov   6/1/92     Revised implementation

********************************************************************/

REG_KEY :: REG_KEY (
    HKEY hKey,
    const TCHAR * pszMachineName,
    REGSAM rsDesired )
    : _lApiErr( 0 ),
      _hKey( NULL ),
      _amMask( rsDesired )
{
    const TCHAR * pszBaseName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    if ( pszMachineName != NULL )
    {
        //
        //  Build up a base registry name of the from:
        //     \\MachineName\Machine\ThisIsMySubKey
        //
        _nlsKeyName.Append( pszMachineName ) ;
        _nlsKeyName.Append( PATHSEPSTRING ) ;
    }

    if ( hKey == HKEY_LOCAL_MACHINE )
    {
	pszBaseName = REG_NAME_LOCAL_MACHINE ;
    }
    else
    if ( hKey == HKEY_CURRENT_USER )
    {
	pszBaseName = REG_NAME_CURRENT_USER ;
    }

    if ( pszBaseName == NULL )
    {
        _lApiErr = ERROR_INVALID_PARAMETER ;
    }
    else
    {
        _nlsKeyName.Append( pszBaseName ) ;

        if ( (_lApiErr = _nlsKeyName.QueryError()) == 0 )
        {
            _lApiErr = ::RegConnectRegistry( (LPTSTR) pszMachineName,
                                             hKey,
                                             &_hKey );
        }
    }

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:       REG_KEY::OpenByName

    SYNOPSIS:   Open a Registry handle using only a name string

    ENTRY:      const NLS_STR & nlsKeyName      full name of key
                REGSAM rsDesired                access desired

    EXIT:       Nothing

    RETURNS:    Nothing

    NOTES:      This routine is based upon the manifests:

                      REG_NAME_CURRENT_USER   "User"
                      REG_NAME_LOCAL_MACHINE  "Machine"

                These are pseudonyms for HKEY_CURRENT_USER and
                HKEY_LOCAL_MACHINE, respectively.  They are prefixed
                onto names produced by QueryName() if "full names" are
                desired.  They are NOT exposed, since all such name
                strings should only be obtained from REG_KEY::QueryName().

                This function is useful for restoring Registry locations
                which have previously been converted to textual form.
                For example, an app calls QueryName(), and writes
                the result into a disk file.  Later, the app reloads
                this information and wants to reconstruct the
                corresponding REG_KEY.  This constructor provides
                this support.

    HISTORY:    DavidHov    2/13/92     Created

********************************************************************/
APIERR REG_KEY :: OpenByName (
    const NLS_STR & nlsKeyName,
    REGSAM rsDesired )
{
    HKEY hKey = NULL ;
    NLS_STR nlsName,
            nlsServer ;

    //  Strip  "[\\Server\]User\" or "[\\Server\]Machine\" from
    //  the given name.   If successful, check if it's remote; do
    //  the open accordingly.

    if ( ! HandlePrefix( nlsKeyName, & hKey, & nlsServer, & nlsName ) )
    {
        _lApiErr = ERROR_INVALID_PARAMETER ;
    }
    else
    if ( nlsServer.QueryTextLength() == 0 )
    {
        // Open a local key.

        REG_KEY rkTop( hKey, rsDesired ) ;

        if ( (_lApiErr = rkTop.QueryError()) == 0 )
           _lApiErr = rkTop.OpenChild( this, nlsName, rsDesired ) ;
    }
    else
    {
        //  Connect to a remote server.

        REG_KEY rkTop( hKey, nlsServer.QueryPch(), rsDesired ) ;

        if ( (_lApiErr = rkTop.QueryError()) == 0 )
           _lApiErr = rkTop.OpenChild( this, nlsName, rsDesired ) ;
    }

    return _lApiErr ;
}

/*******************************************************************

    NAME:       REG_KEY::REG_KEY

    SYNOPSIS:   Construct a REG_KEY from a pure string name.

    ENTRY:      NLS_STR

    EXIT:       Nothing

    RETURNS:    Nothing

    NOTES:

    HISTORY:    DavidHov    2/13/92     Created

********************************************************************/
REG_KEY :: REG_KEY (
    const NLS_STR & nlsKeyName,
    REGSAM amMask )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( amMask )
{
    HKEY hKey = NULL ;
    NLS_STR * pnlsName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = OpenByName( nlsKeyName, amMask ) ;

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}


/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Copy constructor for REG_KEY.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY :: REG_KEY ( REG_KEY & regNode )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( regNode._amMask )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = OpenByName( regNode._nlsKeyName, _amMask ) ;

    if ( _lApiErr )
        ReportError( _lApiErr ) ;
}


/*******************************************************************

    NAME:	REG_KEY::~ REG_KEY

    SYNOPSIS:	Destructor

    ENTRY:	nothing

    EXIT:

    RETURNS:	nothing

    NOTES:	Destroy a REG_KEY.  If it represents an open HKEY,
		close the key.	If the node has children, their subkey
		name strings are modified to have this node's subkey
		name as a prefix, and they become children of this
		node's parent.

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: ~ REG_KEY ()
{
    Close() ;
}

/*******************************************************************

    NAME:	REG_KEY::Flush

    SYNOPSIS:	Commit any changes to the given node to disk.

    ENTRY:	Nothing.

    EXIT:	Nothing.

    RETURNS:	Error associated with operation.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Flush ()
{
    return ::RegFlushKey( _hKey ) ;
}

/*******************************************************************

    NAME:	REG_KEY::Delete

    SYNOPSIS:	Delete the Registry node represented by this REG_KEY.

		It is the caller's responsibility to delete all
		subkeys from this key.	The Registry will delete all
		values for this key automatically.

    ENTRY:	Nothing.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Delete ()
{
    APIERR err = 0 ;

    REG_KEY * prkParent = OpenParent() ;

    if ( prkParent == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        err = prkParent->QueryError() ;
    }

    if ( err == 0 )
    {
        Close();

        err = ::RegDeleteKey( prkParent->_hKey,
                              (TCHAR *) LeafKeyName() ) ;
    }
    delete prkParent ;
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryName

    SYNOPSIS:	Fill in the caller's NLS_STR with a complete
		path name back to the root node.  The root
                node name is included if 'fComplete' is TRUE.

    ENTRY:	NLS_STR *     -->  String to fill in
		BOOL fComplete	   if TRUE, top node name appended.

    EXIT:	string constructed.

    RETURNS:	APIERR	from NLS_STR construction.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created
		DavidHov  10/20/92    Modified to handle UNC names

********************************************************************/

APIERR REG_KEY :: QueryName ( NLS_STR * pnlsName, BOOL fComplete ) const
{
    const TCHAR * pszKeyName = _nlsKeyName.QueryPch() ;

    if ( ! fComplete )
    {
        //  Determine the number of slashes we're looking for.

        INT cchDelims = 1,
            cchUnc = ::strlenf( UNCSEPARATOR ) ;

        if ( ::strncmpf( pszKeyName, UNCSEPARATOR, cchUnc ) == 0 )
        {
            // UNC name; there's three more slashes to eat
            cchDelims += cchUnc + 1 ;
        }

        // Strip off the topmost name ("[\\Server\]User\" or "[\\Server\]Machine\")

        for ( ; *pszKeyName != 0 && cchDelims ; pszKeyName++ )
        {
            if ( *pszKeyName == PATHSEPARATOR )
                cchDelims-- ;
        }
    }

    return pnlsName->CopyFrom( pszKeyName ) ;
}

/*******************************************************************

    NAME:	REG_KEY::QueryKeyName

    SYNOPSIS:	Fill in the caller's NLS_STR with final
                portion of this key's name.		

    ENTRY:	NLS_STR *     -->  String to fill in

    EXIT:	string constructed.

    RETURNS:	APIERR	from NLS_STR construction.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: QueryKeyName ( NLS_STR * pnlsName ) const
{
    return pnlsName->CopyFrom( LeafKeyName() ) ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryLocalMachine

    SYNOPSIS:	Return a new REG_KEY representing
		the top of tree for the local machine.

    ENTRY:	nothing

    EXIT:	pointer or NULL.

    RETURNS:	Pointer to requested REG_KEY.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY * REG_KEY :: QueryLocalMachine ( REGSAM rsDesired )
{
    return new REG_KEY( HKEY_LOCAL_MACHINE, rsDesired ) ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryCurrentUser

    SYNOPSIS:	Return a new REG_KEY representing
		the top of tree for the current user.

    ENTRY:	nothing

    EXIT:	pointer or NULL.

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY * REG_KEY :: QueryCurrentUser ( REGSAM rsDesired )
{
    return new REG_KEY( HKEY_CURRENT_USER, rsDesired ) ;
}

/*******************************************************************

    NAME:	REG_KEY::QueryInfo

    SYNOPSIS:	Query information about a node in the Regsitry.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: QueryInfo ( REG_KEY_INFO_STRUCT * pRegInfoStruct )
{
    TCHAR szClassName [ REGNAMEMAX ] ;
    ULONG ulCbClassName = sizeof szClassName ;
    APIERR err ;

    _lApiErr = ::RegQueryInfoKey( _hKey,
				  szClassName,
				  & ulCbClassName,
				  NULL,
				  & pRegInfoStruct->ulSubKeys,
				  & pRegInfoStruct->ulMaxSubKeyLen,
				  & pRegInfoStruct->ulMaxClassLen,
				  & pRegInfoStruct->ulValues,
				  & pRegInfoStruct->ulMaxValueIdLen,
				  & pRegInfoStruct->ulMaxValueLen,
                                  & pRegInfoStruct->ulSecDescLen,
				  & pRegInfoStruct->ftLastWriteTime );

    if ( (err = _lApiErr) == 0 )
    {
	pRegInfoStruct->nlsName = _nlsKeyName ;
        if ( pRegInfoStruct->nlsName.QueryError() )
        {
            err = pRegInfoStruct->nlsName.QueryError() ;
        }
        else
        {
	    pRegInfoStruct->nlsClass = szClassName ;
            if ( pRegInfoStruct->nlsName.QueryError() )
            {
                err = pRegInfoStruct->nlsName.QueryError() ;
            }
        }
    }
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryValue

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The member functions QueryValue() and SetValue()
		use a common structure to simplify the interface:
		REG_VALUE_INFO_STRUCT.	Its fields are used by
		QueryValue() as:

		    huaValueName	IN:  atom for name
		    ulTitle		OUT: title index
		    ulType		OUT: type scalar
		    pwcData		IN:  location to store data
		    ulDataLength	IN:  room available at *pwcData
		    ulDataLengthOut	OUT: length of value data in buffer

		In other words, the value data stored into
		the data buffer given as input. The amount of data present
		will be stored into "ulDataLengthOut".	If a size
		error occurs,  ulDataLengthOut will contain the amount of
		data that was present, and the contents of *pwcData are
		undefined.


    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: QueryValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo )
{
    pRegValueInfo->ulDataLengthOut = pRegValueInfo->ulDataLength ;

    _lApiErr = ::RegQueryValueEx( _hKey,
				(TCHAR *) pRegValueInfo->nlsValueName.QueryPch(),
				NULL,
				& pRegValueInfo->ulType,
				pRegValueInfo->pwcData,
				& pRegValueInfo->ulDataLengthOut );

    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::SetValue

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      As of 5/14/92, this routine allows the setting of a
                zero-length string.

    HISTORY:
		DavidHov   9/20/91    Created
                DavidHov   5/14/92    Changed for zero length data.

********************************************************************/
APIERR REG_KEY :: SetValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo )
{
    TCHAR chNull = 0 ;
    DWORD cbData = pRegValueInfo->ulDataLength ;
    LPBYTE pbData = pRegValueInfo->pwcData ;

    //  If the data length is zero, replace it with a single NUL
    //   byte/word.  Use a TCHAR so it will work for either the
    //   A or W form of the API.

    if ( cbData == 0 )
    {
        pbData = (LPBYTE) & chNull ;
        cbData = sizeof chNull ;
    }

    if ( pRegValueInfo->ulType == REG_NONE )
	pRegValueInfo->ulType = REG_DEFAULT_TYPE ;

    _lApiErr = ::RegSetValueEx( _hKey,
				(TCHAR *) pRegValueInfo->nlsValueName.QueryPch(),
                                REG_TITLE_VALUE_RESERVED,
				pRegValueInfo->ulType,
				pbData,
				cbData );

    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::DeleteValue

    SYNOPSIS:   Delete a value using an NLS_STR name

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: DeleteValue ( const NLS_STR & nlsValueName )
{
    _lApiErr = ::RegDeleteValue( _hKey,
				 (TCHAR *) nlsValueName.QueryPch() ) ;
    return _lApiErr ;
}


/*******************************************************************

    NAME:	REG_ENUM::REG_ENUM

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_ENUM :: REG_ENUM ( REG_KEY & regNode )
    : _rnNode( regNode ),
    _ulIndex( 0 ),
    _usLastErr( NERR_Success ),
    _eType( RENUM_NONE )
{
}

REG_ENUM :: ~ REG_ENUM ()
{
}

VOID REG_ENUM :: Reset ()
{
    _usLastErr = NERR_Success ;
    _ulIndex = 0 ;
    _eType = RENUM_NONE ;
}

/*******************************************************************

    NAME:	REG_ENUM::NextSubKey

    SYNOPSIS:	Obtain information about the next REG_KEY sub-key
		attached to the node used during construction.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_ENUM :: NextSubKey ( REG_KEY_INFO_STRUCT * pRegInfoStruct )
{
    TCHAR szKeyName   [REGNAMEMAX + 2] ;
    ULONG cbSzKeyName = REGNAMEMAX * sizeof (TCHAR) ;
    LONG lApiErr ;

    if ( _eType != RENUM_NONE && _eType != RENUM_KEYS )
    {
        return ERROR_INVALID_PARAMETER ;
    }

    szKeyName[0] = 0 ;

    lApiErr = ::RegEnumKeyEx( _rnNode._hKey,
			    _ulIndex,
			    szKeyName,
			    & cbSzKeyName,
			    NULL,
			    NULL,
			    NULL,
			    & pRegInfoStruct->ftLastWriteTime );

    if ( lApiErr == 0 )
    {
	pRegInfoStruct->nlsName 	  = szKeyName ;
	pRegInfoStruct->nlsClass	  = SZ("") ;
	pRegInfoStruct->ulSubKeys	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxSubKeyLen	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulValues	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxValueIdLen   = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxValueLen	  = REG_VALUE_NOT_KNOWN ;
	_ulIndex++ ;

        if (   (pRegInfoStruct->nlsName.QueryError())
            || (pRegInfoStruct->nlsName.QueryError()) )
            lApiErr = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return _usLastErr = lApiErr ;
}

/*******************************************************************

    NAME:	REG__ENUM::NextValue

    SYNOPSIS:	Obtain information about the next value
		attached to the node used during construction.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_ENUM :: NextValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo  )
{
    TCHAR szValueName [REGNAMEMAX + 2] ;
    ULONG cbValueName = sizeof (TCHAR) * REGNAMEMAX ;

    if ( _eType != RENUM_NONE && _eType != RENUM_VALUES )
    {
        return ERROR_INVALID_PARAMETER ;
    }

    pRegValueInfo->ulDataLengthOut = pRegValueInfo->ulDataLength ;

    LONG lApiErr = ::RegEnumValue( _rnNode._hKey,
				_ulIndex,
				szValueName,
				& cbValueName,
				NULL,
				& pRegValueInfo->ulType,
				pRegValueInfo->pwcData,
				& pRegValueInfo->ulDataLengthOut );

    if ( lApiErr == 0 )
    {
	pRegValueInfo->nlsValueName = szValueName ;
	_ulIndex++ ;
        if ( pRegValueInfo->nlsValueName.QueryError() )
            lApiErr = ERROR_NOT_ENOUGH_MEMORY ;
    }
    return _usLastErr = lApiErr ;
}

// End of REGKEY.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\istraux.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    istraux.cxx
    NLS/DBCS-aware string class: secondary methods of index class

    This file contains the implementation of the auxiliary methods
    for the ISTR class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx
	beng	    26-Apr-1991     Relocated some funcs from string.hxx

*/

#include "pchstr.hxx"  // Precompiled header




/*******************************************************************

    NAME:	ISTR::Reset

    SYNOPSIS:	Reset the ISTR so the index is 0;
		updates the version number of the string.

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

VOID ISTR::Reset()
{
    SetIch(0);
#ifdef NLS_DEBUG
    SetVersion( QueryString()->QueryVersion() );
#endif
}


/*******************************************************************

    NAME:	ISTR::operator-

    SYNOPSIS:	Returns the difference in TCHAR between the two ISTR

    NOTES:
	Should this return instead an unsigned difference?

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

INT ISTR::operator-( const ISTR& istr2 ) const
{
    UIASSERT( QueryString() == istr2.QueryString() );

    return ( QueryIch() - istr2.QueryIch() );
}


/*******************************************************************

    NAME:	ISTR::operator++

    SYNOPSIS:	Increment the ISTR to the next logical character

    NOTES:	Stops if we are at the end of the string

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    23-Jul-1991 Simplified CheckIstr
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

ISTR& ISTR::operator++()
{
    QueryString()->CheckIstr( *this );
    TCHAR c = *(QueryString()->QueryPch() + QueryIch());
    if ( c != TCH('\0') )
    {
#if defined(UNICODE)
	++_ichString;
#else
	SetIch( QueryIch() + (IS_LEAD_BYTE(c) ? 2 : 1) );
#endif
    }
    return *this;
}


/*******************************************************************

    NAME:	ISTR::operator+=

    SYNOPSIS:	Increment the ISTR to the nth logical character

    NOTES:	Stops if we are at the end of the string

    HISTORY:
	Johnl	    14-Jan-1990 Created
	beng	    21-Nov-1991 Unicode optimization

********************************************************************/

VOID ISTR::operator+=( INT cch )
{
#if defined(UNICODE)
    QueryString()->CheckIstr( *this );

    const TCHAR * psz = QueryString()->QueryPch();
    INT ich = QueryIch();

    while (cch-- && (psz[ich] != TCH('\0')))
	++ich;

    SetIch(ich);

#else
    while ( cch-- )
	operator++();
#endif
}


/*******************************************************************

    NAME:	ISTR::operator==

    SYNOPSIS:	Equality operator

    RETURNS:	TRUE if the two ISTRs are equivalent.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator==( const ISTR& istr ) const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() == istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::operator>

    SYNOPSIS:	Greater-than operator

    RETURNS:	TRUE if this ISTR points further into the string
		than the argument.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator>( const ISTR& istr )  const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() > istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::operator<

    SYNOPSIS:	Lesser-than operator

    RETURNS:	TRUE if this ISTR points less further into the string
		than the argument.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator<( const ISTR& istr )  const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() < istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::IsLastPos

    SYNOPSIS:	Predicate: does istr index the last character in string?

    RETURNS:	Boolean value

    HISTORY:
	yi-hsins    14-Oct-1991 (created as inline fcn)
	beng	    21-Nov-1991 Implementation outlined

********************************************************************/

BOOL ISTR::IsLastPos() const
{
    return (*(QueryString()->QueryPch() + QueryIch() + 1)) == TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\mappers.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mappers.cxx
    Charset-mapping classes, internal to string: implementation

    FILE HISTORY:
        beng        02-Mar-1992 Created (from mapcopy.cxx)
        beng        07-May-1992 Use official wchar.h headerfile

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       WCHAR_STRING::WCHAR_STRING

    SYNOPSIS:   Ctor

        Allocates sufficient temporary storage, then maps the given
        MBCS string into a Unicode string.

    ENTRY:      pszSource - given source string, MBCS
                cbCopy    - max number of bytes to copy

    EXIT:       Constructed

    RETURNS:    As per class BASE

    CAVEATS:
        NULL is a perfectly acceptable arg here, and will yield
        another NULL (with cb == 0), as will cbCopy == 0.  This
        works since we typically give this temporary to CopyFrom,
        which will interpret the NULL and set its NLS_STR to empty.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        29-Mar-1992 cbCopy param added
        thomaspa    08-Apr-1992 Fixed bug in non-NUL term'd strings
        beng        24-Apr-1992 Change meaning of cbCopy==0

********************************************************************/

WCHAR_STRING::WCHAR_STRING( const CHAR * pszSource, UINT cbCopy )
    : _pwszStorage(NULL), _cbStorage(0)
{
    if (pszSource == NULL || cbCopy == 0)
        return;

    // If called with cbCopy==CBNLSMAGIC, then the string hasn't been
    // counted, but is instead assumed to end with NUL.

    BOOL fCounted = (cbCopy != CBNLSMAGIC);

    // Convert MBCS to Unicode.  Assumes the worst case (SBCS) for
    // space, doubling the storage expectations.

    UINT cschSource = fCounted ? cbCopy : (::strlen(pszSource));

    _pwszStorage = new WCHAR[cschSource+1]; // pun: counted as csch, passed as cwch
    if (_pwszStorage == NULL)
    {
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }
    _cbStorage = (cschSource+1);

    // I could always give the API all-but-terminator, then append
    // the terminator myself; however, then I couldn't process empty
    // strings.

    UINT cschGiveToApi = fCounted ? cschSource
                                  : (cschSource+1);

    UINT cbRet = ::MultiByteToWideChar(CP_ACP,    // use ANSI Code Page
                                       MB_PRECOMPOSED,
                                       (LPSTR)pszSource,
                                       cschGiveToApi,
                                       _pwszStorage,
                                       _cbStorage);
    if (cbRet == 0)
    {
        ReportError(::GetLastError());
        return;
    }

    // Always NUL-terminate result

    if (fCounted)
        _pwszStorage[cbRet] = 0;
}


/*******************************************************************

    NAME:       WCHAR_STRING::~WCHAR_STRING

    SYNOPSIS:   Dtor

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

WCHAR_STRING::~WCHAR_STRING()
{
    delete _pwszStorage;
#if defined(NLS_DEBUG)
    _pwszStorage = (WCHAR*)(-1);
#endif
}


/*******************************************************************

    NAME:       CHAR_STRING::CHAR_STRING

    SYNOPSIS:   Ctor

        Allocates sufficient temporary storage, then maps the given
        Unicode string into a MBCS string.

    ENTRY:      pwszSource - given wide-char source string, Unicode
                cbCopy     - max number of bytes to copy

    EXIT:       Constructed

    RETURNS:    As per class BASE

    CAVEATS:
        NULL is a perfectly acceptable arg here, and will yield
        another NULL (with cb == 0).

    HISTORY:
        beng        02-Mar-1992 Created
        beng        19-Mar-1992 Fixed bug in WCtoMB usage
        beng        29-Mar-1992 cbCopy param added
        thomaspa    08-Apr-1992 Fixed bug in non-NUL term'd strings
        beng        24-Apr-1992 Change meaning of cbCopy==0
        beng        02-Jun-1992 WCtoMB changed

********************************************************************/

CHAR_STRING::CHAR_STRING( const WCHAR * pwszSource, UINT cbCopy )
    : _pszStorage(NULL), _cbStorage(0)
{
    if (pwszSource == NULL || cbCopy == 0)
        return;

    // If called with cbCopy==CBNLSMAGIC, then the string hasn't been
    // counted, but is instead assumed to end with NUL.

    BOOL fCounted = (cbCopy != CBNLSMAGIC);

    // Convert Unicode to MBCS.  Assumes that each Unicode character will
    // require *two* MBCS characters in xlation.  While this will almost always
    // overestimate storage requirements, it's okay since instances of this
    // class have a very short lifespan (he said, hopefully).

    ASSERT(cbCopy == CBNLSMAGIC || (cbCopy % sizeof(WCHAR) == 0)); // must contain a whole # of WCHARs

    UINT cwchSource = fCounted ? cbCopy/sizeof(WCHAR) : (::wcslen(pwszSource));

    _pszStorage = new CHAR[(2*cwchSource)+1];
    if (_pszStorage == NULL)
    {
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }
    _cbStorage = sizeof(CHAR)*((2*cwchSource)+1); // yes, 2, not "sizeof WCHAR"

    // I could always give the API all-but-terminator, then append
    // the terminator myself; however, then I couldn't process empty
    // strings.

    UINT cwchGiveToApi = fCounted ? cwchSource
                                  : (cwchSource+1);

    BOOL fDummy;
    UINT cbRet = ::WideCharToMultiByte(CP_ACP,    // use ANSI Code Page
                                       0,
                                       (LPWSTR)pwszSource,
                                       cwchGiveToApi,
                                       _pszStorage,
                                       _cbStorage,
                                       NULL,
                                       &fDummy);
    if (cbRet == 0)
    {
        ReportError(::GetLastError());
        return;
    }

    // Always NUL-terminate result

    if (fCounted)
        _pszStorage[cbRet] = 0;
}


/*******************************************************************

    NAME:       CHAR_STRING::~CHAR_STRING

    SYNOPSIS:   Dtor

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

CHAR_STRING::~CHAR_STRING()
{
    delete _pszStorage;
#if defined(NLS_DEBUG)
    _pszStorage = (CHAR*)(-1);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strassgn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strassgn.cxx
    NLS/DBCS-aware string class: assignment operator

    This file contains the implementation of the assignment operator
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::operator=

    SYNOPSIS:   Assignment operator

    ENTRY:      Either NLS_STR or TCHAR*.

    EXIT:       If successful, contents of string overwritten.
                If failed, the original contents of the string remain.

    RETURNS:    Reference to self.

    HISTORY:
        beng        23-Oct-1990 Created
        johnl       13-Nov-1990 Added UIASSERTion checks for using bad
                                strings
        beng        05-Feb-1991 Uses TCHAR * instead of PCH
        Johnl       06-Mar-1991 Removed assertion check for *this
                                being valid
        johnl       12-Apr-1991 Resets error variable on PCH assignment
                                if successful.
        beng        22-Jul-1991 Allow assignment of an erroneous string;
                                reset error on nls assignment as well
        beng        14-Nov-1991 Unicode fixes
        beng        29-Mar-1992 Relocated guts to CopyFrom

********************************************************************/

NLS_STR & NLS_STR::operator=( const NLS_STR & nlsSource )
{
    APIERR err = CopyFrom(nlsSource);

    if (err != NERR_Success)
        ReportError(err);

    return *this;
}


NLS_STR & NLS_STR::operator=( const TCHAR * pchSource )
{
    APIERR err = CopyFrom(pchSource);

    if (err != NERR_Success)
        ReportError(err);

    return *this;
}


/*******************************************************************

    NAME:       NLS_STR::CopyFrom

    SYNOPSIS:   Assignment method which returns an error code

    ENTRY:
        nlsSource   - source argument, either a nlsstr or char vector.
        achSource
        cbCopy      - max number of bytes to copy from source

    EXIT:
        Copied argument into this.  Error code of string set.

    RETURNS:
        Error code of string - NERR_Success if successful.

    NOTES:
        If the CopyFrom fails, the current string will retain its
        original contents and error state.

    HISTORY:
        beng        18-Sep-1991 Created
        beng        19-Sep-1991 Added content-preserving behavior
        beng        29-Mar-1992 Added cbCopy parameter
        beng        24-Apr-1992 Changed meaning of cbCopy == 0

********************************************************************/

APIERR NLS_STR::CopyFrom( const NLS_STR & nlsSource )
{
    // This deliberately doesn't check this->QueryError(), since
    // it can reset an erroneous string.

    if (!nlsSource)
        return nlsSource.QueryError();

    if (this == &nlsSource)
        return NERR_Success;

    if (!Realloc(nlsSource.QueryTextLength()))
        return ERROR_NOT_ENOUGH_MEMORY;

    ::memcpy( _pchData, nlsSource.QueryPch(), nlsSource.QueryTextSize() );
    _cchLen = nlsSource.QueryTextLength();
    IncVers();

    // Reset the error state, since the string is now valid.
    //
    ResetError();
    return NERR_Success;
}


APIERR NLS_STR::CopyFrom( const TCHAR * pchSource, UINT cbCopy )
{
    if ( pchSource == NULL || cbCopy == 0 )
    {
        if ( !IsOwnerAlloc() && QueryAllocSize() == 0 )
        {
            Alloc(0); // will call reporterror if appropriate
            return QueryError();
        }

        UIASSERT( QueryAllocSize() > 0 );

        *_pchData = TCH('\0');
        _cchLen = 0;
    }
    else if (cbCopy == CBNLSMAGIC)
    {
        UINT cchSource = ::strlenf( pchSource );
        UINT cbSource = (cchSource+1) * sizeof(TCHAR);

        if (!Realloc(cchSource))
            return ERROR_NOT_ENOUGH_MEMORY;

        ::memcpy( _pchData, pchSource, cbSource );
        _cchLen = cchSource;
    }
    else
    {
        // Following takes care of half-chars, but isn't necessarily
        // safe in a DBCS environment.  I'm assuming that this fcn will
        // be used by folks who want to copy from a complete, yet non-SZ
        // string (e.g. in a struct UNICODE_STRING); there, it's safe.

        UINT cchSource = cbCopy/sizeof(TCHAR);
        UINT cbSource = cchSource*sizeof(TCHAR);

        if (!Realloc(cchSource))
            return ERROR_NOT_ENOUGH_MEMORY;

        ::memcpy( _pchData, pchSource, cbSource );
        _pchData[cchSource] = 0;
        _cchLen = cchSource;
    }

    IncVers();

    // Reset the error state, since the string is now valid.
    //
    ResetError();
    return NERR_Success;
}


/*******************************************************************

    NAME:       ALIAS_STR::operator=

    SYNOPSIS:   Assignment operator

    ENTRY:      Either NLS_STR or TCHAR*.

    EXIT:       If successful, string aliases new string.
                If failed, the original contents of the string remain.

    RETURNS:    Reference to self.

    NOTES:
        An alias string can only alias a char vector (string literal)
        or an owner-alloc string.  It can't alias a regular dynamic
        string, since that dynamic string may elect to realloc.

    HISTORY:
        beng        14-Nov-1991 Created
        beng        30-Mar-1992 Use BASE::ResetError

********************************************************************/

const ALIAS_STR & ALIAS_STR::operator=( const NLS_STR & nlsSource )
{
    if ( this == &nlsSource )
    {
        // No action needed
        ;
    }
    else if (!nlsSource)
    {
        // Assignment of an erroneous string
        //
        ReportError(nlsSource.QueryError());
    }
    else if (!nlsSource.IsOwnerAlloc())
    {
        // Tried to assign a dynamic string
        //
        ReportError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _pchData = nlsSource._pchData;
        _cbData = nlsSource._cbData;
        _cchLen = nlsSource._cchLen;
        IncVers();
        ResetError();
    }

    return *this;
}

const ALIAS_STR & ALIAS_STR::operator=( const TCHAR * pszSource )
{
    if (pszSource == NULL)
    {
        // It is not legal to assign a NULL pointer to an alias string,
        // since such a string must have some real string to alias.
        //
        ReportError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _pchData = (TCHAR*)pszSource; // cast away constness
        _cchLen = ::strlenf(pszSource);
        _cbData = (_cchLen + 1) * sizeof(TCHAR);
        IncVers();
        ResetError();
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\stratol.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratol.cxx
    NLS/DBCS-aware string class: atol method

    This file contains the implementation of the atol method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      31-Oct-1991     Change atol to strtol
        beng        08-Mar-1992     Include "mappers.hxx"
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atol

    SYNOPSIS:   Returns *this in its long numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.
        Given an ISTR, starts at that point within the string.

    RETURNS:    Value as a long integer

    HISTORY:
        johnl       26-Nov-1990 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        terryk      31-Oct-1991 Change atol to strtol
        beng        08-Mar-1992 Unicode fixes

********************************************************************/

LONG NLS_STR::atol() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atol(istr);  // call through to other version
}


LONG NLS_STR::atol( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );
    CHAR *pszEndPoint;

#if defined(UNICODE)
    // BUGBUG - revisit this mess when we get propert CRT Unicode support

    // Convert Unicode to ASCII to keep the runtimes happy

    CHAR_STRING xsszTemp(QueryPch(istrStart));
    if (!xsszTemp)
        return 0;

    return ::strtol( xsszTemp.QueryData(), &pszEndPoint, 10 );
#else
    return ::strtol( QueryPch(istrStart), &pszEndPoint, 10 );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strcat.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcat.cxx
    NLS/DBCS-aware string class: strcat method

    This file contains the implementation of the strcat method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
*/

#include "pchstr.hxx"  // Precompiled header


#ifndef min
inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}
#endif

/*******************************************************************

    NAME:       NLS_STR::strcat

    SYNOPSIS:   Concantenate string

    ENTRY:      nlsSuffix - appended to end of string

    EXIT:       Self extended, possibly realloced.
                String doesn't change if a memory allocation failure occurs

    RETURNS:    Reference to self.  Error set on failure.

    NOTES:
        NLS_STR::Append() is the preferred form.

    HISTORY:
        johnl       13-Nov-1990 Written
        beng        22-Jul-1991 Allow on erroneous strings
        beng        15-Nov-1991 Unicode fixes
        beng        07-Mar-1992 Reloc guts into Append fcn

********************************************************************/

NLS_STR & NLS_STR::strcat( const NLS_STR & nlsSuffix )
{
    if (QueryError() || !nlsSuffix)
        return *this;

    APIERR err = Append(nlsSuffix);

    if (err)
        ReportError(err);

    return *this;
}


/*******************************************************************

    NAME:       NLS_STR::Append

    SYNOPSIS:   Append a string to the end of current string

    ENTRY:      nlsSuffix - a string

    EXIT:       nlsSuffix was appended to end of string

    RETURNS:    Error code.  NERR_Success if successful; ERROR_NOT
                ENOUGH_MEMORY should a reallocation fail.

    NOTES:
        Currently checks to see if we need to reallocate the
        string (but we have to traverse it to determine the
        actual storage required).  We may want to change this.

    HISTORY:
        beng        22-Jul-1991 Created (parallel of AppendChar)
        beng        05-Mar-1992 Return the error of a bad argument
        beng        07-Mar-1992 Start at end of string (avoid n**2 behavior)

********************************************************************/

APIERR NLS_STR::Append( const NLS_STR &nlsSuffix )
{
    if (!*this)
        return QueryError();
    if (!nlsSuffix)
        return nlsSuffix.QueryError();

    if (!Realloc( QueryTextLength() + nlsSuffix.QueryTextLength()))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Don't use strcatf, since it will retraverse the string, giving
    // O(n**2) behavior in loops.  After all, we do have _cchLen handy.

    ::strcpyf( _pchData + _cchLen, nlsSuffix.QueryPch() );
    _cchLen += nlsSuffix.QueryTextLength();

    return 0;
}


/*******************************************************************

    NAME:       NLS_STR::AppendChar

    SYNOPSIS:   Append a single character to the end of current string

    ENTRY:      wch - appended to end of string

    EXIT:       String has the new character.  Could result in a realloc.

    RETURNS:    0 if successful

    HISTORY:
        beng        23-Jul-1991 Created
        beng        15-Nov-1991 Unicode fixes

********************************************************************/

APIERR NLS_STR::AppendChar( WCHAR wch )
{
    // This works by assembling a temporary string of the single
    // character, then using the "strcat" member to append that
    // string to *this.
    //
    // CODEWORK: might do well to append the char directly to the
    // subject string.  Need to profile and see.

    TCHAR tch [3] ;

#if defined(UNICODE)

    tch[0] = wch ;
    tch[1] = 0 ;

#else

    if (HIBYTE(wch) == 0)
    {
        // Single-byte character
        tch[0] = LOBYTE(wch);
        tch[1] = TCH('\0');
    }
    else
    {
        // Double-byte character
        tch[0] = HIBYTE(wch); // lead byte
        tch[1] = LOBYTE(wch);
        tch[2] = TCH('\0');
    }

#endif

    ALIAS_STR nlsTemp( tch ) ;

    return Append(nlsTemp);
}


/*******************************************************************

    NAME:       NLS_STR::operator+=

    SYNOPSIS:   Append a string to the end of current string

    ENTRY:      nlsSecond - appended to end of string

    EXIT:

    RETURNS:

    NOTES:      Little more than a wrapper around strcat.

    HISTORY:
        beng        23-Jul-1991     Header added

********************************************************************/

NLS_STR & NLS_STR::operator+=( const NLS_STR & nlsSecond )
{
    return strcat( nlsSecond );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strchr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strchr.cxx
    NLS/DBCS-aware string class: strchr method

    This file contains the implementation of the strchr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strchr

    SYNOPSIS:	Puts the index of the first occurrence of ch in *this
		into istrPos.


    ENTRY:	pistrPos - points to ISTR in which to leave pos
		ch	 - character sought
		istrStart- staring point in string.  If omitted, start
			   at beginning

    EXIT:	pistrPos

    RETURNS:	TRUE if character found; otherwise FALSE

    NOTES:
	This routine only works for TCHAR - not WCHAR.
	Hence it is useless for double-byte characters
	under MBCS.

    HISTORY:
	johnl	    26-Nov-1990 Written
	beng	    22-Jul-1991 Allow on erroneous strings;
				simplified CheckIstr
	beng	    21-Nov-1991 Unicode fixes

********************************************************************/

BOOL NLS_STR::strchr( ISTR * pistrPos, const TCHAR ch ) const
{
    if ( QueryError() )
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strchrf( QueryPch(), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( QueryTextLength() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strchr( ISTR * pistrPos, const TCHAR ch,
		      const ISTR & istrStart ) const
{
    if ( QueryError() )
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strchrf( QueryPch(istrStart), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( QueryTextLength() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\stratoul.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratoul.cxx
    NLS/DBCS-aware string class: atol method

    This file contains the implementation of the atoul method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      31-Oct-1991     Change atol to strtol
        beng        08-Mar-1992     Include "mappers.hxx"
	terryk	    20-Apr-1992	    Change to atoul
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atoul

    SYNOPSIS:   Returns *this in its unsigned long numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.
        Given an ISTR, starts at that point within the string.

    RETURNS:    Value as a long integer

    HISTORY:
        johnl       26-Nov-1990 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        terryk      31-Oct-1991 Change atol to strtol
        beng        08-Mar-1992 Unicode fixes
	terryk	    20-Apr-1992 Change to atoul

********************************************************************/

ULONG NLS_STR::atoul() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atoul(istr);  // call through to other version
}


ULONG NLS_STR::atoul( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );
    CHAR *pszEndPoint;

#if defined(UNICODE)
    // BUGBUG - revisit this mess when we get propert CRT Unicode support

    // Convert Unicode to ASCII to keep the runtimes happy

    CHAR_STRING xsszTemp(QueryPch(istrStart));
    if (!xsszTemp)
        return 0;

    return ::strtoul( xsszTemp.QueryData(), &pszEndPoint, 10 );
#else
    return ::strtoul( QueryPch(istrStart), &pszEndPoint, 10 );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\mapcopy.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mapcopy.cxx
    Methods which map character sets, copying to or from the string

    Where the environment requires no mapping (e.g. Map-To WCHAR
    in a Unicode env), these routines perform a naive copy.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        08-Mar-1992 Broke out [W]CHAR_STRING into mappers
*/

#include "pchstr.hxx"  // Precompiled header



/*******************************************************************

    NAME:       NLS_STR::MapCopyFrom

    SYNOPSIS:   Copy new data into string, mapping into alternate charset

    ENTRY:
        pwszSource   - source argument, either a WCHAR* or CHAR*
        cbCopy       - the maximum number of bytes to copy from the
                       source.  0 will set the current string to empty;
                       CBNLSMAGIC (the default value) assumes that the
                       source string is NUL-terminated.

    EXIT:
        Copied argument into this.

    RETURNS:
        NERR_Success if successful.  Otherwise, errorcode.

    NOTES:
        If the operation fails, the current string will retain its
        original contents and error state.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        29-Mar-1992 Added cbCopy param
        beng        24-Apr-1992 Change meaning of cbCopy == 0

********************************************************************/

APIERR NLS_STR::MapCopyFrom( const CHAR * pszSource, UINT cbCopy )
{
#if defined(UNICODE)

    // Does translation before copyfrom - necessary in order to
    // retain original string as late as possible.  Temp object
    // makes rollback convenient.

    WCHAR_STRING xwszTemp(pszSource, cbCopy);

    APIERR err = xwszTemp.QueryError();
    if (err != NERR_Success)
        return err;

    return CopyFrom(xwszTemp.QueryData());

#else
    return CopyFrom(pszSource, cbCopy);
#endif
}


APIERR NLS_STR::MapCopyFrom( const WCHAR * pwszSource, UINT cbCopy )
{
#if defined(UNICODE)
    return CopyFrom(pwszSource, cbCopy);
#else

    CHAR_STRING xsszTemp(pwszSource, cbCopy);

    APIERR err = xsszTemp.QueryError();
    if (err != NERR_Success)
        return err;

    return CopyFrom(xsszTemp.QueryData());

#endif
}


/*******************************************************************

    NAME:       NLS_STR::MapCopyTo

    SYNOPSIS:   Copy string data, mapping into alternate charset

    ENTRY:
        pwchDest   - pointer to destination buffer, either WCHAR* or CHAR*
        cbAvailable- size of available buffer in bytes

    RETURNS:
        NERR_Success if successful.  Otherwise, errorcode.

    NOTES:
        At present, only MBCS<->Unicode mappings are supported.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        19-Mar-1992 Fixed bug in WCtoMB usage
        beng        02-Jun-1992 WCtoMB changed again

********************************************************************/

APIERR NLS_STR::MapCopyTo( CHAR * pchDest, UINT cbAvailable ) const
{
#if defined(UNICODE)

    // No need to allocate any temp object here - this is a const fcn

    BOOL fDummy;
    UINT cb = ::WideCharToMultiByte(CP_ACP,    // use ANSI Code Page
                                    0,
                                    _pchData,
                                    QueryTextSize() / sizeof(WCHAR),
                                    pchDest,
                                    cbAvailable,
                                    NULL,
                                    &fDummy);

    return (cb == 0) ? ::GetLastError() : NERR_Success;

#else
    return CopyTo(pchDest, cbAvailable);
#endif
}


APIERR NLS_STR::MapCopyTo( WCHAR * pwchDest, UINT cbAvailable ) const
{
#if defined(UNICODE)
    return CopyTo(pwchDest, cbAvailable);
#else

    UINT cb = ::MultiByteToWideChar(CP_ACP,     // use ANSI Code Page
                                    MB_PRECOMPOSED,
                                    _pchData,
                                    QueryTextSize(),
                                    pwchDest,
                                    cbAvailable / sizeof(WCHAR));

    return (cb == 0) ? ::GetLastError() : NERR_Success;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\stratoi.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratoi.cxx
    NLS/DBCS-aware string class: atoi method

    This file contains the implementation of the atoi method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        markbl      04-Jun-1991     Created

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atoi

    SYNOPSIS:   Returns *this in its integer numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.

        Given an ISTR, starts at that point within the string.

    EXIT:

    NOTES:      Uses C-Runtime atoi function

    HISTORY:
        markbl      04-Jun-1991 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        beng        08-Mar-1992 Call through to atol member fcn

********************************************************************/

INT NLS_STR::atoi() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atoi(istr);  // call through to other version
}


INT NLS_STR::atoi( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );

    LONG nRes = atol(istrStart);

    // Check for over/underflow
    if (nRes < (LONG)INT_MIN || nRes > (LONG)INT_MAX)
    {
        return 0;
    }

    return (INT)nRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strcpy.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcpy.cxx
    NLS/DBCS-aware string class: strcpy function

    This file contains the implementation of the strcpy function
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        02-Mar-1992 Added CopyTo

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::CopyTo

    SYNOPSIS:   Copies the string to the passed bytevector,
                checking the length

    ENTRY:      pchDest     - pointer to TCHAR array destination
                cbAvailable - bytes of storage available at destination

    EXIT:       pchDest  - written

    RETURNS:
        NERR_Success if successful.
        ERROR_NOT_ENOUGH_MEMORY if destination buffer too small.

    NOTES:
        If called on an erroneous string, returns that string's error state.

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

APIERR NLS_STR::CopyTo( TCHAR * pchDest, UINT cbAvailable ) const
{
    if (QueryError())
        return QueryError();

    if (QueryTextSize() > cbAvailable)
        return ERROR_NOT_ENOUGH_MEMORY;

    ::strcpyf(pchDest, QueryPch());
    return NERR_Success;
}


/*******************************************************************

    NAME:       NLS_STR::strcpy

    SYNOPSIS:   Copies the string to the passed bytevector.

    ENTRY:      pchDest  - pointer to TCHAR array destination
                nls      - source string

    EXIT:       pchDest  - written

    RETURNS:    Destination string (as C runtime "strcpy")

    NOTES:
        If called on an erroneous string, copies a null string.

    HISTORY:
        Johnl       27-Dec-1990 Created
        beng        23-Jul-1991 Allow from erroneous strings
        beng        21-Nov-1991 Remove static empty string

********************************************************************/
DLL_BASED
TCHAR * strcpy( TCHAR * pchDest, const NLS_STR& nls )
{
    if (!nls)
    {
        *pchDest = TCH('\0');
        return pchDest;
    }
    else
    {
        return ::strcpyf( pchDest, nls.QueryPch() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strcspn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strcspn.cxx
    NLS/DBCS-aware string class: strcspn method

    This file contains the implementation of the strcspn method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strcspn

    SYNOPSIS:	Set membership.  Finds the first matching character
		in the passed string

    ENTRY:	pistrPos - destination for results
		nls	 - set of sought characters

    EXIT:	*pistrPos contains offset within "this" of element
		found (assuming it was successful); otherwise it
		is moved to the end of the string.

    RETURNS:	TRUE if any character found; FALSE otherwise

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous strings;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strcspn( ISTR* pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    pistrPos->SetIch( ::strcspnf( QueryPch(), nls.QueryPch() ) );
    return *QueryPch( *pistrPos ) != TCH('\0');
}


BOOL NLS_STR::strcspn( ISTR * pistrPos,
		       const NLS_STR & nls,
		       const ISTR & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );
    CheckIstr( istrStart );

    pistrPos->SetIch( ::strcspnf( QueryPch(istrStart), nls.QueryPch() )
		     + istrStart.QueryIch()  );
    return *QueryPch( *pistrPos ) != TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strcmp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcmp.cxx
    NLS/DBCS-aware string class: strcmp method and equality operator

    This file contains the implementation of the strcmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        jonn        04-Sep-1992     Compare() is _CRTAPI1

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::operator==

    SYNOPSIS:   Case-sensitive test for equality

    RETURNS:    TRUE if the two operands are equal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        johnl       11-Nov-90       Written
        beng        23-Jul-1991     Allow on erroneous strings

********************************************************************/

BOOL NLS_STR::operator==( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
        return FALSE;

    return !::strcmpf( QueryPch(), nls.QueryPch() );
}


/*******************************************************************

    NAME:       NLS_STR::Compare

    SYNOPSIS:   Case-sensitive test for equality

    RETURNS:    TRUE if the two operands are equal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        jonn        04-Sep-1992     Compare must be _CRTAPI1

********************************************************************/

INT __cdecl NLS_STR::Compare( const NLS_STR * pnls ) const
{
    return(strcmp(*pnls));
}


/*******************************************************************

    NAME:       NLS_STR::operator!=

    SYNOPSIS:   Case-sensitive test for inequality

    RETURNS:    TRUE if the two operands are unequal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        beng        23-Jul-1991     Header added

********************************************************************/

BOOL NLS_STR::operator!=( const NLS_STR & nls ) const
{
    return ! operator==( nls );
}


/*******************************************************************

    NAME:       NLS_STR::strcmp

    SYNOPSIS:   Standard string compare with optional character indexes

    ENTRY:      nls                   - string against which to compare
                istrStart1 (optional) - index into "this"
                istrStart2 (optional) - index into "nls"

    RETURNS:    As the C runtime "strcmp".

    NOTES:      If either string is erroneous, return "match."
                This runs contrary to the eqop.

                Glock doesn't allow default parameters which require
                construction; hence this member is overloaded multiply.

    HISTORY:
        johnl       15-Nov-1990     Written
        johnl       19-Nov-1990     Changed to use ISTR, overloaded for
                                    different number of ISTRs
        beng        23-Jul-1991     Allow on erroneous strings;
                                    simplified CheckIstr

********************************************************************/

INT NLS_STR::strcmp( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
        return 0;

    return ::strcmpf( QueryPch(), nls.QueryPch() );
}

INT NLS_STR::strcmp(
    const NLS_STR & nls,
    const ISTR    & istrStart1 ) const
{
    if (QueryError() || !nls)
        return 0;

    CheckIstr( istrStart1 );

    return ::strcmpf( QueryPch(istrStart1) , nls.QueryPch() );
}

INT NLS_STR::strcmp(
    const NLS_STR & nls,
    const ISTR    & istrStart1,
    const ISTR    & istrStart2 ) const
{
    if (QueryError() || !nls)
        return 0;

    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strcmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strelaps.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    strelaps.cxx
    Class definitions for the ELAPSED_TIME_STR class.


    FILE HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

*/
#include "pchstr.hxx"  // Precompiled header

//
//  ELAPSED_TIME_STR methods
//

/*******************************************************************

    NAME:           ELAPSED_TIME_STR :: ELAPSED_TIME_STR

    SYNOPSIS:       ELAPSED_TIME_STR class constructor.

    ENTRY:          ulTime              - Elapsed time (in seconds).

                    chTimeSep           - The current time separator.

                    fShowSeconds        - If TRUE, then a 'seconds' field
                                          will be appended to the time
                                          string.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

********************************************************************/
ELAPSED_TIME_STR :: ELAPSED_TIME_STR( ULONG ulTime,
                                      TCHAR chTimeSep,
                                      BOOL  fShowSeconds )
  : NLS_STR()
{
    UIASSERT( chTimeSep != TCH('\0') );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Create an NLS_STR for the time separator.
    //

    TCHAR szTimeSep[2];

    szTimeSep[0] = chTimeSep;
    szTimeSep[1] = TCH('\0');

    ALIAS_STR nlsTimeSep( szTimeSep );
    UIASSERT( nlsTimeSep.QueryError() == NERR_Success );

    APIERR err;

    //
    //  Concatenate the hours/sep/minutes[/sep/seconds] together.
    //

    {
        DEC_STR nls( ulTime / 3600L, 2 );

        err = nls.QueryError();

        if( err == NERR_Success )
        {
            strcat( nls );
            err = QueryError();
        }
    }

    if( err == NERR_Success )
    {
        strcat( nlsTimeSep );
        err = QueryError();

        if( err == NERR_Success )
        {
            DEC_STR nls( ( ulTime % 3600L ) / 60L, 2 );

            err = nls.QueryError();

            if( err == NERR_Success )
            {
                strcat( nls );
                err = QueryError();
            }
        }
    }

    if( fShowSeconds && ( err == NERR_Success ) )
    {
        strcat( nlsTimeSep );
        err = QueryError();

        if( err == NERR_Success )
        {
            DEC_STR nls( ulTime % 60L, 2 );

            err = nls.QueryError();

            if( err == NERR_Success )
            {
                strcat( nls );
                err = QueryError();
            }
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // ELAPSED_TIME_STR :: ELAPSED_TIME_STR


/*******************************************************************

    NAME:           ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR

    SYNOPSIS:       ELAPSED_TIME_STR class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

********************************************************************/
ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strdss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strdss.cxx
    NLS/DBCS-aware string class: DelSubStr method

    This file contains the implementation of the DelSubStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::DelSubStr

    SYNOPSIS:	Collapse the string by removing the characters from
		istrStart to:
			 istrStart  to the end of string
			 istrStart + istrEnd
		The string is not reallocated

    ENTRY:

    EXIT:	Modifies istrStart

    NOTES:
	The method DelSubStr( ISTR&, CCH ) is private and does
	the work.

    HISTORY:
	johnl	    26-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous strings;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

VOID NLS_STR::DelSubStr( ISTR & istrStart,
			 UINT	cchLen )
{
    if (QueryError())
	return;

    CheckIstr( istrStart );

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    // cchLen == 0 means delete to end of string

    if ( cchLen == 0 )
	*pchStart = TCH('\0');
    else
    {
	UINT cbNewEOS = (::strlenf( pchStart + cchLen ) + 1)
			* sizeof(TCHAR);

	::memmove(pchStart, pchStart + cchLen, cbNewEOS);
    }

    _cchLen = ::strlenf( QueryPch() );

    IncVers();
    UpdateIstr( &istrStart );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart )
{
    if (QueryError())
	return;

    // 0 means delete to end of string.  (Deleting a 0-length substring
    // is meaningless otherwise, so this makes a good magic value.  It
    // will never otherwise appear, since the public interface special-
    // cases the istrEnd == istrStart scenario.)

    DelSubStr( istrStart, 0 );
}


VOID NLS_STR::DelSubStr(       ISTR & istrStart,
			 const ISTR & istrEnd  )
{
    if (QueryError())
	return;

    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    if (istrEnd == istrStart)
	return;

    DelSubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\stricmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    stricmp.cxx
    NLS/DBCS-aware string class: stricmp method

    This file contains the implementation of the stricmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::stricmp

    SYNOPSIS:	Case insensitive string compare w/ optional indices

    ENTRY:	nls		      - string against which to compare
		istrStart1 (optional) - index into "this"
		istrStart2 (optional) - index into "nls"

    RETURNS:	As the C runtime "strcmp".

    NOTES:	If either string is erroneous, return "match."
		This runs contrary to the eqop.

		Glock doesn't allow default parameters which require
		construction; hence this member is overloaded multiply.

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous strings;
				    simplified CheckIstr

********************************************************************/

INT NLS_STR::_stricmp( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return 0;

    return ::stricmpf( QueryPch(), nls.QueryPch() );
}


INT NLS_STR::_stricmp(
    const NLS_STR & nls,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrStart1 );

    return ::stricmpf( QueryPch(istrStart1), nls.QueryPch() );
}


INT NLS_STR::_stricmp(
    const NLS_STR & nls,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::stricmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\stris.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    stris.cxx
    NLS/DBCS-aware string class: InsertStr method

    This file contains the implementation of the InsertStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::InsertStr

    SYNOPSIS:	Insert passed string into *this at istrStart

    ENTRY:

    EXIT:	If this function returns FALSE, ReportError has been
		called to report the error that occurred.

    RETURN:	TRUE on success, FALSE otherwise.

    NOTES:	If *this is not STR_OWNERALLOCed and the inserted string
		won't fit in the allocated space for *this, then *this
		will be reallocated.

    HISTORY:
	johnl	    28-Nov-1990 Created
	rustanl     14-Apr-1991 Fixed new length calculation.  Report
				error if owner alloc'd and not enough space.
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

BOOL NLS_STR::InsertStr( const NLS_STR & nlsIns, ISTR & istrStart )
{
    if (QueryError() || !nlsIns)
	return FALSE;

    CheckIstr( istrStart );

    INT cchNewSize = QueryTextLength() + nlsIns.QueryTextLength();

    if (!Realloc(cchNewSize))
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return FALSE;
    }

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    ::memmove(pchStart + nlsIns.QueryTextLength(),
	      pchStart,
	      (::strlenf(pchStart)+1) * sizeof(TCHAR) );
    ::memmove(pchStart,
	      nlsIns._pchData,
	      nlsIns.QueryTextSize() - sizeof(TCHAR) );

    _cchLen = cchNewSize;

    IncVers();
    UpdateIstr( &istrStart );	    // This ISTR does not become invalid
				    // after the string update
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strinsrt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strinsrt.cxx
    NLS/DBCS-aware string class: InsertParams method

    This file contains the implementation of the InsertParams method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        Johnl       31-Jan-1991 Created
        beng        07-Feb-1991 Uses lmui.hxx
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        28-Jul-1992 Fix conflicting def'n of MAX_INSERT_PARAMS
*/

#include "pchstr.hxx"  // Precompiled header


#define PARAM_ESC         TCH('%')


/*******************************************************************

    NAME:      NLS_STR::InsertParams

    SYNOPSIS:  Fill in a message string from the resource file
               replacing the number parameters with the real text.

    ENTRY:     *this contains the message text
               apnlsParams is an array of pointers to NLS_STRs

               Example:

                 *this = "Error %1 occurred, do %2, or %1 will happen again"
                 apnlsParams[0] = "696969"
                 apnlsParams[1] = "Something else"

                 Return string = "Error 696969 occurred, do Something else or
                                  696969 will happen again"

               Alternately, cpnlsArgs gives the number of strings supplied,
               followed on the stack by the appropriate number of string
               pointers.

    EXIT:      0 if successful, error code otherwise, one of:
                   ERROR_INVALID_PARAMETER
                   ERROR_NOT_ENOUGH_MEMORY

    NOTES:
        The minimum parameter is 1, the maximum parameter is 99.

        The array of param strings must have a NULL to mark
        the end of the array.

    CAVEATS:
        This function doesn't work quite the same way as does the NT
        FormatMessage API.  It very simplemindedly substitutes those
        escape sequences found, but doesn't do anything else with %
        sequences (such as %%).

    HISTORY:
        JohnL       1/30/91     Created
        beng        26-Apr-1991 Uses WCHAR
        beng        23-Jul-1991 Allow on erroneous string
        beng        20-Nov-1991 Unicode fixes
        beng        27-Feb-1992 Additional forms
        beng        05-Mar-1992 Upped max params to 99; code sharing rewrite
        YiHsinS     30-Nov-1992 Make this function work more like FormatMessage
			        Supports %0, %\,...
        YiHsinS     23-Dec-1992 Use "%\" instead of "%n" and added support
  				for "%t"

********************************************************************/

APIERR NLS_STR::InsertParams( const NLS_STR ** apnlsParams )
{
    if (QueryError())
        return QueryError();

    // How many parameters were we passed?  Count and check each.
    //
    UINT cParams = 0;
    while ( apnlsParams[cParams] != NULL )
    {
        APIERR err = apnlsParams[cParams]->QueryError();
        if (err != NERR_Success)
            return err;

        ++cParams;
    }

    if ( cParams > MAX_INSERT_PARAMS )
        return ERROR_INVALID_PARAMETER;

    // Determine total string length required for the expanded string
    // and get out if we can't fulfill the request
    //

    UINT cchMax = 0;
    APIERR err = InsertParamsAux(apnlsParams, cParams, FALSE, &cchMax);
    if (err != NERR_Success)
        return err;
    ASSERT(cchMax != 0);

    if ( !Realloc( cchMax ) )
        return ERROR_NOT_ENOUGH_MEMORY;

    // Now do the parameter substitution.
    //
    return InsertParamsAux(apnlsParams, cParams, TRUE, NULL);
}


APIERR NLS_STR::InsertParams( UINT cpnlsArgs, const NLS_STR * parg1, ... )
{
    va_list v;

    const NLS_STR * * apnlsList = (const NLS_STR * *) new NLS_STR * [ cpnlsArgs + 1 ] ;
    if (NULL == apnlsList) return ERROR_NOT_ENOUGH_MEMORY; // JonN 01/23/00: PREFIX bug 444888

    apnlsList[0] = parg1;

    va_start(v, parg1);
    for ( UINT i = 1 ; i < cpnlsArgs ; ++i )
    {
        const NLS_STR * pnlsArgNext = (const NLS_STR *)va_arg(v, NLS_STR*);
        apnlsList[i] = pnlsArgNext;
    }
    va_end(v);
    apnlsList[cpnlsArgs] = NULL;

    APIERR err = InsertParams(apnlsList);
    delete (NLS_STR * *) apnlsList;
    return err;
}


/*******************************************************************

    NAME:      NLS_STR::InsertParamsAux

    SYNOPSIS:  Helper routine for InsertParams

        This routine allows code sharing between the loop which calcs
        the storage needed in the resulting string and the loop which
        performs the actual parameter insertion.

    ENTRY:
            apnlsParams       - vector of parameter strings to insert,
                                NULL-terminated.
            cParams           - count of items in above vector
            fDoReplace        - set to TRUE if caller wants actual
                                substitution performed.
            pcchRequired      - points to storage for char count,
                                or NULL if not desired

    EXIT:
            pcchRequired      - instantiated with count of characters
                                required (if non-NULL).
            *this             - if fDoReplace, substitution performed

    RETURNS:
        NERR_Success if successful
        ERROR_INVALID_PARAMETER if something wrong with format string
        (e.g. invalid insert specifier).
        Other errors possible as a result of the substitution.

    NOTES:
        This is a private member function.

        InsertParams calls this routine twice while doing its duty.
        The first call calculates the storage required; after that,
        it resizes the string appropriately, then calls this again
        to perform the actual substitution.

        See NLS_STR::InsertParams for more discussion.

    HISTORY:
        beng        05-Mar-1992 Created (code sharing within InsertParams)

********************************************************************/

APIERR NLS_STR::InsertParamsAux( const NLS_STR ** apnlsParams,
                                 UINT cParams, BOOL fDoReplace,
                                 UINT * pcchRequired )
{
    // If pcchRequired is non-NULL, then the caller wants this
    // routine to figure the amount of storage the total param-subbed
    // string would require (TCHARs, less terminator).

    UINT cchMax = (pcchRequired != NULL) ? QueryTextLength() : 0;

    ISTR istrCurPos( *this );
    while ( strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
    {
        ISTR istrParamEsc( istrCurPos );
        WCHAR wchParam = QueryChar( ++istrCurPos );

        //
        // If this PARAM_ESC didn't delimit an insertion point,
        // continue as if nothing had happened.
        //
        if ( wchParam < TCH('1') || wchParam > TCH('9') )
            continue;

        // CurPos now points to one or two decimal digits.
        // Time for a quick and cheap numeric conversion within this range.

        UINT iParam = (wchParam - TCH('0'));
        wchParam = QueryChar(++istrCurPos);
        if (wchParam >= TCH('0') && wchParam <= TCH('9'))
        {
            iParam *= 10;
            iParam += (wchParam - TCH('0'));
            ++istrCurPos;
        }

        // N.b. Escape sequences are 1-base, but array indices 0-base
        //
        iParam -= 1;

        if (iParam >= cParams)
            continue;

        if (pcchRequired != NULL)
        {
            // Adjust calculation of required storage.  The PARAM_ESC
            // and its following digits will be deleted; the parameter
            // string, inserted.

            cchMax -= (istrCurPos - istrParamEsc);
            cchMax += apnlsParams[iParam]->QueryTextLength();
        }

        if (fDoReplace)
        {
            ReplSubStr( *apnlsParams[iParam],
                        istrParamEsc,
                        istrCurPos );

            // CurPos was invalidated, revalidate
            istrCurPos = istrParamEsc;
            istrCurPos += apnlsParams[iParam]->QueryTextLength();
        }
    }

    if (pcchRequired != NULL)
        *pcchRequired = cchMax;

    return QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strncmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strncmp.cxx
    NLS/DBCS-aware string class: strncmp method

    This file contains the implementation of the strncmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strncmp

    SYNOPSIS:	Case sensitve string compare up to index position istrLen

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrEnd );

    return ::strncmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIch() );
}


INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );

    return ::strncmpf( QueryPch(istrStart1),
		       nls.QueryPch(),
		       istrEnd - istrStart1 );
}


INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    UIASSERT( istrEnd.QueryIch() >= istrStart2.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strncmpf( QueryPch(istrStart1),
		       nls.QueryPch(istrStart2),
		       istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strlist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strlist.cxx
    String List Class : implementation

    See string.hxx

    FILE HISTORY:
        chuckc      2-Jan-1991      Created
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      11-Jul-1991     Add the fDestroy parameter in the
                                    constructors. The fDestroy parameter is
                                    used to indicate whether you want the
                                    slist destructor to delete the element or
                                    not.
        KeithMo     09-Oct-1991     Win32 Conversion.
        beng        17-Jun-1992     Remove single-string ctors
*/

#include "pchstr.hxx"  // Precompiled header


#if !defined(LM_2)
DEFINE_EXT_SLIST_OF(NLS_STR)
#endif


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    NOTES:
                The default constructor creates an empty string.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST( BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    this->Clear();
}


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      valid strings in pszSrc, pszSep
                BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    EXIT:       if pszSrc & pszSep have valid nonempty string,
                we end up with STRLIST as describe below. Else
                and empty STRLIST if anything goes wrong.

    NOTES:      Takes a Src string of tokens, and a Sep string
                of separators. We end up with a STRLIST with the
                source string being broken into its tokens. Multiple
                separators are allowed, contigous separators in the Src
                string are handled.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST(const TCHAR * pszSrc, const TCHAR * pszSep, BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    // call out to worker routine
    CreateList(pszSrc, pszSep) ;
}


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      NLS_STR & strSrc - original string
                NLS_STR & strSep - the separator string
                BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    NOTES:
                as STRLIST(const TCHAR *   pszSrc, const TCHAR * pszSep),
                except we take NLS_STR instead of PSZ.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST(const NLS_STR & strSrc, const NLS_STR & strSep, BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    // call worker, passing it the char * to the strings.
    CreateList(strSrc.QueryPch(), strSep.QueryPch()) ;
}


/*******************************************************************

    NAME:       STRLIST::~STRLIST

    SYNOPSIS:   Destructor for STRLIST

    NOTES:      clears the strlist, freeing the memory.

    HISTORY:
        chuckc      2-Jan-1991      Created

********************************************************************/

STRLIST::~STRLIST()
{
    this->Clear();
}


/*******************************************************************

    NAME:       STRLIST::WriteToBuffer

    SYNOPSIS:   Writes the contents of STRLIST to PSZ format,
                using separators specified by pszSep.

    ENTRY:      TCHAR * pszDest - destination
                INT cbDest - bytes in destination
                TCHAR * pszSep - separator string

    EXIT:       return code

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        26-Apr-1991     Replaced CB with INT

********************************************************************/

INT STRLIST::WriteToBuffer(
    TCHAR * pszDest,
    INT    cbDest,
    TCHAR * pszSep )
{
    INT    cbSize ;
    NLS_STR *pStr ;
    ITER_STRLIST iter_strlist(*this) ;

    // check for non empty separator string
    if (!pszSep  || !*pszSep)
        return(0) ;

    // check for valid buffer & size
    if (pszDest == NULL || cbDest < (cbSize = QueryBufferSize(pszSep)))
        return(0) ;

    // write out to pszDest.
    *pszDest = TCH('\0') ;
    if ( pStr = iter_strlist() )
    {
        ::strcatf(pszDest,pStr->QueryPch()) ;
        while ( pStr = iter_strlist() )
        {
            ::strcatf(pszDest,pszSep) ;
            ::strcatf(pszDest,pStr->QueryPch()) ;
        }
    }

    // return the number of bytes written
    return(cbSize) ;
}


/*******************************************************************

    NAME:       STRLIST::QueryBufferSize

    SYNOPSIS:   Query the number of bytes required by WriteToBuffer()

    ENTRY:      TCHAR * pszSep - separator

    EXIT:       return code

    HISTORY:
        chuckc      2-Jan-1991  Created
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

INT STRLIST::QueryBufferSize( TCHAR * pszSep )
{
    INT      cbSep;                     // doesn't include terminators
    INT      cbSize = sizeof(TCHAR);    // for a NUL terminator
    NLS_STR *pStr;

    // separator is required
    if (!pszSep || ((cbSep = ::strlenf(pszSep)*sizeof(TCHAR)) == 0))
        return(0) ;

    // create an iterator for the strlist
    ITER_STRLIST iter_strlist(*this) ;
    while ( pStr = iter_strlist() )
    {
        // add each len plus separator
        cbSize += (pStr->strlen() + cbSep) ;
    }

    // take off last separator if any
    return (cbSize > sizeof(TCHAR)) ? (cbSize - cbSep) : (cbSize);
}


/*******************************************************************

    NAME:       STRLIST::CreateList

    SYNOPSIS:   Parses a Src string for tokens separated by
                separator characters in the Sep string, and
                generates a STRLIST of these tokens.

    ENTRY:      TCHAR * pszSrc - source string
                TCHAR * pszSep - separator string

    EXIT:

    NOTES:
        This worker of the STRLIST accepts 2 strings. The first
        contains any number of 'tokens' separated by any character in
        the second. Note I avoided strtok() to minimize effect on
        others.

    HISTORY:
        chuckc      2-Jan-1991  Created
        beng        26-Apr-1991 Replaced PSZ with TCHAR*
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

VOID STRLIST::CreateList(const TCHAR * pszSrc, const TCHAR * pszSep)
{
    NLS_STR *pstr ;
    TCHAR *pszBuffer, *pszStart, *pszEnd ;
#if !defined(UNICODE)
    UINT cchSkip;
#endif

    // break out if empty string for Src or Sep
    if (!pszSrc || !*pszSrc || !pszSep || !*pszSep)
        return;

    // clear the str list
    this->Clear();

    // allocate temp buffer
    if ( !(pszBuffer = new TCHAR[::strlenf(pszSrc)+1]) )
    {
        // empty list if no memory
        return ;
    }

    // make copy & skip past leading separators
    ::strcpyf( pszBuffer, pszSrc ) ;
    pszStart = pszBuffer + ::strspnf( pszBuffer, pszSep ) ;

    // zip thru, adding each one to the strlist
    while (pszStart && *pszStart)
    {
        // find next separator if any, and null terminate at that point
        if (pszEnd = ::strpbrkf( pszStart, pszSep ))
        {
#if !defined(UNICODE)
            // keep track if 1 or 2 byte separator
            cchSkip = (IS_LEAD_BYTE(*pszEnd) ? 2 : 1) ;
#endif
            *pszEnd = TCH('\0') ;
        }

        // make new string and add to strlist
        if (!(pstr = new NLS_STR(pszStart))
            || (this->Append(pstr) != 0))
        {
            // either no memeory or failed to add, so quit
            this->Clear();
            return ;
        }

        if (pszEnd == NULL)
            // nothing more, might as well bag now
            break ;
        else
        {
            // skip past the separator we found earlier
#if defined(UNICODE)
            pszStart = pszEnd + 1;
#else
            pszStart = pszEnd + cchSkip ;
#endif
            // now skip past any other leading separators
            pszStart = pszStart +
                       ::strspnf( pszStart, pszSep ) ;
        }
    }

    delete pszBuffer ;  // delete temp buffer
}


/*******************************************************************

    NAME:       ITER_STRLIST::ITER_STRLIST

    SYNOPSIS:   Constructor for ITER_STRLIST

    ENTRY:      STRLIST & strl - the string list

    NOTES:
        The constructor just passes the STRLIST to the collector class

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        30-Apr-1991     Modern constructor syntax

********************************************************************/

ITER_STRLIST::ITER_STRLIST( STRLIST & strl ) :
    ITER_SL_OF(NLS_STR)(strl)
{
    ; // nothing to do
}


/*******************************************************************

    NAME:       ITER_STRLIST::ITER_STRLIST

    SYNOPSIS:   Constructor for ITER_STRLIST

    ENTRY:      ITER_STRLIST & iter_strl - iterator of the string list

    NOTES:
        The constructor just passes the STRLIST to the collector class

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        30-Apr-1991     Modern constructor syntax

********************************************************************/

ITER_STRLIST::ITER_STRLIST( const ITER_STRLIST & iter_strl ) :
    ITER_SL_OF(NLS_STR)( iter_strl )
{
    ; // nothing to do
}


/*******************************************************************

    NAME:       ITER_STRLIST::~ITER_STRLIST

    SYNOPSIS:   Destructor for ITER_STRLIST

    NOTES:      The destructor do nothing.

    HISTORY:
        chuckc      2-Jan-1991      Created

********************************************************************/

ITER_STRLIST::~ITER_STRLIST()
{
    ; // nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strload.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strload.cxx
    NLS/DBCS-aware string class:  LoadString methods

    This file contains the implementation of the LoadString methods
    for the NLS_STR class.  It is separate so that clients of NLS_STR who
    do not use this operator need not link to it.

    FILE HISTORY:
        rustanl     31-Jan-1991     Created
        beng        07-Feb-1991     Uses lmui.hxx
        beng        27-Jul-1992     No longer links to uimisc
        Yi-HsinS    14-Aug-1992     Make method "load" load system strings too
*/

#include "pchstr.hxx"  // Precompiled header

extern "C"
{
    //  Define the "default" HMODULE for use in this load function
    extern HMODULE hmodBase ;
}

#define NETMSG_DLL_STRING SZ("netmsg.dll")


/*******************************************************************

    NAME:       NLS_STR::Load

    SYNOPSIS:   Loads a string from a resource file.

    ENTRY:      msgid   - ID of the string resource to load
                hmod    - the module instance to use for the load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    NOTES:
        This function was created to allow separate BLT from the
        NLS classes.

    HISTORY:
        DavidHov    17-Sep-1993 Created

********************************************************************/

APIERR NLS_STR::Load ( MSGID msgid, HMODULE hmod )
{
    if ( msgid < IDS_UI_BASE )
    {
        return LoadSystem( msgid );
    }

    // Since I'm reading the data directly from the system, I need a
    // new "transmutable" type which corresponds to what the SYSTEM
    // contains.  Conceivably this could be compiled ifndef UNICODE on
    // a UNICODE-native Win32 world.  Ordinarily LoadString handles
    // this for the client - oh, for a portable SizeofString!

#if defined(WIN32)
    typedef WCHAR   XCHAR;
    typedef WORD    UXCHAR;
#else
    typedef CHAR    XCHAR;
    typedef BYTE    UXCHAR;
#endif

    //  Supply the default HMODULE if necessary
    if ( hmod == NLS_BASE_DLL_HMOD )
    {
        hmod = ::hmodBase ;
    }

    const ULONG nRsrc = ((USHORT)msgid >> 4) + 1;

    // Find the packet of strings ("nRsrc" calculated above).

    HRSRC hrsrc = ::FindResource(hmod, (LPTSTR)((ULONG_PTR)nRsrc), RT_STRING);
    if (hrsrc == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }
    HGLOBAL hsegString = ::LoadResource(hmod, hrsrc); // no Free req'd
    if (hsegString == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }
    const XCHAR * pszMess = (const XCHAR *)::LockResource(hsegString);
    if (pszMess == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }

    // Dredge the desired string out of the packet

    UINT iString = (UINT) (msgid & 0x0f);
    UINT cch = 0;
    for (;;)
    {
        cch = (UINT) *(const UXCHAR *)pszMess++; // prefixed by length
        if (iString-- == 0)
            break;
        pszMess += cch; // not this string, so skip it and move along
    }

    if (cch == 0)
    {
#if !defined(WIN32)
        ::UnlockResource(hsegString);
#endif
        return ERROR_MR_MID_NOT_FOUND;
    }

    // Now cch and pszMess have the string, which BTW isn't NUL term'd.
    // Let MapCopyFrom take care of conversion, allocation, termination,
    // marking string as changed, etc.

    APIERR err = MapCopyFrom( pszMess, cch * sizeof(*pszMess) );
#if !defined(WIN32)
    ::UnlockResource(hsegString);
#endif
    return err;
}


/*******************************************************************

    NAME:       NLS_STR::LoadSystem

    SYNOPSIS:   Loads a string from the system's resource files.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    HISTORY:
        beng        05-Aug-1992 Created
        YiHsinS     01-Jan-1993 Use W version of FormatMessage
        DonRyan     18-May-1994 Reintroduced for LM_EVENT_LOG

********************************************************************/

APIERR NLS_STR::LoadSystem( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    HANDLE hmod = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((msgid <= MAX_LANMAN_MESSAGE_ID) && (msgid >= MIN_LANMAN_MESSAGE_ID))
    {
        // Net Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hmod = ::GetModuleHandle( NETMSG_DLL_STRING );
    }
    else   // other system errors
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }


    TCHAR* pchBuffer = NULL;
    UINT cch = (UINT) ::FormatMessage( dwFlags,
                                       hmod,
                                       msgid,
                                       0,
                                       (LPTSTR)&pchBuffer,
                                       1024,
                                       NULL );
    if (cch > 0)
    {
        APIERR err = CopyFrom(pchBuffer);
        ::LocalFree((VOID*)pchBuffer);
        return err;
    }
    else
    {
        return ::GetLastError();
    }
}


/*******************************************************************

    NAME:       RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:   Constructs a nls-string from a resource ID.

    ENTRY:      idResource

    EXIT:       Successful construct, or else ReportError

    NOTES:      This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        DavidHov    17-Sep-1993 Created

********************************************************************/

RESOURCE_STR::RESOURCE_STR( MSGID msgid, HMODULE hmod )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    APIERR err = Load( msgid, hmod );
    if (err)
        ReportError(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strnicmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strnicmp.cxx
    NLS/DBCS-aware string class: strnicmp method

    This file contains the implementation of the strnicmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strnicmp

    SYNOPSIS:	Case insensitve string compare up to index position istrEnd

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrEnd );

    return ::strnicmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIch() );
}


int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );

    return ::strnicmpf(QueryPch(istrStart1),
		       nls.QueryPch(),
		       istrEnd - istrStart1 );
}


int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch()  );
    UIASSERT( istrEnd.QueryIch() >= istrStart2.QueryIch()  );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strnicmpf(QueryPch(istrStart1),
		       nls.QueryPch(istrStart2),
		       istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strnchar.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strnchar.cxx
    NLS/DBCS-aware string class:QueryNumChar method

    This file contains the implementation of the QueryNumChar method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        terryk      04-Apr-1991     Creation

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::QueryNumChar

    SYNOPSIS:   return the total number of character within the string

    RETURNS:    The number of logical character within the string

    NOTES:
        Treats erroneous string as having length 0

    HISTORY:
        terryk      04-Apr-1991 Written
        beng        23-Jul-1991 Allow on erroneous string
        beng        21-Nov-1991 Returns unsigned value

********************************************************************/

UINT NLS_STR::QueryNumChar() const
{
    if (QueryError())
        return 0;

    ISTR  istrCurPos( *this );
    INT   cchCounter = 0;

    for ( ;
          this->QueryChar( istrCurPos ) != TCH('\0');
          ++istrCurPos, cchCounter ++ )
        ;

    return cchCounter;
}


/*******************************************************************

    NAME:       NLS_STR::strlen

    SYNOPSIS:   Returns the number of byte-characters in the string

    RETURNS:    Count of byte-chars, excluding terminator

    NOTES:

    HISTORY:
        beng        22-Jul-1991 Added header
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::strlen() const
{
    return _cchLen*sizeof(TCHAR);
}


/*******************************************************************

    NAME:       NLS_STR::_QueryTextLength

    SYNOPSIS:   Calculate length of text in TCHAR, sans terminator

    RETURNS:    Count of TCHAR

    NOTES:
        Compare QueryNumChar, which returns a number of glyphs.
        In a DBCS environment, this member will return 2 TCHAR for
        each double-byte character, since a TCHAR is there only 8 bits.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::_QueryTextLength() const
{
    return _cchLen;
}


/*******************************************************************

    NAME:       NLS_STR::QueryTextSize

    SYNOPSIS:   Calculate length of text in BYTES, including terminator

    RETURNS:    Count of BYTES

    NOTES:
        QueryTextSize returns the number of bytes needed to duplicate
        the string into a byte vector.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::QueryTextSize() const
{
    return (_cchLen+1)*sizeof(TCHAR);
}


#if defined(UNICODE) && defined(FE_SB)
/*******************************************************************

    NAME:       NLS_STR::QueryAnsiTextLength

    SYNOPSIS:   Calculate length of text in BYTES, including terminator

    RETURNS:    Count of BYTES

    NOTES:
        QueryTextSize returns the number of bytes.
        In DBCS world, QueryTextSize doesn't return actual byte count.

    HISTORY:


********************************************************************/
UINT NLS_STR::QueryAnsiTextLength() const
{
    return ::WideCharToMultiByte(CP_ACP,
                                 0,
                                 QueryPch(),
                                 QueryTextLength(),
                                 NULL,
                                 0,
                                 NULL,
                                 NULL);
}

#endif // UNICODE && FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strqss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strqss.cxx
    NLS/DBCS-aware string class: QuerySubStr method

    This file contains the implementation of the QuerySubStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


// Magic value used below
//
#define CCH_ENTIRE_STRING ((UINT)-1)


/*******************************************************************

    NAME:	NLS_STR::QuerySubStr

    SYNOPSIS:	Return a pointer to a new NLS_STR that contains the contents
		of *this from istrStart to:
			  istrStart end of string or
			  istrStart + istrEnd

    ENTRY:

    EXIT:

    RETURNS:	Pointer to newly alloc'd NLS_STR, or NULL if error

    NOTES:
	The private method QuerySubStr(ISTR&, CCH) is the worker
	method; the other two just check the parameters and
	pass the data. It is private since we can't allow the
	user to access the string on a byte basis

    CAVEAT:
	Note that this method creates an NLS_STR that the client is
	responsible for deleting.

    HISTORY:
	johnl	    26-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB wth INT; broke
				out CB_ENTIRE_STRING magic value
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    21-Nov-1991 Unicode fixes

********************************************************************/

NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart, UINT cchLen ) const
{
    if (QueryError())
	return NULL;

    CheckIstr( istrStart );

    UINT cchStrLen = (UINT)::strlenf(QueryPch(istrStart) );
    UINT cchCopyLen = ( cchLen == CCH_ENTIRE_STRING || cchLen >= cchStrLen )
		       ? cchStrLen
		       : cchLen;

    NLS_STR *pnlsNew = new NLS_STR( cchCopyLen );
    if ( pnlsNew == NULL )
	return NULL;
    if ( pnlsNew->QueryError() )
    {
	delete pnlsNew;
	return NULL;
    }

    ::memcpy( pnlsNew->_pchData, QueryPch(istrStart),
	      cchCopyLen*sizeof(TCHAR) );
    *(pnlsNew->_pchData + cchCopyLen) = TCH('\0');

    pnlsNew->_cchLen = cchCopyLen;

    return pnlsNew;
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart ) const
{
    return QuerySubStr( istrStart, CCH_ENTIRE_STRING );
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR  & istrStart,
				const ISTR  & istrEnd  ) const
{
    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    return QuerySubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strmisc.cxx
    Miscellaneous members of the string classes

    The NLS_STR and ISTR classes have many inline member functions
    which bloat clients, especially in debug versions.  This file
    gives those unhappy functions a new home.


    FILE HISTORY:
        beng        26-Apr-1991     Created (relocated from string.hxx)
        KeithMo     09-Oct-1991     Win32 Conversion.

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::_QueryAllocSize

    SYNOPSIS:   Returns the number of bytes allocated by the object

    RETURNS:    Count of bytes

    NOTES:
        BUGBUG REVIEW - consider making this member private

    HISTORY:
        beng        22-Jul-1991 OwnerAlloc flag moved into own member
        beng        21-Nov-1991 Returns unsigned value

********************************************************************/

UINT NLS_STR::_QueryAllocSize()  const
{
    return _cbData;
}


/*******************************************************************

    NAME:       NLS_STR::CheckIstr

    SYNOPSIS:   Checks association between ISTR and NLS_STR instances

    ENTRY:      istr - ISTR to check against this NLS_STR

    NOTES:
        Does nothing in retail build.

    HISTORY:
        beng        23-Jul-1991     Header added; removed redundant
                                    "nls" parameter.

********************************************************************/

VOID NLS_STR::CheckIstr( const ISTR& istr ) const
{
    UIASSERT( (istr).QueryString() == this );

#if defined(NLS_DEBUG)
    UIASSERT( (istr).QueryVersion() == QueryVersion() );
#else
    UNREFERENCED(istr);
#endif
}


/*******************************************************************

    NAME:       NLS_STR::_IsOwnerAlloc

    SYNOPSIS:   Discriminate owner-alloc strings

    RETURNS:    TRUE if string owner-alloc'd

    NOTES:      BUGBUG REVIEW - consider making private

    HISTORY:
        beng        22-Jul-1991     Made fOwnerAlloc its own member

********************************************************************/

BOOL NLS_STR::_IsOwnerAlloc() const
{
    return _fOwnerAlloc;
}


/*******************************************************************

    NAME:       NLS_STR::_QueryPch

    SYNOPSIS:   Return pointer to string, possibly offset

    ENTRY:      istr (optional) - offset

    RETURNS:    Pointer to string, starting at offset.
                No offset means beginning of string (istr==0).

    HISTORY:
        beng        14-Nov-1991 Header added

********************************************************************/

const TCHAR * NLS_STR::_QueryPch() const
{
    if (QueryError())
        return NULL;

    return _pchData;
}


const TCHAR * NLS_STR::QueryPch( const ISTR& istr ) const
{
    if (QueryError())
        return NULL;

    CheckIstr( istr );
    return _pchData+istr.QueryIch();
}


/*******************************************************************

    NAME:       NLS_STR::QueryChar

    SYNOPSIS:   Return a character at a given offset

    ENTRY:      istr - offset into string

    RETURNS:    Wide character at offset

    NOTES:

    HISTORY:
        beng        14-Nov-1991 Header added

********************************************************************/

WCHAR NLS_STR::QueryChar( const ISTR& istr ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istr );
    return *(_pchData+istr.QueryIch());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strrchr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strrchr.cxx
    NLS/DBCS-aware string class: strrchr method

    This file contains the implementation of the strrchr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strrchr

    SYNOPSIS:	Puts the index of the last occurrence of ch in *this into
		istrPos.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    26-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    update CheckIstr

********************************************************************/

BOOL NLS_STR::strrchr( ISTR * pistrPos, const TCHAR ch ) const
{
    if (QueryError())
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strrchrf( QueryPch(), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strrchr(
	  ISTR	  * pistrPos,
    const TCHAR	    ch,
    const ISTR	  & istrStart ) const
{
    if (QueryError())
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strrchrf(QueryPch(istrStart), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strspn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strspn.cxx
    NLS/DBCS-aware string class: strspn method

    This file contains the implementation of the strspn method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strspn

    SYNOPSIS:	Find first char in *this that is not a char in arg. and puts
		the position in pistrPos.
		Returns FALSE when no characters do not match

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strspn( ISTR * pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    pistrPos->SetIch( ::strspnf( QueryPch(), nls.QueryPch() ) );
    return *QueryPch( *pistrPos ) != TCH('\0');
}


BOOL NLS_STR::strspn( ISTR *	      pistrPos,
		      const NLS_STR & nls,
		      const ISTR    & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( istrStart );

    pistrPos->SetIch( ::strspnf(QueryPch( istrStart ), nls.QueryPch() ) +
		     istrStart.QueryIch()  );
    return *QueryPch( *pistrPos ) != TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strtok.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strtok.cxx
    NLS/DBCS-aware string class: strtok method

    This file contains the implementation of the strtok method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        28-Mar-1992 Withdrew from Unicode builds
*/

#include "pchstr.hxx"  // Precompiled header


#if !defined(UNICODE)

/*******************************************************************

    NAME:       NLS_STR::strtok

    SYNOPSIS:   Basic strtok functionality.  Returns FALSE after the
                string has been traversed.

    ENTRY:

    EXIT:

    NOTES:      We don't update the version on the string since the
                ::strtokf shouldn't cause DBCS problems.  It would also
                be painful on the programmer if on each call to strtok
                they had to update all of the ISTR associated with this
                string

                fFirst is required to be TRUE on the first call to
                strtok, it is FALSE afterwards (is defaulted to FALSE)

    CAVEAT:     Under windows, all calls to strtok must be done while
                processing a single message.  Otherwise another process
                my confuse it.

    HISTORY:
        johnl       26-Nov-1990 Created
        beng        23-Jul-1991 Allow on erroneous string
        beng        21-Nov-1991 Check arg string, too

********************************************************************/

BOOL NLS_STR::strtok(       ISTR *    pistrPos,
                      const NLS_STR & nlsBreak,
                      BOOL            fFirst     )
{
    if (QueryError() || !nlsBreak)
        return FALSE;

    const TCHAR * pchToken = ::strtokf( fFirst ? _pchData : NULL,
                                       (TCHAR *)nlsBreak.QueryPch());

    if ( pchToken == NULL )
    {
        pistrPos->SetIch( QueryTextLength() );
        return FALSE;
    }

    pistrPos->SetIch( pchToken - QueryPch() );
    return TRUE;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strstr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strstr.cxx
    NLS/DBCS-aware string class: strstr method

    This file contains the implementation of the strstr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strstr

    SYNOPSIS:	Returns TRUE if the passed string is found, false otherwise.
		pistrPos contains start of the specified string if TRUE
		is returned.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strstr( ISTR * pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strstrf( QueryPch(), nls.QueryPch() );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strstr(	    ISTR    * pistrPos,
		      const NLS_STR & nls,
		      const ISTR    & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strstrf(QueryPch(istrStart), nls.QueryPch() );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strrss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strrss.cxx
    NLS/DBCS-aware string class: strrss method

    This file contains the implementation of the strrss method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::ReplSubStr

    SYNOPSIS:	Replace a substring with the passed string.

    ENTRY:	If both a start and end is passed, then the operation is
		equivalent to a DelSubStr( start, end ) and an
		InsertSubStr( start ).

		If just a start is passed in, then the operation is
		equivalent to DelSubStr( start ), concat new string to end.

		The ReplSubStr( NLS_STR&, istrStart&, INT cbDel) method is
		private.

    EXIT:	Substring starting at istrStart was replaced with nlsRepl.

    HISTORY:
	johnl	    29-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl, ISTR& istrStart )
{
    if (QueryError() || !nlsRepl)
	return;

    CheckIstr( istrStart );

    DelSubStr( istrStart );
    strcat( nlsRepl );
}


VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl,
				ISTR &	  istrStart,
			  const ISTR &	  istrEnd )
{
    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    ReplSubStr( nlsRepl, istrStart, istrEnd - istrStart );
}


VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl,
				ISTR	& istrStart,
				UINT	  cchToBeDeleted )
{
    if (QueryError() || !nlsRepl)
	return;

    CheckIstr( istrStart );

    INT cchRequired = QueryTextLength() + nlsRepl.QueryTextLength()
		     - cchToBeDeleted;

    if ( !Realloc( cchRequired ) )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    // Make room for the new data, displacing old data as appropriate.
    // Then copy the new data into its position.

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    ::memmove( pchStart + nlsRepl.QueryTextLength(),
	       pchStart + cchToBeDeleted,
	       QueryTextSize() - istrStart.QueryIch()*sizeof(TCHAR) - cchToBeDeleted*sizeof(TCHAR) );

    ::memmove( pchStart,
	       nlsRepl._pchData,
	       nlsRepl.QueryTextSize() - sizeof(TCHAR));

    _cchLen = _cchLen - cchToBeDeleted + nlsRepl.QueryTextLength();

    IncVers();
    UpdateIstr( &istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strupr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strupr.cxx
    NLS/DBCS-aware string class: strupr method

    This file contains the implementation of the strupr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991 Separated from original monolithic .cxx
	beng	    07-Feb-1991 Uses lmui.hxx
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strupr

    SYNOPSIS:	Convert *this lower case letters to upper case

    ENTRY:	String is of indeterminate case

    EXIT:	String is all uppercase

    NOTES:

    HISTORY:
	johnl	    26-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string

********************************************************************/

NLS_STR& NLS_STR::_strupr()
{
    if (!QueryError())
	::struprf( _pchData );

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\skeleton\xstrskel.h ===
#define IDM_ABOUT	100
#define IDM_RUN_TEST	200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\strupoem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strupoem.cxx
    NLS/DBCS-aware string class: RtlOemUpcase method

    This file contains the implementation of the RtlOemUpcase method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        jonn        09-Feb-1994 Created
*/

#include "pchstr.hxx"  // Precompiled header

extern "C"
{
    #include <ntrtl.h>
}

#include "errmap.hxx"


/*******************************************************************

    NAME:	NLS_STR::RtlOemUpcase

    SYNOPSIS:	Convert *this lower case letters to upper case using
                RtlUpcaseUnicodeStringToOemString

    ENTRY:	String is of indeterminate case

    EXIT:	String is all uppercase

    NOTES:

    HISTORY:
        jonn        09-Feb-1994 Created

********************************************************************/

APIERR NLS_STR::RtlOemUpcase()
{
    APIERR err = QueryError();
    if (err != NERR_Success)
    {
        DBGEOL( "NLS_STR::RtlOemUpcase: string already bad " << err );
	return err;
    }

#ifndef UNICODE
#error not coded for non-UNICODE
#endif

    UNICODE_STRING unistr;
    unistr.Length = (USHORT)(QueryTextLength()*sizeof(WCHAR));
    unistr.MaximumLength = unistr.Length;
    unistr.Buffer = (PWCHAR)QueryPch();
    ASSERT( unistr.Buffer != NULL );
    OEM_STRING oemstrUpcase;
    oemstrUpcase.Buffer = NULL;
    oemstrUpcase.Length = 0;
    oemstrUpcase.MaximumLength = 0;
    NTSTATUS ntstatus = ::RtlUpcaseUnicodeStringToOemString(
        &oemstrUpcase,
        &unistr,
        TRUE );
    if (ntstatus != STATUS_SUCCESS)
    {
        err = ERRMAP::MapNTStatus( ntstatus );
        DBGEOL(    "NLS_STR::RtlOemUpcase: RtlUpcase status " << ntstatus
                << ", error " << err );
        goto cleanup;
    }

    if (  ((err = MapCopyFrom( oemstrUpcase.Buffer,
                               oemstrUpcase.Length )) != NERR_Success)
       )
    {
        DBGEOL( "NLS_STR::RtlOemUpcase: MapCopyFrom error " << err );
        goto cleanup;
    }

cleanup:
    ::RtlFreeOemString( &oemstrUpcase );
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\hello\hello.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    hello.cxx
    The very simplest test case

    FILE HISTORY:
        beng        30-Apr-1991     Created

*/

#include <lmui.hxx>

extern "C"
{
    #include <stdio.h>
}

#include <string.hxx>


INT main()
{
#if defined(UNICODE)
    puts("This test only runs in non-Unicode environments.");
#else
    NLS_STR nlsString = SZ("Your mother loves only Godzilla.");

    puts(nlsString.QueryPch());
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\convert\xconvert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr02.cxx
    Some more string unit tests - the MBCS/Unicode conversion fcns

    This module plugs into XstrSkel.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        16-Mar-1992 Changes to cdebug
        beng        31-Mar-1992 Test extensions to NLS_STR::MapCopyFrom
        beng        24-Apr-1992 More test cases
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_NETERRORS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xconvert.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>

#include "xstrskel.hxx"


// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << "<(Unrenderable - Error state " << nls.QueryError() << ")>";
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << " reads " << nls << dbgEOL;
    cdebug << "   strlen = "       << nls.strlen() << dbgEOL;
    cdebug << "   QAllocSize = "   << nls.QueryAllocSize() << dbgEOL;
    cdebug << "   QNumChar = "     << nls.QueryNumChar() << dbgEOL;
    cdebug << "   QTLength = "     << nls.QueryTextLength() << dbgEOL;
    cdebug << "   QTSize = "       << nls.QueryTextSize() << dbgEOL;
}


VOID Test01()
{
    NLS_STR nlsTest = SZ("Test");

    TCHAR achTooSmall[4];
    TCHAR achPlentyBig[5];

    APIERR err;

    ASSERT(!!nlsTest);

    achTooSmall[0] = TCH('\0');
    err = nlsTest.CopyTo(achTooSmall, sizeof(achTooSmall));
    ASSERT(err == ERROR_NOT_ENOUGH_MEMORY);
    DBGEOL("Buffer TooSmall contains <" << achTooSmall << ">");
    err = nlsTest.CopyTo(achPlentyBig, sizeof(achPlentyBig));
    ASSERT(err == NERR_Success);
    DBGEOL("Buffer PlentyBig contains <" << achPlentyBig << ">");
}


VOID Test02()
{
    NLS_STR nlsTest = SZ("Test");

    CHAR achSmallChars[20];
    WCHAR awchLargeChars[20];

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyTo(achSmallChars, sizeof(achSmallChars));
    ASSERT(err == NERR_Success);
    DBGEOL("Schar array contains "
           << (UINT)achSmallChars[0] << ", "
           << (UINT)achSmallChars[1] << ", "
           << (UINT)achSmallChars[2] << ", "
           << (UINT)achSmallChars[3] << ", "
           << (UINT)achSmallChars[4]);

    err = nlsTest.MapCopyTo(awchLargeChars, sizeof(awchLargeChars));
    ASSERT(err == NERR_Success);
    DBGEOL("Wchar array contains "
           << (UINT)awchLargeChars[0] << ", "
           << (UINT)awchLargeChars[1] << ", "
           << (UINT)awchLargeChars[2] << ", "
           << (UINT)awchLargeChars[3] << ", "
           << (UINT)awchLargeChars[4]);
}


VOID Test03()
{
    NLS_STR nlsTest = SZ("Test string");

    CHAR szSmall[] = {65, 65, 66, 66, 67, 67, 68, 68, 0};
    WCHAR wszLarge[] = {65, 65, 66, 66, 67, 67, 68, 68, 0};

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyFrom(szSmall);
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from schar string = " << nlsTest);

    err = nlsTest.MapCopyFrom(wszLarge);
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from wchar string = " << nlsTest);

    STACK_NLS_STR(nlsPuny, 8);
    ASSERT(!!nlsPuny);

    err = nlsPuny.CopyFrom(SZ("Gnome"));
    ASSERT(err == NERR_Success);
    DBGEOL("Small allocstr contains " << nlsPuny);

    err = nlsPuny.CopyFrom(SZ("Baluchitherium"));
    ASSERT(err == ERROR_NOT_ENOUGH_MEMORY);
    DBGEOL("Small allocstr still contains " << nlsPuny);
}


VOID Test04()
{
    NLS_STR nlsTest;

    static TCHAR achNoTerm[4] = { TCH('A'), TCH('B'), TCH('C'), TCH('D') };
    static TCHAR *const achHasTerm = SZ("EFGH");

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.CopyFrom(achNoTerm, sizeof(achNoTerm));
    ASSERT(err == NERR_Success);
    DBGEOL("Should contain ABCD; contains " << nlsTest);

    err = nlsTest.CopyFrom(achHasTerm);
    ASSERT(err == NERR_Success);
    DBGEOL("Should contain EFGH; contains " << nlsTest);
}



VOID Test05()
{
    NLS_STR nlsTest = SZ("Test string");

    CHAR szSmall[] = {65, 65, 66, 66, 67, 67, 68, 68 };
    WCHAR wszLarge[] = {65, 65, 66, 66, 67, 67, 68, 68};

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyFrom(szSmall, sizeof(szSmall));
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from schar string = " << nlsTest);

    err = nlsTest.MapCopyFrom(wszLarge, sizeof(wszLarge));
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from wchar string = " << nlsTest);
}


VOID Test06()
{
    NLS_STR nlsShouldBeEmpty = SZ("Existing garbage");
    WCHAR wszEmpty[] = {0, (WCHAR)'B', (WCHAR)'u', (WCHAR)'g', (WCHAR)'!', 0};

    ASSERT(!!nlsShouldBeEmpty);

    APIERR err;

    // Mimic a case where a struct UNICODE_STRING is coming back
    // with Length == 0

    err = nlsShouldBeEmpty.MapCopyFrom(wszEmpty, 0);
    ASSERT(err == NERR_Success);
    FunFactsAboutString(SZ("nlsShouldBeEmpty"), nlsShouldBeEmpty);
}


VOID RunTest()
{
    Test01();
    Test02();
    Test03();
    Test04();
    Test05();
    Test06();

    DBGEOL("Done!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\string\uinetlib.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    uinetlib.cxx
    String-compare functions

    This file contains the methods for determining whether hyphens and
    apostrophes should be sorted as symbols.  Normally, CompareStringW
    sorts them  seperately from symbols, and only counts them if the
    strings cannot otherwise be distinguished.  However, ITG has noted
    that this causes "a-username" names to be sorted with "au" instead
    of with "a-".  For this reason, we have provided a registry location
    where they can ask that hyphens and apostrophes be sorted with the
    rest of the characters.

    CompareStringW also can set unequal values equal, for example
    "kuss" == "ku<S-Tzet>".  For this reason we follow up equal
    results with RtlCompareUnicodeString.

    We keep seperate values for Std and Nocase so that we don't have to
    perform the extra OR operation on every ignore-case comparison.

    FILE HISTORY:
        jonn        25-Mar-1993     Created for ITG special sort
        jonn        16-Nov-1995     Compensate for CompareStringW

*/
#include "pchstr.hxx"  // Precompiled header

DWORD _static_dwStdCompareParam = 0;
DWORD _static_dwNocaseCompareParam = NORM_IGNORECASE;
LCID  _static_UserDefaultLCID = 0;


/*******************************************************************

    NAME:	InitCompareParam

    SYNOPSIS:   We read the registry to determine whether we should be
                sorting hyphens and apostrophes as symbols.

    HISTORY:
        jonn        25-Mar-1993     Created (borrowing from ADMIN_INI)

********************************************************************/

void  InitCompareParam( void )
{
    _static_dwStdCompareParam = 0;
    _static_dwNocaseCompareParam = NORM_IGNORECASE;
    _static_UserDefaultLCID = 0;

    INT n = ::GetPrivateProfileInt( SZ("Shared Parameters"),
                                    SZ("Sort Hyphens"),
                                    0,
                                    SZ("NTNET.INI") );

    if ( n != 0 )
    {
        _static_dwStdCompareParam    |= SORT_STRINGSORT;
        _static_dwNocaseCompareParam |= SORT_STRINGSORT;
    }

    _static_UserDefaultLCID = GetUserDefaultLCID();
}


/*******************************************************************

    NAME:	QueryStdCompareParam
                QueryNocaseCompareParam

    SYNOPSIS:	Return the fdwStyle parameter to be used for all calls
                to CompareStringW in the NETUI project.

    HISTORY:
        jonn        25-Mar-1993     Created

********************************************************************/

DWORD QueryStdCompareParam( void )
{
    return _static_dwStdCompareParam;
}

DWORD QueryNocaseCompareParam( void )
{
    return _static_dwNocaseCompareParam;
}


/*******************************************************************

    NAME:	QueryUserDefaultLCID

    SYNOPSIS:	Return the LCID to use in string comparisons.

    HISTORY:
        jonn        02-Feb-1994     Created

********************************************************************/

DWORD QueryUserDefaultLCID( void ) // actually an LCID
{
    return (DWORD)_static_UserDefaultLCID;
}


/*******************************************************************

    NAME:	NLS_STR::NETUI_strcmp
                         NETUI_stricmp
                         NETUI_strncmp
                         NETUI_strnicmp

    HISTORY:
        jonn    29-Mar-1993     Created

********************************************************************/
DLL_BASED
INT NETUI_strcmp( const WCHAR * pchString1, const WCHAR * pchString2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)-1,
                                     (LPCWSTR)pchString2,
                                     (int)-1 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strcmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\" ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = ::strlenf(pchString1)*sizeof(WCHAR);
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = ::strlenf(pchString2)*sizeof(WCHAR);
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;

}

DLL_BASED
INT NETUI_stricmp( const WCHAR * pchString1, const WCHAR * pchString2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)-1,
                                     (LPCWSTR)pchString2,
                                     (int)-1 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_stricmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\" ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = ::strlenf(pchString1)*sizeof(WCHAR);
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = ::strlenf(pchString2)*sizeof(WCHAR);
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strncmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch,
                                     (LPCWSTR)pchString2,
                                     (int)cch );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strncmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\", "
               << cch
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strnicmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch,
                                     (LPCWSTR)pchString2,
                                     (int)cch );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strnicmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\", "
               << cch
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }

#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strncmp2( const WCHAR * pchString1, INT cch1,
                    const WCHAR * pchString2, INT cch2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch1,
                                     (LPCWSTR)pchString2,
                                     (int)cch2 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strncmp2( \""
               << pchString1
               << "\", " << cch1 << ", \""
               << pchString2
               << "\", "
               << cch2
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch1*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch2*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strnicmp2( const WCHAR * pchString1, INT cch1,
                     const WCHAR * pchString2, INT cch2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch1,
                                     (LPCWSTR)pchString2,
                                     (int)cch2 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strnicmp2( \""
               << pchString1
               << "\", " << cch1 << ", \""
               << pchString2
               << "\", "
               << cch2
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }

#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch1*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch2*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\skeleton\xstrskel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstrskel.cxx
    STRING unit test: main application module

    This is a skeleton for string unit tests, allowing them to
    be written in a host-env independent fashion.

    FILE HISTORY:
        johnl       12-Nov-1990 Created
        beng        01-May-1991 Added workaround for C7 bug
        beng        27-Jun-1991 Win and OS2 tests merged
                                (used BUFFER as a template)
        beng        06-Jul-1991 Frame and test partitioned
        beng        14-Oct-1991 Uses APPLICATION
        beng        28-Feb-1992 Works for the console in general
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstrskel.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "xstrskel.h"
}

#if defined(WINDOWS)
# if !defined(USE_CONSOLE)
#  define INCL_BLT_CONTROL
#  define INCL_BLT_CLIENT
# endif
# define INCL_BLT_APP
# include <blt.hxx>
#endif

#if !defined(WINDOWS) || defined(USE_CONSOLE)
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include "xstrskel.hxx"


#if defined(WINDOWS) && !defined(USE_CONSOLE)

const TCHAR szIconResource[] = SZ("TestIcon");
const TCHAR szMenuResource[] = SZ("TestMenu");
const TCHAR szAccelResource[] = SZ("TestAccel");

const TCHAR szMainWindowTitle[] = SZ("Class STRING Test");


class XSTR_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    XSTR_WND();
};


class XSTR_APP: public APPLICATION
{
private:
    XSTR_WND  _wndApp;
    ACCELTABLE _accel;

public:
    XSTR_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


XSTR_APP::XSTR_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _accel( szAccelResource ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL XSTR_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


XSTR_WND::XSTR_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
        return;

    // ...
}


BOOL XSTR_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
        ::MessageBox(QueryHwnd(),
            SZ("Test results will be written to debug terminal.  Bogus, huh?"),
            SZ("Note"), MB_OK);

        ::RunTest();
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( XSTR_APP )

#elif defined(WINDOWS) && defined(USE_CONSOLE)

// Win32, with console support


class TEST_APP: public APPLICATION
{
private:
    OUTPUT_TO_STDERR _out;
    DBGSTREAM        _dbg;
    DBGSTREAM *      _pdbgSave;

public:
    TEST_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
    ~TEST_APP();

    // Redefinitions
    //
    virtual INT Run();
};


TEST_APP::TEST_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _out(),
      _dbg(&_out),
      _pdbgSave( &(DBGSTREAM::QueryCurrent()) )
{
    if (QueryError())
        return;

    // Point cdebug to stderr instead of aux
    //
    DBGSTREAM::SetCurrent(&_dbg);
}


TEST_APP::~TEST_APP()
{
    // Restore original stream

    DBGSTREAM::SetCurrent(_pdbgSave);
}


INT TEST_APP::Run()
{
    // Never mind the message loop... this is a console app.
    // Hope this works.
    //
    ::RunTest();
}


SET_ROOT_OBJECT( TEST_APP )


#else // OS2, or DOS, or some such env


INT main()
{
    OUTPUT_TO_STDOUT out;
    DBGSTREAM dbg(&out);
    DBGSTREAM::SetCurrent(&dbg);

    ::RunTest();

    DBGSTREAM::SetCurrent(NULL);
    return 0;
}


#endif // WINDOWS -vs- OS2 unit test skeletons
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\basic\xstr00.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr00.cxx
    Simple unit test for string class NLS_STR

    This module plugs into XstrSkel.  It contains the original
    string class unit tests as written by johnl.


    FILE HISTORY:
        beng        06-Jul-1991 Separated from xstr.cxx
        beng        21-Nov-1991 Unicode fixes
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstr00.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>

#include "xstrskel.hxx"



// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << SZ("<(Unrenderable - Error state ") << nls.QueryError() << SZ(")>");
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


class DUMB
{
public:
    DUMB( TCHAR * pchInit )
        : CT_INIT_NLS_STR( _nlsStr, pchInit )
    {
        cdebug << SZ("DUMB::DUMB - _nlsStr = ") << _nlsStr << dbgEOL;

        UIASSERT( !::strcmpf( _nlsStr.QueryPch(), pchInit ) );
        UIASSERT( _nlsStr.IsOwnerAlloc() );
        UIASSERT( _nlsStr.QueryAllocSize() == (30+1)*sizeof(TCHAR) );
    }

    DUMB()
        : CT_NLS_STR( _nlsStr )
    {
        cdebug << SZ("DUMB::DUMB - _nlsStr = ") << _nlsStr << dbgEOL;

        UIASSERT( !::strcmpf( _nlsStr.QueryPch(), SZ("") ) );
        UIASSERT( _nlsStr.IsOwnerAlloc() );
        UIASSERT( _nlsStr.QueryAllocSize() == (30+1)*sizeof(TCHAR) );
    }

    ~DUMB()
    {
        cdebug << SZ("DUMB::~DUMB - Destructing ") << _nlsStr << dbgEOL;
    }

private:
    DECL_CLASS_NLS_STR( _nlsStr, 30 );
};


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << SZ(" reads ") << nls << dbgEOL;
    cdebug << SZ("   strlen = ")       << nls.strlen() << dbgEOL;
    cdebug << SZ("   QAllocSize = ")   << nls.QueryAllocSize() << dbgEOL;
    cdebug << SZ("   QNumChar = ")     << nls.QueryNumChar() << dbgEOL;
    cdebug << SZ("   QTLength = ")     << nls.QueryTextLength() << dbgEOL;
    cdebug << SZ("   QTSize = ")       << nls.QueryTextSize() << dbgEOL;
}


VOID Test0()
{
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing Owner-alloc string classes...")
           << dbgEOL;

    TCHAR *const szGreeting = SZ("Good morning Saigon");
    TCHAR achNewBuffer[40];

    {
        ALLOC_STR str1(achNewBuffer, sizeof(achNewBuffer), szGreeting);
        FunFactsAboutString(SZ("Alloc str1"), str1);
        str1.Append(SZ(" - more strings about buildings and food"));
        FunFactsAboutString(SZ("Alloc str1"), str1);
    }

    {
        ALLOC_STR str2(achNewBuffer, sizeof(achNewBuffer));
        str2 = SZ("Cowboy Wally");
        FunFactsAboutString(SZ("Alloc str2"), str2);
    }

    {
        ALLOC_STR str3(achNewBuffer, sizeof(achNewBuffer));
        FunFactsAboutString(SZ("Alloc str3"), str3);
    }

    {
        const ALIAS_STR alias = szGreeting;
        FunFactsAboutString(SZ("alias"), alias);
    }
}


VOID RunTest()
{
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing owner alloced string members...")
           << dbgEOL;
    {
        DUMB dum1( SZ("This is a string") ), dum2;
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing string initialization stuff...")
           << dbgEOL;
    {
        NLS_STR nlsString( 100 ), *pnls = &nlsString;
        TCHAR *const buff = SZ("Hello world");

        *pnls = SZ("Hello there");
        cdebug << SZ("pnls = ") << *pnls << dbgEOL;
        *pnls = buff;
        cdebug << SZ("pnls = ") << *pnls << dbgEOL;
    }

    //-------------------------------------------------------------------
    cdebug << dbgEOL << dbgEOL << SZ("Testing NLS_STR") << dbgEOL;
    {
        NLS_STR nlsDefault,
                nlsSizeNoInitChar( 15 ),
                nlsInitString    ( SZ("123456789012345") ),
                nlsInitNLS       ( nlsInitString ),
                nlsEmpty;
        ALLOC_STR nlsOwnerAlloc  ( SZ("123456789012345") );

        FunFactsAboutString(SZ("nlsDefault"), nlsDefault);
        FunFactsAboutString(SZ("nlsSizeNoInitChar"), nlsSizeNoInitChar);
        FunFactsAboutString(SZ("nlsInitString"), nlsInitString);
        FunFactsAboutString(SZ("nlsInitNLS"), nlsInitNLS);
        FunFactsAboutString(SZ("nlsOwnerAlloc"), nlsOwnerAlloc);

        REQUIRE( nlsDefault.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsDefault.QueryTextLength() == 0 );
        REQUIRE( !::strcmpf( nlsDefault.QueryPch(), SZ("") ));

        REQUIRE( nlsSizeNoInitChar.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsSizeNoInitChar.QueryTextLength() == 0 );
        REQUIRE( !::strcmpf( nlsSizeNoInitChar.QueryPch(), SZ("")) );

        REQUIRE( nlsInitString.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsInitString.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsInitString.QueryPch(), SZ("123456789012345") ));

        REQUIRE( nlsInitNLS.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsInitNLS.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsInitNLS.QueryPch(), SZ("123456789012345") ));

        REQUIRE( nlsOwnerAlloc.IsOwnerAlloc() );
        REQUIRE( nlsOwnerAlloc.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsOwnerAlloc.QueryPch(), SZ("123456789012345") ));

        nlsEmpty = NULL;
        REQUIRE( nlsEmpty.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsEmpty.QueryTextLength() == 0 );

        TCHAR * pchnull = NULL;
        NLS_STR nlsEmpty2( pchnull );
        REQUIRE( nlsEmpty2.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsEmpty2.QueryTextLength() == 0 );
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR concat methods") << dbgEOL;
    {
        NLS_STR nlsCat = SZ("Cat "),
                nlsDog = SZ("Dog"),
                nlsConCat = nlsCat;
        nlsConCat += nlsDog;
        REQUIRE( ::strcmpf( nlsConCat.QueryPch(), SZ("Cat Dog") ) == 0 );
        REQUIRE( nlsConCat.QueryTextLength() == 7 );

        NLS_STR nlsConCat2 = nlsConCat;
        nlsConCat2 += nlsConCat;
        REQUIRE( ::strcmpf( nlsConCat2.QueryPch(), SZ("Cat DogCat Dog") ) == 0 );
        REQUIRE( nlsConCat2.QueryTextLength() == 14 );

    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR str??cmp methods") << dbgEOL;
    {
        NLS_STR nlsCAPS = SZ("FRISBEE"),
                nlslow  = SZ("frisbee"),
                nlsPart1= SZ("nomatch Frisbee"),
                nlsPart2= SZ("maybe Frisbee"),
                nlsLess = SZ("AFRISBEE"),
                nlsGreater = SZ("ZFRISBEE"),
                nlsCAPS2 = SZ("FRISBEE");

        REQUIRE( nlsCAPS != nlslow );
        REQUIRE( nlsCAPS == (NLS_STR)SZ("FRISBEE") );
        REQUIRE( nlsCAPS != (NLS_STR)SZ("NO FRISBEE") );
        REQUIRE( nlsCAPS == nlsCAPS2 );

        REQUIRE( 0 >  nlsCAPS.strcmp( nlslow ) );
        REQUIRE( 0 >  nlsCAPS.strcmp( nlsGreater ) );
        REQUIRE( 0 <  nlsCAPS.strcmp( nlsLess ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsCAPS2 ) );

        ISTR istrFirstF (nlsCAPS),
             istrFirstI (nlsCAPS),
             istrDef    (nlsLess),
             istrGreater(nlsGreater),
             istrLess   (nlsLess );

        nlsCAPS.strcspn( &istrFirstF, SZ("F") );
        nlsCAPS.strcspn( &istrFirstI, SZ("I") );
        nlsLess.strcspn( &istrLess,   SZ("F"));

        cdebug << SZ("str??cmp methods trace 1") << dbgEOL;
        REQUIRE( 0 > nlsCAPS.strncmp( nlslow, istrFirstI ) );
        REQUIRE( 0 > nlsCAPS.strncmp( nlsGreater, istrFirstI ) );
        REQUIRE( 0 < nlsCAPS.strncmp( nlsLess, istrFirstI ) );

        REQUIRE( 0 == nlsCAPS._stricmp( nlslow ) );
        REQUIRE( 0 >  nlsCAPS._stricmp( nlsGreater ) );
        REQUIRE( 0 <  nlsCAPS._stricmp( nlsLess ) );

        cdebug << SZ("str??cmp methods trace 2") << dbgEOL;
        REQUIRE( 0 == nlsCAPS._strnicmp( nlslow, istrFirstI ) );
        REQUIRE( 0 >  nlsCAPS._strnicmp( nlsGreater, istrFirstI) );
        REQUIRE( 0 <  nlsCAPS._strnicmp( nlsLess, istrFirstI ) );

        //---------- With offsets into string ---------------
        cdebug << SZ("str??cmp methods trace 3") << dbgEOL;

        nlsGreater.strcspn( &istrGreater, SZ("F"));
        nlsLess.strcspn( &istrLess, SZ("I") );

        REQUIRE( 0 <  nlsCAPS.strcmp( nlsLess, istrFirstF, istrDef ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsGreater, istrFirstF, istrGreater ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsLess, istrFirstI, istrLess ) );

    }

#if !defined(UNICODE)
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR strtok methods") << dbgEOL;
    {
        NLS_STR nls1 = SZ("Wham-o diskcraft, aerobie ultra-star"),
                nlsSep=SZ(" \t,");

        ISTR istrToken( nls1 );
        BOOL fMore = nls1.strtok( &istrToken, nlsSep, TRUE );
        while ( fMore )
        {
            cdebug << nls1[ istrToken ] << dbgEOL;
            fMore = nls1.strtok( &istrToken, nlsSep );
        }
    }
#endif

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR str?spn methods") << dbgEOL;
    {
        NLS_STR nls1 = SZ("FRISBEE"),
                nls2 = SZ("FROBOSE"),
                nls3 = SZ("BOK");

        ISTR istr1( nls1), istr2( nls1 );

        REQUIRE( nls1.strcspn( &istr1, nls3 ) ); // Should be 4
        REQUIRE( nls1.strspn( &istr2, nls3 ) ); // Should be 0


        cdebug << SZ("\"") << nls1[istr1] << SZ("\"") << SZ("   ")
               << SZ("\"") << nls1[istr2] << SZ("\"") << dbgEOL;
        REQUIRE( 0 == nls1.strcmp( SZ("BEE"), istr1 ) );
        REQUIRE( 0 == nls1.strcmp( SZ("FRISBEE"), istr2 ) );
        cdebug << dbgEOL;

        REQUIRE( nls1.strcspn( &istr1, SZ("E"), istr1 ) );
        istr1++;
        REQUIRE( nls1.strcspn( &istr1, SZ("E"), istr1 ) );
        istr1++;
        REQUIRE( !nls1.strcspn( &istr1, SZ("E"), istr1 ) );
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing Character methods") << dbgEOL;
    {
        NLS_STR nls = SZ("FRISBEE");
        ISTR istr1(nls), istr2(istr1 );

        REQUIRE( nls.QueryChar( istr1 ) == TCH('F') );
        REQUIRE( istr1 == istr2 );
        istr1++;
        REQUIRE( nls.QueryChar( istr1 ) == TCH('R') );
        REQUIRE( istr1 > istr2 );
        REQUIRE( istr2 < istr1 );

        istr2 += 2;
        REQUIRE( nls.QueryChar( istr2 ) == TCH('I') );

        while ( nls.QueryChar(istr1++) != TCH('\0') )
        {
            cdebug << nls.QueryChar(istr1) << SZ(" - ");
        }
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing strchr methods") << dbgEOL;
    {
        NLS_STR nls = SZ("Line of text with a # in it"),
                nls2= SZ("Line of text without a sharp in it");

        ISTR istr(nls), istr2(nls2);

        REQUIRE( nls.strchr( &istr, TCH('#') ) != 0 );
        cdebug << SZ("nls[istr] = \"") << nls[istr] << SZ("\"") << dbgEOL;

        REQUIRE( nls2.strchr( &istr2, TCH('#') ) == 0 );
        cdebug << SZ("nls2[istr] = \"") << nls2[istr2] << SZ("\"") << dbgEOL;

        istr++ ;    // Move past '#'
        REQUIRE( nls.strchr( &istr, TCH('#'), istr ) == 0 );
        cdebug << SZ("nls[istr] = \"") << nls[istr] << SZ("\"") << dbgEOL;
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing Append methods") << dbgEOL;
    {
        NLS_STR nls = SZ("My original string");

        REQUIRE(nls == (NLS_STR)SZ("My original string"));
        cdebug << SZ("Original string is ") << nls << dbgEOL;

        nls.Append(SZ(" plus another fine string"));
        cdebug << SZ("Now it reads ") << nls << dbgEOL;

        nls.AppendChar(TCH('A'));
        nls.AppendChar(TCH('B'));
        nls.AppendChar(TCH('C'));
        nls.AppendChar(TCH('D'));
        nls.AppendChar(TCH('E'));
        cdebug << SZ("With alpha A-E, reads ") << nls << dbgEOL;
    }

    cdebug << dbgEOL << dbgEOL << SZ("Comparing Length methods") << dbgEOL;
    {
        NLS_STR nlsOdd = SZ("Eat me (odd number)");

        FunFactsAboutString(SZ("nlsOdd"), nlsOdd);

        NLS_STR nlsEven = SZ("Eat me (even number)");

        FunFactsAboutString(SZ("nlsEven"), nlsEven);

        NLS_STR nlsEmpty = SZ("");

        FunFactsAboutString(SZ("nlsEmpty"), nlsEmpty);
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing NLS_STACK") << dbgEOL;
    {
        STACK_NLS_STR( Test, 10 );
        ISTACK_NLS_STR( Test2, 10, SZ("123456789") );

        REQUIRE( Test.QueryTextLength() == 0 );
        REQUIRE( Test.QueryAllocSize() == 11*sizeof(TCHAR) );
        REQUIRE( Test.IsOwnerAlloc() );

        REQUIRE( Test2.QueryTextLength() == 9 );
        REQUIRE( Test2.QueryAllocSize() == 11*sizeof(TCHAR) );
        REQUIRE( Test2.IsOwnerAlloc() );
        REQUIRE( !::strcmpf( Test2.QueryPch(), SZ("123456789")) );

        Test = SZ("Good Thing");
        REQUIRE( Test.QueryTextLength() == 10 );
        REQUIRE( Test.QueryAllocSize() == 11*sizeof(TCHAR) );
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing strcpy") << dbgEOL;
    {
        STACK_NLS_STR( nlsSource, 80 );
        TCHAR achBuffer[80];
        nlsSource = SZ("This is a test string");

        strcpy( achBuffer, nlsSource );
        cdebug << SZ("achBuffer = \"") << achBuffer << SZ("\"") << dbgEOL;
        REQUIRE( !::strcmpf( achBuffer, SZ("This is a test string") ) );
    }

    Test0();

    cdebug << dbgEOL << dbgEOL << SZ("Testing substring methods") << dbgEOL;
    {
        NLS_STR nls1  = SZ("jlj ; is a test ffdll; "),
                nlsIs = SZ("is "),
                nlsA = SZ("a");
        ISTR istrIs(nls1), istrA(nls1);

        // QuerySubStr
        REQUIRE( nls1.strstr( &istrIs, nlsIs ) );
        REQUIRE( nls1.strstr( &istrA,  nlsA  ) );

        NLS_STR *pnls = nls1.QuerySubStr( istrIs ),
                *pnls2= nls1.QuerySubStr( istrIs, istrA );

        cdebug << SZ("pnls = ")  << *pnls  << SZ(", ")
               << SZ("pnls2 = ") << *pnls2 << dbgEOL;

        REQUIRE( 0 == pnls->strcmp( SZ("is a test ffdll; ") ) );
        REQUIRE( 0 == pnls2->strcmp(SZ("is ") ) );

        // DelSubStr
        NLS_STR nls3 = nls1;
        REQUIRE( nls3 == nls1 );
        nls1.DelSubStr( istrIs, istrA );

        ISTR istrNLS3Is( nls3 );
        REQUIRE( nls3.strstr( &istrNLS3Is, nlsIs ) );

        cdebug << SZ("nls3 before delsubstring = ") << nls3 << dbgEOL;
        nls3.DelSubStr( istrNLS3Is );
        cdebug << SZ("nls1 = ") << nls1 << SZ(", ")
               << SZ("nls3 = ") << nls3 << dbgEOL;

        REQUIRE( *pnls == (NLS_STR)SZ("is a test ffdll; ") );
        REQUIRE(  nls1 == (NLS_STR)SZ("jlj ; a test ffdll; ") );

        // The following two "delete" ops are correct, since
        // QuerySubStr constructs a new string object for its substr.

        delete pnls;
        delete pnls2;
    }

    // Insert String
    {
        // InsertStr
        NLS_STR nlsIns1 = SZ("Rustan Leino");
        ISTR istrSpc( nlsIns1 );

        REQUIRE( nlsIns1.strcspn( &istrSpc, SZ(" ") ) );
        REQUIRE( nlsIns1.InsertStr( SZ(" \"Mean Swede\""), istrSpc ) );
        cdebug << SZ("nlsIns1 = ") << nlsIns1 << dbgEOL;
        REQUIRE( !::strcmpf( nlsIns1.QueryPch(), SZ("Rustan \"Mean Swede\" Leino") ));

        REQUIRE( nlsIns1.InsertStr( SZ(" very mean"), istrSpc ) );
        cdebug << SZ("nlsIns1 = ") << nlsIns1 << dbgEOL;
        REQUIRE( !::strcmpf( nlsIns1.QueryPch(), SZ("Rustan very mean \"Mean Swede\" Leino") ));

        // ReplSubStr
        NLS_STR nlsRepl = SZ("Margaret Thatcher"),
                nlsRepl2 = SZ("Major");
        ISTR istrThatcher( nlsRepl );
        REQUIRE( nlsRepl.strstr( &istrThatcher, SZ("Thatcher") ) );
        nlsRepl.ReplSubStr( nlsRepl2, istrThatcher );
        cdebug << SZ("nlsRepl = ") << nlsRepl << dbgEOL;
        REQUIRE( nlsRepl == (NLS_STR)SZ("Margaret Major") );

    }

    // Repl. Substring variations
    {
        NLS_STR nlsRepl3 = SZ("set x =20");
        ISTR istrRepl3Start( nlsRepl3 ), istrRepl3End( nlsRepl3);

        // Start and end same at the end of the string
        REQUIRE( nlsRepl3.strcspn( &istrRepl3Start, SZ("2") ) );
        REQUIRE( nlsRepl3.strchr(  &istrRepl3End, TCH('\0') ) );
        nlsRepl3.ReplSubStr( SZ("56234"), istrRepl3Start, istrRepl3End );
        cdebug << SZ("nlsRepl3 = ") << nlsRepl3 << dbgEOL;
        REQUIRE( !::strcmpf( nlsRepl3.QueryPch(), SZ("set x =56234") ) );
        REQUIRE( nlsRepl3.QueryTextLength() == (UINT)::strlenf(SZ("set x =56234") ) );

        // Regular replace substring (delstring/insert string)
        NLS_STR nlsRepl4 = SZ("set x = Line of Text");
        ISTR istrRepl4Start( nlsRepl4 ), istrRepl4End( nlsRepl4);

        REQUIRE( nlsRepl4.strcspn( &istrRepl4Start, SZ("L") ) );
        REQUIRE( nlsRepl4.strcspn(  &istrRepl4End, SZ(" "), istrRepl4Start ) );
        nlsRepl4.ReplSubStr( SZ("Big Buffer"), istrRepl4Start, istrRepl4End );
        cdebug << SZ("nlsRepl4 = ") << nlsRepl4 << dbgEOL;
        REQUIRE( !::strcmpf( nlsRepl4.QueryPch(), SZ("set x = Big Buffer of Text") ) );
        REQUIRE( nlsRepl4.QueryTextLength() == (UINT)::strlenf( SZ("set x = Big Buffer of Text") ) );
    }

    // InsertParams test
    {
        NLS_STR nlsPrimaryOne = SZ("Param 1 = \"%1\"");
        NLS_STR nlsPrimaryTwo = SZ("Param 1 = %1, Param 2 = %2, Param 1+2 = %1%2");
        NLS_STR nlsPrimaryThree = SZ("No params in this string %0, %%% 1%");
        NLS_STR nlsP1 = SZ("Param 1");
        NLS_STR nlsP2 = SZ("Param 2");

        NLS_STR * apnls1[2], *apnls2[3];

        apnls1[0] = apnls2[0] = &nlsP1;
        apnls2[1] = &nlsP2;
        apnls1[1] = apnls2[2] = NULL;

        REQUIRE( !nlsPrimaryOne.InsertParams( apnls1 ) );
        cdebug << SZ("nlsPrimaryOne = ") << nlsPrimaryOne << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryOne.QueryPch(), SZ("Param 1 = \"Param 1\"") ) );

        REQUIRE( !nlsPrimaryTwo.InsertParams( apnls2 ) );
        cdebug << SZ("nlsPrimaryTwo = ") << nlsPrimaryTwo << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryTwo.QueryPch(), SZ("Param 1 = Param 1, Param 2 = Param 2, Param 1+2 = Param 1Param 2")  ) );

        REQUIRE( !nlsPrimaryThree.InsertParams( apnls2 ) );
        cdebug << SZ("nlsPrimaryThree = ") << nlsPrimaryThree << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryThree.QueryPch(), SZ("No params in this string %0, %%% 1%")  ) );
    }
    cdebug << SZ("Done!") << dbgEOL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\string\test\format\xstr01.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr01.cxx
    Some more string unit tests - the formatters

    This module plugs into XstrSkel.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstr01.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>
#include <strtchar.hxx>
#include <strnumer.hxx>

#include "xstrskel.hxx"


// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << SZ("<(Unrenderable - Error state ") << nls.QueryError() << SZ(")>");
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << SZ(" reads ") << nls << dbgEOL;
    cdebug << SZ("   strlen = ")       << nls.strlen() << dbgEOL;
    cdebug << SZ("   QAllocSize = ")   << nls.QueryAllocSize() << dbgEOL;
    cdebug << SZ("   QNumChar = ")     << nls.QueryNumChar() << dbgEOL;
    cdebug << SZ("   QTLength = ")     << nls.QueryTextLength() << dbgEOL;
    cdebug << SZ("   QTSize = ")       << nls.QueryTextSize() << dbgEOL;
}


VOID Test01()
{
    NLS_STR nlsPrimaryOne = SZ("Param 1 = \"%1\"");
    NLS_STR nlsPrimaryTwo = SZ("Param 1 = %1, Param 2 = %2, Param 1+2 = %1%2");
    NLS_STR nlsPrimaryThree = SZ("No params in this string %0, %%% 1%");
    NLS_STR nlsP1 = SZ("Param 1");
    NLS_STR nlsP2 = SZ("Param 2");

    NLS_STR * apnls1[2], *apnls2[3];

    apnls1[0] = apnls2[0] = &nlsP1;
    apnls2[1] = &nlsP2;
    apnls1[1] = apnls2[2] = NULL;

    REQUIRE( !nlsPrimaryOne.InsertParams( apnls1 ) );
    cdebug << SZ("nlsPrimaryOne = ") << nlsPrimaryOne << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryOne.QueryPch(), SZ("Param 1 = \"Param 1\"") ) );

    REQUIRE( !nlsPrimaryTwo.InsertParams( apnls2 ) );
    cdebug << SZ("nlsPrimaryTwo = ") << nlsPrimaryTwo << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryTwo.QueryPch(), SZ("Param 1 = Param 1, Param 2 = Param 2, Param 1+2 = Param 1Param 2")  ) );

    REQUIRE( !nlsPrimaryThree.InsertParams( apnls2 ) );
    cdebug << SZ("nlsPrimaryThree = ") << nlsPrimaryThree << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryThree.QueryPch(), SZ("No params in this string %0, %%% 1%")  ) );
}


VOID Test02()
{
    NLS_STR nlsUno = SZ("My one argument: %1");
    NLS_STR nlsDos = SZ("My two arguments: %1, %2");
    NLS_STR nlsRevved = SZ("My two arguments in rev order: %2, %1");

    NLS_STR nlsDing = SZ("Ding");
    NLS_STR nlsDong = SZ("Dong");

    REQUIRE(!!nlsUno && !!nlsDos && !!nlsRevved && !!nlsDing && !!nlsDong);

    REQUIRE(!nlsUno.InsertParams(nlsDing));
    DBGEOL(SZ("nlsUno = ") << nlsUno);
    REQUIRE(!::strcmpf(nlsUno, SZ("My one argument: Ding")));

    REQUIRE(!nlsDos.InsertParams(nlsDing, nlsDong));
    DBGEOL(SZ("nlsDos = ") << nlsDos);
    REQUIRE(!::strcmpf(nlsDos, SZ("My two arguments: Ding, Dong")));

    REQUIRE(!nlsRevved.InsertParams(nlsDing, nlsDong));
    DBGEOL(SZ("nlsRevved = ") << nlsRevved);
    REQUIRE(!::strcmpf(nlsRevved, SZ("My two arguments in rev order: Dong, Ding")));
}


// test TCHAR_STR dinky class

VOID Test03()
{
    TCHAR_STR nlsA(TCH('A'));
    TCHAR_STR nlsM(TCH('m'));
    TCHAR_STR nlsN(TCH('N'));
    TCHAR_STR nlsZ(TCH('z'));
    TCHAR_STR nlsZero(TCH('0'));

    REQUIRE(!!nlsA && !!nlsM && !!nlsN && !!nlsZ && !!nlsZero);

    NLS_STR nlsAlfa = SZ("From %1 to %2, with %3 exceptions.  Amen.");

    REQUIRE(!nlsAlfa.InsertParams(nlsA, nlsZ, nlsZero));
    DBGEOL(SZ("nlsAlfa = ") << nlsAlfa);
    REQUIRE(!::strcmpf(nlsAlfa, SZ("From A to z, with 0 exceptions.  Amen.")));
}


VOID Test04()
{
    DEC_STR nls2001(2001);
    DEC_STR nls2002(2002, 6);

    HEX_STR nlsBeef(0xBEEF);
    HEX_STR nlsBigBeef(0xBEEF, 8);
    HEX_STR nlsDeadBeef(0xDEADBEEF);

    REQUIRE(!!nls2001 && !!nls2002 && !!nlsBeef && !!nlsBigBeef && !!nlsDeadBeef);

    DBGEOL(SZ("nls2001 = ") << nls2001);
    REQUIRE(!::strcmpf(nls2001, SZ("2001")));

    DBGEOL(SZ("nls2002 = ") << nls2002);
    REQUIRE(!::strcmpf(nls2002, SZ("002002")));

    DBGEOL(SZ("nlsBeef = ") << nlsBeef);
    REQUIRE(!::strcmpf(nlsBeef, SZ("beef")));

    DBGEOL(SZ("nlsBigBeef = ") << nlsBigBeef);
    REQUIRE(!::strcmpf(nlsBigBeef, SZ("0000beef")));

    DBGEOL(SZ("nlsDeadBeef = ") << nlsDeadBeef);
    REQUIRE(!::strcmpf(nlsDeadBeef, SZ("deadbeef")));
}


VOID Test05()
{
    NUM_NLS_STR nls1 = 1;
    NUM_NLS_STR nls17 = 17;
    NUM_NLS_STR nls385 = 385;
    NUM_NLS_STR nls8277 = 8277;
    NUM_NLS_STR nls20000 = 20000;
    NUM_NLS_STR nls718333 = 718333;
    NUM_NLS_STR nls6666666 = 6666666;
    NUM_NLS_STR nls40200200 = 40200200;
    NUM_NLS_STR nls100000000 = 100000000;
    NUM_NLS_STR nls2999999991 = 2999999991;

    REQUIRE(!!nls1);
    REQUIRE(!!nls17);
    REQUIRE(!!nls385);
    REQUIRE(!!nls8277);
    REQUIRE(!!nls20000);
    REQUIRE(!!nls718333);
    REQUIRE(!!nls6666666);
    REQUIRE(!!nls40200200);
    REQUIRE(!!nls100000000);
    REQUIRE(!!nls2999999991);

    DBGEOL(SZ("nls1 = ") << nls1);
    DBGEOL(SZ("nls17 = ") << nls17);
    DBGEOL(SZ("nls385 = ") << nls385);
    DBGEOL(SZ("nls8277 = ") << nls8277);
    DBGEOL(SZ("nls20000 = ") << nls20000);
    DBGEOL(SZ("nls718333 = ") << nls718333);
    DBGEOL(SZ("nls6666666 = ") << nls6666666);
    DBGEOL(SZ("nls40200200 = ") << nls40200200);
    DBGEOL(SZ("nls100000000 = ") << nls100000000);
    DBGEOL(SZ("nls2999999991 = ") << nls2999999991);

    REQUIRE(!::strcmpf(nls1,          SZ("1")));
    REQUIRE(!::strcmpf(nls17,         SZ("17")));
    REQUIRE(!::strcmpf(nls385,        SZ("385")));
    REQUIRE(!::strcmpf(nls8277,       SZ("8,277")));
    REQUIRE(!::strcmpf(nls20000,      SZ("20,000")));
    REQUIRE(!::strcmpf(nls718333,     SZ("718,333")));
    REQUIRE(!::strcmpf(nls6666666,    SZ("6,666,666")));
    REQUIRE(!::strcmpf(nls40200200,   SZ("40,200,200")));
    REQUIRE(!::strcmpf(nls100000000,  SZ("100,000,000")));
    REQUIRE(!::strcmpf(nls2999999991, SZ("2,999,999,991")));
}


VOID RunTest()
{
    Test01();
    Test02();
    Test03();
    Test04();
    Test05();

    DBGEOL(SZ("Done!"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\ftpsmx\ftpmgr.cxx ===
#include "..\cpl\ftpmgr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\h\ftphelp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftphelp.h
    FTP Service Manager include file for help numbers

    FILE HISTORY:
        Yi-Hsin   25-Mar-1993   Created

*/


#ifndef _FTPHELP_H_
#define _FTPHELP_H_

#include <uihelp.h>

#define HC_FTPSVCMGR_DIALOG         (HC_UI_FTPMGR_BASE + 1)
#define HC_FTPSECURITY_DIALOG       (HC_UI_FTPMGR_BASE + 2)

#endif  // _FTPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\clicreg.cpp ===
//-------------------------------------------------------------------
//
//  FILE: CLiCLicReg.Cpp
//
//  Summary;
// 		Class implementation for handling the licensing api registration
//
//	Notes;
//		Key = \HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LicenseInfo
//		Value= ErrorControl : REG_DWORD : 0x1
//		Value= Start : REG_DWORD : 0x3
//		Value= Type : REG_DWORD : 0x4
//
//		Subkeys :
//		\SNA
//		\SQL
//		\FilePrint
//
//		Value for All Subkeys=
//		Mode : REG_DWORD :  (0x0 = Per Seat Mode, 0x1 = Concurrent/Per Server Mode)
//		ConcurrentLimit : REG_DWORD : (0x<limit>, ie. 0x100 = 256 concurrent user limit)
//      FamilyDisplayName: RED_SZ : Name for this service (not version specific)
//		DisplayName : REG_SZ : User seen name for this Service entry
//		FlipAllow : REG_DWORD : (0x0 = can change license mode, 0x1 license mode can't
//			be changed.   Server apps are only allowed to switch their license mode
//			once, so after the first switch, this value would be set to non-zero, 
//			then the UI	will not allow for further changes to the licence mode.
//			Changing is currently allowed but a dialog is raised to warn them of the
//			possible violation.
//
//	History
//		11/15/94 MikeMi Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include "CLicReg.hpp"

// Strings for keys and values
//
const WCHAR szLicenseKey[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseInfo";
const WCHAR szErrControlValue[] = L"ErrorControl";
const WCHAR szStartValue[] = L"Start";
const WCHAR szTypeValue[] = L"Type";

const WCHAR szNameValue[] = L"DisplayName";
const WCHAR szFamilyNameValue[] = L"FamilyDisplayName";
const WCHAR szModeValue[] = L"Mode";
const WCHAR szLimitValue[] = L"ConcurrentLimit";
const WCHAR szFlipValue[] = L"FlipAllow";

// set values under License Key
//
const DWORD dwErrControlValue = SERVICE_ERROR_NORMAL; // 1;
const DWORD dwStartValue = SERVICE_DEMAND_START; // 3;
const DWORD dwTypeValue = SERVICE_ADAPTER; // 4;

//-------------------------------------------------------------------
//
//	Method:	CLicReg::CLicReg
//
//	Summary;
//		Contructor
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicReg::CLicReg( )
{
	_hkey = NULL;
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::~CLicReg
//
//	Summary;
//		Destructor
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicReg::~CLicReg( )
{
	Close();
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::CommitNow
//
//	Summary;
//		This will flush the changes made imediately
//
//	Return:
//		ERROR_SUCCESS when this method works.
//		See RegFlushKey for return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicReg::CommitNow()
{
	return( RegFlushKey( _hkey ) );
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::Close
//
//	Summary;
//		This will close the registry. See Open.
//
//	Return: 
//		ERROR_SUCCESS when this method works.
//		See RegCloseKey for return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicReg::Close()
{
    LONG lrt = ERROR_SUCCESS;
    if ( _hkey )
    {
        lrt = ::RegCloseKey( _hkey );
        _hkey = NULL;
    }
    return( lrt  );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicense::Open
//
//	Summary;
//		This will open the registry for License Services Enumeration.
//
//	Arguments;
//		fNew [out] - Was the opened reg key new.
//      pszComputer [in] - the computer name to open the registry on
//              this value maybe null (default), this means local machine
//              should be of the form \\name
//
//	Return:  
//		ERROR_SUCCESS when this method works.
//		See RegCreateKeyEx & RegSetValueEx for error returns.
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicense::Open( BOOL& fNew, LPCWSTR pszComputer )
{
	DWORD dwDisposition;
	LONG  lrt;
    HKEY  hkeyRemote = NULL;

    lrt = RegConnectRegistry( (LPTSTR)pszComputer, 
            HKEY_LOCAL_MACHINE, 
            &hkeyRemote );

    if (ERROR_SUCCESS == lrt)
    {
    	fNew = FALSE;
    	lrt = ::RegCreateKeyEx( hkeyRemote, 
    				szLicenseKey,
    				0,
    				NULL,
    				REG_OPTION_NON_VOLATILE,
    				KEY_ALL_ACCESS,
    				NULL,
    				&_hkey,
    				&dwDisposition );

    	if ((ERROR_SUCCESS == lrt) &&
    		(REG_CREATED_NEW_KEY == dwDisposition) )
    	{
    		fNew = 	TRUE;
    		// Set normal values
    		//
    		lrt = ::RegSetValueEx( _hkey,
    				szErrControlValue,
    				0,
    				REG_DWORD,
    				(PBYTE)&dwErrControlValue,
    				sizeof( DWORD ) );
    		if (ERROR_SUCCESS == lrt)
    		{

    			lrt = ::RegSetValueEx( _hkey,
    					szStartValue,
    					0,
    					REG_DWORD,
    					(PBYTE)&dwStartValue,
    					sizeof( DWORD ) );
    			if (ERROR_SUCCESS == lrt)
    			{

    				lrt = ::RegSetValueEx( _hkey,
    						szTypeValue,
    						0,
    						REG_DWORD,
    						(PBYTE)&dwTypeValue,
    						sizeof( DWORD ) );
    			}
    		}
    	}
        ::RegCloseKey( hkeyRemote );    
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicense::EnumService
//
//	Summary;
//		This will enumerate services listed in the registry for Licensing
//
//	Arguments;
//		iService [in] - This should be zero on the first call and incremented
//			on subsequent calls.
//		pszBuffer [out] - string buffer to place service reg name in
//		cchBuffer [in-out] - the length of the pszBuffer, if not large enough,
//			this value will change to what is needed.
//
//	Return:   
//		ERROR_SUCCESS when this method works.
//		ERROR_NO_MORE_ITEMS when end of enumeration was reached
//		See RegEnumKeyEx for error return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicense::EnumService( DWORD iService, LPWSTR pszBuffer, DWORD& cchBuffer )
{
	LONG lrt;
	FILETIME ftLastWritten;
	
	lrt = ::RegEnumKeyEx( _hkey, 
			iService,
			pszBuffer,
			&cchBuffer,
			0,
			NULL,
			NULL,
			&ftLastWritten );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::CLicRegLicenseService
//
//	Summary;
//		Contructor
//
//	Arguments;
//		pszService [in] - Service Reg Key Name 
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicRegLicenseService::CLicRegLicenseService( LPCWSTR pszService )
{
	_pszService = (LPWSTR)pszService;
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetServie
//
//	Summary;
//		Set the Service Reg Key name
//
//	Arguments;
//		pszService [in] - Service Reg Key Name 
//
//  History;
//		Nov-15-94 MikeMi Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

void
CLicRegLicenseService::SetService( LPCWSTR pszService )
{
	Close();
	_pszService = (LPWSTR)pszService;
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::Open
//
//	Summary;
//		Opens/Create registry entry for this service
//
//	Arguments;
//      pszComputer [in] - the computer name to open the registry on
//              this value maybe null (default), this means local machine
//              should be of the form \\name
//
//	Return:
//		ERROR_SUCCESS - Open/Created Correctly
//		See RegCreateKeyEx for other errors.
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicenseService::Open( LPCWSTR pszComputer, BOOL fCreate )
{
	HKEY  hkeyRoot;
	DWORD dwDisposition;
	LONG  lrt;
    HKEY  hkeyRemote = NULL;

    lrt = RegConnectRegistry( (LPTSTR)pszComputer, 
            HKEY_LOCAL_MACHINE, 
            &hkeyRemote );

    if (ERROR_SUCCESS == lrt)
    {
        if (fCreate)
        {
        	lrt = ::RegCreateKeyEx( hkeyRemote, 
        				szLicenseKey,
        				0,
        				NULL,
        				REG_OPTION_NON_VOLATILE,
        				KEY_ALL_ACCESS,
        				NULL,
        				&hkeyRoot,
        				&dwDisposition );
        }
        else
        {
        	lrt = ::RegOpenKeyEx( hkeyRemote, 
				szLicenseKey,
				0,
				KEY_ALL_ACCESS,
				&hkeyRoot );
        }

    	if (ERROR_SUCCESS == lrt)
    	{
    		// open or create our service key
    		//
            if (fCreate)
            {
        		lrt = ::RegCreateKeyEx( hkeyRoot, 
        				_pszService,
        				0,
        				NULL,
        				REG_OPTION_NON_VOLATILE,
        				KEY_ALL_ACCESS,
        				NULL,
        				&_hkey,
        				&dwDisposition );
            }
            else
            {
           		lrt = ::RegOpenKeyEx( hkeyRoot, 
        				_pszService,
        				0,
        				KEY_ALL_ACCESS,
        				&_hkey );
            }
    		::RegCloseKey( hkeyRoot );
    	}
        ::RegCloseKey( hkeyRemote );    
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::CanChangeMode
//
//	Summary;
//		This will check the registry to see if the license mode 
//		can be changed.
//
//	Return:  TRUE if the mode can be changed, otherwise FALSE
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

BOOL 
CLicRegLicenseService::CanChangeMode()
{
	BOOL frt = TRUE;
	LONG lrt;
	DWORD dwSize = sizeof( DWORD );
	DWORD dwRegType = REG_DWORD;
	DWORD fWasChanged;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szFlipValue,
			0,
			&dwRegType,
			(PBYTE)&fWasChanged,
			&dwSize );

	if ( (ERROR_SUCCESS == lrt) &&
		 (dwRegType == REG_DWORD) &&
		 (dwSize == sizeof( DWORD )) )
	{
		frt = !fWasChanged;
	}
	else
	{
		SetChangeFlag( FALSE );
	}

	return( frt );
}
//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetChangeFlag
//
//	Summary;
//		This will set the change flag in the registry
//
//	Arguments;
//		fHasChanged [in] - Has the license been changed
//
//	Return:
//		ERROR_SUCCESS - The flag was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetChangeFlag( BOOL fHasChanged )
{
	LONG lrt;
    DWORD dwf = (DWORD)fHasChanged;

	lrt = ::RegSetValueEx( _hkey,
			szFlipValue,
			0,
			REG_DWORD,
			(PBYTE)&dwf,
			sizeof( DWORD ) );

	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetMode
//
//	Summary;
//		Set this services licensing mode
//
//	Arguments;
//		lm [in] - the mode to set the registry to
//
//	Return:
//		ERROR_SUCCESS - The mode was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetMode( LICENSE_MODE lm )
{
	LONG lrt;
    DWORD dwlm = (DWORD)lm;

	lrt = ::RegSetValueEx( _hkey,
			szModeValue,
			0,
			REG_DWORD,
			(PBYTE)&dwlm,
			sizeof( DWORD ) );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetUserLimit
//
//	Summary;
//		Set this serices user limit in the registry
//
//	Arguments;
//		dwLimit[in] - the limit to set
//
//	Return:
//		ERROR_SUCCESS - The limit was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetUserLimit( DWORD dwLimit )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szLimitValue,
			0,
			REG_DWORD,
			(PBYTE)&dwLimit,
			sizeof( DWORD ) );

	return( lrt );
}					
//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetMode
//
//	Summary;
//		Retrieve the services license mode from the registry
//
//	Arguments;
//		lm [out] - the mode from the registry
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//			   
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetMode( LICENSE_MODE& lm )
{
	LONG lrt;
	DWORD dwSize = sizeof( LICENSE_MODE );
	DWORD dwRegType = REG_DWORD;
    DWORD dwlm = LICMODE_UNDEFINED;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szModeValue,
			0,
			&dwRegType,
			(PBYTE)&dwlm,
			&dwSize );

    lm = (LICENSE_MODE)dwlm;

	if ( (dwRegType != REG_DWORD) ||
		 (dwSize != sizeof( LICENSE_MODE )) )
	{
		lrt = ERROR_BADDB;
	}
    if (ERROR_SUCCESS != lrt)
    {
        lm = LICMODE_UNDEFINED;
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetUserLimit
//
//	Summary;
//		retrieve the user limit fro this service from the registry
//
//	Arguments;
//		dwLimit [out] - The limit retrieved
//
//	Return:
//
//  Notes:
//		ERROR_SUCCESS - The limit was retrieved
//		See RegQueryValueEx for error returns
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetUserLimit( DWORD& dwLimit )
{
	LONG lrt;
	DWORD dwSize = sizeof( DWORD );
	DWORD dwRegType = REG_DWORD;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szLimitValue,
			0,
			&dwRegType,
			(PBYTE)&dwLimit,
			&dwSize );

	if ( (dwRegType != REG_DWORD) ||
		 (dwSize != sizeof( DWORD )) )
	{
		lrt = ERROR_BADDB;
	}
    if (ERROR_SUCCESS != lrt)
    {
        dwLimit = 0;
    }
	
	return( lrt );
}					

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetDisplayName
//
//	Summary;
//		Retrieve the display name for this service from the registry
//
//	Arguments;
//		pszName [in-out] - the buffer to place the retrieved name
//		cchName [in-out] - the length of the pszName buffer in chars
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetDisplayName( LPWSTR pszName, DWORD& cchName )
{
	LONG lrt;
	DWORD dwSize = cchName * sizeof(WCHAR);
	DWORD dwRegType = REG_SZ;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szNameValue,
			0,
			&dwRegType,
			(PBYTE)pszName,
			&dwSize );

	if ((NULL != pszName) &&  // request for data size
	    (dwRegType != REG_SZ))
	{
		lrt = ERROR_BADDB;
	}

	cchName = dwSize / sizeof( WCHAR );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetDisplayName
//
//	Summary;
//		Set the display name for this service in the regstry
//
//	Arguments;
//		pszName [in] - the null terminated display name
//
//	Return:
//		ERROR_SUCCESS - The name eas set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetDisplayName( LPCWSTR pszName )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szNameValue,
			0,
			REG_SZ,
			(PBYTE)pszName,
			(lstrlen( pszName ) + 1) * sizeof( WCHAR ) );

	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetFamilyDisplayName
//
//	Summary;
//		Retrieve the family display name for this service from the registry
//
//	Arguments;
//		pszName [in-out] - the buffer to place the retrieved name
//		cchName [in-out] - the length of the pszName buffer in chars
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetFamilyDisplayName( LPWSTR pszName, DWORD& cchName )
{
	LONG lrt;
	DWORD dwSize = cchName * sizeof(WCHAR);
	DWORD dwRegType = REG_SZ;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szFamilyNameValue,
			0,
			&dwRegType,
			(PBYTE)pszName,
			&dwSize );

	if ((NULL != pszName) &&  // request for data size
	    (dwRegType != REG_SZ))
	{
		lrt = ERROR_BADDB;
	}

	cchName = dwSize / sizeof( WCHAR );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetFamilyDisplayName
//
//	Summary;
//		Set the Family display name for this service in the regstry
//
//	Arguments;
//		pszName [in] - the null terminated display name
//
//	Return:
//		ERROR_SUCCESS - The name eas set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetFamilyDisplayName( LPCWSTR pszName )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szFamilyNameValue,
			0,
			REG_SZ,
			(PBYTE)pszName,
			(lstrlen( pszName ) + 1) * sizeof( WCHAR ) );

	return( lrt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\cpl\ftpmgr.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpmgr.cxx
       The file contains the classes for the FTP user sessions dialog
    and the security dialog.

    FILE HISTORY:
        YiHsinS         17-Mar-1992     Created
*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_CC
#include <blt.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

extern "C"
{
    #include <winsock.h>       // IN_ADDR, inet_ntoa
    #include <lmapibuf.h>      // For NetApiBufferFree
    #include <ftpd.h>          // For I_Ftp... APIs
    #include <mnet.h>
    #include <ftpmgr.h>
}

#include <lmoloc.hxx>
#include <ftpmgr.hxx>

/*******************************************************************

    NAME:       FTP_USER_LBI::FTP_USER_LBI

    SYNOPSIS:   Constructor. Each LBI represents a user connected
                to the FTP service on the given computer.

    ENTRY:      pszUserName          -  The name of the user
                ulUserID             -  The internal ID used by the FTP
                                        service to represent this user
                fAnonymous           -  TRUE if the user logged on as anonymous
                                        FALSE otherwise.
                pszInternetAddress   -  The address of the host the user
                                        is connected from.
                pszConnectTimeString -  The duration of time the user has
                                        been connected

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_USER_LBI::FTP_USER_LBI( const TCHAR *pszUserName,
                            ULONG        ulUserID,
                            BOOL         fAnonymous,
                            const TCHAR *pszInternetAddress,
                            const TCHAR *pszConnectTimeString )
   : _nlsUserName         ( pszUserName ),
     _ulUserID            ( ulUserID ),
     _fAnonymous          ( fAnonymous ),
     _nlsInternetAddress  ( pszInternetAddress ),
     _nlsConnectTimeString( pszConnectTimeString )
{
    if ( QueryError() )
        return;

    APIERR err = NERR_Success;

    //
    //  If the user name is username@mailhost-style string,
    //  print only the username portion ( everything left of @ )
    //

    ISTR istr( _nlsUserName );
    if ( _nlsUserName.strchr( &istr, TCH('@')))
        _nlsUserName.DelSubStr( istr );

    if (  ( err = _nlsUserName.QueryError() )
       || ( err = _nlsInternetAddress.QueryError() )
       || ( err = _nlsConnectTimeString.QueryError() )
       )
    {
        ReportError( err? err : ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

}

/*******************************************************************

    NAME:       FTP_USER_LBI::FTP_USER_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_USER_LBI::~FTP_USER_LBI()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       FTP_USER_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of the LBI class.

    ENTRY:      plb - the listbox this LBI belongs to
                hdc
                prect
                pGUILTT

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

VOID FTP_USER_LBI::Paint( LISTBOX *plb, HDC hdc, const RECT *prect,
                          GUILTT_INFO *pGUILTT ) const
{
    FTP_USER_LISTBOX *plbUser = ( FTP_USER_LISTBOX *) plb;

    STR_DTE strdteUserName( _nlsUserName );
    STR_DTE strdteInternetAddress( _nlsInternetAddress );
    STR_DTE strdteConnectTime( _nlsConnectTimeString );

    DISPLAY_TABLE cdt( 4, plbUser->QueryColumnWidths() );
    cdt[0] = (DMID_DTE *) (IsAnonymousUser()? plbUser->QueryAnonymousBitmap()
                                            : plbUser->QueryUserBitmap());
    cdt[1] = &strdteUserName;
    cdt[2] = &strdteInternetAddress;
    cdt[3] = &strdteConnectTime;

    cdt.Paint( plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:       FTP_USER_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of the LBI class.
                We compare the user names of the two LBIs.

    ENTRY:      plbi - Pointer to the LBI to compare with

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

INT FTP_USER_LBI::Compare( const LBI *plbi ) const
{
    return _nlsUserName._stricmp( *( ((FTP_USER_LBI *) plbi)->QueryUserName()));
}

/*******************************************************************

    NAME:       FTP_USER_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the user name

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

WCHAR FTP_USER_LBI::QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsUserName );
    return _nlsUserName.QueryChar( istr );
}

/*******************************************************************

    NAME:       FTP_USER_LISTBOX::FTP_USER_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powOwner  - pointer to the owner window
                cid       - resource id of the listbox
                pszServer - the server name to point to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_USER_LISTBOX::FTP_USER_LISTBOX( OWNER_WINDOW *powOwner,
                                    CID           cid,
                                    const TCHAR  *pszServer )
   : BLT_LISTBOX( powOwner, cid ),
     _nlsServer ( pszServer ),
     _nlsUnknown( IDS_UI_UNKNOWN ),
     _pdmdteUser( NULL ),
     _pdmdteAnonymous( NULL ),
     _intlProf()
{
    if ( QueryError() )
        return;

    APIERR err;
    if (  ( err = _nlsServer.QueryError())
       || ( err = _nlsUnknown.QueryError())
       || ( err = _intlProf.QueryError())
       || (( _pdmdteUser = new DMID_DTE( BMID_USER )) == NULL )
       || (( _pdmdteAnonymous = new DMID_DTE( BMID_ANONYMOUS)) == NULL )
       || ( err = _pdmdteUser->QueryError())
       || ( err = _pdmdteAnonymous->QueryError())
       || ( err = DISPLAY_TABLE::CalcColumnWidths( _adx, 4, powOwner, cid,TRUE))
       )
    {
        ReportError( err? err : ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
}

/*******************************************************************

    NAME:       FTP_USER_LISTBOX::~FTP_USER_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_USER_LISTBOX::~FTP_USER_LISTBOX()
{
    delete _pdmdteUser;
    delete _pdmdteAnonymous;

    _pdmdteUser = NULL;
    _pdmdteAnonymous = NULL;
}

/*******************************************************************

    NAME:       FTP_USER_LISTBOX::Fill

    SYNOPSIS:   This method enumerates the users connected to the
                FTP service and add them to the listbox.

    ENTRY:

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

APIERR FTP_USER_LISTBOX::Fill( VOID )
{

    //
    // Enumerate the users connected to the FTP service on the
    // given server.
    //

    DWORD nCount = 0;
    LPFTP_USER_INFO aUserInfo = NULL;
    APIERR err = ::I_FtpEnumerateUsers( (LPWSTR) _nlsServer.QueryPch(),
                                        &nCount,
                                        &aUserInfo );

    if ( err == NERR_Success )
    {
        NLS_STR nlsTimeString;
        NLS_STR nlsInternetAddress;
        if (  (( err = nlsTimeString.QueryError()) == NERR_Success )
           && (( err = nlsInternetAddress.QueryError()) == NERR_Success )
           )
        {
            //
            // Loop through all the users, create LBIs for each of them,
            // and add them to the listbox.
            //
            LPFTP_USER_INFO pUserInfo = aUserInfo;
            for ( INT i = 0; i < (INT) nCount; i++ )
            {
                err = QueryTimeString( pUserInfo->tConnect, &nlsTimeString );
                if ( err != NERR_Success )
                    break;

                IN_ADDR inaddr;
                inaddr.s_addr = pUserInfo->inetHost;
                CHAR *pszInternetAddress = ::inet_ntoa( inaddr );
                if ( err = nlsInternetAddress.MapCopyFrom( pszInternetAddress) )
                    break;

                const TCHAR * pszDisplayName = pUserInfo->pszUser;

                if( ( pszDisplayName == NULL ) || ( *pszDisplayName == '\0' ) )
                {
                    pszDisplayName = _nlsUnknown;
                }

                FTP_USER_LBI *plbi = new FTP_USER_LBI( pszDisplayName,
                                                       pUserInfo->idUser,
                                                       pUserInfo->fAnonymous,
                                                       nlsInternetAddress,
                                                       nlsTimeString );


                if (  ( plbi == NULL )
                   || ( err = plbi->QueryError() )
                   || ( AddItem( plbi ) < 0 )
                   )
                {
                    delete plbi;
                    plbi = NULL;
                    err =  err? err : ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                ++pUserInfo;
            }
        }
    }

    ::NetApiBufferFree( (LPVOID) aUserInfo );

    return err;
}

/*******************************************************************

    NAME:       FTP_USER_LISTBOX::Refresh

    SYNOPSIS:   This method refresh the contents of the listbox.

    ENTRY:

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

APIERR FTP_USER_LISTBOX::Refresh( VOID )
{
    SetRedraw( FALSE );

    //
    // Delete all the original items in the listbox
    //
    DeleteAllItems();

    //
    // Call Fill() to enumerate the users
    //
    APIERR err = Fill();

    Invalidate();
    SetRedraw( TRUE );

    return err;
}

/*******************************************************************

    NAME:       FTP_USER_LISTBOX::QueryTimeString

    SYNOPSIS:   This method turns the time duration to a displayable
                string that complies with the window settings.

    ENTRY:      ulTime   - The elapsed time

    EXIT:       pnlsTime - Pointer to the time display string returned.

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

#define SECONDS_PER_DAY    86400
#define SECONDS_PER_HOUR    3600
#define SECONDS_PER_MINUTE    60

APIERR FTP_USER_LISTBOX::QueryTimeString( ULONG ulTime, NLS_STR *pnlsTime )
{
    INT nDay = (INT) ulTime / SECONDS_PER_DAY;
    ulTime %= SECONDS_PER_DAY;
    INT nHour = (INT) ulTime / SECONDS_PER_HOUR;
    ulTime %= SECONDS_PER_HOUR;
    INT nMinute = (INT) ulTime / SECONDS_PER_MINUTE;
    INT nSecond = (INT) ulTime % SECONDS_PER_MINUTE;

    return _intlProf.QueryDurationStr( nDay, nHour, nMinute, nSecond, pnlsTime);
}

/*******************************************************************

    NAME:       FTP_SVCMGR_DIALOG::FTP_SVCMGR_DIALOG

    SYNOPSIS:   Constructor. This is the user sessions dialog of
                FTP service manager.

    ENTRY:      hwndOwner - Hwnd of the owner window
                pszServer - The name of the server to point to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_SVCMGR_DIALOG::FTP_SVCMGR_DIALOG( HWND         hwndOwner,
                                      const TCHAR *pszServer )
   : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_FTPSVCMGRDLG), hwndOwner ),
     _nlsServer( pszServer ),
     _lbUser   ( this, LB_USERS, pszServer ),
     _pbuttonDisconnect   ( this, BUTTON_DISCONNECT ),
     _pbuttonDisconnectAll( this, BUTTON_DISCONNECT_ALL )

{
    if ( QueryError() != NERR_Success )
        return;

    //
    // Call Refresh() to fill the users in the listbox
    //
    APIERR err = NERR_Success;
    if (  ((err = _nlsServer.QueryError()) != NERR_Success )
       || ((err = Refresh()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    //
    // Set the caption to include the server name if the given
    // server name is not an empty string.
    //
    if ( _nlsServer.QueryTextLength() > 0 )
    {
        RESOURCE_STR nlsCaption( IDS_FTP_USER_SESSIONS_ON_COMPUTER );

        ISTR istr ( _nlsServer );
        istr += 2;  // Skip the two backslashes
        ALIAS_STR nlsSrvWithoutPrefix( _nlsServer.QueryPch( istr ) );

        if (  ((err = nlsCaption.QueryError()) != NERR_Success )
           || ((err = nlsCaption.InsertParams( 1, &nlsSrvWithoutPrefix))
               != NERR_Success)
           )
        {
            ReportError( err );
            return;
        }
        SetText( nlsCaption );
    }
}

/*******************************************************************

    NAME:       FTP_SVCMGR_DIALOG::~FTP_SVCMGR_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_SVCMGR_DIALOG::~FTP_SVCMGR_DIALOG()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       FTP_SVCMGR_DIALOG::Refresh

    SYNOPSIS:   Refresh the contents of the user listbox

    ENTRY:

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

APIERR FTP_SVCMGR_DIALOG::Refresh( VOID )
{
    AUTO_CURSOR autocur;

    APIERR err = _lbUser.Refresh();
    if ( err == NERR_Success )
    {
        //
        // Enable/Disable the Disconnect/DisconnectAll button
        // depending on whether there are users in the listbox
        // after the refresh.
        //
        _pbuttonDisconnect.Enable( ( _lbUser.QueryCount() > 0 )
                                   && (_lbUser.QuerySelCount() > 0 ));
        _pbuttonDisconnectAll.Enable( _lbUser.QueryCount() > 0 );
    }
    _lbUser.ClaimFocus();

    return err;
}

/*******************************************************************

    NAME:       FTP_SVCMGR_DIALOG::OnCommand

    SYNOPSIS:   Process all commands for Security, Refresh,
                Disconnect, Disconnect All buttons.

    ENTRY:      event - The event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

BOOL FTP_SVCMGR_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;
    switch ( event.QueryCid() )
    {
        case BUTTON_DISCONNECT:
        {
            INT *paSelItems = NULL;
            BOOL fAtLeastDeleteOneUser = FALSE;

            do {  // not a loop

                INT nCount = _lbUser.QuerySelCount();

                if ( nCount == 0 )
                {
                    // If no user is selected, just ignore the command.
                    break;
                }
                else if ( nCount > 1 )
                {
                    // If more than one user is selected in the listbox,
                    // give a warning to the user to see if he/she
                    // really wanted to disconnect the selected users.

                    if ( ::MsgPopup( this,
                           IDS_CONFIRM_DISCONNECT_SELECTED_USERS,
                           MPSEV_WARNING, MP_YESNO, MP_NO ) != IDYES )
                    {
                        break;
                    }
                }

                //
                //  Get all the items selected in the listbox
                //
                paSelItems = (INT *) new BYTE[ sizeof(INT) * nCount ];
                if ( paSelItems == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if ( err = _lbUser.QuerySelItems( paSelItems, nCount ))
                    break;

                //
                // Pop up an warning containing the user name to be
                // disconnected if only one user is selected. Otherwise,
                // we would have already pop up the warning.
                //
                FTP_USER_LBI *pusrlbi = _lbUser.QueryItem( paSelItems[0] );
                if ( nCount == 1 )
                {
                    if ( IDYES != ::MsgPopup( this,
                                             IDS_CONFIRM_DISCONNECT_ONE_USER,
                                             MPSEV_WARNING,
                                             MP_YESNO,
                                             *(pusrlbi->QueryUserName()),
                                             MP_NO ))
                    {
                        break;
                    }
                }

                //
                // Disconnect the selected users one by one. If an error
                // occurred while disconnecting a user, we would break out
                // of the loop and the rest of the users will not be
                // disconnected.
                //
                AUTO_CURSOR autocur;
                for ( INT i = 0; i < nCount; i++ )
                {
                    pusrlbi = _lbUser.QueryItem( paSelItems[i] );
                    err = ::I_FtpDisconnectUser( (LPWSTR) _nlsServer.QueryPch(),
                                                 pusrlbi->QueryUserID());

                    if( err == NERR_UserNotFound )
                    {
                        //
                        //  The user is no longer connected.  Since this
                        //  is what the admin wants anyway, we'll pretend
                        //  it succeeded.
                        //

                        err = NERR_Success;
                    }

                    if ( err != NERR_Success )
                        break;

                    fAtLeastDeleteOneUser = TRUE;
                }


            } while ( FALSE );

            if ( err )
                ::MsgPopup( this, err );

            //
            // If at least one user has be disconnected, refresh the listbox.
            //
            if ( fAtLeastDeleteOneUser )
            {
                if ( err = Refresh() )
                    ::MsgPopup( this, err );
            }

            delete paSelItems;
            break;
        }

        case BUTTON_DISCONNECT_ALL:
        {
            //
            // Give a warning to the user to see if he really wants to
            // disconnect all users.
            //
            if ( IDYES == ::MsgPopup( this,
                          IDS_CONFIRM_DISCONNECT_ALL_USERS,
                          MPSEV_WARNING, MP_YESNO, MP_NO ))
            {
                //
                // Disconnect all Users and refresh the listbox
                //
                AUTO_CURSOR autocur;
                if ( (err = ::I_FtpDisconnectUser(
                      (LPWSTR) _nlsServer.QueryPch(), 0)) == NERR_Success )
                {
                    err = Refresh();
                }

                if ( err != NERR_Success )
                    ::MsgPopup( this, err );

            }
            break;
        }

        case BUTTON_SECURITY:
        {
            //
            //  Show the security dialog.
            //
            AUTO_CURSOR autocur;
            FTP_SECURITY_DIALOG *pdlg = new FTP_SECURITY_DIALOG( QueryHwnd(),
                                                                _nlsServer );
            BOOL fOK = FALSE;
            if (  ( pdlg == NULL )
               || ( err = pdlg->QueryError() )
               || ( err = pdlg->Process( &fOK ) )
               )
            {
                err = err? err: ERROR_NOT_ENOUGH_MEMORY;
            }
            else if ( fOK )
            {
                // If the user clicks OK in the security dialog,
                // we need to refresh the listbox since the service
                // might blew some users away depending on the new
                // read/write access.
                err = Refresh();
            }

            if ( err != NERR_Success )
                ::MsgPopup( this, err );

            delete pdlg;
            pdlg = NULL;
            break;
        }

        case BUTTON_REFRESH:
        {
            if ( (err = Refresh()) != NERR_Success )
                ::MsgPopup( this, err );
            break;
        }

        case LB_USERS:
            //
            // Enable the Disconnect button only if the user has a selection
            // in the listbox.
            //
            _pbuttonDisconnect.Enable( ( _lbUser.QueryCount() > 0 )
                                       && (_lbUser.QuerySelCount() > 0 ));
            //
            // Falls through
            //

        default:
            return DIALOG_WINDOW::OnCommand( event );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       FTP_SVCMGR_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

ULONG FTP_SVCMGR_DIALOG::QueryHelpContext( VOID )
{
    return HC_FTPSVCMGR_DIALOG;
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::FTP_SECURITY_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndOwner - Hwnd of the owner window
                pszServer - The name of the server name to point to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_SECURITY_DIALOG::FTP_SECURITY_DIALOG( HWND         hwndOwner,
                                          const TCHAR *pszServer )
    : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_FTPSECDLG ), hwndOwner ),
      _nlsServer        ( pszServer ),
      _fLocal           ( TRUE ),
      _cbPartition      ( this, CB_PARTITION ),
      _sltFileSysInfo   ( this, SLT_FILESYSTEMTYPE ),
      _checkbReadAccess ( this, CHECKB_READ ),
      _checkbWriteAccess( this, CHECKB_WRITE ),
      _ulReadAccess     ( 0 ),
      _ulWriteAccess    ( 0 ),
      _nCurrentDiskIndex( 0 )
{
    if ( QueryError() )
        return;

    //
    // Get security information on all drives
    //
    APIERR err;
    if (  ((err = _nlsServer.QueryError()) != NERR_Success )
       || ((err = ::I_FtpQueryVolumeSecurity( (LPWSTR) _nlsServer.QueryPch(),
            &_ulReadAccess, &_ulWriteAccess )) != NERR_Success )
       || ((err = AddDrives()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    if ( _cbPartition.QueryCount() > 0 )
    {
        //
        // Select the first partition and show its information
        //
        _cbPartition.SelectItem( 0 );
        if ((err = ShowCurrentPartitionInfo()) != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }
    else
    {
        // Popup an error if there are not partitions on the machine to
        // configure.
        ReportError( IDS_NO_PARTITION );
        return;
    }

    //
    // Set the caption to include the server name if the given server name
    // is not an empty string.
    //
    if ( _nlsServer.QueryTextLength() > 0 )
    {
        RESOURCE_STR nlsCaption( IDS_FTP_SERVER_SECURITY_ON_COMPUTER );

        ISTR istr ( _nlsServer );
        istr += 2;  // Skip the two backslashes
        ALIAS_STR nlsSrvWithoutPrefix( _nlsServer.QueryPch( istr ) );

        if (  ((err = nlsCaption.QueryError()) != NERR_Success )
           || ((err = nlsCaption.InsertParams( 1, &nlsSrvWithoutPrefix))
               != NERR_Success)
           )
        {
            ReportError( err );
            return;
        }
        SetText( nlsCaption );
    }
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::~FTP_SECURITY_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

FTP_SECURITY_DIALOG::~FTP_SECURITY_DIALOG()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::AddDrivers

    SYNOPSIS:   Get all drivers on the selected server and add
                them to the partition combo

    ENTRY:

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         6-Apr-1993      Created

********************************************************************/

APIERR FTP_SECURITY_DIALOG::AddDrives( VOID )
{
    APIERR err = NERR_Success;
    _fLocal = TRUE;

    //
    // Check if the given server is the local computer
    //
    if ( _nlsServer.QueryTextLength() > 0 )
    {
        LOCATION loc;  // local machine
        NLS_STR nlsLocalComputer;

        if (  ( (err = nlsLocalComputer.QueryError()) != NERR_Success )
           || ( (err = loc.QueryError()) != NERR_Success )
           || ( (err = loc.QueryDisplayName(&nlsLocalComputer)) != NERR_Success)
           )
        {
            return err;
        }

        ISTR istr( _nlsServer );
        istr += 2;  // Skip the two backslashes

        if ( ::I_MNetComputerNameCompare( nlsLocalComputer,
                                          _nlsServer.QueryPch( istr)) != 0 )
            _fLocal = FALSE;
    }


    //
    //  If the machine is local, use GetDriveType to get all the possible
    //  drives.
    //
    if ( _fLocal )
    {
        //
        // Add local drive letters to the combobox
        //
        TCHAR szDevice[4];   // This will contain A:, B:, ...
        ::strcpyf( szDevice, SZ("?:\\"));

        for ( INT i = TCH('Z'); i >= TCH('A'); i-- )
        {
            szDevice[0] = (TCHAR)i;
            szDevice[2] = TCH('\\');
            ULONG ulRes= ::GetDriveType( szDevice );

            if (  ( ulRes == DRIVE_FIXED )
               || ( ulRes == DRIVE_REMOVABLE )
               || ( ulRes == DRIVE_CDROM )
               )
            {
                szDevice[2] = 0;   // nuke the backslash at the end
                if ( _cbPartition.AddItem( szDevice ) < 0 )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }
    }
    //
    //  If the machine is not the local one, use MNetServerDiskEnum
    //  to get all the drives.
    //
    else
    {
        BYTE  *pbBuffer = NULL;
        UINT  nEntriesRead = 0;
        err = ::MNetServerDiskEnum( _nlsServer,
                                    0,
                                    &pbBuffer,
                                    &nEntriesRead );

        if ( err == NERR_Success )
        {
            UIASSERT( pbBuffer != NULL );
            for ( UINT i = 0; i < nEntriesRead; i++ )
            {
                ALIAS_STR nls( (TCHAR *) pbBuffer );
                if ( _cbPartition.AddItem( nls ) < 0 )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pbBuffer += nls.QueryTextSize();
            }
        }

        ::MNetApiBufferFree( &pbBuffer );
    }

    return err;
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::ShowCurrentPartitionInfo

    SYNOPSIS:   Show the information ( i.e. file system information,
                read access, write access ) of the current selected
                partition

    ENTRY:

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

APIERR FTP_SECURITY_DIALOG::ShowCurrentPartitionInfo( VOID )
{
    APIERR err = NERR_Success;

    //
    // Get the selected drive
    //
    NLS_STR nlsSelectedDrive;
    NLS_STR nlsFileSysInfo;
    if (  ((err = nlsSelectedDrive.QueryError())==NERR_Success)
       && ((err = _cbPartition.QueryItemText(&nlsSelectedDrive))==NERR_Success)
       && ((err = nlsSelectedDrive.AppendChar( TCH('\\')))==NERR_Success)
       )
    {
        //
        // Update _nCurrentDiskIndex
        //
        ISTR istr( nlsSelectedDrive );
        _nCurrentDiskIndex = nlsSelectedDrive.QueryChar( istr ) - TCH('A');

        //
        // Show the security information
        //
        _checkbWriteAccess.Enable( TRUE );
        _checkbReadAccess.SetCheck(  (INT) _ulReadAccess &
                                           ( 0x1 <<_nCurrentDiskIndex ));
        _checkbWriteAccess.SetCheck( (INT) _ulWriteAccess &
                                           ( 0x1 <<_nCurrentDiskIndex));

        if ( _fLocal )
        {
            //
            // Show the file system information
            //
            ULONG ulRes = ::GetDriveType( (LPWSTR) nlsSelectedDrive.QueryPch());
            if (( ulRes == DRIVE_REMOVABLE ) || ( ulRes == DRIVE_CDROM ))
            {
                err = nlsFileSysInfo.Load( ulRes == DRIVE_REMOVABLE
                                           ? IDS_DRIVE_REMOVABLE
                                           : IDS_DRIVE_CDROM );

                //
                // Disable Allow Write checkbox when the selection is a CDROM
                //
                if ( ulRes == DRIVE_CDROM )
                    _checkbWriteAccess.Enable( FALSE );
            }
            else
            {
               err = GetFileSystemInfo( nlsSelectedDrive, &nlsFileSysInfo);

               // If we cannot get the file system info,
               // then just show them as unknown type.
               if ( err != NERR_Success )
                   err = nlsFileSysInfo.Load( IDS_UI_UNKNOWN );
            }
        }
        else
        {
            err = nlsFileSysInfo.Load( IDS_UI_UNKNOWN );
        }
    }

    if ( err == NERR_Success )
        _sltFileSysInfo.SetText( nlsFileSysInfo );

    return err;
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::GetFileSystemInfo

    SYNOPSIS:   Get the file system information for the given drive

    ENTRY:      pszDrive        - The drive to get information on

    EXIT:       pnlsFileSysInfo - Pointer to a string describing the
                                  file system info of pszDrive

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/
#define MAX_FILE_SYSTEM_INFO_LENGTH  20

APIERR FTP_SECURITY_DIALOG::GetFileSystemInfo( const TCHAR *pszDrive,
                                               NLS_STR     *pnlsFileSysInfo )
{
    TCHAR szFileSysInfo[ MAX_FILE_SYSTEM_INFO_LENGTH ];
    APIERR err = NERR_Success;
    if ( ::GetVolumeInformation(  (LPWSTR) pszDrive,
                                  NULL, 0, NULL, NULL, NULL,
                                  szFileSysInfo, MAX_FILE_SYSTEM_INFO_LENGTH) )
    {
        err = pnlsFileSysInfo->CopyFrom( szFileSysInfo );
    }
    else
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::SaveDriveSecurity

    SYNOPSIS:   Save the read/write access indicated by the current
                read/write checkbox to the drive indexed by _nCurrentDiskIndex
                ( 0 represents A:, 1 represents B:,...).

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

VOID FTP_SECURITY_DIALOG::SaveDriveSecurity( VOID )
{
    //
    // Save the read access depending on the read access checkbox
    //
    if ( _checkbReadAccess.QueryCheck() )
        _ulReadAccess |=  ( 0x1 << _nCurrentDiskIndex );
    else
        _ulReadAccess &=  ~( 0x1 << _nCurrentDiskIndex );

    //
    // Save the write access depending on the write access checkbox
    //
    if ( _checkbWriteAccess.QueryCheck() )
        _ulWriteAccess |=  ( 0x1 << _nCurrentDiskIndex );
    else
        _ulWriteAccess &=  ~( 0x1 << _nCurrentDiskIndex );
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::OnOK

    SYNOPSIS:   Set the security (read/write access) back to the service

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

BOOL FTP_SECURITY_DIALOG::OnOK( VOID )
{
    //
    // Store the information of the last selected partition
    //
    SaveDriveSecurity();

    //
    // Set the Read mask and Write mask of the partitions
    //
    APIERR err = ::I_FtpSetVolumeSecurity( (LPWSTR) _nlsServer.QueryPch(),
                                           _ulReadAccess,
                                           _ulWriteAccess);
    if ( err != NERR_Success )
        ::MsgPopup( this, err );
    else
        Dismiss( TRUE );

    return TRUE;
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::OnCommand

    SYNOPSIS:   When the user change selection in the partition combo,
                we must save the read/write access of the previous selected
                drive and show the info on the currently selected drive.

    ENTRY:      event - The event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

BOOL FTP_SECURITY_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    if (  ( event.QueryCid() ==  CB_PARTITION )
       && ( event.QueryCode() == CBN_SELCHANGE )
       )
    {
        //
        // Save read/write access of the previously selected partition
        // NOTE: _nCurrentDiskIndex still points to the previously selected
        //       partition
        //
        SaveDriveSecurity();

        //
        // Show current selected disk info
        //
        APIERR err = ShowCurrentPartitionInfo();
        if ( err != NERR_Success )
            ::MsgPopup( this, err );

        return TRUE;
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:       FTP_SECURITY_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        YiHsinS         25-Mar-1993     Created

********************************************************************/

ULONG FTP_SECURITY_DIALOG::QueryHelpContext( VOID )
{
    return HC_FTPSECURITY_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\ftpsmx\ftpsmx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpsmx.cxx
        This contains the main module for the FTP Server Manager 
    Extension. It contains "SMLoadMenuW",...

    FILE HISTORY:
        YiHsinS     25-Mar-1993		Templated from smxdebug.c	

*/


#define INCL_NET                 
#define INCL_NETLIB              
#define INCL_NETWKSTA              
#define INCL_WINDOWS             
#define INCL_NETERRORS           
#define INCL_DOSERRORS           
#include <lmui.hxx>              
                                 
#if defined(DEBUG)               
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif                           
                                 
#include <uiassert.hxx>          
#include <uitrace.hxx>           
                                 
#define INCL_BLT_WINDOW          
#define INCL_BLT_DIALOG          
#define INCL_BLT_CONTROL         
#define INCL_BLT_MSGPOPUP        
#include <blt.hxx>               
                                 
#include <dbgstr.hxx>            
                                 
extern "C"                       
{                                
    #include <smx.h>            // Server Manager extension defs
    #include <ftpmgr.h>        
}                                

extern "C"
{
    //
    //  Dll load/unload entry point
    //
    BOOL FAR PASCAL FtpSmxDllInitialize( HINSTANCE hInstance,
                                         DWORD     nReason,
                                         LPVOID    pReserved );
}

#include <lmowks.hxx>          // WKSTA_10
#include <ftpmgr.hxx>          // FTP_SVCMGR_DIALOG  

//
//  Constants
//

#define FTP_EXT_VERSION  0     // Version number for the extension interface

//
//  Globals.
//

HINSTANCE _hInstance;
HWND      _hwndMessage;
DWORD     _dwVersion;
DWORD     _dwDelta;

/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance   - Program instance of the caller.

    EXIT:       The DLL has been initialized.

    RETURNS:    BOOL        - TRUE  = Initialization OK.
                              FALSE = Initialization failed.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
BOOL InitializeDll( HINSTANCE hInstance )
{
    //
    //  Save the instance handle.
    //

    _hInstance = hInstance;

    APIERR err = BLT::Init( _hInstance, 
                            IDRSRC_FTPMGR_BASE, IDRSRC_FTPMGR_LAST,
                            IDS_UI_FTPMGR_BASE, IDS_UI_FTPMGR_LAST );

    if ( err == NERR_Success )
    {
        err = BLT::RegisterHelpFile( _hInstance,
                                     IDS_FTPSMX_HELPFILENAME,
                                     HC_UI_FTPMGR_BASE, HC_UI_FTPMGR_LAST );
    }
    
    if ( err != NERR_Success )
        BLT::Term( _hInstance );

    return ( err == NERR_Success );

}   // InitializeDll

/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Kill the NetUI goodies.
    //

    BLT::DeregisterHelpFile( _hInstance, 0 );
    BLT::Term( _hInstance );

    //
    //  Just in case we try to do anything goofy.
    //

    _hInstance = NULL;

}   // TerminateDll

/*******************************************************************

    NAME:       RunFtpSvcMgr

    SYNOPSIS:   Invoke the user session dialog of the FTP Server 
                Manager Extension

    ENTRY:      hWnd       - Window handle of parent window.
                pszServer  - The name of the server to set focus to

    RETURNS:    APIERR

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID RunFtpSvcMgr( HWND hWnd, const TCHAR *pszServer )
{

    AUTO_CURSOR autocur;

    // 
    // Get the help file name
    //
 
    RESOURCE_STR nlsHelpFileName( IDS_FTPSMX_HELPFILENAME );
    APIERR err = nlsHelpFileName.QueryError();

    //
    // Invoke the user session dialog
    //

    if ( err == NERR_Success ) 
    {
        FTP_SVCMGR_DIALOG * pDlg = new FTP_SVCMGR_DIALOG( hWnd, 
                                                          pszServer );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->QueryError();

        if ( err == NERR_Success )
            err = pDlg->Process();

        delete pDlg;
        pDlg = NULL;
    }

    if( err != NERR_Success )                   
    {                                           
        // Try to see why we get the rpc server unavailable error.
        // Mainly, we want to distinguish between the case where
        // the server is not found v.s. the ftp service is 
        // unavailable.

        if ( err == RPC_S_SERVER_UNAVAILABLE )  
        {
            WKSTA_10 wksta10( pszServer );
            APIERR errTemp = wksta10.QueryError();

            if ( errTemp == NERR_Success )
            { 
                errTemp = wksta10.GetInfo();
                if ( errTemp != NERR_Success ) 
                {
                    // An error occurred while trying to do NetWorkstaGetInfo
                    // at level 10 ( no privilege needed). Hence, the problem
                    // might be bad path... We thus report the error 
                    // from NetWkstaGetInfo ( level 10 ).
                    err = errTemp;
                }
            }
        }
   
        //
        // At this point, either the remote computer exist
        // or wksta10 object failed to construct. Hence, report that the
        // FTP Service is unavailable.
        //
        if ( err == RPC_S_SERVER_UNAVAILABLE )  
        {
            ::MsgPopup( hWnd, IERR_FTP_SERVICE_UNAVAILABLE_ON_COMPUTER, 
                        MPSEV_ERROR, MP_OK, pszServer );
        }
        else
        {
            ::MsgPopup( hWnd, err );
        }
    }                                           

}   // RunFtpSvcMgr

/*******************************************************************

    NAME:       FtpSmxDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance   - A handle to the DLL.

                nReason     - Indicates why the DLL entry
                              point is being called.

                pReserved   - Reserved.

    RETURNS:    BOOL        - TRUE  = DLL init was successful.
                              FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
BOOL FAR PASCAL FtpSmxDllInitialize( HINSTANCE hInstance,
                                     DWORD     nReason,
                                     LPVOID    pReserved )
{
    UNREFERENCED( pReserved );

    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // FtpSmxDllInitialize


/*******************************************************************

    NAME:       SMELoadMenuW

    SYNOPSIS:   This DLL entrypoint notifies the extension that it
                is getting loaded by the application.

    ENTRY:      hwndMessage  - The "owning" window.

                psmsload     - Points to an SMS_LOADMENU
                               structure containing load
                               parameters.

    RETURNS:    DWORD        - Actually an APIERR, should be
                               0 if successful.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
DWORD PASCAL SMELoadMenuW( HWND          hwndMessage,
                           PSMS_LOADMENU psmsload )
{
    if ( psmsload == NULL )
        return ERROR_INVALID_PARAMETER;

    _hwndMessage = hwndMessage;
    _dwDelta     = psmsload->dwMenuDelta;

    _dwVersion   = FTP_EXT_VERSION;
    if( psmsload->dwVersion > _dwVersion )
    {
        psmsload->dwVersion = _dwVersion;
    }
    else if( psmsload->dwVersion < _dwVersion )
    {
        _dwVersion = psmsload->dwVersion;
    }

    psmsload->dwServerType = 0;  // Don't need special menu for View 

    APIERR err = NERR_Success;
    if (  ( ::LoadString( _hInstance, IDS_FTPSMX_MENUNAME, 
                     psmsload->szMenuName, MENU_TEXT_LEN ) == 0 )
       || ( ::LoadString( _hInstance, IDS_FTPSMX_HELPFILENAME, 
                     psmsload->szHelpFileName, MAX_PATH-1 ) == 0 )
       || ( (psmsload->hMenu = ::LoadMenu( _hInstance, 
                               MAKEINTRESOURCE( ID_FTPSMX_MENU ))) == NULL )
       )
    {
        err = GetLastError();
    }

    return err;

}   // SMELoadMenuW


/*******************************************************************

    NAME:       SMEGetExtendedErrorStringW

    SYNOPSIS:   If SMELoadW returns ERROR_EXTENDED_ERROR, then this
                entrypoint should be called to retrieve the error
                text associated with the failure condition.

    RETURNS:    LPTSTR  - The extended error text.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
LPTSTR PASCAL SMEGetExtendedErrorStringW( VOID )
{

    // This extension will never return ERROR_EXTENDED_ERROR when
    // SMELoad fails.
    return NULL;

}   // SMEGetExtendedErrorStringW

/*******************************************************************

    NAME:       SMEMenuAction

    SYNOPSIS:   Notifies the extension DLL that one of its menu
                items has been selected.

    ENTRY:      dwEventId  - The menu ID being activated (should be 1-99).

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId )
{

    APIERR err = NERR_Success;

    //
    // Get the number of servers selected 
    //
    SMS_GETSELCOUNT smsget;
    if (  (::SendMessage(_hwndMessage, SM_GETSELCOUNT, 0, (LPARAM)&smsget) == 0)
       || (smsget.dwItems == 0 ) 
       )
    {
        // No servers are selected
        err = IDS_NO_SERVERS_SELECTED;
    }
    else
    {

        //
        // Get the name of the selected server
        // ( There should only be one since server manager is single select
        // only ).
        //

        SMS_GETSERVERSEL smssel;
        if ( !SendMessage( _hwndMessage, SM_GETSERVERSEL, 0, (LPARAM)&smssel ))
        {
            err = IDS_CANNOT_GET_SERVER_SELECTION;
        }
        else
        {
            switch( dwEventId )
            {
                case IDM_FTP_SERVICE:
                    RunFtpSvcMgr( hwndParent, smssel.szServerName );
                    break;

                default:   
                    //
                    // Who knows? Just ignore it.
                    //
                    break;
            }
        }
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( hwndParent, err );
    }

}   // SMEMenuAction

/*******************************************************************

    NAME:       SMEUnloadMenu

    SYNOPSIS:   Notifies the extension DLL that it is getting unloaded.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID PASCAL SMEUnloadMenu( VOID )
{
    //
    //  Nothing to do
    //

}   // SMEUnloadMenu


/*******************************************************************

    NAME:       SMEInitializeMenu

    SYNOPSIS:   Notifies the extension DLL that the main menu is
                getting activated.  The extension should use this
                opportunity to perform any menu manipulations.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID PASCAL SMEInitializeMenu( VOID )
{
    //
    //  Nothing to do
    //

}   // SMEInitializeMenu


/*******************************************************************

    NAME:       SMERefresh

    SYNOPSIS:   Notifies the extension DLL that the user has requested
                a refresh.  The extension should use this opportunity
                to update any cached data.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
VOID PASCAL SMERefresh( HWND hwndParent )
{
    //
    //  Don't need to do refresh since this extension does
    //  not recognize additional servers.
    //

}   // SMERefresh


/*******************************************************************

    NAME:       SMEValidateW

    SYNOPSIS:   Tries to recognize the given server.

    ENTRY:      psmsvalidate  - Points to an SMS_VALIDATE
                                structure.

    RETURNS:    BOOL          - TRUE if recognized,
                                FALSE otherwise.

    HISTORY:
        YiHsinS		25-Mar-1993	Created

********************************************************************/
BOOL PASCAL SMEValidateW( PSMS_VALIDATE psmsvalidate )
{
    UNREFERENCED( psmsvalidate );
    //
    //  This extension does not recognize additional servers
    //
    return FALSE;

}   // SMEValidateW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\h\ftpmgr.h ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1993               **/
/*****************************************************************/

/*
 *  ftpmgr.h
 *  This manifests are used by the ftp service manager dialogs
 *  in the control panel applet and the server manager extension dll
 *
 *  History:
 *      Yi-HsinS        3/18/93         Created
 *
 */

#ifndef _FTPMGR_H_
#define _FTPMGR_H_

#include <uirsrc.h>
#include <uimsg.h>

/*
 *  Menu Ids - used in server manager extension dll only
 */

#define ID_FTPSMX_MENU                  1000
#define IDM_FTP_SERVICE                 1

/*
 *  Resource Ids from 12000-12999 are reserved for ftpmgr.cpl and ftpsmx.dll
 */

/*
 *  Icons - used in the control panel applet only
 */

#define IDI_FTPCPA_ICON                 12001

/*
 *  Bitmaps
 */

#define BMID_USER                       12002
#define BMID_ANONYMOUS                  12003

/*
 *  Dialog Numbers
 */

#define IDD_FTPSVCMGRDLG                12004
#define IDD_FTPSECDLG                   12005

/*
 *  FTP User Sessions Dialog
 */

// The following four needs to be consecutive numbers.
#define LB_USERS                        105
#define LBHEADER_USER_NAME              106
#define LBHEADER_INTERNET_ADDRESS       107
#define LBHEADER_TIME_CONNECTED         108

#define BUTTON_DISCONNECT               109
#define BUTTON_DISCONNECT_ALL           110
#define BUTTON_SECURITY                 111
#define BUTTON_REFRESH                  112


/*
 *  FTP Server Security Dialog
 */

#define CB_PARTITION                    106
#define CHECKB_READ                     107
#define CHECKB_WRITE                    108
#define SLT_FILESYSTEMTYPE              110

/*
 *  String IDs
 */

// The following are used in the control panel applet only
#define IDS_FTPCPA_NAME_STRING                (IDS_UI_FTPMGR_BASE+1)
#define IDS_FTPCPA_INFO_STRING                (IDS_UI_FTPMGR_BASE+2)
#define IDS_CPL_HELPFILENAME                  (IDS_UI_FTPMGR_BASE+3)
#define IDS_START_FTPSVC_NOW                  (IDS_UI_FTPMGR_BASE+4)
#define IDS_FTPCPA_CAPTION                    (IDS_UI_FTPMGR_BASE+5)

// The following are used in the server manager extension only
#define IDS_FTPSMX_MENUNAME                   (IDS_UI_FTPMGR_BASE+100)
#define IDS_FTPSMX_HELPFILENAME               (IDS_UI_FTPMGR_BASE+101)
#define IDS_NO_SERVERS_SELECTED               (IDS_UI_FTPMGR_BASE+102)
#define IDS_CANNOT_GET_SERVER_SELECTION       (IDS_UI_FTPMGR_BASE+103)

// The following are common to both the control panel applet and
// server manager extension
#define IDS_FTP_USER_SESSIONS_ON_COMPUTER     (IDS_UI_FTPMGR_BASE+200)
#define IDS_FTP_SERVER_SECURITY_ON_COMPUTER   (IDS_UI_FTPMGR_BASE+201)
#define IDS_CONFIRM_DISCONNECT_SELECTED_USERS (IDS_UI_FTPMGR_BASE+202)
#define IDS_CONFIRM_DISCONNECT_ONE_USER       (IDS_UI_FTPMGR_BASE+203)
#define IDS_CONFIRM_DISCONNECT_ALL_USERS      (IDS_UI_FTPMGR_BASE+204)
#define IDS_DRIVE_REMOVABLE                   (IDS_UI_FTPMGR_BASE+205)
#define IDS_DRIVE_CDROM                       (IDS_UI_FTPMGR_BASE+206)
#define IDS_NO_PARTITION                      (IDS_UI_FTPMGR_BASE+207)
#define IERR_FTP_SERVICE_UNAVAILABLE              (IDS_UI_FTPMGR_BASE+208)
#define IERR_FTP_SERVICE_UNAVAILABLE_ON_COMPUTER  (IDS_UI_FTPMGR_BASE+209)

/*
 *  Help Context
 */
#include <ftphelp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\ftpmgr\cpl\ftpmcpl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpmcpl.cxx
    This is the main module for the FTP Server Control Panel Applet.
    It contains the "CplApplet" function.


    FILE HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            26-Jun-2000      CPlApplet takes HWND, UINT, LPARAM, LPARAM

*/



#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <lmoloc.hxx>
#include <srvsvc.hxx>

extern "C"
{
    #include <cpl.h>               // Multimedia CPL defs
    #include <ftpmgr.h>
    #include <ftpd.h>
}


extern "C"
{
    //
    //  Control Panel Applet entry point.
    //

    LONG FAR PASCAL CPlApplet( HWND hwndCPl,
                               UINT nMsg,
                               LPARAM lParam1,
                               LPARAM lparam2 );

    //
    //  DLL load/unload entry point.
    //

    BOOL FAR PASCAL FtpMgrDllInitialize( HINSTANCE hInstance,
                                         DWORD  nReason,
                                         LPVOID pReserved );

    //
    //  Globals.
    //

    HINSTANCE _hCplInstance = NULL;

}   // extern "C"

#include <ftpmgr.hxx>

//
//  This is the "type" for an applet startup function.
//

typedef APIERR (* PCPL_APPLET_FUNC)( HWND hWnd );


//
//  We'll keep one of these structures for each applet in this DLL.
//

typedef struct _CPL_APPLET
{
    int                 idIcon;
    int                 idName;
    int                 idInfo;
    int                 idHelpFile;
    DWORD               dwHelpContext;
    LONG                lData;
    PCPL_APPLET_FUNC    pfnApplet;

} CPL_APPLET;


//
//  Forward reference prototypes.
//

APIERR RunFtpSvcMgr( HWND hWnd );


//
//  Our applet descriptors.
//

CPL_APPLET CplApplets[] = {
                              {  // FTP Server applet
                                 IDI_FTPCPA_ICON,
                                 IDS_FTPCPA_NAME_STRING,
                                 IDS_FTPCPA_INFO_STRING,
                                 IDS_CPL_HELPFILENAME,
                                 HC_FTPSVCMGR_DIALOG,
                                 0L,
                                 &RunFtpSvcMgr
                              }
                          };

#define NUM_APPLETS ( sizeof(CplApplets) / sizeof(CplApplets[0]) )

/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance  - Program instance of the caller.

    EXIT:       If this is the first initialization request for this
                process, then all necessary BLT initializers have
                been invoked.

    RETURNS:    BOOL       - TRUE  = Initialization OK.
                             FALSE = Initialization failed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
BOOL InitializeDll( HINSTANCE hInstance )
{
    //
    //  Save the instance handle.
    //

    _hCplInstance = hInstance;

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hCplInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       IsFtpServerInstalled

    SYNOPSIS:   Determines if the FTP Server service is installed.
                This doesn't necessarily mean the service is actually
                running, just that it is installed on the system.

    RETURNS:    BOOL   - TRUE  = FTP Server service is installed.
                         FALSE = FTP Server service isn't installed.

    NOTES:      We could perform this check by trying to open the
                service via the Service Controller, but this would
                cause a lot of extraneous code to get paged in.
                Instead, we'll check for the presence of the registry
                key that controls the service.

    HISTORY:
        KeithMo         09-Apr-1993      Created.

********************************************************************/
BOOL IsFtpServerInstalled( VOID )
{
    BOOL fInstalled = FALSE;    // until proven otherwise...

    //
    //  Open the registry root.
    //

    REG_KEY RootKey( HKEY_LOCAL_MACHINE );

    APIERR err = RootKey.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Open the FTPSVC registry key.
        //

        ALIAS_STR nlsKeyName( (TCHAR *)FTPD_PARAMETERS_KEY );
        UIASSERT( !!nlsKeyName );

        REG_KEY RegKey( RootKey, nlsKeyName );
        err = RegKey.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Since we successfully opened the FTP Server's
            //  parameters key, we'll assume that the service
            //  is indeed installed.
            //

            fInstalled = TRUE;
        }
    }

    return fInstalled;

}   // IsFtpServerInstalled


/*******************************************************************

    NAME:       InitializeAllApplets

    SYNOPSIS:   Called before applet proper is run.

    ENTRY:      hWnd   - Window handle of parent window.

    RETURNS:    BOOL   - TRUE  = Applet should be installed.
                         FALSE = Applet cannot be installed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        KeithMo         09-Apr-1993      Don't init if service not installed.
        JonN            05-Oct-1994      Added lParam parameters to CPL_INIT, CPL_TERM
        JonN            22-Sep-1995      Only called when applet is run

********************************************************************/
BOOL InitializeAllApplets( HWND hWnd, LPARAM lParam1, LPARAM lParam2 )
{
    TRACEEOL( "FTPMGR.CPL: InitializeAllApplets enter" );
    //
    //  Before we do anything, check to see if the FTP Server service
    //  is installed.  If it isn't there's not much point in running
    //  this applet.
    //

    if( !IsFtpServerInstalled() )
    {
        return FALSE;
    }

    //
    //  Initialize all of the NetUI goodies.
    //

    APIERR err = BLT::Init( _hCplInstance,
                            IDRSRC_FTPMGR_BASE, IDRSRC_FTPMGR_LAST,
                            IDS_UI_FTPMGR_BASE, IDS_UI_FTPMGR_LAST );

    TRACEEOL( "FTPMGR.CPL: InitializeAllApplets BLT::Init returns " << err );

    if( err == NERR_Success )
    {
        TRACEEOL( "FTPMGR.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init next" );

        err = BLT_MASTER_TIMER::Init();

        TRACEEOL( "FTPMGR.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init returns " << err );

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( _hCplInstance );
        }
    }

    if( err == NERR_Success )
    {
        err = BLT::RegisterHelpFile( _hCplInstance,
                                     IDS_CPL_HELPFILENAME,
                                     HC_UI_FTPMGR_BASE,
                                     HC_UI_FTPMGR_LAST );

        if( err != NERR_Success )
        {
            //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //
            ::MsgPopup( hWnd, err );

            BLT::Term( _hCplInstance );
        }
    }

    TRACEEOL( "FTPMGR.CPL: InitializeAllApplets exit" );

    return err == NERR_Success;

}   // InitializeAllApplets


/*******************************************************************

    NAME:       TerminateAllApplets

    SYNOPSIS:   Called after applet is run.

    ENTRY:      hWnd - Window handle of parent window.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            04-Oct-1994      Added lParam parameters to CPL_INIT, CPL_TERM
        JonN            22-Sep-1995      Only called when applet is run

********************************************************************/
VOID TerminateAllApplets( HWND hWnd, LPARAM lParam1, LPARAM lParam2 )
{
    UNREFERENCED( hWnd );

    TRACEEOL( "FTPMGR.CPL: TerminateAllApplets enter" );
    //
    //  Kill the NetUI goodies.
    //

    BLT::DeregisterHelpFile( _hCplInstance, 0 );
    TRACEEOL( "FTPMGR.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term next" );
    BLT_MASTER_TIMER::Term();
    TRACEEOL( "FTPMGR.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term complete" );
    BLT::Term( _hCplInstance );

    TRACEEOL( "FTPMGR.CPL: TerminateAllApplets exit" );

}   // TerminateAllApplets

/*******************************************************************

    NAME:       AutoStartFtpServer

    SYNOPSIS:   Check the state of the FTP Server service.  If it
                isn't started, ask the user if it should be started.
                If the user wants us to start the service, start it.

    ENTRY:      hWnd    - Window handle of parent window.

    RETURNS:    BOOL - TRUE  == FTP Server service is running.
                       FALSE == FTP Server service isn't running.
                                This may indicate either an error
                                or the user didn't want the service
                                started.  If an error occurs, this
                                routine is responsible for displaying
                                it to the user.

    HISTORY:
        KeithMo         09-Apr-1993     Created.

********************************************************************/
BOOL AutoStartFtpServer( HWND hWnd )
{
    BOOL fStarted = FALSE;      // until proven otherwise...

    //
    //  Get the "display name" for the local machine.
    //

    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();
    err = err ? err : nlsDisplayName.QueryError();
    err = err ? err : loc.QueryDisplayName( &nlsDisplayName );

    if( err == NERR_Success )
    {
        //
        //  Determine the state of the service.
        //

        GENERIC_SERVICE * psvc = new GENERIC_SERVICE( hWnd,
                                                      NULL,
                                                      nlsDisplayName,
                                                      (TCHAR *)FTPD_SERVICE_NAME );

        err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : psvc->QueryError();

        if( err == NERR_Success )
        {
            fStarted = psvc->IsInstalled( &err );

            if( !fStarted && ( err == NERR_Success ) )
            {
                //
                //  Service isn't started.  See if the user wants us
                //  to start it.
                //

                if( ::MsgPopup( hWnd,
                                IDS_START_FTPSVC_NOW,
                                MPSEV_WARNING,
                                MP_YESNO,
                                MP_YES ) == IDYES )
                {
                    err = psvc->Start();

                    if( err == NERR_ServiceInstalled )
                    {
                        //
                        //  Somebody must have started the service
                        //  behind our backs...
                        //

                        err = NERR_Success;
                    }

                    if( err == NERR_Success )
                    {
                        //
                        //  Whew!
                        //

                        fStarted = TRUE;
                    }
                }
            }
        }

        delete psvc;
    }

    //
    //  If anything tragic occurred, tell the user.
    //

    if( err != NERR_Success )
    {
        ::MsgPopup( hWnd, err );
    }

    return fStarted;

}   // AutoStartFtpServer


/*******************************************************************

    NAME:       RunFtpSvcMgr

    SYNOPSIS:   Invoke the main dialog of the FTP Server Control
                Panel Applet.

    ENTRY:      hWnd    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        YiHsinS         18-Mar-1993     Created
        KeithMo         09-Apr-1993     Autostart FTP service.

********************************************************************/
APIERR RunFtpSvcMgr( HWND hWnd )
{
    //
    //  If the service isn't started, ask the user if
    //  it should be started.
    //

    if( !AutoStartFtpServer( hWnd ) )
    {
        //
        //  The user doesn't want to play right now.
        //

        return NERR_Success;
    }

    AUTO_CURSOR autocur;

    // In the control panel applet, we will only be focusing on
    // the local machine.

    POPUP::SetCaption( IDS_FTPCPA_CAPTION );

    FTP_SVCMGR_DIALOG * pDlg = new FTP_SVCMGR_DIALOG( hWnd,
                                                      NULL ); // local computer

    APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pDlg->QueryError();

    if ( err == NERR_Success )
        err = pDlg->Process();

    delete pDlg;
    pDlg = NULL;

    if( err != NERR_Success )
    {
        if ( err == RPC_S_SERVER_UNAVAILABLE )
            err = IERR_FTP_SERVICE_UNAVAILABLE;
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();
    return err;

}   // RunFtpSvcMgr


BOOL strLoad( INT idString, WCHAR * pszBuffer, INT cchBuffer )
{
    int result = ::LoadString( ::_hCplInstance,
                                idString,
                                pszBuffer,
                                cchBuffer );

    return ( result > 0 ) && ( result < cchBuffer );

}   // strLoad


/*******************************************************************

    NAME:       CPlApplet

    SYNOPSIS:   Exported function to start the FTP Server Control
                Panel Applet.

    ENTRY:      hwndCPl   - Window handle of parent.

                nMsg      - CPL user message (see CPL.H
                            in WINDOWS\SHELL\CONTROL\H).

                lParam1   - Message-specific pointer.

                lParam2   - Message-specific pointer.

    RETURNS:    LONG

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            04-Oct-1994      Added lParam parameters to CPL_INIT, CPL_TERM
        JonN            22-Sep-1995      BLT::Init only called when applet is run
        JonN            26-Jun-2000      CPlApplet takes HWND, UINT, LPARAM, LPARAM

********************************************************************/
LONG FAR PASCAL CPlApplet( HWND hwndCPl,
                           UINT nMsg,
                           LPARAM lParam1,
                           LPARAM lParam2 )
{
    LPCPLINFO    pCplInfo;
    LPNEWCPLINFO pNewInfo;
    LONG         nResult = 0;

    switch( nMsg )
    {
    case CPL_INIT:
        //
        //  This message is sent to indicate that CPlApplet() was found.
        //
        //  lParam1 is not used, but we pass it anyway.
        //
        //  lParam2 is -1 iff the DLL will be used only to confirm the
        //  number of applets.
        //
        //  Return TRUE if applet should be installed, FALSE otherwise.
        //
        //  Before we do anything, check to see if the FTP Server service
        //  is installed.  If it isn't there's not much point in running
        //  this applet.
        //

        return IsFtpServerInstalled();

    case CPL_GETCOUNT:
        //
        //  This message is set to determine the number of applets contained
        //  in this DLL.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return the number of applets contained in this DLL.
        //

        return NUM_APPLETS;

    case CPL_INQUIRE:
        //
        //  This message is sent once per applet to retrieve information
        //  about each applet.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a CPLINFO structure.  The CPLINFO
        //  structure's idIcon, idName, idInfo, and lData fields should
        //  be initialized as appropriate for the applet.
        //
        //  There is no return value.
        //

        pCplInfo = (LPCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pCplInfo->idIcon = pApplet->idIcon;
            pCplInfo->idName = pApplet->idName;
            pCplInfo->idInfo = pApplet->idInfo;
            pCplInfo->lData  = pApplet->lData;
        }
        break;

    case CPL_SELECT:
        //
        //  This message is sent when the applet's icon has been
        //  selected.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_DBLCLK:
        //
        //  This message is sent when the applet's icon has been
        //  double-clicked.  This message should initiate the
        //  applet's dialog box.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        if( lParam1 < NUM_APPLETS )
        {
            if ((LONG)InitializeAllApplets( hwndCPl, lParam1, lParam2 ))
            {
                (CplApplets[lParam1].pfnApplet)( hwndCPl );
                TerminateAllApplets( hwndCPl, lParam1, lParam2 );
            }
            else
            {
                ASSERT( FALSE );
            }
        }
        break;

    case CPL_STOP:
        //
        //  This message is sent once for each applet when the
        //  control panel is shutting down.  This message should
        //  initiate applet specific cleanup.
        //
        //  lParam1 is the applet number being stopped.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_EXIT:
        //
        //  This message is sent just before the control panel calls
        //  FreeLibrary.  This message should initiate non applet
        //  specific cleanup.
        //
        //  lParam1 is not used, but we pass it anyway.
        //
        //  lParam2 is -1 iff the DLL was used only to confirm the
        //  number of applets.
        //
        //  There is no return value.
        //

        break;

    case CPL_NEWINQUIRE:
        //
        //  This message is basically the same as CPL_INQUIRE, except
        //  lParam2 points to a NEWCPLINFO structure.  This message will
        //  be sent *before* CPL_INQUIRE.  If the applet returns a non
        //  zero value, then CPL_INQUIRE will not be sent.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a NEWCPLINFO structure.
        //
        //  Return TRUE this message was handled, otherwise return FALSE.
        //

        pNewInfo = (LPNEWCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pNewInfo->dwSize        = sizeof(*pNewInfo);
            pNewInfo->dwFlags       = 0;
            pNewInfo->dwHelpContext = pApplet->dwHelpContext;
            pNewInfo->lData         = pApplet->lData;

            pNewInfo->hIcon = ::LoadIcon( ::_hCplInstance,
                                          MAKEINTRESOURCE( pApplet->idIcon ) );

            if( ( pNewInfo->hIcon != NULL ) &&
                strLoad( pApplet->idName,
                         pNewInfo->szName,
                         sizeof(pNewInfo->szName) ) &&
                strLoad( pApplet->idInfo,
                         pNewInfo->szInfo,
                         sizeof(pNewInfo->szInfo) ) &&
                strLoad( pApplet->idHelpFile,
                         pNewInfo->szHelpFile,
                         sizeof(pNewInfo->szHelpFile) ) )
            {
                nResult = TRUE;
            }
        }
        break;

    default:
        //
        //  Who knows.  Ignore it.
        //

        break;
    }

    return nResult;

}   // CPlApplet


/*******************************************************************

    NAME:       FtpMgrDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance    - A handle to the DLL.

                nReason      - Indicates why the DLL entry
                               point is being called.

                pReserved    - Reserved.

    RETURNS:    BOOL         - TRUE  = DLL init was successful.
                               FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/

BOOL FAR PASCAL FtpMgrDllInitialize( HINSTANCE hInstance,
                                     DWORD  nReason,
                                     LPVOID pReserved )
{
    UNREFERENCED( pReserved );

    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;


}   // FtpMgrDllInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\clicreg.hpp ===
//-------------------------------------------------------------------
//
//  FILE: CLicReg.Hpp
//
//  Summary;
//      Class definition for handling the licensing api registration
//
// Notes;
//
// History
//      11/15/94    MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

#ifndef __CLicReg_HPP__
#define __CLicReg_HPP__

const WCHAR FILEPRINT_SERVICE_REG_KEY[]             = L"FilePrint";
const WCHAR FILEPRINT_SERVICE_DISPLAY_NAME[]        = L"Windows Server";
const WCHAR FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME[] = L"Windows Server";

// license modes to pass to SetMode 
//
enum LICENSE_MODE
{
   LICMODE_PERSEAT,
   LICMODE_PERSERVER,
   LICMODE_UNDEFINED
};

//-------------------------------------------------------------------
//  Root class of all registry classes
//

class CLicReg
{
public:
   CLicReg();
   ~CLicReg();

   LONG CommitNow();
   LONG Close();

protected:
   HKEY  _hkey;
};

//-------------------------------------------------------------------
// License Registry Key, for initialization and enumeration
//

class CLicRegLicense : public CLicReg
{
public:
   LONG Open( BOOL& fNew,  LPCWSTR pszComputer = NULL );
   LONG EnumService( DWORD iService, LPWSTR pszBuffer, DWORD& cBuffer );
};

//-------------------------------------------------------------------
// Services under the License Registry Key
//

class CLicRegLicenseService : public CLicReg
{
public:
   CLicRegLicenseService( LPCWSTR pszService = NULL );

   LONG Open( LPCWSTR pszComputer = NULL, BOOL fCreate = TRUE );
   
   void SetService( LPCWSTR pszService );
   BOOL CanChangeMode();
   LONG SetChangeFlag( BOOL fHasChanged );
   LONG SetMode( LICENSE_MODE lm );
   LONG SetUserLimit( DWORD dwLimit );             
   LONG GetMode( LICENSE_MODE& lm );
   LONG GetUserLimit( DWORD& dwLimit );               
   LONG GetDisplayName( LPWSTR pszName, DWORD& cchName );
   LONG SetDisplayName( LPCWSTR pszName );
   LONG GetFamilyDisplayName( LPWSTR pszName, DWORD& cchName );
   LONG SetFamilyDisplayName( LPCWSTR pszName );

private:
   PWCHAR _pszService;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\dialogs.h ===
#define IDC_BUTTONHELP              104
#define IDC_SERVICES                106
#define IDC_PERSEAT                 108
#define IDC_PERSERVER               110
#define IDC_USERCOUNT               112
#define IDC_USERCOUNTARROW          114
#define IDC_ADD_LICENSES            115
#define IDC_REMOVE_LICENSES         116

#define IDC_STATICTITLE             118
#define IDC_STATICPERSEAT           120
#define IDC_AGREE                   122
#define IDC_STATICINFO              124

#define IDD_CPADLG                  100
#define IDD_SETUPDLG                200
#define IDD_SETUP2DLG               300
#define IDD_LICVIOLATIONDLG         400
#define IDD_PERSEATDLG              500
#define IDD_PERSERVERDLG            600
#define IDD_SERVERAPPDLG            700
#define IDC_STATICAGREE             121
#define IDD_CPADLG_CONFIGURE        800
#define IDC_CONFIGURE               801
#define IDD_CPADLG_LCACONF          900
#define IDC_PDC                     901
#define IDC_ES                      902
#define IDC_ENT_SERVER              903
#define IDC_REPL_TIME               905
#define IDC_REPL_INT                906
#define IDC_HOURS                   907
#define IDC_HOURARROW               908
#define IDC_HOUR                    910
#define IDC_TIMESEP1                911
#define IDC_MINUTE                  912
#define IDC_TIMESEP2                913
#define IDC_SECOND                  914
#define IDC_TIMEARROW               915
#define IDC_AMPM                    917
#define IDC_TIMEEDIT_BORDER         918
#define IDC_SYSTEM_ACCOUNT          919
#define IDC_THIS_ACCOUNT            920
#define IDC_ACCOUNT_NAME            921
#define IDC_PASSWORD                922
#define IDC_CONFIRM_PASSWORD        923

#define IDI_LICCPA                  1000
#define IDI_LICSETUPICON            1001


#define IDD_SPECIALSETUP            1100
#define IDD_SETUP_LICENSE_MODE_PAGE 1101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\config.cpp ===
//-------------------------------------------------------------------
//
// FILE: Config.cpp
//
// Summary;
//         This file contains the dialog proc for IDD_CPADLG_LCACONF
//
// History;
//      Feb-06-95    ChandanS Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Mar-30-95   MikeMi  Added Replication Help Context
//      Dec-15-95  JeffParh Disallowed local server as own enterprise server.
//      Feb-28-96  JeffParh Moved from private cpArrow window class to
//                          Up-Down common ctrl, in the process fixing the
//                          multi-colored background problems
//      Apr-17-96  JeffParh Imported variable definitions that were in the
//                          config.hpp header file.
//
//-------------------------------------------------------------------

#include <windows.h>
#include <commctrl.h>
#include "resource.h"
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "config.hpp"

extern "C"
{
#include <lmcons.h>
#include <icanon.h>
    INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

static BOOL OnEnSetFocus( HWND hwndDlg, short nID );
static BOOL OnDeltaPosSpinTime( HWND hwndDlg, NM_UPDOWN * pnmud );
static HBRUSH OnCtlColorStatic( HWND hwndDlg, HDC hDC, HWND hwndStatic );

DWORD HOUR_MIN = HOUR_MIN_24;
DWORD HOUR_MAX = HOUR_MAX_24;
DWORD HOUR_PAGE = HOUR_PAGE_24;

SERVICEPARAMS ServParams;
static PSERVICEPARAMS pServParams = &ServParams;

// JBP 96/04/17 : This #ifdef should not be necessary; the default is only used
// in the event that GetLocalInfo() fails.
//
// #ifdef JAPAN
// INTLSTRUCT IntlDefault = {    1,
//                               0,
//                               TEXT(""),
//                               TEXT(""),
//                               TEXT(":")
//                          };
// #else
INTLSTRUCT IntlDefault = {    0,
                              0,
                              TEXT("AM"),
                              TEXT("PM"),
                              TEXT(":")
                         };
// #endif

INTLSTRUCT IntlCurrent;


//-------------------------------------------------------------------
//  Function:  GetLocaleValue
//
//  Summary:
//
//  In:
//        lcid       :
//        lcType     :
//        pszStr     :
//        size       :
//        pszDefault :
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
int GetLocaleValue(
    LCID lcid,
    LCTYPE lcType,
    WCHAR *pszStr,
    int size,
    LPWSTR pszDefault )
{
    /*
     *  Initialize the output buffer.
     */
    *pszStr = (WCHAR) 0;

    /*
     *  Get the locale information.
     */
    if (!GetLocaleInfo ( lcid,
                         lcType,
                         pszStr,
                         size ))
    {
        /*
         *  Couldn't get info from GetLocaleInfo.
         */
        if (pszDefault)
        {
            /*
             *  Return the default info.
             */
            lstrcpy (pszStr, pszDefault);
        }
        else
        {
            /*
             *  Return error.
             */
            return (-1);
        }
    }

    /*
     *  Convert the string to an integer and return the result.
     *  This will only be used by the caller of this routine when
     *  appropriate.
     */
    return ( _wtoi(pszStr) );
}


//-------------------------------------------------------------------
//  Function:  TimeInit
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
VOID TimeInit()
{
    WCHAR szTemp[128];

    GetLocaleValue (0,
                    LOCALE_STIME,
                    IntlCurrent.szTime,
                    sizeof(IntlCurrent.szTime),
                    IntlDefault.szTime);

    GetLocaleValue (0,
                    LOCALE_ITLZERO,
                    szTemp,
                    sizeof(szTemp)/sizeof(TCHAR),
                    TEXT("0"));
    IntlCurrent.iTLZero = _wtoi(szTemp);

    GetLocaleValue (0,
                    LOCALE_ITIME,
                    szTemp,
                    sizeof(szTemp)/sizeof(TCHAR),
                    TEXT("0"));
    IntlCurrent.iTime = _wtoi(szTemp);
    if (!IntlCurrent.iTime)
    {
        GetLocaleValue (0,
                        LOCALE_S1159,
                        IntlCurrent.sz1159,
                        sizeof(IntlCurrent.sz1159),
                        IntlDefault.sz1159);
        GetLocaleValue (0,
                        LOCALE_S2359,
                        IntlCurrent.sz2359,
                        sizeof(IntlCurrent.sz2359),
                        IntlDefault.sz2359);
        HOUR_MIN = HOUR_MIN_12;
        HOUR_MAX = HOUR_MAX_12;
        HOUR_PAGE = HOUR_PAGE_12;
    }
}

//-------------------------------------------------------------------
//  Function:  ReadRegistry
//
//  Summary:
//        Opens the registry & reads in the key values
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
LONG ReadRegistry()
{
    DWORD dwDisposition;
    LONG  lrt;
    BOOL fNew;
    HKEY hKey;

    fNew = FALSE;
    lrt = ::RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
            szLicenseKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition );

    if ((ERROR_SUCCESS == lrt) &&
            (REG_CREATED_NEW_KEY == dwDisposition) )
    {
        fNew =     TRUE;
        // Set normal values
        //
        lrt = ::RegSetValueEx( hKey,
                szUseEnterprise,
                0,
                REG_DWORD,
                (PBYTE)&dwUseEnterprise,
                sizeof( DWORD ) );
        if (ERROR_SUCCESS == lrt)
        {

            lrt = ::RegSetValueEx( hKey,
                    szReplicationType,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwReplicationType,
                    sizeof( DWORD ) );
            if (ERROR_SUCCESS == lrt)
            {

                lrt = ::RegSetValueEx( hKey,
                        szReplicationTime,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwReplicationTimeInSec, // In seconds
                        sizeof( DWORD ) );

                if (ERROR_SUCCESS == lrt)
                {
                    WCHAR szNull[] = L"";
                    lrt = ::RegSetValueEx( hKey,
                            szEnterpriseServer,
                            0,
                            REG_SZ,
                            (PBYTE)szNull,
                            sizeof(WCHAR));
                }
            }
        }
    }

    if (ERROR_SUCCESS == lrt)
    {  //  read values into pServParams

        DWORD dwSize = sizeof( DWORD );
        DWORD dwRegType = REG_DWORD;

        lrt = ::RegQueryValueEx( hKey,
                (LPWSTR)szUseEnterprise,
                0,
                &dwRegType,
                (PBYTE)&(pServParams->dwUseEnterprise),
                &dwSize );
        if (lrt == REG_OPENED_EXISTING_KEY)
        {
            lrt = ::RegSetValueEx( hKey,
                    szUseEnterprise,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwUseEnterprise,
                    sizeof( DWORD ) );
            pServParams->dwUseEnterprise = dwUseEnterprise;
        }
        else if ((dwRegType != REG_DWORD) || 
                (dwSize != sizeof( DWORD )) )
        {
            lrt = ERROR_BADDB;
        }
        if (!lrt )
        {
            dwSize = sizeof( DWORD );
            dwRegType = REG_DWORD;

            lrt = ::RegQueryValueEx( hKey,
                    (LPWSTR)szReplicationType,
                    0,
                    &dwRegType,
                    (PBYTE)&(pServParams->dwReplicationType),
                    &dwSize );
            if (lrt == REG_OPENED_EXISTING_KEY)
            {
                lrt = ::RegSetValueEx( hKey,
                        szReplicationType,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwReplicationType,
                        sizeof(DWORD));
                pServParams->dwReplicationType = dwReplicationType;
            }
            else if ( lrt || (dwRegType != REG_DWORD) ||
                    (dwSize != sizeof( DWORD )) )
            {
                lrt = ERROR_BADDB;
            }
            if (!lrt)
            {
                dwSize = sizeof( DWORD );
                dwRegType = REG_DWORD;

                lrt = ::RegQueryValueEx( hKey,
                        (LPWSTR)szReplicationTime,
                        0,
                        &dwRegType,
                        (PBYTE)&(pServParams->dwReplicationTime),
                        &dwSize );
                if (lrt == REG_OPENED_EXISTING_KEY)
                {
                    lrt = ::RegSetValueEx( hKey,
                            szReplicationTime,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwReplicationTimeInSec,
                            sizeof(DWORD));
                    pServParams->dwReplicationTime = dwReplicationTimeInSec;
                }
                else if ( (dwRegType != REG_DWORD) ||
                        (dwSize != sizeof( DWORD )) )
                {
                    lrt = ERROR_BADDB;
                }
                if (!lrt)
                {
                    dwRegType = REG_SZ;

                    lrt = RegQueryValueEx( hKey,
                            (LPWSTR)szEnterpriseServer,
                            0,
                            &dwRegType,
                            (PBYTE)NULL, //request for size
                            &dwSize );
                    if (lrt == REG_OPENED_EXISTING_KEY)
                    {
                        WCHAR szNull[] = L"";
                        lrt = ::RegSetValueEx( hKey,
                                szEnterpriseServer,
                                0,
                                REG_SZ,
                                (PBYTE)szNull,
                                sizeof(WCHAR));
                        pServParams->pszEnterpriseServer = (LPWSTR)GlobalAlloc(GPTR, (wcslen(szNull) + 1) * sizeof(WCHAR));
                        wcscpy(pServParams->pszEnterpriseServer, szNull);
                    }
                    else if (dwRegType != REG_SZ)
                    {
                        lrt = ERROR_BADDB;
                    }
                    else
                    {

                        pServParams->pszEnterpriseServer = (LPWSTR) GlobalAlloc(GPTR, dwSize);
                        if (pServParams->pszEnterpriseServer)
                        {
                            lrt = ::RegQueryValueEx( hKey,
                                    (LPWSTR)szEnterpriseServer,
                                    0,
                                    &dwRegType,
                                    (PBYTE)(pServParams->pszEnterpriseServer),
                                    &dwSize );

                            if ( (dwRegType != REG_SZ) ||
                                    (dwSize != (wcslen(pServParams->pszEnterpriseServer ) + 1) * sizeof(WCHAR)))
                            {
                                lrt = ERROR_BADDB;
                            }
                        }
                        else
                        {
                            lrt = ERROR_BADDB;
                        }
                    }
                }
            }
        }
    }

    if (hKey && lrt == ERROR_SUCCESS)
    {
        // Init the globals
        if (pServParams->dwReplicationType)
        {
            DWORD dwTemp = pServParams->dwReplicationTime;
            pServParams->dwHour = dwTemp / (60 * 60);
            pServParams->dwMinute = (dwTemp - (pServParams->dwHour * 60 * 60)) / 60;
                    pServParams->dwSecond = dwTemp - (pServParams->dwHour * 60 * 60) - 
                    (pServParams->dwMinute * 60);
            if (!IntlCurrent.iTime)
            { // it's in 12 hour format
                if (pServParams->dwHour > 12)
                {
                    pServParams->fPM = TRUE;
                    pServParams->dwHour -= 12;
                }
                else if (pServParams->dwHour == 12)
                {
                    pServParams->fPM = TRUE;
                }
                else
                {
                    if (pServParams->dwHour == 0)
                        pServParams->dwHour = HOUR_MAX;
                    pServParams->fPM = FALSE;
                }
            }
        }
        else
        {
            pServParams->dwReplicationTime = pServParams->dwReplicationTime / (60 * 60);
            if (!IntlCurrent.iTime)
            // it's in 12 hour format
                pServParams->dwHour  = HOUR_MAX;
            else
                pServParams->dwHour  = HOUR_MIN;
            pServParams->dwMinute = MINUTE_MIN;
            pServParams->dwSecond = SECOND_MIN;
            pServParams->fPM = FALSE;

        }
        return (RegCloseKey(hKey));
    }
    else if (hKey)
        RegCloseKey(hKey);

    return( lrt );
}


//-------------------------------------------------------------------
//  Function:  ConfigAccessOk
//
//  Summary:
//        Checks access rights form reg call and raise dialog as needed
//
//  In:
//        hDlg     - Handle to working dialog to raise error dlgs with
//        lrc      - the return status from a reg call
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
inline BOOL ConfigAccessOk( HWND hDlg, LONG lrc )
{
    BOOL  frt = TRUE;
    
    if (ERROR_SUCCESS != lrc)
    {
        WCHAR szText[TEMPSTR_SIZE];
        WCHAR szTitle[TEMPSTR_SIZE];
        UINT  wId;
        
        if (ERROR_ACCESS_DENIED == lrc)
        {
            wId = IDS_NOACCESS;            
        }
        else
        {
            wId = IDS_BADREG;
        }        
        LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
        LoadString(g_hinst, wId, szText, TEMPSTR_SIZE);
        MessageBox (hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
        frt = FALSE;
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function: ConfigInitUserEdit
//
//  Summary:
//        Initializes and defines user count edit control behaviour
//
//  In:
//        hwndDlg    - Parent dialog of user count edit dialog
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigInitUserEdit( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_HOURS);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_HOUR);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_MINUTE);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_SECOND);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_AMPM);
    SendMessage( hwndCount, EM_LIMITTEXT, max(wcslen(IntlCurrent.sz1159), 
                                              wcslen(IntlCurrent.sz2359)), 0 );

    SetDlgItemText (hwndDlg, IDC_TIMESEP1, IntlCurrent.szTime);
    SetDlgItemText (hwndDlg, IDC_TIMESEP2, IntlCurrent.szTime);
}


//-------------------------------------------------------------------
//  Function: ConfigInitDialogForService
//
//  Summary:
//        Initialize dialog controls to the service state
//
//  In:
//        hwndDlg - Parent dialog to init controls in
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//        Feb-28-96    JeffParh Added range set for interval spin ctrl
//-------------------------------------------------------------------
void ConfigInitDialogForService( HWND hwndDlg, DWORD dwGroup )
{
    HWND hwndHour           = GetDlgItem( hwndDlg, IDC_HOUR);
    HWND hwndMinute         = GetDlgItem( hwndDlg, IDC_MINUTE);
    HWND hwndSecond         = GetDlgItem( hwndDlg, IDC_SECOND);
    HWND hwndAMPM           = GetDlgItem( hwndDlg, IDC_AMPM);
    HWND hwndInterval       = GetDlgItem( hwndDlg, IDC_HOURS);
    HWND hwndIntervalSpin   = GetDlgItem( hwndDlg, IDC_HOURARROW );
    HWND hwndTimeSpin       = GetDlgItem( hwndDlg, IDC_TIMEARROW );

    BOOL fEnterprise = (pServParams->dwUseEnterprise);
    BOOL fReplAtTime = (pServParams->dwReplicationType);

    if (dwGroup == ATINIT || dwGroup == FORTIME)
    {
        if (fReplAtTime)
        {
            WCHAR szTemp[3];
            CheckDlgButton( hwndDlg, IDC_REPL_TIME, fReplAtTime);
            CheckDlgButton( hwndDlg, IDC_REPL_INT, !fReplAtTime);
            if (IntlCurrent.iTLZero)
            {
                wsprintf(szTemp,TEXT("%02u"), pServParams->dwHour);
                szTemp[2] = UNICODE_NULL;
                SetDlgItemText( hwndDlg, IDC_HOUR, szTemp);
            }
            else
            {
                SetDlgItemInt( hwndDlg, IDC_HOUR, pServParams->dwHour, FALSE );
            }

            wsprintf(szTemp,TEXT("%02u"), pServParams->dwMinute);
            szTemp[2] = UNICODE_NULL;
            SetDlgItemText( hwndDlg, IDC_MINUTE, szTemp);

            wsprintf(szTemp,TEXT("%02u"), pServParams->dwSecond);
            szTemp[2] = UNICODE_NULL;
            SetDlgItemText( hwndDlg, IDC_SECOND, szTemp);

            if (pServParams->fPM)
                SetDlgItemText( hwndDlg, IDC_AMPM, IntlCurrent.sz2359);
            else
                SetDlgItemText( hwndDlg, IDC_AMPM, IntlCurrent.sz1159);

            SetDlgItemText( hwndDlg, IDC_HOURS, L"");
            SetFocus(GetDlgItem(hwndDlg, IDC_REPL_TIME));
        }
        else
        {
            CheckDlgButton( hwndDlg, IDC_REPL_INT, !fReplAtTime);
            CheckDlgButton( hwndDlg, IDC_REPL_TIME, fReplAtTime);
            SetDlgItemInt( hwndDlg, IDC_HOURS, pServParams->dwReplicationTime, FALSE);
            SetDlgItemText( hwndDlg, IDC_HOUR, L"");
            SetDlgItemText( hwndDlg, IDC_MINUTE, L"");
            SetDlgItemText( hwndDlg, IDC_SECOND, L"");
            SetDlgItemText( hwndDlg, IDC_AMPM, L"");
            SetFocus(GetDlgItem(hwndDlg, IDC_REPL_INT));
        }

        EnableWindow( hwndTimeSpin, fReplAtTime);
        EnableWindow( hwndHour, fReplAtTime);
        EnableWindow( hwndMinute, fReplAtTime);
        EnableWindow( hwndSecond, fReplAtTime);

        if ( IntlCurrent.iTime )
        {
           ShowWindow( hwndAMPM, SW_HIDE );
        }
        else
        {
           EnableWindow( hwndAMPM, fReplAtTime );
        }

        EnableWindow( hwndInterval, !fReplAtTime);
        EnableWindow( hwndIntervalSpin, !fReplAtTime);
        SendMessage( hwndIntervalSpin, UDM_SETRANGE, 0, (LPARAM) MAKELONG( (short) INTERVAL_MAX, (short) INTERVAL_MIN ) );
    }


}


//-------------------------------------------------------------------
//  Function: ConfigFreeServiceEntry
//
//  Summary:
//        Free all allocated memory when a service structure is created
//
//  In:
//        pServParams - The Service structure to free
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigFreeServiceEntry( )
{
    if (pServParams->pszEnterpriseServer)
        GlobalFree( pServParams->pszEnterpriseServer );
}

//-------------------------------------------------------------------
//  Function: ConfigSaveServiceToReg
//
//  Summary:
//        Save the given Service structure to the registry
//
//  In:
//        pServParams - Service structure to save
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigSaveServiceToReg( )
{
    DWORD dwDisposition;
    LONG  lrt;
    HKEY hKey;

    if (!pServParams->dwReplicationType)
        pServParams->dwReplicationTime = pServParams->dwReplicationTime * 60 *60;
    lrt = RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
                szLicenseKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dwDisposition );

    if (ERROR_SUCCESS == lrt)
    {
        lrt = RegSetValueEx( hKey,
                szUseEnterprise,
                0,
                REG_DWORD,
                (PBYTE)&(pServParams->dwUseEnterprise),
                sizeof( DWORD ) );
        if (ERROR_SUCCESS == lrt)
        {
            lrt = RegSetValueEx( hKey,
                    szEnterpriseServer,
                    0,
                    REG_SZ,
                    (PBYTE)pServParams->pszEnterpriseServer,
                    (wcslen (pServParams->pszEnterpriseServer) + 1) * sizeof(WCHAR));
            if (ERROR_SUCCESS == lrt)
            {
                lrt = RegSetValueEx( hKey,
                    szReplicationTime,
                    0,
                    REG_DWORD,
                    (PBYTE)&(pServParams->dwReplicationTime),
                    sizeof( DWORD ) );
                if (ERROR_SUCCESS == lrt)
                {
                    lrt = ::RegSetValueEx( hKey,
                        szReplicationType,
                        0,
                        REG_DWORD,
                        (PBYTE)&(pServParams->dwReplicationType),
                        sizeof( DWORD ) );
                }
            }
        }
    }
    if (hKey && lrt == ERROR_SUCCESS)
        lrt = RegCloseKey(hKey);
    else if (hKey)
        lrt = RegCloseKey(hKey);
}


//-------------------------------------------------------------------
//  Function: ConfigEditInvalidDlg
//
//  Summary:
//        Display Dialog when user count edit control value is invalid
//
//  In:
//        hwndDlg - hwnd of dialog
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigEditInvalidDlg( HWND hwndDlg, short nID, BOOL fBeep)
{
    HWND hwnd = GetDlgItem( hwndDlg, nID);

    if (fBeep) //If we've already put up a MessageBox, we shouldn't beep
        MessageBeep( MB_VALUELIMIT );

    SetFocus(hwnd);
    SendMessage(hwnd, EM_SETSEL, 0, -1 );
}


//-------------------------------------------------------------------
//  Function: ConfigEditValidate
//
//  Summary:
//        Handle when the value within the user count edit control changes
//
//  In:
//        hwndDlg - hwnd of dialog
//        pserv   - currently selected service
//  Out: 
//  Returns: FALSE if Edit Value is not valid, TRUE if it is
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL ConfigEditValidate( HWND hwndDlg, short *pnID, BOOL *pfBeep)
{
    UINT nValue;
    BOOL fValid = FALSE;
    WCHAR szTemp[MAX_PATH + 1];
    DWORD NumberOfHours, SecondsinHours;
    WCHAR szText[TEMPSTR_SIZE];
    WCHAR szTitle[TEMPSTR_SIZE];

    *pfBeep = TRUE;

    // only do this if license info is replicated to an ES

    do {

        if (IsDlgButtonChecked(hwndDlg, IDC_REPL_INT))
        {
            nValue = GetDlgItemInt( hwndDlg, IDC_HOURS, &fValid, FALSE);
            *pnID = IDC_HOURS;
            if (fValid)
            {
                if (nValue < INTERVAL_MIN)
                {
                    fValid = FALSE;
                    pServParams->dwReplicationTime = INTERVAL_MIN;
                    SetDlgItemInt(hwndDlg, IDC_HOURS, INTERVAL_MIN, FALSE);
                    break;
                }
                else if (nValue > INTERVAL_MAX)
                {
                    fValid = FALSE;
                    pServParams->dwReplicationTime = INTERVAL_MAX;
                    SetDlgItemInt(hwndDlg, IDC_HOURS, INTERVAL_MAX, FALSE);
                    break;
                }
                else
                    pServParams->dwReplicationTime = nValue;
            }
            else
            {
                fValid = FALSE;
                break;
            }
            pServParams->dwReplicationType = FALSE;
        }
        else
        {
            nValue = GetDlgItemInt( hwndDlg, IDC_HOUR, &fValid, FALSE);
            if (fValid)
                 pServParams->dwHour = nValue;
            else
            {
                *pnID = IDC_HOUR;
                break;
            }

            nValue = GetDlgItemInt( hwndDlg, IDC_MINUTE, &fValid, FALSE);
            if (fValid)
                 pServParams->dwMinute = nValue;
            else
            {
                *pnID = IDC_MINUTE;
                break;
            }

            nValue = GetDlgItemInt( hwndDlg, IDC_SECOND, &fValid, FALSE);
            if (fValid)
                 pServParams->dwSecond = nValue;
            else
            {
                *pnID = IDC_SECOND;
                break;
            }

            if (!IntlCurrent.iTime)
            {
                *pnID = IDC_AMPM;
                nValue = GetDlgItemText( hwndDlg, IDC_AMPM, szTemp, MAX_PATH);
                if (nValue == 0) 
                {
                    fValid = FALSE;
                    break;
                }
                szTemp[nValue] = UNICODE_NULL;

                if (!_wcsicmp(szTemp, IntlCurrent.sz1159))
                {
                    pServParams->fPM = FALSE;
                }
                else if (!_wcsicmp(szTemp, IntlCurrent.sz2359))
                {
                    pServParams->fPM = TRUE;
                }
                else
                {
                    fValid = FALSE;
                    break;
                }
            }
            if (!IntlCurrent.iTime)
            { // It's in 12 hour format
                if (pServParams->fPM)
                {
                    NumberOfHours = 12 + pServParams->dwHour - 
                                    ((pServParams->dwHour / 12) * 12);
                }
                else
                {
                    NumberOfHours = pServParams->dwHour - 
                                    ((pServParams->dwHour / 12) * 12);
                }
            }
            else
            { // It's in 24 hour format
                NumberOfHours = pServParams->dwHour;
            }
            SecondsinHours = NumberOfHours * 60 * 60;
            pServParams->dwReplicationTime = SecondsinHours + 
                           (pServParams->dwMinute * 60) + pServParams->dwSecond;
            pServParams->dwReplicationType = TRUE;
        }

    } while(FALSE);

    return( fValid );
}


//-------------------------------------------------------------------
//  Function: OnCpaConfigClose
//
//  Summary:
//        Do work needed when the Control Panel applet is closed.
//        Free all Service structures alloced and possible save.
//
//  In:
//        hwndDlg - Dialog close was requested on
//        fSave   - Save Services to Registry
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void OnCpaConfigClose( HWND hwndDlg, BOOL fSave , WPARAM wParam)
{
    short nID;
    BOOL fBeep = TRUE;

    if (fSave)
    {
        if ( ConfigEditValidate(hwndDlg, &nID, &fBeep))
        {
            ConfigSaveServiceToReg( );
            ConfigFreeServiceEntry( );
            EndDialog( hwndDlg, fSave );
        }
        else
        {
            ConfigEditInvalidDlg(hwndDlg, nID, fBeep);
        }
    }
    else
    {
        ConfigFreeServiceEntry( );
        EndDialog( hwndDlg, fSave );
    }
}


//-------------------------------------------------------------------
//  Function: OnSetReplicationTime
//
//  Summary:
//        Handle the users request to change replication time
//
//  In:
//        hwndDlg - hwnd of dialog
//        idCtrl  - the control id that was pressed to make this request
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//        Feb-28-96    JeffParh Added code to modify time bg color
//-------------------------------------------------------------------
void OnSetReplicationTime( HWND hwndDlg, WORD idCtrl )
{
    if (idCtrl == IDC_REPL_INT)
    {
        pServParams->dwReplicationType = dwReplicationType;
    }
    else
    {
        pServParams->dwReplicationType = !dwReplicationType;
    }

    // Edit control within this IDC_TIMEEDIT_BORDER should be subclassed and
    // use some other backgroup brush to repaint the background.
    // following code works but...

    // change the background color of the time edit control

    HWND hwndTimeEdit = GetDlgItem( hwndDlg, IDC_TIMEEDIT_BORDER );
    InvalidateRect( hwndTimeEdit, NULL, TRUE );
    UpdateWindow( hwndTimeEdit );

    HWND hwndTimeSep1 = GetDlgItem( hwndDlg, IDC_TIMESEP1 );
    InvalidateRect( hwndTimeSep1, NULL, TRUE );
    UpdateWindow( hwndTimeSep1 );

    HWND hwndTimeSep2 = GetDlgItem( hwndDlg, IDC_TIMESEP2 );
    InvalidateRect( hwndTimeSep2, NULL, TRUE );
    UpdateWindow( hwndTimeSep2 );

    InvalidateRect( 
                GetDlgItem(hwndDlg, IDC_TIMEARROW), 
                NULL, 
                FALSE 
            );

    UpdateWindow( GetDlgItem(hwndDlg, IDC_TIMEARROW) );

    ConfigInitDialogForService( hwndDlg, FORTIME);
}

//-------------------------------------------------------------------
//  Function: OnCpaConfigInitDialog
//
//  Summary:
//        Handle the initialization of the Control Panel Applet Dialog
//
//  In:
//        hwndDlg - the dialog to initialize
//  Out: 
//        iSel  - the current service selected
//        pServParams  - the current service 
//  Returns: 
//        TRUE if succesful, otherwise false
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL OnCpaConfigInitDialog( HWND hwndDlg)
{
    BOOL frt;
    LONG lrt;

    TimeInit();
    // Do Registry stuff
    lrt = ReadRegistry();
    
    frt = ConfigAccessOk( hwndDlg, lrt );
    if (frt)
    {
        CenterDialogToScreen( hwndDlg );

        // Set edit text chars limit
        ConfigInitUserEdit( hwndDlg );

        ConfigInitDialogForService( hwndDlg, ATINIT);

        if (pServParams->dwReplicationType)
            SetFocus(GetDlgItem(hwndDlg, IDC_HOUR));
        else
            SetFocus(GetDlgItem(hwndDlg, IDC_HOURS));
    }
    else
    {
        EndDialog( hwndDlg, -1 );
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function:  CheckNum
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL CheckNum (HWND hDlg, WORD nID)
{
    short    i;
    WCHAR    szNum[4];
    BOOL    bReturn;
    INT     iVal;
    UINT    nValue;

    bReturn = TRUE;

    // JonN 5/15/00: PREFIX 112120
    ::ZeroMemory( szNum, sizeof(szNum) );
    nValue = GetDlgItemText (hDlg, nID, szNum, 3);

    for (i = 0; szNum[i]; i++)
        if (!_istdigit (szNum[i]))
            return (FALSE);

    iVal = _wtoi(szNum);

    switch (nID)
    {
       case IDC_HOURS:
          if (!nValue)
          {
              pServParams->dwReplicationTime = dwReplicationTime;
              break;
          }
          if (iVal < 9)
          {
              pServParams->dwReplicationTime = (DWORD)iVal;
              break;
          }

          if ((iVal < INTERVAL_MIN) || (iVal > INTERVAL_MAX))
              bReturn = FALSE;
          else
              pServParams->dwReplicationTime = (DWORD)iVal;
          break;

       case IDC_HOUR:
          if (!nValue)
          {
              if (IntlCurrent.iTime)
              { // 24 hour format
                  pServParams->dwHour = 0;
                  pServParams->fPM = FALSE;
              }
              else
              { // 12 hour format
                  pServParams->dwHour = HOUR_MAX;
                  pServParams->fPM = FALSE;
              }
              break;
          }
          if ((iVal < (int)HOUR_MIN) || (iVal > (int)HOUR_MAX))
             bReturn = FALSE;
          break;

       case IDC_MINUTE:
          if (!nValue)
          {
              pServParams->dwMinute = MINUTE_MIN;
              break;
          }
          if ((iVal < MINUTE_MIN) || (iVal > MINUTE_MAX))
             bReturn = FALSE;
          break;

       case IDC_SECOND:
          if (!nValue)
          {
              pServParams->dwSecond = SECOND_MIN;
              break;
          }
          if ((iVal < SECOND_MIN) || (iVal > SECOND_MAX))
             bReturn = FALSE;
          break;
    }
    return (bReturn);
}



//-------------------------------------------------------------------
//  Function:  CheckAMPM
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL CheckAMPM(HWND hDlg, WORD nID)
{
    WCHAR   szName[TIMESUF_LEN + 1];
    UINT    nValue;

    nValue = GetDlgItemText (hDlg, nID, szName, TIMESUF_LEN);
    szName[nValue] = UNICODE_NULL;

    switch (nID)
    {
       case IDC_AMPM:
           if (!nValue)
           {
               pServParams->fPM = FALSE; // default
               return TRUE;
           }
           if (_wcsnicmp(szName, IntlCurrent.sz1159, nValue) &&
               _wcsnicmp(szName, IntlCurrent.sz2359, nValue))
           {
               return FALSE;
           }
           else
           { // One of them may match fully
               if (!_wcsicmp (szName, IntlCurrent.sz1159))
               {
                   pServParams->fPM = FALSE;
               }
               else if (!_wcsicmp(szName, IntlCurrent.sz2359))
               {
                   pServParams->fPM = TRUE;
               }
           }
           break;
    }
    return TRUE;
}

//-------------------------------------------------------------------
//  Function: dlgprocLICCPACONFIG
//
//  Summary:
//        The dialog procedure for the main Control Panel Applet Dialog
//
//  In:
//        hwndDlg     - handle of Dialog window 
//        uMsg         - message                       
//         lParam1    - first message parameter
//        lParam2    - second message parameter       
//  Out: 
//  Returns: 
//        message dependant
//
//  Caveats:
//
//  History:
//        Feb-07-95  ChandanS Created
//        Mar-14-95   MikeMi  Added F1 PWM_HELP message
//        Mar-30-95   MikeMi  Added Replication Help Context
//        Feb-28-96  JeffParh Added handling of UDN_DELTAPOS and EN_SETFOCUS,
//                            removed WM_VSCROLL (switched from private
//                            cpArrow class to Up-Down common ctrl)
//
//-------------------------------------------------------------------
INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LRESULT frt = FALSE;
    short nID;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            OnCpaConfigInitDialog( hwndDlg );
            return( (LRESULT)TRUE ); // use default keyboard focus
            break;

        case WM_COMMAND:
            switch (HIWORD( wParam ))
            {
                case EN_UPDATE:
                    switch (LOWORD( wParam ))
                    {
                        case IDC_AMPM:
                            if (!CheckAMPM (hwndDlg, LOWORD(wParam)))
                                SendMessage ((HWND) lParam, EM_UNDO, 0, 0L);
                            break;
                        case IDC_HOURS:
                        case IDC_HOUR:
                        case IDC_MINUTE:
                        case IDC_SECOND:
                            if (!CheckNum (hwndDlg, LOWORD(wParam)))
                                SendMessage ((HWND) lParam, EM_UNDO, 0, 0L);
                            break;
                        default:
                            break;
                    }
                    break;

                case EN_SETFOCUS:
                    frt = (LRESULT)OnEnSetFocus( hwndDlg, LOWORD( wParam ) );
                    break;

                case BN_CLICKED:
                    switch (LOWORD( wParam ))
                    {
                        case IDOK:
                            frt = (LRESULT)TRUE;     // use as save flag
                            // intentional no break

                        case IDCANCEL:
                            OnCpaConfigClose( hwndDlg, !!frt , wParam);
                            frt = (LRESULT)FALSE;
                            break;

                        case IDC_REPL_INT:
                        case IDC_REPL_TIME:
                            OnSetReplicationTime( hwndDlg, LOWORD(wParam) );
                            break;
             
                        case IDC_BUTTONHELP:
                            PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                            break;

                        default:
                            break;
                    }
                break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:
            nID = (short) wParam;

            if ( IDC_TIMEARROW == nID )
            {
                frt = (LRESULT)OnDeltaPosSpinTime( hwndDlg, (NM_UPDOWN*) lParam );
            }
            else
            {
                frt = (LRESULT)FALSE;
            }
            break;

        case WM_CTLCOLORSTATIC:
            frt = (LRESULT) OnCtlColorStatic( hwndDlg, (HDC) wParam, (HWND) lParam );
            break;

        default:
            if (PWM_HELP == uMsg)
            {
                ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
            }
            break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function:  OnEnSetFocus
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static BOOL OnEnSetFocus( HWND hwndDlg, short nID )
{
   BOOL  fSetNewRange = TRUE;
   HWND  hwndSpinCtrl;
   int   nMax;
   int   nMin;

   switch ( nID )
   {
   case IDC_AMPM:
      nMin = 0;
      nMax = 1;
      break;

   case IDC_HOUR:
      nMin = HOUR_MIN;
      nMax = HOUR_MAX;
      break;

   case IDC_MINUTE:
      nMin = MINUTE_MIN;
      nMax = MINUTE_MAX;
      break;

   case IDC_SECOND:
      nMin = SECOND_MIN;
      nMax = SECOND_MAX;
      break;

   default:
      fSetNewRange = FALSE;
      break;
   }

   if ( fSetNewRange )
   {
      hwndSpinCtrl = GetDlgItem( hwndDlg, IDC_TIMEARROW );
      SendMessage( hwndSpinCtrl, UDM_SETRANGE, 0, (LPARAM) MAKELONG( (short) nMax, (short) nMin ) );      
   }
   

   return FALSE;
}

//-------------------------------------------------------------------
//  Function:  OnDeltaPosSpinTime
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static BOOL OnDeltaPosSpinTime( HWND hwndDlg, NM_UPDOWN * pnmud )
{
   WCHAR szTemp[ 16 ] = TEXT( "" );
   HWND  hwndEdit;
   short nID;
   int nValue;
   LRESULT lRange;
   short nRangeHigh;
   short nRangeLow;
   BOOL  frt;

   hwndEdit = GetFocus();
   nID = (short) GetWindowLong( hwndEdit, GWL_ID );

   if (    ( IDC_HOUR   == nID )
        || ( IDC_MINUTE == nID )
        || ( IDC_SECOND == nID )
        || ( IDC_AMPM   == nID ) )
   {
      if ( IDC_AMPM == nID )
      {
         // AM/PM
         GetDlgItemText( hwndDlg, nID, szTemp, sizeof( szTemp ) / sizeof( *szTemp ) );
         nValue = _wcsicmp( szTemp, IntlCurrent.sz2359 );
         SetDlgItemText( hwndDlg, nID, nValue ? IntlCurrent.sz2359 : IntlCurrent.sz1159 );
      }
      else
      {
         lRange = SendMessage( pnmud->hdr.hwndFrom, UDM_GETRANGE, 0, 0 );
         nRangeHigh = LOWORD( lRange );
         nRangeLow  = HIWORD( lRange );

         nValue = GetDlgItemInt( hwndDlg, nID, NULL, FALSE );
         nValue += pnmud->iDelta;

         if ( nValue < nRangeLow )
         {
            nValue = nRangeLow;
         }
         else if ( nValue > nRangeHigh )
         {
            nValue = nRangeHigh;
         }

         if ( ( IDC_HOUR == nID ) && !IntlCurrent.iTLZero )
         {
            // set value w/o leading 0
            SetDlgItemInt( hwndDlg, nID, nValue, FALSE );
         }
         else
         {
            // set value w/ leading 0
            wsprintf( szTemp, TEXT("%02u"), nValue );
            SetDlgItemText( hwndDlg, nID, szTemp );
         }
      }

      SetFocus( hwndEdit );
      SendMessage( hwndEdit, EM_SETSEL, 0, -1 );

      // handled
      frt = TRUE;
   }
   else
   {
      // not handled
      frt = FALSE;
   }

   return frt;
}

//-------------------------------------------------------------------
//  Function:  OnCtlColorStatic
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static HBRUSH OnCtlColorStatic( HWND hwndDlg, HDC hDC, HWND hwndStatic )
{
   LONG     nID;
   HBRUSH   hBrush;

   nID = GetWindowLong( hwndStatic, GWL_ID );

   if (    pServParams->dwReplicationType
        && (    ( IDC_TIMESEP1        == nID )
             || ( IDC_TIMESEP2        == nID )
             || ( IDC_TIMEEDIT_BORDER == nID ) ) )
   {
      hBrush = (HBRUSH) DefWindowProc( hwndDlg, WM_CTLCOLOREDIT, (WPARAM) hDC, (LPARAM) hwndStatic );
   }    
   else
   {
      hBrush = (HBRUSH) DefWindowProc( hwndDlg, WM_CTLCOLORSTATIC, (WPARAM) hDC, (LPARAM) hwndStatic );
   }

   return hBrush;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\help.hpp ===
//-------------------------------------------------------------------
//
// FILE: Help.hpp
//
// Summary;
// 		This file contians global defines for helpfile entries
//
// History;
//		Nov-30-94	MikeMi	Created
//
//-------------------------------------------------------------------

#ifndef __HELP_HPP__
#define __HELP_HPP__

// Applet help file and help context
//
const DWORD LICCPA_HELPCONTEXTMAIN        = 100; 
const DWORD LICCPA_HELPCONTEXTMAINSETUP   = 101;
const DWORD LICCPA_HELPCONTEXTVIOLATION   = 200;
const DWORD LICCPA_HELPCONTEXTPERSEAT     = 300;
const DWORD LICCPA_HELPCONTEXTPERSERVER   = 400;
const DWORD LICCPA_HELPCONTEXTSERVERAPP   = 500;
const DWORD LICCPA_HELPCONTEXTLICENSING   = 600;
const DWORD LICCPA_HELPCONTEXTREPLICATION = 700;
const DWORD LICCPA_HELPCONTEXTSETUPMODE   = 161;

const WCHAR LICCPA_HELPFILE[] = L"LicCpa.Hlp";

const WCHAR LICCPA_HTMLHELPFILE[] = L"liceconcepts.chm";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\liccpa.cpp ===
//-------------------------------------------------------------------
//
// FILE: LicCpa.cpp
//
// Summary;
//      This file contians the DLL & CPL entry points, F1 Help message
//      hooking, and misc common dialog functions.
//
// Entry Points;
//      CPlSetup
//      CPlApplet
//      DllMain
//
// History;
//      Nov-30-94   MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-12-95  JeffParh Added secure certificate support
//
//-------------------------------------------------------------------

#include <windows.h>
#include <cpl.h>
#include "resource.h"
#include <stdlib.h>
#include <stdio.h>
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include "liccpa.hpp"
#include "Special.hpp"

extern "C"
{
    BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
    BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult );
    LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
    LRESULT CALLBACK msgprocHelpFilter( int nCode, WPARAM wParam, LPARAM lParam );
}

// Setup routines
//
const CHAR szSETUP_NORMAL[]         = "FULLSETUP";
const CHAR szSETUP_PERSEAT[]        = "PERSEAT";
const CHAR szSETUP_UNATTENDED[]     = "UNATTENDED";
const CHAR szSETUP_NORMALNOEXIT[]   = "FULLSETUPNOEXIT";

const CHAR szREMOTESETUP_NORMAL[]       = "REMOTEFULLSETUP";
const CHAR szREMOTESETUP_PERSEAT[]      = "REMOTEPERSEAT";
const CHAR szREMOTESETUP_UNATTENDED[]   = "REMOTEUNATTENDED";
const CHAR szREMOTESETUP_NORMALNOEXIT[] = "REMOTEFULLSETUPNOEXIT";

// Modes for unattended setup
//
const CHAR szUNATTENDED_PERSEAT[]   = "PERSEAT";
const CHAR szUNATTENDED_PERSERVER[] = "PERSERVER";

// Certificate required / not required
const CHAR szSETUP_CERTREQUIRED[]    = "CERTREQUIRED";
const CHAR szSETUP_CERTNOTREQUIRED[] = "CERTNOTREQUIRED";

// Use default help file
const CHAR szSETUP_DEFAULTHELP[]     = "DEFAULTHELP";

// Setup Error return strings
//
static CHAR szSETUP_EXIT[]           = "EXIT";
static CHAR szSETUP_ERROR[]          = "ERROR";
static CHAR szSETUP_SECURITY[]       = "SECURITY";
static CHAR szSETUP_NOREMOTE[]       = "NOREMOTE";
static CHAR szSETUP_DOWNLEVEL[]      = "DOWNLEVEL";

static CHAR szSETUP_OK[]             = "OK";


// Registered help message for F1 hooking
//
const WCHAR szF1HELPMESSAGE[] = L"LicCpaF1Help";

HINSTANCE g_hinst = NULL;  // global hinstance of this dll
HHOOK g_hhook = NULL;      // global hhook for F1 message filter
UINT PWM_HELP = 0;          // global help message when F1 is pressed

//-------------------------------------------------------------------
//
//  Function: msgprocHelpFilter
//
//  Summary;
//      This functions will filter the messages looking for F1, then send
//      the registered message to the top most parent of that window
//      informing it that F1 for help was pressed.
//
//  Arguments;
//      (see Win32 MessageProc)
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

LRESULT CALLBACK msgprocHelpFilter( int nCode, WPARAM wParam, LPARAM lParam )
{
    LRESULT lrt = 0;
    PMSG pmsg = (PMSG)lParam;

    if (nCode < 0)
    {
        lrt = CallNextHookEx( g_hhook, nCode, wParam, lParam );
    }
    else
    {
        if (MSGF_DIALOGBOX == nCode)
        {
            // handle F1 key
            if ( (WM_KEYDOWN == pmsg->message) &&
                 (VK_F1 == (INT_PTR)pmsg->wParam) )
            {
                HWND hwnd = pmsg->hwnd;

                // post message to parent that handles help
                while( GetWindowLong( hwnd, GWL_STYLE ) & WS_CHILD )
                {
                    hwnd = GetParent( hwnd );
                }
                PostMessage( hwnd, PWM_HELP, 0, 0 );

                lrt = 1;
            }
        }
    }

    return( lrt );
}

//-------------------------------------------------------------------
//
//  Function: InstallF1Hook
//
//  Summary;
//      This will ready the message filter for handling F1.
//      It install the message hook and registers a message that will
//      be posted to the dialogs.
//
//  Arguments;
//      hinst [in] - the module handle of this DLL (needed to install hook)
//      dwThreadId [in] - thread to attach filter to
//
//  Notes:
//      The control.exe does this work and sends the "ShellHelp" message.
//      A seperate F1 message filter is needed because these dialogs maybe
//      raised by other applications than control.exe.
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL InstallF1Hook( HINSTANCE hInst, DWORD dwThreadId )
{
    BOOL frt = FALSE;

    if (NULL == g_hhook)
    {
        g_hhook = SetWindowsHookEx( WH_MSGFILTER,
                (HOOKPROC)msgprocHelpFilter,
                hInst,
                dwThreadId );
        if (NULL != g_hhook)
        {
            PWM_HELP = RegisterWindowMessage( szF1HELPMESSAGE );
            if (0 != PWM_HELP)
            {
                frt = TRUE;
            }
        }
    }

    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: RemoveF1Hook
//
//  Summary;
//      This will remove the message filter hook that InstallF1Hook installs.
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL RemoveF1Hook( )
{
    BOOL frt = UnhookWindowsHookEx( g_hhook );
    g_hhook = NULL;
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: DLLMain
//
//  Summary;
//      Entry point for all DLLs
//
//  Notes:
//      We only support being called from the same thread that called
//      LoadLibrary. Because we install a message hook, and passing a
//      zero for threadid does not work as documented.
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL frt = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
        frt = InstallF1Hook( g_hinst, GetCurrentThreadId() );
        break;

    case DLL_PROCESS_DETACH:
        RemoveF1Hook();
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: LowMemoryDlg
//
//  Summary;
//      Standard function for handling low memory situation
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void LowMemoryDlg()
{
    WCHAR szText[TEMPSTR_SIZE];
    WCHAR szTitle[TEMPSTR_SIZE];

    LoadString(g_hinst, IDS_CPATITLE, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_LOWMEM, szText, TEMPSTR_SIZE);
    MessageBox (NULL, szText, szTitle, MB_OK|MB_ICONEXCLAMATION);
}

//-------------------------------------------------------------------
//
//  Function: BadRegDlg
//
//  Summary;
//      Standard function for handling bad registry situation
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void BadRegDlg( HWND hwndDlg )
{
    WCHAR szText[TEMPSTR_SIZE];
    WCHAR szTitle[TEMPSTR_SIZE];

    LoadString(g_hinst, IDS_CPATITLE, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_BADREGTERM, szText, TEMPSTR_SIZE);
    MessageBox (hwndDlg, szText, szTitle, MB_OK|MB_ICONEXCLAMATION);
}

//-------------------------------------------------------------------
//
//  Function: CenterDialogToScreen
//
//  Summary;
//      Move the window so that it is centered on the screen
//
//  Arguments;
//      hwndDlg [in] - the hwnd to the dialog to center
//
//  History;
//      Dec-3-94    MikeMi  Created
//
//-------------------------------------------------------------------

void CenterDialogToScreen( HWND hwndDlg )
{
    RECT rcDlg;
    INT x, y, w, h;
    INT sw, sh;

    sw = GetSystemMetrics( SM_CXSCREEN );
    sh = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwndDlg, &rcDlg );

    w = rcDlg.right - rcDlg.left;
    h = rcDlg.bottom - rcDlg.top;
    x = (sw / 2) - (w / 2);
    y = (sh / 2) - (h / 2);

    MoveWindow( hwndDlg, x, y, w, h, FALSE );
}

//-------------------------------------------------------------------
//
//  Function: InitStaticWithService
//  Summary;
//      Handle the initialization of a static text with a service name
//
//  Arguments;
//      hwndDlg [in] - the dialog that contains the static
//      wID [in] - the id of the static control
//      pszService [in] - the service display name to use
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void InitStaticWithService( HWND hwndDlg, UINT wID, LPCWSTR pszService )
{
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    GetDlgItemText( hwndDlg, wID, szTemp, LTEMPSTR_SIZE );
    wsprintf( szText, szTemp, pszService );
    SetDlgItemText( hwndDlg, wID, szText );
}

//-------------------------------------------------------------------
//
//  Function: InitStaticWithService2
//  Summary;
//      Handle the initialization of a static text that contians two
//      instances of a service name with the service name
//
//  Arguments;
//      hwndDlg [in] - the dialog that contains the static
//      wID [in] - the id of the static control
//      pszService [in] - the service display name to use
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void InitStaticWithService2( HWND hwndDlg, UINT wID, LPCWSTR pszService )
{
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    GetDlgItemText( hwndDlg, wID, szTemp, LTEMPSTR_SIZE );
    wsprintf( szText, szTemp, pszService, pszService );
    SetDlgItemText( hwndDlg, wID, szText );
}

//-------------------------------------------------------------------
//
//  Function: CPlApplet
//
//  Summary;
//      Entry point for Comntrol Panel Applets
//
//  Arguments;
//      hwndCPL [in]    - handle of Control Panel window
//      uMsg [in]       - message
//      lParam1 [in]    - first message parameter, usually the application number
//      lParam2 [in]    - second message parameter
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------

LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPNEWCPLINFO lpNewCPlInfo;
    LONG_PTR iApp;
    LONG lrt = 0;

    iApp = (LONG_PTR) lParam1;

    switch (uMsg)
    {
    case CPL_INIT:      /* first message, sent once  */
        //
        // Initialize global special version information is this liccpa
        // is a special version (eg: restricted SAM, NFR, etc).
        //

        InitSpecialVersionInfo();
        lrt = TRUE;
        break;

    case CPL_GETCOUNT:  /* second message, sent once */
        lrt = 1; // we support only one application within this DLL
        break;

    case CPL_NEWINQUIRE: /* third message, sent once per app */
        lpNewCPlInfo = (LPNEWCPLINFO) lParam2;

        lpNewCPlInfo->dwSize = (DWORD) sizeof(NEWCPLINFO);
        lpNewCPlInfo->dwFlags = 0;
        lpNewCPlInfo->dwHelpContext = LICCPA_HELPCONTEXTMAIN;
        lpNewCPlInfo->lData = 0;
        lpNewCPlInfo->hIcon = LoadIcon(g_hinst, (LPCWSTR)MAKEINTRESOURCE(IDI_LICCPA));

        wcsncpy( lpNewCPlInfo->szHelpFile,
                LICCPA_HELPFILE,
                sizeof( lpNewCPlInfo->szHelpFile ) / sizeof(WCHAR) );

        LoadString(g_hinst,
                IDS_CPATITLE,
                lpNewCPlInfo->szName,
                sizeof( lpNewCPlInfo->szName ) / sizeof(WCHAR) );
        LoadString(g_hinst,
                IDS_CPADESC,
                lpNewCPlInfo->szInfo,
                sizeof( lpNewCPlInfo->szInfo ) / sizeof(WCHAR));

        break;

    case CPL_SELECT:    /* application icon selected */
        lrt = 1;
        break;

    case CPL_DBLCLK:    /* application icon double-clicked */
        //
        // Check if this is a special version of liccpa.
        //

        if (gSpecVerInfo.idsSpecVerWarning)
        {
            RaiseNotAvailWarning( hwndCPL );
			break;
        }

        CpaDialog( hwndCPL );
        break;

    case CPL_STOP:      /* sent once per app. before CPL_EXIT */
        break;

    case CPL_EXIT:      /* sent once before FreeLibrary called */
        break;

    default:
        break;
    }
    return( lrt );
}

//-------------------------------------------------------------------
//
//  Function: CreateWSTR
//
//  Summary;
//      Given a STR (ASCII or MB), allocate and translate to WSTR
//
//  Arguments;
//      ppszWStr [out] - allocated & converted string
//      pszStr [in] - string to convert
//
//  Return: TRUE if allocated and converted, FALSE if failed
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CreateWSTR( LPWSTR* ppszWStr, LPSTR pszStr )
{
    int cchConv;
    LPWSTR pszConv;
    BOOL frt = FALSE;
    WCHAR pszTemp[LTEMPSTR_SIZE];

    if (NULL == pszStr)
    {
        *ppszWStr = NULL;
        frt = TRUE;
    }
    else
    {
#ifdef FE_SB
        // Since there was a problem in Server setup when calling setlocale or
        // linking C-runtime lib, we used Win32 API instead of mbstowcs.
        cchConv = ::MultiByteToWideChar(CP_ACP, 0,
                                        pszStr, -1,
                                        NULL, 0);
        pszConv = (LPWSTR)::GlobalAlloc( GPTR, cchConv * sizeof( WCHAR ) );
        if (NULL != pszConv)
        {
            ::MultiByteToWideChar(CP_ACP, 0,
                                  pszStr, -1,
                                  pszConv, cchConv);
            *ppszWStr = pszConv;
            frt = TRUE;
        }
#else
        cchConv = mbstowcs( pszTemp, pszStr, LTEMPSTR_SIZE );

        cchConv++;
        pszConv = (LPWSTR)GlobalAlloc( GPTR, cchConv * sizeof( WCHAR ) );
        if (NULL != pszConv)
        {
            lstrcpyW( pszConv, pszTemp );
            *ppszWStr = pszConv;
            frt = TRUE;
        }
#endif
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: Setup
//
//  Summary;
//      Run normal setup or Perseat Setup
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//              If this value is 5, help button will call common help
//              If this value is 9, help button will call the passed help
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (FullSetup | PerSeatSetup)
//          [1] szHwnd - The parent Window handle, in HEX!
//          [2] szService - The Reg Key name of the service
//          [3] szFamilyDisplayName - The family display name of the service
//          [4] szDisplayName - The display name of the service
//          [5] szHelpFile - The complete path and name to help file
//                  leave as an empty string to remove help buttons
//          [6] szHelpContext - the DWORD to use as the main help context
//          [7] szHCPerSeat   - the DWORD to use as the PerSeat Help context
//          [8] szHCPerServer - the DWORD to use as the PerServer help context
//
//  Return:
//      0 - sucessfull
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Nov-17-94   MikeMi  Created
//
//-------------------------------------------------------------------

const int SETUPARG_SETUP        = 0;
const int SETUPARG_HWND         = 1;
const int SETUPARG_SERVICE      = 2;
const int SETUPARG_FAMILYNAME   = 3;
const int SETUPARG_NAME         = 4;
const int SETUPARG_HELPFILE     = 5;
const int SETUPARG_HELPCONTEXT  = 6;
const int SETUPARG_HCPERSEAT    = 7;
const int SETUPARG_HCPERSERVER  = 8;
const int SETUPARG_CERTREQUIRED = 9;

const int SETUPARG_WOOPTIONAL   = 5;  // count of args without optional
const int SETUPARG_WOPTIONAL    = 9;  // count of args with optional
const int SETUPARG_WOPTIONALEX  = 10; // count of args with optional + certrequired extension

INT_PTR Setup( DWORD nArgs, LPSTR apszArgs[] )
{
    SETUPDLGPARAM dlgParam;
    INT_PTR   nError = 0;
    HWND    hwndParent = NULL;
    BOOL fCustomHelp = FALSE;
    BOOL bCertRequired = FALSE;

    dlgParam.pszHelpFile = (LPWSTR)LICCPA_HELPFILE;
    dlgParam.dwHelpContext = LICCPA_HELPCONTEXTMAINSETUP;
    dlgParam.dwHCPerServer = LICCPA_HELPCONTEXTPERSERVER;
    dlgParam.dwHCPerSeat = LICCPA_HELPCONTEXTPERSEAT;
    dlgParam.pszService = NULL;
    dlgParam.pszComputer = NULL;
    dlgParam.fNoExit = FALSE;

    do
    {
        if ((nArgs == SETUPARG_WOPTIONAL) || (nArgs == SETUPARG_WOOPTIONAL) || (nArgs == SETUPARG_WOPTIONALEX))
        {
            if (nArgs > SETUPARG_WOOPTIONAL)
            {
                if ( ( NULL != apszArgs[SETUPARG_HELPFILE] ) && lstrcmpiA( apszArgs[SETUPARG_HELPFILE], szSETUP_DEFAULTHELP ) )
                {
                    // help file given
                    LPWSTR pszHelpFile;

                    if ( CreateWSTR( &pszHelpFile, apszArgs[SETUPARG_HELPFILE] ) )
                    {
                        if (0 == lstrlen( pszHelpFile ))
                        {
                            GlobalFree( (HGLOBAL)pszHelpFile );
                            dlgParam.pszHelpFile = NULL; // should remove help buttons
                        }
                        else
                        {
                            fCustomHelp = TRUE;
                            dlgParam.pszHelpFile = pszHelpFile;
                        }
                    }
                    else
                    {
                        nError = ERR_HELPPARAMS;
                        break;
                    }
                    dlgParam.dwHelpContext = (DWORD)strtoul( apszArgs[SETUPARG_HELPCONTEXT], NULL, 0);
                    dlgParam.dwHCPerSeat = (DWORD)strtoul( apszArgs[SETUPARG_HCPERSEAT], NULL, 0);
                    dlgParam.dwHCPerServer = (DWORD)strtoul( apszArgs[SETUPARG_HCPERSERVER], NULL, 0);
                }

                if ( nArgs > SETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[SETUPARG_CERTREQUIRED] ) )
                    {
                        bCertRequired = TRUE;
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[SETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                        break;
                    }
                }
            }
            // hwnd is in hex!
#ifdef _WIN64
            {
                _int64 val = 0;
                sscanf(apszArgs[SETUPARG_HWND], "%I64x", &val);
                hwndParent = (HWND)val;
            }
#else
            hwndParent = (HWND)strtoul( apszArgs[SETUPARG_HWND], NULL, 16);
#endif
            if ( !IsWindow( hwndParent ) )
            {
                nError = ERR_HWNDPARAM;
                hwndParent = GetActiveWindow(); // use active window as parent
                if (!IsWindow( hwndParent ) )
                {
                    hwndParent = GetDesktopWindow();
                }
            }

            if ( CreateWSTR( &dlgParam.pszService, apszArgs[SETUPARG_SERVICE] ) &&
                 CreateWSTR( &dlgParam.pszDisplayName, apszArgs[SETUPARG_NAME] ) &&
                 CreateWSTR( &dlgParam.pszFamilyDisplayName, apszArgs[SETUPARG_FAMILYNAME] ) )
            {
                if ( bCertRequired )
                {
                    nError = ServiceSecuritySet( dlgParam.pszComputer, dlgParam.pszDisplayName );
                }
                else
                {
                    nError = ERR_NONE;
                }

                if ( ERR_NONE == nError )
                {
                    if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_PERSEAT ))
                    {
                        // use the licensing help context as the main help context
                        dlgParam.dwHelpContext = LICCPA_HELPCONTEXTLICENSING;

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            dlgParam.fNoExit = TRUE;
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = PerSeatSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMALNOEXIT ))
                        {
                            dlgParam.fNoExit = TRUE;
                        }

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = SetupDialog( hwndParent, dlgParam );
                        }
                    }
                }
                else
                {
                    nError = ERR_SERVICEPARAM;
                }
            }

            if (fCustomHelp)
            {
                GlobalFree( (HGLOBAL)dlgParam.pszHelpFile );
            }
            GlobalFree( (HGLOBAL)dlgParam.pszService );
            GlobalFree( (HGLOBAL)dlgParam.pszDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszFamilyDisplayName );
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}

//-------------------------------------------------------------------
//
//  Function: UnattendedSetup
//
//  Summary;
//      This will save the passed values in the registry, keeping all
//      licensing rules in effect and returning errorr/raising dialogs if
//      errors occur.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (Unattended)
//          [1] szService - The Reg Key name of the service
//          [2] szFamilyDisplayName - The family display name of the service
//          [3] szDisplayName - The display name of the service
//          [4] szMode - The string that defines the mode (PerSeat | PerServer)
//          [5] szUsers - The DWORD to use as the count of users in PerServer mode
//
//  Return:
//      0 - sucessfull
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Dec-09-94   MikeMi  Created
//
//-------------------------------------------------------------------

const int UNSETUPARG_SETUP          = 0;
const int UNSETUPARG_SERVICE        = 1;
const int UNSETUPARG_FAMILYNAME     = 2;
const int UNSETUPARG_NAME           = 3;
const int UNSETUPARG_MODE           = 4;
const int UNSETUPARG_USERS          = 5;
const int UNSETUPARG_CERTREQUIRED   = 6;

const int UNSETUPARG_NARGSREQUIRED  = 6;
const int UNSETUPARG_NARGSWOPTIONAL = 7;

int UnattendedSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    int nError = 0;
    LPWSTR pszService;
    LPWSTR pszDisplayName;
    LPWSTR pszFamilyDisplayName;
    LICENSE_MODE lmMode;
    DWORD dwUsers;

    do
    {
        if ( (nArgs == UNSETUPARG_NARGSREQUIRED) || (nArgs == UNSETUPARG_NARGSWOPTIONAL) )
        {
            if ( CreateWSTR( &pszService, apszArgs[UNSETUPARG_SERVICE] ) &&
                 CreateWSTR( &pszDisplayName, apszArgs[UNSETUPARG_NAME] ) &&
                 CreateWSTR( &pszFamilyDisplayName, apszArgs[UNSETUPARG_FAMILYNAME] ) )
            {
                nError = ERR_NONE;

                if ( nArgs > UNSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[UNSETUPARG_CERTREQUIRED] ) )
                    {
                        nError = ServiceSecuritySet( NULL, pszDisplayName );
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[UNSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                    }
                }

                if ( ERR_NONE == nError )
                {
                    //
                    // Check if this is a special version of liccpa.
                    //

                    if (gSpecVerInfo.idsSpecVerWarning)
                    {
                        lmMode  = gSpecVerInfo.lmSpecialMode;
                        dwUsers = gSpecVerInfo.dwSpecialUsers;
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[UNSETUPARG_MODE],
                                            szUNATTENDED_PERSERVER ))
                        {
                            lmMode = LICMODE_PERSERVER;
                        }
                        else if (0 == lstrcmpiA( apszArgs[UNSETUPARG_MODE],
                                                 szUNATTENDED_PERSEAT ))
                        {
                            lmMode = LICMODE_PERSEAT;
                        }
                        else
                        {
                            nError = ERR_INVALIDMODE;
                            break;
                        }
                        dwUsers = (DWORD)strtoul( apszArgs[UNSETUPARG_USERS],
                                                  NULL, 0);
                    }

                    nError = UpdateReg( NULL,
                            pszService,
                            pszFamilyDisplayName,
                            pszDisplayName,
                            lmMode,
                            dwUsers );
                }

                GlobalFree( (HGLOBAL)pszService );
                GlobalFree( (HGLOBAL)pszDisplayName );
                GlobalFree( (HGLOBAL)pszFamilyDisplayName );
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}
//-------------------------------------------------------------------
//
//  Function: RemoteSetup
//
//  Summary;
//      Run normal setup, Perseat Setup, normal setup without exit remotely
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//              If this value is 6, help button will call common help
//              If this value is 10, help button will call the passed help
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run
//          [1] szComputer - the name of the computer to setup on (\\name)
//          [2] szHwnd - The parent Window handle, in HEX!
//          [3] szService - The Reg Key name of the service
//          [4] szFamilyDisplayName - The family display name of the service
//          [5] szDisplayName - The display name of the service
//          [6] szHelpFile - The complete path and name to help file
//                  leave as an empty string to remove help buttons
//          [7] szHelpContext - the DWORD to use as the main help context
//          [8] szHCPerSeat   - the DWORD to use as the PerSeat Help context
//          [9] szHCPerServer - the DWORD to use as the PerServer help context
//
//  Return:
//      0 - sucessfull
//      ERR_PERMISSIONDENIED
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Apr-26-95   MikeMi  Created
//
//-------------------------------------------------------------------

const int REMSETUPARG_SETUP         = 0;
const int REMSETUPARG_COMPUTER      = 1;
const int REMSETUPARG_HWND          = 2;
const int REMSETUPARG_SERVICE       = 3;
const int REMSETUPARG_FAMILYNAME    = 4;
const int REMSETUPARG_NAME          = 5;
const int REMSETUPARG_HELPFILE      = 6;
const int REMSETUPARG_HELPCONTEXT   = 7;
const int REMSETUPARG_HCPERSEAT     = 8;
const int REMSETUPARG_HCPERSERVER   = 9;
const int REMSETUPARG_CERTREQUIRED  = 10;

const int REMSETUPARG_WOOPTIONAL    = 6; // count of args without optional
const int REMSETUPARG_WOPTIONAL = 10; // count of args with optional
const int REMSETUPARG_WOPTIONALEX   = 11; // count of args with optional + certrequired

INT_PTR RemoteSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    SETUPDLGPARAM dlgParam;
    INT_PTR   nError = 0;
    HWND    hwndParent = NULL;
    BOOL fCustomHelp = FALSE;
    BOOL bCertRequired = FALSE;

    dlgParam.pszHelpFile = (LPWSTR)LICCPA_HELPFILE;
    dlgParam.dwHelpContext = LICCPA_HELPCONTEXTMAINSETUP;
    dlgParam.dwHCPerServer = LICCPA_HELPCONTEXTPERSERVER;
    dlgParam.dwHCPerSeat = LICCPA_HELPCONTEXTPERSEAT;
    dlgParam.pszService = NULL;
    dlgParam.fNoExit = FALSE;

    do
    {
        nError = ERR_NONE;

        if ((nArgs == REMSETUPARG_WOPTIONAL) || (nArgs == REMSETUPARG_WOOPTIONAL) || (nArgs == REMSETUPARG_WOPTIONALEX))
        {
            if (nArgs > REMSETUPARG_WOOPTIONAL)
            {
                if ( ( NULL != apszArgs[REMSETUPARG_HELPFILE] ) && lstrcmpiA( apszArgs[REMSETUPARG_HELPFILE], szSETUP_DEFAULTHELP ) )
                {
                    LPWSTR pszHelpFile;

                    if ( CreateWSTR( &pszHelpFile, apszArgs[REMSETUPARG_HELPFILE] ) )
                    {
                        if (0 == lstrlen( pszHelpFile ))
                        {
                            GlobalFree( (HGLOBAL)pszHelpFile );
                            dlgParam.pszHelpFile = NULL; // should remove help buttons
                        }
                        else
                        {
                            fCustomHelp = TRUE;
                            dlgParam.pszHelpFile = pszHelpFile;
                        }
                    }
                    else
                    {
                        nError = ERR_HELPPARAMS;
                        break;
                    }
                    dlgParam.dwHelpContext = (DWORD)strtoul( apszArgs[REMSETUPARG_HELPCONTEXT], NULL, 0);
                    dlgParam.dwHCPerSeat = (DWORD)strtoul( apszArgs[REMSETUPARG_HCPERSEAT], NULL, 0);
                    dlgParam.dwHCPerServer = (DWORD)strtoul( apszArgs[REMSETUPARG_HCPERSERVER], NULL, 0);
                }

                if ( nArgs > REMSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[REMSETUPARG_CERTREQUIRED] ) )
                    {
                        bCertRequired = TRUE;
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[REMSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                        break;
                    }
                }
            }
            // hwnd is in hex!
#ifdef _WIN64
            {
                _int64 val = 0;
                sscanf(apszArgs[REMSETUPARG_HWND], "%I64x", &val);
                hwndParent = (HWND)val;
            }
#else
            hwndParent = (HWND)strtoul( apszArgs[REMSETUPARG_HWND], NULL, 16);
#endif
            if ( !IsWindow( hwndParent ) )
            {
                nError = ERR_HWNDPARAM;
                hwndParent = GetActiveWindow(); // use active window as parent
                if (!IsWindow( hwndParent ) )
                {
                    hwndParent = GetDesktopWindow();
                }
            }

            if ( CreateWSTR( &dlgParam.pszService, apszArgs[REMSETUPARG_SERVICE] ) &&
                 CreateWSTR( &dlgParam.pszDisplayName, apszArgs[REMSETUPARG_NAME] ) &&
                 CreateWSTR( &dlgParam.pszComputer, apszArgs[REMSETUPARG_COMPUTER] ) &&
                 CreateWSTR( &dlgParam.pszFamilyDisplayName, apszArgs[REMSETUPARG_FAMILYNAME] ) )
            {
                if ( bCertRequired )
                {
                    nError = ServiceSecuritySet( dlgParam.pszComputer, dlgParam.pszDisplayName );
                }
                else
                {
                    nError = ERR_NONE;
                }

                if ( ERR_NONE == nError )
                {
                    if (0 == lstrcmpiA( apszArgs[REMSETUPARG_SETUP], szREMOTESETUP_PERSEAT ))
                    {
                        // use the licensing help context as the main help context
                        dlgParam.dwHelpContext = LICCPA_HELPCONTEXTLICENSING;

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            dlgParam.fNoExit = TRUE;
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = PerSeatSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[REMSETUPARG_SETUP], szREMOTESETUP_NORMALNOEXIT ))
                        {
                            dlgParam.fNoExit = TRUE;
                        }

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = SetupDialog( hwndParent, dlgParam );
                        }
                    }
                }
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }

            if (fCustomHelp)
            {
                GlobalFree( (HGLOBAL)dlgParam.pszHelpFile );
            }
            GlobalFree( (HGLOBAL)dlgParam.pszService );
            GlobalFree( (HGLOBAL)dlgParam.pszDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszFamilyDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszComputer );
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}

//-------------------------------------------------------------------
//
//  Function: RemoteUnattendedSetup
//
//  Summary;
//      This will save the passed values in the registry, keeping all
//      licensing rules in effect and returning errorr/raising dialogs if
//      errors occur. This is done remotely on the computer specified.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (Unattended)
//          [1] szComputer - the name of the computer to setup on (\\name)
//          [2] szService - The Reg Key name of the service
//          [3] szFamilyDisplayName - The family display name of the service
//          [4] szDisplayName - The display name of the service
//          [5] szMode - The string that defines the mode (PerSeat | PerServer)
//          [6] szUsers - The DWORD to use as the count of users in PerServer mode
//
//  Return:
//      0 - sucessfull
//      ERR_PERMISSIONDENIED
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_USERSPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Apr-26-95   MikeMi  Created
//
//-------------------------------------------------------------------

const int REMUNSETUPARG_SETUP           = 0;
const int REMUNSETUPARG_COMPUTER        = 1;
const int REMUNSETUPARG_SERVICE         = 2;
const int REMUNSETUPARG_FAMILYNAME      = 3;
const int REMUNSETUPARG_NAME            = 4;
const int REMUNSETUPARG_MODE            = 5;
const int REMUNSETUPARG_USERS           = 6;
const int REMUNSETUPARG_CERTREQUIRED    = 7;

const int REMUNSETUPARG_NARGSREQUIRED   = 7;
const int REMUNSETUPARG_NARGSWOPTIONAL  = 8;

int RemoteUnattendedSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    int nError = 0;
    LPWSTR pszService;
    LPWSTR pszDisplayName;
    LPWSTR pszFamilyDisplayName;
    LPWSTR pszComputerName;

    LICENSE_MODE lmMode;
    DWORD dwUsers;

    do
    {
        if ( (nArgs == REMUNSETUPARG_NARGSREQUIRED) || (nArgs == REMUNSETUPARG_NARGSWOPTIONAL) )
        {
            if ( CreateWSTR( &pszService, apszArgs[REMUNSETUPARG_SERVICE] ) &&
                 CreateWSTR( &pszDisplayName, apszArgs[REMUNSETUPARG_NAME] ) &&
                 CreateWSTR( &pszFamilyDisplayName, apszArgs[REMUNSETUPARG_FAMILYNAME] ) &&
                 CreateWSTR( &pszComputerName, apszArgs[REMUNSETUPARG_COMPUTER] ) )
            {
                nError = ERR_NONE;

                if ( nArgs > REMUNSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[REMUNSETUPARG_CERTREQUIRED] ) )
                    {
                        nError = ServiceSecuritySet( pszComputerName, pszDisplayName );
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[REMUNSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                    }
                }

                if ( ERR_NONE == nError )
                {
                    //
                    // Check if this is a special version of liccpa.
                    //

                    if (gSpecVerInfo.idsSpecVerWarning)
                    {
                        lmMode  = gSpecVerInfo.lmSpecialMode;
                        dwUsers = gSpecVerInfo.dwSpecialUsers;
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[REMUNSETUPARG_MODE],
                                            szUNATTENDED_PERSERVER ))
                        {
                            lmMode = LICMODE_PERSERVER;
                        }
                        else if (0 == lstrcmpiA( apszArgs[REMUNSETUPARG_MODE],
                                                 szUNATTENDED_PERSEAT ))
                        {
                            lmMode = LICMODE_PERSEAT;
                        }
                        else
                        {
                            nError = ERR_INVALIDMODE;
                            break;
                        }
                        dwUsers = (DWORD)strtoul(
                                            apszArgs[REMUNSETUPARG_USERS],
                                            NULL, 0);
                    }

                    nError = UpdateReg( pszComputerName,
                            pszService,
                            pszFamilyDisplayName,
                            pszDisplayName,
                            lmMode,
                            dwUsers );
                }

                if(pszService != NULL)
                {
                    GlobalFree( (HGLOBAL)pszService );
                }
                if(pszDisplayName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszDisplayName );
                }
                if(pszFamilyDisplayName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszFamilyDisplayName );
                }
                if(pszComputerName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszComputerName );
                }
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}

//-------------------------------------------------------------------
//
//  Function: CPlSetup
//
//  Summary;
//      Dll entry point for License Mode Setup, to be used from Setup
//      programs.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run
//                  FullSetup | RemoteFullSetup |
//                  PerSeatSetup | RemotePerSeatSetup |
//                  Unattended |  RemoteUnattended |
//                  FullSetupNoexit | RemoteFullSetupNoexit
//      ppszResult [out]- The result string
//
//  Return:
//
//  Notes:
//
//  History:
//      Nov-17-94   MikeMi  Created
//      Apr-26-95   MikeMi  Added remoting routines
//
//-------------------------------------------------------------------

BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult )
{
    INT_PTR   nError = 0;
    BOOL  frt = TRUE;

    //
    // Initialize global special version information is this liccpa
    // is a special version (eg: restricted SAM, NFR, etc).
    //

    InitSpecialVersionInfo();

    if ((0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_PERSEAT )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMAL )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMALNOEXIT )) )
    {
        nError = Setup( nArgs, apszArgs );
    }
    else if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_UNATTENDED ))
    {
        nError = UnattendedSetup( nArgs, apszArgs );
    }
    else if ((0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_PERSEAT )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_NORMAL )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_NORMALNOEXIT )) )
    {
        nError = RemoteSetup( nArgs, apszArgs );
    }
    else if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_UNATTENDED ))
    {
        nError = RemoteUnattendedSetup( nArgs, apszArgs );
    }
    else
    {
        nError = ERR_INVALIDROUTINE;
    }

    // prepare error for return
    switch (nError)
    {
    case 0:
        *ppszResult = szSETUP_EXIT;
        break;

    case ERR_NONE:
        *ppszResult = szSETUP_OK;
        break;

    case ERR_PERMISSIONDENIED:
        frt = FALSE;
        *ppszResult = szSETUP_SECURITY;
        break;

    case ERR_NOREMOTESERVER:
        frt = FALSE;
        *ppszResult = szSETUP_NOREMOTE;
        break;

    case ERR_DOWNLEVEL:
        frt = FALSE;
        *ppszResult = szSETUP_DOWNLEVEL;
        break;

    default:
        *ppszResult = szSETUP_ERROR;
        frt = FALSE;
        break;
    }

    return( frt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\liccpa.hpp ===
//-------------------------------------------------------------------
//
// FILE: LicCpa.cpp
//
// Summary;
// 		This file contians applet global defines and stdfuncs externs
//
// History;
//      Nov-30-94   MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-12-95  JeffParh Added secure certificate support
//
//-------------------------------------------------------------------

#ifndef __LICCPA_HPP__
#define __LICCPA_HPP__

#include "Help.hpp"


const int TEMPSTR_SIZE = 257; // avoid 256 boundary
const int LTEMPSTR_SIZE = 513; // avoid 512 boundary

// Setup Error codes, though currently only internal
//
const int ERR_NONE              = 1;   // zero has the meaning of cancel or exit
const int ERR_HELPPARAMS   		= 100;
const int ERR_HWNDPARAM    		= 101;
const int ERR_SERVICEPARAM 		= 102;
const int ERR_USERSPARAM 		= 103;

const int ERR_NUMPARAMS			= 104;
const int ERR_CLASSREGFAILED	= 105;
const int ERR_INVALIDROUTINE	= 106;
const int ERR_INVALIDMODE		= 107;
const int ERR_PERMISSIONDENIED	= 200;
const int ERR_NOREMOTESERVER	= 201;
const int ERR_REGISTRYCORRUPT	= 202;
const int ERR_DOWNLEVEL          = 210;   // target server doesn't support LLS extended RPC
                                          // (i.e., it's running 3.51)
const int ERR_CERTREQFAILED      = 211;   // the attempt to notify the license service that
                                          // the given product requires a secure certificate failed
const int ERR_CERTREQPARAM       = 212;   // the string in the "certrequired" argument position
                                          // is unrecognized

extern HINSTANCE g_hinst;
extern UINT PWM_HELP;

extern void LowMemoryDlg();
extern void BadRegDlg( HWND hwndDlg );
extern void CenterDialogToScreen( HWND hwndDlg );
extern void InitStaticWithService( HWND hwndDlg, UINT wID, LPCWSTR pszService );
extern void InitStaticWithService2( HWND hwndDlg, UINT wID, LPCWSTR pszService );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\config.hpp ===
//-------------------------------------------------------------------
//
// FILE: config.hpp
//
// Summary;
//    This file contians the definitions of Primary Dialogs functions
//
// Entry Points;
//
// History;
//    Mar-01-95   ChandanS    Created
//    Jan-30-96   JeffParh    Lowered minimum replication interval
//                            from 6 hours to 1 hour
//    Apr-17-96   JeffParh    Moved variable definitions to config.cpp.
//
//-------------------------------------------------------------------

#ifndef __CONFIG_HPP__
#define __CONFIG_HPP__

const int cchEDITLIMIT = 2;  // the number of chars to repesent 
const DWORD INTERVAL_MIN = 1;
const DWORD INTERVAL_MAX = 72;
const DWORD INTERVAL_PAGE = 2;
const DWORD HOUR_MIN_24 = 0;
const DWORD HOUR_MAX_24 = 23;
const DWORD HOUR_PAGE_24 = 2;
const DWORD HOUR_MIN_12 = 1;
const DWORD HOUR_MAX_12 = 12;
const DWORD HOUR_PAGE_12 = 1;
const DWORD MINUTE_MIN = 0;
const DWORD MINUTE_MAX = 59;
const DWORD MINUTE_PAGE = 4;
const DWORD SECOND_MIN = 0;
const DWORD SECOND_MAX = 59;
const DWORD SECOND_PAGE = 4;
const DWORD ATINIT = 1;
const DWORD FORSERVER = 2;
const DWORD FORTIME = 3;

const UINT MB_VALUELIMIT = MB_OK;  // beep when value limit is reached

// Registry Keys
const WCHAR LICENSE_SERVICE_REG_KEY[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseService";
const WCHAR szLicenseKey[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters";
const WCHAR szUseEnterprise[] = L"UseEnterprise";
const WCHAR szEnterpriseServer[] = L"EnterpriseServer";
const WCHAR szReplicationType[] = L"ReplicationType";
const WCHAR szReplicationTime[] = L"ReplicationTime";

// set values under License Key
//
const DWORD dwUseEnterprise = 0; 
const DWORD dwReplicationType = 0;
const DWORD dwReplicationTime = 24;
const DWORD dwReplicationTimeInSec = 24 * 60 * 60;
const DWORD dwInterval = 0;

// Used for in memory storage of license mode state
//
typedef struct _ServiceParams
{
    DWORD           dwUseEnterprise;
    LPWSTR          pszEnterpriseServer;
    DWORD           dwReplicationType;
    DWORD           dwReplicationTime;
    DWORD           dwHour;
    DWORD           dwMinute;
    DWORD           dwSecond;
    BOOL            fPM;
} SERVICEPARAMS, *PSERVICEPARAMS;

/* Suffix length + NULL terminator */
#define TIMESUF_LEN   9

typedef struct              /* International section description */
{
    int    iTime;           /* Time mode (0: 12 hour clock, 1: 24 ) */
    int    iTLZero;         /* Leading zeros for hour (0: no, 1: yes) */
    TCHAR  sz1159[TIMESUF_LEN];  /* Trailing string from 0:00 to 11:59 */
    TCHAR  sz2359[TIMESUF_LEN];  /* Trailing string from 12:00 to 23:59 */
    TCHAR  szTime[4];        /* Time separator string */
} INTLSTRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\pridlgs.hpp ===
//-------------------------------------------------------------------
//
// FILE: PriDlgs.hpp
//
// Summary;
// 		This file contians the definitions of Primary Dialogs functions
//
// Entry Points;
//		PerSeatSetupDialog
//		SetupDialog
//		CpaDialog
//		UpdateReg
//
// History;
//		Nov-30-94	MikeMi	Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

#ifndef __PRIDLGS_HPP__
#define __PRIDLGS_HPP__

#include "CLicReg.hpp"

// Used to pass information from the Setup entry point to the Setup Dialog
//
typedef struct tagSETUPDLGPARAM
{
    LPWSTR  pszComputer;
	LPWSTR  pszService;
	LPWSTR  pszFamilyDisplayName;
    LPWSTR  pszDisplayName;
	LPWSTR	pszHelpFile;
	DWORD   dwHelpContext;
	DWORD   dwHCPerServer;
	DWORD	dwHCPerSeat;
	BOOL	fNoExit;
} SETUPDLGPARAM, *PSETUPDLGPARAM;

extern INT AccessOk( HWND hDlg, LONG lrc, BOOL fCPCall );
extern INT_PTR PerSeatSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern INT_PTR SetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern INT_PTR CpaDialog( HWND hwndParent );
extern int UpdateReg( LPCWSTR pszComputer, 
        LPCWSTR pszService, 
        LPCWSTR pszFamilyDisplayName, 
        LPCWSTR pszDisplayName, 
        LICENSE_MODE lm, 
        DWORD dwUsers );

int ServiceSecuritySet( LPWSTR pszComputer, LPWSTR pszDisplayName );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\resource.h ===
#include <windows.h>

#define  IDS_CPATITLE                                 1
#define  IDS_CPADESC                                  2

#define  IDS_CPCAPTION                                3
#define  IDS_SETUPCAPTION                             4
#define  IDS_NOACCESS                                 5
#define  IDS_NOSERVER                                 6
#define  IDS_BADREG                                   7
#define  IDS_NOSERVICES                               8

#define  IDS_BADREGTERM                               9
#define  IDS_LOWMEM                                   10

#define  IDS_INVALIDUSERCOUNT                         13
#define  IDS_PASSWORD_INVALID                         14
#define  IDS_PASSWORD_MISMATCH                        15
#define  IDS_COMPUTERNAME_INVALID                     16
#define  IDS_ACCOUNT_NAME_INVALID                     17
#define  IDS_NO_SELF_REPLICATION                      18

#define  IDS_MSDN_NOTAVAILABLE                        20
#define  IDS_MSDN_TEXT1                               21
#define  IDS_MSDN_TEXT2                               22

#define  IDS_NFR_NOTAVAILABLE                         30
#define  IDS_NFR_TEXT1                                31
#define  IDS_NFR_TEXT2                                32

#define  IDS_LICENSE_SETUP_NO_PER_SERVER_LICENSES     40
#define  IDS_LICENSE_SETUP_SAVE_FAILED                41
#define  IDS_LICENSE_SETUP_CANT_INVOKE_WINHELP        42
#define  IDS_LICENSE_SETUP_BAD_UNATTEND_PARAM         43

#define  IDS_WARNING                                  50
#define  IDS_ERROR                                    51

#define  IDS_MSSERIF                                  60
#define  IDS_LARGEFONTSIZE                            61

#define  IDS_SERVICE_DISPLAY_NAME                     70

#define  IDS_SETUP_HEADER                             71
#define  IDS_SETUP_SUBHEADER                          72

#define  IDS_SERVICE_DESCRIPTION                      73

#define  IDS_SAM_NOTAVAILABLE                         80
#define  IDS_SAM_TEXT1                                81
#define  IDS_SAM_TEXT2                                82
#define  IDS_SAMNFR_NOTAVAILABLE                      83
#define  IDS_SAMNFR_TEXT1                             84
#define  IDS_SAMNFR_TEXT2                             85
#include "Dialogs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\sbs_res.h ===
#define SBS_RESOURCE_DLL    L"sbslimit.dll"
#define SBS_License_Error   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\pridlgs.cpp ===
//-------------------------------------------------------------------
//
// FILE: PriDlgs.cpp
//
// Summary;
//      This file contians the Primary Dialogs, functions and dialog procs
//
// Entry Points;
//
// History;
//      Nov-30-94   MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-15-95  JeffParh Added secure certificate support.
//
//-------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "resource.h"
#include "CLicReg.hpp"
#include <stdlib.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include <llsapi.h>


extern "C"
{
    INT_PTR CALLBACK dlgprocLICCPA( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocLICSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocPERSEATSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

// Perserver user count value limits and defaults
//
const int PERSERVER_LIMITDEFAULT = 0;
const int PERSERVER_MAX = 999999;
const int PERSERVER_MIN = 0;
const int PERSERVER_PAGE = 10;
const int cchEDITLIMIT = 6;  // the number of chars to represent PERSERVER_MAX

const UINT MB_VALUELIMIT = MB_OK;  // beep when value limit is reached

// Used for in memory storage of license mode state
//
typedef struct tagSERVICEENTRY
{
    LPWSTR       pszComputer;
    LPWSTR       pszService;
    LPWSTR       pszDisplayName;
    LPWSTR       pszFamilyDisplayName;
    LICENSE_MODE lm;
    DWORD        dwLimit;
    BOOL         fIsNewProduct;
} SERVICEENTRY, *PSERVICEENTRY;

#pragma warning(push)
#pragma warning(disable: 4296) // C4296: '<=' : expression is always true
inline BOOL VALIDUSERCOUNT( UINT users )
{
    return ((PERSERVER_MIN <= users) && (PERSERVER_MAX >= users));
}
#pragma warning(pop)

static void UpdatePerServerLicenses( HWND hwndDlg, PSERVICEENTRY pServ );
static int ServiceRegister( LPWSTR pszComputer,
                            LPWSTR pszFamilyDisplayName,
                            LPWSTR pszDisplayName );


BOOL g_fWarned = FALSE;

//-------------------------------------------------------------------
//
//  Function:  AccessOk
//
//  Summary;
//      Checks access rights from reg call and raise dialog as needed
//
//  Arguments;
//      hDlg [in]   - Handle to working dialog to raise error dlgs with
//      lrc [in]    - the return status from a reg call
//
//  Returns:
//      local error mapping;
//      ERR_NONE
//      ERR_PERMISSIONDENIED
//      ERR_NOREMOTESERVER
//      ERR_REGISTRYCORRUPT
//
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

INT AccessOk( HWND hDlg, LONG lrc, BOOL fCPCall )
{
    INT  nrt = ERR_NONE;
    
    if (ERROR_SUCCESS != lrc)
    {
        WCHAR szText[TEMPSTR_SIZE];
        WCHAR szTitle[TEMPSTR_SIZE];
        UINT  wId;
        UINT  wIdTitle;
        
        switch (lrc)
        {
        case ERROR_ACCESS_DENIED:
            wId = IDS_NOACCESS;
            nrt = ERR_PERMISSIONDENIED;
            break;

        case RPC_S_SERVER_UNAVAILABLE:
            wId = IDS_NOSERVER;         
            nrt = ERR_NOREMOTESERVER;
            break;

        default:
            wId = IDS_BADREG;
            nrt = ERR_REGISTRYCORRUPT;
            break;
        }       

        if (fCPCall)
        {
            wIdTitle = IDS_CPCAPTION;
        }
        else
        {
            wIdTitle = IDS_SETUPCAPTION;
        }

        LoadString(g_hinst, wIdTitle, szTitle, TEMPSTR_SIZE);
        LoadString(g_hinst, wId, szText, TEMPSTR_SIZE);
        MessageBox (hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
    }
    return( nrt );
}

//-------------------------------------------------------------------
//
//  Function: InitUserEdit
//
//  Summary;
//      Initializes and defines user count edit control behaviour
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog of user count edit dialog
//
// History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitUserEdit( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);

    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );
}

//-------------------------------------------------------------------
//
//  Function: InitTitleText
//
//  Summary;
//      Initialize title static text and mode definition static text
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog of description static text
//      pServ [in]      - Service definition to set static text
//  
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitTitleText( HWND hwndDlg,  PSERVICEENTRY pServ )
{
    InitStaticWithService( hwndDlg, IDC_STATICTITLE, pServ->pszDisplayName );
    InitStaticWithService( hwndDlg, IDC_STATICPERSEAT, pServ->pszDisplayName );
}

//-------------------------------------------------------------------
//
//  Function: InitDialogForService
//
//  Summary;
//      Initialize dialog controls to the service state
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog to init controls in
//      pServ [in]      - Service definition to set controls
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitDialogForService( HWND hwndDlg, PSERVICEENTRY pServ )
{
    HWND hwndCount =    GetDlgItem( hwndDlg, IDC_USERCOUNT );
    HWND hwndSpin = GetDlgItem( hwndDlg, IDC_USERCOUNTARROW );
    BOOL fIsPerServer = (LICMODE_PERSERVER==pServ->lm);

    // set radio button states
    CheckDlgButton( hwndDlg, IDC_PERSEAT, !fIsPerServer );
    CheckDlgButton( hwndDlg, IDC_PERSERVER, fIsPerServer );
    
    // set user count edit control
    if (fIsPerServer)
    {
        // add text back
        SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
        SetFocus( hwndCount );
        SendMessage( hwndCount, EM_SETSEL, 0, -1 );
    }
    else
    {
        // remove all text in item
        SetDlgItemText( hwndDlg, IDC_USERCOUNT, L"" );
    }

    // set state of edit control and arrows
   if ( NULL != hwndSpin )
   {
       EnableWindow( hwndCount, fIsPerServer );
       EnableWindow( hwndSpin, fIsPerServer );
   }
   else
   {
       UpdatePerServerLicenses( hwndDlg, pServ );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ADD_LICENSES    ), fIsPerServer );
       EnableWindow( GetDlgItem( hwndDlg, IDC_REMOVE_LICENSES ), fIsPerServer );
   }
}

//-------------------------------------------------------------------
//
//  Function: FreeServiceEntry
//
//  Summary;
//      Free all allocated memory when a service structure is created
//
//  Aruments;
//      pServ [in]  - The Service structure to free
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void FreeServiceEntry( PSERVICEENTRY pServ )
{
    GlobalFree( pServ->pszService );
    GlobalFree( pServ->pszDisplayName );
    if ( NULL != pServ->pszComputer )
    {
        GlobalFree( pServ->pszComputer );
    }
    GlobalFree( pServ );
}

//-------------------------------------------------------------------
//
//  Function: CreateServiceEntry
//
//  Summary;
//      Using the Service registry key name, allocate a Service structure
//      and setup registry.
//
//  Arguments;
//      pszComputer [in] - The name of the computer to use (maybe null)
//      pszService [in] - The name of the reg key to use to load or create 
//          service from
//      pszDisplayName [in] - The name the user will see, this will only be
//          if the registry does not contain a displayname already
//
//  Returns: NULL if Error, pointer to allocated Service Structure
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

PSERVICEENTRY CreateServiceEntry( LPCWSTR pszComputer,
        LPCWSTR pszService,
        LPCWSTR pszFamilyDisplayName,
        LPCWSTR pszDisplayName )
{
    CLicRegLicenseService cLicServKey;
    PSERVICEENTRY pServ = NULL;
    DWORD cchSize = 0;
    LONG lrt;

    pServ = (PSERVICEENTRY)GlobalAlloc( GPTR, sizeof( SERVICEENTRY ));
    if (pServ)
    {
        cLicServKey.SetService( pszService );
        cLicServKey.Open( pszComputer, TRUE );

        // load or set defaults
        //
        if (ERROR_SUCCESS != cLicServKey.GetMode( pServ->lm ))
        {
            pServ->lm = LICMODE_UNDEFINED;
        }

        if (ERROR_SUCCESS != cLicServKey.GetUserLimit( pServ->dwLimit ))
        {
            pServ->dwLimit = PERSERVER_LIMITDEFAULT;
        }

        //
        // get, set DisplayName
        //
        lrt = cLicServKey.GetDisplayName( NULL, cchSize );
        if (ERROR_SUCCESS == lrt)
        {
            pServ->pszDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if (pServ->pszDisplayName == NULL)
            {
                goto ErrorCleanup;
            }
            lrt = cLicServKey.GetDisplayName( pServ->pszDisplayName, cchSize );
        }

        // the GetDisplayName may fail in both the two cases above
        //
        if (ERROR_SUCCESS != lrt)
        {
            GlobalFree( (HGLOBAL)pServ->pszDisplayName );
            cchSize = lstrlen( pszDisplayName ) + 1;
            pServ->pszDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if (pServ->pszDisplayName == NULL)
            {
                goto ErrorCleanup;
            }
            lstrcpy( pServ->pszDisplayName, pszDisplayName );
            cLicServKey.SetDisplayName( pServ->pszDisplayName );
            pServ->fIsNewProduct = TRUE;
        }
        else
        {
            pServ->fIsNewProduct = FALSE;
        }

        //
        // get, set FamilyDisplayName
        //
        lrt = cLicServKey.GetFamilyDisplayName( NULL, cchSize );
        if (ERROR_SUCCESS == lrt)
        {
            pServ->pszFamilyDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if ( pServ->pszFamilyDisplayName == NULL )
            {
                goto ErrorCleanup;
            }
            lrt = cLicServKey.GetFamilyDisplayName( pServ->pszFamilyDisplayName, cchSize );
        }

        // the GetFamilyDisplayName may fail in both the two cases above
        //
        if (ERROR_SUCCESS != lrt)
        {
            GlobalFree( (HGLOBAL)pServ->pszFamilyDisplayName );
            cchSize = lstrlen( pszFamilyDisplayName ) + 1;
            pServ->pszFamilyDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );

            if ( pServ->pszFamilyDisplayName == NULL )
            {
                goto ErrorCleanup;
            }
            lstrcpy( pServ->pszFamilyDisplayName, pszFamilyDisplayName );
        }

        cchSize = lstrlen( pszService ) + 1;
        pServ->pszService = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
        if (pServ->pszService == NULL)
        {
            goto ErrorCleanup;
        }
        lstrcpy( pServ->pszService, pszService );

        cLicServKey.Close();

        if ( NULL == pszComputer )
        {
            pServ->pszComputer = NULL;
        }
        else
        {
            pServ->pszComputer = (LPWSTR)GlobalAlloc( GPTR, sizeof( WCHAR ) * ( 1 + lstrlen( pszComputer ) ) );
            if (pServ->pszComputer == NULL)
            {
                goto ErrorCleanup;
            }
            lstrcpy( pServ->pszComputer, pszComputer );
        }
    }
    return( pServ );

ErrorCleanup:

    
    if (pServ) // JonN 5/15/00: PREFIX 112116-112119
    {
        if (pServ->pszDisplayName)
            GlobalFree( (HGLOBAL)pServ->pszDisplayName );
        if (pServ->pszFamilyDisplayName)
            GlobalFree( (HGLOBAL)pServ->pszFamilyDisplayName );
        if (pServ->pszService)
            GlobalFree( (HGLOBAL)pServ->pszService );
        if (pServ->pszComputer)
            GlobalFree( (HGLOBAL)pServ->pszComputer );
        GlobalFree( (HGLOBAL)pServ );
    }
    return ( (PSERVICEENTRY)NULL );
}

//-------------------------------------------------------------------
//
//  Function: SaveServiceToReg
//
//  Summary;
//      Save the given Service structure to the registry
//
//  Arguments;
//      pServ [in] - Service structure to save
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void SaveServiceToReg( LPCWSTR pszComputer, PSERVICEENTRY pServ )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;

    cLicServKey.SetService( pServ->pszService );
    cLicServKey.Open( pszComputer );
    
    //
    // if no mode in the registry, set to current selected mode
    //
    if (ERROR_SUCCESS != cLicServKey.GetMode( lm ))
    {
        lm = pServ->lm;
    }
    //
    // if a mode change was made or perseat mode selected,
    // set the change flag so that user is warned on any change
    //
    if ((pServ->lm != lm) ||
        (LICMODE_PERSEAT == pServ->lm) )
    {
        cLicServKey.SetChangeFlag( TRUE );
    }
    else
    {
        // this will not modify change flag if it is
        // present, but will set it to false if it is not
        // present
        cLicServKey.CanChangeMode();
    }

    DWORD dwLimitInReg;

    // user limit should be set by CCFAPI32; set only if it's absent
    if ( ERROR_SUCCESS != cLicServKey.GetUserLimit( dwLimitInReg ) )
    {
       cLicServKey.SetUserLimit( pServ->dwLimit );
    }

    cLicServKey.SetDisplayName( pServ->pszDisplayName );
    cLicServKey.SetFamilyDisplayName( pServ->pszFamilyDisplayName );
    cLicServKey.SetMode( pServ->lm );

    cLicServKey.Close();
}

//-------------------------------------------------------------------
//
//  Function: ServiceLicAgreement
//
//  Summary;
//      Check the given Service structure for violation
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog to use to raise legal voilation dialog
//      pServ [in] - Service structure to check
//      pszComputer [in] - computer to work with
//      pszHelpFile [in] - helpfile for dialogs help button
//      pszPerSeatHelpContext [in] - helpcontext for PerSeat dialog help button
//      pszPerServerHelpContext [in] - helpcontext for PerServer dialog help button
//
//  Return: FALSE if agreement was not acceptable
//          TRUE if agreement was accepted
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL ServiceLicAgreement( HWND hwndDlg, 
        PSERVICEENTRY pServ,
        LPCWSTR pszComputer, 
        LPCWSTR pszHelpFile, 
        DWORD dwPerSeatHelpContext,
        DWORD dwPerServerHelpContext )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;
    DWORD dwLimit = pServ->dwLimit;
    BOOL frt = TRUE;
    BOOL fRaiseAgreement = TRUE;

    cLicServKey.SetService( pServ->pszService );
    if (ERROR_SUCCESS == cLicServKey.Open( pszComputer, FALSE ))
    {
        
        cLicServKey.GetMode( lm );
        cLicServKey.GetUserLimit( dwLimit );
    
        // check for changes
        if ( !( pServ->lm != lm ||
                (LICMODE_PERSERVER == pServ->lm && 
                 dwLimit != pServ->dwLimit) ) )
        {
            fRaiseAgreement = FALSE;
        }
        cLicServKey.Close();
    }

    if (fRaiseAgreement)
    {
        if (LICMODE_PERSEAT == pServ->lm)
        {
            frt = PerSeatAgreementDialog( hwndDlg, 
                    pServ->pszDisplayName,
                    pszHelpFile,
                    dwPerSeatHelpContext );
        }
        else
        {   
            // special case FilePrint and zero concurrent users
            //
            if ( 0 == lstrcmp( pServ->pszService, FILEPRINT_SERVICE_REG_KEY ) &&
                    (0 == pServ->dwLimit))
            {
                frt = ServerAppAgreementDialog( hwndDlg, 
                        pszHelpFile,
                        LICCPA_HELPCONTEXTSERVERAPP );
            }
            else
            {
                // find the limit has changed but was this invoked
                // by adding more licenses if so the user was already warned

                if( !g_fWarned )
                {
                    frt = PerServerAgreementDialog( hwndDlg, 
                            pServ->pszDisplayName,
                            dwLimit , //pServ->dwLimit,
                            pszHelpFile,
                            dwPerServerHelpContext );
                }
            }
        }   
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: ServiceViolation
//
//  Summary;
//      Check the given Service structure for violation
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog to use to raise legal voilation dialog
//      pszComputer [in] - the name of the computer to work on
//      pServ [in] - Service structure to check
//
//
//  Return: FALSE if violation not made 
//          TRUE if violation was made
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL ServiceViolation( HWND hwndDlg, LPCWSTR pszComputer, PSERVICEENTRY pServ )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;
    DWORD dwLimit;
    BOOL frt = FALSE;
    
    cLicServKey.SetService( pServ->pszService );
    if (ERROR_SUCCESS == cLicServKey.Open( pszComputer, FALSE ))
    {
        cLicServKey.GetMode( lm );
    
        // check for changes
        if ( (pServ->lm != lm) && !cLicServKey.CanChangeMode() )
        {
            frt = LicViolationDialog( hwndDlg );    
        }
        cLicServKey.Close();
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: EditInvalidDlg
//
//  Summary;
//      Display Dialog when user count edit control value is invalid
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void EditInvalidDlg( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);
    WCHAR szTitle[TEMPSTR_SIZE];
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    MessageBeep( MB_VALUELIMIT );
    
    LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_INVALIDUSERCOUNT, szTemp, LTEMPSTR_SIZE);
    wsprintf( szText, szTemp, PERSERVER_MIN, PERSERVER_MAX );
    MessageBox( hwndDlg, szText, szTitle, MB_OK | MB_ICONINFORMATION );
    
    // also set focus to edit and select all
    SetFocus( hwndCount );
    SendMessage( hwndCount, EM_SETSEL, 0, -1 );
}

//-------------------------------------------------------------------
//
//  Function: EditValidate
//
//  Summary;
//      Handle when the value within the user count edit control changes
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pserv [in]  - currently selected service
//
//  Return: FALSE if Edit Value is not valid, TRUE if it is
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL EditValidate( HWND hwndDlg, PSERVICEENTRY pServ )
{
    BOOL fTranslated;
    UINT nValue;
    BOOL fValid = TRUE;

    // only do this if in PerServer mode
    //
    if (LICMODE_PERSERVER == pServ->lm)
    {
        fValid = FALSE;
        nValue = GetDlgItemInt( hwndDlg, IDC_USERCOUNT, &fTranslated, FALSE );  

        if (fTranslated)
        {
            if (VALIDUSERCOUNT( nValue))
            {
                pServ->dwLimit = nValue;
                fValid = TRUE;
            }
        }
    }
    return( fValid );
}

//-------------------------------------------------------------------
//
//  Function: OnEditChange
//
//  Summary;
//      Handle when the value within the user count edit control changes
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pserv [in]  - currently selected service
//
//  History;
//      Mar-06-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnEditChange( HWND hwndDlg, HWND hwndCount, PSERVICEENTRY pServ )
{
    BOOL fTranslated;
    UINT nValue;
    BOOL fValid = TRUE;
    BOOL fModified = FALSE;

    // only do this if in PerServer mode
    //
    if (LICMODE_PERSERVER == pServ->lm)
    {
        fValid = FALSE;
        nValue = GetDlgItemInt( hwndDlg, IDC_USERCOUNT, &fTranslated, FALSE );  

        if (fTranslated)
        {
#pragma warning(push)
#pragma warning(disable: 4296) // C4296: '>' : expression is always false
            if (PERSERVER_MIN > nValue)
            {
                nValue = PERSERVER_MIN;
                fModified = TRUE;
            }
            else if (PERSERVER_MAX < nValue)
            {
                nValue = PERSERVER_MAX;
                fModified = TRUE;
            }
#pragma warning(pop)

            pServ->dwLimit = nValue;
        }
        else
        {
            // reset to last value
            nValue = pServ->dwLimit;
            fModified = TRUE;
        }

        if (fModified)
        {
            SetDlgItemInt( hwndDlg, IDC_USERCOUNT, nValue, FALSE );
            SetFocus( hwndCount );
            SendMessage( hwndCount, EM_SETSEL, 0, -1 );
            MessageBeep( MB_VALUELIMIT );
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: OnCpaClose
//
//  Summary;
//      Do work needed when the Control Panel applet is closed.
//      Free all Service structures alloced and possible save.
//
//  Arguments;
//      hwndDlg [in] - Dialog close was requested on
//      fSave [in] - Save Services to Registry
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnCpaClose( HWND hwndDlg, BOOL fSave )
{
    WCHAR szText[TEMPSTR_SIZE];
    HWND hwndService = GetDlgItem( hwndDlg, IDC_SERVICES);
    LRESULT cItems = SendMessage( hwndService, CB_GETCOUNT, 0, 0 ) - 1;
    LONG_PTR iItem;
    PSERVICEENTRY pServ;
    LRESULT iSel;

    iSel  = SendMessage( hwndService, CB_GETCURSEL, 0, 0 );
    pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iSel, 0 ); 

    if ( fSave &&
         (pServ->lm == LICMODE_PERSERVER) &&
         !EditValidate( hwndDlg, pServ ) )
    {
        EditInvalidDlg( hwndDlg );
    }
    else
    {
        BOOL fCompleted = TRUE;
        // loop and check for agreement changes (only needed if saving)
        //
        if (fSave)
        {
            for (iItem = cItems; iItem >= 0; iItem--)
            {   
                pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iItem, 0 );    
                if (ServiceLicAgreement( hwndDlg, 
                        pServ,
                        NULL,
                        LICCPA_HELPFILE,
                        LICCPA_HELPCONTEXTPERSEAT,
                        LICCPA_HELPCONTEXTPERSERVER ))
                {
                    SaveServiceToReg( NULL, pServ );
                }
                else
                {
                    fCompleted = FALSE; 
                    break;
                }
            }
        }

        if (fCompleted)
        {
            // loop and free service entries
            //
            for (iItem = cItems; iItem >= 0; iItem--)
            {   
                pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iItem, 0 );    
                FreeServiceEntry( pServ );
            }
            EndDialog( hwndDlg, fSave );
        }
        else
        {
            // set combo box to last canceled entry
            SendMessage( hwndService, CB_SETCURSEL, iItem, 0 );
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: OnSetupClose
//
//  Summary;
//      Do work needed when the Setup Dialog is closed.
//      Free the service structure and possible save it
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog this close was requested on
//      fSave [in] - Save service to registry
//      pServ [in] - the service structure to work with
//      psdParams [in] - setup dlg params for help contexts and files
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSetupClose( HWND hwndDlg, 
        BOOL fSave, 
        PSERVICEENTRY pServ,
        PSETUPDLGPARAM psdParams )
{
    if ( fSave &&
         (pServ->lm == LICMODE_PERSERVER) &&
         !EditValidate( hwndDlg, pServ ) )
    {
        EditInvalidDlg( hwndDlg );
    }
    else
    {
        BOOL fCompleted = TRUE;

        if (fSave)
        {
            if (ServiceLicAgreement( hwndDlg, 
                    pServ,
                    psdParams->pszComputer,
                    psdParams->pszHelpFile,
                    psdParams->dwHCPerSeat,
                    psdParams->dwHCPerServer ))
            {
                SaveServiceToReg( psdParams->pszComputer, pServ );

                // register service at enterprise server
                ServiceRegister( psdParams->pszComputer,
                                 psdParams->pszFamilyDisplayName,
                                 psdParams->pszDisplayName );
            }
            else
            {
                fCompleted = FALSE;
            }
        }
        else if ( pServ->fIsNewProduct )
        {
            // new product, but we're aborting
            // make sure we don't leave any scraps behind
            DWORD winError;
            HKEY  hkeyInfo;

            winError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" ),
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hkeyInfo );

            if ( ERROR_SUCCESS == winError )
            {
                RegDeleteKey( hkeyInfo, pServ->pszService );
                RegCloseKey( hkeyInfo );
            }
        }

        if (fCompleted)
        {
            FreeServiceEntry( pServ );
            EndDialog( hwndDlg, fSave );
        }
    }
}


//-------------------------------------------------------------------
//
//  Function: OnSetServiceMode
//
//  Summary;
//      Handle the users request to change service mode
//
//  Aruments;
//      hwndDlg [in] - hwnd of dialog
//      pszComputer [in] - compter to confirm mode change against
//      pServ [in] - The service the request was made agianst
//      idCtrl [in] - the control id that was pressed to make this request
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSetServiceMode( HWND hwndDlg, LPCWSTR pszComputer, PSERVICEENTRY pServ, WORD idCtrl )
{
    LICENSE_MODE lmOld = pServ->lm;
    BOOL fChanged = FALSE;

    if (idCtrl == IDC_PERSEAT)
    {
        fChanged = (pServ->lm != LICMODE_PERSEAT);
        pServ->lm = LICMODE_PERSEAT;
    }
    else
    {
        fChanged = (pServ->lm != LICMODE_PERSERVER);
        pServ->lm = LICMODE_PERSERVER;
    }

    //
    // only check for violation the first time the user switches
    //
    if (fChanged && ServiceViolation( hwndDlg, pszComputer, pServ ))
    {
        pServ->lm = lmOld;
        InitDialogForService( hwndDlg, pServ );
    
    }
    
    
}

//-------------------------------------------------------------------
//
//  Function: OnSpinButton
//
//  Summary;
//      Handle the events from user interactions with the spin control
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      wAction [in] - spin control event
//      pServ [in] - current service selected
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpinButton( HWND hwndDlg, WORD wAction, PSERVICEENTRY pServ )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);
    INT  nValue;
    BOOL fValidAction = TRUE;

    nValue = pServ->dwLimit;

    switch (wAction)
    {
    case SB_LINEUP:
        nValue++;
        break;

    case SB_LINEDOWN:
        nValue--;
        break;

    case SB_PAGEUP:
        nValue += PERSERVER_PAGE;
        break;

    case SB_PAGEDOWN:
        nValue -= PERSERVER_PAGE;
        break;

    case SB_TOP:
        nValue = PERSERVER_MAX;
        break;

    case SB_BOTTOM:
        nValue = PERSERVER_MIN;
        break;

    default:
        fValidAction = FALSE;
        break;
    }
    if (fValidAction)
    {
        nValue = max( PERSERVER_MIN, nValue );
        nValue = min( PERSERVER_MAX, nValue );

        if (pServ->dwLimit == (DWORD)nValue)
        {
            MessageBeep( MB_VALUELIMIT );
        }
        else
        {
            pServ->dwLimit = nValue;
            SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
        }
        SetFocus( hwndCount );
        SendMessage( hwndCount, EM_SETSEL, 0, -1 );
    }
}

//-------------------------------------------------------------------
//
//  Function: UpdatePerServerLicenses
//
//  Summary;
//      Update the number of per server licenses displayed in the
//      dialog with the proper value.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

static void UpdatePerServerLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LLS_HANDLE  hLls;
   DWORD       dwError;
   BOOL        fIsSecure;
   BOOL        fUseRegistry;

   fUseRegistry = TRUE;

   dwError = LlsConnect( pServ->pszComputer, &hLls );

   if ( ERROR_SUCCESS == dwError )
   {
      if ( pServ->fIsNewProduct )
      {
         dwError = LlsProductSecurityGet( hLls, pServ->pszDisplayName, &fIsSecure );

         if (    ( ERROR_SUCCESS == dwError )
              && fIsSecure                    )
         {
            dwError = LlsProductLicensesGet( hLls, pServ->pszDisplayName, LLS_LICENSE_MODE_PER_SERVER, &pServ->dwLimit );

            if ( ERROR_SUCCESS == dwError )
            {
               fUseRegistry = FALSE;
            }
         }
      }
      else
      {
         dwError = LlsProductLicensesGet( hLls, pServ->pszDisplayName, LLS_LICENSE_MODE_PER_SERVER, &pServ->dwLimit );

         if ( ERROR_SUCCESS == dwError )
         {
            fUseRegistry = FALSE;
         }
      }

      LlsClose( hLls );
   }

   if ( fUseRegistry )
   {
      CLicRegLicenseService cLicServKey;

      cLicServKey.SetService( pServ->pszService );
      cLicServKey.Open( NULL, FALSE );

      cLicServKey.GetUserLimit( pServ->dwLimit );

      cLicServKey.Close();
   }

   SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
   UpdateWindow( hwndDlg );
}

//-------------------------------------------------------------------
//
//  Function: OnAddLicenses
//
//  Summary;
//      Handle the BN_CLICKED message from the Add Licenses button.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

void OnAddLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LPSTR    pszAscProductName;
   LPSTR    pszAscServerName = NULL;
   CHAR     szAscServerName[ 3 + MAX_PATH ];

   pszAscProductName = (LPSTR) LocalAlloc( LPTR, 1 + lstrlen(pServ->pszDisplayName) );

   if ( NULL != pszAscProductName )
   {
      wsprintfA( pszAscProductName, "%ls", pServ->pszDisplayName );
      if ( NULL != pServ->pszComputer )
      {
         wsprintfA( szAscServerName, "%ls", pServ->pszComputer );
         pszAscServerName = szAscServerName;
      }

      CCFCertificateEnterUI( hwndDlg, pszAscServerName, pszAscProductName, "Microsoft", CCF_ENTER_FLAG_PER_SERVER_ONLY, NULL );
      UpdatePerServerLicenses( hwndDlg, pServ );

      LocalFree( pszAscProductName );

      g_fWarned = TRUE;
   }
}

//-------------------------------------------------------------------
//
//  Function: OnRemoveLicenses
//
//  Summary;
//      Handle the BN_CLICKED message from the Remove Licenses button.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

void OnRemoveLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LPSTR    pszAscProductName;
   LPSTR    pszAscServerName = NULL;
   CHAR     szAscServerName[ 3 + MAX_PATH ];

   pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen(pServ->pszDisplayName) );

   if ( NULL != pszAscProductName )
   {
      wsprintfA( pszAscProductName, "%ls", pServ->pszDisplayName );
      if ( NULL != pServ->pszComputer )
      {
         wsprintfA( szAscServerName, "%ls", pServ->pszComputer );
         pszAscServerName = szAscServerName;
      }

      CCFCertificateRemoveUI( hwndDlg, pszAscServerName, pszAscProductName, "Microsoft", NULL, NULL );
      UpdatePerServerLicenses( hwndDlg, pServ );

      LocalFree( pszAscProductName );
   }
}


//-------------------------------------------------------------------
//
//  Function: OnSetupInitDialog
//
//  Summary;
//      Handle the initialization of the Setup Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      pszParams [in] - the dialog params to use to initialize
//      pServ [out] - the current service 
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------

BOOL OnSetupInitDialog( HWND hwndDlg, 
        PSETUPDLGPARAM psdParams, 
        PSERVICEENTRY& pServ )
{
    BOOL frt = TRUE;
    CLicRegLicense cLicKey;
    LONG lrt;
    INT  nrt;
    BOOL fNew;

    do
    {
        CenterDialogToScreen( hwndDlg );

        lrt = cLicKey.Open( fNew, psdParams->pszComputer );
        nrt = AccessOk( hwndDlg, lrt, FALSE );
        if (ERR_NONE != nrt)
        {
            EndDialog( hwndDlg, nrt );
            frt = FALSE;
            break;
        }

        pServ = CreateServiceEntry( psdParams->pszComputer,
                psdParams->pszService, 
                psdParams->pszFamilyDisplayName,
                psdParams->pszDisplayName );
        if (pServ == NULL)
        {
            LowMemoryDlg();
            EndDialog( hwndDlg, -2 );
            break;
        }
        if (NULL == psdParams->pszHelpFile)
        {
            HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );
            // remove the help button
            EnableWindow( hwndHelp, FALSE );
            ShowWindow( hwndHelp, SW_HIDE );
        }
        if (psdParams->fNoExit)
        {
            HWND hwndExit = GetDlgItem( hwndDlg, IDCANCEL );
            // remove the ExitSetup button
            EnableWindow( hwndExit, FALSE );
            ShowWindow( hwndExit, SW_HIDE );
        }

        // set char limit on edit box
        InitUserEdit( hwndDlg );

        // make sure title static text is set for this service
        InitTitleText( hwndDlg, pServ );
        
        // defaul to PerServer with Focus on edit
        pServ->lm = LICMODE_PERSERVER;

        // change default for setup only
        // pServ->dwLimit = 1;

        InitDialogForService( hwndDlg, pServ );

        SetFocus( GetDlgItem( hwndDlg, IDC_PERSERVER ) );
    } while (FALSE); // used to remove gotos

    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: OnCpaInitDialog
//
//  Summary;
//      Handle the initialization of the Control Panel Applet Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      fEnableReplication [in] -
//      iSel [out] - the current service selected
//      pServ [out] - the current service 
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Added removal of Replication button
//
//-------------------------------------------------------------------

BOOL OnCpaInitDialog( HWND hwndDlg, 
        BOOL fEnableReplication,
        LONG_PTR& iSel, 
        PSERVICEENTRY& pServ )
{
    BOOL frt = FALSE;
    CLicRegLicense cLicKey;
    LONG lrt;
    INT  nrt;
    BOOL fNew;

    lrt = cLicKey.Open( fNew );
    nrt = AccessOk( hwndDlg, lrt, TRUE );
    if (ERR_NONE == nrt)
    {
        DWORD i = 0;
        WCHAR szText[TEMPSTR_SIZE];
        DWORD cchText = TEMPSTR_SIZE;
        HWND hwndService =  GetDlgItem( hwndDlg, IDC_SERVICES);
        LONG_PTR lIndex;

        CenterDialogToScreen( hwndDlg );

        //
        // remove replication button if product used on pre 3.51
        //
        if (!fEnableReplication)
        {
            HWND hwndRep =  GetDlgItem( hwndDlg, IDC_CONFIGURE );

            EnableWindow( hwndRep, FALSE );
            ShowWindow( hwndRep, SW_HIDE );
        }

        // load the service names from the registry into combo box
        // Create service local state structures as we go
        //
        while (ERROR_SUCCESS == cLicKey.EnumService(i, szText, cchText ))
        {

            pServ = CreateServiceEntry( NULL, szText, L"<unknown>", L"<undefined>" );
            if (pServ == NULL)
            {
                LowMemoryDlg();
                EndDialog( hwndDlg, -2 );
                return( TRUE );
            }
            lIndex = SendMessage( hwndService, CB_ADDSTRING, 0, (LPARAM)pServ->pszDisplayName );
            SendMessage( hwndService, CB_SETITEMDATA, lIndex, (LPARAM)pServ );
            i++;
            cchText = TEMPSTR_SIZE;
        }
        cLicKey.Close();

        if (0 == i)
        {
            // no services installed
            //
            WCHAR szText[TEMPSTR_SIZE];
            WCHAR szTitle[TEMPSTR_SIZE];

            LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
            LoadString(g_hinst, IDS_NOSERVICES, szText, TEMPSTR_SIZE);
            MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
    
            frt = FALSE;
        }
        else
        {
            // make sure a service is selected and update dialog
            iSel  = SendMessage( hwndService, CB_GETCURSEL, 0, 0 );

            if (CB_ERR == iSel)
            {
                iSel = 0;                 
                SendMessage( hwndService, CB_SETCURSEL, iSel, 0 );
            }
            pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iSel, 0 );

            // Set edit text chars limit
            InitUserEdit( hwndDlg );

            InitDialogForService( hwndDlg, pServ );
            frt = TRUE;
        }
    }
    if (!frt)
    {
        EndDialog( hwndDlg, -1 );
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocLICCPA
//
//  Summary;
//      The dialog procedure for the main Control Panel Applet Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Added removal of Replication button 
//                              from WM_INITDIALOG
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocLICCPA( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSERVICEENTRY pServ = NULL;
    static LONG_PTR iSel = 0;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        OnCpaInitDialog( hwndDlg, (BOOL)lParam , iSel, pServ );
        return( TRUE ); // use default keyboard focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnCpaClose( hwndDlg, frt );
                frt = FALSE;
                break;

            case IDC_PERSEAT:
            case IDC_PERSERVER:
                OnSetServiceMode( hwndDlg, NULL, pServ, LOWORD(wParam) );
                break;

            case IDC_CONFIGURE:
                DialogBox(g_hinst, 
                        MAKEINTRESOURCE(IDD_CPADLG_LCACONF),
                        hwndDlg, 
                        (DLGPROC)dlgprocLICCPACONFIG );
                break;
            
            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_ADD_LICENSES:
                OnAddLicenses( hwndDlg, pServ );
                break;

            case IDC_REMOVE_LICENSES:
                OnRemoveLicenses( hwndDlg, pServ );
                break;

            default:
                break;
            }
            break;

        case CBN_SELENDOK:
            if ((LICMODE_PERSERVER == pServ->lm) &&
                !EditValidate( hwndDlg, pServ ))
            {
                // reset back to original
                SendMessage( (HWND)lParam, CB_SETCURSEL, iSel, 0 );
                EditInvalidDlg( hwndDlg );
            }
            else
            {
                iSel  = SendMessage( (HWND)lParam, CB_GETCURSEL, 0, 0 );
                pServ = (PSERVICEENTRY)SendMessage( (HWND)lParam, CB_GETITEMDATA, iSel, 0 );
                InitDialogForService( hwndDlg, pServ );
            }
            break;

        case EN_UPDATE:
            if (IDC_USERCOUNT == LOWORD(wParam))
            {
                OnEditChange( hwndDlg, (HWND)(lParam),  pServ );
            }
            break;

        default:
            break;
        }
        break;
    case WM_VSCROLL:
        OnSpinButton( hwndDlg, LOWORD( wParam ), pServ );
        break;
   
    default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//
//  Function: dlgprocLICSETUP
//
//  Summary;
//      The dialog procedure for the Setup entry point Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocLICSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSERVICEENTRY pServ;
    static PSETUPDLGPARAM psdParams;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        psdParams = (PSETUPDLGPARAM)lParam;
        OnSetupInitDialog( hwndDlg, psdParams, pServ );
        frt = FALSE; // we set the focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnSetupClose( hwndDlg, frt, pServ, psdParams );
                frt = FALSE;
                break;

            case IDC_PERSEAT:
            case IDC_PERSERVER:
                OnSetServiceMode( hwndDlg, psdParams->pszComputer, pServ, LOWORD(wParam) );
                break;

            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_ADD_LICENSES:
                OnAddLicenses( hwndDlg, pServ );
                break;

            case IDC_REMOVE_LICENSES:
                OnRemoveLicenses( hwndDlg, pServ );
                break;

            default:
                break;
            }
            break;

        case EN_UPDATE:
            if (IDC_USERCOUNT == LOWORD(wParam))
            {
                OnEditChange( hwndDlg, (HWND)(lParam),  pServ );
            }
            break;

        default:
            break;
        }
        break;

    case WM_VSCROLL:
        OnSpinButton( hwndDlg, LOWORD( wParam ), pServ );
        break;

    default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//
//  Function: OnPerSeatInitDialog
//
//  Summary;
//      Handle the initialization of the PerSeat only Setup Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      psdParams [in] - used for the displayname and service name
//
//  Notes;
//
//  History;
//      Dec-08-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatInitDialog( HWND hwndDlg, PSETUPDLGPARAM psdParams )
{
    HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
    CLicRegLicense cLicKey;
    BOOL fNew;
    LONG lrt;
    INT nrt;

    lrt = cLicKey.Open( fNew, psdParams->pszComputer );
    nrt = AccessOk( NULL, lrt, FALSE );
    if (ERR_NONE == nrt)
    {
        CenterDialogToScreen( hwndDlg );

        InitStaticWithService( hwndDlg, IDC_STATICTITLE, psdParams->pszDisplayName );
        InitStaticWithService2( hwndDlg, IDC_STATICINFO, psdParams->pszDisplayName );

        // disable OK button at start!
        EnableWindow( hwndOK, FALSE );

        // if help is not defined, remove the button
        if (NULL == psdParams->pszHelpFile)
        {
            HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

            EnableWindow( hwndHelp, FALSE );
            ShowWindow( hwndHelp, SW_HIDE );
        }
     }
     else
     {
        EndDialog( hwndDlg, nrt );
     }
}

//-------------------------------------------------------------------
//
//  Function: OnPerSeatSetupClose
//
//  Summary;
//      Do work needed when the Setup Dialog is closed.
//      Save to Reg the Service entry.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog this close was requested on
//      fSave [in] - Save service to registry
//      psdParams [in] - used for the service name and displayname
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatSetupClose( HWND hwndDlg, BOOL fSave, PSETUPDLGPARAM psdParams ) 
{
    int nrt = fSave;

    if (fSave)
    {
        CLicRegLicenseService cLicServKey;

        cLicServKey.SetService( psdParams->pszService );
        cLicServKey.Open( psdParams->pszComputer );

        // configure license rule of one change from PerServer to PerSeat
        //
        cLicServKey.SetChangeFlag( TRUE );

        cLicServKey.SetUserLimit( 0 );
        cLicServKey.SetDisplayName( psdParams->pszDisplayName );
        cLicServKey.SetFamilyDisplayName( psdParams->pszFamilyDisplayName );
        cLicServKey.SetMode( LICMODE_PERSEAT );
        cLicServKey.Close();

        // register service at enterprise server
        ServiceRegister( psdParams->pszComputer,
                         psdParams->pszFamilyDisplayName,
                         psdParams->pszDisplayName );
    }

    EndDialog( hwndDlg, nrt );
}

//-------------------------------------------------------------------
//
//  Function: OnPerSeatAgree
//
//  Summary;
//      Handle the user interaction with the Agree Check box
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatAgree( HWND hwndDlg )
{
    HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
    BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
    
    CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
    EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocPERSEATSETUP
//
//  Summary;
//      The dialog procedure for the PerSeat only Setup Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocPERSEATSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSETUPDLGPARAM psdParams;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        psdParams = (PSETUPDLGPARAM)lParam;
        OnPerSeatInitDialog( hwndDlg, psdParams );
        frt = TRUE; // we use the default focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnPerSeatSetupClose( hwndDlg, frt, psdParams );
                frt = FALSE;
                break;

            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_AGREE:
                OnPerSeatAgree( hwndDlg );
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: SetupDialog
//
//  Summary;
//      Init and raises main setup dialog.
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      dlgParem [in]   - Setup params
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//     -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR SetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
   INT_PTR nError;

   nError = DialogBoxParam( g_hinst, 
                            MAKEINTRESOURCE(IDD_SETUPDLG), 
                            hwndParent, 
                            (DLGPROC)dlgprocLICSETUP,
                            (LPARAM)&dlgParam );

   return( nError );
} 

//-------------------------------------------------------------------
//
//  Function: PerSeatSetupDialog
//
//  Summary;
//      Init and raises Per Seat only setup dialog.
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      dlgParem [in]   - Setup params
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//     -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR PerSeatSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
    return( DialogBoxParam( g_hinst, 
            MAKEINTRESOURCE(IDD_SETUP2DLG), 
            hwndParent, 
            (DLGPROC)dlgprocPERSEATSETUP,
            (LPARAM)&dlgParam ) );
} 

//-------------------------------------------------------------------
//
//  Function: CpaDialog
//
//  Summary;
//      Init and Raise the main control panel applet dialog
//
//  Arguments;
//      hwndParent [in] - handle of parent window (CONTROL.EXE window)
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//    -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Changed to only one Dialog Resource, Replication Button
//
//-------------------------------------------------------------------

INT_PTR CpaDialog( HWND hwndParent )
{
   INT_PTR nError;
   OSVERSIONINFO version;

   version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx( &version );

   BOOL fReplicationEnabled;

   //
   // Only allow Replication Button on 3.51 and above
   //
   fReplicationEnabled = (    (version.dwMajorVersion > 3)
                           || (version.dwMajorVersion == 3 && version.dwMinorVersion >= 51) );
   nError = DialogBoxParam( g_hinst,
                            MAKEINTRESOURCE(IDD_CPADLG_CONFIGURE),
                            hwndParent,
                            (DLGPROC)dlgprocLICCPA,
                            (LPARAM)fReplicationEnabled );

   return( nError );
}

//-------------------------------------------------------------------
//
//  Function: UpdateReg
//
//  Summary;  
//      This function is used in unatteneded  setup modes, it will 
//      configure the registry with the values passed.
//
//  Arguments;
//      pszComputer [in] - computer name (maybe null for local)
//      pszService [in] - service key name
//      pszFamilyDisplayName [in] - family display name
//      pszDisplayName [in] - displayname
//      lm [in] - license mode
//      dwUsers [in] - number of conncurrent users
//
//  Return;
//     ERR_NONE - Successful
//     ERR_USERSPARAM - invalid users count
//     ERR_PERMISSIONDENIED - invalid access rights
//
//  Notes;
//
//  History;
//      Dec-09-1994 MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

int UpdateReg( LPCWSTR pszComputer, 
        LPCWSTR pszService, 
        LPCWSTR pszFamilyDisplayName, 
        LPCWSTR pszDisplayName, 
        LICENSE_MODE lm, 
        DWORD dwUsers )
{
    int nrt = ERR_NONE;

    if (VALIDUSERCOUNT( dwUsers ))
    {
        CLicRegLicense cLicKey;
        LONG lrt;
        BOOL fNew;

        lrt = cLicKey.Open( fNew, pszComputer );
        nrt = AccessOk( NULL, lrt, FALSE );
        if (ERR_NONE == nrt)
        {
            CLicRegLicenseService cLicServKey;

            cLicServKey.SetService( pszService );
            cLicServKey.Open( pszComputer );

            // configure license rule of one change from PerServer to PerSeat
            //
            cLicServKey.SetChangeFlag( (LICMODE_PERSEAT == lm ) );

            cLicServKey.SetUserLimit( dwUsers );
            cLicServKey.SetDisplayName( pszDisplayName );
            cLicServKey.SetFamilyDisplayName( pszFamilyDisplayName );
            cLicServKey.SetMode( lm );
            cLicServKey.Close();
        }
    }
    else
    {
        nrt = ERR_USERSPARAM;
    }
    return( nrt );
}

//-------------------------------------------------------------------
//
//  Function: ServiceSecuritySet
//
//  Summary;
//      Set security on a given product such that it requires a
//      secure certificate for license entry.
//
//  Arguments;
//      pszComputer [in] - computer on which the license server resides
//      pszDisplayName [in] - display name for the service
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

int ServiceSecuritySet( LPWSTR pszComputer, LPWSTR pszDisplayName )
{
   int            nError;
   NTSTATUS       nt;
   LLS_HANDLE     hLls;

   // register the product as secure on the target server
   nt = LlsConnect( pszComputer, &hLls );

   if ( STATUS_SUCCESS != nt )
   {
      nError = ERR_NOREMOTESERVER;
   }
   else
   {
      if ( !LlsCapabilityIsSupported( hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
      {
         nError = ERR_DOWNLEVEL;
      }
      else
      {
         nt = LlsProductSecuritySetW( hLls, pszDisplayName );

         if ( STATUS_SUCCESS != nt )
         {
            nError = ERR_CERTREQFAILED;
         }
         else
         {
            nError = ERR_NONE;
         }
      }

      LlsClose( hLls );
   }

   // register the product as secure on the enterprise server
   // it is acceptable for this to fail (the enterprise server may
   // be downlevel)
   if ( ERR_NONE == nError )
   {
      PLLS_CONNECT_INFO_0  pConnectInfo = NULL;

      nt = LlsConnectEnterprise( pszComputer, &hLls, 0, (LPBYTE *) &pConnectInfo );

      if ( STATUS_SUCCESS == nt )
      {
         LlsFreeMemory( pConnectInfo );

         if ( LlsCapabilityIsSupported( hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
         {
            LlsProductSecuritySetW( hLls, pszDisplayName );
         }

         LlsClose( hLls );
      }
   }

   return nError;
}

//-------------------------------------------------------------------
//
//  Function: ServiceRegister
//
//  Summary;
//      Register a service at the enterprise server corresponding to
//      the given server so that per seat licenses may be added
//      immediately, rather than it taking up until the next
//      replication cycle for the product to be listed.
//
//  Arguments;
//      pszComputer [in] - computer for which to register the service 
//      pszFamilyDisplayName [in] - family display name of the service
//      pszDisplayName [in] - display name of the service
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

static int ServiceRegister( LPWSTR pszComputer,
                            LPWSTR pszFamilyDisplayName,
                            LPWSTR pszDisplayName )
{
   int                  nError;
   NTSTATUS             nt;
   LLS_HANDLE           hLls;
   PLLS_CONNECT_INFO_0  pConnectInfo = NULL;

   // register the product as secure on the enterprise server
   nt = LlsConnectEnterprise( pszComputer, &hLls, 0, (LPBYTE *) &pConnectInfo );

   if ( STATUS_SUCCESS != nt )
   {
      nError = ERR_NOREMOTESERVER;
   }
   else
   {
      LlsFreeMemory( pConnectInfo );

      nt = LlsProductAdd( hLls, pszFamilyDisplayName, pszDisplayName, TEXT( "" ) );

      LlsClose( hLls );

      if ( STATUS_SUCCESS != nt )
      {
         nError = ERR_NOREMOTESERVER;
      }
      else
      {
         nError = ERR_NONE;
      }
   }

   return nError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\secdlgs.cpp ===
//-------------------------------------------------------------------
//
// FILE: SecDlgs.cpp
//
// Summary;
// 		This file contians the Secondary Dialogs,
//		functions and dialog procs
//
// Entry Points;
//
// History;
//		Nov-30-94	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//
//-------------------------------------------------------------------

#include <windows.h>
#include <htmlhelp.h>
#include "resource.h"
#include "liccpa.hpp"

extern "C"
{
	INT_PTR CALLBACK dlgprocLicViolation( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	INT_PTR CALLBACK dlgprocCommon( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

// used to define dlg initialization using common dlgproc
//
enum DLG_TYPE
{
	DLGTYPE_AGREEMENT_PERSEAT,
  	DLGTYPE_AGREEMENT_PERSERVER,
	DLGTYPE_PERSEATSETUP,
	DLGTYPE_SERVERAPP
};

// used to pass info to a common dlgproc
//
typedef struct tagCOMMONDLGPARAM
{
	LPWSTR	 pszDisplayName;
    DWORD    dwLimit;
	LPWSTR	 pszHelpFile;
	DWORD    dwHelpContext;
	DLG_TYPE dtType;
} COMMONDLGPARAM, *PCOMMONDLGPARAM;

//-------------------------------------------------------------------
//
//  Function: dlgprocLicViolation
//
//  Summary;
//		The dialog procedure for the  Dialog
//
//  Arguments;
//		hwndDlg [in]	- handle of Dialog window
//		uMsg [in]		- message
// 		lParam1 [in]    - first message parameter
//		lParam2 [in]    - second message parameter
//
//  Return;
//		message dependant
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocLicViolation( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	BOOL frt = FALSE;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		CenterDialogToScreen( hwndDlg );
		frt = TRUE; // we use the default focus
		break;

	case WM_COMMAND:
		switch (HIWORD( wParam ))
		{
		case BN_CLICKED:
			switch (LOWORD( wParam ))
			{
			case IDCANCEL:
				frt = TRUE;	 // use as save flag
				// intentional no break

			case IDOK:
			    EndDialog( hwndDlg, frt );
				frt = FALSE;
				break;

			case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
				break;

			default:
				break;
			}
			break;

		default:
			break;
		}
		break;

	default:
		if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
	}
	return( frt );
}

//-------------------------------------------------------------------
//
//  Function: OnCommonInitDialog
//
//  Summary;
//		Handle the initialization of the Common Dialog
//
//  Arguments;
//		hwndDlg [in] - the dialog to initialize
//		pcdParams [in] - used to get displayname, helpfile
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

void OnCommonInitDialog( HWND hwndDlg, PCOMMONDLGPARAM pcdParams )
{
	HWND hwndOK = GetDlgItem( hwndDlg, IDOK );

	CenterDialogToScreen( hwndDlg );

	switch( pcdParams->dtType )
	{
	case DLGTYPE_AGREEMENT_PERSEAT:
		InitStaticWithService2( hwndDlg, IDC_STATICINFO, pcdParams->pszDisplayName );
		break;

    case DLGTYPE_AGREEMENT_PERSERVER:
        {
      	    WCHAR szText[LTEMPSTR_SIZE];
        	WCHAR szTemp[LTEMPSTR_SIZE];

        	GetDlgItemText( hwndDlg, IDC_STATICINFO, szTemp, LTEMPSTR_SIZE );
            //
            // need both service display name and number of conncurrent connections
            //
        	wsprintf( szText, szTemp,
                    pcdParams->dwLimit,
        	        pcdParams->pszDisplayName );
        	SetDlgItemText( hwndDlg, IDC_STATICINFO, szText );
        }

		break;

	case DLGTYPE_PERSEATSETUP:
		InitStaticWithService( hwndDlg, IDC_STATICTITLE, pcdParams->pszDisplayName );
		InitStaticWithService2( hwndDlg, IDC_STATICINFO, pcdParams->pszDisplayName );
		break;

	case DLGTYPE_SERVERAPP:
		break;

	default:
		break;
	}

	// disable OK button at start!
	EnableWindow( hwndOK, FALSE );

	// if help is not defined, remove the button
	if (NULL == pcdParams->pszHelpFile)
	{
		HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

		EnableWindow( hwndHelp, FALSE );
		ShowWindow( hwndHelp, SW_HIDE );
	}
}

//-------------------------------------------------------------------
//
//  Function: OnCommonAgree
//
//  Summary;
//		Handle user interaction with Agree check box
//
//  Arguments;
//		hwndDlg [in] - the dialog that contains the check box
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

void OnCommonAgree( HWND hwndDlg )
{
	HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
	BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
	
	CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
	EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocCommon
//
//  Summary;
//		The dialog procedure for the Common legal Dialogs
//
//  Arguments;
//		hwndDlg [in]	- handle of Dialog window
//		uMsg [in]		- message
// 		lParam1 [in]    - first message parameter
//		lParam2 [in]    - second message parameter
//
//  Return;
//		message dependant
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocCommon( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	BOOL frt = FALSE;
	static PCOMMONDLGPARAM pcdParams;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		pcdParams = (PCOMMONDLGPARAM)lParam;
		OnCommonInitDialog( hwndDlg, pcdParams );
		frt = TRUE; // we use the default focus
		break;

	case WM_COMMAND:
		switch (HIWORD( wParam ))
		{
		case BN_CLICKED:
			switch (LOWORD( wParam ))
			{
			case IDOK:
				frt = TRUE;	 // use as save flag
				// intentional no break

			case IDCANCEL:
			    EndDialog( hwndDlg, frt );
				frt = FALSE;
				break;

			case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
				break;

			case IDC_AGREE:
				OnCommonAgree( hwndDlg );
				break;

			default:
				break;
			}
			break;

		default:
			break;
		}
		break;

	default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
	}
	return( frt );
}

//-------------------------------------------------------------------
//
//  Function: LicviolationDialog
//
//  Summary;
//		Init and Raise the license Violation dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//
//  Return;
//		1 - use OK operation, NO was pressed to exit
//		0 - use Cancel operation, YES was pressed to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int LicViolationDialog( HWND hwndParent )
{
	return( (int)DialogBox(g_hinst,
    			MAKEINTRESOURCE(IDD_LICVIOLATIONDLG),
    			hwndParent,
    			dlgprocLicViolation ) );
}

//-------------------------------------------------------------------
//
//  Function: SetupPerOnlyDialog
//
//  Summary;
//		Init and Raise the setup for per seat only  dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int SetupPerOnlyDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_PERSEATSETUP;
	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_SETUP2DLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam) );
}

//-------------------------------------------------------------------
//
//  Function: PerServerAgreementDialog
//
//  Summary;
//		Init and Raise the per server legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//      dwLimit [in] - the number of concurrent connections
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int PerServerAgreementDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
        DWORD dwLimit,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
    dlgParam.dwLimit = dwLimit;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_AGREEMENT_PERSERVER;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_PERSERVERDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}

//-------------------------------------------------------------------
//
//  Function: PerSeatAgreementDialog
//
//  Summary;
//		Init and Raise the per seat legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int PerSeatAgreementDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;
	
	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_AGREEMENT_PERSEAT;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_PERSEATDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}

//-------------------------------------------------------------------
//
//  Function: ServerAppAgreementDialog
//
//  Summary;
//		Init and Raise the Server and App legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int ServerAppAgreementDialog( HWND hwndParent,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = NULL;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_SERVERAPP;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_SERVERAPPDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=  net
MINORCOMP=  ui

TARGETNAME= liccpa
TARGETPATH= obj
TARGETTYPE= DYNLINK
TARGETEXT=  cpl

DLLENTRY=   _DllMainCRTStartup

TARGETLIBS= $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\gdi32.lib    \
            $(SDK_LIB_PATH)\comdlg32.lib \
            $(SDK_LIB_PATH)\comctl32.lib \
            $(SDK_LIB_PATH)\shell32.lib  \
            $(SDK_LIB_PATH)\version.lib  \
            $(SDK_LIB_PATH)\ntdll.lib    \
            $(SDK_LIB_PATH)\netapi32.lib \
            $(SDK_LIB_PATH)\llsrpc.lib   \
            $(SDK_LIB_PATH)\htmlhelp.lib   \
            $(SDK_LIB_PATH)\ccfapi32.lib

USE_MSVCRT= 1

INCLUDES=   $(SOURCES_PATH).;                       \
            $(NET_INC_PATH);                        \
            $(DS_INC_PATH);                         \

C_DEFINES=  $(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE

UMTYPE=     windows

DLLDEF=     $(SOURCES_PATH)liccpa.def

SOURCES=    $(SOURCES)                  \
            $(SOURCES_PATH)LicCpa.cpp   \
            $(SOURCES_PATH)CLicReg.cpp  \
            $(SOURCES_PATH)PriDlgs.cpp  \
            $(SOURCES_PATH)Config.cpp   \
            $(SOURCES_PATH)SecDlgs.cpp  \
            $(SOURCES_PATH)LicSetup.cpp \
            $(SOURCES_PATH)Special.cpp  \
            $(SOURCES_PATH)LicCpa.rc


# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ServerAdmin.ObjectPicker
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=liccpa.cpl.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\licsetup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved

Module Name:

   licsetup.cpp

Abstract:

   This module exports a function, LicenseSetupRequestWizardPages, which
   gives NT Setup a wizard page for licensing to use in system setup (if
   licensing should be installed).

   This wizard page is responsible for all license system configuration,
   including:
      o  Creating the LicenseService
      o  Creating the ...\CurrentControlSet\Services\LicenseService key and
         its values.  (This key contains all configuration information for the
         LicenseService.)
      o  Creating the ...\CurrentControlSet\Services\LicenseInfo key and its
         values.  (This key contains all product-specific license info.)
      o  Creating the appropriate registry key to register the LicenseService
         with the EventLog.

   Portions of this module were extracted from SETUP (specifically from
   \nt\private\windows\setup\syssetup\license.c).

Author:

   Jeff Parham (jeffparh)     15-Apr-1996

Revision History:

   Jeff Parham (jeffparh)     17-Jul-1997
      Added KSecDD to FilePrint services table for SFM

--*/

#include <windows.h>
#include <commctrl.h>
#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <stdlib.h>
#include <htmlhelp.h>
#include <Accctrl.h>
#include <aclapi.h>
#include "liccpa.hpp"
#include "help.hpp"
#include "clicreg.hpp"
#include "config.hpp"
#include "resource.h"
#include "pridlgs.hpp"
#include "special.hpp"






//============================================================================
//
//    MACROS
//

// used by setup tests?  simulates a click on the NEXT button
#define  WM_SIMULATENEXT      ( WM_USER + 287 )

// begin or end a wait cursor
#define  WM_BEGINWAITCURSOR   ( WM_USER + 300 )
#define  WM_ENDWAITCURSOR     ( WM_USER + 301 )

// number of license wizard pages
const DWORD    NUM_LICENSE_PAGES    = 1;

// limits for per server licenses entered from the edit box in the
// license mode page
const int      PERSERVER_EDIT_MAX   = 9999;
const int      PERSERVER_EDIT_MIN   = 5;

// the number of chars to represent PERSERVER_EDIT_MAX
const int      PERSERVER_EDIT_WIDTH = 4;


//============================================================================
//
//    LOCAL PROTOTYPES
//

// decides, based on the setup type, whether licensing is installed
static   BOOL   LicenseSetupDisplayLicensePagesQuery( PINTERNAL_SETUP_DATA );

// License mode page functions
static   HPROPSHEETPAGE    LicenseSetupModePageGet( PINTERNAL_SETUP_DATA );
static   INT_PTR CALLBACK     LicenseSetupModeDlgProc( HWND, UINT, WPARAM, LPARAM );

// License mode page Windows message handlers
static   void   LicenseSetupModeOnInitDialog( HWND, LPARAM, PINTERNAL_SETUP_DATA *, LPBOOL, LPDWORD, LPDWORD );
static   void   LicenseSetupModeOnSetActive( HWND, PINTERNAL_SETUP_DATA, LPBOOL, LPDWORD );
static   void   LicenseSetupModeOnSetLicenseMode( HWND, BOOL, DWORD );
static   void   LicenseSetupModeOnEditUpdate( HWND, HWND, BOOL, LPDWORD );
static   void   LicenseSetupModeOnWaitCursor( HWND, BOOL, LPDWORD );
static   BOOL   LicenseSetupModeOnSetCursor( HWND, WORD, DWORD );
static   void   LicenseSetupModeOnNext( HWND, PINTERNAL_SETUP_DATA, BOOL, DWORD );
static   void   LicenseSetupModeOnHelp( HWND );
static   void   LicenseSetupModeOnSimulateNext( HWND );
static   void   LicenseSetupModeOnKillActive( HWND );
static   BOOL   LicenseSetupModeDoUnattended( HWND, PINTERNAL_SETUP_DATA, LPBOOL, LPDWORD );

// License configuration save functions
static   DWORD  LicenseSetupWrite( BOOL, DWORD );
static   DWORD  LicenseSetupWriteKeyLicenseInfo( BOOL, DWORD );
static   DWORD  LicenseSetupWriteKeyLicenseService( BOOL fWriteParametersKey );
static   DWORD  LicenseSetupWriteKeyEventLog();
static   DWORD  LicenseSetupWriteService( BOOL * fCreated );

// utility functions
static   int    MessageBoxFromStringID( HWND, UINT, UINT, UINT );


void CreateDirectoryWithAccess();

void CreateFileWithAccess();

BOOL IsRestrictedSmallBusSrv( void );
#define SBS_SPECIAL_USERS   10

//============================================================================
//
//    GLOBAL IMPLEMENTATION
//

BOOL
APIENTRY
LicenseSetupRequestWizardPages(
   HPROPSHEETPAGE *        paPropSheetPages,
   UINT *                  pcPages,
   PINTERNAL_SETUP_DATA    pSetupData )
{
   BOOL  fSuccess = FALSE;
   BOOL  fDisplayLicensePages;

   // validate params
   if (    ( NULL != pcPages                                       )
        && ( NULL != pSetupData                                    )
        && ( sizeof( INTERNAL_SETUP_DATA ) == pSetupData->dwSizeOf ) )
   {
      fDisplayLicensePages = LicenseSetupDisplayLicensePagesQuery( pSetupData );

      if ( NULL == paPropSheetPages )
      {
         // request for number of pages only
         *pcPages = fDisplayLicensePages ? NUM_LICENSE_PAGES : 0;
         fSuccess = TRUE;
      }
      else
      {
         // request for actual pages
         if ( !fDisplayLicensePages )
         {
            // no pages needed
            *pcPages = 0;
            fSuccess = TRUE;
         }
         else if ( *pcPages >= NUM_LICENSE_PAGES )
         {
            // create and return pages
            paPropSheetPages[ 0 ] = LicenseSetupModePageGet( pSetupData );

            if ( NULL != paPropSheetPages[ 0 ] )
            {
               *pcPages = NUM_LICENSE_PAGES;
               fSuccess = TRUE;
            }
         }
      }
   }

   return fSuccess;
}


//============================================================================
//
//    LOCAL IMPLEMENTATIONS
//

static
BOOL
LicenseSetupDisplayLicensePagesQuery(
   PINTERNAL_SETUP_DATA    pSetupData )
//
// The following code was extracted and modified from
//    \nt\private\windows\setup\syssetup\license.c
// in setup.  It returns TRUE iff the licensing wizard pages should be
// displayed as a part of setup.
//
{
   BOOL     fDisplayLicensePages;

   if ( PRODUCT_WORKSTATION == pSetupData->ProductType )
   {
      //
      //  If installing a workstation, then do not display the licensing page
      //
      fDisplayLicensePages = FALSE;
   }
   else
   {
      if ( !( pSetupData->OperationFlags & SETUPOPER_NTUPGRADE ) )
      {
         //
         //  The licensing page needs to be displayed on a clean install
         //  of a server
         //
         fDisplayLicensePages = TRUE;
      }
      else
      {
         //
         //  If upgrading a server, find out if it was already licensed
         //  (NT 3.51 and later). If it was, then do not display the
         //  licensing page.
         //  We find out whether or not the system was licensed by looking
         //  at a value entry in the registry.
         //  Note that NT 3.1 and 3.5 will never have this value in the
         //  registry, and in these cases the licensing page needs to be
         //  displayed.
         //

         DWORD                   winStatus;
         CLicRegLicenseService   FilePrintService( FILEPRINT_SERVICE_REG_KEY );

         winStatus = FilePrintService.Open( NULL, FALSE );

         if ( ERROR_SUCCESS != winStatus )
         {
            fDisplayLicensePages = TRUE;
         }
         else
         {
            LICENSE_MODE   LicenseMode;

            winStatus = FilePrintService.GetMode( LicenseMode );

            if (    ( ERROR_SUCCESS != winStatus              )
                 || (    ( LICMODE_PERSEAT   != LicenseMode )
                      && ( LICMODE_PERSERVER != LicenseMode ) ) )
            {
               fDisplayLicensePages = TRUE;
            }
            else
            {
               // set FlipAllow value if it's not already set (a setup bug in
               // the betas of NT 4.0 caused this value to be absent)
               FilePrintService.CanChangeMode();

               // add KSecDD to FilePrint services table if it isn't there already
               HKEY  hkeySFM;
               DWORD dwDisposition;

               winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                           TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\FilePrint\\KSecDD" ),
                                           0,
                                           NULL,
                                           0,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hkeySFM,
                                           &dwDisposition );

               if ( ERROR_SUCCESS == winStatus )
               {
                  RegCloseKey( hkeySFM );
               }

               // Change FilePrint License name from Windows NT to Windows.

               CLicRegLicenseService   FilePrintService(
                                                   FILEPRINT_SERVICE_REG_KEY );

               winStatus = FilePrintService.Open( NULL, FALSE );

               if ( ERROR_SUCCESS == winStatus )
               {
                   winStatus = FilePrintService.SetFamilyDisplayName(
                                       FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME );

                   if ( ERROR_SUCCESS == winStatus )
                   {
                       winStatus = FilePrintService.SetDisplayName(
                                              FILEPRINT_SERVICE_DISPLAY_NAME );
                   }
               }

                //
                // makarp: setting fDisplayLicensePages to true is wrong, because in such case
                // the pages will be displayed, and the original settings will be lost.
                //
                // fDisplayLicensePages = TRUE;

                //
                // instead we do the stuff we want to explicitely here.
                //
                BOOL bFlag = FALSE;
                LicenseSetupWriteService(&bFlag);
                CreateDirectoryWithAccess();
                CreateFileWithAccess();

               fDisplayLicensePages = FALSE;
            }
         }
      }
   }

   return fDisplayLicensePages;
}


static
HPROPSHEETPAGE
LicenseSetupModePageGet(
   PINTERNAL_SETUP_DATA    pSetupData )
//
// Returns an HPROPSHEETPAGE for the license mode wizard page, or
// NULL if error.
//
{
    HPROPSHEETPAGE   hpsp;
    PROPSHEETPAGE    psp;
    TCHAR    szHeader[256];
    TCHAR    szSubHeader[512];

    psp.dwSize       = sizeof( psp );
    psp.dwFlags      = PSP_USETITLE | PSP_HASHELP | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance    = g_hinst;
    psp.pszTemplate  = MAKEINTRESOURCE( IDD_SETUP_LICENSE_MODE_PAGE );
    psp.hIcon        = NULL;
    psp.pfnDlgProc   = LicenseSetupModeDlgProc;
    psp.lParam       = (LPARAM) pSetupData;
    psp.pszTitle     = pSetupData->WizardTitle;

    szHeader[0] = L'\0';
    szSubHeader[0] = L'\0';

    LoadString( g_hinst,
                  IDS_SETUP_HEADER,
                  szHeader,
                  sizeof( szHeader ) / sizeof( *szHeader ) );

    LoadString( g_hinst,
                  IDS_SETUP_SUBHEADER,
                  szSubHeader,
                  sizeof( szSubHeader ) / sizeof( *szSubHeader ) );

    psp.pszHeaderTitle = szHeader;
    psp.pszHeaderSubTitle = szSubHeader;


    hpsp = CreatePropertySheetPage( &psp );

    return hpsp;
}


static
INT_PTR
CALLBACK
LicenseSetupModeDlgProc(
   HWND     hwndPage,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
//
// Dialog procedure for the license mode wizard page.
//
{
   // static data initialized by WM_INITDIALOG
   static   PINTERNAL_SETUP_DATA    pSetupData = NULL;
   static   BOOL                    fLicensePerServer;
   static   DWORD                   cPerServerLicenses;
   static   DWORD                   cWaitCursor;

   BOOL     fReturn = TRUE;

   switch ( msg )
   {
   case WM_INITDIALOG:
      LicenseSetupModeOnInitDialog( hwndPage, lParam, &pSetupData, &fLicensePerServer, &cPerServerLicenses, &cWaitCursor );
      break;

   case WM_SIMULATENEXT:
      LicenseSetupModeOnSimulateNext( hwndPage );
      break;

   case WM_BEGINWAITCURSOR:
      LicenseSetupModeOnWaitCursor( hwndPage, TRUE, &cWaitCursor );
      break;

   case WM_ENDWAITCURSOR:
      LicenseSetupModeOnWaitCursor( hwndPage, FALSE, &cWaitCursor );
      break;

   case WM_SETCURSOR:
      LicenseSetupModeOnSetCursor( hwndPage, LOWORD( lParam ), cWaitCursor );
      break;

   case WM_COMMAND:
      switch ( HIWORD( wParam ) )
      {
      case BN_CLICKED:
         switch ( LOWORD( wParam ) )
         {
         case IDC_PERSEAT:
            fLicensePerServer = FALSE;
            LicenseSetupModeOnSetLicenseMode( hwndPage, fLicensePerServer, cPerServerLicenses );
            break;

         case IDC_PERSERVER:
            fLicensePerServer = TRUE;
            LicenseSetupModeOnSetLicenseMode( hwndPage, fLicensePerServer, cPerServerLicenses );
            break;
         }
         break;

      case EN_UPDATE:
         if ( IDC_USERCOUNT == LOWORD( wParam ) )
         {
            LicenseSetupModeOnEditUpdate( hwndPage, (HWND) lParam, fLicensePerServer, &cPerServerLicenses );
         }
         break;

      default:
         fReturn = FALSE;
         break;
      }
      break;

   case WM_NOTIFY:
      {
         NMHDR *  pNmHdr;

         pNmHdr = (NMHDR *)lParam;

         switch ( pNmHdr->code )
         {
         case PSN_SETACTIVE:
            LicenseSetupModeOnSetActive( hwndPage, pSetupData, &fLicensePerServer, &cPerServerLicenses );
            break;

         case PSN_KILLACTIVE:
            LicenseSetupModeOnKillActive( hwndPage );
            break;

         case PSN_WIZNEXT:
         case PSN_WIZFINISH:
            LicenseSetupModeOnNext( hwndPage, pSetupData, fLicensePerServer, cPerServerLicenses );
            break;

         case PSN_HELP:
            LicenseSetupModeOnHelp( hwndPage );
            break;

         default:
            fReturn = FALSE;
            break;
         }
      }

      break;

   default:
      fReturn = FALSE;
   }

   return fReturn;
}


static
void
LicenseSetupModeOnInitDialog(
   HWND                    hwndPage,
   LPARAM                  lParam,
   PINTERNAL_SETUP_DATA *  ppSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses,
   LPDWORD                 pcWaitCursor )
//
// Message handler for WM_INITDIALOG
//
{
   // initialize static data
   *ppSetupData         = (PINTERNAL_SETUP_DATA) ( (LPPROPSHEETPAGE) lParam )->lParam;
   *pcPerServerLicenses = 5;
   *pfLicensePerServer  = TRUE;
   *pcWaitCursor        = 0;

   // limit license count edit text length
   SendMessage( GetDlgItem( hwndPage, IDC_USERCOUNT ), EM_LIMITTEXT, PERSERVER_EDIT_WIDTH, 0 );

   // limit license count up-down range
   LONG     lRange;

   lRange = (LPARAM) MAKELONG( (short) PERSERVER_EDIT_MAX, (short) PERSERVER_EDIT_MIN );
   SendMessage( GetDlgItem( hwndPage, IDC_USERCOUNTARROW ), UDM_SETRANGE, 0, (LPARAM) lRange );

   // initialize for default license mode
   LicenseSetupModeOnSetLicenseMode( hwndPage, *pfLicensePerServer, *pcPerServerLicenses );
}


static
void
LicenseSetupModeOnSetActive(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses )
//
// Notification handler for PSN_SETACTIVE
//
{
    static BOOL fFirstTime = TRUE;
   BOOL  fSkipPage;

#ifdef SPECIAL_USERS
      *pfLicensePerServer  = TRUE;
      *pcPerServerLicenses = SPECIAL_USERS;
      fSkipPage            = TRUE;
#else
   if ( IsRestrictedSmallBusSrv() )
   {
      *pfLicensePerServer  = TRUE;
      *pcPerServerLicenses = SBS_SPECIAL_USERS;
      fSkipPage            = TRUE;
   }
   else if ( pSetupData->OperationFlags & SETUPOPER_BATCH )
   {
      // operating in unattended mode; attempt to get all answers
      // from the unattend configuration file
      fSkipPage = LicenseSetupModeDoUnattended( hwndPage,
                                                pSetupData,
                                                pfLicensePerServer,
                                                pcPerServerLicenses );
      if ( !fSkipPage )
      {
        // Set defaults from unattended file
        LicenseSetupModeOnSetLicenseMode( hwndPage,
                                          *pfLicensePerServer,
                                          *pcPerServerLicenses );
        //
        // makarp: setting skippage to true is wrong, because we do not want to skip page.
        // we came here because we did not find sufficent answers in answer file.
        //
        // fSkipPage = TRUE;
      }
   }
   else
   {
      // operating in interactive mode; get answers from user
      fSkipPage = FALSE;
   }
#endif

   HWND hwndSheet = GetParent( hwndPage );

   if ( fSkipPage )
   {

    if (fFirstTime)
    {
      fFirstTime = FALSE;
      // skip page
      // Only the first time do we need to do the processing which happens on next
      PostMessage( hwndSheet, PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0 );
    }
    else
    {
      // After the first time the processing is already done and we don't have to do anything
      // This also solves the problem where the page needs to be skipped when the user clicks back
      // on a later page and this pages needs to be skipped.
      SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)-1 );
      return;
    }

   }
   else
   {
      // display page

      // hide Cancel button
      HWND hwndCancel = GetDlgItem( hwndSheet, IDCANCEL );
      EnableWindow( hwndCancel, FALSE);
      ShowWindow(   hwndCancel, SW_HIDE);

      PropSheet_SetWizButtons( hwndSheet, PSWIZB_NEXT | PSWIZB_BACK );

      if (pSetupData)
      {
        pSetupData->ShowHideWizardPage(TRUE);
      }
   }

   // success
   SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)0 );
}


static
void
LicenseSetupModeOnSetLicenseMode(
   HWND     hwndPage,
   BOOL     fToPerServer,
   DWORD    cPerServerLicenses )
//
// Handles changing the page to signify that the given license mode
// is selected.
//
{
   HWND hwndCount = GetDlgItem( hwndPage, IDC_USERCOUNT );
   HWND hwndSpin  = GetDlgItem( hwndPage, IDC_USERCOUNTARROW );

   // set radio button states
   CheckDlgButton( hwndPage, IDC_PERSEAT,   !fToPerServer );
   CheckDlgButton( hwndPage, IDC_PERSERVER,  fToPerServer );

   // set user count edit control
   if ( fToPerServer )
   {
      // display per server count
      SetDlgItemInt( hwndPage, IDC_USERCOUNT, cPerServerLicenses, FALSE );
      SetFocus( hwndCount );
      SendMessage( hwndCount, EM_SETSEL, 0, -1 );
   }
   else
   {
      // remove per server count
      SetDlgItemText( hwndPage, IDC_USERCOUNT, TEXT( "" ) );
   }

   // display count up-down and edit box iff per server mode is selected
   EnableWindow( hwndCount, fToPerServer );
   EnableWindow( hwndSpin,  fToPerServer );
}


static
void
LicenseSetupModeOnEditUpdate(
   HWND     hwndPage,
   HWND     hwndCount,
   BOOL     fLicensePerServer,
   LPDWORD  pcPerServerLicenses )
//
// Command handler for EN_UPDATE of count edit box
//
{
   if ( fLicensePerServer )
   {
      BOOL  fTranslated;
      UINT  nValue;
      BOOL  fModified = FALSE;

      nValue = GetDlgItemInt( hwndPage, IDC_USERCOUNT, &fTranslated, FALSE );

      if ( fTranslated )
      {
         // count translated; ensure its within the valid range
         if ( PERSERVER_EDIT_MAX < nValue )
         {
            // too big
            nValue    = PERSERVER_EDIT_MAX;
            fModified = TRUE;
         }

         *pcPerServerLicenses = nValue;
      }
      else
      {
         // count couldn't be translated; reset to last value
         nValue    = *pcPerServerLicenses;
         fModified = TRUE;
      }

      if ( fModified )
      {
         // text in edit box is invalid; change it to the proper value
         SetDlgItemInt( hwndPage, IDC_USERCOUNT, nValue, FALSE );
         SetFocus( hwndCount );
         SendMessage( hwndCount, EM_SETSEL, 0, -1 );
         MessageBeep( MB_VALUELIMIT );
      }
   }
}


static
void
LicenseSetupModeOnWaitCursor(
   HWND     hwndDlg,
   BOOL     fWait,
   LPDWORD  pcWaitCursor )
//
// Handler for WM_BEGINWAITCURSOR / WM_ENDWAITCURSOR
//
{
   if ( fWait )
   {
      (*pcWaitCursor)++;

      if ( 1 == (*pcWaitCursor) )
      {
         // display wait cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_WAIT ) ) );
      }
   }
   else
   {
      if ( 0 < *pcWaitCursor )
      {
         (*pcWaitCursor)--;
      }

      if ( 0 == *pcWaitCursor )
      {
         // display regular cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_ARROW ) ) );
      }
   }

   // success
   SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)*pcWaitCursor );
}


static
BOOL
LicenseSetupModeOnSetCursor(
   HWND     hwndDlg,
   WORD     nHitTest,
   DWORD    cWaitCursor )
//
// Handler for WM_SETCURSOR
//
{
   BOOL frt = FALSE;

   if ( HTCLIENT == nHitTest )
   {
      if ( cWaitCursor > 0 )
      {
         // display wait cursor instead of regular cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_WAIT ) ) );
         SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)TRUE );
         frt = TRUE;
      }
   }

   return frt;
}


static
void
LicenseSetupModeOnNext(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   BOOL                    fLicensePerServer,
   DWORD                   cPerServerLicenses )
//
// Notification handler for PSN_WIZNEXT
//
{
   DWORD    winStatus;
   int      nButton;

   if (     ( fLicensePerServer )
        &&  ( PERSERVER_EDIT_MIN > cPerServerLicenses )
        && !( pSetupData->OperationFlags & SETUPOPER_BATCH ) )
   {
      // warn user about using per server mode with less then 5 licenses
      MessageBoxFromStringID( hwndPage,
                                        IDS_LICENSE_SETUP_NO_PER_SERVER_LICENSES,
                                        IDS_WARNING,
                                        MB_ICONERROR | MB_OK );
      nButton = IDCANCEL;
   }
   else
   {
      // per seat mode or per server mode with positive license count
      nButton = IDOK;
   }

   if ( IDOK == nButton )
   {
      do
      {
         // save license configuration
         SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

         winStatus = LicenseSetupWrite( fLicensePerServer, cPerServerLicenses );

         SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

         if ( ERROR_SUCCESS != winStatus )
         {
            // save failed; alert user
            nButton = MessageBoxFromStringID( hwndPage,
                                              IDS_LICENSE_SETUP_SAVE_FAILED,
                                              IDS_ERROR,
                                              MB_ICONSTOP | MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 );

            if ( IDIGNORE == nButton )
            {
               nButton = IDOK;
            }
         }
         else
         {
            // save succeeded
            nButton = IDOK;
         }
      } while ( IDRETRY == nButton );
   }

   if ( IDOK != nButton )
   {
      // don't advance to next page
      SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)-1 );
   }
}


static
void
LicenseSetupModeOnHelp(
   HWND  hwndPage )
//
// Notification handler for PSN_HELP
//
{
    ::HtmlHelp( hwndPage, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
}


static
void
LicenseSetupModeOnSimulateNext(
   HWND  hwndPage )
//
// Handler for WM_SIMULATENEXT (used by setup tests?)
//
{
   // simulate the next button
   PropSheet_PressButton( GetParent( hwndPage ), PSBTN_NEXT );
}


static
void
LicenseSetupModeOnKillActive(
   HWND  hwndPage )
//
// Notification handler for PSN_KILLACTIVE
//
{
   // success
   SetWindowLong( hwndPage, DWLP_MSGRESULT, 0);
}

typedef enum {
    UnattendFullUnattend,
    UnattendGUIAttended,
    UnattendDefaultHide,
    UnattendProvideDefault,
    UnattendReadOnly } UNATTENDMODE; 

static
BOOL
LicenseSetupModeDoUnattended(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses )
//
// Get answers to wizard page from unattend file.
//
{
   int      cch;
   LPTSTR   pszBadParam;
   TCHAR    szLicenseMode[ 64 ];
   TCHAR    szPerServerLicenses[ 64 ];
   TCHAR    szUnattendMode[ 64 ];
   UNATTENDMODE UnattendMode = UnattendDefaultHide;

   pszBadParam = NULL;

   SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

   // Get Unattend Mode
   cch = GetPrivateProfileString( WINNT_UNATTENDED,
                                  WINNT_U_UNATTENDMODE,
                                  TEXT( "" ),
                                  szUnattendMode,
                                  sizeof( szUnattendMode ) / sizeof( *szUnattendMode ),
                                  pSetupData->UnattendFile );
   if ( 0 < cch )
   {
      if ( !lstrcmpi( szUnattendMode, WINNT_A_FULLUNATTENDED ) )
      {
        UnattendMode = UnattendFullUnattend;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_PROVIDEDEFAULT ) )
      {
        UnattendMode = UnattendProvideDefault;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_READONLY ) )
      {
        UnattendMode = UnattendReadOnly;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_GUIATTENDED ) )
      {
        // This should never happen
        UnattendMode = UnattendGUIAttended;
      }
   }


   // get license mode
   cch = GetPrivateProfileString( WINNT_LICENSEDATA_W,
                                  WINNT_L_AUTOMODE_W,
                                  TEXT( "" ),
                                  szLicenseMode,
                                  sizeof( szLicenseMode ) / sizeof( *szLicenseMode ),
                                  pSetupData->UnattendFile );

   SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

   if ( 0 < cch )
   {
      if ( !lstrcmpi( szLicenseMode, WINNT_A_PERSEAT_W ) )
      {
         *pfLicensePerServer = FALSE;
      }
      else if ( !lstrcmpi( szLicenseMode, WINNT_A_PERSERVER_W ) )
      {
         *pfLicensePerServer = TRUE;
      }
      else
      {
         cch = 0;
      }
   }

   if ( cch <= 0 )
   {
      // license mode absent or invalid
      pszBadParam = WINNT_L_AUTOMODE_W;
   }
   else if ( !*pfLicensePerServer )
   {
      // per seat mode; no need to read per server license count
      *pcPerServerLicenses = 0;
   }
   else
   {
      // get per server license count
      SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

      cch = GetPrivateProfileString( WINNT_LICENSEDATA_W,
                                     WINNT_L_AUTOUSERS_W,
                                     TEXT( "" ),
                                     szPerServerLicenses,
                                     sizeof( szPerServerLicenses ) / sizeof( *szPerServerLicenses ),
                                     pSetupData->UnattendFile );

      SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

      if ( 0 < cch )
      {
         *pcPerServerLicenses = wcstoul( szPerServerLicenses, NULL, 10 );

         if (    ( PERSERVER_EDIT_MIN > *pcPerServerLicenses )
              || ( PERSERVER_EDIT_MAX < *pcPerServerLicenses ) )
         {
            // Don't let things go without setting a valid server license
            // count.
            *pcPerServerLicenses = PERSERVER_EDIT_MIN;
            cch = 0;
         }
      }

      if ( cch <= 0 )
      {
         // per server license count absent or invalid
         pszBadParam = WINNT_L_AUTOUSERS_W;
      }
   }

   //
   // Do not display the error message on preinstall.
   //

   if ( NULL != pszBadParam &&
        !(pSetupData->OperationFlags & (SETUPOPER_PREINSTALL | SETUPOPER_NTUPGRADE)) &&
        UnattendMode == UnattendFullUnattend )
   {
      // encountered a bad unattended parameter; display error
      TCHAR    szCaption[   64 ];
      TCHAR    szFormat[  1024 ];
      TCHAR    szText[    1024 ];

      LoadString( g_hinst,
                  IDS_LICENSE_SETUP_BAD_UNATTEND_PARAM,
                  szFormat,
                  sizeof( szFormat ) / sizeof( *szFormat ) );

      LoadString( g_hinst,
                  IDS_ERROR,
                  szCaption,
                  sizeof( szCaption ) / sizeof( *szCaption ) );

      wsprintf( szText, szFormat, pszBadParam );

      MessageBox( hwndPage,
                  szText,
                  szCaption,
                  MB_OK | MB_ICONSTOP );
   }

   // If just providing defaults, return FALSE to force the page to show
   if ( UnattendMode == UnattendProvideDefault )
      return ( FALSE );
   return ( NULL == pszBadParam );
}


static
DWORD
LicenseSetupWrite(
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses )
//
// Write license configuration; returns ERROR_SUCCESS or Windows error.
//
{
   DWORD    winStatus;
   BOOL     fCreated = TRUE;    // TRUE if service entry is created
                                // Used to determine if we should create
                                // the parameters key or leave it alone.

   winStatus = LicenseSetupWriteService( &fCreated );

   if ( ERROR_SUCCESS == winStatus )
   {
      winStatus = LicenseSetupWriteKeyLicenseInfo( fLicensePerServer,
                                                   cPerServerLicenses );

      if ( ERROR_SUCCESS == winStatus )
      {
         winStatus = LicenseSetupWriteKeyLicenseService( fCreated );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = LicenseSetupWriteKeyEventLog();
         }
      }
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyLicenseInfo(
   BOOL  fLicensePerServer,
   DWORD cPerServerLicenses )
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseInfo
//                      ErrorControl : REG_DWORD : 1
//                      Start        : REG_DWORD : 3
//                      Type         : REG_DWORD : 4
//                      \FilePrint
//                         ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
//                         DisplayName       : REG_SZ    : "Windows Server"
//                         FamilyDisplayName : REG_SZ    : "Windows Server"
//                         Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
//                         FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0
//
{
   DWORD             winStatus;
   BOOL              fCreatedNewServiceList;
   CLicRegLicense    ServiceList;

   winStatus = ServiceList.Open( fCreatedNewServiceList );

   if ( ERROR_SUCCESS == winStatus )
   {
      CLicRegLicenseService   FilePrintService( FILEPRINT_SERVICE_REG_KEY );

      winStatus = FilePrintService.Open( NULL, TRUE );

      if ( ERROR_SUCCESS == winStatus )
      {
         LICENSE_MODE   lm;

         lm = fLicensePerServer ? LICMODE_PERSERVER : LICMODE_PERSEAT;

         winStatus = FilePrintService.SetMode( lm );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = FilePrintService.SetUserLimit( fLicensePerServer ? cPerServerLicenses : 0 );

            if ( ERROR_SUCCESS == winStatus )
            {
               winStatus = FilePrintService.SetChangeFlag( fLicensePerServer );

               if ( ERROR_SUCCESS == winStatus )
               {
                  winStatus = FilePrintService.SetFamilyDisplayName( FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME );

                  if ( ERROR_SUCCESS == winStatus )
                  {
                     winStatus = FilePrintService.SetDisplayName( FILEPRINT_SERVICE_DISPLAY_NAME );
                  }
               }
            }
         }
      }
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyLicenseService( BOOL fWriteParametersKey )
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseService
//                   \FilePrint
//                      \KSecDD
//                      \MSAfpSrv
//                      \SMBServer
//                      \TCP/IP Print Server
//                   \Parameters
//                      UseEnterprise    : REG_DWORD : 0
//                      ReplicationType  : REG_DWORD : 0
//                      ReplicationTime  : REG_DWORD : 24 * 60 * 60
//                      EnterpriseServer : REG_SZ    : ""
//
{
   DWORD    winStatus;
   HKEY     hKeyLicenseService;
   DWORD    dwKeyCreateDisposition;

   // create LicenseInfo key
   winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               LICENSE_SERVICE_REG_KEY,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyLicenseService,
                               &dwKeyCreateDisposition );

   if ( ERROR_SUCCESS == winStatus )
   {
      HKEY  hKeyFilePrint;

      // create FilePrint key
      winStatus = RegCreateKeyEx( hKeyLicenseService,
                                  TEXT( "FilePrint" ),
                                  0,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyFilePrint,
                                  &dwKeyCreateDisposition );

      if ( ERROR_SUCCESS == winStatus )
      {
         const LPCTSTR  apszFilePrintSubkeys[] =
         {
            TEXT( "KSecDD" ),
            TEXT( "MSAfpSrv" ),
            TEXT( "SMBServer" ),
            TEXT( "TCP/IP Print Server" ),
            NULL
         };

         HKEY     hKeyFilePrintSubkey;
         DWORD    iSubkey;

         for ( iSubkey = 0; NULL != apszFilePrintSubkeys[ iSubkey ]; iSubkey++ )
         {
            winStatus = RegCreateKeyEx( hKeyFilePrint,
                                        apszFilePrintSubkeys[ iSubkey ],
                                        0,
                                        NULL,
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKeyFilePrintSubkey,
                                        &dwKeyCreateDisposition );

            if ( ERROR_SUCCESS == winStatus )
            {
               RegCloseKey( hKeyFilePrintSubkey );
            }
            else
            {
               break;
            }
         }

         RegCloseKey( hKeyFilePrint );
      }

      RegCloseKey( hKeyLicenseService );
   }

   //
   // Only write the Parameters key if the service was just created.  That is,
   // this is not an upgrade
   //
   if ( fWriteParametersKey && (ERROR_SUCCESS == winStatus) )
   {
      HKEY  hKeyParameters;

      // create Parameters key
      winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                  szLicenseKey, // const
                                  0,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyParameters,
                                  &dwKeyCreateDisposition );

      if ( ERROR_SUCCESS == winStatus )
      {
         // create LicenseService\Parameters values
         winStatus = RegSetValueEx( hKeyParameters,
                                    szUseEnterprise, // const
                                    0,
                                    REG_DWORD,
                                    (CONST BYTE *) &dwUseEnterprise,  // const
                                    sizeof( dwUseEnterprise ) );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = RegSetValueEx( hKeyParameters,
                                       szReplicationType, // const
                                       0,
                                       REG_DWORD,
                                       (CONST BYTE *) &dwReplicationType,  // const
                                       sizeof( dwReplicationType ) );

            if ( ERROR_SUCCESS == winStatus )
            {
               winStatus = RegSetValueEx( hKeyParameters,
                                          szReplicationTime, // const
                                          0,
                                          REG_DWORD,
                                          (CONST BYTE *) &dwReplicationTimeInSec, // const
                                          sizeof( dwReplicationTimeInSec ) );

               if ( ERROR_SUCCESS == winStatus )
               {
                  LPCTSTR pszEnterpriseServer = TEXT( "" );

                  winStatus = RegSetValueEx( hKeyParameters,
                                             szEnterpriseServer, // const
                                             0,
                                             REG_SZ,
                                             (CONST BYTE *) pszEnterpriseServer,
                                             ( 1 + lstrlen( pszEnterpriseServer ) ) * sizeof( *pszEnterpriseServer ) );
               }
            }
         }

         RegCloseKey( hKeyParameters );
      }
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyEventLog()
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \EventLog
//                   \Application
//                      \LicenseService
//                         EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
//                         TypesSupported   : REG_DWORD     : 7
//
{
   DWORD    winStatus;
   HKEY     hKeyLicenseService;
   DWORD    dwKeyCreateDisposition;

   // create LicenseService key
   winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" ),
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyLicenseService,
                               &dwKeyCreateDisposition );

   if ( ERROR_SUCCESS == winStatus )
   {
      LPCTSTR     pszEventMessageFile = TEXT( "%SystemRoot%\\System32\\llsrpc.dll" );
      const DWORD dwTypesSupported    = (   EVENTLOG_ERROR_TYPE
                                          | EVENTLOG_WARNING_TYPE
                                          | EVENTLOG_INFORMATION_TYPE );

      winStatus = RegSetValueEx( hKeyLicenseService,
                                 TEXT( "TypesSupported" ),
                                 0,
                                 REG_DWORD,
                                 (CONST BYTE *) &dwTypesSupported,
                                 sizeof( dwTypesSupported ) );

      if ( ERROR_SUCCESS == winStatus )
      {
         winStatus = RegSetValueEx( hKeyLicenseService,
                                    TEXT( "EventMessageFile" ),
                                    0,
                                    REG_SZ,
                                    (CONST BYTE *) pszEventMessageFile,
                                    ( 1 + lstrlen( pszEventMessageFile ) ) * sizeof( *pszEventMessageFile ) );
      }

      RegCloseKey( hKeyLicenseService );
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteService( BOOL * fCreated )
//
// Create/modify service:
//
//    lpServiceName        = "LicenseService"
//    lpDisplayName        = "License Logging Service"
//    dwServiceType        = SERVICE_WIN32_OWN_PROCESS
//    dwStartType          = LanManServerInstalled ? SERVICE_AUTO_START : SERVICE_DISABLED
//    dwErrorControl       = SERVICE_ERROR_NORMAL
//    lpBinaryPathName     = "%SystemRoot%\\System32\\llssrv.exe"
//    lpLoadOrderGroup     = NULL
//    lpdwTagId            = NULL
//    lpDependencies       = NULL
//    lpServiceStartName   = NULL
//    lpPassword           = NULL
//
{
   SC_HANDLE   hSC;
   DWORD       winStatus;

   *fCreated = FALSE;      

   hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

   if ( NULL == hSC )
   {
      winStatus = GetLastError();      
   }
   else
   {       
      HKEY        hKeyLanmanServerParameters;
      DWORD       dwStartType ;
      SC_HANDLE   hLicenseService = NULL;      
      TCHAR       szServiceDisplayName[ 128 ] = TEXT( "License Logging" );      
      TCHAR       szServiceDescription[256] = TEXT("");  
      TCHAR       szServiceStartName [] = TEXT("NT AUTHORITY\\NetworkService");    
      TCHAR       szServicePassword[]=TEXT("");
      SERVICE_DESCRIPTION   svcDescription;
      QUERY_SERVICE_CONFIG*  pConfig = NULL;
      DWORD   cbBytesNeeded = 0;
      BOOL    frt;
      DWORD dwDesiredAccess = SERVICE_ALL_ACCESS;
      
      
     

      // enable service iff LanmanServer was installed
      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters" ),
                                0,
                                KEY_READ,
                                &hKeyLanmanServerParameters );
            

      if ( ERROR_SUCCESS == winStatus )
      {   

          dwStartType = SERVICE_AUTO_START; 
		  
		  hLicenseService = OpenService( hSC, TEXT( "LicenseService"), dwDesiredAccess );

         if( hLicenseService != NULL )
         {               
         
             cbBytesNeeded = sizeof(QUERY_SERVICE_CONFIG) + 4096;

             pConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LPTR, cbBytesNeeded );
         
             if ( pConfig != NULL )
             {

                 frt = ::QueryServiceConfig( hLicenseService,
                        pConfig,
                        cbBytesNeeded,
                        &cbBytesNeeded );
				 
                 if ( frt )
                 {						
                     dwStartType = pConfig->dwStartType;                             
                 } 

                 LocalFree ( pConfig ) ;
             }
         
             
             CloseServiceHandle( hLicenseService );
                       
         }      

         RegCloseKey( hKeyLanmanServerParameters );
         
      }
      
      else
      {
          dwStartType = SERVICE_DISABLED;
      }                          

      LoadString( g_hinst,
                  IDS_SERVICE_DISPLAY_NAME,
                  szServiceDisplayName,
                  sizeof( szServiceDisplayName ) / sizeof( *szServiceDisplayName ) );

      LoadString( g_hinst,
                  IDS_SERVICE_DESCRIPTION,
                  szServiceDescription,
                  sizeof( szServiceDescription ) / sizeof( *szServiceDescription ) );


      svcDescription.lpDescription = szServiceDescription;   
      

      hLicenseService = CreateService( hSC,
                                       TEXT( "LicenseService" ),
                                       szServiceDisplayName,
                                       // 14659: needed to call ChangeConfig2 later
                                       SERVICE_CHANGE_CONFIG,
                                       SERVICE_WIN32_OWN_PROCESS,
                                       dwStartType,
                                       SERVICE_ERROR_NORMAL,
                                       TEXT( "%SystemRoot%\\System32\\llssrv.exe" ),
                                       NULL,
                                       NULL,
                                       NULL,
                                       szServiceStartName,
                                       szServicePassword );        


      if ( NULL != hLicenseService )
      {
         // service successfully created

         ChangeServiceConfig2( hLicenseService,
                               SERVICE_CONFIG_DESCRIPTION,
                               &svcDescription );

         CloseServiceHandle( hLicenseService );

         winStatus = ERROR_SUCCESS;
         *fCreated = TRUE;
      }
      else
      {
         winStatus = GetLastError();

         if ( ERROR_SERVICE_EXISTS == winStatus )
         {
            // service already exists; change configuration of existing service
            hLicenseService = OpenService( hSC,
                                           TEXT( "LicenseService" ),
                                           SERVICE_CHANGE_CONFIG );

            if ( NULL == hLicenseService )
            {
               winStatus = GetLastError();
            }
            else
            {
               SC_LOCK     scLock;
               BOOL        ok;

               scLock = LockServiceDatabase( hSC );
               // continue even if we can't lock the database

               ok = ChangeServiceConfig( hLicenseService,
                                         SERVICE_WIN32_OWN_PROCESS,
                                         dwStartType,
                                         SERVICE_ERROR_NORMAL,
                                         TEXT( "%SystemRoot%\\System32\\llssrv.exe" ),
                                         NULL,
                                         NULL,
                                         NULL,
                                         szServiceStartName,
                                         szServicePassword,
                                         szServiceDisplayName );

               if ( !ok )
               {
                  winStatus = GetLastError();
               }
               else
               {
                  ChangeServiceConfig2( hLicenseService,
                                         SERVICE_CONFIG_DESCRIPTION,
                                         &svcDescription);

                  winStatus = ERROR_SUCCESS;
               }

               if ( NULL != scLock )
               {
                  UnlockServiceDatabase( scLock );
               }

               CloseServiceHandle( hLicenseService );
            }
         }
      }

      CloseServiceHandle( hSC );
   }

   
   CreateDirectoryWithAccess();

   CreateFileWithAccess();

   return winStatus;
}

void CreateDirectoryWithAccess()
{
    DWORD winStatus = 0;
    TCHAR tchWinDirPath[MAX_PATH+1] = L"";        
    PACL pNewDacl = NULL;
    PACL pOldDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    TCHAR tchLLSDirPath[ MAX_PATH +1] = L"";    
    BOOL bFlag = FALSE;
    PSID pSid = NULL;   
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;

    winStatus = GetSystemWindowsDirectory( tchWinDirPath , MAX_PATH+1);
    if(winStatus == 0)
    {
        goto cleanup;
    }

    lstrcpy(tchLLSDirPath, tchWinDirPath);
    lstrcat( tchLLSDirPath , L"\\system32\\lls" );
	
	// Creating new EXPLICIT_ACCESS structure to set on the directory

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    bFlag = AllocateAndInitializeSid(
        &ntSidAuthority,
        1,
        SECURITY_NETWORK_SERVICE_RID,0,          
        0, 0, 0, 0, 0, 0,
        &pSid );



    if ( !bFlag || (pSid == NULL) ) {

        goto cleanup;
    }


    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );

    ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;
    ExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;


    bFlag = CreateDirectory( tchLLSDirPath, NULL );


    if ( !bFlag ) 
    {

        winStatus = GetLastError();

        if (ERROR_ALREADY_EXISTS != winStatus)  
        {
            goto cleanup;
        }
    }

   
    if( GetNamedSecurityInfoW( tchLLSDirPath,
                             SE_FILE_OBJECT,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl, // pDacl
                             NULL, // pSacl
                             &pSD ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl,
                          &pNewDacl ) != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    //  SET security on the Directory
    //

    winStatus = SetNamedSecurityInfo(
                      tchLLSDirPath,                // object name
                      SE_FILE_OBJECT ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl,                        // new DACL
                      NULL                         // new SACL
                    );
cleanup:
    
    if(pSid) 
    {
        LocalFree( pSid );
    }
    
    if(pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }

    if(pNewDacl)
    {
        LocalFree(pNewDacl);
        pNewDacl = NULL;
    }
}

void CreateFileWithAccess()
{
    DWORD winStatus = 0;
    TCHAR tchWinDirPath[MAX_PATH+1] = L"";    
    PACL pNewDacl = NULL;
    PACL pOldDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    TCHAR tchCPLFilePath[ MAX_PATH+1 ] = L"";
    BOOL bFlag = FALSE;
    PSID pSid = NULL;   
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE hFile = NULL;
    
    winStatus = GetSystemWindowsDirectory( tchWinDirPath , MAX_PATH+1);
    if(winStatus == 0)
    {
        goto cleanup;
    }
        
    lstrcpy(tchCPLFilePath, tchWinDirPath);
    lstrcat( tchCPLFilePath , L"\\system32\\cpl.cfg" );    

    
	// Creating new EXPLICIT_ACCESS structure to set on the file

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    bFlag = AllocateAndInitializeSid(
        &ntSidAuthority,
        1,
        SECURITY_NETWORK_SERVICE_RID,0,          
        0, 0, 0, 0, 0, 0,
        &pSid );


    if ( !bFlag || (pSid == NULL) ) {

        goto cleanup;
    }

    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );

    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;
    ExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;


    hFile = CreateFile(tchCPLFilePath, 
                            GENERIC_READ | GENERIC_WRITE, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, 
                            OPEN_ALWAYS, 
                            0, 
                            NULL);


    if(hFile == NULL)
    {
        winStatus = GetLastError();

        if (winStatus != ERROR_ALREADY_EXISTS) {
            goto cleanup ;
        }


    }

    

    if( GetNamedSecurityInfoW( tchCPLFilePath,
                             SE_FILE_OBJECT,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl, // pDacl
                             NULL, // pSacl
                             &pSD ) != ERROR_SUCCESS)

    {
        goto cleanup;
    }

    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl,
                          &pNewDacl ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    //  SET security on the File
    //


   
    winStatus = SetNamedSecurityInfo(
                      tchCPLFilePath,                // object name
                      SE_FILE_OBJECT ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl,                        // new DACL
                      NULL                         // new SACL
                    );    
    

cleanup:

    if(hFile)
    {
        CloseHandle(hFile);
    }
    
    if(pSid) 
    {
        LocalFree( pSid );
    }
    
    if(pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }
    
    if(pNewDacl)
    {
        LocalFree(pNewDacl);
        pNewDacl = NULL;
    }
}


static
int
MessageBoxFromStringID(
   HWND     hwndParent,
   UINT     uTextID,
   UINT     uCaptionID,
   UINT     uType )
//
// Same as MessageBox(), except Text and Caption are string resources
// instead of string pointers.
//
{
   int      nButton;
   TCHAR    szText[ 1024 ];
   TCHAR    szCaption[ 64 ];

   LoadString( g_hinst, uTextID,    szText,    sizeof( szText )    / sizeof( *szText    ) );
   LoadString( g_hinst, uCaptionID, szCaption, sizeof( szCaption ) / sizeof( *szCaption ) );

   nButton = MessageBox( hwndParent, szText, szCaption, uType );

   return nButton;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\special.hpp ===
//-------------------------------------------------------------------
//
// FILE: Special.hpp
//
// Summary;
//              This file contians the definitions of Special Dialogs functions
//
// Entry Points;
//
// History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

#ifndef __SPECIAL_HPP__
#define __SPECIAL_HPP__

// currently we support one special version for msdn, 
// when others are needed, just copy the group below for each version
//

// define MSDNVERSION to build for this version
#ifdef MSDNVERSION

#define SPECIALVERSION
#define IDS_SPECVER_WARNING IDS_MSDN_NOTAVAILABLE
#define IDS_SPECVER_TEXT1   IDS_MSDN_TEXT1
#define IDS_SPECVER_TEXT2   IDS_MSDN_TEXT2

#define SPECIAL_MODE  LICMODE_PERSERVER
#define SPECIAL_USERS 5
#endif

// define NFRVERSION to build for this version
#ifdef NFRVERSION

#define SPECIALVERSION
#define IDS_SPECVER_WARNING IDS_NFR_NOTAVAILABLE
#define IDS_SPECVER_TEXT1   IDS_NFR_TEXT1
#define IDS_SPECVER_TEXT2   IDS_NFR_TEXT2

#define SPECIAL_MODE  LICMODE_PERSERVER
#ifndef SPECIAL_USERS
#  define SPECIAL_USERS 5
#endif
#endif

#define REGKEY_LICENSEINFO_SBS      L"System\\CurrentControlSet\\Services\\LicenseInfoSuites\\SmallBusiness"
#define   REGVAL_CONCURRENT_LIMIT   L"ConcurrentLimit"

#define DEFAULT_SPECIAL_USERS   5

#define SAM_NFR_LICENSE_COUNT   2

typedef struct _SPECIALVERSIONINFO {
    UINT         idsSpecVerWarning;
    UINT         idsSpecVerText1;
    UINT         idsSpecVerText2;
    DWORD        dwSpecialUsers;
    LICENSE_MODE lmSpecialMode;
} SPECIALVERSIONINFO, * LPSPECIALVERSIONINFO;

extern SPECIALVERSIONINFO gSpecVerInfo;

extern void  InitSpecialVersionInfo( VOID );
extern void  RaiseNotAvailWarning( HWND hwndCPL );
extern INT_PTR   SpecialSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern DWORD GetSpecialUsers( VOID );
extern BOOL  IsRestrictedSmallBusSrv( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\secdlgs.hpp ===
//-------------------------------------------------------------------
//
// FILE: SecDlgs.hpp
//
// Summary;
// 		This file contians the definitions of Secondary Dialogs functions
//
// Entry Points;
//		LicViolationDialog
//		SetupPerOnlyDialog
//		PerServerAgreementDialog
//		PerSeatAgreementDialog
//		ServerAppAgreementDialog
//
// History;
//		Nov-30-94	MikeMi	Created
//
//-------------------------------------------------------------------

#ifndef __SECDLGS_HPP__
#define __SECDLGS_HPP__

// Used to pass information from the Setup entry point to the Setup Dialog
//

extern int LicViolationDialog( HWND hwndParent );
extern int SetupPerOnlyDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int PerServerAgreementDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
        DWORD dwLimit,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int PerSeatAgreementDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int ServerAppAgreementDialog( HWND hwndParent,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\special.cpp ===
//-------------------------------------------------------------------
//
// FILE:        special.cpp
//
// Summary;     This file contians the dialogs for the MSDN version of
//              the  control panel applet and setup entry points.
//
// History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include "resource.h"
#include "CLicReg.hpp"
#include <stdlib.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include "Special.hpp"
#include "sbs_res.h"

SPECIALVERSIONINFO gSpecVerInfo;

//-------------------------------------------------------------------
//
//  Function:   InitSpecialVersionInfo
//
//  Summary:    Initialize global data if liccpa is launched as
//              a special version (eg: restricted SAM, NFR, etc).
//
//  Arguments:  None.
//
//  History:    Oct-07-97       MarkBl  Created
//
//-------------------------------------------------------------------

void InitSpecialVersionInfo( void )
{
    //
    // If the SPECIALVERSION manifest is defined, initialize the
    // global data from the specifc manifests defined for the special
    // version.
    //
    // TBD : These special versions should change to be detected at
    //       runtime vs. building a special version of liccpa.
    //

#ifdef SPECIALVERSION
    gSpecVerInfo.idsSpecVerWarning = IDS_SPECVER_WARNING;
    gSpecVerInfo.idsSpecVerText1   = IDS_SPECVER_TEXT1;
    gSpecVerInfo.idsSpecVerText2   = IDS_SPECVER_TEXT2;
    gSpecVerInfo.dwSpecialUsers    = SPECIAL_USERS;
    gSpecVerInfo.lmSpecialMode     = SPECIAL_MODE;
#else
    ZeroMemory(&gSpecVerInfo, sizeof(gSpecVerInfo));
#endif // SPECIALVERSION

    //
    // Special versions of liccpa detected at runtime.
    //
    // Currently, small business server only.
    //

    if (IsRestrictedSmallBusSrv())
    {
        gSpecVerInfo.dwSpecialUsers = GetSpecialUsers();

        //
        // Check for small business server NFR.
        //

        if (gSpecVerInfo.dwSpecialUsers == SAM_NFR_LICENSE_COUNT)
        {
            gSpecVerInfo.idsSpecVerWarning = IDS_SAMNFR_NOTAVAILABLE;
            gSpecVerInfo.idsSpecVerText1   = IDS_SAMNFR_TEXT1;
            gSpecVerInfo.idsSpecVerText2   = IDS_SAMNFR_TEXT2;
            gSpecVerInfo.lmSpecialMode     = LICMODE_PERSERVER;
        }
        else
        {
            gSpecVerInfo.idsSpecVerWarning = IDS_SAM_NOTAVAILABLE;
            gSpecVerInfo.idsSpecVerText1   = IDS_SAM_TEXT1;
            gSpecVerInfo.idsSpecVerText2   = IDS_SAM_TEXT2;
            gSpecVerInfo.lmSpecialMode     = LICMODE_PERSERVER;
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: RaiseNotAvailWarning
//
//  Summary;
//              Raise the special not available with this version warning
//
//      Arguments;
//              hwndDlg [in] - hwnd of control dialog
//
//  History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

void RaiseNotAvailWarning( HWND hwndCPL )
{
    TCHAR pszText[LTEMPSTR_SIZE];
    TCHAR pszTitle[TEMPSTR_SIZE];
    HINSTANCE hSbsLib = NULL;

    if ( (gSpecVerInfo.idsSpecVerWarning == IDS_SAMNFR_NOTAVAILABLE)
        && (hSbsLib = LoadLibrary( SBS_RESOURCE_DLL )) )
    {
        LoadString( hSbsLib, SBS_License_Error, pszText, TEMPSTR_SIZE );
    }
    else
    {
        LoadString( g_hinst, gSpecVerInfo.idsSpecVerWarning, pszText,
                    TEMPSTR_SIZE );
    }
    LoadString( g_hinst, IDS_CPATITLE, pszTitle, TEMPSTR_SIZE );
    
    MessageBox( hwndCPL, pszText, pszTitle, MB_ICONINFORMATION | MB_OK );
}

//-------------------------------------------------------------------

void SetStaticWithService( HWND hwndDlg, UINT idcStatic, LPTSTR psService, UINT idsText )
{
        WCHAR szText[LTEMPSTR_SIZE];
        WCHAR szTemp[LTEMPSTR_SIZE];
    
    LoadString( g_hinst, idsText, szTemp, LTEMPSTR_SIZE ); 
        wsprintf( szText, szTemp, psService );
        SetDlgItemText( hwndDlg, idcStatic, szText );
}

//-------------------------------------------------------------------

void SetStaticUsers( HWND hwndDlg, UINT idcStatic, DWORD users, UINT idsText )
{
        WCHAR szText[LTEMPSTR_SIZE];
        WCHAR szTemp[LTEMPSTR_SIZE];
    
    LoadString( g_hinst, idsText, szTemp, LTEMPSTR_SIZE ); 
        wsprintf( szText, szTemp, users );
        SetDlgItemText( hwndDlg, idcStatic, szText );
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialInitDialog
//
//  Summary;
//              Handle the initialization of the Special only Setup Dialog
//
//  Arguments;
//              hwndDlg [in] - the dialog to initialize
//              psdParams [in] - used for the displayname and service name
//
//  Notes;
//
//      History;
//              Dec-08-1994     MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialInitDialog( HWND hwndDlg, PSETUPDLGPARAM psdParams )
{
        HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
        CLicRegLicense cLicKey;
        BOOL fNew;
    LONG lrt;
    INT nrt;

        lrt = cLicKey.Open( fNew, psdParams->pszComputer );
        nrt = AccessOk( NULL, lrt, FALSE );
        if (ERR_NONE == nrt)
        {
            CenterDialogToScreen( hwndDlg );
        
            SetStaticWithService( hwndDlg,
                IDC_STATICTITLE,
                psdParams->pszDisplayName,
                gSpecVerInfo.idsSpecVerText1 );

            if (IsRestrictedSmallBusSrv())
            {
                SetStaticUsers( hwndDlg,
                        IDC_STATICINFO,
                        gSpecVerInfo.dwSpecialUsers,
                        gSpecVerInfo.idsSpecVerText2 );
            }
            else
            {
                SetStaticWithService( hwndDlg,
                        IDC_STATICINFO,
                        psdParams->pszDisplayName,
                        gSpecVerInfo.idsSpecVerText2 );
            }

            // disable OK button at start!
            EnableWindow( hwndOK, FALSE );

            // if help is not defined, remove the button
            if (NULL == psdParams->pszHelpFile)
            {
                HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

                EnableWindow( hwndHelp, FALSE );
                ShowWindow( hwndHelp, SW_HIDE );
            }
            if (psdParams->fNoExit)
            {
                HWND hwndExit = GetDlgItem( hwndDlg, IDCANCEL );
                // remove the ExitSetup button
                EnableWindow( hwndExit, FALSE );
                ShowWindow( hwndExit, SW_HIDE );
            }

         }
         else
         {
                EndDialog( hwndDlg, nrt );
         }
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialSetupClose
//
//  Summary;
//              Do work needed when the Setup Dialog is closed.
//              Save to Reg the Service entry.
//
//      Arguments;
//              hwndDlg [in] - hwnd of dialog this close was requested on
//              fSave [in] - Save service to registry
//              psdParams [in] - used for the service name and displayname
//
//  History;
//              Nov-30-94       MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialSetupClose( HWND hwndDlg, BOOL fSave, PSETUPDLGPARAM psdParams ) 
{
        int nrt = fSave;

        if (fSave)
        {
                CLicRegLicenseService cLicServKey;

                cLicServKey.SetService( psdParams->pszService );
                cLicServKey.Open( psdParams->pszComputer );

                // configure license rule of one change from PerServer to PerSeat
                //
                cLicServKey.SetChangeFlag( TRUE );

                cLicServKey.SetMode( gSpecVerInfo.lmSpecialMode );
                cLicServKey.SetUserLimit( gSpecVerInfo.dwSpecialUsers );
                cLicServKey.SetDisplayName( psdParams->pszDisplayName );
        cLicServKey.SetFamilyDisplayName( psdParams->pszFamilyDisplayName );
                cLicServKey.Close();
        }
        EndDialog( hwndDlg, nrt );
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialAgree
//
//  Summary;
//              Handle the user interaction with the Agree Check box
//
//  Arguments;
//              hwndDlg [in] - the dialog to initialize
//
//  Return;
//              TRUE if succesful, otherwise false
//
//  Notes;
//
//      History;
//              Nov-11-1994     MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialAgree( HWND hwndDlg )
{
        HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
        BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
        
        CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
        EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocSPECIALSETUP
//
//  Summary;
//              The dialog procedure for the special version Setup Dialog,
//      which will replace all others
//
//  Arguments;
//              hwndDlg [in]    - handle of Dialog window 
//              uMsg [in]               - message                       
//              lParam1 [in]    - first message parameter
//              lParam2 [in]    - second message parameter       
//
//  Return;
//              message dependant
//
//  Notes;
//
//      History;
//              Jun-26-1995     MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocSPECIALSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
        BOOL frt = FALSE;
        static PSETUPDLGPARAM psdParams;

        switch (uMsg)
        {
        case WM_INITDIALOG:
                psdParams = (PSETUPDLGPARAM)lParam;
                OnSpecialInitDialog( hwndDlg, psdParams );
                frt = TRUE; // we use the default focus
                break;

        case WM_COMMAND:
                switch (HIWORD( wParam ))
                {
                case BN_CLICKED:
                        switch (LOWORD( wParam ))
                        {
                        case IDOK:
                                frt = TRUE;      // use as save flag
                                // intentional no break

                        case IDCANCEL:
                            OnSpecialSetupClose( hwndDlg, frt, psdParams );
                                frt = FALSE;
                                break;

                        case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                                break;

                        case IDC_AGREE:
                                OnSpecialAgree( hwndDlg );
                                break;

                        default:
                                break;
                        }
                        break;

                default:
                        break;
                }
                break;

        default:
        if (PWM_HELP == uMsg)
        {
                        ::HtmlHelp( hwndDlg,
                                     LICCPA_HTMLHELPFILE,
                                     HH_DISPLAY_TOPIC,
                                     0);
        }
                break;
        }
        return( frt );
}

//-------------------------------------------------------------------
//
//  Function: SpecialSetupDialog
//
//  Summary;
//              Init and raises Per Seat only setup dialog.
//
//  Arguments;
//              hwndDlg [in]    - handle of Dialog window 
//              dlgParem [in]   - Setup params IDC_BUTTONHELP
//
//  Return;
//              1 - OK button was used to exit
//              0 - Cancel button was used to exit
//         -1 - General Dialog error
//
//  Notes;
//
//      History;
//              Dec-05-1994     MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR SpecialSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
        return( DialogBoxParam( g_hinst, 
                MAKEINTRESOURCE(IDD_SPECIALSETUP), 
                hwndParent, 
                dlgprocSPECIALSETUP,
                (LPARAM)&dlgParam ) );
} 

//-------------------------------------------------------------------
//
//  Function: GetSpecialUsers
//
//  Summary;
//              Gets the number of licensed users from the registry.
//
//  Arguments;
//              none
//  Return;
//              The number of licensed users
//
//  Notes;
//
//      History;
//              Aug-18-97     GeorgeJe Created
//
//-------------------------------------------------------------------

DWORD GetSpecialUsers( VOID )
{
    LONG rVal;
    DWORD Disposition;
    HKEY hKey;
    DWORD Type;
    DWORD Size = sizeof(DWORD);
    DWORD Value;

    rVal = RegCreateKeyEx(
                     HKEY_LOCAL_MACHINE,
                     REGKEY_LICENSEINFO_SBS,
                     0,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     KEY_READ,
                     NULL,
                     &hKey,
                     &Disposition
                     );

    if (rVal != ERROR_SUCCESS) {
        return DEFAULT_SPECIAL_USERS;
    }
    
    rVal = RegQueryValueEx(
                     hKey,
                     REGVAL_CONCURRENT_LIMIT,
                     0,
                     &Type,
                     (LPBYTE) &Value,
                     &Size
                     );

    RegCloseKey( hKey );

    return (rVal == ERROR_SUCCESS ? Value : DEFAULT_SPECIAL_USERS);
}

const WCHAR wszProductOptions[] =
        L"System\\CurrentControlSet\\Control\\ProductOptions";

const WCHAR wszProductSuite[] =
                        L"ProductSuite";
const WCHAR wszSBSRestricted[] =
                        L"Small Business(Restricted)";

BOOL IsRestrictedSmallBusSrv( void )

/*++

Routine Description:

    Check if this server is a Microsoft small business restricted server.

Arguments:

    None.

Return Values:

    TRUE  -- This server is a restricted small business server.
    FALSE -- No such restriction.

--*/

{
    WCHAR  wszBuffer[1024] = L"";
    DWORD  cbBuffer = sizeof(wszBuffer);
    DWORD  dwType;
    LPWSTR pwszSuite;
    HKEY   hKey;
    BOOL   bRet = FALSE;

    //
    // Check if this server is a Microsoft small business restricted server.
    // Do so by checking for the existence of the string
    //     "Small Business(Restricted)"
    // in the MULTI_SZ "ProductSuite" value under
    //      HKLM\CurrentCcntrolSet\Control\ProductOptions.
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     wszProductOptions,
                     0,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey,
                            wszProductSuite,
                            NULL,
                            &dwType,
                            (LPBYTE)wszBuffer,
                            &cbBuffer) == ERROR_SUCCESS)
        {
            if (dwType == REG_MULTI_SZ && *wszBuffer)
            {
                pwszSuite = wszBuffer;

                while (*pwszSuite)
                {
                    if (lstrcmpi(pwszSuite, wszSBSRestricted) == 0)
                    {
                        bRet = TRUE;
                        break;
                    }
                    pwszSuite += wcslen(pwszSuite) + 1;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\test\licsetup\ctls.h ===
#ifdef __cplusplus
extern "C"
{
#endif

//
// Bitmap control routines.
//
BOOL
InitializeBmpClass(
    VOID
    );

VOID
DestroyBmpClass(
    VOID
    );

BOOL
RegisterActionItemListControl(
    IN BOOL Init
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\test\licsetup\resource.h ===
#define  IDC_STATICTITLE   100

#define  IDD_START_PAGE    1000
#define  IDD_FINISH_PAGE   1001

#define  IDB_WELCOME       1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\remote.bvt\licbvtrm.cpp ===
//-------------------------------------------------------------------
//
//  FILE: LicBvtRm.Cpp
//
//  Summary;
// 		The License Setup Remote Routines BVT
//
//	Notes;
//
//	History
//		4/25/95 MikeMi Created
//
//-------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>

typedef BOOL (CALLBACK* CPLSETUPPROC)(INT, LPSTR[], LPSTR* );

//BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult )

#define szBOOL( ftf ) ftf?"TRUE":"FALSE"

//-------------------------------------------------------------------

void PressNGo()
{
    printf( "press enter to continue..." );
    getchar();
    printf( "\n" );
}

//-------------------------------------------------------------------
void RemoteUnattedned( CPLSETUPPROC prf, LPSTR pszComputer )
{
    BOOL frt;
    LPSTR apszArgs[7];
    LPSTR pszReturn;

    printf( "RemoteUnattened " );

    // your cool code here
    apszArgs[0] = "RemoteUnattended" ;
    apszArgs[1] = pszComputer;
    apszArgs[2] = "CoolService";
    apszArgs[3] = "Microsoft's CoolService";
    apszArgs[4] = "Microsoft's CoolService for the hip 2.51";
    apszArgs[5] = "PerSeat";
    apszArgs[6] = "0";

    frt = prf( 7, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n");
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void RemoteSetup( CPLSETUPPROC prf, LPSTR pszComputer, LPSTR szRoutine )
{
    BOOL frt;
    LPSTR apszArgs[10];
    LPSTR pszReturn;

    printf( "%s ", szRoutine );

    apszArgs[0] = szRoutine;
    apszArgs[1] = pszComputer;
    apszArgs[2] = "0";
    apszArgs[3] = "CoolService";
    apszArgs[4] = "Microsoft's CoolService";
    apszArgs[5] = "Microsoft's CoolService for the hip 2.51";
    
    frt = prf( 6, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n\n" );
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void LocalSetup( CPLSETUPPROC prf, LPSTR szRoutine )
{
    BOOL frt;
    LPSTR apszArgs[10];
    LPSTR pszReturn;

    printf( "%s ", szRoutine );

    apszArgs[0] = szRoutine;
    apszArgs[1] = "0";
    apszArgs[2] = "CoolService";
    apszArgs[3] = "Microsoft's CoolService";
    apszArgs[4] = "Microsoft's CoolService for the hip 2.51";
    
    frt = prf( 5, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n\n" );
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void LocalUnattedned( CPLSETUPPROC prf, LPSTR pszComputer )
{
    BOOL frt;
    LPSTR apszArgs[7];
    LPSTR pszReturn;

    printf( "Unattened " );

    // your cool code here
    apszArgs[0] = "Unattended" ;
    apszArgs[1] = "CoolService";
    apszArgs[2] = "Microsoft's CoolService";
    apszArgs[3] = "Microsoft's CoolService for the hip 2.51";
    apszArgs[4] = "PerSeat";
    apszArgs[5] = "0";

    frt = prf( 6, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n");
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void RunTests( CPLSETUPPROC pfn, LPSTR pszComputer )
{
    /*
    RemoteUnattedned( pfn, pszComputer );
    PressNGo();

    RemoteSetup( pfn, pszComputer, "RemotePerSeat" );
    PressNGo();
    
    RemoteSetup( pfn, pszComputer, "RemoteFullSetup" );
    
    PressNGo();

    RemoteSetup( pfn, pszComputer, "RemoteFullSetupNoExit" );
    
    */
    
    LocalUnattedned( pfn, pszComputer );
    PressNGo();

    LocalSetup( pfn, "PerSeat" );
    PressNGo();
    
    LocalSetup( pfn, "FullSetup" );
    
    PressNGo();

    LocalSetup( pfn, "FullSetupNoExit" );
    
    

}

//-------------------------------------------------------------------

void _cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
    HINSTANCE hinstLicCpa;
    CPLSETUPPROC   pfn;
    LPSTR pszComputer;

    printf( "LicBvtRm.Exe - The License Setup (Remote) Build Verification Test\n" );

    if (argc <= 2)
    {
        if (argc == 1)
        {
            pszComputer = NULL;
        }
        else
        {
            pszComputer = argv[1];
        }
        hinstLicCpa = LoadLibrary( L"LicCpa.Cpl" );
        if (NULL != hinstLicCpa)
        {
            pfn = (CPLSETUPPROC)GetProcAddress( hinstLicCpa, "CPlSetup" );
            if (NULL != pfn)
            {
                RunTests( pfn, pszComputer );
            }
            else
            {
                printf( "GetProcAddress Failed\n" );
            }
            FreeLibrary( hinstLicCpa );
            PressNGo();

        }
        else
        {
            printf( "LoadLibary Failed\n" );
        }
    }
    else
    {
        printf( "This test requires a computername (ie: \\\\Wombat),\n" );
        printf( "  or nothing, meaning local.\n\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\test\licsetup\licsetup.cpp ===
//-------------------------------------------------------------------
//
// File:
//
// Summary;
//
// Notes;
//
// History
//
//-------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <syssetup.h>
#include "resource.h"
#include "ctls.h"

#ifdef UNICODE
#  define TSTR_FMT "%ls"
#else
#  define TSTR_FMT "%s"
#endif

static
BOOL
TestInteractive(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages );

static
BOOL
TestBatch(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages );

static
BOOL
CALLBACK
StartPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam );

static
BOOL
CALLBACK
FinishPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam );

static
void
SetLargeDialogFont(
   HWND hdlg,
   UINT ControlId );

static
BOOL
LicenseKeysSave();

static
BOOL
LicenseKeysDelete();

static
BOOL
LicenseKeysRestore();

static
BOOL
LicenseKeysVerify(
   BOOL     fShouldBePresent,
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses );

static
DWORD
MyRegDeleteKey(
   HKEY     hKeyParent,
   LPCTSTR  pcszKeyName );

TCHAR    g_szWizardTitle[]       = TEXT( "License Setup Test" );

TCHAR    g_szKeyLicenseService[] = TEXT( "System\\CurrentControlSet\\Services\\LicenseService" );
TCHAR    g_szKeyLicenseInfo[]    = TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" );
TCHAR    g_szKeyEventLog[]       = TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" );

LPTSTR   g_apszKeys[] =
{
   g_szKeyLicenseService,
   g_szKeyLicenseInfo,
   g_szKeyEventLog,
   NULL
};

TCHAR    g_szTempPath[ 1 + MAX_PATH ];

// paths to file in which to save license registry information
TCHAR    g_szKeyFileLicenseService[ 1 + MAX_PATH ];
TCHAR    g_szKeyFileLicenseInfo[    1 + MAX_PATH ];
TCHAR    g_szKeyFileEventLog[       1 + MAX_PATH ];

int _cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
   BOOL                       fSuccess;
   HINSTANCE                  hLicCpa;
   NETSETUPPAGEREQUESTPROC    pfnRequestPages;
   BOOL                       fIsInteractive;
   BOOL                       fIsUsage;
   BOOL                       fIsRestore;
   LPSTR                      pszBadArg;

   printf( "\nLicense Setup Wizard Page Test for LICCPA.CPL\n\n" );

   fIsInteractive = FALSE;
   fIsUsage       = FALSE;
   fIsRestore     = FALSE;
   pszBadArg      = NULL;

   if ( 1 == argc )
   {
      printf( "Use \"%s /?\" for a list of command-line options.\n\n", argv[ 0 ] );
   }
   else
   {
      int      cCurArg;
      LPSTR *  ppszCurArg;

      for ( cCurArg = 1, ppszCurArg = argv;
            (    ( !fIsUsage         )
              && ( NULL == pszBadArg )
              && ( cCurArg < argc    ) );
            cCurArg++ )
      {
         ++ppszCurArg;

         if (    (    ( '-' == (*ppszCurArg)[ 0 ] )
                   || ( '/' == (*ppszCurArg)[ 0 ] ) )
              && ( '\0'     != (*ppszCurArg)[ 1 ]   ) )
         {
            DWORD    cchOption;

            cchOption = strlen( &( (*ppszCurArg)[ 1 ] ) );

            if ( !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "interactive", min( cchOption, strlen( "interactive" ) ) ) )
            {
               fIsInteractive = TRUE;
            }
            else if (    !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "help", min( cchOption, strlen( "help" ) ) )
                      || !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "?",    min( cchOption, strlen( "?"    ) ) ) )
            {
               fIsUsage = TRUE;
            }
            else if ( !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "restore", min( cchOption, strlen( "restore" ) ) ) )
            {
               fIsRestore = TRUE;
            }
            else
            {
               pszBadArg = *ppszCurArg;
            }
         }
         else
         {
            pszBadArg = *ppszCurArg;
         }
      }
   }

   if ( NULL != pszBadArg )
   {
      printf( "The argument \"%s\" is unrecognized.\n"
              "Use \"%s /?\" for a list of command-line options.\n",
              pszBadArg,
              argv[ 0 ] );

      fSuccess = FALSE;
   }
   else if ( fIsUsage )
   {
      printf( "Options: [ /? | /H | /HELP ]   Display option list.\n"
              "         [ /INTERACTIVE ]      Test the wizard page interactively.\n"
              "         [ /RESTORE ]          Restore licensing registry keys in the\n"
              "                               event that a program error kept them from\n"
              "                               being restored in a previous run.\n" );

      fSuccess = TRUE;
   }
   else
   {
      DWORD    cchTempPath;

      fSuccess = FALSE;

      cchTempPath = GetTempPath( sizeof( g_szTempPath ) / sizeof( *g_szTempPath ), g_szTempPath );

      if ( 0 == cchTempPath )
      {
         printf( "GetTempPath() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         lstrcpy( g_szKeyFileLicenseService, g_szTempPath );
         lstrcpy( g_szKeyFileLicenseInfo,    g_szTempPath );
         lstrcpy( g_szKeyFileEventLog,       g_szTempPath );

         lstrcat( g_szKeyFileLicenseService, TEXT( "jbplskey" ) );
         lstrcat( g_szKeyFileLicenseInfo,    TEXT( "jbplikey" ) );
         lstrcat( g_szKeyFileEventLog,       TEXT( "jbpelkey" ) );

         if ( fIsRestore )
         {
            fSuccess = LicenseKeysRestore();
         }
         else
         {
            BOOL ok;

            fSuccess = FALSE;

            // init common control library
            InitCommonControls();

            ok = InitializeBmpClass();

            if ( !ok )
            {
               printf( "InitializeBmpClass() Failed!\n" );
            }
            else
            {
               hLicCpa = LoadLibrary( TEXT( "LicCpa.Cpl" ) );

               if ( NULL == hLicCpa )
               {
                  printf( "LoadLibary() Failed!\n" );
               }
               else
               {
                  pfnRequestPages = (NETSETUPPAGEREQUESTPROC) GetProcAddress( hLicCpa, "LicenseSetupRequestWizardPages" );

                  if ( NULL == pfnRequestPages )
                  {
                     printf( "GetProcAddress() Failed!\n" );
                  }
                  else if ( fIsInteractive )
                  {
                     fSuccess = TestInteractive( pfnRequestPages );
                  }
                  else
                  {
                     fSuccess = TestBatch( pfnRequestPages );
                  }

                  FreeLibrary( hLicCpa );
               }
            }

            if ( fSuccess )
            {
               printf( "\nTest completed successfully.\n" );
            }
            else
            {
               printf( "\nTest failed!\n" );
            }
         }
      }
   }

   return fSuccess ? 0 : -1;
}


static
BOOL
TestInteractive(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages )
{
   BOOL                 fSuccess;
   UINT                 chpages;
   INTERNAL_SETUP_DATA  SetupData;
   BOOL                 ok;

   fSuccess = LicenseKeysSave();

   if ( fSuccess )
   {
      SetupData.dwSizeOf          = sizeof( SetupData );
      SetupData.SetupMode         = SETUPMODE_CUSTOM;
      SetupData.ProductType       = PRODUCT_SERVER_PRIMARY;
      SetupData.OperationFlags    = 0; // SETUPOPER_NTUPGRADE;
      SetupData.WizardTitle       = g_szWizardTitle;
      SetupData.SourcePath        = NULL;
      SetupData.UnattendFile      = NULL;
      SetupData.LegacySourcePath  = NULL;

      // get number pages the wizard needs
      ok = (*pfnRequestPages)( NULL, &chpages, &SetupData );

      if ( !ok )
      {
         // request number of pages failure
         printf( "Cannot retrieve number of pages!\n" );
      }
      else
      {
         HPROPSHEETPAGE *  phpage;

         // we will add anm intro and a finish page
         phpage = new HPROPSHEETPAGE[ chpages + 2 ];

         if ( NULL == phpage )
         {
            // memory allocation failue
            printf( "Cannot allocate memory!\n" );
         }
         else
         {
            ok = (*pfnRequestPages)( &phpage[ 1 ], &chpages, &SetupData );

            if ( !ok )
            {
               // request number of pages failure
               printf( "Cannot retrieve pages!\n" );
            }
            else
            {
               PROPSHEETPAGE  psp;

               psp.dwSize        = sizeof( psp );
               psp.dwFlags       = PSP_USETITLE;
               psp.hInstance     = GetModuleHandle( NULL );
               psp.pszTemplate   = MAKEINTRESOURCE( IDD_START_PAGE );
               psp.hIcon         = NULL;
               psp.pfnDlgProc    = StartPageDlgProc;
               psp.pszTitle      = SetupData.WizardTitle;
               psp.lParam        = 0;
               psp.pfnCallback   = NULL;

               phpage[ 0 ] = CreatePropertySheetPage( &psp );

               if ( NULL == phpage[ 0 ] )
               {
                  printf( "Cannot create start page!\n" );
               }
               else
               {
                  psp.dwSize        = sizeof( psp );
                  psp.dwFlags       = PSP_USETITLE;
                  psp.hInstance     = GetModuleHandle( NULL );
                  psp.pszTemplate   = MAKEINTRESOURCE( IDD_FINISH_PAGE );
                  psp.hIcon         = NULL;
                  psp.pfnDlgProc    = FinishPageDlgProc;
                  psp.pszTitle      = SetupData.WizardTitle;
                  psp.lParam        = 0;
                  psp.pfnCallback   = NULL;

                  phpage[ chpages + 1 ] = CreatePropertySheetPage( &psp );

                  if ( NULL == phpage[ chpages + 1 ] )
                  {
                     printf( "Cannot create finish page!\n" );
                  }
                  else
                  {
                     PROPSHEETHEADER   psh;
                     int               nResult;

                     // prep frame header
                     psh.dwSize        = sizeof( psh );
                     psh.dwFlags       = PSH_WIZARD;
                     psh.hwndParent    = NULL;
                     psh.hInstance     = GetModuleHandle( NULL );
                     psh.hIcon         = NULL;
                     psh.pszCaption    = NULL;
                     psh.nPages        = chpages + 2;
                     psh.nStartPage    = 0;
                     psh.phpage        = phpage;
                     psh.pfnCallback   = NULL;

                     // raise frame
                     PropertySheet( &psh );

                     fSuccess = TRUE;
                  }
               }
            }

            delete [] phpage;
         }
      }

      fSuccess = LicenseKeysRestore() && fSuccess;
   }

   return fSuccess;
}

static
BOOL
CALLBACK
StartPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
{
   static   BOOL  fIsBatch;

   BOOL     ok = TRUE;
   LPNMHDR  pnmh;

   switch ( msg )
   {
   case WM_INITDIALOG:
      fIsBatch = ( (LPPROPSHEETPAGE)lParam )->lParam;
      SetLargeDialogFont( hdlg, IDC_STATICTITLE );
      break;

   case WM_NOTIFY:
      pnmh = (LPNMHDR)lParam;

      switch (pnmh->code)
      {
      // propsheet notification
      case PSN_HELP:
         break;

      case PSN_SETACTIVE:
         // hide Cancel button
         EnableWindow( GetDlgItem( GetParent( hdlg ), IDCANCEL ), FALSE);
         ShowWindow(   GetDlgItem( GetParent( hdlg ), IDCANCEL ), SW_HIDE);

         PropSheet_SetWizButtons( GetParent( hdlg ), PSWIZB_NEXT );

         if ( fIsBatch )
         {
            // batch mode
            PostMessage( GetParent( hdlg ), PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0 );
         }

         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_KILLACTIVE:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_WIZFINISH:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      default:
         ok = TRUE;
         break;
      }
      break;

   default:
      ok = FALSE;
   }

   return ok;
}


static
BOOL
CALLBACK
FinishPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
{
   static   BOOL  fIsBatch;

   BOOL     ok = TRUE;
   LPNMHDR  pnmh;

   switch ( msg )
   {
   case WM_INITDIALOG:
      fIsBatch = ( (LPPROPSHEETPAGE)lParam )->lParam;
      SetLargeDialogFont( hdlg, IDC_STATICTITLE );
      break;

   case WM_NOTIFY:
      pnmh = (LPNMHDR)lParam;

      switch (pnmh->code)
      {
      // propsheet notification
      case PSN_HELP:
         break;

      case PSN_SETACTIVE:
         // hide Cancel button
         EnableWindow( GetDlgItem( GetParent( hdlg ), IDCANCEL ), FALSE);
         ShowWindow(   GetDlgItem( GetParent( hdlg ), IDCANCEL ), SW_HIDE);

         PropSheet_SetWizButtons( GetParent( hdlg ), PSWIZB_BACK | PSWIZB_FINISH );

         if ( fIsBatch )
         {
            // batch mode
            PostMessage( GetParent( hdlg ), PSM_PRESSBUTTON, (WPARAM)PSBTN_FINISH, 0 );
         }

         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_KILLACTIVE:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_WIZFINISH:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      default:
         ok = TRUE;
         break;
      }
      break;

   default:
      ok = FALSE;
   }

   return ok;
}


static
void
SetLargeDialogFont(
   HWND hdlg,
   UINT ControlId )

/*++

Routine Description:

    Sets the font of a given control in a dialog to a
    larger point size.

    (Lifted from SetupSetLargeDialogFont() in
    \nt\private\windows\setup\syssetup\wizard.c.)

Arguments:

    hwnd - supplies window handle of the dialog containing
        the control.

    ControlId - supplies the id of the control whose font is
        to be made larger.

Return Value:

    None.

--*/

{
   //
   // We keep one log font around to satisfy the request.
   //
   static HFONT BigFont = NULL;

   HFONT    Font;
   LOGFONT  LogFont;
   WCHAR    str[24];
   int      Height;
   HDC      hdc;

   if ( !BigFont )
   {
      Font = (HFONT)SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 );

      if ( NULL != Font )
      {
         if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
         {
            //
            // Use a larger font in boldface. Get the face name and size in points
            // from the resources. We use 18 point in the U.S. but in the Far East
            // they will want to use a different size since the standard dialog font
            // is larger than the one we use in the U.S..
            //
            LogFont.lfWeight = FW_BOLD;

            lstrcpy( LogFont.lfFaceName, TEXT( "MS Serif" ) );
            Height = 18;

            hdc = GetDC( hdlg );

            if ( NULL != hdc )
            {
               // create font
               LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * Height / 72 );

               BigFont = CreateFontIndirect( &LogFont );

               ReleaseDC( hdlg, hdc );
            }
         }
      }
   }

   if ( NULL != BigFont )
   {
      // change font of ControlId to BigFont
      SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM)BigFont, MAKELPARAM( TRUE, 0 ) );
   }
}


static
BOOL
TestBatch(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages )
{
   BOOL     fSuccess;

   fSuccess = FALSE;

   // save registry keys before we go and overwrite them
   fSuccess = LicenseKeysSave();

   if ( fSuccess )
   {
      TCHAR    szTempFile[ 1 + MAX_PATH ];
      DWORD    cchTempFile;

      cchTempFile = GetTempFileName( g_szTempPath, TEXT( "JBP" ), 0, szTempFile );

      if ( 0 == cchTempFile )
      {
         printf( "GetTempFileName() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         HANDLE   hUnattendFile;

         hUnattendFile = CreateFile( szTempFile,
                                     GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                     NULL );

         if ( NULL == hUnattendFile )
         {
            printf( "CreateFile() on \""TSTR_FMT"\" failed, error %lu.\n",
                     szTempFile,
                     GetLastError() );
         }
         else
         {
            struct UnattendEntry
            {
               LPSTR    pszFileContents;
               BOOL     fLicensePerServer;
               DWORD    cPerServerLicenses;
            };

            static UnattendEntry aUnattendEntries[] =
            {
               { "[licensefileprintdata]\nautomode=perseat\nautousers=0\n",    FALSE, 0   },
               { "[licensefileprintdata]\nautomode=perseat\nautousers=100\n",  FALSE, 100 },
               { "[licensefileprintdata]\nautomode=perserver\nautousers=42\n", TRUE,  42  },
               { "[licensefileprintdata]\nautomode=perserver\nautousers=0\n",  TRUE,  0   },
               { NULL,                                                         FALSE, 0   }
            };

            DWORD    iEntry;

            for ( iEntry=0;
                  fSuccess && ( NULL != aUnattendEntries[ iEntry ].pszFileContents );
                  iEntry++ )
            {
               // delete current licensing info in registry
               fSuccess = LicenseKeysDelete();

               if ( fSuccess )
               {
                  DWORD    cbFilePos;

                  // erase file
                  cbFilePos = SetFilePointer( hUnattendFile, 0, NULL, FILE_BEGIN );

                  if ( 0xFFFFFFFF == cbFilePos )
                  {
                     printf( "SetFilePointer() failed, error %lu.\n", GetLastError() );
                  }
                  else
                  {
                     BOOL  ok;

                     ok = SetEndOfFile( hUnattendFile );

                     if ( !ok )
                     {
                        printf( "SetEndOfFile() failed, error %lu.\n", GetLastError() );
                     }
                     else
                     {
                        DWORD    cbBytesWritten;

                        // write new unattend file contents
                        ok = WriteFile( hUnattendFile,
                                        aUnattendEntries[ iEntry ].pszFileContents,
                                        lstrlenA( aUnattendEntries[ iEntry ].pszFileContents ),
                                        &cbBytesWritten,
                                        NULL );

                        if ( !ok )
                        {
                           printf( "WriteFile() failed, error %lu.\n", GetLastError() );
                        }
                        else
                        {
                           // run setup with this unattend file
                           UINT                 chpages;
                           INTERNAL_SETUP_DATA  SetupData;
                           BOOL                 ok;

                           fSuccess = FALSE;

                           SetupData.dwSizeOf          = sizeof( SetupData );
                           SetupData.SetupMode         = SETUPMODE_CUSTOM;
                           SetupData.ProductType       = PRODUCT_SERVER_PRIMARY;
                           SetupData.OperationFlags    = SETUPOPER_BATCH;
                           SetupData.WizardTitle       = g_szWizardTitle;
                           SetupData.SourcePath        = NULL;
                           SetupData.UnattendFile      = szTempFile;
                           SetupData.LegacySourcePath  = NULL;

                           // get number pages the wizard needs
                           ok = (*pfnRequestPages)( NULL, &chpages, &SetupData );

                           if ( !ok )
                           {
                              // request number of pages failure
                              printf( "Cannot retrieve number of pages!\n" );
                           }
                           else
                           {
                              HPROPSHEETPAGE *  phpage;

                              phpage = new HPROPSHEETPAGE[ chpages + 2 ];

                              if ( NULL == phpage )
                              {
                                 // memory allocation failue
                                 printf( "Cannot allocate memory!\n" );
                              }
                              else
                              {
                                 ok = (*pfnRequestPages)( &phpage[ 1 ], &chpages, &SetupData );

                                 if ( !ok )
                                 {
                                    // request number of pages failure
                                    printf( "Cannot retrieve pages!\n" );
                                 }
                                 else
                                 {
                                    PROPSHEETPAGE  psp;

                                    psp.dwSize        = sizeof( psp );
                                    psp.dwFlags       = PSP_USETITLE;
                                    psp.hInstance     = GetModuleHandle( NULL );
                                    psp.pszTemplate   = MAKEINTRESOURCE( IDD_START_PAGE );
                                    psp.hIcon         = NULL;
                                    psp.pfnDlgProc    = StartPageDlgProc;
                                    psp.pszTitle      = SetupData.WizardTitle;
                                    psp.lParam        = 1;
                                    psp.pfnCallback   = NULL;

                                    phpage[ 0 ] = CreatePropertySheetPage( &psp );

                                    if ( NULL == phpage[ 0 ] )
                                    {
                                       printf( "Cannot create start page!\n" );
                                    }
                                    else
                                    {
                                       psp.dwSize        = sizeof( psp );
                                       psp.dwFlags       = PSP_USETITLE;
                                       psp.hInstance     = GetModuleHandle( NULL );
                                       psp.pszTemplate   = MAKEINTRESOURCE( IDD_FINISH_PAGE );
                                       psp.hIcon         = NULL;
                                       psp.pfnDlgProc    = FinishPageDlgProc;
                                       psp.pszTitle      = SetupData.WizardTitle;
                                       psp.lParam        = 1;
                                       psp.pfnCallback   = NULL;

                                       phpage[ chpages + 1 ] = CreatePropertySheetPage( &psp );

                                       if ( NULL == phpage[ chpages + 1 ] )
                                       {
                                          printf( "Cannot create finish page!\n" );
                                       }
                                       else
                                       {
                                          PROPSHEETHEADER   psh;
                                          int               nResult;

                                          // prep frame header
                                          psh.dwSize        = sizeof( psh );
                                          psh.dwFlags       = PSH_WIZARD;
                                          psh.hwndParent    = NULL;
                                          psh.hInstance     = GetModuleHandle( NULL );
                                          psh.hIcon         = NULL;
                                          psh.pszCaption    = NULL;
                                          psh.nPages        = chpages + 2;
                                          psh.nStartPage    = 0;
                                          psh.phpage        = phpage;
                                          psh.pfnCallback   = NULL;

                                          // raise frame
                                          PropertySheet( &psh );

                                          fSuccess = LicenseKeysVerify( TRUE,
                                                                        aUnattendEntries[ iEntry ].fLicensePerServer,
                                                                        aUnattendEntries[ iEntry ].cPerServerLicenses );
                                       }
                                    }
                                 }

                                 delete [] phpage;
                              }
                           }
                        }
                     }
                  }
               }
            }

            CloseHandle( hUnattendFile );
         }
      }

      fSuccess = LicenseKeysRestore() && fSuccess;
   }

   return fSuccess;
}


static
BOOL
LicenseKeysSave()
{
   DWORD             winStatus;
   HANDLE            hToken;
   TOKEN_PRIVILEGES  tp;
   LUID              luid;
   BOOL              ok;

   // Enable backup privilege.
   ok = OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ) ;

   if ( !ok )
   {
      winStatus = GetLastError();
      printf( "OpenProcessToken() failed, error %lu.\n", winStatus );
   }
   else
   {
      ok = LookupPrivilegeValue( NULL, SE_BACKUP_NAME, &luid );

      if ( !ok )
      {
         winStatus = GetLastError();
         printf( "LookupPrivilegeValue() failed, error %lu.\n", winStatus );
      }
      else
      {
         tp.PrivilegeCount           = 1;
         tp.Privileges[0].Luid       = luid;
         tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

         ok = AdjustTokenPrivileges( hToken,
                                     FALSE,
                                     &tp,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL );

         if ( !ok )
         {
            winStatus = GetLastError();
            printf( "AdjustTokenPrivileges() failed, error %lu.\n", winStatus );
         }
         else
         {
            HKEY     hKeyLicenseService;
            HKEY     hKeyLicenseInfo;
            HKEY     hKeyEventLog;

            winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      g_szKeyLicenseService,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKeyLicenseService );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                       "   o Was the license service not properly installed?\n"
                       "   o Are you running on Workstation instead of Server?\n"
                       "   o Was the registry wiped and not restored in a previous run?\n"
                       "     (In this case, use the /RESTORE option!)\n",
                       g_szKeyLicenseService,
                       winStatus );
            }
            else
            {
               winStatus = RegSaveKey( hKeyLicenseService, g_szKeyFileLicenseService, NULL );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                          "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                          "   o Does the file \""TSTR_FMT"\" already exist?\n",
                          g_szKeyLicenseService,
                          winStatus,
                          g_szTempPath,
                          g_szKeyFileLicenseService );
               }
               else
               {
                  winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            g_szKeyLicenseInfo,
                                            0,
                                            KEY_ALL_ACCESS,
                                            &hKeyLicenseInfo );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                             "   o Was the license service not properly installed?\n"
                             "   o Are you running on Workstation instead of Server?\n",
                             "   o Was the registry wiped and not restored in a previous run?\n"
                             "     (In this case, use the /RESTORE option!)\n",
                             g_szKeyLicenseInfo,
                             winStatus );

                     DeleteFile( g_szKeyFileLicenseService );
                  }
                  else
                  {
                     winStatus = RegSaveKey( hKeyLicenseInfo, g_szKeyFileLicenseInfo, NULL );

                     if ( ERROR_SUCCESS != winStatus )
                     {
                        printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                                "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                                "   o Does the file \""TSTR_FMT"\" already exist?\n",
                                g_szKeyLicenseInfo,
                                winStatus,
                                g_szTempPath,
                                g_szKeyFileLicenseInfo );
                     }
                     else
                     {
                        winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                                  g_szKeyEventLog,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &hKeyEventLog );

                        if ( ERROR_SUCCESS != winStatus )
                        {
                           printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                                   "   o Was the license service not properly installed?\n"
                                   "   o Are you running on Workstation instead of Server?\n",
                                   "   o Was the registry wiped and not restored in a previous run?\n"
                                   "     (In this case, use the /RESTORE option!)\n",
                                   g_szKeyEventLog,
                                   winStatus );

                           DeleteFile( g_szKeyFileLicenseInfo );
                        }
                        else
                        {
                           winStatus = RegSaveKey( hKeyEventLog, g_szKeyFileEventLog, NULL );

                           if ( ERROR_SUCCESS != winStatus )
                           {
                              printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                                      "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                                      "   o Does the file \""TSTR_FMT"\" already exist?\n",
                                      g_szKeyEventLog,
                                      winStatus,
                                      g_szTempPath,
                                      g_szKeyFileEventLog );
                           }

                           RegCloseKey( hKeyEventLog );
                        }
                     }

                     RegCloseKey( hKeyLicenseInfo );
                  }
               }

               RegCloseKey( hKeyLicenseService );
            }

            // Disable backup privilege.
            AdjustTokenPrivileges( hToken,
                                   TRUE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL );
         }
      }
   }

   if ( ERROR_SUCCESS != winStatus )
   {
      printf( "The license info in the registry could not be saved!\n" );

      return FALSE;
   }
   else
   {
      printf( "The license info in the registry has been saved.\n" );

      return TRUE;
   }
}


static
BOOL
LicenseKeysDelete()
{
   DWORD    winStatus;
   DWORD    iKey;
   DWORD    iLastBackslash;

   SC_HANDLE   hSC;

   winStatus = ERROR_SUCCESS;

   hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

   if ( NULL == hSC )
   {
      winStatus = GetLastError();
      printf( "OpenSCManager() failed, error %lu.\n", winStatus );
   }
   else
   {
      SC_HANDLE   hLicenseService;

      hLicenseService = OpenService( hSC, TEXT( "LicenseService" ), SERVICE_ALL_ACCESS );

      if ( NULL == hLicenseService )
      {
         winStatus = GetLastError();

         if ( ERROR_SERVICE_DOES_NOT_EXIST == winStatus )
         {
            // license service not configured; no need to stop or delete
            winStatus = ERROR_SUCCESS;
         }
         else
         {
            printf( "OpenService() failed, error %lu.\n", winStatus );
         }
      }
      else
      {
         BOOL              ok;
         SERVICE_STATUS    SvcStatus;

         // stop license service
         ok = ControlService( hLicenseService,
                              SERVICE_CONTROL_STOP,
                              &SvcStatus );

         if ( !ok )
         {
            winStatus = GetLastError();

            if ( ERROR_SERVICE_NOT_ACTIVE == winStatus )
            {
               // license service not running; no need to stop
               winStatus = ERROR_SUCCESS;
            }
            else
            {
               printf( "ControlService() failed, error %lu.\n", winStatus );
            }
         }

         if (    ( ERROR_SUCCESS == winStatus                       )
              && ( SERVICE_STOP_PENDING == SvcStatus.dwCurrentState ) )
         {
            DWORD dwOldCheckPoint;

            printf( "License Service is stopping.." );

            ok = TRUE;

            while ( ok && ( SvcStatus.dwCurrentState == SERVICE_STOP_PENDING ) )
            {
               printf( "." );

               dwOldCheckPoint = SvcStatus.dwCheckPoint;
               Sleep( SvcStatus.dwWaitHint );

               ok = QueryServiceStatus( hLicenseService,
                                        &SvcStatus );

               if ( dwOldCheckPoint >= SvcStatus.dwCheckPoint )
                  break;
            }

            printf( "\n" );

            if ( !ok )
            {
               winStatus = GetLastError();
               printf( "ControlService() failed, error %lu.\n", winStatus );
            }
            else if ( SvcStatus.dwCurrentState != SERVICE_STOPPED )
            {
               winStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
               printf( "License Service failed to stop!\n" );
            }
            else
            {
               winStatus = ERROR_SUCCESS;
               printf( "License Service stopped.\n" );
            }
         }

         if ( ERROR_SUCCESS == winStatus )
         {
            // delete service
            ok = DeleteService( hLicenseService );

            if ( !ok )
            {
               winStatus = GetLastError();
               printf( "DeleteService() failed, error %lu.\n", winStatus );
            }
            else
            {
               winStatus = ERROR_SUCCESS;
               printf( "License Service deleted.\n" );
            }
         }

         CloseServiceHandle( hLicenseService );
      }

      CloseServiceHandle( hSC );
   }

   if ( ERROR_SUCCESS == winStatus )
   {
      // delete keys
      for ( iKey=0, winStatus = ERROR_SUCCESS;
            ( NULL != g_apszKeys[ iKey ] ) && ( ERROR_SUCCESS == winStatus );
            iKey++ )
      {
         TCHAR    szKeyParent[ 1 + MAX_PATH ];
         TCHAR    szKey[ 1 + MAX_PATH ];
         HKEY     hKeyParent;

         lstrcpy( szKeyParent, g_apszKeys[ iKey ] );

         for ( iLastBackslash = lstrlen( szKeyParent ) - 1;
               TEXT( '\\' ) != szKeyParent[ iLastBackslash ];
               iLastBackslash-- )
         {
            ;
         }

         szKeyParent[ iLastBackslash ] = TEXT( '\0' );
         lstrcpy( szKey, &szKeyParent[ iLastBackslash + 1 ] );

         winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                   szKeyParent,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKeyParent );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n",
                    szKeyParent,
                    winStatus );
         }
         else
         {
            winStatus = MyRegDeleteKey( hKeyParent, szKey );

            if ( ERROR_FILE_NOT_FOUND == winStatus )
            {
               winStatus = ERROR_SUCCESS;
            }
            else if ( ERROR_SUCCESS != winStatus )
            {
               printf( "MyRegDeleteKey() on \""TSTR_FMT"\" failed, error %lu.\n",
                       g_apszKeys[ iKey ],
                       winStatus );
            }

            RegCloseKey( hKeyParent );
         }
      }
   }

   if ( ERROR_SUCCESS != winStatus )
   {
      printf( "Could not delete licensing registry keys!\n" );

      return FALSE;
   }
   else
   {
      printf( "Licensing registry keys deleted.\n" );

      return TRUE;
   }
}


static
BOOL
LicenseKeysRestore()
{
   DWORD             winStatus;
   DWORD             winStatusRestoreLicenseService;
   DWORD             winStatusRestoreLicenseInfo;
   DWORD             winStatusRestoreEventLog;

   HANDLE            hToken;
   TOKEN_PRIVILEGES  tp;
   LUID              luid;
   BOOL              ok;

   winStatus = ERROR_SUCCESS;

   // Enable backup privilege.
   ok = OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ) ;

   if ( !ok )
   {
      winStatus = GetLastError();
      printf( "OpenProcessToken() failed, error %lu.\n", winStatus );
   }
   else
   {
      ok = LookupPrivilegeValue( NULL, SE_RESTORE_NAME, &luid );

      if ( !ok )
      {
         winStatus = GetLastError();
         printf( "LookupPrivilegeValue() failed, error %lu.\n", winStatus );
      }
      else
      {
         tp.PrivilegeCount           = 1;
         tp.Privileges[0].Luid       = luid;
         tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

         ok = AdjustTokenPrivileges( hToken,
                                     FALSE,
                                     &tp,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL );

         if ( !ok )
         {
            winStatus = GetLastError();
            printf( "AdjustTokenPrivileges() failed, error %lu.\n", winStatus );
         }
         else
         {
            HKEY     hKeyLicenseService;
            HKEY     hKeyLicenseInfo;
            HKEY     hKeyEventLog;
            DWORD    dwDisposition;

            winStatusRestoreLicenseService = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                             g_szKeyLicenseService,
                                                             0,
                                                             NULL,
                                                             0,
                                                             KEY_ALL_ACCESS,
                                                             NULL,
                                                             &hKeyLicenseService,
                                                             &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreLicenseService )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyLicenseService,
                       winStatusRestoreLicenseService );
            }
            else
            {
               winStatusRestoreLicenseService = RegRestoreKey( hKeyLicenseService, g_szKeyFileLicenseService, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreLicenseService )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyLicenseService,
                          winStatusRestoreLicenseService );
               }
               else
               {
                  DeleteFile( g_szKeyFileLicenseService );
               }

               RegCloseKey( hKeyLicenseService );
            }

            winStatusRestoreLicenseInfo = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                          g_szKeyLicenseInfo,
                                                          0,
                                                          NULL,
                                                          0,
                                                          KEY_ALL_ACCESS,
                                                          NULL,
                                                          &hKeyLicenseInfo,
                                                          &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreLicenseInfo )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyLicenseInfo,
                       winStatusRestoreLicenseInfo );
            }
            else
            {
               winStatusRestoreLicenseInfo = RegRestoreKey( hKeyLicenseInfo, g_szKeyFileLicenseInfo, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreLicenseInfo )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyLicenseInfo,
                          winStatusRestoreLicenseInfo );
               }
               else
               {
                  DeleteFile( g_szKeyFileLicenseInfo );
               }

               RegCloseKey( hKeyLicenseInfo );
            }

            winStatusRestoreEventLog = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                       g_szKeyEventLog,
                                                       0,
                                                       NULL,
                                                       0,
                                                       KEY_ALL_ACCESS,
                                                       NULL,
                                                       &hKeyEventLog,
                                                       &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreEventLog )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyEventLog,
                       winStatusRestoreEventLog );
            }
            else
            {
               winStatusRestoreEventLog = RegRestoreKey( hKeyEventLog, g_szKeyFileEventLog, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreEventLog )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyEventLog,
                          winStatusRestoreEventLog );
               }
               else
               {
                  DeleteFile( g_szKeyFileEventLog );
               }

               RegCloseKey( hKeyEventLog );
            }

            // Disable backup privilege.
            AdjustTokenPrivileges( hToken,
                                   TRUE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL );
         }
      }
   }

   if (    ( ERROR_SUCCESS != winStatus                      )
        || ( ERROR_SUCCESS != winStatusRestoreLicenseService )
        || ( ERROR_SUCCESS != winStatusRestoreLicenseInfo    )
        || ( ERROR_SUCCESS != winStatusRestoreEventLog       ) )
   {
      printf( "!! WARNING !!  The license info in the registry has not been fully restored!\n" );

      return FALSE;
   }
   else
   {
      printf( "The license info in the registry has been fully restored.\n" );

      return TRUE;
   }
}

static
DWORD
MyRegDeleteKey(
   HKEY     hKeyParent,
   LPCTSTR  pcszKeyName )
{
   DWORD    winStatus;
   TCHAR    szSubKeyToDelete[ 256 ];
   HKEY     hKey;

   // try to delete it outright
   winStatus = RegDeleteKey( hKeyParent, pcszKeyName );

   if ( ERROR_SUCCESS != winStatus )
   {
      // could not delete it; perhaps the key has children
      // that we must delete first?
      winStatus = RegOpenKeyEx( hKeyParent,
                                pcszKeyName,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey );

      if ( ERROR_SUCCESS == winStatus )
      {
         do
         {
            winStatus = RegEnumKey( hKey,
                                    0,
                                    szSubKeyToDelete,
                                    sizeof( szSubKeyToDelete ) / sizeof( *szSubKeyToDelete ) );

            if ( ERROR_SUCCESS == winStatus )
            {
               // recursively try to delete this subkey
               winStatus = MyRegDeleteKey( hKey, szSubKeyToDelete );
            }
         } while ( ERROR_SUCCESS == winStatus );

         // we've tried tried to delete all the key's children;
         // try deleting the key again
         winStatus = RegDeleteKey( hKeyParent, pcszKeyName );
      }
   }

   return winStatus;
}


static
BOOL
LicenseKeysVerify(
   BOOL     fShouldBePresent,
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses )
//
// Verify service config:
//
//    lpServiceName        = "LicenseService"
//    lpDisplayName        = "License Logging Service"
//    dwServiceType        = SERVICE_WIN32_OWN_PROCESS
//    dwStartType          = LanManServerInstalled ? SERVICE_AUTO_START : SERVICE_DISABLED
//    dwErrorControl       = SERVICE_ERROR_NORMAL
//    lpBinaryPathName     = "%SystemRoot%\\System32\\llssrv.exe"
//    lpLoadOrderGroup     = NULL
//    lpdwTagId            = NULL
//    lpDependencies       = NULL
//    lpServiceStartName   = NULL
//    lpPassword           = NULL
//
// Verify registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseInfo
//                      ErrorControl : REG_DWORD : 1
//                      Start        : REG_DWORD : 3
//                      Type         : REG_DWORD : 4
//                      \FilePrint
//                         ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
//                         DisplayName       : REG_SZ    : "Windows NT Server"
//                         FamilyDisplayName : REG_SZ    : "Windows NT Server"
//                         Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
//                         FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0
//                \LicenseService
//                   \FilePrint
//                      \KSecDD
//                      \MSAfpSrv
//                      \SMBServer
//                      \TCP/IP Print Server
//                   \Parameters
//                      UseEnterprise    : REG_DWORD : 0
//                      ReplicationType  : REG_DWORD : 0
//                      ReplicationTime  : REG_DWORD : 24 * 60 * 60
//                      EnterpriseServer : REG_SZ    : ""
//                \EventLog
//                   \Application
//                      \LicenseService
//                         EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
//                         TypesSupported   : REG_DWORD     : 7
//
{
   BOOL        fSuccess;
   DWORD       winStatus;

   // check service config
   if ( !fShouldBePresent )
   {
      fSuccess = TRUE;
   }
   else
   {
      SC_HANDLE   hSC;

      fSuccess = FALSE;

      hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

      if ( NULL == hSC )
      {
         printf( "OpenSCManager() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         SC_HANDLE   hLicenseService;

         hLicenseService = OpenService( hSC, TEXT( "LicenseService" ), SERVICE_ALL_ACCESS );

         if ( NULL == hLicenseService )
         {
            printf( "OpenService() failed, error %lu.\n", GetLastError() );
         }
         else
         {
            BOOL                    ok;
            BYTE                    abLicenseServiceConfig[ 4096 ];
            LPQUERY_SERVICE_CONFIG  pLicenseServiceConfig;
            DWORD                   cbLicenseServiceConfigNeeded;

            pLicenseServiceConfig = (LPQUERY_SERVICE_CONFIG) abLicenseServiceConfig;

            ok = QueryServiceConfig( hLicenseService,
                                     pLicenseServiceConfig,
                                     sizeof( abLicenseServiceConfig ),
                                     &cbLicenseServiceConfigNeeded );

            if ( !ok )
            {
               printf( "QueryServiceConfig() failed, error %lu.\n", GetLastError() );
            }
            else if (    ( SERVICE_WIN32_OWN_PROCESS != pLicenseServiceConfig->dwServiceType   )
                      || ( SERVICE_AUTO_START        != pLicenseServiceConfig->dwStartType     )
                      || ( SERVICE_ERROR_NORMAL      != pLicenseServiceConfig->dwErrorControl  )
                      || lstrcmpi( TEXT( "" ),                                   pLicenseServiceConfig->lpLoadOrderGroup )
                      || lstrcmpi( TEXT( "" ),                                   pLicenseServiceConfig->lpDependencies )
                      || lstrcmpi( TEXT( "LocalSystem" ),                        pLicenseServiceConfig->lpServiceStartName )
                    //|| lstrcmpi( TEXT( "%SystemRoot%\\System32\\llssrv.exe" ), pLicenseServiceConfig->lpBinaryPathName )
                    //|| lstrcmp(  TEXT( "License Logging Service" ),            pLicenseServiceConfig->lpDisplayName )
                    )
            {
               printf( "LicenseService was incorrectly configured!\n" );
            }
            else
            {
               fSuccess = TRUE;
            }

            CloseServiceHandle( hLicenseService );
         }

         CloseServiceHandle( hSC );
      }
   }

   if ( fSuccess )
   {
      // check LicenseService\FilePrint
      HKEY     hKeyFilePrint;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\FilePrint" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyFilePrint );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseService\\FilePrint\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseService\\FilePrint\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         static LPTSTR apszFilePrintServices[] =
         {
            TEXT( "KSecDD" ),
            TEXT( "MSAfpSrv" ),
            TEXT( "SMBServer" ),
            TEXT( "TCP/IP Print Server" ),
            NULL
         };

         DWORD    iService;

         fSuccess = TRUE;

         for ( iService=0; fSuccess && ( NULL != apszFilePrintServices[ iService ] ); iService++ )
         {
            HKEY  hKeyFilePrintService;

            winStatus = RegOpenKeyEx( hKeyFilePrint,
                                      apszFilePrintServices[ iService ],
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKeyFilePrintService );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n",
                       apszFilePrintServices[ iService ],
                       winStatus );

               fSuccess = FALSE;
            }
            else
            {
               RegCloseKey( hKeyFilePrintService );
            }
         }

         RegCloseKey( hKeyFilePrint );
      }
   }

   if ( fSuccess )
   {
      // check LicenseService\Parameters
      HKEY     hKeyParameters;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\Parameters" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyParameters );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseService\\Parameters\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseService\\Parameters\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // UseEnterprise    : REG_DWORD : 0
         // ReplicationType  : REG_DWORD : 0
         // ReplicationTime  : REG_DWORD : 24 * 60 * 60
         // EnterpriseServer : REG_SZ    : ""

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyParameters,
                                      TEXT( "UseEnterprise" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"UseEnterprise\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 0 != dwValue ) )
         {
            printf( "\"UseEnterprise\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyParameters,
                                         TEXT( "ReplicationType" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"ReplicationType\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( 0 != dwValue ) )
            {
               printf( "\"ReplicationType\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyParameters,
                                            TEXT( "ReplicationTime" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"ReplicationTime\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( 24L * 60L * 60L != dwValue ) )
               {
                  printf( "\"ReplicationTime\" has incorrect value!\n" );
               }
               else
               {
                  cbValue = sizeof( szValue );
                  winStatus = RegQueryValueEx( hKeyParameters,
                                               TEXT( "EnterpriseServer" ),
                                               NULL,
                                               &dwType,
                                               (LPBYTE) szValue,
                                               &cbValue );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegQueryValueEx() on \"EnterpriseServer\" failed, error %lu.\n",
                             winStatus );
                  }
                  else if ( ( REG_SZ != dwType ) || ( TEXT( '\0' ) != szValue[ 0 ] ) )
                  {
                     printf( "\"EnterpriseServer\" has incorrect value!\n" );
                  }
                  else
                  {
                     fSuccess = TRUE;
                  }
               }
            }
         }

         RegCloseKey( hKeyParameters );
      }
   }

   if ( fSuccess )
   {
      // check LicenseInfo
      HKEY     hKeyLicenseInfo;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyLicenseInfo );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseInfo\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseInfo\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // ErrorControl : REG_DWORD : 1
         // Start        : REG_DWORD : 3
         // Type         : REG_DWORD : 4

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                      TEXT( "ErrorControl" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"ErrorControl\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 1 != dwValue ) )
         {
            printf( "\"ErrorControl\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                         TEXT( "Start" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"Start\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( 3 != dwValue ) )
            {
               printf( "\"Start\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                            TEXT( "Type" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"Type\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( 4 != dwValue ) )
               {
                  printf( "\"Type\" has incorrect value!\n" );
               }
               else
               {
                  fSuccess = TRUE;
               }
            }
         }

         RegCloseKey( hKeyLicenseInfo );
      }
   }

   if ( fSuccess )
   {
      // check LicenseInfo\FilePrint
      HKEY     hKeyFilePrint;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo\\FilePrint" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyFilePrint );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\EventLog\\Application\\LicenseInfo\\FilePrint\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseInfo\\FilePrint\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
         // DisplayName       : REG_SZ    : "Windows NT Server"
         // FamilyDisplayName : REG_SZ    : "Windows NT Server"
         // Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
         // FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyFilePrint,
                                      TEXT( "ConcurrentLimit" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"ConcurrentLimit\" failed, error %lu.\n",
                    winStatus );
         }
         else if (    ( REG_DWORD != dwType )
                   || ( ( fLicensePerServer ? cPerServerLicenses : 0 ) != dwValue ) )
         {
            printf( "\"ConcurrentLimit\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyFilePrint,
                                         TEXT( "Mode" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"Mode\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( (DWORD) fLicensePerServer != dwValue ) )
            {
               printf( "\"Mode\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyFilePrint,
                                            TEXT( "FlipAllow" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"FlipAllow\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( (DWORD) fLicensePerServer != dwValue ) )
               {
                  printf( "\"FlipAllow\" has incorrect value!\n" );
               }
               else
               {
                  cbValue = sizeof( szValue );
                  winStatus = RegQueryValueEx( hKeyFilePrint,
                                               TEXT( "DisplayName" ),
                                               NULL,
                                               &dwType,
                                               (LPBYTE) szValue,
                                               &cbValue );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegQueryValueEx() on \"DisplayName\" failed, error %lu.\n",
                             winStatus );
                  }
                  else if ( ( REG_SZ != dwType ) || lstrcmp( TEXT( "Windows NT Server" ), szValue ) )
                  {
                     printf( "\"DisplayName\" has incorrect value!\n" );
                  }
                  else
                  {
                     cbValue = sizeof( szValue );
                     winStatus = RegQueryValueEx( hKeyFilePrint,
                                                  TEXT( "FamilyDisplayName" ),
                                                  NULL,
                                                  &dwType,
                                                  (LPBYTE) szValue,
                                                  &cbValue );

                     if ( ERROR_SUCCESS != winStatus )
                     {
                        printf( "RegQueryValueEx() on \"FamilyDisplayName\" failed, error %lu.\n",
                                winStatus );
                     }
                     else if ( ( REG_SZ != dwType ) || lstrcmp( TEXT( "Windows NT Server" ), szValue ) )
                     {
                        printf( "\"FamilyDisplayName\" has incorrect value!\n" );
                     }
                     else
                     {
                        fSuccess = TRUE;
                     }
                  }
               }
            }
         }

         RegCloseKey( hKeyFilePrint );
      }
   }

   if ( fSuccess )
   {
      // check EventLog
      HKEY     hKeyEventLog;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyEventLog );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\EventLog\\Application\\LicenseService\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\EventLog\\Application\\LicenseService\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
         // TypesSupported   : REG_DWORD     : 7

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyEventLog,
                                      TEXT( "TypesSupported" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"TypesSupported\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 7 != dwValue ) )
         {
            printf( "\"TypesSupported\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( szValue );
            winStatus = RegQueryValueEx( hKeyEventLog,
                                         TEXT( "EventMessageFile" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) szValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"EventMessageFile\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_SZ != dwType ) || lstrcmpi( TEXT( "%SystemRoot%\\System32\\llsrpc.dll" ), szValue ) )
            {
               printf( "\"EventMessageFile\" has incorrect value!\n" );
            }
            else
            {
               fSuccess = TRUE;
            }
         }

         RegCloseKey( hKeyEventLog );
      }
   }

   if ( !fSuccess )
   {
      printf( "Configuration failed!\n" );
   }
   else
   {
      printf( "Configuration succeeded.\n" );
   }

   return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\liccpa\test\licsetup\ctls.c ===
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
#include "ctls.h"
#pragma hdrstop

#define  MyModuleHandle    GetModuleHandle( NULL )
#define  MYASSERT(x)
#define  MyFree(x)         LocalFree( x )

PWSTR DuplicateString( PWSTR pszOriginal )
{
   PWSTR    pszCopy;

   pszCopy = LocalAlloc( LPTR, ( 1 + lstrlenW( pszOriginal ) ) * sizeof( *pszOriginal ) );

   if ( NULL != pszCopy )
   {
      lstrcpy( pszCopy, pszOriginal );
   }

   return pszCopy;
}

////////////////////////////////////////////
//
// Bitmap control
//
////////////////////////////////////////////

PCWSTR szBMPCLASS = L"_mybmp";


LRESULT
BmpClassWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );


BOOL
InitializeBmpClass(
    VOID
    )
{
    WNDCLASS wc;
    BOOL b;

    if(GetClassInfo(MyModuleHandle,szBMPCLASS,&wc)) {
        b = TRUE;
    } else {

        wc.lpszClassName = szBMPCLASS;
        wc.style         = CS_GLOBALCLASS;
        wc.lpfnWndProc   = BmpClassWndProc;
        wc.hInstance     = MyModuleHandle;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = NULL;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;

        b = RegisterClass(&wc);
    }

    return(b);
}


VOID
DestroyBmpClass(
    VOID
    )
{
    WNDCLASS wc;

    if(GetClassInfo(MyModuleHandle,szBMPCLASS,&wc)) {
        //
        // Hope there are no more windows using the class!
        //
        MYASSERT(!FindWindow(szBMPCLASS,NULL));
        UnregisterClass(szBMPCLASS,MyModuleHandle);
    }
}


VOID
BmpClassPaint(
    IN HWND hwnd
    )
{
    PAINTSTRUCT ps;
    unsigned BmpId;
    HDC hdc, hdcMem;
    HBITMAP hbm,hbmOld;
    BITMAP bm;

    BmpId = GetDlgCtrlID(hwnd);

    hdc = BeginPaint(hwnd,&ps);
    if(hbm = LoadBitmap((HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE),MAKEINTRESOURCE(BmpId))) {
        GetObject(hbm, sizeof(bm),&bm);
        if(hdcMem = CreateCompatibleDC(hdc)) {
            if(hbmOld = SelectObject(hdcMem,hbm)) {
                BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcMem,0,0,SRCCOPY);
                SelectObject(hdcMem,hbmOld);
            }
            DeleteDC(hdcMem);
        }
        DeleteObject(hbm);
    }
    EndPaint(hwnd,&ps);
}


LRESULT
BmpClassWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(msg) {

    case WM_NCCREATE:

        SetWindowLong(
            hwnd,
            GWL_STYLE,
            GetWindowLong(hwnd,GWL_STYLE) | WS_BORDER
            );

        return(TRUE);

    case WM_PAINT:

        BmpClassPaint(hwnd);
        return(0);
    }

    return(DefWindowProc(hwnd,msg,wParam,lParam));
}


////////////////////////////////////////////
//
// Action item list control
//
////////////////////////////////////////////

//
// Define locations in extra window storage
//
#define AIL_FONT        (0)
#define AIL_BOLDFONT    (sizeof(LONG))
#define AIL_BOLDITEM    (2*sizeof(LONG))
#define AIL_TEXT        (3*sizeof(LONG))
#define AIL_LINECOUNT   (4*sizeof(LONG))
#define AIL_FREEFONTS   (5*sizeof(LONG))

#define AIL_EXTRA       6

PCWSTR szActionItemListClassName = L"$$$ActionItemList";


VOID
ActionItemListPaint(
    IN HWND hwnd
    )
{

    PAINTSTRUCT PaintStruct;
    PWSTR p,Text;
    UINT LineCount;
    HFONT OldFont,Font,BoldFont;
    UINT HighlightedItem;
    UINT i;
    int Length;
    int y;
    int yDelta;
    HBITMAP Bitmap,OldBitmap;
    BITMAP bitmap;
    HDC MemoryDC;
    SIZE Size;
    RECT rect;
    int Spacing;
    #define BORDER 3

    if(!BeginPaint(hwnd,&PaintStruct)) {
        return;
    }

    //
    // If no text, nothing to do.
    //
    if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
        LineCount = (UINT)GetWindowLong(hwnd,AIL_LINECOUNT);
    }

    if(!Text || !LineCount) {
        return;
    }

    //
    // Get value indicating which item is to be bolded.
    //
    HighlightedItem = (UINT)GetWindowLong(hwnd,AIL_BOLDITEM);

    //
    // Get font handles.
    //
    Font = (HFONT)GetWindowLong(hwnd,AIL_FONT);
    BoldFont = (HFONT)GetWindowLong(hwnd,AIL_BOLDFONT);

    //
    // Select the non-boldface font to get the handle of
    // the currently selected font.
    //
    OldFont = SelectObject(PaintStruct.hdc,Font);

    //
    // Set text background color.
    //
    SetBkColor(PaintStruct.hdc,GetSysColor(COLOR_3DFACE));

    //
    // Load the little triangle bitmap and create a compatible DC for it.
    //
    Bitmap = LoadBitmap(NULL,MAKEINTRESOURCE(OBM_MNARROW));

    if(MemoryDC = CreateCompatibleDC(PaintStruct.hdc)) {

        OldBitmap = SelectObject(MemoryDC,Bitmap);
        GetObject(Bitmap,sizeof(BITMAP),&bitmap);
    }

    Spacing = GetSystemMetrics(SM_CXICON) / 2;

    //
    // Treat the text as a series of lines and draw each one.
    //
    p = Text;
    y = 0;
    for(i=0; i<LineCount; i++) {

        //
        // Calculate the line's height based on the boldface font.
        // This is used to get to the y coord of the next line.
        //
        SelectObject(PaintStruct.hdc,BoldFont);

        GetClientRect(hwnd,&rect);
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = 0;

        DrawText(PaintStruct.hdc,p,lstrlen(p),&rect,DT_CALCRECT|DT_WORDBREAK);

        yDelta = rect.bottom + (2*BORDER);

        //
        // Change font to non-boldface for this line if necessary.
        //
        if(i != HighlightedItem) {
            SelectObject(PaintStruct.hdc,Font);
        }

        rect.top = y + BORDER;
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = rect.top + yDelta;

        //
        // Draw the line's text.
        //
        Length = lstrlen(p);
        DrawText(PaintStruct.hdc,p,Length,&rect,DT_WORDBREAK);

        //
        // Draw the little triangle thing if necessary.
        //
        if((i == HighlightedItem) && Bitmap && MemoryDC) {

            GetTextExtentPoint(PaintStruct.hdc,L"WWWWW",5,&Size);

            BitBlt(
                PaintStruct.hdc,
                BORDER,
                y + ((Size.cy - bitmap.bmHeight) / 2) + BORDER,
                bitmap.bmWidth,
                bitmap.bmHeight,
                MemoryDC,
                0,0,
                0x220326        // (NOT src) AND dest [DSna]
                );
        }

        //
        // Point to next line's text.
        //
        p += Length + 1;
        y += yDelta;
    }

    //
    // Clean up.
    //
    if(OldFont) {
        SelectObject(PaintStruct.hdc,OldFont);
    }

    if(MemoryDC) {
        if(OldBitmap) {
            SelectObject(MemoryDC,OldBitmap);
        }
        if(Bitmap) {
            DeleteObject(Bitmap);
        }
        DeleteDC(MemoryDC);
    }

    EndPaint(hwnd,&PaintStruct);
}


LRESULT
ActionItemListWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT rc;
    HFONT OldFont,Font,BoldFont;
    LOGFONT LogFont;
    PWSTR Text;
    PWSTR p;
    UINT LineCount;
    BOOL FreeFont,FreeBoldFont;

    switch(msg) {

    case WM_CREATE:

        //
        // Create fonts.
        //
        OldFont = (HFONT)SendMessage(GetParent(hwnd),WM_GETFONT,0,0);
        if(!OldFont) {
            //
            // Using system font.
            //
            OldFont = GetStockObject(DEFAULT_GUI_FONT);
        }

        FreeFont = TRUE;
        FreeBoldFont = TRUE;
        if(OldFont && GetObject(OldFont,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = 400;
            Font = CreateFontIndirect(&LogFont);
            if(!Font) {
                Font = GetStockObject(DEFAULT_GUI_FONT);
                FreeFont = FALSE;
            }

            LogFont.lfWeight = 700;
            BoldFont = CreateFontIndirect(&LogFont);
            if(!BoldFont) {
                BoldFont = Font;
                FreeBoldFont = FALSE;
            }
        }

        SetWindowLong(hwnd,AIL_FONT,(LONG)Font);
        SetWindowLong(hwnd,AIL_BOLDFONT,(LONG)BoldFont);
        SetWindowLong(hwnd,AIL_BOLDITEM,0);
        SetWindowLong(hwnd,AIL_TEXT,0);
        SetWindowLong(hwnd,AIL_LINECOUNT,0);
        SetWindowLong(hwnd,AIL_FREEFONTS,MAKELONG(FreeFont,FreeBoldFont));

        rc = 0;
        break;

    case WM_DESTROY:
        //
        // Get rid of fonts we created if necessary.
        //
        FreeFont = (BOOL)GetWindowLong(hwnd,AIL_FREEFONTS);
        FreeBoldFont = HIWORD(FreeFont);
        FreeFont = LOWORD(FreeFont);

        if(FreeFont && (Font = (HFONT)GetWindowLong(hwnd,AIL_FONT))) {
            DeleteObject(Font);
        }

        if(FreeBoldFont && (BoldFont = (HFONT)GetWindowLong(hwnd,AIL_BOLDFONT))) {
            DeleteObject(BoldFont);
        }

        if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }
        rc = 0;
        break;

    case WM_SETTEXT:
        //
        // Free old text and remember new text.
        //
        if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }

        LineCount = 0;
        if(Text = DuplicateString((PVOID)lParam)) {
            //
            // Count lines in the text. This is equal to the number of
            // newlines. We require that the last line have a newline
            // to be counted.
            //
            for(LineCount=0,p=Text; *p; p++) {

                if(*p == L'\r') {
                    *p = L' ';
                } else {
                    if(*p == L'\n') {
                        *p = 0;
                        LineCount++;
                    }
                }
            }
        }

        //
        // Cheat a little: we expect wParam to be the 0-based index
        // of the boldfaced line. Callers will have to use SendMessage
        // instead of SetWindowText().
        //
        SetWindowLong(hwnd,AIL_BOLDITEM,(LONG)wParam);
        SetWindowLong(hwnd,AIL_LINECOUNT,LineCount);
        SetWindowLong(hwnd,AIL_TEXT,(LONG)Text);

        rc = (Text != NULL);
        break;

    case WM_PAINT:

        ActionItemListPaint(hwnd);
        rc = 0;
        break;

    default:
        rc = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(rc);
}


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    )
{
    WNDCLASS wc;
    BOOL b;
    static BOOL Registered;

    if(Init) {
        if(Registered) {
            b = TRUE;
        } else {
            wc.style = CS_PARENTDC;
            wc.lpfnWndProc = ActionItemListWndProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = AIL_EXTRA * sizeof(LONG);
            wc.hInstance = MyModuleHandle;
            wc.hIcon = NULL;
            wc.hCursor = LoadCursor(NULL,IDC_ARROW);
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
            wc.lpszMenuName = NULL;
            wc.lpszClassName = szActionItemListClassName;

            if(b = (RegisterClass(&wc) != 0)) {
                Registered = TRUE;
            }
        }
    } else {
        if(Registered) {
            if(b = UnregisterClass(szActionItemListClassName,MyModuleHandle)) {
                Registered = FALSE;
            }
        } else {
            b = TRUE;
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\appobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    appobj.h

Abstract:

    OLE-createable application object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added Get/SetLastTargetServer() to help isolate server connection
        problems.  (Bug #2993.)

--*/

#ifndef _APPOBJ_H_
#define _APPOBJ_H_

class CApplication : public CCmdTarget
{
    DECLARE_DYNCREATE(CApplication)
    DECLARE_OLECREATE(CApplication)
private:
    CObArray     m_domainArray;
    CDomain*     m_pLocalDomain;
    CDomain*     m_pActiveDomain;
    CController* m_pActiveController;
    BOOL         m_bIsFocusDomain;
    BOOL         m_bDomainsRefreshed;
    long         m_idStatus;
    CString      m_strLastTargetServer;
            
public:
    CDomains*    m_pDomains;

public:
    CApplication(); 
    virtual ~CApplication();

    void ResetDomains();
    BOOL RefreshDomains();

    long GetLastStatus();
    void SetLastStatus(long Status);

    BSTR GetLastTargetServer();
    void SetLastTargetServer( LPCTSTR pszServerName );

    BOOL IsConnected();
    LPVOID GetActiveHandle();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CApplication)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CApplication)
    afx_msg LPDISPATCH GetApplication();
    afx_msg BSTR GetFullName();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg BOOL GetVisible();
    afx_msg LPDISPATCH GetActiveController();
    afx_msg LPDISPATCH GetActiveDomain();
    afx_msg LPDISPATCH GetLocalDomain();
    afx_msg BOOL IsFocusDomain();
    afx_msg BSTR GetLastErrorString();
    afx_msg void Quit();
    afx_msg BOOL SelectDomain(const VARIANT FAR& domain);
    afx_msg BOOL SelectEnterprise();
    afx_msg LPDISPATCH GetDomains(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CApplication)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

inline BOOL CApplication::IsConnected()
    { ASSERT_VALID(m_pActiveController); return m_pActiveController->IsConnected(); }

inline LPVOID CApplication::GetActiveHandle()
    { ASSERT_VALID(m_pActiveController); return m_pActiveController->GetLlsHandle(); }

inline void CApplication::SetLastStatus(long Status)
    { m_idStatus = Status; }

inline long CApplication::GetLastStatus()
    { return m_idStatus; }

#endif // _APPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\appobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    appobj.cpp

Abstract:

    OLE-createable application object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added Get/SetLastTargetServer() to help isolate server connection
        problems.  (Bug #2993.)

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lmerr.h"
#include "lmcons.h"
#include "lmwksta.h"
#include "lmapibuf.h"
#include "lmserver.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CApplication, CCmdTarget)
// IMPLEMENT_OLECREATE(CApplication, "Llsmgr.Application.1", 0x2c5dffb3, 0x472f, 0x11ce, 0xa0, 0x30, 0x0, 0xaa, 0x0, 0x33, 0x9a, 0x98)

BEGIN_MESSAGE_MAP(CApplication, CCmdTarget)
    //{{AFX_MSG_MAP(CApplication)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CApplication, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CApplication)
    DISP_PROPERTY_EX(CApplication, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "FullName", GetFullName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CApplication, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CApplication, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "Visible", GetVisible, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CApplication, "ActiveController", GetActiveController, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "ActiveDomain", GetActiveDomain, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "LocalDomain", GetLocalDomain, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "IsFocusDomain", IsFocusDomain, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CApplication, "LastErrorString", GetLastErrorString, SetNotSupported, VT_BSTR)
    DISP_FUNCTION(CApplication, "Quit", Quit, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CApplication, "SelectDomain", SelectDomain, VT_BOOL, VTS_VARIANT)
    DISP_FUNCTION(CApplication, "SelectEnterprise", SelectEnterprise, VT_BOOL, VTS_NONE)
    DISP_PROPERTY_PARAM(CApplication, "Domains", GetDomains, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CApplication, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CApplication::CApplication()

/*++

Routine Description:

    Constructor for OLE-createable application object.

    To keep the application running as long as an OLE automation
    object is active, we must call AfxOleLockApp.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableAutomation();

    ASSERT(theApp.m_pApplication == NULL);

    if (theApp.m_pApplication == NULL)
        theApp.m_pApplication = this;

    if (theApp.m_bIsAutomated)
        AfxOleLockApp();

    m_pDomains          = NULL;
    m_pLocalDomain      = NULL;
    m_pActiveDomain     = NULL;
    m_bIsFocusDomain    = FALSE;
    m_bDomainsRefreshed = FALSE;

    m_strLastTargetServer = TEXT("");

    m_domainArray.RemoveAll();

    m_pActiveController = new CController;
    m_idStatus = m_pActiveController ? STATUS_SUCCESS : STATUS_NO_MEMORY;
}


CApplication::~CApplication()

/*++

Routine Description:

    Destructor for OLE-createable application object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ASSERT(theApp.m_pApplication == this);

    if (theApp.m_pApplication == this)
        theApp.m_pApplication = NULL;

    if (theApp.m_bIsAutomated)
        AfxOleUnlockApp();

    if (m_pDomains)
        m_pDomains->InternalRelease();

    if (m_pLocalDomain)
        m_pLocalDomain->InternalRelease();

    if (m_pActiveDomain)
        m_pActiveDomain->InternalRelease();

    if (m_pActiveController)
        m_pActiveController->InternalRelease();
}


void CApplication::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetDomains();
    delete this;
}


LPDISPATCH CApplication::GetActiveController()

/*++

Routine Description:

    Returns the active license controller object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pActiveController);
    return m_pActiveController->GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetActiveDomain()

/*++

Routine Description:

    Returns the active domain object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    return m_pActiveDomain ? m_pActiveDomain->GetIDispatch(TRUE) : NULL;
}


LPDISPATCH CApplication::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetDomains(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the domains
    visible to the local machine or returns an individual domain
    described by an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a domain name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pDomains)
    {
        m_pDomains = new CDomains(this, &m_domainArray);
    }

    if (m_pDomains)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bDomainsRefreshed)
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
            else if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
        }
    }
    else
    {
        SetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BSTR CApplication::GetFullName()

/*++

Routine Description:

    Returns the file specification for the application,
    including path.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    TCHAR szModuleFileName[260];

    GetModuleFileName(AfxGetApp()->m_hInstance, szModuleFileName, 260);
    return SysAllocStringLen(szModuleFileName, lstrlen(szModuleFileName));
}


BSTR CApplication::GetLastErrorString()

/*++

Routine Description:

    Retrieves string for last error.

    (Routine stolen from winsadmn...).

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    CString strLastError;
    DWORD nId = m_idStatus;

    if (((long)nId == RPC_S_CALL_FAILED) ||
        ((long)nId == RPC_NT_SS_CONTEXT_MISMATCH))
    {
        strLastError.LoadString(IDP_ERROR_DROPPED_LINK);
    }
    else if (((long)nId == RPC_S_SERVER_UNAVAILABLE) ||
             ((long)nId == RPC_NT_SERVER_UNAVAILABLE))
    {
        strLastError.LoadString(IDP_ERROR_NO_RPC_SERVER);
    }
    else if ((long)nId == STATUS_MEMBER_IN_GROUP)
    {
        strLastError.LoadString(IDP_ERROR_MEMBER_IN_GROUP);
    }
    else
    {
        HINSTANCE hinstDll = NULL;

        if ((nId >= NERR_BASE) && (nId <= MAX_NERR))
        {
            hinstDll = ::LoadLibrary(_T("netmsg.dll"));
        }
        else if (nId >= 0x4000000)
        {
            hinstDll = ::LoadLibrary(_T("ntdll.dll"));
        }

        TCHAR szLastError[1024];
        DWORD cchLastError = sizeof(szLastError) / sizeof(TCHAR);

        DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS|
                        FORMAT_MESSAGE_MAX_WIDTH_MASK|
                        (hinstDll ? FORMAT_MESSAGE_FROM_HMODULE
                                  : FORMAT_MESSAGE_FROM_SYSTEM);

        cchLastError = ::FormatMessage(
                          dwFlags,
                          hinstDll,
                          nId,
                          0,
                          szLastError,
                          cchLastError,
                          NULL
                          );

        if (hinstDll)
        {
            ::FreeLibrary(hinstDll);
        }

        if (cchLastError)
        {
            strLastError = szLastError;
        }
        else
        {
            strLastError.LoadString(IDP_ERROR_UNSUCCESSFUL);
        }
    }

    return strLastError.AllocSysString();
}


LPDISPATCH CApplication::GetLocalDomain()

/*++

Routine Description:

    Returns the local domain object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    if (!m_pLocalDomain)
    {
        NET_API_STATUS NetStatus;
        PWKSTA_INFO_100 pWkstaInfo100 = NULL;

        NetStatus = NetWkstaGetInfo(
                        NULL,
                        100,
                        (LPBYTE*)&pWkstaInfo100
                        );

        if (NetStatus == ERROR_SUCCESS)
        {
            m_pLocalDomain = new CDomain(this, pWkstaInfo100->wki100_langroup);

            if (!m_pLocalDomain)
            {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            }

            NetApiBufferFree(pWkstaInfo100);
        }

        SetLastStatus(NetStatus);   // called api
    }

    return m_pLocalDomain ? m_pLocalDomain->GetIDispatch(TRUE) : NULL;
}


BSTR CApplication::GetName()

/*++

Routine Description:

    Returns the name of the application.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    CString AppName = AfxGetAppName();
    return AppName.AllocSysString();
}


LPDISPATCH CApplication::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetApplication();
}


BOOL CApplication::GetVisible()

/*++

Routine Description:

    Returns whether or not the application is visible to the user.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return FALSE;
}


BOOL CApplication::IsFocusDomain()

/*++

Routine Description:

    Returns true if application focused on domain.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsFocusDomain;
}


BOOL CApplication::RefreshDomains()

/*++

Routine Description:

    Refreshs domain object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetDomains();

    NET_API_STATUS NetStatus;
    DWORD ResumeHandle = 0L;

    int iDomain = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NetStatus = NetServerEnum(
                        NULL,                   // servername
                        100,                    // level
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        SV_TYPE_DOMAIN_ENUM,
                        NULL,                   // domain
                        &ResumeHandle
                        );

        if (NetStatus == ERROR_SUCCESS ||
            NetStatus == ERROR_MORE_DATA)
        {
            CDomain*         pDomain;
            PSERVER_INFO_100 pServerInfo100;

            pServerInfo100 = (PSERVER_INFO_100)ReturnBuffer;

            ASSERT(iDomain == m_domainArray.GetSize());
            m_domainArray.SetSize(m_domainArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pDomain = new CDomain(this, pServerInfo100->sv100_name);

                m_domainArray.SetAt(iDomain++, pDomain); // validate later
                pServerInfo100++;
            }

            NetApiBufferFree(ReturnBuffer);
        }

    } while (NetStatus == ERROR_MORE_DATA);

    SetLastStatus(NetStatus);   // called api

    if (NetStatus == ERROR_SUCCESS)
    {
        m_bDomainsRefreshed = TRUE;
    }
    else
    {
        ResetDomains();
    }

    return m_bDomainsRefreshed;
}


void CApplication::ResetDomains()

/*++

Routine Description:

    Resets domain object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDomain* pDomain;
    INT_PTR  iDomain = m_domainArray.GetSize();

    while (iDomain--)
    {
        if (pDomain = (CDomain*)m_domainArray[iDomain])
        {
            ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));
            pDomain->InternalRelease();
        }
    }

    m_domainArray.RemoveAll();
    m_bDomainsRefreshed = FALSE;
}


BOOL CApplication::SelectDomain(const VARIANT FAR& domain)

/*++

Routine Description:

    Connects to license controller of specified domain.

Arguments:

    domain - name of domain.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsSelected = FALSE;

    ASSERT_VALID(m_pActiveController);

    if (bIsSelected = m_pActiveController->Connect(domain))
    {
        LPTSTR pszActiveDomain = MKSTR(m_pActiveController->m_strActiveDomainName);

        if (m_pActiveDomain)
        {
            m_pActiveDomain->InternalRelease();
            m_pActiveDomain = NULL;
        }

        if (pszActiveDomain && *pszActiveDomain)
        {
            m_pActiveDomain = new CDomain(this, pszActiveDomain);

            if (m_pActiveDomain)
            {
                m_bIsFocusDomain = TRUE;
            }
            else
            {
                m_bIsFocusDomain = FALSE; // invalidate m_pActiveDomain
                SetLastStatus(STATUS_NO_MEMORY);
            }
        }
        else
        {
            m_bIsFocusDomain = FALSE; // invalidate m_pActiveDomain
        }
    }

    return bIsSelected;
}


BOOL CApplication::SelectEnterprise()

/*++

Routine Description:

    Connects to license controller of enterprise.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsSelected = FALSE;

    VARIANT va;
    VariantInit(&va);   // connect to default controller

    if (bIsSelected = m_pActiveController->Connect(va))
    {
        if (m_pActiveDomain)
        {
            m_pActiveDomain->InternalRelease();
            m_pActiveDomain = NULL;
        }

        m_bIsFocusDomain = FALSE;
    }

    return bIsSelected;
}


void CApplication::Quit()

/*++

Routine Description:

    Closes all documents and exits the application.

Arguments:

    None.

Return Values:

    None.

--*/

{
    AfxPostQuitMessage(0); // no main window...
}


BSTR CApplication::GetLastTargetServer()

/*++

Routine Description:

    Retrieves string for last server to which we tried to connect.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    if ( m_strLastTargetServer.IsEmpty() )
        return NULL;
    else
        return m_strLastTargetServer.AllocSysString();
}


void CApplication::SetLastTargetServer( LPCTSTR pszServerName )

/*++

Routine Description:

    Sets string for last server to which we tried to connect.

Arguments:

    pszServerName - last server name to which we tried to connect.

Return Values:

    None.

--*/

{
    m_strLastTargetServer = pszServerName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\ausrdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ausrdlg.h

Abstract:

    Add user dialog implementation.

Author:

    Don Ryan (donryan) 14-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _AUSRDLG_H_
#define _AUSRDLG_H_

class CAddUsersDialog : public CDialog
{
private:
    CObList*   m_pObList;
    BOOL       m_bIsDomainListExpanded;

    BOOL       m_bIsFocusUserList;
    BOOL       m_bIsFocusAddedList;

public:
    CAddUsersDialog(CWnd* pParent = NULL);   

    void InitUserList();
    void InitDomainList();

    BOOL InsertDomains(CDomains* pDomains);
    BOOL RefreshUserList();

    void InitDialog(CObList* pObList);
    void InitDialogCtrls();

    //{{AFX_DATA(CAddUsersDialog)
    enum { IDD = IDD_ADD_USERS };
    CButton m_addBtn;
    CButton m_delBtn;
    CComboBox   m_domainList;
    CListCtrl   m_addedList;
    CListCtrl   m_userList;
    int     m_iDomain;
    int m_iIndex;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CAddUsersDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CAddUsersDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnDropdownDomains();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnDblclkAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangeDomains();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnGetdispinfoUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _AUSRDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\ausrdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ausrdlg.cpp

Abstract:

    Add user dialog implementation.

Author:

    Don Ryan (donryan) 14-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "ausrdlg.h"

static LV_COLUMN_INFO g_userColumnInfo  = {0, 0, 1, {0, 0, 0, -1}};
static LV_COLUMN_INFO g_addedColumnInfo = {0, 0, 1, {0, 0, 0, -1}};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CAddUsersDialog, CDialog)
    //{{AFX_MSG_MAP(CAddUsersDialog)
    ON_CBN_DROPDOWN(IDC_ADD_USERS_DOMAINS, OnDropdownDomains)
    ON_BN_CLICKED(IDC_ADD_USERS_ADD, OnAdd)
    ON_BN_CLICKED(IDC_ADD_USERS_DELETE, OnDelete)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_USERS_ADD_USERS, OnDblclkAddUsers)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_USERS_USERS, OnDblclkUsers)
    ON_CBN_SELCHANGE(IDC_ADD_USERS_DOMAINS, OnSelchangeDomains)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_ADD_USERS_USERS, OnGetdispinfoUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_ADD_USERS_USERS, OnKillfocusUsers)
    ON_NOTIFY(NM_SETFOCUS, IDC_ADD_USERS_USERS, OnSetfocusUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_ADD_USERS_ADD_USERS, OnKillfocusAddUsers)
    ON_NOTIFY(NM_SETFOCUS, IDC_ADD_USERS_ADD_USERS, OnSetfocusAddUsers)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CAddUsersDialog::CAddUsersDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CAddUsersDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for add user dialog.

Arguments:

    pParent - parent window handle.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CAddUsersDialog)
    m_iDomain = -1;
    m_iIndex = 0;
    //}}AFX_DATA_INIT

    m_pObList = NULL;
    m_bIsDomainListExpanded = FALSE;

    m_bIsFocusUserList  = FALSE;
    m_bIsFocusAddedList = FALSE;
}


void CAddUsersDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddUsersDialog)
    DDX_Control(pDX, IDC_ADD_USERS_ADD, m_addBtn);
    DDX_Control(pDX, IDC_ADD_USERS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_ADD_USERS_DOMAINS, m_domainList);
    DDX_Control(pDX, IDC_ADD_USERS_ADD_USERS, m_addedList);
    DDX_Control(pDX, IDC_ADD_USERS_USERS, m_userList);
    DDX_CBIndex(pDX, IDC_ADD_USERS_DOMAINS, m_iDomain);
    //}}AFX_DATA_MAP
}


void CAddUsersDialog::InitDialog(CObList* pObList)

/*++

Routine Description:

    Initializes return list.

Arguments:

    pObList - pointer to return list.

Return Values:

    None.

--*/

{
    ASSERT_VALID(pObList);
    m_pObList = pObList;
}



void CAddUsersDialog::InitDomainList()

/*++

Routine Description:

    Initializes list of domains.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    int iDomain;

    CString strLabel;
    strLabel.LoadString(IDS_DEFAULT_DOMAIN);

    if ((iDomain = m_domainList.AddString(strLabel)) != CB_ERR)
    {
        m_domainList.SetCurSel(iDomain);
        m_domainList.SetItemDataPtr(iDomain, (LPVOID)-1L);
    }
    else
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
}


void CAddUsersDialog::InitUserList()

/*++

Routine Description:

    Initializes list of users.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvInitColumns(&m_userList,  &g_userColumnInfo);
    ::LvInitColumns(&m_addedList, &g_addedColumnInfo);
}


BOOL CAddUsersDialog::InsertDomains(CDomains* pDomains)

/*++

Routine Description:

    Inserts domains into domain list.

Arguments:

    pDomains - domain collection.

Return Values:

    None.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ASSERT_VALID(pDomains);

    if (pDomains)
    {
        VARIANT va;
        VariantInit(&va);

        CDomain* pDomain;
        int      iDomain;
        int      nDomains = pDomains->GetCount();

        for (va.vt = VT_I4, va.lVal = 0; (va.lVal < nDomains) && NT_SUCCESS(NtStatus); va.lVal++)
        {
            pDomain = (CDomain*)MKOBJ(pDomains->GetItem(va));
            ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

            if (pDomain)
            {
                if ((iDomain = m_domainList.AddString(pDomain->m_strName)) != CB_ERR)
                {
                    m_domainList.SetItemDataPtr(iDomain, pDomain);
                }
                else
                {
                    NtStatus = STATUS_NO_MEMORY;
                }

                pDomain->InternalRelease();
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus))
    {
        m_bIsDomainListExpanded = TRUE;
    }
    else
    {
        m_domainList.ResetContent();
        LlsSetLastStatus(NtStatus);
    }

    return m_bIsDomainListExpanded;
}


void CAddUsersDialog::OnAdd()

/*++

Routine Description:

    Message handler for IDC_ADD_USER_ADD.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;

    while (pUser = (CUser*)::LvGetNextObj(&m_userList, &iItem))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        LV_FINDINFO lvFindInfo;

        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz   = MKSTR(pUser->m_strName);

        if (m_addedList.FindItem(&lvFindInfo, -1) == -1)
        {
            //
            // Make a copy of the user (w/no parent)
            //

            CUser* pNewUser = new CUser(NULL, pUser->m_strName);

            if (pNewUser)
            {
                LV_ITEM lvItem;

                lvItem.mask = LVIF_TEXT|
                              LVIF_PARAM|
                              LVIF_IMAGE;

                lvItem.iSubItem  = 0;
                lvItem.lParam    = (LPARAM)(LPVOID)pNewUser;

                lvItem.iImage  = BMPI_USER;
                lvItem.pszText = MKSTR(pNewUser->m_strName);
                lvItem.iItem = m_iIndex;
                

                m_addedList.InsertItem(&lvItem);
                m_iIndex++;

                
            }
            else
            {
                theApp.DisplayStatus( STATUS_NO_MEMORY );
                break;
            }
        }
    }

    m_userList.SetFocus();
}


void CAddUsersDialog::OnDblclkAddUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DLBCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnDelete();
    *pResult = 0;
}


void CAddUsersDialog::OnDblclkUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DLBCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnAdd();
    *pResult = 0;
}


void CAddUsersDialog::OnDelete()

/*++

Routine Description:

    Message handler for IDC_ADD_USER_DELETE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;
    int iLastItem = 0;

    while (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        pUser->InternalRelease();   // allocated above....
        m_addedList.DeleteItem(iItem);

        iLastItem = iItem;
        iItem = -1;
        m_iIndex--;
    }

    m_addedList.SetItemState(iLastItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    m_addedList.SetFocus();
}


void CAddUsersDialog::OnDropdownDomains()

/*++

Routine Description:

    Notification handler for CBN_DROPDOWN.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_bIsDomainListExpanded)
        return;

    NTSTATUS NtStatus = STATUS_SUCCESS;

    CDomains* pDomains;
    CDomain*  pDomain;
    int       iDomain;

    VARIANT va;
    VariantInit(&va);

    if (LlsGetApp()->IsFocusDomain())
    {
        pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetActiveDomain());
        ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

        if (pDomain)
        {
            //
            // Expand to include trusted domains
            //

            pDomains = (CDomains*)MKOBJ(pDomain->GetTrustedDomains(va));

            if (pDomains && InsertDomains(pDomains))
            {
                //
                // Now add active domain itself...
                //

                if ((iDomain = m_domainList.AddString(pDomain->m_strName)) != CB_ERR)
                {
                    m_domainList.SetItemDataPtr(iDomain, pDomain);
                }
                else
                {
                    NtStatus = STATUS_NO_MEMORY;
                }
            }
            else
            {
                NtStatus = LlsGetLastStatus();
            }

            if (pDomains)
                pDomains->InternalRelease();

            pDomain->InternalRelease();
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }
    }
    else
    {
        pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetLocalDomain());
        ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

        if (pDomain)
        {
            //
            // Expand to include all domains
            //

            pDomains = (CDomains*)MKOBJ(LlsGetApp()->GetDomains(va));

            if (pDomains && InsertDomains(pDomains))
            {
                //
                // CODEWORK... scroll to local domain???
                //
            }
            else
            {
                NtStatus = LlsGetLastStatus();
            }

            if (pDomains)
                pDomains->InternalRelease();

            pDomain->InternalRelease();
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        theApp.DisplayStatus(NtStatus);
        m_domainList.ResetContent();
    }
}


BOOL CAddUsersDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BeginWaitCursor();

    CDialog::OnInitDialog();

    InitUserList(); // always construct headers...
    InitDomainList();

    m_addBtn.EnableWindow(FALSE);
    m_delBtn.EnableWindow(FALSE);

    if (!RefreshUserList())
        theApp.DisplayLastStatus();

    m_domainList.SetFocus();

    EndWaitCursor();

    return FALSE;   // set focus to domain list
}


void CAddUsersDialog::OnSelchangeDomains()

/*++

Routine Description:

    Message handler for CBN_SELCHANGED.

Arguments:

    None.

Return Values:

    None.

--*/

{
    RefreshUserList();
}


BOOL CAddUsersDialog::RefreshUserList()

/*++

Routine Description:

    Refreshs list of users (with currently selected item).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    m_userList.DeleteAllItems();

    int iDomain;

    if ((iDomain = m_domainList.GetCurSel()) != CB_ERR)
    {
        CDomain* pDomain = (CDomain*)m_domainList.GetItemDataPtr(iDomain);
        CUsers*  pUsers = (CUsers*)NULL;

        VARIANT va;
        VariantInit(&va);

        if (pDomain == (CDomain*)-1L)
        {
            //
            // Enumerate users in license cache...
            //

            CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
            if ( pController )
            {
                pController->InternalRelease(); // held open by CApplication

                pUsers = pController->m_pUsers;
                pUsers->InternalAddRef();       // released below...
            }
        }
        else
        {
            //
            // Enumerate users in particular domain...
            //

            ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

            pUsers = (CUsers*)MKOBJ(pDomain->GetUsers(va));
            ASSERT(pUsers && pUsers->IsKindOf(RUNTIME_CLASS(CUsers)));
        }

        if (pUsers)
        {
            CUser* pUser;
            int    nUsers = pUsers->GetCount();

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT|
                          LVIF_PARAM|
                          LVIF_IMAGE;

            lvItem.iSubItem  = 0;

            lvItem.pszText    = LPSTR_TEXTCALLBACK;
            lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;

            lvItem.iImage = BMPI_USER;

            for (va.vt = VT_I4, va.lVal = 0; (va.lVal < nUsers) && NT_SUCCESS(NtStatus); va.lVal++)
            {
                pUser = (CUser*)MKOBJ(pUsers->GetItem(va));
                ASSERT(pUser && pUser->IsKindOf(RUNTIME_CLASS(CUser)));

                if (pUser)
                {
                    lvItem.iItem  = va.lVal;
                    lvItem.lParam  = (LPARAM)(LPVOID)pUser;

                    if (m_userList.InsertItem(&lvItem) == -1)
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }

                    pUser->InternalRelease();
                }
                else
                {
                    NtStatus = STATUS_NO_MEMORY;
                }
            }

            pUsers->InternalRelease();
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }

        VariantClear(&va);
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        m_userList.DeleteAllItems();
        LlsSetLastStatus(NtStatus);
    }

    ::LvResizeColumns(&m_userList, &g_userColumnInfo);

    return NT_SUCCESS(NtStatus);
}


void CAddUsersDialog::OnOK()

/*++

Routine Description:

    Message handler for IDOK.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pObList)
    {
        CUser* pUser;
        int iItem = -1;

        m_pObList->RemoveAll();

        while (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem, LVNI_ALL))
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            m_pObList->AddTail(pUser);
        }
    }

    CDialog::OnOK();
}


void CAddUsersDialog::OnCancel()

/*++

Routine Description:

    Message handler for IDCANCEL.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;

    while (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem, LVNI_ALL))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
        pUser->InternalRelease();
    }

    CDialog::OnCancel();
}


void CAddUsersDialog::InitDialogCtrls()
{
    int iItem = -1;

    if (m_bIsFocusUserList && m_userList.GetItemCount())
    {
        m_addBtn.EnableWindow(TRUE);
        m_delBtn.EnableWindow(FALSE);
    }
    else if (m_bIsFocusAddedList && m_addedList.GetItemCount())
    {
        m_addBtn.EnableWindow(FALSE);
        m_delBtn.EnableWindow(TRUE);
    }
    else
    {
        m_addBtn.EnableWindow(FALSE);
        m_delBtn.EnableWindow(FALSE);
    }

    ::LvResizeColumns(&m_userList,  &g_userColumnInfo);
    ::LvResizeColumns(&m_addedList, &g_addedColumnInfo);
}


void CAddUsersDialog::OnGetdispinfoUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_ITEM lvItem = ((LV_DISPINFO*)pNMHDR)->item;

    if (lvItem.iSubItem == 0)
    {
        CUser* pUser = (CUser*)lvItem.lParam;
        ASSERT(pUser && pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        lstrcpyn(lvItem.pszText, pUser->m_strName, lvItem.cchTextMax);
    }

    *pResult = 0;
}

void CAddUsersDialog::OnKillfocusUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;
}

void CAddUsersDialog::OnSetfocusUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_bIsFocusUserList = TRUE;
    m_bIsFocusAddedList = FALSE;
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}

void CAddUsersDialog::OnKillfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;
}

void CAddUsersDialog::OnSetfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_bIsFocusUserList = FALSE;
    m_bIsFocusAddedList = TRUE;
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}

BOOL CAddUsersDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    if (wParam == ID_INIT_CTRLS)
    {
        InitDialogCtrls();
        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\dlicdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    dlicdlg.cpp

Abstract:

    Delete license dialog implementation.

Author:

    Don Ryan (donryan) 05-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "dlicdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CDeleteLicenseDialog, CDialog)
    //{{AFX_MSG_MAP(CDeleteLicenseDialog)
    ON_NOTIFY(UDN_DELTAPOS, IDC_DEL_LICENSE_SPIN, OnDeltaPosSpin)
    ON_EN_UPDATE(IDC_DEL_LICENSE_QUANTITY, OnUpdateQuantity)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDeleteLicenseDialog::CDeleteLicenseDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CDeleteLicenseDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CDeleteLicenseDialog)
    m_strComment = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    m_strProduct = _T("");
    //}}AFX_DATA_INIT

    m_pProduct = NULL;
    m_nTotalLicenses = 0;
    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CDeleteLicenseDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDeleteLicenseDialog)
    DDX_Control(pDX, IDC_DEL_LICENSE_COMMENT, m_cmtEdit);
    DDX_Control(pDX, IDC_DEL_LICENSE_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_DEL_LICENSE_QUANTITY, m_licEdit);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Control(pDX, IDCANCEL, m_cancelBtn);
    DDX_Text(pDX, IDC_DEL_LICENSE_COMMENT, m_strComment);
    DDX_Text(pDX, IDC_DEL_LICENSE_QUANTITY, m_nLicenses);
    DDV_MinMaxLong(pDX, m_nLicenses, m_nLicensesMin, m_nTotalLicenses);
    DDX_Text(pDX, IDC_DEL_LICENSE_PRODUCT, m_strProduct);
    //}}AFX_DATA_MAP
}


void CDeleteLicenseDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_strProduct = m_pProduct->m_strName;
    UpdateData(FALSE); // upload...

    m_spinCtrl.SetRange(0, UD_MAXVAL);
    
    m_cmtEdit.LimitText(256);

    m_licEdit.SetFocus();
    m_licEdit.SetSel(0,-1);
    m_licEdit.LimitText(6);

    m_bAreCtrlsInitialized = TRUE;
}


void CDeleteLicenseDialog::InitDialog(CProduct* pProduct, int nTotalLicenses)

/*++

Routine Description:

    Initializes dialog.

Arguments:

    pProduct - product object.
    nTotalLicenses - total licenses for product.

Return Values:

    None.

--*/

{
    ASSERT(nTotalLicenses > 0);
    VALIDATE_OBJECT(pProduct, CProduct);

    m_pProduct = pProduct;
    m_nTotalLicenses = nTotalLicenses;
}


void CDeleteLicenseDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortDialog(); // bail...
    }
}


void CDeleteLicenseDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_ABORT;
    EndDialog(IDABORT); 
}


BOOL CDeleteLicenseDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();
    
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CDeleteLicenseDialog::OnOK() 

/*++

Routine Description:

    Deletes a license for product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!IsQuantityValid())
        return;

    if (m_strProduct.IsEmpty())
        return;

    CString strConfirm;
    CString strLicenses;

    strLicenses.Format(_T("%d"), m_nLicenses);
    AfxFormatString2(
        strConfirm, 
        IDP_CONFIRM_DELETE_LICENSE,
        strLicenses,
        m_strProduct
        );

    if (AfxMessageBox(strConfirm, MB_YESNO) != IDYES)
        return;        

    BeginWaitCursor(); // hourglass...

    NTSTATUS NtStatus;
    LLS_LICENSE_INFO_0 LicenseInfo0;

    TCHAR szUserBuffer[256];
    DWORD dwUserBuffer = sizeof(szUserBuffer);
    
    if (::GetUserName(szUserBuffer, &dwUserBuffer))
    {
        LicenseInfo0.Product  = MKSTR(m_strProduct);
        LicenseInfo0.Quantity = -m_nLicenses;
        LicenseInfo0.Date     = 0;  // ignored...
        LicenseInfo0.Admin    = szUserBuffer;
        LicenseInfo0.Comment  = MKSTR(m_strComment);

        NtStatus = ::LlsLicenseAdd(
                        LlsGetActiveHandle(),
                        0,
                        (LPBYTE)&LicenseInfo0
                        );

        if (NtStatus == STATUS_UNSUCCESSFUL)
        {
            //
            // Some licenses for this product have already
            // been deleted so we just pass back success so
            // that we can return to the summary list...
            //

            NtStatus = STATUS_SUCCESS;
            AfxMessageBox(IDP_ERROR_NO_LICENSES);
        }

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))                             
        {                                                     
            m_fUpdateHint = UPDATE_LICENSE_DELETED;
            EndDialog(IDOK);
        }                                                     
        else
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
    else
    {
        LlsSetLastStatus(::GetLastError());
        AbortDialogIfNecessary(); // display error...
    }

    EndWaitCursor(); // hourglass...
}


BOOL CDeleteLicenseDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
        }
        
        ::SafeEnableWindow(
            &m_okBtn, 
            &m_cancelBtn, 
            CDialog::GetFocus(),
            (BOOL)(m_nTotalLicenses > 0)
            );

        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CDeleteLicenseDialog::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;
    
    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);      
    }
    else if (m_nLicenses > m_nTotalLicenses)
    {
        m_nLicenses = m_nTotalLicenses;

        ::MessageBeep(MB_OK);      
    }

    UpdateData(FALSE);  // set data

    *pResult = 1;   // handle ourselves...
}


void CDeleteLicenseDialog::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long nLicensesOld = m_nLicenses;

    if (!IsQuantityValid())
    {
        m_nLicenses = nLicensesOld;

        UpdateData(FALSE);

        m_licEdit.SetFocus();
        m_licEdit.SetSel(0,-1);

        ::MessageBeep(MB_OK);      
    }
}


BOOL CDeleteLicenseDialog::IsQuantityValid()

/*++

Routine Description:

    Wrapper around UpdateData(TRUE).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsValid;

    m_nLicensesMin = 1; // raise minimum...

    bIsValid = UpdateData(TRUE);

    m_nLicensesMin = 0; // reset minimum...

    return bIsValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\ctlobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ctlobj.h

Abstract:

    License controller object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CTLOBJ_H_
#define _CTLOBJ_H_

class CController : public CCmdTarget
{
    DECLARE_DYNCREATE(CController)
private: 
    LPVOID     m_llsHandle;
    BOOL       m_bIsConnected;

    CObArray   m_productArray;
    CObArray   m_licenseArray;
    CObArray   m_mappingArray;
    CObArray   m_userArray;

    BOOL       m_bProductsRefreshed;
    BOOL       m_bLicensesRefreshed;
    BOOL       m_bMappingsRefreshed;
    BOOL       m_bUsersRefreshed;

public:
    CString    m_strName;
    CString    m_strActiveDomainName;   // blah!

    CProducts* m_pProducts;
    CLicenses* m_pLicenses;
    CMappings* m_pMappings;
    CUsers*    m_pUsers;

public:
    CController();
    virtual ~CController();

    BOOL RefreshProducts();
    BOOL RefreshUsers();
    BOOL RefreshMappings();
    BOOL RefreshLicenses();

    void ResetProducts();
    void ResetUsers();
    void ResetMappings();
    void ResetLicenses();

    PVOID GetLlsHandle();
    BSTR  GetActiveDomainName();

    //{{AFX_VIRTUAL(CController)
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CController)
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg BOOL IsConnected();
    afx_msg BOOL Connect(const VARIANT FAR& start);
    afx_msg void Disconnect();
    afx_msg void Refresh();
    afx_msg LPDISPATCH GetMappings(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetUsers(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetLicenses(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetProducts(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CController)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

inline LPVOID CController::GetLlsHandle()
    {   return m_llsHandle;  }

#endif // _CTLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\ctlobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ctlobj.cpp

Abstract:

    License controller object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added SetLastTargetServer() to Connect() to help isolate server
        connection problems.  (Bug #2993.)

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CController, CCmdTarget)

BEGIN_MESSAGE_MAP(CController, CCmdTarget)
    //{{AFX_MSG_MAP(CController)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CController, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CController)
    DISP_PROPERTY_EX(CController, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CController, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CController, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CController, "IsConnected", IsConnected, SetNotSupported, VT_BOOL)
    DISP_FUNCTION(CController, "Connect", Connect, VT_BOOL, VTS_VARIANT)
    DISP_FUNCTION(CController, "Disconnect", Disconnect, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CController, "Refresh", Refresh, VT_EMPTY, VTS_NONE)
    DISP_PROPERTY_PARAM(CController, "Mappings", GetMappings, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Users", GetUsers, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Licenses", GetLicenses, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Products", GetProducts, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CController, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

BOOL IsAdminOn(LPTSTR ServerName);

CController::CController()

/*++

Routine Description:

    Constructor for license controller object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableAutomation();

    m_strName.Empty();

    m_pProducts = NULL;
    m_pUsers    = NULL;
    m_pMappings = NULL;
    m_pLicenses = NULL;

    m_llsHandle   = NULL;

    m_productArray.RemoveAll();
    m_licenseArray.RemoveAll();
    m_mappingArray.RemoveAll();
    m_userArray.RemoveAll();

    m_bProductsRefreshed = FALSE;
    m_bLicensesRefreshed = FALSE;
    m_bMappingsRefreshed = FALSE;
    m_bUsersRefreshed    = FALSE;

    m_bIsConnected = FALSE;
}


CController::~CController()

/*++

Routine Description:

    Destructor for license controller object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    Disconnect();

    if (m_pProducts)
        m_pProducts->InternalRelease();

    if (m_pLicenses)
        m_pLicenses->InternalRelease();

    if (m_pMappings)
        m_pMappings->InternalRelease();

    if (m_pUsers)
        m_pUsers->InternalRelease();
}


BOOL CController::Connect(const VARIANT FAR& start)

/*++

Routine Description:

    Seek out license controller and establish connection.

Arguments:

    start - either a server or domain to start searching for
    the license controller from.

Return Values:

    VT_BOOL.

--*/

{
    VARIANT va;
    VariantInit(&va);

    LPTSTR pControllerName = NULL;

    if (!V_ISVOID((VARIANT FAR*)&start))
    {
        if (start.vt == VT_BSTR)
        {
            pControllerName = start.bstrVal;
        }
        else if (SUCCEEDED(VariantChangeType(&va, (VARIANT FAR*)&start, 0, VT_BSTR)))
        {
            pControllerName = va.bstrVal;
        }
        else
        {
            LlsSetLastStatus(STATUS_INVALID_PARAMETER);
            return FALSE;
        }
    }


    NTSTATUS NtStatus;
    LPVOID llsHandle = NULL;
    PLLS_CONNECT_INFO_0 pConnectInfo0 = NULL;

    NtStatus = ::LlsEnterpriseServerFind(
                    pControllerName,
                    0,
                    (LPBYTE*)&pConnectInfo0
                    );

    if (NT_SUCCESS(NtStatus))
    {
        if (!IsAdminOn( pConnectInfo0->EnterpriseServer ))
        {
            LlsSetLastStatus(STATUS_ACCESS_DENIED);
            return FALSE;
        }

        LlsSetLastTargetServer( pConnectInfo0->EnterpriseServer );

        NtStatus = ::LlsConnect(
                        pConnectInfo0->EnterpriseServer,
                        &llsHandle
                        );

        if (NT_SUCCESS(NtStatus))
        {
            Disconnect();

            m_bIsConnected = TRUE;
            m_llsHandle = llsHandle;

            m_strName = pConnectInfo0->EnterpriseServer;
            m_strActiveDomainName = pConnectInfo0->Domain;

            m_strName.MakeUpper();
            m_strActiveDomainName.MakeUpper();
        }

        ::LlsFreeMemory(pConnectInfo0);
    }
    else
    {
        LlsSetLastTargetServer( TEXT( "" ) );
    }

    VariantClear(&va);

    LlsSetLastStatus(NtStatus);

    return NT_SUCCESS(NtStatus);
}


void CController::Disconnect()

/*++

Routine Description:

    Closes connection to license controller.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_bIsConnected)
    {
        LlsClose(m_llsHandle);

        m_llsHandle      = NULL;
        m_bIsConnected   = FALSE;

        m_strName.Empty();
        m_strActiveDomainName.Empty();

        ResetLicenses();
        ResetProducts();
        ResetUsers();
        ResetMappings();
    }
}


BSTR CController::GetActiveDomainName()

/*++

Routine Description:

    Returns the name of the active domain (internal).

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strActiveDomainName.AllocSysString();
}


LPDISPATCH CController::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


LPDISPATCH CController::GetLicenses(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    license agreements recorded on the license controller
    or returns an individual license agreement described by
    an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pLicenses)
    {
        m_pLicenses = new CLicenses(this, &m_licenseArray);
    }

    if (m_pLicenses)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bLicensesRefreshed)
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
            else if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus( STATUS_NO_MEMORY );
    }

    return lpdispatch;
}


LPDISPATCH CController::GetMappings(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    user/node associations recorded on the license controller
    or returns an individual user/node association described by
    an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a mapping name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pMappings)
    {
        m_pMappings = new CMappings(this, &m_mappingArray);
    }

    if (m_pMappings)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshMappings())
            {
                lpdispatch = m_pMappings->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bMappingsRefreshed)
            {
                lpdispatch = m_pMappings->GetItem(index);
            }
            else if (RefreshMappings())
            {
                lpdispatch = m_pMappings->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BSTR CController::GetName()

/*++

Routine Description:

    Returns the name of the license controller.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CController::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetApplication();
}


LPDISPATCH CController::GetProducts(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    registered products replicated to the license controller
    or returns an individual product described by an index
    into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a product name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pProducts)
    {
        m_pProducts = new CProducts(this, &m_productArray);
    }

    if (m_pProducts)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshProducts())
            {
                lpdispatch = m_pProducts->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bProductsRefreshed)
            {
                lpdispatch = m_pProducts->GetItem(index);
            }
            else if (RefreshProducts())
            {
                lpdispatch = m_pProducts->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


LPDISPATCH CController::GetUsers(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    registered users replicated to the license controller
    or returns an individual user described by an index
    into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a user name or a number (VT_I4) indicating the
    position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pUsers)
    {
        m_pUsers = new CUsers(this, &m_userArray);
    }

    if (m_pUsers)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bUsersRefreshed)
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
            else if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CController::IsConnected()

/*++

Routine Description:

    Returns true if a connection has been established.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsConnected;
}


void CController::Refresh()

/*++

Routine Description:

    Retrieve latest data from license controller.

Arguments:

    None.

Return Values:

    None.

--*/

{
    RefreshProducts();
    RefreshUsers();
    RefreshMappings();
    RefreshLicenses();
}


BOOL CController::RefreshLicenses()

/*++

Routine Description:

    Refreshs license object array.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetLicenses();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iLicense = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsLicenseEnum(
                        m_llsHandle,
                        0,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CLicense*           pLicense;
            PLLS_LICENSE_INFO_0 pLicenseInfo0;

            pLicenseInfo0 = (PLLS_LICENSE_INFO_0)ReturnBuffer;

            ASSERT(iLicense == m_licenseArray.GetSize());
            m_licenseArray.SetSize(m_licenseArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pLicense = new CLicense(
                                this,
                                pLicenseInfo0->Product,
                                pLicenseInfo0->Admin,
                                pLicenseInfo0->Date,
                                pLicenseInfo0->Quantity,
                                pLicenseInfo0->Comment
                                );

                m_licenseArray.SetAt(iLicense++, pLicense); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pLicenseInfo0->Product);
                ::LlsFreeMemory(pLicenseInfo0->Admin);
                ::LlsFreeMemory(pLicenseInfo0->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

                pLicenseInfo0++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bLicensesRefreshed = TRUE;
    }
    else
    {
        ResetLicenses();
    }

    return m_bLicensesRefreshed;
}


BOOL CController::RefreshMappings()

/*++

Routine Description:

    Refreshs mapping object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetMappings();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iMapping = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsGroupEnum(
                        m_llsHandle,
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CMapping*           pMapping ;
            PLLS_GROUP_INFO_1 pMappingInfo1;

            pMappingInfo1 = (PLLS_GROUP_INFO_1)ReturnBuffer;

            ASSERT(iMapping == m_mappingArray.GetSize());
            m_mappingArray.SetSize(m_mappingArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pMapping = new CMapping(
                                  this,
                                  pMappingInfo1->Name,
                                  pMappingInfo1->Licenses,
                                  pMappingInfo1->Comment
                                  );

                m_mappingArray.SetAt(iMapping++, pMapping); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pMappingInfo1->Name);
                ::LlsFreeMemory(pMappingInfo1->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

                pMappingInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bMappingsRefreshed = TRUE;
    }
    else
    {
        ResetMappings();
    }

    return m_bMappingsRefreshed;
}


BOOL CController::RefreshProducts()

/*++

Routine Description:

    Refreshs product object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetProducts();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iProduct = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsProductEnum(
                        m_llsHandle,
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CProduct*           pProduct;
            PLLS_PRODUCT_INFO_1 pProductInfo1;

            pProductInfo1 = (PLLS_PRODUCT_INFO_1)ReturnBuffer;

            ASSERT(iProduct == m_productArray.GetSize());
            m_productArray.SetSize(m_productArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pProduct = new CProduct(
                                  this,
                                  pProductInfo1->Product,
                                  pProductInfo1->Purchased,
                                  pProductInfo1->InUse,
                                  pProductInfo1->ConcurrentTotal,
                                  pProductInfo1->HighMark
                                  );


                m_productArray.SetAt(iProduct++, pProduct); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pProductInfo1->Product);

#endif // DISABLE_PER_NODE_ALLOCATION

                pProductInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);

    if (NT_SUCCESS(NtStatus))
    {
        m_bProductsRefreshed = TRUE;
    }
    else
    {
        ResetProducts();
    }

    return m_bProductsRefreshed;
}


BOOL CController::RefreshUsers()

/*++

Routine Description:

    Refreshs user object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetUsers();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iUser = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsUserEnum(
                        m_llsHandle,
                        2,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CUser*           pUser;
            PLLS_USER_INFO_2 pUserInfo2;

            pUserInfo2 = (PLLS_USER_INFO_2)ReturnBuffer;

            ASSERT(iUser == m_userArray.GetSize());
            m_userArray.SetSize(m_userArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pUser = new CUser(
                             this,
                             pUserInfo2->Name,
                             pUserInfo2->Flags,
                             pUserInfo2->Licensed,
                             pUserInfo2->UnLicensed,
                             pUserInfo2->Group,
                             pUserInfo2->Products
                             );

                m_userArray.SetAt(iUser++, pUser);  // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pUserInfo2->Name);
                ::LlsFreeMemory(pUserInfo2->Group);
                ::LlsFreeMemory(pUserInfo2->Products);

#endif // DISABLE_PER_NODE_ALLOCATION

                pUserInfo2++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bUsersRefreshed = TRUE;
    }
    else
    {
        ResetUsers();
    }

    return m_bUsersRefreshed;
}


void CController::ResetLicenses()

/*++

Routine Description:

    Resets license object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CLicense* pLicense;
    INT_PTR   iLicense = m_licenseArray.GetSize();

    while (iLicense--)
    {
        if (pLicense = (CLicense*)m_licenseArray[iLicense])
        {
            ASSERT(pLicense->IsKindOf(RUNTIME_CLASS(CLicense)));
            pLicense->InternalRelease();
        }
    }

    m_licenseArray.RemoveAll();
    m_bLicensesRefreshed = FALSE;
}


void CController::ResetMappings()

/*++

Routine Description:

    Resets mapping object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CMapping* pMapping;
    INT_PTR   iMapping = m_mappingArray.GetSize();

    while (iMapping--)
    {
        if (pMapping = (CMapping*)m_mappingArray[iMapping])
        {
            ASSERT(pMapping->IsKindOf(RUNTIME_CLASS(CMapping)));
            pMapping->InternalRelease();
        }
    }

    m_mappingArray.RemoveAll();
    m_bMappingsRefreshed = FALSE;
}


void CController::ResetProducts()

/*++

Routine Description:

    Resets product object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CProduct* pProduct;
    INT_PTR   iProduct = m_productArray.GetSize();

    while (iProduct--)
    {
        if (pProduct = (CProduct*)m_productArray[iProduct])
        {
            ASSERT(pProduct->IsKindOf(RUNTIME_CLASS(CProduct)));
            pProduct->InternalRelease();
        }
    }

    m_productArray.RemoveAll();
    m_bProductsRefreshed = FALSE;
}


void CController::ResetUsers()

/*++

Routine Description:

    Resets user object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    INT_PTR iUser = m_userArray.GetSize();

    while (iUser--)
    {
        if (pUser = (CUser*)m_userArray[iUser])
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            pUser->InternalRelease();
        }
    }

    m_userArray.RemoveAll();
    m_bUsersRefreshed = FALSE;
}


BOOL IsAdminOn(LPTSTR ServerName)
/*++

Routine Description:

    Checks for Administrative privilege by attempting to connect to the
    ADMIN$ share on ServerName.

Arguments:

    ServerName - machine with which to attempt a connection

Return Values:

    TRUE if successful, FALSE otherwise.

--*/

{
    BOOL           bIsAdmin = TRUE;
    CString        strNetShareName;
    CString        strServerName = ServerName;

    strNetShareName = strServerName + TEXT( "\\ADMIN$" );

    if ( strNetShareName.Left(2).Compare( TEXT( "\\\\" ) ) )
    {
        strNetShareName = TEXT( "\\\\" ) + strNetShareName;
    }

    NET_API_STATUS  NetStatus;
    USE_INFO_1      UseInfo;
    DWORD           dwErrorParm;

    ZeroMemory( &UseInfo, sizeof( UseInfo ) );

    UseInfo.ui1_remote = MKSTR( strNetShareName );

    NetStatus = NetUseAdd( NULL, 1, (LPBYTE) &UseInfo, &dwErrorParm );

    switch ( NetStatus )
    {
        case NERR_Success:
            NetUseDel( NULL, MKSTR(strNetShareName), 0 );
            // fall through
        case ERROR_BAD_NETPATH:
        case ERROR_BAD_NET_NAME:
        case NERR_WkstaNotStarted:
        case NERR_NetNotStarted:
        case RPC_S_UNKNOWN_IF:
        case RPC_S_SERVER_UNAVAILABLE:
            // On network errors, go ahead and return TRUE.  Let the License
            // APIs fail later if there really is a problem.  The machine may
            // be standalone, or may not have networking installed.
            bIsAdmin = TRUE;
            break;
        default:
            // If we get here, the problem was most likely security related.
            bIsAdmin = FALSE;
            break;
    }

   return bIsAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\dlicdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    dlicdlg.h

Abstract:

    Delete license dialog implementation.

Author:

    Don Ryan (donryan) 05-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DLICDLG_H_
#define _DLICDLG_H_

class CDeleteLicenseDialog : public CDialog
{
private:
    CProduct* m_pProduct;
    int       m_nTotalLicenses;
    BOOL      m_bAreCtrlsInitialized;

public:
    DWORD     m_fUpdateHint;

public:
    CDeleteLicenseDialog(CWnd* pParent = NULL);   

    void InitDialog(CProduct* pProduct, int nTotalLicenses);
    void AbortDialogIfNecessary();
    void AbortDialog();

    void InitCtrls();

    BOOL IsQuantityValid();

    //{{AFX_DATA(CDeleteLicenseDialog)
    enum { IDD = IDD_DELETE_LICENSE };
    CEdit m_cmtEdit;
    CSpinButtonCtrl m_spinCtrl;
    CEdit m_licEdit;
    CButton m_okBtn;
    CButton m_cancelBtn;
    CString m_strComment;
    long m_nLicenses;
    long m_nLicensesMin;
    CString m_strProduct;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CDeleteLicenseDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CDeleteLicenseDialog)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _DLICDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\domcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    domcol.h

Abstract:

    Domain collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DOMCOL_H_
#define _DOMCOL_H_

class CDomains : public CCmdTarget
{
    DECLARE_DYNCREATE(CDomains)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CDomains(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);
    virtual ~CDomains();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDomains)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CDomains)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CDomains)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _DOMCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\domobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    domobj.h

Abstract:

    Domain object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DOMOBJ_H_
#define _DOMOBJ_H_

class CDomain : public CCmdTarget
{
    DECLARE_DYNCREATE(CDomain)
private:
    CCmdTarget* m_pParent;
    CString     m_strPrimary;
    CString     m_strController;
    CObArray    m_serverArray;
    CObArray    m_userArray;
    CObArray    m_domainArray;
    BOOL        m_bServersRefreshed;
    BOOL        m_bUsersRefreshed;
    BOOL        m_bDomainsRefreshed;
                    
public:
    CString     m_strName;

    CServers*   m_pServers;
    CUsers*     m_pUsers;
    CDomains*   m_pDomains;

public:
    CDomain(CCmdTarget* pParent = NULL, LPCTSTR pName = NULL);
    virtual ~CDomain();

    BOOL RefreshServers();
    BOOL RefreshUsers();
    BOOL RefreshDomains();

    void ResetServers();
    void ResetUsers();
    void ResetDomains();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDomain)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CDomain)
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg BSTR GetPrimary();
    afx_msg LPDISPATCH GetApplication();
    afx_msg BSTR GetController();
    afx_msg BOOL IsLogging();
    afx_msg LPDISPATCH GetServers(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetUsers(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetTrustedDomains(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CDomain)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _DOMOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\domobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    domobj.cpp

Abstract:

    Domain object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lmcons.h"
#include "lmapibuf.h"
#include "lmserver.h"
#include "lmaccess.h"
extern "C" {
    #include "dsgetdc.h"
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CDomain, CCmdTarget)

BEGIN_MESSAGE_MAP(CDomain, CCmdTarget)
    //{{AFX_MSG_MAP(CDomain)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDomain, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CDomain)
    DISP_PROPERTY_EX(CDomain, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDomain, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CDomain, "Primary", GetPrimary, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDomain, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CDomain, "Controller", GetController, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CDomain, "IsLogging", IsLogging, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_PARAM(CDomain, "Servers", GetServers, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CDomain, "Users", GetUsers, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CDomain, "TrustedDomains", GetTrustedDomains, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CDomain, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CDomain::CDomain(CCmdTarget* pParent, LPCTSTR pName)

/*++

Routine Description:

    Constructor for domain object.

Arguments:

    pParent - creator of object.
    pName - name of domain.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CApplication)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);

    m_strName = pName;

    m_strPrimary.Empty();
    m_strController.Empty();

    m_pServers = NULL;
    m_pDomains = NULL;
    m_pUsers   = NULL;

    m_serverArray.RemoveAll();
    m_domainArray.RemoveAll();
    m_userArray.RemoveAll();

    m_bServersRefreshed = FALSE;
    m_bDomainsRefreshed = FALSE;
    m_bUsersRefreshed   = FALSE;
}


CDomain::~CDomain()

/*++

Routine Description:

    Destructor for domain object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pUsers)
        m_pUsers->InternalRelease();

    if (m_pServers)
        m_pServers->InternalRelease();

    if (m_pDomains)
        m_pDomains->InternalRelease();
}

void CDomain::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetUsers();
    ResetServers();
    ResetDomains();
    delete this;
}


LPDISPATCH CDomain::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


BSTR CDomain::GetController()

/*++

Routine Description:

    Returns license controller for domain.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return NULL;    // CODEWORK...
}


BSTR CDomain::GetName()

/*++

Routine Description:

    Returns the name of the domain.

Arguments:

    None.

Return Values:

    None.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CDomain::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


BSTR CDomain::GetPrimary()

/*++

Routine Description:

    Returns the name of the ANY domain controller.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    if (m_strPrimary.IsEmpty())
    {
        DWORD NetStatus;
        PDOMAIN_CONTROLLER_INFO pDcInfo;

        NetStatus = DsGetDcName( NULL,
                                 MKSTR(m_strName),
                                 (GUID *)NULL,
                                 NULL,
                                 DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME,
                                 &pDcInfo );


        if (NetStatus == ERROR_SUCCESS)
        {
            m_strPrimary = pDcInfo->DomainControllerName;
            ::NetApiBufferFree((LPBYTE)pDcInfo);
        }

        LlsSetLastStatus(NetStatus);  // called api
    }

    return m_strPrimary.AllocSysString();
}


LPDISPATCH CDomain::GetServers(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    servers in the domain or returns an individual server
    described by an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the server name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pServers)
    {
        m_pServers = new CServers(this, &m_serverArray);
    }

    if (m_pServers)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshServers())
            {
                lpdispatch = m_pServers->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bServersRefreshed)
            {
                lpdispatch = m_pServers->GetItem(index);
            }
            else if (RefreshServers())
            {
                lpdispatch = m_pServers->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


LPDISPATCH CDomain::GetTrustedDomains(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    domains trusted bythe domain or returns an individual
    trusted domain described by an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the domain name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pDomains)
    {
        m_pDomains = new CDomains(this, &m_domainArray);
    }

    if (m_pDomains)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bDomainsRefreshed)
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
            else if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


LPDISPATCH CDomain::GetUsers(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    users in the domain or returns an individual user
    described by an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the user name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pUsers)
    {
        m_pUsers = new CUsers(this, &m_userArray);
    }

    if (m_pUsers)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bUsersRefreshed)
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
            else if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CDomain::IsLogging()

/*++

Routine Description:

    Returns true if primary replicating license information.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return TRUE;    // CODEWORK... LlsEnterpriseServerFind??
}


BOOL CDomain::RefreshDomains()

/*++

Routine Description:

    Refreshs trusted domain array.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetDomains();

    ULONG  DomainCount = 0;
    PDS_DOMAIN_TRUSTS pDomains = NULL;
    NET_API_STATUS NetStatus = 0;
    

    OutputDebugString( L"CDomain::RefreshDomains\n" );
    
    NetStatus = DsEnumerateDomainTrusts( NULL,
                                         // DS_DOMAIN_IN_FOREST |
                                         DS_DOMAIN_DIRECT_OUTBOUND,  //|
                                         // DS_DOMAIN_PRIMARY,
                                         &pDomains,
                                         &DomainCount );

    if (NetStatus == NO_ERROR)
    {
        CDomain* pDomain;
        int DomainsAdded = 0;

        for ( ;DomainCount--; pDomains++)
        {
            if ( (pDomains->Flags
                    & (DS_DOMAIN_IN_FOREST | DS_DOMAIN_DIRECT_OUTBOUND))
                 && (pDomains->TrustType
                    & (TRUST_TYPE_DOWNLEVEL | TRUST_TYPE_UPLEVEL)))
            {
                DBGMSG( L"\tNetbiosDomainName = %s\n" , pDomains->NetbiosDomainName );
                pDomain = new CDomain(this, pDomains->NetbiosDomainName);

                m_domainArray.SetAtGrow(DomainsAdded, pDomain); // validate later
                DomainsAdded++;
            }
        }

        m_domainArray.SetSize(DomainsAdded);

        m_bDomainsRefreshed = TRUE;
        NetApiBufferFree(pDomains);
    }
    
    LlsSetLastStatus(NetStatus);  // called api

    return m_bDomainsRefreshed;
}


BOOL CDomain::RefreshServers()

/*++

Routine Description:

    Refreshs server object array.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetServers();

    NET_API_STATUS NetStatus;
    DWORD ResumeHandle = 0L;

    int iServer = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NetStatus = ::NetServerEnum(
                        NULL,                   // servername
                        100,                    // level
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        SV_TYPE_NT,
                        MKSTR(m_strName),
                        &ResumeHandle
                        );

        if (NetStatus == ERROR_SUCCESS ||
            NetStatus == ERROR_MORE_DATA)
        {
            CServer*         pServer;
            PSERVER_INFO_100 pServerInfo100;

            pServerInfo100 = (PSERVER_INFO_100)ReturnBuffer;

            ASSERT(iServer == m_serverArray.GetSize());
            m_serverArray.SetSize(m_serverArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pServer = new CServer(this, pServerInfo100->sv100_name);

                m_serverArray.SetAt(iServer++, pServer); // validate later
                pServerInfo100++;
            }

            NetApiBufferFree(ReturnBuffer);
        }

    } while (NetStatus == ERROR_MORE_DATA);

    LlsSetLastStatus(NetStatus);  // called api

    if (NetStatus == ERROR_SUCCESS)
    {
        m_bServersRefreshed = TRUE;
    }
    else
    {
        ResetServers();
    }

    return m_bServersRefreshed;
}


BOOL CDomain::RefreshUsers()

/*++

Routine Description:

    Refreshs user object array.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetUsers();

    NET_API_STATUS NetStatus;
    DWORD ResumeHandle = 0L;

    int iUser = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NetStatus = NetUserEnum(
                        GetPrimary(),           // servername
                        0,                      // level
                        FILTER_NORMAL_ACCOUNT,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NetStatus == ERROR_SUCCESS ||
            NetStatus == ERROR_MORE_DATA)
        {
            CUser*       pUser;
            PUSER_INFO_0 pUserInfo0;

            pUserInfo0 = (PUSER_INFO_0)ReturnBuffer;

            ASSERT(iUser == m_userArray.GetSize());
            m_userArray.SetSize(m_userArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pUser = new CUser(this, pUserInfo0->usri0_name);

                m_userArray.SetAt(iUser++, pUser); // validate later
                pUserInfo0++;
            }

            NetApiBufferFree(ReturnBuffer);
        }
    } while (NetStatus == ERROR_MORE_DATA);

    LlsSetLastStatus(NetStatus);  // called api

    if (NetStatus == ERROR_SUCCESS)
    {
        m_bUsersRefreshed = TRUE;
    }
    else
    {
        ResetUsers();
    }

    return m_bUsersRefreshed;
}


void CDomain::ResetDomains()

/*++

Routine Description:

    Resets domain object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDomain* pDomain;
    INT_PTR  iDomain = m_domainArray.GetSize();

    while (iDomain--)
    {
        if (pDomain = (CDomain*)m_domainArray[iDomain])
        {
            ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));
            pDomain->InternalRelease();
        }
    }

    m_domainArray.RemoveAll();
    m_bDomainsRefreshed = FALSE;
}


void CDomain::ResetServers()

/*++

Routine Description:

    Resets server object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CServer* pServer;
    INT_PTR  iServer = m_serverArray.GetSize();

    while (iServer--)
    {
        if (pServer = (CServer*)m_serverArray[iServer])
        {
            ASSERT(pServer->IsKindOf(RUNTIME_CLASS(CServer)));
            pServer->InternalRelease();
        }
    }

    m_serverArray.RemoveAll();
    m_bServersRefreshed = FALSE;
}


void CDomain::ResetUsers()

/*++

Routine Description:

    Resets user object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser*  pUser;
    INT_PTR iUser = m_userArray.GetSize();

    while (iUser--)
    {
        if (pUser = (CUser*)m_userArray[iUser])
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            pUser->InternalRelease();
        }
    }

    m_userArray.RemoveAll();
    m_bUsersRefreshed = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\imagelst.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    imagelst.h

Abstract:

    Constants for shared image list. 

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _IMAGELST_H_
#define _IMAGELST_H_

#define BMPI_RGB_BKGND (RGB(0,255,0))   // green mask...

#define BMPI_ENTERPRISE             0
#define BMPI_DOMAIN                 1
#define BMPI_SERVER                 2
#define BMPI_PRODUCT                3
#define BMPI_PRODUCT_PER_SEAT       4
#define BMPI_PRODUCT_PER_SERVER     5
#define BMPI_USER                   6
#define BMPI_LICENSE_GROUP          7 
#define BMPI_VIOLATION              8
#define BMPI_WARNING_AT_LIMIT       9 

#define BMPI_SMALL_SIZE             18  // one bit border...
#define BMPI_LARGE_SIZE             34  // one bit border...

#endif // _IMAGELST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\domcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    domcol.cpp

Abstract:

    Domain collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CDomains, CCmdTarget)

BEGIN_MESSAGE_MAP(CDomains, CCmdTarget)
    //{{AFX_MSG_MAP(CDomains)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDomains, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CDomains)
    DISP_PROPERTY_EX(CDomains, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CDomains, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CDomains, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CDomains, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CDomains::CDomains(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for domain collection.

    Note AddRef() is not called on theApp.m_pApplication.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CApplication)));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent = pParent;
    m_pObArray = pObArray;
}


CDomains::~CDomains()

/*++

Routine Description:

    Destructor for domain collection.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CDomains::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CDomains::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CDomains::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CDomains::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified domain object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a domain name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CDomain* pDomain;
    INT_PTR  iDomain;

    VARIANT vDomain;
    VariantInit(&vDomain);

    if (iDomain = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iDomain--)
            {
                if (pDomain = (CDomain*)m_pObArray->GetAt(iDomain))
                {
                    ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

                    if (!pDomain->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pDomain->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vDomain, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vDomain.lVal >= 0) && ((int)vDomain.lVal < iDomain))
            {
                if (pDomain = (CDomain*)m_pObArray->GetAt((int)vDomain.lVal))
                {
                    ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));
                    lpdispatch = pDomain->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CDomains::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lgrpdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lgrpdlg.cpp

Abstract:

    License group dialog implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lgrpdlg.h"
#include "nmapdlg.h"
#include "mappsht.h"

#define LVID_MAPPING        0
#define LVID_LICENSES       1
#define LVID_DESCRIPTION    2

#define LVCX_MAPPING        35
#define LVCX_LICENSES       20
#define LVCX_DESCRIPTION    -1

static LV_COLUMN_INFO g_mappingColumnInfo = {

    0, 0, 3,

    {{LVID_MAPPING,     IDS_GROUP_NAME,  0, LVCX_MAPPING    },
     {LVID_LICENSES,    IDS_LICENSES,    0, LVCX_LICENSES   },
     {LVID_DESCRIPTION, IDS_DESCRIPTION, 0, LVCX_DESCRIPTION}},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CLicenseGroupsDialog, CDialog)
    //{{AFX_MSG_MAP(CLicenseGroupsDialog)
    ON_BN_CLICKED(IDC_LICENSE_GROUPS_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_LICENSE_GROUPS_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_LICENSE_GROUPS_ADD, OnAdd)
    ON_NOTIFY(NM_DBLCLK, IDC_LICENSE_GROUPS_MAPPINGS, OnDblClkMappings)
    ON_NOTIFY(NM_RETURN, IDC_LICENSE_GROUPS_MAPPINGS, OnReturnMappings)
    ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_GROUPS_MAPPINGS, OnSetFocusMappings)
    ON_NOTIFY(NM_KILLFOCUS, IDC_LICENSE_GROUPS_MAPPINGS, OnKillFocusMappings)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_GROUPS_MAPPINGS, OnColumnClickMappings)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_LICENSE_GROUPS_MAPPINGS, OnGetDispInfoMappings)  
    ON_COMMAND( ID_EDIT_DELETE , OnDelete )
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CLicenseGroupsDialog::CLicenseGroupsDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CLicenseGroupsDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for license groups dialog.

Arguments:

    pParent - parent window handle.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CLicenseGroupsDialog)
    //}}AFX_DATA_INIT

    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;

    m_hAccel = ::LoadAccelerators( AfxGetInstanceHandle( ) ,
        MAKEINTRESOURCE( IDR_MAINFRAME ) );
}


void CLicenseGroupsDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLicenseGroupsDialog)
    DDX_Control(pDX, IDC_LICENSE_GROUPS_ADD, m_addBtn);
    DDX_Control(pDX, IDC_LICENSE_GROUPS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_LICENSE_GROUPS_EDIT, m_edtBtn);
    DDX_Control(pDX, IDC_LICENSE_GROUPS_MAPPINGS, m_mappingList);
    //}}AFX_DATA_MAP
}


void CLicenseGroupsDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_mappingList.SetFocus();

    m_delBtn.EnableWindow(FALSE);
    m_edtBtn.EnableWindow(FALSE);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_mappingList, &g_mappingColumnInfo);
}


void CLicenseGroupsDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortDialog(); // bail...
    }
}


void CLicenseGroupsDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_ABORT;
    EndDialog(IDABORT);
}


BOOL CLicenseGroupsDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();

    SendMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


void CLicenseGroupsDialog::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_mappingList); // release now...
    CDialog::OnDestroy();
}


BOOL CLicenseGroupsDialog::RefreshCtrls()

/*++

Routine Description:

    Refreshs dialog controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());

    VARIANT va;
    VariantInit(&va);

    BOOL bIsRefreshed = FALSE;

    BeginWaitCursor(); // hourglass...

    if (pController)
    {
        VALIDATE_OBJECT(pController, CController);

        CMappings* pMappings = (CMappings*)MKOBJ(pController->GetMappings(va));

        if (pMappings)
        {
            VALIDATE_OBJECT(pMappings, CMappings);

            bIsRefreshed = ::LvRefreshObArray(
                                &m_mappingList,
                                &g_mappingColumnInfo,
                                pMappings->m_pObArray
                                );

            pMappings->InternalRelease(); // add ref'd individually...
        }

        pController->InternalRelease(); // release now...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_mappingList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}

BOOL CLicenseGroupsDialog::PreTranslateMessage( MSG *pMsg )
{
    if( m_hAccel != NULL )
    {
        if( ::TranslateAccelerator( m_hWnd , m_hAccel , pMsg ) )
        {
            return TRUE;
        }
    }

    return CDialog::PreTranslateMessage( pMsg );
}

void CLicenseGroupsDialog::OnDelete()

/*++

Routine Description:

    Deletes specified mapping.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CMapping* pMapping;    

    if (pMapping = (CMapping*)::LvGetSelObj(&m_mappingList))
    {
        VALIDATE_OBJECT(pMapping, CMapping);

        CString strConfirm;
        AfxFormatString1(
            strConfirm,
            IDP_CONFIRM_DELETE_GROUP,
            pMapping->m_strName
            );

        if (AfxMessageBox(strConfirm, MB_YESNO) != IDYES)
            return; // bail...

        NTSTATUS NtStatus;

        BeginWaitCursor(); // hourglass...

        NtStatus = ::LlsGroupDelete(
                        LlsGetActiveHandle(),
                        MKSTR(pMapping->m_strName)
                        );

        EndWaitCursor(); // hourglass...

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
            NtStatus = STATUS_SUCCESS;

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))
        {
            m_fUpdateHint |= UPDATE_GROUP_DELETED;

            if (!RefreshCtrls())
            {
                AbortDialogIfNecessary(); // display error...
            }
        }
        else
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
}


void CLicenseGroupsDialog::OnEdit()

/*++

Routine Description:

    View properties of mapping.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CMapping* pMapping;

    if (pMapping = (CMapping*)::LvGetSelObj(&m_mappingList))
    {
        VALIDATE_OBJECT(pMapping, CMapping);

        CString strTitle;
        AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pMapping->m_strName);

        CMappingPropertySheet mappingProperties(strTitle);
        mappingProperties.InitPages(pMapping);
        mappingProperties.DoModal();

        m_fUpdateHint |= mappingProperties.m_fUpdateHint;

        if (IsUpdateAborted(mappingProperties.m_fUpdateHint))
        {
            AbortDialog(); // don't display error...
        }
        else if (IsGroupInfoUpdated(mappingProperties.m_fUpdateHint) && !RefreshCtrls())
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
}


void CLicenseGroupsDialog::OnAdd()

/*++

Routine Description:

    Add a new mapping.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CNewMappingDialog newmDlg;
    newmDlg.DoModal();

    if (IsUpdateAborted(newmDlg.m_fUpdateHint))
    {
        AbortDialog(); // don't display error...
    }
    else if (IsGroupInfoUpdated(newmDlg.m_fUpdateHint) && !RefreshCtrls())
    {
        AbortDialogIfNecessary(); // display error...
    }
}


void CLicenseGroupsDialog::OnDblClkMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DLBCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnEdit();
    *pResult = 0;
}


void CLicenseGroupsDialog::OnReturnMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnEdit();
    *pResult = 0;
}


void CLicenseGroupsDialog::OnSetFocusMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CLicenseGroupsDialog::OnKillFocusMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_mappingList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


BOOL CLicenseGroupsDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();

            if (!RefreshCtrls())
            {
                AbortDialogIfNecessary(); // display error...
            }
        }

        ::SafeEnableWindow(
            &m_delBtn,
            &m_addBtn,
            CDialog::GetFocus(),
            m_mappingList.GetItemCount()
            );

        ::SafeEnableWindow(
            &m_edtBtn,
            &m_addBtn,
            CDialog::GetFocus(),
            m_mappingList.GetItemCount()
            );

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CLicenseGroupsDialog::OnColumnClickMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_mappingColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_mappingColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_mappingList.SortItems(CompareMappings, 0);          // use column info

    *pResult = 0;
}


void CLicenseGroupsDialog::OnGetDispInfoMappings(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CMapping* pMapping = (CMapping*)plvItem->lParam;
    VALIDATE_OBJECT(pMapping, CMapping);

    switch (plvItem->iSubItem)
    {
    case LVID_MAPPING:
        plvItem->iImage = BMPI_LICENSE_GROUP;
        lstrcpyn(plvItem->pszText, pMapping->m_strName, plvItem->cchTextMax);
        break;

    case LVID_LICENSES:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pMapping->m_lInUse);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_DESCRIPTION:
        lstrcpyn(plvItem->pszText, pMapping->m_strDescription, plvItem->cchTextMax);
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareMappings(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pMapping1 ((CMapping*)lParam1)
#define pMapping2 ((CMapping*)lParam2)

    VALIDATE_OBJECT(pMapping1, CMapping);
    VALIDATE_OBJECT(pMapping2, CMapping);

    int iResult;

    switch (g_mappingColumnInfo.nSortedItem)
    {
    case LVID_MAPPING:
        iResult = pMapping1->m_strName.CompareNoCase(pMapping2->m_strName);
        break;

    case LVID_LICENSES:
        iResult = pMapping1->m_lInUse - pMapping2->m_lInUse;
        break;

    case LVID_DESCRIPTION:
        iResult = pMapping1->m_strDescription.CompareNoCase(pMapping2->m_strDescription);
        break;

    default:
        iResult = 0;
        break;
    }

    return g_mappingColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lgrpdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lgrpdlg.h

Abstract:

    License group dialog implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LGRPDLG_H_
#define _LGRPDLG_H_

class CLicenseGroupsDialog : public CDialog
{
private:
    BOOL m_bAreCtrlsInitialized;    
    HACCEL m_hAccel;

public:
    DWORD m_fUpdateHint;

public:
    CLicenseGroupsDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CLicenseGroupsDialog)
    enum { IDD = IDD_LICENSE_GROUPS };
    CButton m_addBtn;
    CButton m_delBtn;
    CButton m_edtBtn;
    CListCtrl m_mappingList;
    //}}AFX_DATA

    void AbortDialogIfNecessary();
    void AbortDialog();

    void InitCtrls();   
    BOOL RefreshCtrls();

    //{{AFX_VIRTUAL(CLicenseGroupsDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL PreTranslateMessage( MSG *pMsg );
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CLicenseGroupsDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnAdd();
    afx_msg void OnDblClkMappings(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnMappings(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusMappings(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusMappings(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickMappings(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoMappings(NMHDR* pNMHDR, LRESULT* pResult);    
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareMappings(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _LGRPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\liccol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    liccol.cpp

Abstract:

    License collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLicenses, CCmdTarget)

BEGIN_MESSAGE_MAP(CLicenses, CCmdTarget)
    //{{AFX_MSG_MAP(CLicenses)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CLicenses, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CLicenses)
    DISP_PROPERTY_EX(CLicenses, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CLicenses, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CLicenses, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CLicenses, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CLicenses::CLicenses(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for license collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CProduct)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CController))));
#endif // ENABLE_PARENT_CHECK

    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CLicenses::~CLicenses()

/*++

Routine Description:

    Destructor for license collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CLicenses::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CLicenses::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CLicenses::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CLicenses::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified license object from collection.

Arguments:

    index - optional argument that may a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CLicense* pLicense;
    INT_PTR   iLicense;

    VARIANT vLicense;
    VariantInit(&vLicense);

    if (iLicense = m_pObArray->GetSize())
    {
        if (SUCCEEDED(VariantChangeType(&vLicense, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vLicense.lVal >= 0) && ((int)vLicense.lVal < iLicense))
            {
                if (pLicense = (CLicense*)m_pObArray->GetAt((int)vLicense.lVal))
                {
                    ASSERT(pLicense->IsKindOf(RUNTIME_CLASS(CLicense)));
                    lpdispatch = pLicense->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CLicenses::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\liccol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    liccol.h

Abstract:

    License collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LICCOL_H_
#define _LICCOL_H_

class CLicenses : public CCmdTarget
{
    DECLARE_DYNCREATE(CLicenses)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CLicenses(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CLicenses();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicenses)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CLicenses)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CLicenses)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _LICCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\licobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    licobj.h

Abstract:

    License object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LICOBJ_H_
#define _LICOBJ_H_

class CLicense : public CCmdTarget
{
    DECLARE_DYNCREATE(CLicense)
private:
    CCmdTarget* m_pParent;

public:
    CString     m_strDate;
    CString     m_strUser;
    CString     m_strProduct;
    CString     m_strDescription;
    long        m_lDate;
    long        m_lQuantity;

public:
    CLicense(
        CCmdTarget* pParent      = NULL,
        LPCTSTR     pProduct     = NULL,
        LPCTSTR     pUser        = NULL,
        long        lDate        = 0,
        long        lQuantity    = 0,
        LPCTSTR     pDescription = NULL
        );           
    virtual ~CLicense();

    BSTR GetDateString();

    //{{AFX_VIRTUAL(CLicense)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CLicense)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg DATE GetDate();
    afx_msg BSTR GetDescription();
    afx_msg BSTR GetProductName();
    afx_msg long GetQuantity();
    afx_msg BSTR GetUserName();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CLicense)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _LICOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\licobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    licobj.cpp

Abstract:

    License object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLicense, CCmdTarget)

BEGIN_MESSAGE_MAP(CLicense, CCmdTarget)
    //{{AFX_MSG_MAP(CLicense)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CLicense, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CLicense)
    DISP_PROPERTY_EX(CLicense, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CLicense, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CLicense, "Date", GetDate, SetNotSupported, VT_DATE)
    DISP_PROPERTY_EX(CLicense, "Description", GetDescription, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CLicense, "ProductName", GetProductName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CLicense, "Quantity", GetQuantity, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CLicense, "UserName", GetUserName, SetNotSupported, VT_BSTR)
    DISP_DEFVALUE(CLicense, "ProductName")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CLicense::CLicense(
    CCmdTarget* pParent,
    LPCTSTR     pProduct,
    LPCTSTR     pUser,
    long        lDate,
    long        lQuantity,
    LPCTSTR     pDescription
)

/*++

Routine Description:

    Constructor for license object.

Arguments:

    pParent - creator of object.
    pUser - user who purchased license.
    pProduct - server product licensed.
    lDate - date of purchase.
    lQuantity - number of licenses purchased.
    pDescription - user-defined comment.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CProduct)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CController))));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pUser && *pUser);
    ASSERT(pProduct && *pProduct);

    m_strUser        = pUser;
    m_strProduct     = pProduct;
    m_strDescription = pDescription;

    m_lQuantity = lQuantity;
    m_lDate     = lDate;
}


CLicense::~CLicense()

/*++

Routine Description:

    Destructor for license object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CLicense::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CLicense::GetApplication() 

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


DATE CLicense::GetDate() 

/*++

Routine Description:

    Returns the date of the purchase.

Arguments:

    None.

Return Values:

    VT_DATE.

--*/

{
    return SecondsSince1980ToDate(m_lDate);   
}


BSTR CLicense::GetDescription() 

/*++

Routine Description:

    Returns the user-defined message describing the purchase.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strDescription.AllocSysString();
}


LPDISPATCH CLicense::GetParent() 

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


BSTR CLicense::GetProductName() 

/*++

Routine Description:

    Returns the name of the server product purchased.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strProduct.AllocSysString();
}


long CLicense::GetQuantity() 

/*++

Routine Description:

    Returns the number of clients purchased or deleted.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lQuantity;
}


BSTR CLicense::GetUserName() 

/*++

Routine Description:

    Returns the name of the administrator made the purchase.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strUser.AllocSysString();
}


BSTR CLicense::GetDateString()

/*++

Routine Description:

    Returns the date as a string.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    VARIANT vaIn;
    VARIANT vaOut;

    VariantInit(&vaIn);
    VariantInit(&vaOut);

    vaIn.vt = VT_DATE;
    vaIn.date = SecondsSince1980ToDate(m_lDate);

    BSTR bstrDate = NULL;

    if (SUCCEEDED(VariantChangeType(&vaOut, &vaIn, 0, VT_BSTR)))
    {
        bstrDate = vaOut.bstrVal;
    }

    return bstrDate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsdoc.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsdoc.cpp

Abstract:

    Document implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "llsdoc.h"
#include "llsview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLlsmgrDoc, CDocument)

BEGIN_MESSAGE_MAP(CLlsmgrDoc, CDocument)
    //{{AFX_MSG_MAP(CLlsmgrDoc)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CLlsmgrDoc, CDocument)
    //{{AFX_DISPATCH_MAP(CLlsmgrDoc)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CLlsmgrDoc::CLlsmgrDoc()

/*++

Routine Description:

    Constructor for document object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_pDomain   = NULL;
    m_pController = NULL;
}


CLlsmgrDoc::~CLlsmgrDoc()

/*++

Routine Description:

    Destructor for document object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


#ifdef _DEBUG

void CLlsmgrDoc::AssertValid() const

/*++

Routine Description:

    Validates object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDocument::AssertValid();
}

#endif //_DEBUG


#ifdef _DEBUG

void CLlsmgrDoc::Dump(CDumpContext& dc) const

/*++

Routine Description:

    Dumps contents of object.

Arguments:

    dc - dump context.

Return Values:

    None.

--*/

{
    CDocument::Dump(dc);
}

#endif //_DEBUG


CController* CLlsmgrDoc::GetController()

/*++

Routine Description:

    Retrieves current controller object.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    if (!m_pController)
    {
        m_pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
        VALIDATE_OBJECT(m_pController, CController);

        if (m_pController)
            m_pController->InternalRelease();   // held open by CApplication
    }
    
    return m_pController;    
}


CDomain* CLlsmgrDoc::GetDomain()    

/*++

Routine Description:

    Retrieves current domain object.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    if (!m_pDomain)
    {
        m_pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetActiveDomain());
        VALIDATE_OBJECT(m_pDomain, CDomain);

        if (m_pDomain)
            m_pDomain->InternalRelease();   // held open by CApplication
    }
    
    return m_pDomain;    
}


CLicenses* CLlsmgrDoc::GetLicenses()

/*++

Routine Description:

    Retrieves current list of licenses.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    CLicenses* pLicenses = NULL;

    GetController();    // initialize if necessary

    if (m_pController)
    {    
        VARIANT va;
        VariantInit(&va);

        pLicenses = (CLicenses*)MKOBJ(m_pController->GetLicenses(va));

        if (pLicenses)
            pLicenses->InternalRelease(); // held open by CController  
    }
    
    return pLicenses;    
}


CMappings* CLlsmgrDoc::GetMappings()  

/*++

Routine Description:

    Retrieves current list of mappings.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    CMappings* pMappings = NULL;

    GetController();    // initialize if necessary

    if (m_pController)
    {    
        VARIANT va;
        VariantInit(&va);

        pMappings = (CMappings*)MKOBJ(m_pController->GetMappings(va));

        if (pMappings)
            pMappings->InternalRelease(); // held open by CController  
    }
    
    return pMappings;    
}


CProducts* CLlsmgrDoc::GetProducts()  

/*++

Routine Description:

    Retrieves current list of products.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    CProducts* pProducts = NULL;

    GetController();    // initialize if necessary

    if (m_pController)
    {    
        VARIANT va;
        VariantInit(&va);

        pProducts = (CProducts*)MKOBJ(m_pController->GetProducts(va));

        if (pProducts)
            pProducts->InternalRelease(); // held open by CController  
    }
    
    return pProducts;    
}


CUsers* CLlsmgrDoc::GetUsers()     

/*++

Routine Description:

    Retrieves current list of users.

Arguments:

    None.

Return Values:

    Object pointer or NULL.

--*/

{
    CUsers* pUsers = NULL;

    GetController();    // initialize if necessary

    if (m_pController)
    {    
        VARIANT va;
        VariantInit(&va);

        pUsers = (CUsers*)MKOBJ(m_pController->GetUsers(va));

        if (pUsers)
            pUsers->InternalRelease(); // held open by CController  
    }
    
    return pUsers;    
}


void CLlsmgrDoc::OnCloseDocument() 

/*++

Routine Description:

    Called by framework to close document.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDocument::OnCloseDocument();
}


BOOL CLlsmgrDoc::OnNewDocument()

/*++

Routine Description:

    Called by framework to open new document.

Arguments:

    None.

Return Values:

    Returns true if document successfully opened.

--*/

{
    return TRUE;    // always succeeds
}


BOOL CLlsmgrDoc::OnOpenDocument(LPCTSTR lpszPathName) 

/*++

Routine Description:

    Called by framework to open existing document.

Arguments:

    lpszPathName - file name. 

Return Values:

    Returns true if document successfully opened.

--*/

{
    Update();   // invalidate info...

    CString strTitle;

    if (LlsGetApp()->IsFocusDomain())
    {
        CDomain* pDomain = GetDomain();
        VALIDATE_OBJECT(pDomain, CDomain);

        strTitle = pDomain->m_strName;

        POSITION position = GetFirstViewPosition();
        ((CLlsmgrView*)GetNextView(position))->AddToMRU(strTitle);
    }
    else
    {
        strTitle.LoadString(IDS_ENTERPRISE);
    }

    SetTitle(strTitle);  

    return TRUE;    // always succeeds
}


BOOL CLlsmgrDoc::OnSaveDocument(LPCTSTR lpszPathName) 

/*++

Routine Description:

    Called by framework to save open document.

Arguments:

    None.

Return Values:

    Returns true if document successfully saved.

--*/

{
    return TRUE;    // always succeeds
}


void CLlsmgrDoc::Update()

/*++

Routine Description:

    Resets information so its updated when queried.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_pDomain = NULL;
}


BOOL CLlsmgrDoc::SaveModified() 

/*++

Routine Description:

    Called by framework to determine if document can be saved modified.

Arguments:

    None.

Return Values:

    Returns true if document can be saved.

--*/

{
    return TRUE;    // always succeeds
}


void CLlsmgrDoc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU) 

/*++

Routine Description:

    Called by framework to save pathname in MRU list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CLlsmgrDoc::Serialize(CArchive& ar)

/*++

Routine Description:

    Called by framework for document i/o.

Arguments:

    ar - archive object.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsimp.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsimp.h

Abstract:

    Imported definitions (dirty laundry).

Author:

    Don Ryan (donryan) 29-Jan-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LLSIMP_H_
#define _LLSIMP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT

typedef long NTSTATUS;

#define NT_SUCCESS(Status)              ((NTSTATUS)Status >= 0)
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0x00000001L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#define STATUS_INVALID_PARAMETER        ((NTSTATUS)0xC000000DL)
#define STATUS_INVALID_HANDLE           ((NTSTATUS)0xC0000008L)
#define STATUS_ACCESS_DENIED            ((NTSTATUS)0xC0000022L)
#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L)
#define STATUS_MEMBER_IN_GROUP          ((NTSTATUS)0xC0000067L)
#define STATUS_NOT_SUPPORTED            ((NTSTATUS)0xC00000BBL)
#define STATUS_NOT_FOUND                ((NTSTATUS)0xC0000225L)
#define RPC_NT_SERVER_UNAVAILABLE       ((NTSTATUS)0xC0020017L)
#define RPC_NT_SS_CONTEXT_MISMATCH      ((NTSTATUS)0xC0030005L)

#define IsConnectionDropped(Status)                        \
    (((NTSTATUS)(Status) == STATUS_INVALID_HANDLE)      || \
     ((NTSTATUS)(Status) == RPC_NT_SERVER_UNAVAILABLE)  || \
     ((NTSTATUS)(Status) == RPC_NT_SS_CONTEXT_MISMATCH) || \
     ((NTSTATUS)(Status) == RPC_S_SERVER_UNAVAILABLE)   || \
     ((NTSTATUS)(Status) == RPC_S_CALL_FAILED))

#define LLS_PREFERRED_LENGTH            ((DWORD)-1L)

#define V_ISVOID(va)                                              \
(                                                                 \
    (V_VT(va) == VT_EMPTY) ||                                     \
    (V_VT(va) == VT_ERROR && V_ERROR(va) == DISP_E_PARAMNOTFOUND) \
)                                                                         

#define POLICY_VIEW_LOCAL_INFORMATION   0x00000001L
#define POLICY_LOOKUP_NAMES             0x00000800L

#define LLS_DESIRED_ACCESS    (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES )

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    LPVOID Sid; // PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

NTSTATUS
NTAPI
LsaOpenPolicy(
    IN PLSA_UNICODE_STRING SystemName,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS
NTAPI
LsaFreeMemory(
    IN PVOID Buffer
    );

NTSTATUS
NTAPI
LsaClose(
    IN LSA_HANDLE ObjectHandle
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( LSA_OBJECT_ATTRIBUTES );      \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PLSA_UNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

#ifdef __cplusplus
}
#endif

#endif // _LLSIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsdoc.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsdoc.h

Abstract:

    Document implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LLSDOC_H_
#define _LLSDOC_H_

class CLlsmgrDoc : public CDocument
{
    DECLARE_DYNCREATE(CLlsmgrDoc)
private:
    CController* m_pController;
    CDomain*     m_pDomain;

public:
    CLlsmgrDoc();
    virtual ~CLlsmgrDoc();

    void Update();

    CLicenses*   GetLicenses();  
    CProducts*   GetProducts();  
    CUsers*      GetUsers();     
    CMappings*   GetMappings();  
    CController* GetController();
    CDomain*     GetDomain();    

    virtual void Serialize(CArchive& ar);   

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    //{{AFX_VIRTUAL(CLlsmgrDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void OnCloseDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    protected:
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CLlsmgrDoc)
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CLlsmgrDoc)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _LLSDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsmgr.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsmgr.h

Abstract:

    Application object implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Removed use of "llsimp.h" (which duplicated select info from system
        header files) and "llsapi.h" (which has been folded into stdafx.h),
        transferring all unduplicated information to the tail of this file.

--*/

#ifndef _LLSMGR_H_
#define _LLSMGR_H_

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"
#include "imagelst.h"
#include "utils.h"

//
// Collections
//

#include "prdcol.h"
#include "liccol.h"
#include "mapcol.h"
#include "usrcol.h"
#include "sstcol.h"
#include "stacol.h"
#include "domcol.h"
#include "srvcol.h"
#include "svccol.h"

//
// Collection items
//

#include "prdobj.h"
#include "licobj.h"
#include "mapobj.h"
#include "usrobj.h"
#include "sstobj.h"
#include "staobj.h"
#include "domobj.h"
#include "srvobj.h"
#include "svcobj.h"
#include "ctlobj.h"
#include "appobj.h"


class CLlsmgrApp : public CWinApp
{
private:
    BOOL                m_bIsAutomated;
    CApplication*       m_pApplication;
    CSingleDocTemplate* m_pDocTemplate;

#ifdef _DEBUG
    CMemoryState        m_initMem;
#endif

public:
    CImageList          m_smallImages;
    CImageList          m_largeImages;

public:
    CLlsmgrApp();

    CDocTemplate* GetDocTemplate();
    CApplication* GetApplication();
    IDispatch*    GetAppIDispatch();

    BOOL OnAppStartup();
    void DisplayStatus(long NtStatus);
    void DisplayLastStatus();

    //{{AFX_VIRTUAL(CLlsmgrApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
    //}}AFX_VIRTUAL

    //{{AFX_MSG(CLlsmgrApp)
    afx_msg void OnAppAbout();
    //}}AFX_MSG

    virtual void WinHelp( DWORD_PTR dwData, UINT nCmd );

    DECLARE_MESSAGE_MAP()

    friend class CApplication;  // accesses m_pApplication;
};

extern CLlsmgrApp theApp;

inline CDocTemplate* CLlsmgrApp::GetDocTemplate()
    { return m_pDocTemplate; }

inline CApplication* CLlsmgrApp::GetApplication()
    { return m_pApplication; }

inline IDispatch* CLlsmgrApp::GetAppIDispatch()
    { return m_pApplication->GetIDispatch(TRUE); }

inline CCmdTarget* GetObjFromIDispatch(IDispatch* pIDispatch)
    { return pIDispatch ? CCmdTarget::FromIDispatch(pIDispatch) : NULL; }

#define MKSTR(x) ((LPTSTR)(LPCTSTR)(x))
#define MKOBJ(x) (::GetObjFromIDispatch(x))

#define LlsGetApp() (theApp.GetApplication())
#define LlsGetLastStatus() (theApp.GetApplication()->GetLastStatus())
#define LlsSetLastStatus(s) (theApp.GetApplication()->SetLastStatus((s)))
#define LlsGetActiveHandle() (theApp.GetApplication()->GetActiveHandle())
#define LlsGetLastTargetServer() (theApp.GetApplication()->GetLastTargetServer())
#define LlsSetLastTargetServer(s) (theApp.GetApplication()->SetLastTargetServer(s))

#define IsConnectionDropped(Status)                        \
    (((NTSTATUS)(Status) == STATUS_INVALID_HANDLE)      || \
     ((NTSTATUS)(Status) == RPC_NT_SERVER_UNAVAILABLE)  || \
     ((NTSTATUS)(Status) == RPC_NT_SS_CONTEXT_MISMATCH) || \
     ((NTSTATUS)(Status) == RPC_S_SERVER_UNAVAILABLE)   || \
     ((NTSTATUS)(Status) == RPC_S_CALL_FAILED))

#define LLS_PREFERRED_LENGTH            ((DWORD)-1L)

#define V_ISVOID(va)                                              \
(                                                                 \
    (V_VT(va) == VT_EMPTY) ||                                     \
    (V_VT(va) == VT_ERROR && V_ERROR(va) == DISP_E_PARAMNOTFOUND) \
)

#define LLS_DESIRED_ACCESS    (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES )

#endif // _LLSMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsview.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsview.cpp

Abstract:

    View window implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        o  Ported to CCF API to add/remove licenses.
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).
        o  Added better error message in case where a server being expanded
           in the server browser is not configured for the License Service.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "llsdoc.h"
#include "llsview.h"
#include "prdpsht.h"
#include "usrpsht.h"
#include "mappsht.h"
#include "srvpsht.h"
#include "sdomdlg.h"
#include "lmoddlg.h"
#include "lgrpdlg.h"
#include "nmapdlg.h"

static const TCHAR szRegKeyLlsmgr[]             = REG_KEY_LLSMGR;
static const TCHAR szRegKeyLlsmgrMruList[]      = REG_KEY_LLSMGR_MRU_LIST;
static const TCHAR szRegKeyLlsmgrFontFaceName[] = REG_KEY_LLSMGR_FONT_FACENAME;
static const TCHAR szRegKeyLlsmgrFontHeight[]   = REG_KEY_LLSMGR_FONT_HEIGHT;
static const TCHAR szRegKeyLlsmgrFontWeight[]   = REG_KEY_LLSMGR_FONT_WEIGHT;
static const TCHAR szRegKeyLlsmgrFontItalic[]   = REG_KEY_LLSMGR_FONT_ITALIC;
static const TCHAR szRegKeyLlsmgrSaveSettings[] = REG_KEY_LLSMGR_SAVE_SETTINGS;
static const TCHAR szRegKeyLlsmgrFontCharset[] = REG_KEY_LLSMGR_FONT_CHARSET;

static LV_COLUMN_INFO g_licenseColumnInfo = {

    0, 1, LVID_PURCHASE_HISTORY_TOTAL_COLUMNS,

    {{LVID_SEPARATOR,                      0,                  0,                     0                                  },
     {LVID_PURCHASE_HISTORY_DATE,          IDS_DATE,           IDS_DATE_MENUOPT,           LVCX_PURCHASE_HISTORY_DATE         },
     {LVID_PURCHASE_HISTORY_PRODUCT,       IDS_PRODUCT,        IDS_PRODUCT_MENUOPT,        LVCX_PURCHASE_HISTORY_PRODUCT      },
     {LVID_PURCHASE_HISTORY_QUANTITY,      IDS_QUANTITY,       IDS_QUANTITY_MENUOPT,       LVCX_PURCHASE_HISTORY_QUANTITY     },
     {LVID_PURCHASE_HISTORY_ADMINISTRATOR, IDS_ADMINISTRATOR,  IDS_ADMINISTRATOR_MENUOPT,  LVCX_PURCHASE_HISTORY_ADMINISTRATOR},
     {LVID_PURCHASE_HISTORY_COMMENT,       IDS_COMMENT,        IDS_COMMENT_MENUOPT,        LVCX_PURCHASE_HISTORY_COMMENT      }},

};

static LV_COLUMN_INFO g_productColumnInfo = {

    0, 0, LVID_PRODUCTS_VIEW_TOTAL_COLUMNS,

    {{LVID_PRODUCTS_VIEW_NAME,                 IDS_PRODUCT,              IDS_PRODUCT_MENUOPT,              LVCX_PRODUCTS_VIEW_NAME                },
     {LVID_PRODUCTS_VIEW_PER_SEAT_PURCHASED,   IDS_PER_SEAT_PURCHASED,   IDS_PER_SEAT_PURCHASED_MENUOPT,   LVCX_PRODUCTS_VIEW_PER_SEAT_PURCHASED  },
     {LVID_PRODUCTS_VIEW_PER_SEAT_CONSUMED,    IDS_PER_SEAT_CONSUMED,    IDS_PER_SEAT_CONSUMED_MENUOPT,    LVCX_PRODUCTS_VIEW_PER_SEAT_CONSUMED   },
     {LVID_PRODUCTS_VIEW_PER_SERVER_PURCHASED, IDS_PER_SERVER_PURCHASED, IDS_PER_SERVER_PURCHASED_MENUOPT, LVCX_PRODUCTS_VIEW_PER_SERVER_PURCHASED},
     {LVID_PRODUCTS_VIEW_PER_SERVER_REACHED,   IDS_PER_SERVER_REACHED,   IDS_PER_SERVER_REACHED_MENUOPT,   LVCX_PRODUCTS_VIEW_PER_SERVER_REACHED  }},

};

static LV_COLUMN_INFO g_userColumnInfo = {

    0, 0, LVID_PER_SEAT_CLIENTS_TOTAL_COLUMNS,

    {{LVID_PER_SEAT_CLIENTS_NAME,             IDS_USER_NAME,        IDS_USER_NAME_MENUOPT,        LVCX_PER_SEAT_CLIENTS_NAME            },
     {LVID_PER_SEAT_CLIENTS_LICENSED_USAGE,   IDS_LICENSED_USAGE,   IDS_LICENSED_USAGE_MENUOPT,   LVCX_PER_SEAT_CLIENTS_LICENSED_USAGE  },
     {LVID_PER_SEAT_CLIENTS_UNLICENSED_USAGE, IDS_UNLICENSED_USAGE, IDS_UNLICENSED_USAGE_MENUOPT, LVCX_PER_SEAT_CLIENTS_UNLICENSED_USAGE},
     {LVID_PER_SEAT_CLIENTS_SERVER_PRODUCTS,  IDS_PRODUCTS,         IDS_PRODUCTS_MENUOPT,         LVCX_PER_SEAT_CLIENTS_SERVER_PRODUCTS }},

};

static TC_TAB_INFO g_tcTabInfo = {

    TCID_TOTAL_TABS,
    {{TCID_PURCHASE_HISTORY, IDS_PURCHASE_HISTORY, TCE_LISTVIEW|TCE_FORMAT_REPORT|TCE_SUPPORTS_SORT,   NULL, &g_licenseColumnInfo},
     {TCID_PRODUCTS_VIEW,    IDS_PRODUCTS_VIEW,    TCE_LISTVIEW|TCE_FORMAT_REPORT|TCE_SUPPORTS_ALL,    NULL, &g_productColumnInfo},
     {TCID_PER_SEAT_CLIENTS, IDS_PER_SEAT_CLIENTS, TCE_LISTVIEW|TCE_FORMAT_REPORT|TCE_SUPPORTS_ALL,    NULL, &g_userColumnInfo   },
     {TCID_SERVER_BROWSER,   IDS_SERVER_BROWSER,   TCE_TREEVIEW|TCE_SUPPORTS_EDIT,                     NULL, NULL                }},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLlsmgrView, CView)

BEGIN_MESSAGE_MAP(CLlsmgrView, CView)
    //{{AFX_MSG_MAP(CLlsmgrView)
    ON_WM_SIZE()
    ON_COMMAND(ID_SELECT_FONT, OnSelectFont)
    ON_COMMAND(ID_VIEW_LICENSES, OnViewLicenses)
    ON_COMMAND(ID_VIEW_MAPPINGS, OnViewMappings)
    ON_COMMAND(ID_VIEW_PRODUCTS, OnViewProducts)
    ON_COMMAND(ID_VIEW_SERVERS, OnViewServers)
    ON_COMMAND(ID_VIEW_USERS, OnViewUsers)
    ON_COMMAND(ID_VIEW_DELETE, OnDelete)
    ON_COMMAND(ID_VIEW_ICONS, OnFormatIcons)
    ON_COMMAND(MY_ID_VIEW_LIST, OnFormatList)
    ON_COMMAND(ID_VIEW_PROPERTIES, OnViewProperties)
    ON_COMMAND(ID_VIEW_REFRESH, OnViewRefresh)
    ON_COMMAND(ID_VIEW_REPORT, OnFormatReport)
    ON_COMMAND(ID_VIEW_SMALL_ICONS, OnFormatSmallIcons)
    ON_WM_CREATE()
    ON_COMMAND(ID_SORT_COLUMN0, OnSortColumn0)
    ON_COMMAND(ID_SORT_COLUMN1, OnSortColumn1)
    ON_COMMAND(ID_SORT_COLUMN2, OnSortColumn2)
    ON_COMMAND(ID_SORT_COLUMN3, OnSortColumn3)
    ON_COMMAND(ID_SORT_COLUMN4, OnSortColumn4)
    ON_COMMAND(ID_SORT_COLUMN5, OnSortColumn5)
    ON_COMMAND(ID_NEW_LICENSE, OnNewLicense)
    ON_COMMAND(ID_NEW_MAPPING, OnNewMapping)
    ON_COMMAND(ID_SELECT_DOMAIN, OnSelectDomain)
    ON_COMMAND(ID_SAVE_SETTINGS, OnSaveSettings)
    ON_UPDATE_COMMAND_UI(ID_SAVE_SETTINGS, OnUpdateSaveSettings)
    ON_UPDATE_COMMAND_UI(ID_VIEW_DELETE, OnUpdateViewDelete)
    ON_UPDATE_COMMAND_UI(ID_VIEW_PROPERTIES, OnUpdateViewProperties)
    ON_WM_ERASEBKGND()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_NOTIFY(TCN_SELCHANGING,   IDC_VIEW_TAB_CTRL,     OnSelChangingTabCtrl)
    ON_NOTIFY(TCN_SELCHANGE,     IDC_VIEW_TAB_CTRL,     OnSelChangeTabCtrl)
    ON_NOTIFY(TCN_KEYDOWN,       IDC_VIEW_TAB_CTRL,     OnKeyDownTabCtrl)
    ON_NOTIFY(NM_SETFOCUS,       IDC_VIEW_TAB_CTRL,     OnSetFocusTabCtrl)

    ON_NOTIFY(LVN_KEYDOWN,       IDC_VIEW_LICENSE_LIST, OnKeyDownLicenseList)
    ON_NOTIFY(LVN_COLUMNCLICK,   IDC_VIEW_LICENSE_LIST, OnColumnClickLicenseList)
    ON_NOTIFY(LVN_GETDISPINFO,   IDC_VIEW_LICENSE_LIST, OnGetDispInfoLicenseList)
    ON_NOTIFY(NM_SETFOCUS,       IDC_VIEW_LICENSE_LIST, OnSetFocusLicenseList)

    ON_NOTIFY(LVN_KEYDOWN,       IDC_VIEW_PRODUCT_LIST, OnKeyDownProductList)
    ON_NOTIFY(NM_DBLCLK,         IDC_VIEW_PRODUCT_LIST, OnDblClkProductList)
    ON_NOTIFY(NM_RETURN,         IDC_VIEW_PRODUCT_LIST, OnReturnProductList)
    ON_NOTIFY(LVN_COLUMNCLICK,   IDC_VIEW_PRODUCT_LIST, OnColumnClickProductList)
    ON_NOTIFY(LVN_GETDISPINFO,   IDC_VIEW_PRODUCT_LIST, OnGetDispInfoProductList)
    ON_NOTIFY(NM_SETFOCUS,       IDC_VIEW_PRODUCT_LIST, OnSetFocusProductList)

    ON_NOTIFY(LVN_KEYDOWN,       IDC_VIEW_USER_LIST,    OnKeyDownUserList)
    ON_NOTIFY(NM_DBLCLK,         IDC_VIEW_USER_LIST,    OnDblClkUserList)
    ON_NOTIFY(NM_RETURN,         IDC_VIEW_USER_LIST,    OnReturnUserList)
    ON_NOTIFY(LVN_COLUMNCLICK,   IDC_VIEW_USER_LIST,    OnColumnClickUserList)
    ON_NOTIFY(LVN_GETDISPINFO,   IDC_VIEW_USER_LIST,    OnGetDispInfoUserList)
    ON_NOTIFY(NM_SETFOCUS,       IDC_VIEW_USER_LIST,    OnSetFocusUserList)

    ON_NOTIFY(TVN_KEYDOWN,       IDC_VIEW_SERVER_TREE,  OnKeyDownServerTree)
    ON_NOTIFY(NM_DBLCLK,         IDC_VIEW_SERVER_TREE,  OnDblClkServerTree)
    ON_NOTIFY(NM_RETURN,         IDC_VIEW_SERVER_TREE,  OnReturnServerTree)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_VIEW_SERVER_TREE,  OnItemExpandingServerTree)
    ON_NOTIFY(TVN_GETDISPINFO,   IDC_VIEW_SERVER_TREE,  OnGetDispInfoServerTree)
    ON_NOTIFY(NM_SETFOCUS,       IDC_VIEW_SERVER_TREE,  OnSetFocusServerTree)

    ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)

    ON_COMMAND_EX_RANGE(ID_MRU_DOMAIN0, ID_MRU_DOMAIN15, OnSelMruDomain)

END_MESSAGE_MAP()


CLlsmgrView::CLlsmgrView()

/*++

Routine Description:

    Constructor for view window.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_pTabEntry = g_tcTabInfo.tcTabEntry;
    m_bOrder = FALSE;
    LoadSettings();
}


CLlsmgrView::~CLlsmgrView()

/*++

Routine Description:

    Destructor for view window.

Arguments:

    None.

Return Values:

    None.

--*/

{
    SaveSettings();
}


void CLlsmgrView::AddToMRU(LPCTSTR lpszDomainName)

/*++

Routine Description:

    Adds domain to mru list.

Arguments:

    lpszDomainName - domain of focus.

Return Values:

    None.

--*/

{
    if (lpszDomainName && *lpszDomainName)
    {
        POSITION curPos;
        POSITION nextPos;

        nextPos = m_mruDomainList.GetHeadPosition();

        while (curPos = nextPos)
        {
            CString strDomain = m_mruDomainList.GetNext(nextPos);

            if (!strDomain.CompareNoCase(lpszDomainName))
                m_mruDomainList.RemoveAt(curPos);
        }

        m_mruDomainList.AddHead(lpszDomainName);

        if (m_mruDomainList.GetCount() > MAX_MRU_ENTRIES)
            m_mruDomainList.RemoveTail();
    }
}


#ifdef _DEBUG

void CLlsmgrView::AssertValid() const

/*++

Routine Description:

    Validates object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CView::AssertValid();
}

#endif //_DEBUG


#ifdef _DEBUG

void CLlsmgrView::Dump(CDumpContext& dc) const

/*++

Routine Description:

    Dumps contents of object.

Arguments:

    dc - dump context.

Return Values:

    None.

--*/

{
    CView::Dump(dc);
}

#endif //_DEBUG


void CLlsmgrView::EnableCurSelTab(BOOL bEnable)

/*++

Routine Description:

    Enables or disables currently selected control.

Arguments:

    bEnable - enable control if true.

Return Values:

    None.

--*/

{
    if (bEnable)
    {
        m_pTabEntry = g_tcTabInfo.tcTabEntry + m_tabCtrl.GetCurSel();

        m_pTabEntry->pWnd->EnableWindow(TRUE);
        m_pTabEntry->pWnd->ShowWindow(SW_SHOW);
        m_pTabEntry->pWnd->UpdateWindow();

        if (!IsTabUpdated(m_pTabEntry))
        {
            DWORD fUpdateHint = UPDATE_INFO_NONE;

            switch (m_pTabEntry->iItem)
            {
            case TCID_PURCHASE_HISTORY:
                fUpdateHint = UPDATE_INFO_LICENSES;
                break;

            case TCID_PRODUCTS_VIEW:
                fUpdateHint = UPDATE_INFO_PRODUCTS;
                break;

            case TCID_PER_SEAT_CLIENTS:
                fUpdateHint = UPDATE_INFO_USERS;
                break;

            case TCID_SERVER_BROWSER:
                fUpdateHint = UPDATE_INFO_SERVERS;
                break;
            }

            OnUpdate(this, fUpdateHint, NULL);
        }
    }
    else
    {
        m_pTabEntry->pWnd->EnableWindow(FALSE);
        m_pTabEntry->pWnd->ShowWindow(SW_HIDE);
    }
}


#ifdef _DEBUG

CLlsmgrDoc* CLlsmgrView::GetDocument()

/*++

Routine Description:

    Returns document object associated with view.

Arguments:

    None.

Return Values:

    Returns object pointer or NULL.

--*/

{
    VALIDATE_OBJECT(m_pDocument, CLlsmgrDoc);
    return (CLlsmgrDoc*)m_pDocument;
}

#endif //_DEBUG


void CLlsmgrView::InitLicenseList()

/*++

Routine Description:

    Initializes license list control.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CRect emptyRect;
    emptyRect.SetRectEmpty();

    m_licenseList.Create(
                    WS_CHILD|
                    WS_BORDER|
                    WS_VISIBLE|
                    WS_CLIPSIBLINGS|
                    LVS_REPORT|
                    LVS_SINGLESEL|
                    LVS_SHOWSELALWAYS|
                    LVS_SHAREIMAGELISTS|
                    LVS_AUTOARRANGE,
                    emptyRect,
                    &m_tabCtrl,
                    IDC_VIEW_LICENSE_LIST
                    );

    ::LvInitColumns(&m_licenseList, &g_licenseColumnInfo);
    g_tcTabInfo.tcTabEntry[TCID_PURCHASE_HISTORY].pWnd = &m_licenseList;
}


void CLlsmgrView::InitProductList()

/*++

Routine Description:

    Initializes product list control.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CRect emptyRect;
    emptyRect.SetRectEmpty();

    m_productList.Create(
                    WS_CHILD|
                    WS_BORDER|
                    WS_DISABLED|
                    WS_CLIPSIBLINGS|
                    LVS_REPORT|
                    LVS_SINGLESEL|
                    LVS_SHOWSELALWAYS|
                    LVS_SHAREIMAGELISTS|
                    LVS_AUTOARRANGE,
                    emptyRect,
                    &m_tabCtrl,
                    IDC_VIEW_PRODUCT_LIST
                    );

    ::LvInitColumns(&m_productList, &g_productColumnInfo);
    g_tcTabInfo.tcTabEntry[TCID_PRODUCTS_VIEW].pWnd = &m_productList;
}


void CLlsmgrView::InitServerTree()

/*++

Routine Description:

    Initializes tree ctrl.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CRect emptyRect;
    emptyRect.SetRectEmpty();

    m_serverTree.Create(
                    WS_CHILD|
                    WS_BORDER|
                    WS_DISABLED|
                    WS_CLIPSIBLINGS|
                    TVS_LINESATROOT|
                    TVS_HASBUTTONS|
                    TVS_HASLINES|
                    TVS_DISABLEDRAGDROP|
                    TVS_SHOWSELALWAYS,
                    emptyRect,
                    &m_tabCtrl,
                    IDC_VIEW_SERVER_TREE
                    );

    m_serverTree.SetImageList(&theApp.m_smallImages, TVSIL_NORMAL);
    ::SetDefaultFont(&m_serverTree);

    g_tcTabInfo.tcTabEntry[TCID_SERVER_BROWSER].pWnd = &m_serverTree;
}


void CLlsmgrView::InitTabCtrl()

/*++

Routine Description:

    Initializes tab control.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CRect emptyRect;
    emptyRect.SetRectEmpty();

    m_tabCtrl.Create(
                WS_CHILD|
                WS_VISIBLE|
                WS_CLIPCHILDREN|
                TCS_SINGLELINE|
                TCS_FOCUSONBUTTONDOWN|
                TCS_TABS,
                emptyRect,
                this,
                IDC_VIEW_TAB_CTRL
                );

    ::TcInitTabs(&m_tabCtrl, &g_tcTabInfo);
}


void CLlsmgrView::InitUserList()

/*++

Routine Description:

    Initializes user list control.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CRect emptyRect;
    emptyRect.SetRectEmpty();

    m_userList.Create(
                WS_CHILD|
                WS_BORDER|
                WS_DISABLED|
                LVS_REPORT|
                LVS_SINGLESEL|
                LVS_SHOWSELALWAYS|
                LVS_SHAREIMAGELISTS|
                LVS_AUTOARRANGE,
                emptyRect,
                &m_tabCtrl,
                IDC_VIEW_USER_LIST
                );

    ::LvInitColumns(&m_userList, &g_userColumnInfo);
    g_tcTabInfo.tcTabEntry[TCID_PER_SEAT_CLIENTS].pWnd = &m_userList;
}


void CLlsmgrView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)

/*++

Routine Description:

    Called by framework when view is activated.

Arguments:

    bActivate - activated or deactivated.
    pActivateView - view being activated.
    pDeactiveView - view being deactivated.

Return Values:

    None.

--*/

{
    if (bActivate && (pActivateView == this))
    {
        if (IsTabInFocus(m_pTabEntry))
        {
            m_tabCtrl.SetFocus();
        }
        else
        {
            m_pTabEntry->pWnd->SetFocus();
        }
    }
}


void CLlsmgrView::OnColumnClickLicenseList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    //g_licenseColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_licenseColumnInfo.bSortOrder = !g_licenseColumnInfo.bSortOrder;

    g_licenseColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_licenseList.SortItems(CompareLicenses, 0);    // use column info    

    *pResult = 0;
}


void CLlsmgrView::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetLicenseList();
    ResetProductList();
    ResetUserList();
    ResetServerTree();

    m_userList.DestroyWindow();
    m_serverTree.DestroyWindow();
    m_productList.DestroyWindow();
    m_licenseList.DestroyWindow();
    m_tabCtrl.DestroyWindow();

    CView::OnDestroy();
}


void CLlsmgrView::LoadSettings()

/*++

Routine Description:

    Load settings from registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long Status;
    HKEY hKeyLlsmgr;

    m_bSaveSettings = TRUE;
    m_mruDomainList.RemoveAll();

    memset(&m_lFont, 0, sizeof(LOGFONT));

    m_lFont.lfHeight = FONT_HEIGHT_DEFAULT;
    m_lFont.lfWeight = FONT_WEIGHT_DEFAULT;
    CHARSETINFO csi;
    DWORD dw = ::GetACP();

    if (!::TranslateCharsetInfo((DWORD*)UIntToPtr(dw), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;
    m_lFont.lfCharSet = (BYTE)csi.ciCharset; // default charset

    ::lstrcpy(m_lFont.lfFaceName, TEXT("MS Shell Dlg")); // default facename

    Status = RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyLlsmgr, 0, KEY_READ, &hKeyLlsmgr);

    if (Status == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        DWORD dwValue;
        TCHAR szValue[512];

        //
        // Load save settings on exit
        //

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrSaveSettings, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
            m_bSaveSettings = (BOOL)dwValue;

        //
        // Load font information
        //

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontHeight, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
            m_lFont.lfHeight = ((LONG)dwValue > 0) ? -((LONG)dwValue) : 0;

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontWeight, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
            m_lFont.lfWeight = ((LONG)dwValue > 0) ? ((LONG)dwValue) : 0;

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontItalic, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
            m_lFont.lfItalic = (BOOL)dwValue;

        dwType = REG_SZ;
        dwSize = sizeof(szValue);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontFaceName, 0, &dwType, (LPBYTE)szValue, &dwSize))
            lstrcpyn(m_lFont.lfFaceName, szValue, 32);

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        if (!::RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontCharset, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
            m_lFont.lfCharSet = (BYTE)dwValue;

        //
        // MRU domain list
        //

        dwType = REG_MULTI_SZ;
        dwSize = sizeof(szValue);

        if (!RegQueryValueEx(hKeyLlsmgr, szRegKeyLlsmgrMruList, 0, &dwType, (LPBYTE)szValue, &dwSize))
        {
            LPTSTR psz = szValue;

            while (*psz)
            {
                AddToMRU(psz);
                psz += lstrlen(psz) + 1;
            }
        }

        RegCloseKey(hKeyLlsmgr);
    }
}


void CLlsmgrView::OnColumnClickProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    // g_productColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_productColumnInfo.bSortOrder  = !g_productColumnInfo.bSortOrder;
    g_productColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;
    m_productList.SortItems(CompareProducts, 0);    // use column info
    *pResult = 0;
}


void CLlsmgrView::OnColumnClickUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    // g_userColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_userColumnInfo.bSortOrder = !g_userColumnInfo.bSortOrder;
    g_userColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;
    m_userList.SortItems(CompareUsers, 0);          // use column info
    *pResult = 0;
}


LRESULT CLlsmgrView::OnContextMenu(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_CONTEXTMENU.

Arguments:

    wParam - control window handle.
    lParam - screen coordinates of mouse.

Return Values:

    Returns 0 if successful.

--*/

{
    if (IsEditSupported(m_pTabEntry))
    {
        POINT  pt;
        POINTS pts = MAKEPOINTS(lParam);

        pt.x = (long)(short)pts.x;
        pt.y = (long)(short)pts.y;

        CRect wndRect;
        m_pTabEntry->pWnd->GetWindowRect(wndRect);

        if (wndRect.PtInRect(pt) && IsItemSelected(m_pTabEntry))
        {
            CMenu optionMenu;
            optionMenu.LoadMenu(IDM_POPUP);

            CMenu* pPopupMenu = optionMenu.GetSubMenu(m_pTabEntry->iItem);

            if (pPopupMenu)
            {
                pPopupMenu->TrackPopupMenu(
                                TPM_LEFTALIGN|
                                TPM_RIGHTBUTTON,
                                pt.x,
                                pt.y,
                                GetParentFrame(),
                                NULL
                                );
            }
        }
    }

    return 0;
}


BOOL CLlsmgrView::PreCreateWindow(CREATESTRUCT& cs)

/*++

Routine Description:

    Called by framework before window created.

Arguments:

    cs - window creation information.

Return Values:

    Returns 0 if successful.

--*/

{
    cs.style |= WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
    return CView::PreCreateWindow(cs);
}


int CLlsmgrView::OnCreate(LPCREATESTRUCT lpCreateStruct)

/*++

Routine Description:

    Message handler for WM_CREATE.

Arguments:

    lpCreateStruct - window creation information.

Return Values:

    Returns 0 if successful.

--*/

{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    InitTabCtrl();
    InitLicenseList();
    InitProductList();
    InitUserList();
    InitServerTree();

    CFont* pFont;

    if (pFont = CFont::FromHandle(::CreateFontIndirect(&m_lFont)))
    {
        m_tabCtrl.SetFont(pFont);
        m_licenseList.SetFont(pFont);
        m_productList.SetFont(pFont);
        m_userList.SetFont(pFont);
        m_serverTree.SetFont(pFont);
    }

    return 0;
}


void CLlsmgrView::OnDblClkProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewProductProperties();
    *pResult = 0;
}


void CLlsmgrView::OnDblClkServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    CService* pService;

    if (pService = (CService*)::TvGetSelObj(&m_serverTree))
    {
        ASSERT_VALID(pService);

        if (pService->IsKindOf(RUNTIME_CLASS(CService)))
        {
            ViewServerProperties(); // only support dblclk services
        }
    }

    *pResult = 0;
}


void CLlsmgrView::OnDblClkUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewUserProperties();
    *pResult = 0;
}


void CLlsmgrView::OnDelete()

/*++

Routine Description:

    Message handler for ID_VIEW_DELETE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pTabEntry->iItem == TCID_PER_SEAT_CLIENTS)
    {
        CUser* pUser;
        CString strConfirm;

        if (pUser = (CUser*)::LvGetSelObj(&m_userList))
        {
            AfxFormatString1(strConfirm, IDP_CONFIRM_DELETE_USER, pUser->m_strName);

            if (AfxMessageBox(strConfirm, MB_YESNO) == IDYES)
            {
                NTSTATUS NtStatus;

                NtStatus = ::LlsUserDelete(
                                LlsGetActiveHandle(),
                                MKSTR(pUser->m_strName)
                                );

                if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
                    NtStatus = STATUS_SUCCESS;

                if (NT_SUCCESS(NtStatus))
                {
                    OnUpdate(this, UPDATE_LICENSE_DELETED, NULL);
                }
                else
                {
                    theApp.DisplayStatus(NtStatus);
                }
            }
        }
    }
    else if (m_pTabEntry->iItem == TCID_PRODUCTS_VIEW)
    {
        CProduct* pProduct;

        if (pProduct = (CProduct*)::LvGetSelObj(&m_productList))
        {
            CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
            VALIDATE_OBJECT(pController, CController);

            LPTSTR pszUniServerName  = pController->GetName();

            if ( NULL == pszUniServerName )
            {
                theApp.DisplayStatus( STATUS_NO_MEMORY );
            }
            else
            {
                LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );

                if ( NULL == pszAscServerName )
                {
                    theApp.DisplayStatus( STATUS_NO_MEMORY );
                }
                else
                {
                    wsprintfA( pszAscServerName, "%ls", pszUniServerName );

                    LPSTR  pszAscProductName = NULL;
                    LPTSTR pszUniProductName = pProduct->GetName();

                    if ( NULL != pszUniProductName )
                    {
                        pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );

                        if ( NULL != pszAscProductName )
                        {
                            wsprintfA( pszAscProductName, "%ls", pszUniProductName );
                        }

                        SysFreeString( pszUniProductName );
                    }

                    CCFCertificateRemoveUI( m_hWnd, pszAscServerName, pszAscProductName, pszAscProductName ? "Microsoft" : NULL, NULL, NULL );

                    OnUpdate(this, UPDATE_LICENSE_DELETED, NULL);

                    LocalFree( pszAscServerName );
                    if ( NULL != pszAscProductName )
                    {
                        LocalFree( pszAscProductName );
                    }
                }

                SysFreeString( pszUniServerName );
            }
        }
    }
}


void CLlsmgrView::OnDraw(CDC* pDC)

/*++

Routine Description:

    Message handler for WM_DRAW.

Arguments:

    pDC - device context.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


BOOL CLlsmgrView::OnEraseBkgnd(CDC* pDC)

/*++

Routine Description:

    Message handler for WM_ERASEBKGND.

Arguments:

    pDC - device context.

Return Values:

    None.

--*/

{
    CBrush grayBrush(RGB(192,192,192));
    CBrush* pOldBrush = pDC->SelectObject(&grayBrush);

    CRect clientRect;
    GetClientRect(clientRect);

    pDC->FillRect(clientRect, &grayBrush);

    pDC->SelectObject(pOldBrush);

    return TRUE;
}


void CLlsmgrView::OnFormatIcons()

/*++

Routine Description:

    Message handler for ID_VIEW_ICONS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (IsFormatSupported(m_pTabEntry) && !IsFormatLargeIcons(m_pTabEntry))
    {
        VALIDATE_OBJECT(m_pTabEntry->pWnd, CWnd);

        ::LvChangeFormat((CListCtrl*)m_pTabEntry->pWnd, LVS_ICON);
        SetFormatLargeIcons(m_pTabEntry);
    }
}


void CLlsmgrView::OnFormatList()

/*++

Routine Description:

    Message handler for MY_ID_VIEW_LIST.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (IsFormatSupported(m_pTabEntry) && !IsFormatList(m_pTabEntry))
    {
        VALIDATE_OBJECT(m_pTabEntry->pWnd, CWnd);

        ::LvChangeFormat((CListCtrl*)m_pTabEntry->pWnd, LVS_LIST);
        SetFormatList(m_pTabEntry);
    }
}

void CLlsmgrView::OnFormatReport()

/*++

Routine Description:

    Message handler for ID_VIEW_REPORT.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (IsFormatSupported(m_pTabEntry) && !IsFormatReport(m_pTabEntry))
    {
        VALIDATE_OBJECT(m_pTabEntry->pWnd, CWnd);

        ::LvChangeFormat((CListCtrl*)m_pTabEntry->pWnd, LVS_REPORT);
        SetFormatReport(m_pTabEntry);
    }
}

void CLlsmgrView::OnFormatSmallIcons()

/*++

Routine Description:

    Message handler for ID_VIEW_SMALL_ICON

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (IsFormatSupported(m_pTabEntry) && !IsFormatSmallIcons(m_pTabEntry))
    {
        VALIDATE_OBJECT(m_pTabEntry->pWnd, CWnd);

        ::LvChangeFormat((CListCtrl*)m_pTabEntry->pWnd, LVS_SMALLICON);
        SetFormatSmallIcons(m_pTabEntry);
    }
}


void CLlsmgrView::OnGetDispInfoLicenseList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CLicense* pLicense = (CLicense*)plvItem->lParam;
    VALIDATE_OBJECT(pLicense, CLicense);

    switch (plvItem->iSubItem)
    {
    case LVID_SEPARATOR:
    {
        plvItem->iImage = 0;
        CString strLabel = _T("");
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PURCHASE_HISTORY_DATE:
    {
        BSTR bstrDate = pLicense->GetDateString();
        if(bstrDate != NULL )
        {
            lstrcpyn(plvItem->pszText, bstrDate, plvItem->cchTextMax);
            SysFreeString(bstrDate);
        }
    }
        break;

    case LVID_PURCHASE_HISTORY_PRODUCT:
        lstrcpyn(plvItem->pszText, pLicense->m_strProduct, plvItem->cchTextMax);
        break;

    case LVID_PURCHASE_HISTORY_QUANTITY:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pLicense->m_lQuantity);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PURCHASE_HISTORY_ADMINISTRATOR:
        lstrcpyn(plvItem->pszText, pLicense->m_strUser, plvItem->cchTextMax);
        break;

    case LVID_PURCHASE_HISTORY_COMMENT:
        lstrcpyn(plvItem->pszText, pLicense->m_strDescription, plvItem->cchTextMax);
        break;
    }

    *pResult = 0;
}


void CLlsmgrView::OnGetDispInfoProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CProduct* pProduct = (CProduct*)plvItem->lParam;
    VALIDATE_OBJECT(pProduct, CProduct);

    switch (plvItem->iSubItem)
    {
    case LVID_PRODUCTS_VIEW_NAME:
        plvItem->iImage = CalcProductBitmap(pProduct);
        lstrcpyn(plvItem->pszText, pProduct->m_strName, plvItem->cchTextMax);
        break;

    case LVID_PRODUCTS_VIEW_PER_SEAT_CONSUMED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pProduct->m_lInUse);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PRODUCTS_VIEW_PER_SEAT_PURCHASED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pProduct->m_lLimit);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PRODUCTS_VIEW_PER_SERVER_PURCHASED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pProduct->m_lConcurrent);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PRODUCTS_VIEW_PER_SERVER_REACHED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pProduct->m_lHighMark);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;
    }

    *pResult = 0;
}


void CLlsmgrView::OnGetDispInfoServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    TV_ITEM* ptvItem = &((TV_DISPINFO*)pNMHDR)->item;

    CCmdTarget *pObject = (CCmdTarget*)ptvItem->lParam;
    VALIDATE_OBJECT(pObject, CCmdTarget);

    if (pObject->IsKindOf(RUNTIME_CLASS(CDomain)))
    {
        lstrcpyn(ptvItem->pszText, ((CDomain*)pObject)->m_strName, ptvItem->cchTextMax);

        ptvItem->iImage         = BMPI_DOMAIN;
        ptvItem->iSelectedImage = ptvItem->iImage;
    }
    else if (pObject->IsKindOf(RUNTIME_CLASS(CServer)))
    {
        lstrcpyn(ptvItem->pszText, ((CServer*)pObject)->m_strName, ptvItem->cchTextMax);

        ptvItem->iImage         = BMPI_SERVER;
        ptvItem->iSelectedImage = ptvItem->iImage;
    }
    else if (pObject->IsKindOf(RUNTIME_CLASS(CService)))
    {
        BSTR bstrServiceName = ((CService*)pObject)->GetDisplayName();
        lstrcpyn(ptvItem->pszText, bstrServiceName, ptvItem->cchTextMax);
        SysFreeString(bstrServiceName);

        ptvItem->iImage         = CalcServiceBitmap((CService*)pObject);
        ptvItem->iSelectedImage = ptvItem->iImage;
    }

    *pResult = 0;
}


void CLlsmgrView::OnGetDispInfoUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CUser* pUser = (CUser*)plvItem->lParam;
    VALIDATE_OBJECT(pUser, CUser);

    switch (plvItem->iSubItem)
    {
    case LVID_PER_SEAT_CLIENTS_NAME:
        plvItem->iImage = CalcUserBitmap(pUser);
        lstrcpyn(plvItem->pszText, pUser->m_strName, plvItem->cchTextMax);
        break;

    case LVID_PER_SEAT_CLIENTS_LICENSED_USAGE:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pUser->m_lInUse);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PER_SEAT_CLIENTS_UNLICENSED_USAGE:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pUser->m_lUnlicensed);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_PER_SEAT_CLIENTS_SERVER_PRODUCTS:
        lstrcpyn(plvItem->pszText, pUser->m_strProducts, plvItem->cchTextMax);
        break;
    }

    *pResult = 0;
}


void CLlsmgrView::OnItemExpandingServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TVN_ITEMEXPANDING.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    TV_ITEM tvItem = pNMTreeView->itemNew;

    if (!(tvItem.state & TVIS_EXPANDEDONCE))
    {
        BeginWaitCursor();

        CCmdTarget* pParent = (CCmdTarget*)tvItem.lParam;
        VALIDATE_OBJECT(pParent, CCmdTarget);

        VARIANT va;
        VariantInit(&va);

        BOOL bIsInserted = FALSE;
        BOOL bDisplayError = TRUE;

        if (pParent->IsKindOf(RUNTIME_CLASS(CApplication)))
        {
            CDomains* pDomains = (CDomains*)MKOBJ(((CApplication*)pParent)->GetDomains(va));

            if (pDomains)
            {
                if (::TvInsertObArray(&m_serverTree, tvItem.hItem, pDomains->m_pObArray))
                {
                    bIsInserted = TRUE;
                }

                pDomains->InternalRelease();    // objects AddRef'd individually
            }
        }
        else if (pParent->IsKindOf(RUNTIME_CLASS(CDomain)))
        {
            CServers* pServers = (CServers*)MKOBJ(((CDomain*)pParent)->GetServers(va));

            if (pServers)
            {
                if (::TvInsertObArray(&m_serverTree, tvItem.hItem, pServers->m_pObArray))
                {
                    bIsInserted = TRUE;
                }

                pServers->InternalRelease();    // objects AddRef'd individually
            }
        }
        else if (pParent->IsKindOf(RUNTIME_CLASS(CServer)))
        {
            CServices* pServices = (CServices*)MKOBJ(((CServer*)pParent)->GetServices(va));

            if (pServices)
            {
                if (::TvInsertObArray(&m_serverTree, tvItem.hItem, pServices->m_pObArray, FALSE))
                {
                    bIsInserted = TRUE;
                }

                pServices->InternalRelease();   // objects AddRef'd individually
            }
            else if (    ( ERROR_FILE_NOT_FOUND == LlsGetLastStatus() )
                      || ( STATUS_NOT_FOUND     == LlsGetLastStatus() ) )
            {
                // license service not configured on the target server
                AfxMessageBox( IDP_ERROR_SERVER_NOT_CONFIGURED, MB_OK | MB_ICONEXCLAMATION, 0 );
                bDisplayError = FALSE;
            }
        }

        EndWaitCursor();

        if (!bIsInserted && bDisplayError)
        {
            theApp.DisplayLastStatus();
        }
    }

    *pResult = 0;
}


void CLlsmgrView::OnInitialUpdate()

/*++

Routine Description:

    Called by framework after the view is first attached
    to the document but before it is initially displayed.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (LlsGetApp()->IsConnected())
    {
        OnUpdate(this, UPDATE_MAIN_TABS, NULL);
    }
}


void CLlsmgrView::OnKeyDownLicenseList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_KEYDOWN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    if (((LV_KEYDOWN*)pNMHDR)->wVKey == VK_TAB)
    {
        m_tabCtrl.SetFocus();
    }

    *pResult = 0;
}


void CLlsmgrView::OnKeyDownProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_KEYDOWN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    if (((LV_KEYDOWN*)pNMHDR)->wVKey == VK_TAB)
    {
        m_tabCtrl.SetFocus();
    }

    *pResult = 0;
}


void CLlsmgrView::OnKeyDownServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TVN_KEYDOWN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    if (((TV_KEYDOWN*)pNMHDR)->wVKey == VK_TAB)
    {
        m_tabCtrl.SetFocus();
    }

    *pResult = TRUE;
}


void CLlsmgrView::OnKeyDownTabCtrl(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TCN_KEYDOWN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    TC_KEYDOWN* tcKeyDown = (TC_KEYDOWN*)pNMHDR;

    if (tcKeyDown->wVKey == VK_TAB)
    {
        m_pTabEntry->pWnd->SetFocus();
    }
    else if ((tcKeyDown->wVKey == VK_LEFT) &&
             (m_pTabEntry->iItem == TCID_PURCHASE_HISTORY))
    {
        PostMessage(WM_COMMAND, ID_VIEW_SERVERS);
    }
    else if ((tcKeyDown->wVKey == VK_RIGHT) &&
             (m_pTabEntry->iItem == TCID_SERVER_BROWSER))
    {
        PostMessage(WM_COMMAND, ID_VIEW_LICENSES);
    }

    *pResult = 0;
}


void CLlsmgrView::OnKeyDownUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_KEYDOWN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    if (((LV_KEYDOWN*)pNMHDR)->wVKey == VK_TAB)
    {
        m_tabCtrl.SetFocus();
    }

    *pResult = 0;
}



void CLlsmgrView::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)

/*++

Routine Description:

    Message handler for WM_INITMENU.

Arguments:

    pPopupMenu - menu object.
    nIndex - menu position.
    bSysMenu - true if system menu.

Return Values:

    None.

--*/

{
#define SUBMENU_LICENSE             0
#define SUBMENU_LICENSE_DELETE      2
#define SUBMENU_LICENSE_PROPERTIES  3
#define SUBMENU_LICENSE_INSERT_MRU  7

#define SUBMENU_LICENSE_ITEM_ID0    ID_NEW_LICENSE

#define SUBMENU_OPTIONS             2
#define SUBMENU_OPTIONS_FORMAT      2
#define SUBMENU_OPTIONS_SORTBY      3

#define SUBMENU_OPTIONS_ITEM_ID0    ID_SELECT_FONT

#define SUBMENU_FORMAT_LARGE_ICON   0
#define SUBMENU_FORMAT_SMALL_ICON   1
#define SUBMENU_FORMAT_LIST         2
#define SUBMENU_FORMAT_DETAILS      3

    if (bSysMenu)
        return; // bail...

    if ((nIndex != SUBMENU_LICENSE) && (nIndex != SUBMENU_OPTIONS))
        return; // bail...

    int nMenuItemId = pPopupMenu->GetMenuItemID(0); // check first item

    if (nMenuItemId == SUBMENU_LICENSE_ITEM_ID0)
    {
        UINT CmdId;
        UINT MenuId;

        CmdId = ID_MRU_DOMAIN0;
        while (pPopupMenu->RemoveMenu(CmdId++, MF_BYCOMMAND))
            ;

        POSITION position;
        position = m_mruDomainList.GetHeadPosition();

        CmdId  = ID_MRU_DOMAIN0;
        MenuId = SUBMENU_LICENSE_INSERT_MRU;

        while (position)
        {
            TCHAR num[10];
            wsprintf(num, _T("&%d "), CmdId - ID_MRU_DOMAIN0 + 1);

            CString strDomain = m_mruDomainList.GetNext(position);
            pPopupMenu->InsertMenu(MenuId++, MF_BYPOSITION, CmdId++, CString(num) + strDomain);
        }
    }
    else if (nMenuItemId == SUBMENU_OPTIONS_ITEM_ID0)
    {
        UINT fEnableFormat = IsFormatSupported(m_pTabEntry) ? MF_ENABLED : MF_GRAYED;
        UINT fEnableSortBy = IsSortSupported(m_pTabEntry)   ? MF_ENABLED : MF_GRAYED;

        pPopupMenu->EnableMenuItem(SUBMENU_OPTIONS_FORMAT, MF_BYPOSITION|fEnableFormat);
        pPopupMenu->EnableMenuItem(SUBMENU_OPTIONS_SORTBY, MF_BYPOSITION|fEnableSortBy);

        if (fEnableSortBy == MF_ENABLED)
        {
            ASSERT(m_pTabEntry->plvColumnInfo);
            PLV_COLUMN_ENTRY plvColumnEntry = m_pTabEntry->plvColumnInfo->lvColumnEntry;

            CMenu* pSortByMenu = pPopupMenu->GetSubMenu(SUBMENU_OPTIONS_SORTBY);

            while (pSortByMenu->RemoveMenu(0, MF_BYPOSITION))
                ;

            int index;
            int nStringId;
            CString strMenu;

            for (index = 0; index < m_pTabEntry->plvColumnInfo->nColumns; index++)
            {
                if (nStringId = plvColumnEntry->nMenuStringId)
                {
                    strMenu.LoadString(nStringId);
                    pSortByMenu->AppendMenu(MF_STRING, ID_SORT_COLUMN0+index, strMenu);
                }

                plvColumnEntry++;
            }

            pSortByMenu->CheckMenuItem(ID_SORT_COLUMN0+m_pTabEntry->plvColumnInfo->nSortedItem, MF_BYCOMMAND|MF_CHECKED);
        }

        if (fEnableFormat == MF_ENABLED)
        {
            CMenu* pFormatMenu = pPopupMenu->GetSubMenu(SUBMENU_OPTIONS_FORMAT);

            pFormatMenu->CheckMenuItem(SUBMENU_FORMAT_LARGE_ICON, MF_BYPOSITION|(IsFormatLargeIcons(m_pTabEntry) ? MF_CHECKED : MF_UNCHECKED));
            pFormatMenu->CheckMenuItem(SUBMENU_FORMAT_SMALL_ICON, MF_BYPOSITION|(IsFormatSmallIcons(m_pTabEntry) ? MF_CHECKED : MF_UNCHECKED));
            pFormatMenu->CheckMenuItem(SUBMENU_FORMAT_LIST      , MF_BYPOSITION|(IsFormatList(m_pTabEntry)       ? MF_CHECKED : MF_UNCHECKED));
            pFormatMenu->CheckMenuItem(SUBMENU_FORMAT_DETAILS   , MF_BYPOSITION|(IsFormatReport(m_pTabEntry)     ? MF_CHECKED : MF_UNCHECKED));
        }
    }
}


void CLlsmgrView::OnNewLicense()

/*++

Routine Description:

    Message handler for ID_NEW_LICENSE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
    VALIDATE_OBJECT(pController, CController);

    LPTSTR pszUniServerName  = pController->GetName();

    if ( NULL == pszUniServerName )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );

        if ( NULL == pszAscServerName )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
        }
        else
        {
            wsprintfA( pszAscServerName, "%ls", pszUniServerName );

            LPSTR pszAscProductName = NULL;

            if ( m_pTabEntry->iItem == TCID_PRODUCTS_VIEW )
            {
                CProduct* pProduct = (CProduct*) ::LvGetSelObj(&m_productList);

                if ( NULL != pProduct )
                {
                    LPTSTR pszUniProductName = pProduct->GetName();

                    if ( NULL != pszUniProductName )
                    {
                        pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );

                        if ( NULL != pszAscProductName )
                        {
                            wsprintfA( pszAscProductName, "%ls", pszUniProductName );
                        }

                        SysFreeString( pszUniProductName );
                    }
                }
            }

            DWORD dwError = CCFCertificateEnterUI( m_hWnd, pszAscServerName, pszAscProductName, pszAscProductName ? "Microsoft" : NULL, CCF_ENTER_FLAG_PER_SEAT_ONLY | CCF_ENTER_FLAG_SERVER_IS_ES, NULL );
            DWORD fUpdateHint;

            if ( ERROR_SUCCESS == dwError )
            {
                fUpdateHint = UPDATE_LICENSE_ADDED;
            }
            else
            {
                fUpdateHint = UPDATE_INFO_NONE;
            }

            OnUpdate(this, fUpdateHint, NULL);

            LocalFree( pszAscServerName );
            if ( NULL != pszAscProductName )
            {
                LocalFree( pszAscProductName );
            }
        }

        SysFreeString( pszUniServerName );
    }
}


void CLlsmgrView::OnNewMapping()

/*++

Routine Description:

    Message handler for ID_NEW_MAPPING.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CNewMappingDialog newmDlg;
    newmDlg.DoModal();

    OnUpdate(this, newmDlg.m_fUpdateHint, NULL);
}


void CLlsmgrView::OnReturnProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewProductProperties();
    *pResult = 0;
}


void CLlsmgrView::OnReturnServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewServerProperties();
    *pResult = 0;
}


void CLlsmgrView::OnReturnUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewUserProperties();
    *pResult = 0;
}


void CLlsmgrView::OnSaveSettings()

/*++

Routine Description:

    Message handler for ID_SAVE_SETTINGS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_bSaveSettings = !m_bSaveSettings;
}


void CLlsmgrView::OnSelChangeTabCtrl(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TCN_SELCHANGE.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    EnableCurSelTab(TRUE);
    *pResult = 0;
}


void CLlsmgrView::OnSelChangingTabCtrl(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TCN_SELCHANGING.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    EnableCurSelTab(FALSE);
    *pResult = 0;
}


void CLlsmgrView::OnSelectDomain()

/*++

Routine Description:

    Message handler for ID_SELECT_DOMAIN.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CSelectDomainDialog domainDlg;
    domainDlg.DoModal();

    OnUpdate(this, domainDlg.m_fUpdateHint, NULL);
}


void CLlsmgrView::OnSelectFont()

/*++

Routine Description:

    Message handler for ID_SELECT_FONT.

Arguments:

    None.

Return Values:

    None.

--*/

{
    LOGFONT lFont = m_lFont;

    CFontDialog fontDlg(&lFont, CF_SCREENFONTS|CF_LIMITSIZE, NULL, NULL);

    fontDlg.m_cf.nSizeMin  = 8;
    fontDlg.m_cf.nSizeMax  = 20;

    if (fontDlg.DoModal() == IDOK)
    {
        CFont* pNewFont;

        if (!*(m_lFont.lfFaceName))
            lFont.lfCharSet = m_lFont.lfCharSet;
        if (pNewFont = CFont::FromHandle(::CreateFontIndirect(&lFont)))
        {
            m_lFont = lFont;

            BeginWaitCursor();

            m_tabCtrl.SetFont(pNewFont);
            m_licenseList.SetFont(pNewFont);
            m_productList.SetFont(pNewFont);
            m_userList.SetFont(pNewFont);
            m_serverTree.SetFont(pNewFont);

            EndWaitCursor();
        }
    }
}


BOOL CLlsmgrView::OnSelMruDomain(UINT nID)

/*++

Routine Description:

    Message handler for ID_MRU_DOMAIN*.

Arguments:

    nID - id of domain.

Return Values:

    Returns true always.

--*/

{
    POSITION position;

    if (position = m_mruDomainList.FindIndex(nID - ID_MRU_DOMAIN0))
        theApp.OpenDocumentFile(m_mruDomainList.GetAt(position));

    return TRUE;
}


void CLlsmgrView::OnSetFocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ClrTabInFocus(m_pTabEntry);
    *pResult = 0;
}


void CLlsmgrView::OnSetFocusProductList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ClrTabInFocus(m_pTabEntry);
    *pResult = 0;
}


void CLlsmgrView::OnSetFocusTabCtrl(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    SetTabInFocus(m_pTabEntry);
    *pResult = 0;
}


void CLlsmgrView::OnSetFocusServerTree(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ClrTabInFocus(m_pTabEntry);
    *pResult = 0;
}


void CLlsmgrView::OnSetFocusUserList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ClrTabInFocus(m_pTabEntry);
    *pResult = 0;
}


void CLlsmgrView::OnSize(UINT nType, int cx, int cy)

/*++

Routine Description:

    Message handler for WM_SIZE.

Arguments:

    nType - type of resizing.
    cx - new width of client area.
    cy - new height of client area.

Return Values:

    None.

--*/

{
    int x, y;

    CView::OnSize(nType, cx, cy);

#define INDENT_FROM_FRAME    5
#define INDENT_FROM_TAB_CTRL 10

    if (m_tabCtrl.GetSafeHwnd())
    {
        CRect clientRect;
        GetClientRect(clientRect);

        x  = INDENT_FROM_FRAME;
        y  = INDENT_FROM_FRAME;
        cx = clientRect.Width()  - ((2 * x) + 1);
        cy = clientRect.Height() - ((2 * y) + 1);

        m_tabCtrl.MoveWindow(x, y, cx, cy, TRUE);

        RECT tabRect;
        m_tabCtrl.GetClientRect(clientRect);
        m_tabCtrl.GetItemRect(0, &tabRect);

        int tabHeight = tabRect.bottom - tabRect.top;

        x  = INDENT_FROM_TAB_CTRL;
        y  = (2 * tabHeight);
        cx = clientRect.Width()  - ((2 * x) + 1);
        cy = clientRect.Height() - ((2 * tabHeight) + INDENT_FROM_TAB_CTRL + 1);

        m_licenseList.MoveWindow(x, y, cx, cy, TRUE);
        m_productList.MoveWindow(x, y, cx, cy, TRUE);
        m_userList.MoveWindow   (x, y, cx, cy, TRUE);
        m_serverTree.MoveWindow (x, y, cx, cy, TRUE);

        RecalcListColumns();
    }
}


void CLlsmgrView::OnSortColumn(int iColumn)

/*++

Routine Description:

    Sort dispatcher.

Arguments:

    iColumn - sort criteria.

Return Values:

    None.

--*/

{
    //BOOL bOrder = GetKeyState(VK_CONTROL) < 0;

    

    switch (m_pTabEntry->iItem)
    {
    case TCID_PURCHASE_HISTORY:
        g_licenseColumnInfo.bSortOrder  = m_bOrder;
        g_licenseColumnInfo.nSortedItem = iColumn;
        m_licenseList.SortItems(CompareLicenses, 0);    // use column info
        break;
    case TCID_PRODUCTS_VIEW:
        g_productColumnInfo.bSortOrder  = m_bOrder;
        g_productColumnInfo.nSortedItem = iColumn;
        m_productList.SortItems(CompareProducts, 0);    // use column info
        break;
    case TCID_PER_SEAT_CLIENTS:
        g_userColumnInfo.bSortOrder  = m_bOrder;
        g_userColumnInfo.nSortedItem = iColumn;
        m_userList.SortItems(CompareUsers, 0);          // use column info
        break;
    }
    
    m_bOrder = !m_bOrder;
}

void CLlsmgrView::OnSortColumn0()
    { OnSortColumn(0); }

void CLlsmgrView::OnSortColumn1()
    { OnSortColumn(1); }

void CLlsmgrView::OnSortColumn2()
    { OnSortColumn(2); }

void CLlsmgrView::OnSortColumn3()
    { OnSortColumn(3); }

void CLlsmgrView::OnSortColumn4()
    { OnSortColumn(4); }

void CLlsmgrView::OnSortColumn5()
    { OnSortColumn(5); }


void CLlsmgrView::OnUpdate(CView* pSender, LPARAM fUpdateHint, CObject* pIgnore)

/*++

Routine Description:

    Called by framework when view needs to be refreshed.

Arguments:

    pSender - view that modified document (only one).
    fUpdateHint - hints about modifications.
    pIgnore - not used.

Return Values:

    None.

--*/

{
    ASSERT(pSender);

    BeginWaitCursor();

    if (IsLicenseInfoUpdated(fUpdateHint))
    {
        if (RefreshLicenseList())
        {
            SetTabUpdated(&g_tcTabInfo.tcTabEntry[TCID_PURCHASE_HISTORY]);
        }
        else
        {
            fUpdateHint = UPDATE_INFO_ABORT;
            theApp.DisplayLastStatus();
        }
    }

    if (IsProductInfoUpdated(fUpdateHint))
    {
        if (RefreshProductList())
        {
            SetTabUpdated(&g_tcTabInfo.tcTabEntry[TCID_PRODUCTS_VIEW]);
        }
        else
        {
            fUpdateHint = UPDATE_INFO_ABORT;
            theApp.DisplayLastStatus();
        }
    }

    if (IsUserInfoUpdated(fUpdateHint))
    {
        if (RefreshUserList())
        {
            SetTabUpdated(&g_tcTabInfo.tcTabEntry[TCID_PER_SEAT_CLIENTS]);
        }
        else
        {
            fUpdateHint = UPDATE_INFO_ABORT;
            theApp.DisplayLastStatus();
        }
    }

    if (IsUpdateAborted(fUpdateHint))
    {
        ResetLicenseList();
        ResetProductList();
        ResetUserList();

        CSelectDomainDialog sdomDlg;

        if (sdomDlg.DoModal() != IDOK)
        {
            theApp.m_pMainWnd->PostMessage(WM_CLOSE);
        }
    }
    else if (IsServerInfoUpdated(fUpdateHint))
    {
        if (RefreshServerTree())
        {
            SetTabUpdated(&g_tcTabInfo.tcTabEntry[TCID_SERVER_BROWSER]);
        }
        else
        {
            ResetServerTree();
            theApp.DisplayLastStatus();
        }
    }

    EndWaitCursor();
}


void CLlsmgrView::OnUpdateSaveSettings(CCmdUI* pCmdUI)

/*++

Routine Description:

    Notification handler for ID_SAVE_SETTINGS.

Arguments:

    pCmdUI - interface for updating menu.

Return Values:

    None.

--*/

{
    pCmdUI->SetCheck(m_bSaveSettings);
}


void CLlsmgrView::OnUpdateViewDelete(CCmdUI* pCmdUI)

/*++

Routine Description:

    Notification handler for ID_VIEW_DELETE.

Arguments:

    pCmdUI - interface for updating menu.

Return Values:

    None.

--*/

{
    if (!(IsItemSelected(m_pTabEntry) && IsDeleteSupported(m_pTabEntry)))
    {
        pCmdUI->Enable(FALSE);
    }
    else if (m_pTabEntry->iItem == TCID_PRODUCTS_VIEW)
    {
        //
        // Make sure they are licenses to delete...
        //

        CProduct* pProduct = (CProduct*)::LvGetSelObj(&m_productList);
        VALIDATE_OBJECT(pProduct, CProduct);

        if ( pProduct )
        {
            pCmdUI->Enable(pProduct->m_lLimit);
        }
    }
    else
    {
        pCmdUI->Enable(TRUE);
    }
}


void CLlsmgrView::OnUpdateViewProperties(CCmdUI* pCmdUI)

/*++

Routine Description:

    Notification handler for ID_VIEW_PROPERTIES.

Arguments:

    pCmdUI - interface for updating menu.

Return Values:

    None.

--*/

{
    if (!(IsItemSelected(m_pTabEntry) && IsEditSupported(m_pTabEntry)))
    {
        pCmdUI->Enable(FALSE);
    }
    else if (m_pTabEntry->iItem == TCID_SERVER_BROWSER)
    {
        //
        // No properties for enterprise or domain...
        //

        CCmdTarget* pObject = (CCmdTarget*)::TvGetSelObj(&m_serverTree);
        VALIDATE_OBJECT(pObject, CCmdTarget);

        if ( pObject )
        {
            pCmdUI->Enable(pObject->IsKindOf(RUNTIME_CLASS(CServer)) ||
                           pObject->IsKindOf(RUNTIME_CLASS(CService)));
        }
    }
    else
    {
        pCmdUI->Enable(TRUE);
    }
}


void CLlsmgrView::OnViewLicenses()

/*++

Routine Description:

    Message handler for ID_VIEW_LICENSES.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableCurSelTab(FALSE);
    m_tabCtrl.SetCurSel(TCID_PURCHASE_HISTORY);
    EnableCurSelTab(TRUE);
}


void CLlsmgrView::OnViewMappings()

/*++

Routine Description:

    Message handler for ID_VIEW_MAPPINGS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CLicenseGroupsDialog lgrpDlg;
    lgrpDlg.DoModal();

    OnUpdate(this, lgrpDlg.m_fUpdateHint, NULL);
}


void CLlsmgrView::OnViewProducts()

/*++

Routine Description:

    Message handler for ID_VIEW_PRODUCTS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableCurSelTab(FALSE);
    m_tabCtrl.SetCurSel(TCID_PRODUCTS_VIEW);
    EnableCurSelTab(TRUE);
}


void CLlsmgrView::OnViewProperties()

/*++

Routine Description:

    View the properties of selected object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    switch (m_pTabEntry->iItem)
    {
    case TCID_PRODUCTS_VIEW:
        ViewProductProperties();
        return;
    case TCID_PER_SEAT_CLIENTS:
        ViewUserProperties();
        return;
    case TCID_SERVER_BROWSER:
        ViewServerProperties();
        return;
    }
}


void CLlsmgrView::OnViewRefresh()

/*++

Routine Description:

    Message handler for ID_VIEW_REFRESH.

Arguments:

    None.

Return Values:

    None.

--*/

{
    GetDocument()->Update();

    OnUpdate(
        this,
        (m_pTabEntry->iItem == TCID_SERVER_BROWSER)
            ? UPDATE_BROWSER_TAB
            : UPDATE_MAIN_TABS,
        NULL
        );
}


void CLlsmgrView::OnViewServers()

/*++

Routine Description:

    Message handler for ID_VIEW_SERVERS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableCurSelTab(FALSE);
    m_tabCtrl.SetCurSel(TCID_SERVER_BROWSER);
    EnableCurSelTab(TRUE);
    m_serverTree.SetFocus();
}


void CLlsmgrView::OnViewUsers()

/*++

Routine Description:

    Message handler for ID_VIEW_USERS.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableCurSelTab(FALSE);
    m_tabCtrl.SetCurSel(TCID_PER_SEAT_CLIENTS);
    EnableCurSelTab(TRUE);
}


void CLlsmgrView::RecalcListColumns()

/*++

Routine Description:

    Adjusts list columns to client area.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvResizeColumns(&m_licenseList, &g_licenseColumnInfo);
    ::LvResizeColumns(&m_productList, &g_productColumnInfo);
    ::LvResizeColumns(&m_userList,    &g_userColumnInfo);
}


BOOL CLlsmgrView::RefreshLicenseList()

/*++

Routine Description:

    Refreshs license list control.

Arguments:

    None.

Return Values:

    Returns true if licenses successfully updated.

--*/

{
    CLicenses* pLicenses;

    if (pLicenses = GetDocument()->GetLicenses())
    {
        return ::LvRefreshObArray(
                    &m_licenseList,
                    &g_licenseColumnInfo,
                    pLicenses->m_pObArray
                    );
    }

    return FALSE;
}


BOOL CLlsmgrView::RefreshProductList()

/*++

Routine Description:

    Refreshs product list control.

Arguments:

    None.

Return Values:

    Returns true if products successfully updated.

--*/

{
    CProducts* pProducts;

    if (pProducts = GetDocument()->GetProducts())
    {
        return ::LvRefreshObArray(
                    &m_productList,
                    &g_productColumnInfo,
                    pProducts->m_pObArray
                    );
    }

    return FALSE;
}


BOOL CLlsmgrView::RefreshServerTree()

/*++

Routine Description:

    Refreshs server tree control.

Arguments:

    None.

Return Values:

    Returns true if servers successfully updated.

--*/

{
    HTREEITEM hRoot;
    HTREEITEM hDomain;

    TV_ITEM tvItem = {0};
    TV_INSERTSTRUCT tvInsert;

    BOOL bIsRefreshed = FALSE;

    if (hRoot = m_serverTree.GetRootItem())
    {
        VARIANT va;
        VariantInit(&va);

        CDomain*  pDomain;
        CDomains* pDomains = (CDomains*)MKOBJ(LlsGetApp()->GetDomains(va));

        m_serverTree.SetRedraw( FALSE );

        if (pDomains)
        {
            TV_EXPANDED_INFO tvExpandedInfo;

            if (::TvRefreshObArray(
                    &m_serverTree,
                    hRoot,
                    pDomains->m_pObArray,
                    &tvExpandedInfo))
            {
                TV_EXPANDED_ITEM* pExpandedItem = tvExpandedInfo.pExpandedItems;

                while (tvExpandedInfo.nExpandedItems--)
                {
                    pDomain = (CDomain*)pExpandedItem->pObject;
                    VALIDATE_OBJECT(pDomain, CDomain);

                    if (hDomain = ::TvGetDomain(&m_serverTree, hRoot, pDomain))
                    {
                        ::TvSwitchItem(&m_serverTree, hDomain, pExpandedItem);

                        if (!RefreshServerTreeServers(pExpandedItem->hItem))
                        {
                            ::TvReleaseObArray(&m_serverTree, pExpandedItem->hItem);
                        }
                    }
                    else
                    {
                        ::TvReleaseObArray(&m_serverTree, pExpandedItem->hItem);
                    }

                    pDomain->InternalRelease(); // release now...
                    pExpandedItem++;
                }

                delete [] tvExpandedInfo.pExpandedItems;

                bIsRefreshed = TRUE;
            }

            pDomains->InternalRelease(); // release now...
        }

        if (bIsRefreshed)
        {
            TV_SORTCB tvSortCB;

            tvSortCB.hParent     = hRoot;
            tvSortCB.lpfnCompare = CompareDomains;
            tvSortCB.lParam      = 0L;  // ignored...

            m_serverTree.SortChildrenCB(&tvSortCB);
        }

        m_serverTree.SetRedraw( TRUE );
    }
    else
    {
        CString strLabel;

        tvItem.mask = TVIF_TEXT|
                      TVIF_PARAM|
                      TVIF_CHILDREN|
                      TVIF_SELECTEDIMAGE|
                      TVIF_IMAGE;

        tvItem.cChildren = TRUE;
        tvItem.iImage = BMPI_ENTERPRISE;
        tvItem.iSelectedImage = BMPI_ENTERPRISE;

        strLabel.LoadString(IDS_ENTERPRISE);
        tvItem.pszText = MKSTR(strLabel);

        tvItem.lParam = (LPARAM)(LPVOID)LlsGetApp();

        tvInsert.item         = tvItem;
        tvInsert.hInsertAfter = (HTREEITEM)TVI_ROOT;
        tvInsert.hParent      = (HTREEITEM)NULL;

        if (hRoot = m_serverTree.InsertItem(&tvInsert))
        {
            hDomain = hRoot; // initialize...

            if (m_serverTree.Expand(hRoot, TVE_EXPAND))
            {
                if (LlsGetApp()->IsFocusDomain())
                {
                    CDomain* pActiveDomain = GetDocument()->GetDomain();
                    ASSERT(pActiveDomain);

                    if (hDomain = ::TvGetDomain(&m_serverTree, hRoot, pActiveDomain))
                    {
                        m_serverTree.Expand(hDomain, TVE_EXPAND);
                    }
                }
            }
            else
            {
                theApp.DisplayLastStatus(); // display warning...
            }

            VERIFY(m_serverTree.Select(hDomain, TVGN_FIRSTVISIBLE));
            VERIFY(m_serverTree.Select(hDomain, TVGN_CARET));

            bIsRefreshed = TRUE;
        }
        else
        {
            LlsSetLastStatus(STATUS_NO_MEMORY);
        }
    }

    return bIsRefreshed;
}


BOOL CLlsmgrView::RefreshServerTreeServers(HTREEITEM hParent)

/*++

Routine Description:

    Refreshs servers of domain.

Arguments:

    hParent - handle of expanded domain.

Return Values:

    Returns true if successful.

--*/

{
    TV_ITEM tvItem;
    HTREEITEM hServer;

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    tvItem.hItem = hParent;
    tvItem.mask  = LVIF_PARAM;

    VERIFY(m_serverTree.GetItem(&tvItem));

    CDomain* pDomain = (CDomain*)tvItem.lParam;
    VALIDATE_OBJECT(pDomain, CDomain);

    CServer*  pServer;
    CServers* pServers = (CServers*)MKOBJ(pDomain->GetServers(va));

    if (pServers)
    {
        TV_EXPANDED_INFO tvExpandedInfo;

        if (::TvRefreshObArray(
                &m_serverTree,
                hParent,
                pServers->m_pObArray,
                &tvExpandedInfo))
        {
            TV_EXPANDED_ITEM* pExpandedItem = tvExpandedInfo.pExpandedItems;

            while (tvExpandedInfo.nExpandedItems--)
            {
                pServer = (CServer*)pExpandedItem->pObject;
                VALIDATE_OBJECT(pServer, CServer);

                if (hServer = ::TvGetServer(&m_serverTree, hParent, pServer))
                {
                    ::TvSwitchItem(&m_serverTree, hServer, pExpandedItem);

                    if (!RefreshServerTreeServices(pExpandedItem->hItem))
                    {
                        ::TvReleaseObArray(&m_serverTree, pExpandedItem->hItem);
                    }
                }
                else
                {
                    ::TvReleaseObArray(&m_serverTree, pExpandedItem->hItem);
                }

                pServer->InternalRelease(); // release now...
                pExpandedItem++;
            }

            delete [] tvExpandedInfo.pExpandedItems;
            bIsRefreshed = TRUE;
        }

        pServers->InternalRelease(); // release now...
    }

    if (bIsRefreshed)
    {
        TV_SORTCB tvSortCB;

        tvSortCB.hParent     = hParent;
        tvSortCB.lpfnCompare = CompareServers;
        tvSortCB.lParam      = 0L;  // ignored...

        m_serverTree.SortChildrenCB(&tvSortCB);
    }
    else
    {
        theApp.DisplayLastStatus();
    }

    return bIsRefreshed;
}


BOOL CLlsmgrView::RefreshServerTreeServices(HTREEITEM hParent)

/*++

Routine Description:

    Refreshs services of server.

Arguments:

    hParent - handle of expanded server.

Return Values:

    Returns true if successful.

--*/

{
    TV_ITEM tvItem;

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    tvItem.hItem = hParent;
    tvItem.mask  = LVIF_PARAM;

    VERIFY(m_serverTree.GetItem(&tvItem));

    CServer* pServer = (CServer*)tvItem.lParam;
    VALIDATE_OBJECT(pServer, CServer);

    CServices* pServices = (CServices*)MKOBJ(pServer->GetServices(va));

    if (pServices)
    {
        TV_EXPANDED_INFO tvExpandedInfo;

        if (::TvRefreshObArray(&m_serverTree, hParent, pServices->m_pObArray, &tvExpandedInfo))
        {
            ASSERT(!tvExpandedInfo.nExpandedItems);
            ASSERT(!tvExpandedInfo.pExpandedItems);

            bIsRefreshed = TRUE;    // should be no expanded items...
        }

        pServices->InternalRelease();    // release now...
    }

    if (bIsRefreshed)
    {
        TV_SORTCB tvSortCB;

        tvSortCB.hParent     = hParent;
        tvSortCB.lpfnCompare = CompareServices;
        tvSortCB.lParam      = 0L;  // ignored...

        m_serverTree.SortChildrenCB(&tvSortCB);
    }
    else
    {
        theApp.DisplayLastStatus();
    }

    return bIsRefreshed;
}


BOOL CLlsmgrView::RefreshUserList()

/*++

Routine Description:

    Refreshs user list control.

Arguments:

    None.

Return Values:

    Returns true if users successfully updated.

--*/

{
    CUsers* pUsers;

    if (pUsers = GetDocument()->GetUsers())
    {
        return ::LvRefreshObArray(
                    &m_userList,
                    &g_userColumnInfo,
                    pUsers->m_pObArray
                    );
    }

    return FALSE;
}


void CLlsmgrView::SaveSettings()

/*++

Routine Description:

    Save settings to registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long Status;
    HKEY hKeyLlsmgr;

    DWORD dwDisposition;

    Status = RegCreateKeyEx(
                HKEY_CURRENT_USER,
                szRegKeyLlsmgr,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKeyLlsmgr,
                &dwDisposition
                );

    if (Status == ERROR_SUCCESS)
    {
        //
        // Save settings on exit
        //

        RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrSaveSettings, 0, REG_DWORD, (LPBYTE)&m_bSaveSettings, sizeof(DWORD));

        if (m_bSaveSettings)
        {
            //
            // Save font information
            //

            long lValue;

            lValue = (m_lFont.lfHeight < 0) ? -m_lFont.lfHeight : 0;
            RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontHeight, 0, REG_DWORD, (LPBYTE)&lValue, sizeof(DWORD));

            lValue = (m_lFont.lfWeight > 0) ?  m_lFont.lfWeight : 0;
            RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontWeight, 0, REG_DWORD, (LPBYTE)&lValue, sizeof(DWORD));

            lValue = (m_lFont.lfItalic > 0) ? TRUE : FALSE;
            RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontItalic, 0, REG_DWORD, (LPBYTE)&lValue, sizeof(DWORD));

            RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontFaceName, 0, REG_SZ, (LPBYTE)m_lFont.lfFaceName, (lstrlen(m_lFont.lfFaceName) + 1) * sizeof(TCHAR));

            lValue = (LONG)m_lFont.lfCharSet;
            ::RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrFontCharset, 0, REG_DWORD, (LPBYTE)&lValue, sizeof(DWORD));

            //
            // MRU domain list
            //

            TCHAR  szValue[512];
            LPTSTR pszValue = szValue;

            DWORD  cbValue  = 2 * sizeof(TCHAR);    // terminators

            CString strDomain;
            UINT    cchDomain;

            POSITION position;
            position = m_mruDomainList.GetTailPosition();

            while (position)
            {
                strDomain = m_mruDomainList.GetPrev(position);
                cchDomain = strDomain.GetLength() + 1;

                lstrcpyn(pszValue, strDomain, cchDomain);

                pszValue += cchDomain;
                cbValue  += cchDomain * sizeof(TCHAR);
            }

            *pszValue     = _T('\0');
            *(pszValue+1) = _T('\0');

            RegSetValueEx(hKeyLlsmgr, szRegKeyLlsmgrMruList, 0, REG_MULTI_SZ, (LPBYTE)szValue, cbValue);
        }

        RegCloseKey(hKeyLlsmgr);
    }
}


void CLlsmgrView::ViewProductProperties()

/*++

Routine Description:

    View properties of selected product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CProduct* pProduct;

    if (pProduct = (CProduct*)::LvGetSelObj(&m_productList))
    {
        VALIDATE_OBJECT(pProduct, CProduct);

        CString strTitle;
        AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pProduct->m_strName);

        CProductPropertySheet productProperties(strTitle);
        productProperties.InitPages(pProduct);
        productProperties.DoModal();

        OnUpdate(this, productProperties.m_fUpdateHint, NULL);
   }
}


void CLlsmgrView::ViewServerProperties()

/*++

Routine Description:

    View properties of selected server.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CObject* pObject;

    if (pObject = (CObject*)::TvGetSelObj(&m_serverTree))
    {
        CString strTitle;

        ASSERT_VALID(pObject);

        if (pObject->IsKindOf(RUNTIME_CLASS(CServer)))
        {
            CServer* pServer = (CServer*)pObject;
            AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pServer->m_strName);

            CServerPropertySheet serverProperties(strTitle);
            serverProperties.InitPages(pServer);
            serverProperties.DoModal();

            OnUpdate(this, serverProperties.m_fUpdateHint, NULL);
        }
        else if (pObject->IsKindOf(RUNTIME_CLASS(CService)))
        {
            CService* pService = (CService*)pObject;

            CLicensingModeDialog lmodDlg;
            lmodDlg.InitDialog(pService);
            lmodDlg.DoModal();

            if (lmodDlg.m_fUpdateHint)
            {
                TV_ITEM tvItem;

                tvItem.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
                tvItem.hItem = m_serverTree.GetSelectedItem();
                tvItem.iImage = pService->IsPerServer() ? BMPI_PRODUCT_PER_SERVER : BMPI_PRODUCT_PER_SEAT;
                tvItem.iSelectedImage = tvItem.iImage;

                VERIFY(m_serverTree.SetItem(&tvItem));
                VERIFY(m_serverTree.Select(tvItem.hItem, TVGN_CARET));
            }

            OnUpdate(this, lmodDlg.m_fUpdateHint, NULL);
        }
    }
}


void CLlsmgrView::ViewUserProperties()

/*++

Routine Description:

    View properties of selected user.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;

    if (pUser = (CUser*)::LvGetSelObj(&m_userList))
    {
        VALIDATE_OBJECT(pUser, CUser);

        CString strTitle;
        AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pUser->m_strName);

        CUserPropertySheet userProperties(strTitle);
        userProperties.InitPages(pUser);
        userProperties.DoModal();

        OnUpdate(this, userProperties.m_fUpdateHint, NULL);
   }

}


int CALLBACK CompareLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pLicense1 ((CLicense*)lParam1)
#define pLicense2 ((CLicense*)lParam2)

    VALIDATE_OBJECT(pLicense1, CLicense);
    VALIDATE_OBJECT(pLicense2, CLicense);

    int iResult;

    switch (g_licenseColumnInfo.nSortedItem)
    {
    case LVID_PURCHASE_HISTORY_DATE:
        iResult = pLicense1->m_lDate - pLicense2->m_lDate;
        break;

    case LVID_PURCHASE_HISTORY_PRODUCT:
        iResult = pLicense1->m_strProduct.CompareNoCase(pLicense2->m_strProduct);
        break;

    case LVID_PURCHASE_HISTORY_QUANTITY:
        iResult = pLicense1->m_lQuantity - pLicense2->m_lQuantity;
        break;

    case LVID_PURCHASE_HISTORY_ADMINISTRATOR:
        iResult = pLicense1->m_strUser.CompareNoCase(pLicense2->m_strUser);
        break;

    case LVID_PURCHASE_HISTORY_COMMENT:
        iResult = pLicense1->m_strDescription.CompareNoCase(pLicense2->m_strDescription);
        break;

    default:
        iResult = 0;
        break;
    }

    return g_licenseColumnInfo.bSortOrder ? -iResult : iResult;
}


int CALLBACK CompareProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pProduct1 ((CProduct*)lParam1)
#define pProduct2 ((CProduct*)lParam2)

    VALIDATE_OBJECT(pProduct1, CProduct);
    VALIDATE_OBJECT(pProduct2, CProduct);

    int iResult;

    switch (g_productColumnInfo.nSortedItem)
    {
    case LVID_PRODUCTS_VIEW_NAME:
        iResult = pProduct1->m_strName.CompareNoCase(pProduct2->m_strName);
        break;

    case LVID_PRODUCTS_VIEW_PER_SEAT_CONSUMED:
        iResult = pProduct1->m_lInUse - pProduct2->m_lInUse;
        break;

    case LVID_PRODUCTS_VIEW_PER_SEAT_PURCHASED:
        iResult = pProduct1->m_lLimit - pProduct2->m_lLimit;
        break;

    case LVID_PRODUCTS_VIEW_PER_SERVER_PURCHASED:
        iResult = pProduct1->m_lConcurrent - pProduct2->m_lConcurrent;
        break;

    case LVID_PRODUCTS_VIEW_PER_SERVER_REACHED:
        iResult = pProduct1->m_lHighMark - pProduct2->m_lHighMark;
        break;

    default:
        iResult = 0;
        break;
    }

    return g_productColumnInfo.bSortOrder ? -iResult : iResult;
}


int CALLBACK CompareUsers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pUser1 ((CUser*)lParam1)
#define pUser2 ((CUser*)lParam2)

    VALIDATE_OBJECT(pUser1, CUser);
    VALIDATE_OBJECT(pUser2, CUser);

    int iResult;

    switch (g_userColumnInfo.nSortedItem)
    {
    case LVID_PER_SEAT_CLIENTS_NAME:
        iResult = pUser1->m_strName.CompareNoCase(pUser2->m_strName);
        break;

    case LVID_PER_SEAT_CLIENTS_LICENSED_USAGE:
        iResult = pUser1->m_lInUse - pUser2->m_lInUse;
        break;

    case LVID_PER_SEAT_CLIENTS_UNLICENSED_USAGE:
        iResult = pUser1->m_lUnlicensed - pUser2->m_lUnlicensed;
        break;

    case LVID_PER_SEAT_CLIENTS_SERVER_PRODUCTS:
        iResult = pUser1->m_strProducts.CompareNoCase(pUser2->m_strProducts);
        break;

    default:
        iResult = 0;
        break;
    }

    return g_userColumnInfo.bSortOrder ? -iResult : iResult;
}


int CALLBACK CompareDomains(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for TVM_SORTCHILDRENCB.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pDomain1 ((CDomain*)lParam1)
#define pDomain2 ((CDomain*)lParam2)

    VALIDATE_OBJECT(pDomain1, CDomain);
    VALIDATE_OBJECT(pDomain2, CDomain);

    return pDomain1->m_strName.CompareNoCase(pDomain2->m_strName);
}


int CALLBACK CompareServers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for TVM_SORTCHILDRENCB.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pServer1 ((CServer*)lParam1)
#define pServer2 ((CServer*)lParam2)

    VALIDATE_OBJECT(pServer1, CServer);
    VALIDATE_OBJECT(pServer2, CServer);

    return pServer1->m_strName.CompareNoCase(pServer2->m_strName);
}


int CALLBACK CompareServices(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for TVM_SORTCHILDRENCB.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pService1 ((CService*)lParam1)
#define pService2 ((CService*)lParam2)

    VALIDATE_OBJECT(pService1, CService);
    VALIDATE_OBJECT(pService2, CService);

    return pService1->m_strName.CompareNoCase(pService2->m_strName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsview.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsview.h

Abstract:

    View window implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LLSVIEW_H_
#define _LLSVIEW_H_

class CLlsmgrView : public CView
{
    DECLARE_DYNCREATE(CLlsmgrView)
private:
    CListCtrl     m_licenseList;
    CListCtrl     m_userList;
    CTreeCtrl     m_serverTree;
    CListCtrl     m_productList;
    CTabCtrl      m_tabCtrl;

    PTC_TAB_ENTRY m_pTabEntry;

    BOOL          m_bSaveSettings;
    BOOL          m_bOrder;
    CStringList   m_mruDomainList;
    LOGFONT       m_lFont;

public:
    CLlsmgrView();
    virtual ~CLlsmgrView();

    CLlsmgrDoc* GetDocument();

    void InitTabCtrl();
    void InitProductList();
    void InitLicenseList();
    void InitUserList();
    void InitServerTree();

    BOOL RefreshProductList();
    BOOL RefreshLicenseList();
    BOOL RefreshUserList();
    BOOL RefreshServerTree();
    BOOL RefreshServerTreeServers(HTREEITEM hParent);
    BOOL RefreshServerTreeServices(HTREEITEM hParent);

    void ResetLicenseList();
    void ResetProductList();
    void ResetUserList();
    void ResetServerTree();

    void ViewProductProperties();
    void ViewUserProperties();
    void ViewServerProperties();
    void ViewServiceProperties();

    void RecalcListColumns();
    void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    void EnableCurSelTab(BOOL bEnable = TRUE);

    void OnSortColumn(int iColumn);

    void LoadSettings();
    void SaveSettings();

    void AddToMRU(LPCTSTR lpszDomainName);

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    //{{AFX_VIRTUAL(CLlsmgrView)
    public:
    virtual void OnInitialUpdate();
    protected:
    virtual void OnDraw(CDC* pDC);
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

public:
    //{{AFX_MSG(CLlsmgrView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSelectFont();
    afx_msg void OnViewLicenses();
    afx_msg void OnViewMappings();
    afx_msg void OnViewProducts();
    afx_msg void OnViewServers();
    afx_msg void OnViewUsers();
    afx_msg void OnDelete();
    afx_msg void OnFormatIcons();
    afx_msg void OnFormatList();
    afx_msg void OnViewProperties();
    afx_msg void OnViewRefresh();
    afx_msg void OnFormatReport();
    afx_msg void OnFormatSmallIcons();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSortColumn0();
    afx_msg void OnSortColumn1();
    afx_msg void OnSortColumn2();
    afx_msg void OnSortColumn3();
    afx_msg void OnSortColumn4();
    afx_msg void OnSortColumn5();
    afx_msg void OnNewLicense();
    afx_msg void OnNewMapping();
    afx_msg void OnSelectDomain();
    afx_msg void OnSaveSettings();
    afx_msg void OnUpdateSaveSettings(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewDelete(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewProperties(CCmdUI* pCmdUI);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnSelChangingTabCtrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangeTabCtrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKeyDownTabCtrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusTabCtrl(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnKeyDownLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnKeyDownProductList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClkProductList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnProductList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoProductList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickProductList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusProductList(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnKeyDownUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClkUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusUserList(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnKeyDownServerTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClkServerTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnServerTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpandingServerTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoServerTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusServerTree(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

    afx_msg BOOL OnSelMruDomain(UINT nID);

    DECLARE_MESSAGE_MAP()
};

inline void CLlsmgrView::ResetLicenseList()
    { ::LvReleaseObArray(&m_licenseList); }

inline void CLlsmgrView::ResetProductList()
    { ::LvReleaseObArray(&m_productList); }

inline void CLlsmgrView::ResetUserList()
    { ::LvReleaseObArray(&m_userList); }

inline void CLlsmgrView::ResetServerTree()
    { ::TvReleaseObArray(&m_serverTree, m_serverTree.GetRootItem()); }

#ifndef _DEBUG
inline CLlsmgrDoc* CLlsmgrView::GetDocument()
   { return (CLlsmgrDoc*)m_pDocument; }
#endif

int CALLBACK CompareProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK CompareLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK CompareUsers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK CompareDomains(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK CompareServers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK CompareServices(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#define TCID_ALL                                   -1

#define TCID_PURCHASE_HISTORY                       0
#define TCID_PRODUCTS_VIEW                          1
#define TCID_PER_SEAT_CLIENTS                       2
#define TCID_SERVER_BROWSER                         3

#define TCID_TOTAL_TABS                             4

#define LVID_PURCHASE_HISTORY_DATE                  1
#define LVID_PURCHASE_HISTORY_PRODUCT               2
#define LVID_PURCHASE_HISTORY_QUANTITY              3
#define LVID_PURCHASE_HISTORY_ADMINISTRATOR         4
#define LVID_PURCHASE_HISTORY_COMMENT               5

#define LVID_PURCHASE_HISTORY_TOTAL_COLUMNS         6

#define LVCX_PURCHASE_HISTORY_DATE                  12
#define LVCX_PURCHASE_HISTORY_PRODUCT               25
#define LVCX_PURCHASE_HISTORY_QUANTITY              13
#define LVCX_PURCHASE_HISTORY_ADMINISTRATOR         25
#define LVCX_PURCHASE_HISTORY_COMMENT               -1

#define LVID_PRODUCTS_VIEW_NAME                     0
#define LVID_PRODUCTS_VIEW_PER_SEAT_PURCHASED       1
#define LVID_PRODUCTS_VIEW_PER_SEAT_CONSUMED        2
#define LVID_PRODUCTS_VIEW_PER_SERVER_PURCHASED     3
#define LVID_PRODUCTS_VIEW_PER_SERVER_REACHED       4

#define LVID_PRODUCTS_VIEW_TOTAL_COLUMNS            5

#define LVCX_PRODUCTS_VIEW_NAME                     20
#define LVCX_PRODUCTS_VIEW_PER_SEAT_PURCHASED       20
#define LVCX_PRODUCTS_VIEW_PER_SEAT_CONSUMED        20
#define LVCX_PRODUCTS_VIEW_PER_SERVER_PURCHASED     20
#define LVCX_PRODUCTS_VIEW_PER_SERVER_REACHED       -1

#define LVID_PER_SEAT_CLIENTS_NAME                  0
#define LVID_PER_SEAT_CLIENTS_LICENSED_USAGE        1
#define LVID_PER_SEAT_CLIENTS_UNLICENSED_USAGE      2
#define LVID_PER_SEAT_CLIENTS_SERVER_PRODUCTS       3

#define LVID_PER_SEAT_CLIENTS_TOTAL_COLUMNS         4

#define LVCX_PER_SEAT_CLIENTS_NAME                  25
#define LVCX_PER_SEAT_CLIENTS_LICENSED_USAGE        20
#define LVCX_PER_SEAT_CLIENTS_UNLICENSED_USAGE      20
#define LVCX_PER_SEAT_CLIENTS_SERVER_PRODUCTS       -1

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU                              0x007B
#endif // WM_CONTEXTMENU

#define MAX_MRU_ENTRIES                             4

#define REG_KEY_LLSMGR                              _T("Software\\Microsoft\\Llsmgr")
#define REG_KEY_LLSMGR_MRU_LIST                     _T("RecentDomainList")
#define REG_KEY_LLSMGR_FONT_FACENAME                _T("FontFaceName")
#define REG_KEY_LLSMGR_FONT_HEIGHT                  _T("FontHeight")
#define REG_KEY_LLSMGR_FONT_WEIGHT                  _T("FontWeight")
#define REG_KEY_LLSMGR_FONT_ITALIC                  _T("FontItalic")
#define REG_KEY_LLSMGR_FONT_CHARSET                 _T("FontCharSet")
#define REG_KEY_LLSMGR_SAVE_SETTINGS                _T("SaveSettings")

#define FONT_HEIGHT_DEFAULT                         -12
#define FONT_WEIGHT_DEFAULT                         FW_NORMAL

#endif // _LLSVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lmoddlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lmoddlg.h

Abstract:

    Licensing mode dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Ported to CCF API to add/remove licenses.

--*/

#ifndef _LMODDLG_H_
#define _LMODDLG_H_

class CLicensingModeDialog : public CDialog
{
private:
    CService* m_pService;
    CString   m_strServiceName;
    BOOL      m_bAreCtrlsInitialized;

public:
    DWORD     m_fUpdateHint;

public:
    CLicensingModeDialog(CWnd* pParent = NULL);   

    void InitDialog(CService* pService);

    void InitCtrls();

    void UpdatePerServerLicenses();

    //{{AFX_DATA(CLicensingModeDialog)
    enum { IDD = IDD_CHOOSE_MODE };
    CButton m_okBtn;
    CEdit m_licEdit;
    CSpinButtonCtrl m_spinCtrl;
    long m_nLicenses;
    CString m_strPerSeatStatic;
    CString m_strSupportsStatic;
    CButton m_perSeatBtn;
    CButton m_perServerBtn;
    //}}AFX_DATA
    CButton m_addPerServerBtn;
    CButton m_removePerServerBtn;

    //{{AFX_VIRTUAL(CLicensingModeDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CLicensingModeDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnModePerSeat();
    afx_msg void OnModePerServer();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    afx_msg void OnHelp();
    //}}AFX_MSG
    afx_msg void OnAddPerServer();
    afx_msg void OnRemovePerServer();
    DECLARE_MESSAGE_MAP()
};

#endif // _LMODDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lmoddlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lmoddlg.cpp

Abstract:

    Licensing mode dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        o  Ported to CCF API to add/remove licenses, incl. removing
           edit box for number of licenses and replacing with
           Add/Remove Licenses buttons.
        o  Added warning of possible loss when switching license modes.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lmoddlg.h"
#include "psrvdlg.h"
#include "pseatdlg.h"
#include "srvldlg.h"
#include "lviodlg.h"

static TCHAR szServerServiceNameNew[] = _T("Windows Server");
static TCHAR szServerServiceNameOld2[] = _T("Windows NT Server");
static TCHAR szServerServiceNameOld[] = _T("File and Print Service");

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CLicensingModeDialog, CDialog)
    //{{AFX_MSG_MAP(CLicensingModeDialog)
    ON_BN_CLICKED(IDC_MODE_RADIO_PER_SEAT, OnModePerSeat)
    ON_BN_CLICKED(IDC_MODE_RADIO_PER_SERVER, OnModePerServer)
    ON_EN_UPDATE(IDC_MODE_LICENSES, OnUpdateQuantity)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDC_MODE_ADD_PER_SERVER, OnAddPerServer)
    ON_BN_CLICKED(IDC_MODE_REMOVE_PER_SERVER, OnRemovePerServer)
END_MESSAGE_MAP()


CLicensingModeDialog::CLicensingModeDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CLicensingModeDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CLicensingModeDialog)
    m_nLicenses = 0;
    m_strPerSeatStatic = _T("");
    m_strSupportsStatic = _T("");
    //}}AFX_DATA_INIT

    m_pService = NULL;
    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CLicensingModeDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLicensingModeDialog)
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Control(pDX, IDC_MODE_LICENSES, m_licEdit);
    DDX_Text(pDX, IDC_MODE_LICENSES, m_nLicenses);
    DDV_MinMaxDWord(pDX, m_nLicenses, 0, 999999);
    DDX_Text(pDX, IDC_MODE_STATIC_PER_SEAT, m_strPerSeatStatic);
    DDX_Text(pDX, IDC_MODE_STATIC_SUPPORTS, m_strSupportsStatic);
    DDX_Control(pDX, IDC_MODE_RADIO_PER_SEAT, m_perSeatBtn);
    DDX_Control(pDX, IDC_MODE_RADIO_PER_SERVER, m_perServerBtn);
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_MODE_ADD_PER_SERVER, m_addPerServerBtn);
    DDX_Control(pDX, IDC_MODE_REMOVE_PER_SERVER, m_removePerServerBtn);
}


void CLicensingModeDialog::InitDialog(CService* pService)

/*++

Routine Description:

    Initializes dialog.

Arguments:

    pService - service object.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pService, CService);
    
    m_pService = pService;

    BSTR bstrDisplayName = m_pService->GetDisplayName();
    m_strServiceName = bstrDisplayName;
    SysFreeString(bstrDisplayName);
}


void CLicensingModeDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_licEdit.LimitText(6);

    if (m_pService->IsPerServer())
    {   
        OnModePerServer();
    }
    else
    {
        OnModePerSeat();
    }

    m_bAreCtrlsInitialized = TRUE;
}


BOOL CLicensingModeDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    AfxFormatString1(
        m_strPerSeatStatic,   
        IDS_LICENSING_MODE_1, 
        m_strServiceName
        );

    AfxFormatString1(
        m_strSupportsStatic,  
        IDS_LICENSING_MODE_2, 
        m_strServiceName
        );

    CDialog::OnInitDialog();
    
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CLicensingModeDialog::OnModePerSeat() 

/*++

Routine Description:

    Changing mode to per seat.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_perSeatBtn.SetCheck(1);
    m_perServerBtn.SetCheck(0);

    ::SafeEnableWindow(&m_addPerServerBtn,    &m_okBtn, CDialog::GetFocus(), FALSE);
    ::SafeEnableWindow(&m_removePerServerBtn, &m_okBtn, CDialog::GetFocus(), FALSE);

    m_licEdit.Clear();

    if (m_pService->IsPerServer())
    {
        if (m_pService->IsReadOnly())
        {
           CLicensingViolationDialog vioDlg;
           if (vioDlg.DoModal() != IDOK)
           {
               OnModePerServer();
               return; // bail...
           }
        }

        if (    ( 0     != GetDlgItemInt( IDC_MODE_LICENSES, NULL, FALSE ) )
             && ( IDYES != AfxMessageBox( IDP_CONFIRM_TO_PER_SEAT, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2 ) ) )
        {
            OnModePerServer();
            return; // bail...
        }
    }
}


void CLicensingModeDialog::OnModePerServer() 

/*++

Routine Description:

    Changing mode to per server.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_perSeatBtn.SetCheck(0);
    m_perServerBtn.SetCheck(1);

    ::SafeEnableWindow(&m_addPerServerBtn,    &m_okBtn, CDialog::GetFocus(), TRUE);
    ::SafeEnableWindow(&m_removePerServerBtn, &m_okBtn, CDialog::GetFocus(), TRUE);

    UpdatePerServerLicenses();

    if (!m_pService->IsPerServer())
    {
        if (m_pService->IsReadOnly())
        {
           CLicensingViolationDialog vioDlg;
           if (vioDlg.DoModal() != IDOK)
           {
               OnModePerSeat();             
               return; // bail...
           }
        }

        if ( IDYES != AfxMessageBox( IDP_CONFIRM_TO_PER_SERVER, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2 ) )
        {
            OnModePerSeat();             
            return; // bail...
        }
    }
}


void CLicensingModeDialog::OnOK() 

/*++

Routine Description:

    Update registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BOOL bUpdateRegistry = TRUE;


    if (m_perSeatBtn.GetCheck())    
    {
        if (m_pService->IsPerServer())
        {
            CPerSeatLicensingDialog perSeatDlg;
            perSeatDlg.m_strProduct = m_strServiceName;
        
            if (perSeatDlg.DoModal() != IDOK)
                return;         // bail...
        }
        else
        {
            bUpdateRegistry = FALSE;
        }
    }
    else if (m_perServerBtn.GetCheck())
    {
        if (!UpdateData(TRUE))
            return;             // bail...  

        if (!m_pService->IsPerServer())
        {
            if (!m_nLicenses && 
               (!m_strServiceName.CompareNoCase(szServerServiceNameNew) ||
                !m_strServiceName.CompareNoCase(szServerServiceNameOld2) ||
                !m_strServiceName.CompareNoCase(szServerServiceNameOld)))
            {
                CServerLicensingDialog srvlDlg;
                
                if (srvlDlg.DoModal() != IDOK)
                    return;     // bail...
            }
            else
            {
                CString strLicenses;
                CPerServerLicensingDialog perServerDlg;
    
                perServerDlg.m_strProduct = m_strServiceName;

                strLicenses.Format(_T("%ld"), m_nLicenses);
                perServerDlg.m_strLicenses = strLicenses;
            
                if (perServerDlg.DoModal() != IDOK)
                    return;     // bail...
            }
        }            
        else
        {
            bUpdateRegistry = FALSE;
        }
    }

    if (bUpdateRegistry)
    {
        long Status;

#ifdef CONFIG_THROUGH_REGISTRY
        DWORD dwValue;

        BOOL bIsRegistryUpdated = FALSE;
        HKEY hkeyService = m_pService->GetRegKey();

        dwValue = (m_perSeatBtn.GetCheck() || (m_perServerBtn.GetCheck() != m_pService->IsPerServer())) ? 0x1 : 0x0;
                            
        Status = RegSetValueEx(
                    hkeyService,
                    REG_VALUE_FLIP,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwValue,
                    sizeof(DWORD)
                    );

        if (Status == ERROR_SUCCESS)
        {
            m_fUpdateHint |= UPDATE_LICENSE_MODE; // update...
            m_pService->m_bIsReadOnly = (dwValue == 0x1); // update...

            dwValue = m_perSeatBtn.GetCheck() ? 0x0 : 0x1;        

            Status = RegSetValueEx(
                        hkeyService,
                        REG_VALUE_MODE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        sizeof(DWORD)
                        );

            if (Status == ERROR_SUCCESS)
            {
                m_pService->m_bIsPerServer = (dwValue == 0x1); // update...

                bIsRegistryUpdated = TRUE;
            }
        }

        if (hkeyService)
        {
            RegCloseKey(hkeyService);
        }

        if (!bIsRegistryUpdated)
        {
            theApp.DisplayStatus(::GetLastError());
            return; // bail...
        }
#else
        CServer* pServer = (CServer*)MKOBJ(m_pService->GetParent());

        if ( pServer && pServer->ConnectLls() ) // JonN 5/5/00 PREFIX 112122
        {
            BSTR pKeyName = m_pService->GetName();

            if ( NULL == pKeyName )
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                PLLS_LOCAL_SERVICE_INFO_0   pServiceInfo = NULL;

                Status = ::LlsLocalServiceInfoGet( pServer->GetLlsHandle(), pKeyName, 0, (LPBYTE *) &pServiceInfo );

                if ( NT_SUCCESS( Status ) )
                {
                    pServiceInfo->FlipAllow = (m_perSeatBtn.GetCheck() || (m_perServerBtn.GetCheck() != m_pService->IsPerServer())) ? 0x1 : 0x0;
                    pServiceInfo->Mode = m_perSeatBtn.GetCheck() ? 0x0 : 0x1;

                    Status = ::LlsLocalServiceInfoSet( pServer->GetLlsHandle(), pKeyName, 0, (LPBYTE) pServiceInfo );

                    if ( NT_SUCCESS( Status ) )
                    {
                        m_fUpdateHint |= UPDATE_LICENSE_MODE; // update...
                        m_pService->m_bIsReadOnly  = ( 0x1 == pServiceInfo->FlipAllow ); // update...
                        m_pService->m_bIsPerServer = ( 0x1 == pServiceInfo->Mode      ); // update...
                    }

                    ::LlsFreeMemory( pServiceInfo->KeyName );
                    ::LlsFreeMemory( pServiceInfo->DisplayName );
                    ::LlsFreeMemory( pServiceInfo->FamilyDisplayName );
                    ::LlsFreeMemory( pServiceInfo );
                }

                if ( IsConnectionDropped( Status ) )
                {
                    pServer->DisconnectLls();
                }

                SysFreeString( pKeyName );
            }
        }
        else
        {
            Status = LlsGetLastStatus();
        }

        LlsSetLastStatus( Status );

        if ( !NT_SUCCESS( Status ) )
        {
            theApp.DisplayStatus( Status );
            return; // bail...
        }
#endif
    }
    
   

    EndDialog(IDOK);
    return;
}

void CLicensingModeDialog::OnCancel() 

/*++

Routine Description:

    Update registry.

Arguments:

    None.

Return Values:

    None.

--*/

{

   if (m_nLicenses > (LONG) 999999)
   {
       UpdateData( TRUE );
   }
   else
   {

     EndDialog( 0 );
   }

    return;

}



BOOL CLicensingModeDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
        }
        
        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CLicensingModeDialog::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;
    
    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);      
    }
    else if (m_nLicenses > 999999)
    {
        m_nLicenses = 999999;

        ::MessageBeep(MB_OK);      
    }

    UpdateData(FALSE);  // set data

    *pResult = 1;   // handle ourselves...
}


void CLicensingModeDialog::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_licEdit.IsWindowEnabled())
    {
        long nLicensesOld = m_nLicenses;

        if (!UpdateData(TRUE))
        {
            m_nLicenses = nLicensesOld;

            UpdateData(FALSE);

            m_licEdit.SetFocus();
            m_licEdit.SetSel(0,-1);

            ::MessageBeep(MB_OK);      
        }
    }
}


void CLicensingModeDialog::OnHelp()

/*++

Routine Description:

    Help button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDialog::OnCommandHelp(0, 0L);
}


void CLicensingModeDialog::OnAddPerServer()

/*++

Routine Description:

    Add per server licenses button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CServer* pServer = (CServer*)MKOBJ(m_pService->GetParent());

    LPTSTR pszUniServerName   = pServer->GetName();
    LPTSTR pszUniProductName  = m_pService->GetDisplayName();

    if ( ( NULL == pszUniServerName ) || ( NULL == pszUniProductName ) )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );
        LPSTR pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );

        if ( ( NULL == pszAscServerName ) || ( NULL == pszAscProductName ) )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
        }
        else
        {
            wsprintfA( pszAscServerName,  "%ls", pszUniServerName  );
            wsprintfA( pszAscProductName, "%ls", pszUniProductName );

            DWORD dwError = CCFCertificateEnterUI( m_hWnd, pszAscServerName, pszAscProductName, "Microsoft", CCF_ENTER_FLAG_PER_SERVER_ONLY, NULL );

            if ( ERROR_SUCCESS == dwError )
            {
                m_fUpdateHint |= UPDATE_INFO_SERVICES | UPDATE_INFO_PRODUCTS; // update...
                UpdatePerServerLicenses();
            }
        }

        if ( NULL != pszAscServerName )
        {
            LocalFree( pszAscServerName );
        }
        if ( NULL != pszAscProductName )
        {
            LocalFree( pszAscProductName );
        }
    }

    if ( NULL != pszUniServerName )
    {
        SysFreeString( pszUniServerName );
    }
    if ( NULL != pszUniProductName )
    {
        SysFreeString( pszUniProductName );
    }

}


void CLicensingModeDialog::OnRemovePerServer()

/*++

Routine Description:

    Remove per server licenses button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CServer* pServer = (CServer*)MKOBJ(m_pService->GetParent());

    LPTSTR pszUniServerName   = pServer->GetName();
    LPTSTR pszUniProductName  = m_pService->GetDisplayName();

    if ( ( NULL == pszUniServerName ) || ( NULL == pszUniProductName ) )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );
        LPSTR pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );

        if ( ( NULL == pszAscServerName ) || ( NULL == pszAscProductName ) )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
        }
        else
        {
            wsprintfA( pszAscServerName,  "%ls", pszUniServerName  );
            wsprintfA( pszAscProductName, "%ls", pszUniProductName );

            CCFCertificateRemoveUI( m_hWnd, pszAscServerName, pszAscProductName, "Microsoft", NULL, NULL );
            m_fUpdateHint |= UPDATE_INFO_SERVERS | UPDATE_INFO_SERVICES | UPDATE_LICENSE_DELETED; // update...

            UpdatePerServerLicenses();
        }

        if ( NULL != pszAscServerName )   LocalFree( pszAscServerName );
        if ( NULL != pszAscProductName )  LocalFree( pszAscProductName );
    }

    if ( NULL != pszUniServerName )    SysFreeString( pszUniServerName );
    if ( NULL != pszUniProductName )   SysFreeString( pszUniProductName );
}


void CLicensingModeDialog::UpdatePerServerLicenses()

/*++

Routine Description:

    Update the concurrent limit setting from the registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BeginWaitCursor();

    CServer* pServer = (CServer*)MKOBJ(m_pService->GetParent());

    if ( pServer == NULL )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
        return;
    }
    LPTSTR pszUniServerName   = pServer->GetName();
    LPTSTR pszUniProductName  = m_pService->GetDisplayName();

    if ( ( NULL == pszUniServerName ) || ( NULL == pszUniProductName ) )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        LPTSTR pszUniNetServerName  = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR) * ( 3 + lstrlen( pszUniServerName  ) ) );

        if ( NULL == pszUniNetServerName )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
        }
        else
        {
            wsprintf(  pszUniNetServerName,  TEXT("%ls%ls"), (TEXT('\\') == *pszUniServerName) ? TEXT("") : TEXT("\\\\"), pszUniServerName  );

            LLS_HANDLE  hLls;
            DWORD       dwError = LlsConnect( pszUniNetServerName, &hLls );

            if ( ERROR_SUCCESS == dwError )
            {
                DWORD   dwConcurrentLimit;

                dwError = LlsProductLicensesGet( hLls, pszUniProductName, LLS_LICENSE_MODE_PER_SERVER, &dwConcurrentLimit );

                LlsClose( hLls );

                if ( ERROR_SUCCESS == dwError )
                {
                    m_pService->m_lPerServerLimit = dwConcurrentLimit;
                }
            }

            if ( ERROR_SUCCESS != dwError )
            {
#ifdef CONFIG_THROUGH_REGISTRY
                HKEY    hkeyService = m_pService->GetRegKey();
                DWORD   dwConcurrentLimit;
                DWORD   dwType;
                DWORD   cb = sizeof( dwConcurrentLimit );

                DWORD dwError = RegQueryValueEx( hkeyService, REG_VALUE_LIMIT, NULL, &dwType, (LPBYTE) &dwConcurrentLimit, &cb );
                ASSERT( ERROR_SUCCESS == dwError );

                if ( ERROR_SUCCESS == dwError )
                {
                    m_pService->m_lPerServerLimit = dwConcurrentLimit;
                }

                RegCloseKey( hkeyService );
#else
                NTSTATUS Status;

                if ( pServer->ConnectLls() )
                {
                    BSTR pKeyName = m_pService->GetName();

                    if ( NULL == pKeyName )
                    {
                        Status = STATUS_NO_MEMORY;
                    }
                    else
                    {
                        PLLS_LOCAL_SERVICE_INFO_0   pServiceInfo = NULL;

                        Status = ::LlsLocalServiceInfoGet( pServer->GetLlsHandle(), pKeyName, 0, (LPBYTE *) &pServiceInfo );

                        if ( NT_SUCCESS( Status ) )
                        {
                            m_pService->m_lPerServerLimit = pServiceInfo->ConcurrentLimit;

                            ::LlsFreeMemory( pServiceInfo->KeyName );
                            ::LlsFreeMemory( pServiceInfo->DisplayName );
                            ::LlsFreeMemory( pServiceInfo->FamilyDisplayName );
                            ::LlsFreeMemory( pServiceInfo );
                        }

                        if ( IsConnectionDropped( Status ) )
                        {
                            pServer->DisconnectLls();
                        }

                        SysFreeString( pKeyName );
                    }
                }
                else
                {
                    Status = LlsGetLastStatus();
                }

                LlsSetLastStatus( Status );

                if ( !NT_SUCCESS( Status ) )
                {
                    theApp.DisplayStatus( Status );
                    return; // bail...
                }
#endif
            }
        }

        if ( NULL != pszUniNetServerName )
        {
            LocalFree( pszUniNetServerName );
        }
    }

    if ( NULL != pszUniServerName )
    {
        SysFreeString( pszUniServerName );
    }
    if ( NULL != pszUniProductName )
    {
        SysFreeString( pszUniProductName );
    }

    EndWaitCursor();    

    m_nLicenses = m_pService->m_lPerServerLimit;
    
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lviodlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lviodlg.cpp

Abstract:

    License violation dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lviodlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CLicensingViolationDialog, CDialog)
    //{{AFX_MSG_MAP(CLicensingViolationDialog)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CLicensingViolationDialog::CLicensingViolationDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CLicensingViolationDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CLicensingViolationDialog)
    //}}AFX_DATA_INIT
}


void CLicensingViolationDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLicensingViolationDialog)
    //}}AFX_DATA_MAP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\lviodlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    lviodlg.h

Abstract:

    License violation dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LVIODLG_H_
#define _LVIODLG_H_

class CLicensingViolationDialog : public CDialog
{
public:
    CLicensingViolationDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CLicensingViolationDialog)
    enum { IDD = IDD_VIOLATION };
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CLicensingViolationDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CLicensingViolationDialog)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _LVIODLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\llsmgr.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsmgr.cpp

Abstract:

    Application object implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added SetLastTargetServer() to OpenDocumentFile() to help isolate
        server connection problems.  (Bug #2993.)

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "mainfrm.h"
#include "llsdoc.h"
#include "llsview.h"
#include "sdomdlg.h"
#include "shellapi.h"
#include <afxpriv.h>
#include <htmlhelp.h>
#include <sbs_res.h>

BOOL IsRestrictedSmallBusSrv( void );

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CLlsmgrApp theApp;  // The one and only CLlsmgrApp object

BEGIN_MESSAGE_MAP(CLlsmgrApp, CWinApp)
    //{{AFX_MSG_MAP(CLlsmgrApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CLlsmgrApp::CLlsmgrApp()

/*++

Routine Description:

    Constructor for application object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_pApplication = NULL;
    m_bIsAutomated = FALSE;

#ifdef _DEBUG_VERBOSE
    afxMemDF |= checkAlwaysMemDF;
#endif
}


int CLlsmgrApp::ExitInstance()

/*++

Routine Description:

    Called by framework to exit this instance of an application.

Arguments:

    None.

Return Values:

    Application's exit code.

--*/

{
    if (m_pApplication && !m_bIsAutomated)
        m_pApplication->InternalRelease();

#ifdef _DEBUG
    CMemoryState exitMem;
    CMemoryState diffMem;

    exitMem.Checkpoint();

    if (!diffMem.Difference(m_initMem, exitMem))
    {
        diffMem.DumpStatistics();
        m_initMem.DumpAllObjectsSince();
    }
#endif

    return CWinApp::ExitInstance();
}


BOOL CLlsmgrApp::InitInstance()

/*++

Routine Description:

    Called by framework to initialize a new instance of an application.

Arguments:

    None.

Return Values:

    TRUE if initialization succeeds.

--*/

{
#ifdef _DEBUG
    m_initMem.Checkpoint();
#endif

    //
    // Check if this server is a restricted small business server.
    // If so, disallow further use of the license manager.
    //

    if (IsRestrictedSmallBusSrv())
    {
        //
        // Let the user know of the restriction.
        //
        HINSTANCE hSbsLib = NULL;

        if ( hSbsLib = LoadLibrary( SBS_RESOURCE_DLL ) )
        {
            TCHAR pszText[512+1];
            LoadString ( hSbsLib, SBS_License_Error, pszText, 512 );
            AfxMessageBox( pszText );
        }
        else
        {
            AfxMessageBox(IDP_SBS_RESTRICTED);
        }
        return FALSE;
    }

    //
    // Initialize OLE libraries
    //

    if (!AfxOleInit())
    {
        AfxMessageBox(IDP_OLE_INIT_FAILED);
        return FALSE;
    }

    //
    // If the application was launched as an OLE server (run with
    // /Embedding or /Automation) then register all OLE server factories
    // as running and don't show main window.
    //

    if (RunEmbedded() || RunAutomated())
    {
        COleTemplateServer::RegisterAll();
        return m_bIsAutomated = TRUE;
    }

    //
    // Create image list for common controls
    //

    m_smallImages.Create(IDB_SMALL_CTRLS, BMPI_SMALL_SIZE, 0, BMPI_RGB_BKGND);
    m_largeImages.Create(IDB_LARGE_CTRLS, BMPI_LARGE_SIZE, 0, BMPI_RGB_BKGND);

    //
    // Create document template
    //

    m_pDocTemplate = new CSingleDocTemplate(
                            IDR_MAINFRAME,
                            RUNTIME_CLASS(CLlsmgrDoc),
                            RUNTIME_CLASS(CMainFrame),
                            RUNTIME_CLASS(CLlsmgrView)
                            );

    AddDocTemplate(m_pDocTemplate);

    //
    // Create OLE-createable application object. This object
    // will save itself in m_pApplication so there should only
    // be one and only one. If the application was launched as
    // an OLE server then this object is created automatically
    // via CreateObject() or GetObject().
    //

    CApplication* pApplication = new CApplication;

    if (pApplication && !pApplication->GetLastStatus())
    {
        OnFileNew();    // display empty frame ...
        m_pMainWnd->PostMessage(WM_COMMAND, ID_APP_STARTUP);
    }
    else
    {
        AfxMessageBox(IDP_APP_INIT_FAILED);
        return FALSE;
    }

    return TRUE;
}


void CLlsmgrApp::DisplayStatus(long Status)

/*++

Routine Description:

    Retrieves status string and displays.

Arguments:

    Status - status code.

Return Values:

    None.

--*/

{
    m_pApplication->SetLastStatus(Status);
    DisplayLastStatus();
}


void CLlsmgrApp::DisplayLastStatus()

/*++

Routine Description:

    Retrieves status string and displays.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BSTR LastErrorString = m_pApplication->GetLastErrorString();
    AfxMessageBox(LastErrorString);
    SysFreeString(LastErrorString);
}

void CLlsmgrApp::OnAppAbout()

/*++

Routine Description:

    Message handler for ID_APP_ABOUT.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BSTR AppName = LlsGetApp()->GetName();
    ::ShellAbout(m_pMainWnd->GetSafeHwnd(), AppName, AppName, LoadIcon(IDR_MAINFRAME));
    SysFreeString(AppName);
}


CDocument* CLlsmgrApp::OpenDocumentFile(LPCTSTR lpszFileName)

/*++

Routine Description:

    Message handler for ID_FILE_OPEN.

Arguments:

    lpszFileName - file name (actually domain name).

Return Values:

    Pointer to object is successful.

--*/

{
    BOOL bFocusChanged = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor();

    if (lpszFileName)
    {
        va.vt = VT_BSTR;
        va.bstrVal = SysAllocStringLen(lpszFileName, lstrlen(lpszFileName));

        bFocusChanged = LlsGetApp()->SelectDomain(va);
    }
    else
    {
        bFocusChanged = LlsGetApp()->SelectEnterprise();

        CString eTitle;
        eTitle.LoadString(IDS_ENTERPRISE);

        lpszFileName = MKSTR(eTitle);
    }

    EndWaitCursor();

    VariantClear(&va);  // free system string if necessary...

    if (!bFocusChanged)
    {
        LPTSTR pszLastTargetServer;

        if (LlsGetLastStatus() == STATUS_ACCESS_DENIED)
        {
            AfxMessageBox(IDP_ERROR_NO_PRIVILEGES);
        }
        else if (    (    ( LlsGetLastStatus() == RPC_S_SERVER_UNAVAILABLE  )
                       || ( LlsGetLastStatus() == RPC_NT_SERVER_UNAVAILABLE ) )
                  && ( NULL != ( pszLastTargetServer = LlsGetLastTargetServer() ) ) )
        {
            CString strMessage;

            AfxFormatString1( strMessage, IDP_ERROR_NO_RPC_SERVER_FORMAT, pszLastTargetServer );
            SysFreeString( pszLastTargetServer );

            AfxMessageBox( strMessage );
        }
        else
        {
            DisplayLastStatus();
        }
        return FALSE;
    }

    //
    // Notify framework that focus changed....
    //

    return m_pDocTemplate->OpenDocumentFile(lpszFileName);
}


BOOL CLlsmgrApp::OnAppStartup()

/*++

Routine Description:

    Message handler for ID_APP_STARTUP.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    CString strStartingPoint;

    //
    // Update registry in case it has been damaged
    //

    COleObjectFactory::UpdateRegistryAll();

    //
    // Select domain using command line or machine name
    //

    if (m_lpCmdLine && *m_lpCmdLine)
    {
        LPCTSTR pszStartingPoint;
        pszStartingPoint = m_lpCmdLine;

        while (_istspace(*pszStartingPoint))
            pszStartingPoint = _tcsinc(pszStartingPoint);
        strStartingPoint = pszStartingPoint;

        strStartingPoint.TrimRight();
    }
    else
    {
        TCHAR szComputerName[MAX_PATH+1];        
        
        DWORD cchComputerName = sizeof(szComputerName) / sizeof(TCHAR);

        if (::GetComputerName(szComputerName, &cchComputerName))
        {
            strStartingPoint = _T("\\\\");
            strStartingPoint += szComputerName;
        }
        else
        {
            DisplayStatus(::GetLastError());

            m_pMainWnd->PostMessage(WM_CLOSE);
            return FALSE;
        }        
    }

    if (!OpenDocumentFile(strStartingPoint))
    {
        CSelectDomainDialog sdomDlg;

        if (sdomDlg.DoModal() != IDOK)
        {
            m_pMainWnd->PostMessage(WM_CLOSE);
            return FALSE;
        }
    }

    return TRUE;
}


void CLlsmgrApp::WinHelp( DWORD_PTR dwData, UINT nCmd )

/*++

Routine Description:

    Same as CWinApp::WinHelp with the exception that we trap HELP_CONTEXT on
    IDR_MAINFRAME and translate it to a HELP_FINDER call.

Arguments:

    None.

Return Values:

    None.

--*/

{

    UNREFERENCED_PARAMETER( dwData );
    UNREFERENCED_PARAMETER( nCmd );

   CWnd* pMainWnd = AfxGetMainWnd();
   ASSERT_VALID( pMainWnd );

    ::HtmlHelp(pMainWnd->m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);

}


const WCHAR wszProductOptions[] =
        L"System\\CurrentControlSet\\Control\\ProductOptions";

const WCHAR wszProductSuite[] =
                        L"ProductSuite";
const WCHAR wszSBSRestricted[] =
                        L"Small Business(Restricted)";

BOOL IsRestrictedSmallBusSrv( void )

/*++

Routine Description:

    Check if this server is a Microsoft small business restricted server.

Arguments:

    None.

Return Values:

    TRUE  -- This server is a restricted small business server.
    FALSE -- No such restriction.

--*/

{
    WCHAR  wszBuffer[1024] = L"";
    DWORD  cbBuffer = sizeof(wszBuffer);
    DWORD  dwType;
    LPWSTR pwszSuite;
    HKEY   hKey;
    BOOL   bRet = FALSE;

    //
    // Check if this server is a Microsoft small business restricted server.
    // Do so by checking for the existence of the string
    //     "Small Business(Restricted)"
    // in the MULTI_SZ "ProductSuite" value under
    //      HKLM\CurrentCcntrolSet\Control\ProductOptions.
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     wszProductOptions,
                     0,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey,
                            wszProductSuite,
                            NULL,
                            &dwType,
                            (LPBYTE)wszBuffer,
                            &cbBuffer) == ERROR_SUCCESS)
        {
            if (dwType == REG_MULTI_SZ && *wszBuffer)
            {
                pwszSuite = wszBuffer;

                while (*pwszSuite)
                {
                    if (lstrcmpi(pwszSuite, wszSBSRestricted) == 0)
                    {
                        bRet = TRUE;
                        break;
                    }
                    pwszSuite += wcslen(pwszSuite) + 1;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mainfrm.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mainfrm.cpp

Abstract:

    Main frame implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "mainfrm.h"
#include "llsdoc.h"
#include "llsview.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_COMMAND(ID_HELP_HTMLHELP, OnHtmlHelp)
    ON_WM_INITMENUPOPUP()
    ON_WM_SETFOCUS()
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP, OnHtmlHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHtmlHelp)
END_MESSAGE_MAP()

static UINT BASED_CODE buttons[] =
{
    ID_SELECT_DOMAIN,
        ID_SEPARATOR,
    ID_NEW_LICENSE,
        ID_SEPARATOR,
    ID_VIEW_PROPERTIES,
        ID_SEPARATOR,
    ID_APP_ABOUT,
};

static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


CMainFrame::CMainFrame()

/*++

Routine Description:

    Constructor for main frame window.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


CMainFrame::~CMainFrame()

/*++

Routine Description:

    Destructor for main frame window.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


#ifdef _DEBUG

void CMainFrame::AssertValid() const

/*++

Routine Description:

    Validates object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CFrameWnd::AssertValid();
}

#endif // _DEBUG


#ifdef _DEBUG

void CMainFrame::Dump(CDumpContext& dc) const

/*++

Routine Description:

    Dump contents of object.

Arguments:

    dc - dump context.

Return Values:

    None.

--*/

{
    CFrameWnd::Dump(dc);
}

#endif // _DEBUG


BOOL CMainFrame::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - usual.
    lParam - usual.

Return Values:

    Depends on message.

--*/

{
    if (wParam == ID_APP_STARTUP)
    {
        theApp.OnAppStartup();
        return TRUE; // processed...
    }

    return CFrameWnd::OnCommand(wParam, lParam);
}


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)

/*++

Routine Description:

    Message handler for WM_CREATE.

Arguments:

    lpCreateStruct - contains information about CWnd being constructed.

Return Values:

    None.

--*/

{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)))
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
        !m_wndToolBar.SetButtons(buttons, sizeof(buttons)/sizeof(UINT)))
        return -1;

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle()|CBRS_TOOLTIPS|CBRS_FLYBY);

    return 0;
}


void CMainFrame::OnHtmlHelp()

/*++

Routine Description:

    Message handler for ID_HELP_SEARCH.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::HtmlHelp(m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);
    // theApp.WinHelp((ULONG_PTR)"", HELP_PARTIALKEY); // force search...
}



void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)

/*++

Routine Description:

    Message handler for WM_INITMENUPOPUP.

Arguments:

    pPopupMenu - menu object.
    nIndex - menu position.
    bSysMenu - true if system menu.

Return Values:

    None.

--*/

{
    ((CLlsmgrView*)m_pViewActive)->OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
    CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
}


void CMainFrame::OnSetFocus(CWnd* pOldWnd)

/*++

Routine Description:

    Handles focus for application.

Arguments:

    pOldWnd - window releasing focus.

Return Values:

    None.

--*/

{
    CFrameWnd::OnSetFocus(pOldWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapcol.h

Abstract:

    Mapping collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _MAPCOL_H_
#define _MAPCOL_H_

class CMappings : public CCmdTarget
{
    DECLARE_DYNCREATE(CMappings)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CMappings(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CMappings();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMappings)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CMappings)
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CMappings)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _MAPCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapcol.h

Abstract:

    Mapping collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMappings, CCmdTarget)

BEGIN_MESSAGE_MAP(CMappings, CCmdTarget)
    //{{AFX_MSG_MAP(CMappings)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CMappings, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CMappings)
    DISP_PROPERTY_EX(CMappings, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CMappings, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CMappings, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_FUNCTION(CMappings, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CMappings::CMappings(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for mapping collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CController)));
#endif // ENABLE_PARENT_CHECK

    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CMappings::~CMappings()

/*++

Routine Description:

    Destructor for mapping collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CMappings::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CMappings::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CMappings::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CMappings::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified mapping object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a mapping name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CMapping* pMapping;
    INT_PTR   iMapping;

    VARIANT vMapping;
    VariantInit(&vMapping);

    if (iMapping = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iMapping--)
            {
                if (pMapping = (CMapping*)m_pObArray->GetAt(iMapping))
                {
                    ASSERT(pMapping->IsKindOf(RUNTIME_CLASS(CMapping)));

                    if (!pMapping->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pMapping->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vMapping, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vMapping.lVal >= 0) && ((int)vMapping.lVal < iMapping))
            {
                if (pMapping = (CMapping*)m_pObArray->GetAt((int)vMapping.lVal))
                {
                    ASSERT(pMapping->IsKindOf(RUNTIME_CLASS(CMapping)));
                    lpdispatch = pMapping->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CMappings::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapobj.h

Abstract:

    Mapping object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _MAPOBJ_H_
#define _MAPOBJ_H_

class CMapping : public CCmdTarget
{
    DECLARE_DYNCREATE(CMapping)
private:
    CCmdTarget* m_pParent;
    CObArray    m_userArray;
    BOOL        m_bUsersRefreshed;

public:
    CString     m_strName;
    CString     m_strDescription;
    long        m_lInUse;

    CUsers*     m_pUsers;

public:
    CMapping(
        CCmdTarget* pParent     = NULL,
        LPCTSTR     pName       = NULL, 
        long        lInUse      = 0L,
        LPCTSTR     pDecription = NULL
        );           
    virtual ~CMapping();

    BOOL Refresh();

    BOOL RefreshUsers();
    void ResetUsers();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMapping)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CMapping)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg BSTR GetDescription();
    afx_msg long GetInUse();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetUsers(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CMapping)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _MAPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapobj.cpp

Abstract:

    Mapping object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMapping, CCmdTarget)

BEGIN_MESSAGE_MAP(CMapping, CCmdTarget)
    //{{AFX_MSG_MAP(CMapping)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CMapping, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CMapping)
    DISP_PROPERTY_EX(CMapping, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CMapping, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CMapping, "Description", GetDescription, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CMapping, "InUse", GetInUse, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CMapping, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_PARAM(CMapping, "Users", GetUsers, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CMapping, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CMapping::CMapping(
    CCmdTarget* pParent,
    LPCTSTR     pName,
    long        lInUse,
    LPCTSTR     pDecription
)

/*++

Routine Description:

    Constructor for mapping object.

Arguments:

    pParent - creator of object.
    pName - name of mapping.
    lInUse - number of licenses consumed by mapping.
    pDescription - user-defined message describing mapping.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CController)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);

    m_strName        = pName;
    m_lInUse         = lInUse;
    m_strDescription = pDecription;

    m_pUsers = NULL;
    m_userArray.RemoveAll();
    m_bUsersRefreshed = FALSE;
}


CMapping::~CMapping()

/*++

Routine Description:

    Destructor for mapping object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pUsers)
        m_pUsers->InternalRelease();
}


void CMapping::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetUsers();
    delete this;
}


LPDISPATCH CMapping::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


BSTR CMapping::GetDescription()

/*++

Routine Description:

    Returns the user-defined message describing mapping.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strDescription.AllocSysString();
}


long CMapping::GetInUse()

/*++

Routine Description:

    Returns the number of licenses the mapping is consuming.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lInUse;
}


BSTR CMapping::GetName()

/*++

Routine Description:

    Returns the name of the mapping.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CMapping::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


LPDISPATCH CMapping::GetUsers(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    registered users replicated to the license controller
    pertaining to the mapping or returns an individual user
    pertaining to the mapping described by an index into
    the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a user name or a number (VT_I4) indicating the
    position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pUsers)
    {
        m_pUsers = new CUsers(this, &m_userArray);
    }

    if (m_pUsers)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bUsersRefreshed)
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
            else if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CMapping::Refresh()

/*++

Routine Description:

    Refreshs a mapping object.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS NtStatus;
    PLLS_GROUP_INFO_1 pMappingInfo1 = NULL;

    NtStatus = ::LlsGroupInfoGet(
                    LlsGetActiveHandle(),
                    MKSTR(m_strName),
                    1,
                    (LPBYTE*)&pMappingInfo1
                    );

    if (NT_SUCCESS(NtStatus))
    {
        if (RefreshUsers())
        {
            m_lInUse = pMappingInfo1->Licenses;
            m_strDescription = pMappingInfo1->Comment;
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }

#ifndef DISABLE_PER_NODE_ALLOCATION

        ::LlsFreeMemory(pMappingInfo1->Name);
        ::LlsFreeMemory(pMappingInfo1->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

        ::LlsFreeMemory(pMappingInfo1);
    }

    LlsSetLastStatus(NtStatus);   // called api

    return NT_SUCCESS(NtStatus);
}


BOOL CMapping::RefreshUsers()

/*++

Routine Description:

    Refreshs user object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetUsers();

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iUser = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsGroupUserEnum(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        0,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CUser*           pUser;
            PLLS_USER_INFO_0 pUserInfo0;

            pUserInfo0 = (PLLS_USER_INFO_0)ReturnBuffer;

            ASSERT(iUser == m_userArray.GetSize());
            m_userArray.SetSize(m_userArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pUser = new CUser(this, pUserInfo0->Name);

                m_userArray.SetAt(iUser++, pUser);  // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pUserInfo0->Name);

#endif // DISABLE_PER_NODE_ALLOCATION

                pUserInfo0++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }
    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bUsersRefreshed = TRUE;
    }
    else
    {
        ResetUsers();
    }

    return m_bUsersRefreshed;
}


void CMapping::ResetUsers()

/*++

Routine Description:

    Resets user object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    INT_PTR iUser = m_userArray.GetSize();

    while (iUser--)
    {
        if (pUser = (CUser*)m_userArray[iUser])
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            pUser->InternalRelease();
        }
    }

    m_userArray.RemoveAll();
    m_bUsersRefreshed = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapppgs.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapppgs.cpp

Abstract:

    Mapping property page (settings) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _MAPPPGS_H_
#define _MAPPPGS_H_

class CMappingPropertyPageSettings : public CPropertyPage
{
    DECLARE_DYNCREATE(CMappingPropertyPageSettings)
private:
    CMapping*  m_pMapping;
    CObList    m_deleteList;
    DWORD*     m_pUpdateHint;
    BOOL       m_bAreCtrlsInitialized;

public:
    CMappingPropertyPageSettings();
    ~CMappingPropertyPageSettings();

    void InitPage(CMapping* pMapping, DWORD* pUpdateHint);
    void AbortPageIfNecessary();
    void AbortPage();

    void InitCtrls();
    BOOL RefreshCtrls();

    BOOL IsQuantityValid();

    //{{AFX_DATA(CMappingPropertyPageSettings)
    enum { IDD = IDD_PP_MAPPING_SETTINGS };
    CEdit m_desEdit;
    CEdit m_licEdit;
    CButton m_delBtn;
    CButton m_addBtn;
    CSpinButtonCtrl m_spinCtrl;
    CListCtrl m_userList;
    CString m_strDescription;
    long m_nLicenses;
    long m_nLicensesMin;
    CString m_strName;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CMappingPropertyPageSettings)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CMappingPropertyPageSettings)
    virtual BOOL OnInitDialog();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

extern int CALLBACK CompareUsersInMapping(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _MAPPPGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mainfrm.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mainfrm.h

Abstract:

    Main frame implementation.

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _MAINFRM_H_
#define _MAINFRM_H_

class CMainFrame : public CFrameWnd
{
    DECLARE_DYNCREATE(CMainFrame)
private:
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

public:
    CMainFrame();
    virtual ~CMainFrame();

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    //{{AFX_VIRTUAL(CMainFrame)
    protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

public:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnHtmlHelp();
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _MAINFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mappsht.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mappsht.cpp

Abstract:

    Mapping property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "mappsht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CMappingPropertySheet, CPropertySheet)

BEGIN_MESSAGE_MAP(CMappingPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CMappingPropertySheet)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CMappingPropertySheet::CMappingPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for mapping property sheet.

Arguments:

    nIDCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CMappingPropertySheet::CMappingPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for mapping property sheet.

Arguments:

    pszCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CMappingPropertySheet::~CMappingPropertySheet()

/*++

Routine Description:

    Destructor for mapping property sheet.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CMappingPropertySheet::InitPages(CMapping* pMapping)

/*++

Routine Description:

    Initializes property pages.

Arguments:

    pMapping - mapping object.

Return Values:

    None.

--*/

{
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    AddPage(&m_settingsPage);
    m_settingsPage.InitPage(pMapping, &m_fUpdateHint);
}


void CMappingPropertySheet::OnHelp()

/*++

Routine Description:

    Help button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CPropertySheet::OnCommandHelp(0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mapppgs.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mapppgs.cpp

Abstract:

    Mapping property page (settings) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "mapppgs.h"
#include "ausrdlg.h"
#include "mainfrm.h"

static LV_COLUMN_INFO g_userColumnInfo = {0, 0, 1, {0, 0, 0, -1}};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMappingPropertyPageSettings, CPropertyPage)

BEGIN_MESSAGE_MAP(CMappingPropertyPageSettings, CPropertyPage)
    //{{AFX_MSG_MAP(CMappingPropertyPageSettings)
    ON_BN_CLICKED(IDC_PP_MAPPING_SETTINGS_ADD, OnAdd)
    ON_BN_CLICKED(IDC_PP_MAPPING_SETTINGS_DELETE, OnDelete)
    ON_NOTIFY(UDN_DELTAPOS, IDC_PP_MAPPING_SETTINGS_SPIN, OnDeltaPosSpin)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_MAPPING_SETTINGS_USERS, OnGetDispInfoUsers)
    ON_EN_UPDATE(IDC_PP_MAPPING_SETTINGS_LICENSES, OnUpdateQuantity)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CMappingPropertyPageSettings::CMappingPropertyPageSettings()
    : CPropertyPage(CMappingPropertyPageSettings::IDD)

/*++

Routine Description:

    Constructor for mapping property page (settings).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CMappingPropertyPageSettings)
    m_strDescription = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    m_strName = _T("");
    //}}AFX_DATA_INIT

    m_pMapping = NULL;
    m_pUpdateHint = NULL;
    m_bAreCtrlsInitialized = FALSE;
}


CMappingPropertyPageSettings::~CMappingPropertyPageSettings()

/*++

Routine Description:

    Destructor for mapping property page (settings).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


void CMappingPropertyPageSettings::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMappingPropertyPageSettings)
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_DESCRIPTION, m_desEdit);
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_LICENSES, m_licEdit);
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_ADD, m_addBtn);
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_PP_MAPPING_SETTINGS_USERS, m_userList);
    DDX_Text(pDX, IDC_PP_MAPPING_SETTINGS_DESCRIPTION, m_strDescription);
    DDX_Text(pDX, IDC_PP_MAPPING_SETTINGS_LICENSES, m_nLicenses);
    DDV_MinMaxDWord(pDX, m_nLicenses, m_nLicensesMin, 999999);
    DDX_Text(pDX, IDC_PP_MAPPING_SETTINGS_NAME, m_strName);
    //}}AFX_DATA_MAP
}


void CMappingPropertyPageSettings::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_strName = m_pMapping->m_strName;
    m_strDescription = m_pMapping->m_strDescription;
    m_nLicenses = m_pMapping->GetInUse();

    UpdateData(FALSE); // upload;

    m_delBtn.EnableWindow(FALSE);

    m_spinCtrl.SetRange(0, UD_MAXVAL);

    m_licEdit.LimitText(6);
    m_desEdit.LimitText(256);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_userList, &g_userColumnInfo);
}


void CMappingPropertyPageSettings::InitPage(CMapping* pMapping, DWORD* pUpdateHint)

/*++

Routine Description:

    Initializes property page.

Arguments:

    pMapping - mapping object.
    pUpdateHint - update hints.

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pMapping, CMapping);

    m_pMapping = pMapping;
    m_pUpdateHint = pUpdateHint;
}


void CMappingPropertyPageSettings::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortPage(); // bail...
    }
}


void CMappingPropertyPageSettings::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL);
}


BOOL CMappingPropertyPageSettings::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set to control manually.

--*/

{
    CPropertyPage::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


void CMappingPropertyPageSettings::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_userList); // release now...

    while (!m_deleteList.IsEmpty())
    {
        CUser* pUserDel = (CUser*)m_deleteList.RemoveHead();
        VALIDATE_OBJECT(pUserDel, CUser);

        pUserDel->InternalRelease(); // release now...
    }

    CPropertyPage::OnDestroy();
}


BOOL CMappingPropertyPageSettings::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;

    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (IsGroupInfoUpdated(*m_pUpdateHint) && !RefreshCtrls())
        {
            AbortPageIfNecessary(); // display error...
        }
    }

    return bIsActivated;

}


void CMappingPropertyPageSettings::OnAdd()

/*++

Routine Description:

    Adds users to list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CObList newUserList;

    CAddUsersDialog addDlg;
    addDlg.InitDialog(&newUserList);

    if (addDlg.DoModal() == IDOK)
    {
        int nUsers = m_userList.GetItemCount();

        while (!newUserList.IsEmpty())
        {
            CUser* pUser = (CUser*)newUserList.RemoveHead();
            VALIDATE_OBJECT(pUser, CUser);

            LV_FINDINFO lvFindInfo;

            lvFindInfo.flags = LVFI_STRING;
            lvFindInfo.psz   = MKSTR(pUser->m_strName);

            if (m_userList.FindItem(&lvFindInfo, -1) == -1)
            {
                //
                // Check if already deleted once
                //

                CUser* pUserDel;

                POSITION curPos;
                POSITION nextPos;

                nextPos = m_deleteList.GetHeadPosition();

                while (curPos = nextPos)
                {
                    pUserDel = (CUser*)m_deleteList.GetNext(nextPos);
                    VALIDATE_OBJECT(pUserDel, CUser);

                    if (!pUserDel->m_strName.CompareNoCase(pUser->m_strName))
                    {
                        m_deleteList.RemoveAt(curPos);

                        pUser->InternalRelease(); // release new...
                        pUser = pUserDel; // replace with old...
                        break;
                    }
                }

                LV_ITEM lvItem;

                lvItem.mask = LVIF_TEXT|
                              LVIF_PARAM|
                              LVIF_IMAGE;

                lvItem.iItem    = nUsers++; // append...
                lvItem.iSubItem = 0;

                lvItem.pszText    = LPSTR_TEXTCALLBACK;
                lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
                lvItem.iImage     = I_IMAGECALLBACK;

                lvItem.lParam = (LPARAM)(LPVOID)pUser;

                m_userList.InsertItem(&lvItem);
            }
            else
            {
                pUser->InternalRelease();   // allocated in add user dialog...
            }
        }

        VERIFY(m_userList.SortItems(CompareUsersInMapping, 0)); // use column info...

        ::LvSelObjIfNecessary(&m_userList, TRUE); // ensure selection...

        PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    }
}


void CMappingPropertyPageSettings::OnDelete()

/*++

Routine Description:

    Removes users from list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser*    pUser;
    CMapping* pMapping;
    int iItem = -1;

    while (pUser = (CUser*)::LvGetNextObj(&m_userList, &iItem))
    {
        VALIDATE_OBJECT(pUser, CUser);

        //
        // Only cache users with this mapping as a parent
        //

        if (pMapping = (CMapping*)MKOBJ(pUser->GetParent()))
        {
            ASSERT(m_pMapping == pMapping);
            pMapping->InternalRelease();    // just checking...

            m_deleteList.AddTail(pUser);
        }
        else
        {
            pUser->InternalRelease(); // release now...
        }

        VERIFY(m_userList.DeleteItem(iItem));
        iItem = -1;
    }

    ::LvSelObjIfNecessary(&m_userList, TRUE); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
}


BOOL CMappingPropertyPageSettings::RefreshCtrls()

/*++

Routine Description:

    Refreshs dialog controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    VALIDATE_OBJECT(m_pMapping, CMapping);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor(); // hourglass...

    CUsers* pUsers = (CUsers*)MKOBJ(m_pMapping->GetUsers(va));

    if (pUsers)
    {
        VALIDATE_OBJECT(pUsers, CUsers);

        bIsRefreshed = ::LvRefreshObArray(
                            &m_userList,
                            &g_userColumnInfo,
                            pUsers->m_pObArray
                            );

        pUsers->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_userList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


BOOL CMappingPropertyPageSettings::OnKillActive()

/*++

Routine Description:

    Processes property page.

Arguments:

    None.

Return Values:

    Returns true if processed successfully.

--*/

{
    if (!IsQuantityValid())
        return FALSE;

    NTSTATUS NtStatus = STATUS_SUCCESS;

    LLS_GROUP_INFO_1 MappingInfo1;

    //
    // Update information if necessary....
    //

    BeginWaitCursor(); // hourglass...

    if ((m_nLicenses != m_pMapping->GetInUse()) ||
        lstrcmp(MKSTR(m_strDescription), MKSTR(m_pMapping->m_strDescription)))
    {
        MappingInfo1.Name     = MKSTR(m_strName);
        MappingInfo1.Comment  = MKSTR(m_strDescription);
        MappingInfo1.Licenses = m_nLicenses;

        NtStatus = ::LlsGroupInfoSet(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        1,
                        (LPBYTE)&MappingInfo1
                        );

        LlsSetLastStatus(NtStatus); // called api...

        *m_pUpdateHint |= NT_SUCCESS(NtStatus) ? UPDATE_GROUP_ALTERED : 0;
    }

    //
    // Delete specified users
    //

    while (NT_SUCCESS(NtStatus) && !m_deleteList.IsEmpty())
    {
        CUser* pUserDel = (CUser*)m_deleteList.RemoveHead();
        VALIDATE_OBJECT(pUserDel, CUser);

        NtStatus = ::LlsGroupUserDelete(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        MKSTR(pUserDel->m_strName)
                        );

        pUserDel->InternalRelease(); // release now...

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
            NtStatus = STATUS_SUCCESS;

        LlsSetLastStatus(NtStatus); // called api...

        *m_pUpdateHint |= NT_SUCCESS(NtStatus) ? UPDATE_GROUP_ALTERED : 0;
    }

    CUser*    pUserAdd;
    CMapping* pMapping;
    int iItem = -1;

    while (NT_SUCCESS(NtStatus) &&
          (pUserAdd = (CUser*)::LvGetNextObj(&m_userList, &iItem, LVNI_ALL)))
    {
        VALIDATE_OBJECT(pUserAdd, CUser);

        //
        // Do not add users with this mapping as a parent
        //

        if (pMapping = (CMapping*)MKOBJ(pUserAdd->GetParent()))
        {
            ASSERT(m_pMapping == pMapping);
            pMapping->InternalRelease();    // just checking...
        }
        else
        {
            NtStatus = ::LlsGroupUserAdd(
                            LlsGetActiveHandle(),
                            MKSTR(m_strName),
                            MKSTR(pUserAdd->m_strName)
                            );

            LlsSetLastStatus(NtStatus); // called api...

            *m_pUpdateHint |= NT_SUCCESS(NtStatus) ? UPDATE_GROUP_ALTERED : 0;
        }
    }

    EndWaitCursor(); // hourglass...

    if (!NT_SUCCESS(NtStatus))
    {
        AbortPageIfNecessary(); // display error...
        return FALSE;
    }

    return TRUE;
}


BOOL CMappingPropertyPageSettings::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();

            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }

        ::SafeEnableWindow(
            &m_delBtn,
            &m_userList,
            CDialog::GetFocus(),
            m_userList.GetItemCount()
            );

        ::LvResizeColumns(&m_userList, &g_userColumnInfo);

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CMappingPropertyPageSettings::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;

    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);
    }
    else if (m_nLicenses > 999999)
    {
        m_nLicenses = 999999;

        ::MessageBeep(MB_OK);
    }

    UpdateData(FALSE);  // set data

    *pResult = 1;   // handle ourselves...
}


void CMappingPropertyPageSettings::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long nLicensesOld = m_nLicenses;

    if (!IsQuantityValid())
    {
        m_nLicenses = nLicensesOld;

        UpdateData(FALSE);

        m_licEdit.SetFocus();
        m_licEdit.SetSel(0,-1);

        ::MessageBeep(MB_OK);
    }
}


BOOL CMappingPropertyPageSettings::IsQuantityValid()

/*++

Routine Description:

    Wrapper around UpdateData(TRUE).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsValid;

    m_nLicensesMin = 1; // raise minimum...

    bIsValid = UpdateData(TRUE);

    m_nLicensesMin = 0; // reset minimum...

    return bIsValid;
}


void CMappingPropertyPageSettings::OnGetDispInfoUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);
    ASSERT(plvItem->iSubItem == 0);

    CUser* pUser = (CUser*)plvItem->lParam;
    VALIDATE_OBJECT(pUser, CUser);

    plvItem->iImage = BMPI_USER;
    lstrcpyn(plvItem->pszText, pUser->m_strName, plvItem->cchTextMax);

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\nlicdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nlicdlg.h

Abstract:

    New license dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NLICDLG_H_
#define _NLICDLG_H_

class CNewLicenseDialog : public CDialog
{
private:
    CProduct* m_pProduct;
    BOOL      m_bIsOnlyProduct;
    BOOL      m_bAreCtrlsInitialized;

#ifdef SUPPORT_UNLISTED_PRODUCTS
    int       m_iUnlisted;
#endif

public:
    DWORD     m_fUpdateHint;

public:
    CNewLicenseDialog(CWnd* pParent = NULL);   

    void InitDialog(CProduct* pProduct = NULL, BOOL bIsOnlyProduct = FALSE);
    void AbortDialogIfNecessary();
    void AbortDialog();

    void InitCtrls();
    BOOL RefreshCtrls();

    BOOL IsQuantityValid();

    //{{AFX_DATA(CNewLicenseDialog)
    enum { IDD = IDD_NEW_LICENSE };
    CEdit m_comEdit;
    CEdit m_licEdit;
    CSpinButtonCtrl m_spinCtrl;
    CComboBox m_productList;
    CString m_strComment;
    long m_nLicenses;
    long m_nLicensesMin;
    CString m_strProduct;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CNewLicenseDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CNewLicenseDialog)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _NLICDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\mappsht.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    mappsht.h

Abstract:

    Mapping property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _MAPPSHT_H_
#define _MAPPSHT_H_

#include "mapppgs.h"

class CMappingPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CMappingPropertySheet)
private:
    CMappingPropertyPageSettings m_settingsPage;

public:
    DWORD m_fUpdateHint;

public:
    CMappingPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CMappingPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    virtual ~CMappingPropertySheet();

    void InitPages(CMapping* pMapping);    

    //{{AFX_VIRTUAL(CMappingPropertySheet)
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CMappingPropertySheet)
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _MAPPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\nmapdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nmapdlg.cpp

Abstract:

    New mapping dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NMAPDLG_H_
#define _NMAPDLG_H_

class CNewMappingDialog : public CDialog
{
private:
    BOOL m_bAreCtrlsInitialized;

public:
    DWORD m_fUpdateHint;

public:
    CNewMappingDialog(CWnd* pParent = NULL);   

    void AbortDialogIfNecessary();
    void AbortDialog();

    void InitCtrls();    

    BOOL IsQuantityValid();

    //{{AFX_DATA(CNewMappingDialog)
    enum { IDD = IDD_NEW_MAPPING };
    CEdit m_desEdit;
    CButton m_addBtn;
    CButton m_delBtn;
    CSpinButtonCtrl m_spinCtrl;
    CListCtrl m_userList;
    CEdit m_userEdit;
    CEdit m_licEdit;
    CString m_strDescription;
    CString m_strName;
    long m_nLicenses;
    long m_nLicensesMin;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CNewMappingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CNewMappingDialog)
    afx_msg void OnAdd();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDelete();
    afx_msg void OnSetFocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareUsersInMapping(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _NMAPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\nlicdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nlicdlg.cpp

Abstract:

    New license dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "nlicdlg.h"
#include "mainfrm.h"
#include "pseatdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CNewLicenseDialog, CDialog)
    //{{AFX_MSG_MAP(CNewLicenseDialog)
    ON_NOTIFY(UDN_DELTAPOS, IDC_NEW_LICENSE_SPIN, OnDeltaPosSpin)
    ON_EN_UPDATE(IDC_NEW_LICENSE_QUANTITY, OnUpdateQuantity)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CNewLicenseDialog::CNewLicenseDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CNewLicenseDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CNewLicenseDialog)
    m_strComment = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    m_strProduct = _T("");
    //}}AFX_DATA_INIT

    m_pProduct = NULL;
    m_bIsOnlyProduct = FALSE;
    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CNewLicenseDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewLicenseDialog)
    DDX_Control(pDX, IDC_NEW_LICENSE_COMMENT, m_comEdit);
    DDX_Control(pDX, IDC_NEW_LICENSE_QUANTITY, m_licEdit);
    DDX_Control(pDX, IDC_NEW_LICENSE_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_NEW_LICENSE_PRODUCT, m_productList);
    DDX_Text(pDX, IDC_NEW_LICENSE_COMMENT, m_strComment);
    DDX_Text(pDX, IDC_NEW_LICENSE_QUANTITY, m_nLicenses);
    DDV_MinMaxLong(pDX, m_nLicenses, m_nLicensesMin, 999999);
    DDX_CBString(pDX, IDC_NEW_LICENSE_PRODUCT, m_strProduct);
    //}}AFX_DATA_MAP
}


void CNewLicenseDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_licEdit.SetFocus();
    m_licEdit.SetSel(0,-1);
    m_licEdit.LimitText(6);
    
    m_comEdit.LimitText(256);

    m_spinCtrl.SetRange(0, UD_MAXVAL);

    m_bAreCtrlsInitialized = TRUE;
}


void CNewLicenseDialog::InitDialog(CProduct* pProduct, BOOL bIsOnlyProduct)

/*++

Routine Description:

    Initializes dialog.

Arguments:

    pProduct - product object.
    bIsSingleProduct - true if only this product listed.

Return Values:

    None.

--*/

{
    m_pProduct = pProduct;
    m_bIsOnlyProduct = bIsOnlyProduct;

#ifdef SUPPORT_UNLISTED_PRODUCTS
    m_iUnlisted = CB_ERR;
#endif 
}


void CNewLicenseDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortDialog(); // bail...
    }
}


void CNewLicenseDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_ABORT;
    EndDialog(IDABORT); 
}


BOOL CNewLicenseDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();
    
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CNewLicenseDialog::OnOK() 

/*++

Routine Description:

    Creates a new license for product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!IsQuantityValid())
        return;

    if (m_strProduct.IsEmpty())
        return;

#ifdef SUPPORT_UNLISTED_PRODUCTS
    if (m_productList.GetCurSel() == m_iUnlisted)
    {
        //
        // CODEWORK...
        //

        return; 
    }
#endif

    CPerSeatLicensingDialog psLicDlg;
    psLicDlg.m_strProduct = m_strProduct;

    if (psLicDlg.DoModal() != IDOK)
        return;

    BeginWaitCursor(); // hourglass...

    NTSTATUS NtStatus;
    LLS_LICENSE_INFO_0 LicenseInfo0;

    TCHAR szUserBuffer[256];
    DWORD dwUserBuffer = sizeof(szUserBuffer);
    
    if (::GetUserName(szUserBuffer, &dwUserBuffer))
    {
        LicenseInfo0.Product  = MKSTR(m_strProduct);
        LicenseInfo0.Quantity = m_nLicenses;
        LicenseInfo0.Date     = 0;  // ignored...
        LicenseInfo0.Admin    = szUserBuffer;
        LicenseInfo0.Comment  = MKSTR(m_strComment);

        NtStatus = ::LlsLicenseAdd(
                        LlsGetActiveHandle(),
                        0,
                        (LPBYTE)&LicenseInfo0
                        );

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))                             
        {                                                     
            m_fUpdateHint = UPDATE_LICENSE_ADDED;
            EndDialog(IDOK);
        }                                                     
        else
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
    else
    {
        LlsSetLastStatus(::GetLastError());
        AbortDialogIfNecessary(); // display error...
    }

    EndWaitCursor(); // hourglass...
}


BOOL CNewLicenseDialog::RefreshCtrls()

/*++

Routine Description:

    Refreshs list of products available.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    int iProductInCB = CB_ERR;

    BeginWaitCursor(); // hourglass...

    if (m_bIsOnlyProduct)
    {
        VALIDATE_OBJECT(m_pProduct, CProduct);
        iProductInCB = m_productList.AddString(m_pProduct->m_strName);
    }
    else
    {
        CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
        pController->InternalRelease(); // held open by application...

        VALIDATE_OBJECT(pController, CController);
        VALIDATE_OBJECT(pController->m_pProducts, CProducts);    
    
        CObArray* pObArray = pController->m_pProducts->m_pObArray;
        VALIDATE_OBJECT(pObArray, CObArray);

        int iProduct = 0;
        int nProducts = pObArray->GetSize();

        CProduct* pProduct;

        while (nProducts--)
        {
            pProduct = (CProduct*)pObArray->GetAt(iProduct++);
            VALIDATE_OBJECT(pProduct, CProduct);

            if (m_productList.AddString(pProduct->m_strName) == CB_ERR)
            {
                LlsSetLastStatus(STATUS_NO_MEMORY);
                return FALSE; // bail...
            }
        }

        if (m_pProduct)
        {
            VALIDATE_OBJECT(m_pProduct, CProduct);

            iProductInCB = m_productList.FindStringExact(-1, m_pProduct->m_strName);
            ASSERT(iProductInCB != CB_ERR);
        }

#ifdef SUPPORT_UNLISTED_PRODUCTS
        CString strUnlisted;
        strUnlisted.LoadString(IDS_UNLISTED_PRODUCT);
        m_iUnlisted = m_productList.AddString(strUnlisted);
#endif
    }

    m_productList.SetCurSel((iProductInCB == CB_ERR) ? 0 : iProductInCB);

    EndWaitCursor(); // hourglass...

    return TRUE;
}


BOOL CNewLicenseDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
         
            if (!RefreshCtrls())
            {
                AbortDialogIfNecessary(); // display error...
            }
        }
        
        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CNewLicenseDialog::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;
    
    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);      
    }
    else if (m_nLicenses > 999999)
    {
        m_nLicenses = 999999;

        ::MessageBeep(MB_OK);      
    }

    UpdateData(FALSE);  // set data

    *pResult = 1;   // handle ourselves...
}


void CNewLicenseDialog::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long nLicensesOld = m_nLicenses;

    if (!IsQuantityValid())
    {
        m_nLicenses = nLicensesOld;

        UpdateData(FALSE);

        m_licEdit.SetFocus();
        m_licEdit.SetSel(0,-1);

        ::MessageBeep(MB_OK);      
    }
}


BOOL CNewLicenseDialog::IsQuantityValid()

/*++

Routine Description:

    Wrapper around UpdateData(TRUE).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsValid;

    m_nLicensesMin = 1; // raise minimum...

    bIsValid = UpdateData(TRUE);

    m_nLicensesMin = 0; // reset minimum...

    return bIsValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\nmapdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nmapdlg.cpp

Abstract:

    New mapping dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "nmapdlg.h"
#include "ausrdlg.h"
#include "mainfrm.h"

static LV_COLUMN_INFO g_userColumnInfo = {0, 0, 1, {0, 0, 0, -1}};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CNewMappingDialog, CDialog)
    //{{AFX_MSG_MAP(CNewMappingDialog)
    ON_BN_CLICKED(IDC_NEW_MAPPING_ADD, OnAdd)
    ON_BN_CLICKED(IDC_NEW_MAPPING_DELETE, OnDelete)
    ON_NOTIFY(NM_SETFOCUS, IDC_NEW_MAPPING_USERS, OnSetFocusUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_NEW_MAPPING_USERS, OnKillFocusUsers)
    ON_NOTIFY(UDN_DELTAPOS, IDC_NEW_MAPPING_SPIN, OnDeltaPosSpin)
    ON_EN_UPDATE(IDC_NEW_MAPPING_LICENSES, OnUpdateQuantity)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CNewMappingDialog::CNewMappingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CNewMappingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CNewMappingDialog)
    m_strDescription = _T("");
    m_strName = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    //}}AFX_DATA_INIT

    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CNewMappingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewMappingDialog)
    DDX_Control(pDX, IDC_NEW_MAPPING_DESCRIPTION, m_desEdit);
    DDX_Control(pDX, IDC_NEW_MAPPING_ADD, m_addBtn);
    DDX_Control(pDX, IDC_NEW_MAPPING_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_NEW_MAPPING_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_NEW_MAPPING_USERS, m_userList);
    DDX_Control(pDX, IDC_NEW_MAPPING_NAME, m_userEdit);
    DDX_Control(pDX, IDC_NEW_MAPPING_LICENSES, m_licEdit);
    DDX_Text(pDX, IDC_NEW_MAPPING_DESCRIPTION, m_strDescription);
    DDX_Text(pDX, IDC_NEW_MAPPING_NAME, m_strName);
    DDX_Text(pDX, IDC_NEW_MAPPING_LICENSES, m_nLicenses);
    DDV_MinMaxLong(pDX, m_nLicenses, m_nLicensesMin, 999999);
    //}}AFX_DATA_MAP
}


void CNewMappingDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_userEdit.SetFocus();

    m_delBtn.EnableWindow(FALSE);

    m_spinCtrl.SetRange(0, UD_MAXVAL);

    m_licEdit.LimitText(6);
    m_desEdit.LimitText(256);
    m_userEdit.LimitText(256);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_userList, &g_userColumnInfo);
}


void CNewMappingDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortDialog(); // bail...
    }
}


void CNewMappingDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_ABORT;
    EndDialog(IDABORT);
}


BOOL CNewMappingDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set to control manually.

--*/

{
    CDialog::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


void CNewMappingDialog::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_userList); // release now...
    CDialog::OnDestroy();
}


BOOL CNewMappingDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();
        }

        ::SafeEnableWindow(
            &m_delBtn,
            &m_addBtn,
            CDialog::GetFocus(),
            m_userList.GetItemCount()
            );

        ::LvResizeColumns(&m_userList, &g_userColumnInfo);

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CNewMappingDialog::OnAdd()

/*++

Routine Description:

    Adds new users to mapping.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CObList newUserList;

    CAddUsersDialog addDlg;
    addDlg.InitDialog(&newUserList);

    if (addDlg.DoModal() == IDOK)
    {
        int nUsers = m_userList.GetItemCount();

        while (!newUserList.IsEmpty())
        {
            CUser* pUser = (CUser*)newUserList.RemoveHead();
            VALIDATE_OBJECT(pUser, CUser);

            LV_FINDINFO lvFindInfo;

            lvFindInfo.flags = LVFI_STRING;
            lvFindInfo.psz   = MKSTR(pUser->m_strName);

            if (m_userList.FindItem(&lvFindInfo, -1) == -1)
            {
                LV_ITEM lvItem;

                lvItem.mask = LVIF_TEXT|
                              LVIF_PARAM|
                              LVIF_IMAGE;

                lvItem.iItem = nUsers++; // append...
                lvItem.iSubItem = 0;

                lvItem.lParam = (LPARAM)(LPVOID)pUser;

                lvItem.iImage  = BMPI_USER;
                lvItem.pszText = MKSTR(pUser->m_strName);

                m_userList.InsertItem(&lvItem);
            }
            else
            {
                pUser->InternalRelease();   // allocated in add user dialog...
            }
        }

        VERIFY(m_userList.SortItems(CompareUsersInMapping, 0)); // use column info...

        ::LvSelObjIfNecessary(&m_userList, TRUE); // ensure selection...

        PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    }
}


void CNewMappingDialog::OnDelete()

/*++

Routine Description:

    Deletes users from list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseSelObjs(&m_userList);
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
}


void CNewMappingDialog::OnOK()

/*++

Routine Description:

    Message handler for IDOK.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!IsQuantityValid())
        return;

    if (!m_strName.IsEmpty() && m_userList.GetItemCount())
    {
        CUser* pUser;
        NTSTATUS NtStatus;
        LLS_GROUP_INFO_1 MappingInfo1;

        BeginWaitCursor(); // hourglass...

        MappingInfo1.Name     = MKSTR(m_strName);
        MappingInfo1.Comment  = MKSTR(m_strDescription);
        MappingInfo1.Licenses = m_nLicenses;

        NtStatus = ::LlsGroupAdd(
                        LlsGetActiveHandle(),
                        1,
                        (LPBYTE)&MappingInfo1
                        );

        int iItem = -1;

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))
        {
            m_fUpdateHint |= UPDATE_GROUP_ADDED;

            while (NT_SUCCESS(NtStatus) &&
              (pUser = (CUser*)::LvGetNextObj(&m_userList, &iItem, LVNI_ALL)))
            {
                VALIDATE_OBJECT(pUser, CUser);

                //
                // Add users one-by-one (blah!)
                //

                NtStatus = ::LlsGroupUserAdd(
                                LlsGetActiveHandle(),
                                MKSTR(m_strName),
                                MKSTR(pUser->m_strName)
                                );

                LlsSetLastStatus(NtStatus); // called api...
            }
        }

        if (NT_SUCCESS(NtStatus))
        {
            EndDialog(IDOK);
        }
        else
        {
            AbortDialogIfNecessary(); // display error...
        }

        EndWaitCursor(); // hourglass...
    }
    else
    {
        AfxMessageBox(IDP_ERROR_INVALID_MAPPING);
    }
}


void CNewMappingDialog::OnSetFocusUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CNewMappingDialog::OnKillFocusUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_userList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CNewMappingDialog::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;

    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);
    }
    else if (m_nLicenses > 999999)
    {
        m_nLicenses = 999999;

        ::MessageBeep(MB_OK);
    }

    UpdateData(FALSE);  // set data

    *pResult = 1;   // handle ourselves...
}


void CNewMappingDialog::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long nLicensesOld = m_nLicenses;

    if (!IsQuantityValid())
    {
        m_nLicenses = nLicensesOld;

        UpdateData(FALSE);

        m_licEdit.SetFocus();
        m_licEdit.SetSel(0,-1);

        ::MessageBeep(MB_OK);
    }
}


BOOL CNewMappingDialog::IsQuantityValid()

/*++

Routine Description:

    Wrapper around UpdateData(TRUE).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsValid;

    m_nLicensesMin = 1; // raise minimum...

    bIsValid = UpdateData(TRUE);

    m_nLicensesMin = 0; // reset minimum...

    return bIsValid;
}


int CALLBACK CompareUsersInMapping(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pUser1 ((CUser*)lParam1)
#define pUser2 ((CUser*)lParam2)

    VALIDATE_OBJECT(pUser1, CUser);
    VALIDATE_OBJECT(pUser2, CUser);

    ASSERT(g_userColumnInfo.nSortedItem == 0);
    ASSERT(g_userColumnInfo.bSortOrder == FALSE);

    return pUser1->m_strName.CompareNoCase(pUser2->m_strName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdcol.cpp

Abstract:

    Product collection object implementation.

Author:

    Don Ryan (donryan) 11-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProducts, CCmdTarget)

BEGIN_MESSAGE_MAP(CProducts, CCmdTarget)
    //{{AFX_MSG_MAP(CProducts)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CProducts, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CProducts)
    DISP_PROPERTY_EX(CProducts, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CProducts, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CProducts, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CProducts, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CProducts::CProducts(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for product collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CController)));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}

CProducts::~CProducts()

/*++

Routine Description:

    Destructor for product collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}

void CProducts::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CProducts::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CProducts::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CProducts::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified product object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the product name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CProduct* pProduct;
    INT_PTR   iProduct;

    VARIANT vProduct;
    VariantInit(&vProduct);

    if (iProduct = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iProduct--)
            {
                if (pProduct = (CProduct*)m_pObArray->GetAt(iProduct))
                {
                    ASSERT(pProduct->IsKindOf(RUNTIME_CLASS(CProduct)));

                    if (!pProduct->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pProduct->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vProduct, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vProduct.lVal >= 0) && ((int)vProduct.lVal < iProduct))
            {
                if (pProduct = (CProduct*)m_pObArray->GetAt((int)vProduct.lVal))
                {
                    ASSERT(pProduct->IsKindOf(RUNTIME_CLASS(CProduct)));
                    lpdispatch = pProduct->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CProducts::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdobj.cpp

Abstract:

    Product object implementation.

Author:

    Don Ryan (donryan) 11-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProduct, CCmdTarget)

BEGIN_MESSAGE_MAP(CProduct, CCmdTarget)
    //{{AFX_MSG_MAP(CProduct)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CProduct, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CProduct)
    DISP_PROPERTY_EX(CProduct, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CProduct, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CProduct, "InUse", GetInUse, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CProduct, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CProduct, "PerSeatLimit", GetPerSeatLimit, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CProduct, "PerServerLimit", GetPerServerLimit, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CProduct, "PerServerReached", GetPerServerReached, SetNotSupported, VT_I4)
    DISP_PROPERTY_PARAM(CProduct, "Licenses", GetLicenses, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CProduct, "Statistics", GetStatistics, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CProduct, "ServerStatistics", GetServerStatistics, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CProduct, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CProduct::CProduct(
    CCmdTarget* pParent,
    LPCTSTR     pName,
    long        lPurchased,
    long        lInUse,
    long        lConcurrent,
    long        lHighMark
)

/*++

Routine Description:

    Constructor for product object.

Arguments:

    pParent - creator of object.
    pName - name of product.
    lPurchased - number of licenses available.
    lInUse - number of licenses consumed.
    lConcurrent - number of concurrent licenses.
    lHighMark - high water mark for domain.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CController)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);

    m_strName = pName;

    m_lInUse      = lInUse;
    m_lLimit      = lPurchased;
    m_lConcurrent = lConcurrent;
    m_lHighMark   = lHighMark;

    m_pLicenses         = NULL;
    m_pStatistics       = NULL;
    m_pServerStatistics = NULL;

    m_licenseArray.RemoveAll();
    m_statisticArray.RemoveAll();
    m_serverstatisticArray.RemoveAll();

    m_bLicensesRefreshed         = FALSE;
    m_bStatisticsRefreshed       = FALSE;
    m_bServerStatisticsRefreshed = FALSE;
}


CProduct::~CProduct()

/*++

Routine Description:

    Destructor for product object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pLicenses)
        m_pLicenses->InternalRelease();

    if (m_pStatistics)
        m_pStatistics->InternalRelease();

    if (m_pServerStatistics)
        m_pServerStatistics->InternalRelease();
}


void CProduct::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetLicenses();
    ResetStatistics();
    ResetServerStatistics();
    delete this;
}


LPDISPATCH CProduct::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CProduct::GetInUse()

/*++

Routine Description:

    Returns the number of clients registered as using product.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lInUse;
}


LPDISPATCH CProduct::GetLicenses(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    license agreements recorded on the license controller
    pertaining to the product or returns an individual
    license agreement pertaining to the product described
    by an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pLicenses)
    {
        m_pLicenses = new CLicenses(this, &m_licenseArray);
    }

    if (m_pLicenses)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bLicensesRefreshed)
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
            else if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus( STATUS_NO_MEMORY );
    }

    return lpdispatch;
}


BSTR CProduct::GetName()

/*++

Routine Description:

    Returns the name of the server product.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CProduct::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


long CProduct::GetPerSeatLimit()

/*++

Routine Description:

    Returns number of per seat clients purchased.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lLimit;
}


long CProduct::GetPerServerLimit()

/*++

Routine Description:

    Returns number of per server clients purchased.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lConcurrent;
}


LPDISPATCH CProduct::GetStatistics(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    usage statistics recorded on the license controller
    pertaining to the product or returns an individual
    usage statistic pertaining to the product described
    by an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pStatistics)
    {
        m_pStatistics = new CStatistics(this, &m_statisticArray);
    }

    if (m_pStatistics)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshStatistics())
            {
                lpdispatch = m_pStatistics->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bStatisticsRefreshed)
            {
                lpdispatch = m_pStatistics->GetItem(index);
            }
            else if (RefreshStatistics())
            {
                lpdispatch = m_pStatistics->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus( STATUS_NO_MEMORY );
    }

    return lpdispatch;
}


LPDISPATCH CProduct::GetServerStatistics(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    usage statistics recorded on the license controller
    pertaining to the product or returns an individual
    server statistic pertaining to the product described
    by an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pServerStatistics)
    {
        m_pServerStatistics = new CServerStatistics(this, &m_serverstatisticArray);
    }

    if (m_pServerStatistics)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshServerStatistics())
            {
                lpdispatch = m_pServerStatistics->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bServerStatisticsRefreshed)
            {
                lpdispatch = m_pServerStatistics->GetItem(index);
            }
            else if (RefreshServerStatistics())
            {
                lpdispatch = m_pServerStatistics->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus( STATUS_NO_MEMORY );
    }

    return lpdispatch;
}


BOOL CProduct::RefreshLicenses()

/*++

Routine Description:

    Refreshs license object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetLicenses();

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iLicense = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsProductLicenseEnum(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        0,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CLicense*                   pLicense;
            PLLS_PRODUCT_LICENSE_INFO_0 pProductLicenseInfo0;

            pProductLicenseInfo0 = (PLLS_PRODUCT_LICENSE_INFO_0)ReturnBuffer;

            ASSERT(iLicense == m_licenseArray.GetSize());
            m_licenseArray.SetSize(m_licenseArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pLicense = new CLicense(
                                  this,
                                  m_strName,
                                  pProductLicenseInfo0->Admin,
                                  pProductLicenseInfo0->Date,
                                  pProductLicenseInfo0->Quantity,
                                  pProductLicenseInfo0->Comment
                                  );

                m_licenseArray.SetAt(iLicense++, pLicense); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pProductLicenseInfo0->Admin);
                ::LlsFreeMemory(pProductLicenseInfo0->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

                pProductLicenseInfo0++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }
    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bLicensesRefreshed = TRUE;
    }
    else
    {
        ResetLicenses();
    }

    return m_bLicensesRefreshed;
}


BOOL CProduct::RefreshStatistics()

/*++

Routine Description:

    Refreshs statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetStatistics();

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iStatistic = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsProductUserEnum(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CStatistic*              pStatistic;
            PLLS_PRODUCT_USER_INFO_1 pProductUserInfo1;

            pProductUserInfo1 = (PLLS_PRODUCT_USER_INFO_1)ReturnBuffer;

            ASSERT(iStatistic == m_statisticArray.GetSize());
            m_statisticArray.SetSize(m_statisticArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pStatistic = new CStatistic(
                                    this,
                                    pProductUserInfo1->User,
                                    pProductUserInfo1->Flags,
                                    pProductUserInfo1->LastUsed,
                                    pProductUserInfo1->UsageCount
                                    );

                m_statisticArray.SetAt(iStatistic++, pStatistic);   // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pProductUserInfo1->User);

#endif // DISABLE_PER_NODE_ALLOCATION

                pProductUserInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }
    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bStatisticsRefreshed = TRUE;
    }
    else
    {
        ResetStatistics();
    }

    return m_bStatisticsRefreshed;
}


BOOL CProduct::RefreshServerStatistics()

/*++

Routine Description:

    Refreshs server statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetServerStatistics();

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iStatistic = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsProductServerEnum(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CServerStatistic*          pStatistic;
            PLLS_SERVER_PRODUCT_INFO_1 pProductServerInfo1;

            pProductServerInfo1 = (PLLS_SERVER_PRODUCT_INFO_1)ReturnBuffer;

            ASSERT(iStatistic == m_serverstatisticArray.GetSize());
            m_serverstatisticArray.SetSize(m_serverstatisticArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pStatistic = new CServerStatistic(
                                    this,
                                    pProductServerInfo1->Name,
                                    pProductServerInfo1->Flags,
                                    pProductServerInfo1->MaxUses,
                                    pProductServerInfo1->HighMark
                                    );

                m_serverstatisticArray.SetAt(iStatistic++, pStatistic); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pProductServerInfo1->Name);

#endif // DISABLE_PER_NODE_ALLOCATION

                pProductServerInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }
    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bServerStatisticsRefreshed = TRUE;
    }
    else
    {
        ResetServerStatistics();
    }

    return m_bServerStatisticsRefreshed;
}


void CProduct::ResetLicenses()

/*++

Routine Description:

    Resets license object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CLicense* pLicense;
    INT_PTR   iLicense = m_licenseArray.GetSize();

    while (iLicense--)
    {
        if (pLicense = (CLicense*)m_licenseArray[iLicense])
        {
            ASSERT(pLicense->IsKindOf(RUNTIME_CLASS(CLicense)));
            pLicense->InternalRelease();
        }
    }

    m_licenseArray.RemoveAll();
    m_bLicensesRefreshed = FALSE;
}


void CProduct::ResetStatistics()

/*++

Routine Description:

    Resets statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic;
    INT_PTR     iStatistic = m_statisticArray.GetSize();

    while (iStatistic--)
    {
        if (pStatistic = (CStatistic*)m_statisticArray[iStatistic])
        {
            ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CStatistic)));
            pStatistic->InternalRelease();
        }
    }

    m_statisticArray.RemoveAll();
    m_bStatisticsRefreshed = FALSE;
}


void CProduct::ResetServerStatistics()

/*++

Routine Description:

    Resets statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CServerStatistic* pStatistic;
    INT_PTR           iStatistic = m_serverstatisticArray.GetSize();

    while (iStatistic--)
    {
        if (pStatistic = (CServerStatistic*)m_serverstatisticArray[iStatistic])
        {
            ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CServerStatistic)));
            pStatistic->InternalRelease();
        }
    }

    m_serverstatisticArray.RemoveAll();
    m_bServerStatisticsRefreshed = FALSE;
}


long CProduct::GetPerServerReached()
{
    return m_lHighMark;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdcol.h

Abstract:

    Product collection object implementation.

Author:

    Don Ryan (donryan) 11-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDCOL_H_
#define _PRDCOL_H_

class CProducts : public CCmdTarget
{
    DECLARE_DYNCREATE(CProducts)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CProducts(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CProducts();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProducts)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProducts)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CProducts)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PRDCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgl.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgl.h

Abstract:

    Product property page (licences) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDPPGL_H_
#define _PRDPPGL_H_

class CProductPropertyPageLicenses : public CPropertyPage
{
    DECLARE_DYNCREATE(CProductPropertyPageLicenses)
private:
    CProduct*  m_pProduct;
    DWORD*     m_pUpdateHint;
    BOOL       m_bAreCtrlsInitialized;

public:
    CProductPropertyPageLicenses();
    ~CProductPropertyPageLicenses();

    void InitPage(CProduct* pProduct, DWORD* pUpdateHint);
    void AbortPageIfNecessary();
    void AbortPage();

    void InitCtrls();
    BOOL RefreshCtrls();

    //{{AFX_DATA(CProductPropertyPageLicenses)
    enum { IDD = IDD_PP_PRODUCT_LICENSES };
    CButton m_newBtn;
    CButton m_delBtn;
    CListCtrl m_licenseList;
    long m_nLicensesTotal;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CProductPropertyPageLicenses)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CProductPropertyPageLicenses)
    virtual BOOL OnInitDialog();
    afx_msg void OnNew();
    afx_msg void OnColumnClickLicenses(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoLicenses(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDelete();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareProductLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _PRDPPGL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgs.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgs.cpp

Abstract:

    Product property page (servers) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDPPGS_H_
#define _PRDPPGS_H_

class CProductPropertyPageServers : public CPropertyPage
{
    DECLARE_DYNCREATE(CProductPropertyPageServers)
private:
    CProduct*          m_pProduct;
    DWORD*             m_pUpdateHint;
    BOOL               m_bAreCtrlsInitialized;

public:
    CProductPropertyPageServers();
    ~CProductPropertyPageServers();

    void InitPage(CProduct* pProduct, DWORD* pUpdateHint);
    void AbortPageIfNecessary();
    void AbortPage();

    void InitCtrls();
    BOOL RefreshCtrls();

    void ViewServerProperties();

    //{{AFX_DATA(CProductPropertyPageServers)
    enum { IDD = IDD_PP_PRODUCT_SERVERS };
    CButton m_editBtn;
    CListCtrl m_serverList;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CProductPropertyPageServers)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CProductPropertyPageServers)
    virtual BOOL OnInitDialog();
    afx_msg void OnEdit();
    afx_msg void OnDblClkServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareProductServers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _PRDPPGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgs.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgs.cpp

Abstract:

    Product property page (servers) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
       o  Added refresh when service info is updated.
       o  Added new element to LV_COLUMN_ENTRY to differentiate the string
          used for the column header from the string used in the menus
          (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "prdppgs.h"
#include "srvpsht.h"

#define LVID_SERVER         0
#define LVID_PURCHASED      1
#define LVID_REACHED        2

#define LVCX_SERVER         40
#define LVCX_PURCHASED      30
#define LVCX_REACHED        -1

static LV_COLUMN_INFO g_serverColumnInfo = {

    0, 0, 3,
    {{LVID_SERVER,    IDS_SERVER_NAME, 0, LVCX_SERVER   },
     {LVID_PURCHASED, IDS_PURCHASED,   0, LVCX_PURCHASED},
     {LVID_REACHED,   IDS_REACHED,     0, LVCX_REACHED  }},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProductPropertyPageServers, CPropertyPage)

BEGIN_MESSAGE_MAP(CProductPropertyPageServers, CPropertyPage)
    //{{AFX_MSG_MAP(CProductPropertyPageServers)
    ON_BN_CLICKED(IDC_PP_PRODUCT_SERVERS_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_PRODUCT_SERVERS_SERVERS, OnDblClkServers)
    ON_NOTIFY(NM_RETURN, IDC_PP_PRODUCT_SERVERS_SERVERS, OnReturnServers)
    ON_NOTIFY(NM_SETFOCUS,  IDC_PP_PRODUCT_SERVERS_SERVERS, OnSetFocusServers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_PP_PRODUCT_SERVERS_SERVERS, OnKillFocusServers)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_PRODUCT_SERVERS_SERVERS, OnColumnClickServers)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_PRODUCT_SERVERS_SERVERS, OnGetDispInfoServers)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CProductPropertyPageServers::CProductPropertyPageServers()
    : CPropertyPage(CProductPropertyPageServers::IDD)

/*++

Routine Description:

    Constructor for product property page (servers).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CProductPropertyPageServers)
    //}}AFX_DATA_INIT

    m_pProduct    = NULL;
    m_pUpdateHint = NULL;
    m_bAreCtrlsInitialized = FALSE;
}

CProductPropertyPageServers::~CProductPropertyPageServers()

/*++

Routine Description:

    Destructor for product property page (servers).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}

void CProductPropertyPageServers::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProductPropertyPageServers)
    DDX_Control(pDX, IDC_PP_PRODUCT_SERVERS_EDIT, m_editBtn);
    DDX_Control(pDX, IDC_PP_PRODUCT_SERVERS_SERVERS, m_serverList);
    //}}AFX_DATA_MAP
}


void CProductPropertyPageServers::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_serverList.SetFocus();
    m_editBtn.EnableWindow(FALSE);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_serverList, &g_serverColumnInfo);
}


void CProductPropertyPageServers::InitPage(CProduct* pProduct, DWORD* pUpdateHint)

/*++

Routine Description:

    Initializes property page.

Arguments:

    pProduct - product object.
    pUpdateHint - update hint.

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pProduct, CProduct);

    m_pProduct = pProduct;
    m_pUpdateHint = pUpdateHint;
}


void CProductPropertyPageServers::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortPage(); // bail...
    }
}


void CProductPropertyPageServers::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL);
}


void CProductPropertyPageServers::OnEdit()

/*++

Routine Description:

    View properties of server.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ViewServerProperties();
}


BOOL CProductPropertyPageServers::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set to control manually.

--*/

{
    CPropertyPage::OnInitDialog();

    SendMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


void CProductPropertyPageServers::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_serverList); // release now...
    CPropertyPage::OnDestroy();
}


BOOL CProductPropertyPageServers::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;

    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (    (    IsServerInfoUpdated(  *m_pUpdateHint )
                  || IsServiceInfoUpdated( *m_pUpdateHint ) )
             && !RefreshCtrls()                               )
        {
            AbortPageIfNecessary(); // display error...
        }
    }

    return bIsActivated;

}


BOOL CProductPropertyPageServers::RefreshCtrls()

/*++

Routine Description:

    Refreshs property page controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    VALIDATE_OBJECT(m_pProduct, CProduct);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor(); // hourglass...

    CServerStatistics* pStatistics = (CServerStatistics*)MKOBJ(m_pProduct->GetServerStatistics(va));

    if (pStatistics)
    {
        VALIDATE_OBJECT(pStatistics, CServerStatistics);

        bIsRefreshed = ::LvRefreshObArray(
                            &m_serverList,
                            &g_serverColumnInfo,
                            pStatistics->m_pObArray
                            );

        pStatistics->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_serverList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


void CProductPropertyPageServers::ViewServerProperties()

/*++

Routine Description:

    View properties of server.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CServerStatistic* pStatistic;

    if (pStatistic = (CServerStatistic*)::LvGetSelObj(&m_serverList))
    {
        VALIDATE_OBJECT(pStatistic, CServerStatistic);

        CServer* pServer = new CServer(NULL, pStatistic->m_strEntry);

        if (pServer)
        {
            CString strTitle;
            AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pServer->m_strName);

            CServerPropertySheet serverProperties(strTitle);
            serverProperties.InitPages(pServer);
            serverProperties.DoModal();

            *m_pUpdateHint |= serverProperties.m_fUpdateHint;

            if (IsUpdateAborted(serverProperties.m_fUpdateHint))
            {
                AbortPage(); // don't display error...
            }
            else if (    (    IsServerInfoUpdated(  serverProperties.m_fUpdateHint )
                           || IsServiceInfoUpdated( serverProperties.m_fUpdateHint ) )
                      && !RefreshCtrls()                                               )
            {
                AbortPageIfNecessary(); // display error...
            }
        }
        else
        {
            AbortPageIfNecessary(); // display error...
        }

        if (pServer)
            pServer->InternalRelease();    // delete object...
    }
}


BOOL CProductPropertyPageServers::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();

            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }

        ::SafeEnableWindow(
            &m_editBtn,
            &m_serverList,
            CDialog::GetFocus(),
            m_serverList.GetItemCount()
            );

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CProductPropertyPageServers::OnDblClkServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewServerProperties();
    *pResult = 0;
}


void CProductPropertyPageServers::OnReturnServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewServerProperties();
    *pResult = 0;
}


void CProductPropertyPageServers::OnSetFocusServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CProductPropertyPageServers::OnKillFocusServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_serverList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CProductPropertyPageServers::OnColumnClickServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_serverColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_serverColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_serverList.SortItems(CompareProductServers, 0); // use column info

    *pResult = 0;
}


void CProductPropertyPageServers::OnGetDispInfoServers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CServerStatistic* pStatistic = (CServerStatistic*)plvItem->lParam;
    VALIDATE_OBJECT(pStatistic, CServerStatistic);

    switch (plvItem->iSubItem)
    {
    case LVID_SERVER:
    {
        if (pStatistic->m_bIsPerServer)
        {
            if ((pStatistic->GetMaxUses() <= pStatistic->GetHighMark()) && pStatistic->GetMaxUses())
            {
                plvItem->iImage = BMPI_WARNING_AT_LIMIT;
            }
            else
            {
                plvItem->iImage = BMPI_PRODUCT_PER_SERVER;
            }
        }
        else
        {
            plvItem->iImage = BMPI_PRODUCT_PER_SEAT;
        }

        lstrcpyn(plvItem->pszText, pStatistic->m_strEntry, plvItem->cchTextMax);
    }
        break;

    case LVID_PURCHASED:
    {
        CString strLabel;

        if (pStatistic->m_bIsPerServer)
        {
            strLabel.Format(_T("%ld"), pStatistic->GetMaxUses());
        }
        else
        {
            strLabel.LoadString(IDS_NOT_APPLICABLE);
        }

        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_REACHED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pStatistic->GetHighMark());
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareProductServers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pStatistic1 ((CServerStatistic*)lParam1)
#define pStatistic2 ((CServerStatistic*)lParam2)

    VALIDATE_OBJECT(pStatistic1, CServerStatistic);
    VALIDATE_OBJECT(pStatistic2, CServerStatistic);

    int iResult;

    switch (g_serverColumnInfo.nSortedItem)
    {
    case LVID_SERVER:
        iResult = pStatistic1->m_strEntry.CompareNoCase(pStatistic2->m_strEntry);
        break;

    case LVID_PURCHASED:
        iResult = pStatistic1->GetMaxUses() - pStatistic2->GetMaxUses();
        break;

    case LVID_REACHED:
        iResult = pStatistic1->GetHighMark() - pStatistic2->GetHighMark();
        break;

    default:
        iResult = 0;
        break;
    }

    return g_serverColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdobj.h

Abstract:

    Product object implementation.

Author:

    Don Ryan (donryan) 11-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDOBJ_H_
#define _PRDOBJ_H_

class CProduct : public CCmdTarget
{
    DECLARE_DYNCREATE(CProduct)
private:
    CCmdTarget*        m_pParent;      
    CObArray           m_licenseArray;  
    CObArray           m_statisticArray;
    CObArray           m_serverstatisticArray;
    BOOL               m_bLicensesRefreshed;
    BOOL               m_bStatisticsRefreshed;   
    BOOL               m_bServerStatisticsRefreshed;   

public:
    CString            m_strName;
    long               m_lInUse;
    long               m_lLimit;
    long               m_lConcurrent;
    long               m_lHighMark;

    CLicenses*         m_pLicenses;    
    CStatistics*       m_pStatistics;  
    CServerStatistics* m_pServerStatistics;

public:
    CProduct(
        CCmdTarget* pParent     = NULL,
        LPCTSTR     pName       = NULL,
        long        lPurchased  = 0L,
        long        lInUse      = 0L,
        long        lConcurrent = 0L,
        long        lHighMark   = 0L
        );
    virtual ~CProduct();

    BOOL RefreshLicenses();
    BOOL RefreshStatistics();
    BOOL RefreshServerStatistics();

    void ResetLicenses();
    void ResetStatistics();
    void ResetServerStatistics();

    //{{AFX_VIRTUAL(CProduct)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CProduct)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetInUse();
    afx_msg BSTR GetName();
    afx_msg long GetPerSeatLimit();
    afx_msg long GetPerServerLimit();
    afx_msg long GetPerServerReached();
    afx_msg LPDISPATCH GetLicenses(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetStatistics(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetServerStatistics(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CProduct)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#define IsProductInViolation(prd)   ((prd)->m_lLimit < (prd)->m_lInUse)
#define IsProductAtLimit(prd)       (((prd)->m_lLimit == (prd)->m_lInUse) && (prd)->m_lLimit)

#define CalcProductBitmap(prd)      (IsProductInViolation(prd) ? BMPI_VIOLATION : (IsProductAtLimit(prd) ? BMPI_WARNING_AT_LIMIT : BMPI_PRODUCT))

#endif // _PRDOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgu.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgu.cpp

Abstract:

    Product property page (users) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "prdppgu.h"
#include "usrpsht.h"

#define LVID_USER               0
#define LVID_LAST_USED          1
#define LVID_TOTAL_USED         2

#define LVCX_USER               40
#define LVCX_LAST_USED          30
#define LVCX_TOTAL_USED         -1

static LV_COLUMN_INFO g_userColumnInfo = {

    0, 0, 3,
    {{LVID_USER,       IDS_USER,           0, LVCX_USER      },
     {LVID_LAST_USED,  IDS_LAST_DATE_USED, 0, LVCX_LAST_USED },
     {LVID_TOTAL_USED, IDS_USAGE_COUNT,    0, LVCX_TOTAL_USED}},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProductPropertyPageUsers, CPropertyPage)

BEGIN_MESSAGE_MAP(CProductPropertyPageUsers, CPropertyPage)
    //{{AFX_MSG_MAP(CProductPropertyPageUsers)
    ON_BN_CLICKED(IDC_PP_PRODUCT_USERS_DELETE, OnDelete)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_PRODUCT_USERS_USERS, OnDblClkUsers)
    ON_NOTIFY(NM_RETURN, IDC_PP_PRODUCT_USERS_USERS, OnReturnUsers)
    ON_NOTIFY(NM_SETFOCUS, IDC_PP_PRODUCT_USERS_USERS, OnSetFocusUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_PP_PRODUCT_USERS_USERS, OnKillFocusUsers)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_PRODUCT_USERS_USERS, OnColumnClickUsers)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_PRODUCT_USERS_USERS, OnGetDispInfoUsers)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CProductPropertyPageUsers::CProductPropertyPageUsers() 
    : CPropertyPage(CProductPropertyPageUsers::IDD)

/*++

Routine Description:

    Constructor for product property page (users).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CProductPropertyPageUsers)
    //}}AFX_DATA_INIT

    m_pProduct = NULL;
    m_pUpdateHint = NULL;
    m_bUserProperties = FALSE;
    m_bAreCtrlsInitialized = FALSE;
}


CProductPropertyPageUsers::~CProductPropertyPageUsers()

/*++

Routine Description:

    Destructor for product property page (users).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CProductPropertyPageUsers::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProductPropertyPageUsers)
    DDX_Control(pDX, IDC_PP_PRODUCT_USERS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_PP_PRODUCT_USERS_USERS, m_userList);
    //}}AFX_DATA_MAP
}


void CProductPropertyPageUsers::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_userList.SetFocus();
    m_delBtn.EnableWindow(FALSE);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_userList, &g_userColumnInfo);
}


void 
CProductPropertyPageUsers::InitPage(
    CProduct* pProduct, 
    DWORD*    pUpdateHint, 
    BOOL      bUserProperties
    )

/*++

Routine Description:

    Initializes property page.

Arguments:

    pProduct - product object.
    pUpdateHint - update hint.
    bUserProperties - to recurse or not.

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pProduct, CProduct);

    m_pProduct = pProduct;
    m_pUpdateHint = pUpdateHint;
    m_bUserProperties = bUserProperties;
}


void CProductPropertyPageUsers::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortPage(); // bail...
    }
}


void CProductPropertyPageUsers::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL); 
}


BOOL CProductPropertyPageUsers::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set to control manually.

--*/

{
    CPropertyPage::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CProductPropertyPageUsers::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_userList); // release now...
    CPropertyPage::OnDestroy();
}


BOOL CProductPropertyPageUsers::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;
    
    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (IsUserInfoUpdated(*m_pUpdateHint) && !RefreshCtrls()) 
        {
            AbortPageIfNecessary(); // display error...
        }    
    }

    return bIsActivated; 

}


BOOL CProductPropertyPageUsers::RefreshCtrls()

/*++

Routine Description:

    Refreshs property page controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed successfully.

--*/

{
    VALIDATE_OBJECT(m_pProduct, CProduct);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor(); // hourglass...

    CStatistics* pStatistics = (CStatistics*)MKOBJ(m_pProduct->GetStatistics(va));

    if (pStatistics)
    {
        VALIDATE_OBJECT(pStatistics, CStatistics);

        bIsRefreshed = ::LvRefreshObArray(        
                            &m_userList, 
                            &g_userColumnInfo, 
                            pStatistics->m_pObArray
                            );

        pStatistics->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_userList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


void CProductPropertyPageUsers::OnDelete() 

/*++

Routine Description:

    Revokes licenses from user.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic; 
        
    if (pStatistic = (CStatistic*)::LvGetSelObj(&m_userList))
    {
        VALIDATE_OBJECT(pStatistic, CStatistic);

        CString strConfirm;
        AfxFormatString2(
            strConfirm, 
            IDP_CONFIRM_REVOKE_LICENSE, 
            pStatistic->m_strEntry, 
            m_pProduct->m_strName
            );

        if (AfxMessageBox(strConfirm, MB_YESNO) == IDYES)
        {
            NTSTATUS NtStatus;

            BeginWaitCursor(); // hourglass...

            NtStatus = ::LlsUserProductDelete(
                            LlsGetActiveHandle(),
                            MKSTR(pStatistic->m_strEntry),
                            MKSTR(m_pProduct->m_strName)
                            );
                            
            EndWaitCursor(); // hourglass...

            if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
                NtStatus = STATUS_SUCCESS;

            LlsSetLastStatus(NtStatus); // called api...
    
            if (NT_SUCCESS(NtStatus))
            {
                *m_pUpdateHint |= UPDATE_LICENSE_REVOKED;

                if (!RefreshCtrls())
                {
                    AbortPageIfNecessary(); // display error...
                }
            }
            else
            {
                AbortPageIfNecessary(); // display error...
            }
        }
    }
}


void CProductPropertyPageUsers::OnDblClkUsers(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewUserProperties();
    *pResult = 0;
}


void CProductPropertyPageUsers::OnReturnUsers(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ViewUserProperties();
    *pResult = 0;
}


void CProductPropertyPageUsers::OnSetFocusUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CProductPropertyPageUsers::OnKillFocusUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_userList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


BOOL CProductPropertyPageUsers::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
         
            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }

        ::SafeEnableWindow(
            &m_delBtn,
            &m_userList,
            CDialog::GetFocus(),
            m_userList.GetItemCount()
            );

        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CProductPropertyPageUsers::OnColumnClickUsers(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_userColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_userColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_userList.SortItems(CompareProductUsers, 0); // use column info

    *pResult = 0;
}


void CProductPropertyPageUsers::ViewUserProperties()

/*++

Routine Description:

    Recurse into user property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic;

    if (!m_bUserProperties)
    {
        ::MessageBeep(MB_OK);
        return; // bail if recursion disabled...
    }

    if (pStatistic = (CStatistic*)::LvGetSelObj(&m_userList))
    {
        VALIDATE_OBJECT(pStatistic, CStatistic);

        CUser* pUser = new CUser(NULL, pStatistic->m_strEntry);

        if (pUser && pUser->Refresh())
        {
            CString strTitle;                                                  
            AfxFormatString1(strTitle, IDS_PROPERTIES_OF, pUser->m_strName);
                                                                           
            CUserPropertySheet userProperties(strTitle);           
            userProperties.InitPages(pUser, FALSE);                             
            userProperties.DoModal();                                       

            *m_pUpdateHint |= userProperties.m_fUpdateHint;

            if (IsUpdateAborted(userProperties.m_fUpdateHint))
            {
                AbortPage(); // don't display error...
            }
            else if (IsUserInfoUpdated(userProperties.m_fUpdateHint) && !RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }
        else
        {
            AbortPageIfNecessary(); // display error...
        }
            
        if (pUser)
            pUser->InternalRelease();    // delete object...
    }
}


void CProductPropertyPageUsers::OnGetDispInfoUsers(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CStatistic* pStatistic = (CStatistic*)plvItem->lParam;
    VALIDATE_OBJECT(pStatistic, CStatistic);

    switch (plvItem->iSubItem)
    {
    case LVID_USER:
        plvItem->iImage = pStatistic->m_bIsValid ? BMPI_USER : BMPI_VIOLATION;
        lstrcpyn(plvItem->pszText, pStatistic->m_strEntry, plvItem->cchTextMax);
        break;

    case LVID_LAST_USED:
    {
        BSTR bstrDateLastUsed = pStatistic->GetLastUsedString();
        if( bstrDateLastUsed != NULL )
        {
            lstrcpyn(plvItem->pszText, bstrDateLastUsed, plvItem->cchTextMax);
            SysFreeString(bstrDateLastUsed);
        }
        else
        {
            lstrcpy(plvItem->pszText, L"");
        }
    }
        break;

    case LVID_TOTAL_USED:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pStatistic->GetTotalUsed());         
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareProductUsers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pStatistic1 ((CStatistic*)lParam1)
#define pStatistic2 ((CStatistic*)lParam2)

    VALIDATE_OBJECT(pStatistic1, CStatistic);
    VALIDATE_OBJECT(pStatistic2, CStatistic);

    int iResult;

    switch (g_userColumnInfo.nSortedItem)
    {
    case LVID_USER:
        iResult = pStatistic1->m_strEntry.CompareNoCase(pStatistic2->m_strEntry);
        break;

    case LVID_LAST_USED:
        iResult = pStatistic1->m_lLastUsed - pStatistic2->m_lLastUsed;
        break;

    case LVID_TOTAL_USED:
        iResult = pStatistic1->GetTotalUsed() - pStatistic2->GetTotalUsed();
        break;

    default:
        iResult = 0;
        break;
    }

    return g_userColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgl.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgl.cpp

Abstract:

    Product property page (licences) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Ported to CCF API to add/remove licenses.
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "prdppgl.h"
#include "mainfrm.h"

#define LVID_DATE               1
#define LVID_QUANTITY           2
#define LVID_ADMIN              3
#define LVID_COMMENT            4

#define LVCX_DATE               20
#define LVCX_QUANTITY           20
#define LVCX_ADMIN              30
#define LVCX_COMMENT            -1

static LV_COLUMN_INFO g_licenseColumnInfo = {

    0, 0, 5,
    {{LVID_SEPARATOR, 0,                 0, 0            },
     {LVID_DATE,      IDS_DATE,          0, LVCX_DATE    },
     {LVID_QUANTITY,  IDS_QUANTITY,      0, LVCX_QUANTITY},
     {LVID_ADMIN,     IDS_ADMINISTRATOR, 0, LVCX_ADMIN   },
     {LVID_COMMENT,   IDS_COMMENT,       0, LVCX_COMMENT }},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProductPropertyPageLicenses, CPropertyPage)

BEGIN_MESSAGE_MAP(CProductPropertyPageLicenses, CPropertyPage)
    //{{AFX_MSG_MAP(CProductPropertyPageLicenses)
    ON_BN_CLICKED(IDC_PP_PRODUCT_LICENSES_NEW, OnNew)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_PRODUCT_LICENSES_LICENSES, OnColumnClickLicenses)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_PRODUCT_LICENSES_LICENSES, OnGetDispInfoLicenses)
    ON_BN_CLICKED(IDC_PP_PRODUCT_LICENSES_DELETE, OnDelete)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CProductPropertyPageLicenses::CProductPropertyPageLicenses()
    : CPropertyPage(CProductPropertyPageLicenses::IDD)

/*++

Routine Description:

    Constructor for product property page (licenses).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CProductPropertyPageLicenses)
    m_nLicensesTotal = 0;
    //}}AFX_DATA_INIT

    m_pProduct  = NULL;
    m_pUpdateHint = NULL;
    m_bAreCtrlsInitialized = FALSE;
}


CProductPropertyPageLicenses::~CProductPropertyPageLicenses()

/*++

Routine Description:

    Destructor for product property page (licenses).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


void CProductPropertyPageLicenses::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProductPropertyPageLicenses)
    DDX_Control(pDX, IDC_PP_PRODUCT_LICENSES_NEW, m_newBtn);
    DDX_Control(pDX, IDC_PP_PRODUCT_LICENSES_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_PP_PRODUCT_LICENSES_LICENSES, m_licenseList);
    DDX_Text(pDX, IDC_PP_PRODUCT_LICENSES_TOTAL, m_nLicensesTotal);
    //}}AFX_DATA_MAP
}


void CProductPropertyPageLicenses::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_newBtn.SetFocus();
    m_delBtn.EnableWindow(FALSE);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_licenseList, &g_licenseColumnInfo);
}


void CProductPropertyPageLicenses::InitPage(CProduct* pProduct, DWORD* pUpdateHint)

/*++

Routine Description:

    Initializes property page.

Arguments:

    pProduct - product object.
    pUpdateHint - update hint.

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pProduct, CProduct);

    m_pProduct = pProduct;
    m_pUpdateHint = pUpdateHint;
}


void CProductPropertyPageLicenses::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortPage(); // bail...
    }
}


void CProductPropertyPageLicenses::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
    *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL);
}


BOOL CProductPropertyPageLicenses::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:


    Returns false if focus set to control manually.

--*/

{
    CPropertyPage::OnInitDialog();

    SendMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


void CProductPropertyPageLicenses::OnNew()

/*++

Routine Description:

    Creates a new license for product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
    VALIDATE_OBJECT(pController, CController);

    LPTSTR pszUniServerName   = pController->GetName();
    LPTSTR pszUniProductName  = m_pProduct->GetName();

    if ( ( NULL == pszUniServerName ) || ( NULL == pszUniProductName ) )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        /*
        LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );
        LPSTR pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );
        */
        LPSTR pszAscServerName = NULL;
        LPSTR pszAscProductName = NULL;

        int cbSize = 0;

        cbSize = WideCharToMultiByte( CP_OEMCP ,
                                      0 ,
                                      pszUniServerName ,
                                      -1,
                                      pszAscServerName ,
                                      0 ,
                                      NULL ,
                                      NULL  );

        if( cbSize != 0 )
        {
            pszAscServerName = ( LPSTR )LocalAlloc( LMEM_FIXED , cbSize + 1 );
        }

        if( pszAscServerName == NULL )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );

            return;
        }

        WideCharToMultiByte( CP_OEMCP ,
                             0 ,
                             pszUniServerName ,
                             -1,
                             pszAscServerName ,
                             cbSize ,
                             NULL ,
                             NULL  );

        


        cbSize = 0;

        cbSize = WideCharToMultiByte( CP_OEMCP ,
                                      0 ,
                                      pszUniProductName ,
                                      -1,
                                      pszAscProductName ,
                                      0 ,
                                      NULL ,
                                      NULL  );

        if( cbSize != 0 )
        {
            pszAscProductName = ( LPSTR )LocalAlloc( LMEM_FIXED , 1 + cbSize );
        }

        if( NULL == pszAscProductName ) 
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
            
            return;

        }
        else
        {
            /*
            wsprintfA( pszAscServerName,  "%ls", pszUniServerName  );
            wsprintfA( pszAscProductName, "%ls", pszUniProductName );
            */
            WideCharToMultiByte( CP_OEMCP ,
                                 0 ,
                                 pszUniProductName ,
                                 -1,
                                 pszAscProductName ,
                                 cbSize ,
                                 NULL ,
                                 NULL  );

            DWORD dwError = CCFCertificateEnterUI( m_hWnd, pszAscServerName, pszAscProductName, "Microsoft", CCF_ENTER_FLAG_PER_SEAT_ONLY | CCF_ENTER_FLAG_SERVER_IS_ES, NULL );
            DWORD fUpdateHint;

            if ( ERROR_SUCCESS == dwError )
            {
                fUpdateHint = UPDATE_LICENSE_ADDED;
            }
            else
            {
                fUpdateHint = UPDATE_INFO_NONE;
            }

            *m_pUpdateHint |= fUpdateHint;

            if (IsLicenseInfoUpdated(fUpdateHint) && !RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }

        if ( NULL != pszAscServerName )
        {
            LocalFree( pszAscServerName );
        }
        if ( NULL != pszAscProductName )
        {
            LocalFree( pszAscProductName );
        }
    }

    if ( NULL != pszUniServerName )
    {
        SysFreeString( pszUniServerName );
    }
    if ( NULL != pszUniProductName )
    {
        SysFreeString( pszUniProductName );
    }
}


void CProductPropertyPageLicenses::OnDelete()

/*++

Routine Description:

    Removes licenses from product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
    VALIDATE_OBJECT(pController, CController);

    LPTSTR pszUniServerName  = pController->GetName();
    LPSTR pszAscServerName = NULL;
    LPSTR pszAscProductName = NULL;
    int cbSize;


    if ( NULL == pszUniServerName )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
    else
    {
        // LPSTR pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniServerName  ) );

        cbSize = WideCharToMultiByte( CP_OEMCP ,
                                      0 ,
                                      pszUniServerName ,
                                      -1,
                                      pszAscServerName ,
                                      0 ,
                                      NULL ,
                                      NULL  );

        if( cbSize != 0 )
        {
            pszAscServerName = ( LPSTR )LocalAlloc( LMEM_FIXED , cbSize + 1 );
        }


        if ( NULL == pszAscServerName )
        {
            theApp.DisplayStatus( STATUS_NO_MEMORY );
        }
        else
        {
            // wsprintfA( pszAscServerName, "%ls", pszUniServerName );
            WideCharToMultiByte( CP_OEMCP ,
                                 0 ,
                                 pszUniServerName ,
                                 -1,
                                 pszAscServerName ,
                                 cbSize ,
                                 NULL ,
                                 NULL  );

            // LPSTR  pszAscProductName = NULL;
            LPTSTR pszUniProductName = m_pProduct->GetName();

            if ( NULL != pszUniProductName )
            {
                // pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + lstrlen( pszUniProductName ) );
                cbSize = 0;
                
                cbSize = WideCharToMultiByte( CP_OEMCP ,
                                              0 ,
                                              pszUniProductName ,
                                              -1,
                                              pszAscProductName ,
                                              0 ,
                                              NULL ,
                                              NULL  );

                if( cbSize != 0 )
                {
                    pszAscProductName = ( LPSTR )LocalAlloc( LMEM_FIXED , 1 + cbSize );
                }


                if ( NULL != pszAscProductName )
                {
                    // wsprintfA( pszAscProductName, "%ls", pszUniProductName );
                    WideCharToMultiByte( CP_OEMCP ,
                                         0 ,
                                         pszUniProductName ,
                                         -1,
                                         pszAscProductName ,
                                         cbSize ,
                                         NULL ,
                                         NULL  );

                }

                SysFreeString( pszUniProductName );
            }

            CCFCertificateRemoveUI( m_hWnd, pszAscServerName, pszAscProductName, pszAscProductName ? "Microsoft" : NULL, NULL, NULL );

            *m_pUpdateHint |= UPDATE_LICENSE_DELETED;

            if ( !RefreshCtrls() )
            {
                AbortPageIfNecessary(); // display error...
            }

            LocalFree( pszAscServerName );
            if ( NULL != pszAscProductName )
            {
                LocalFree( pszAscProductName );
            }
        }

        SysFreeString( pszUniServerName );
    }
}


BOOL CProductPropertyPageLicenses::RefreshCtrls()

/*++

Routine Description:

    Refreshs property page controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    VALIDATE_OBJECT(m_pProduct, CProduct);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    m_nLicensesTotal = 0; // reset now...

    BeginWaitCursor(); // hourglass...

    CLicenses* pLicenses = (CLicenses*)MKOBJ(m_pProduct->GetLicenses(va));

    if (pLicenses)
    {
        VALIDATE_OBJECT(pLicenses, CLicenses);

        bIsRefreshed = ::LvRefreshObArray(
                            &m_licenseList,
                            &g_licenseColumnInfo,
                            pLicenses->m_pObArray
                            );

        if (bIsRefreshed)
        {
            CObArray* pObArray;
            CLicense* pLicense;

            pObArray = pLicenses->m_pObArray;
            INT_PTR nLicenses = pObArray->GetSize();

            while (nLicenses--)
            {
                pLicense = (CLicense*)pObArray->GetAt(nLicenses);
                VALIDATE_OBJECT(pLicense, CLicense);

                m_nLicensesTotal += pLicense->GetQuantity();
            }
        }

        pLicenses->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_licenseList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    UpdateData(FALSE); // update total...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


void CProductPropertyPageLicenses::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_licenseList); // release now...
    CPropertyPage::OnDestroy();
}


BOOL CProductPropertyPageLicenses::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;

    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (IsLicenseInfoUpdated(*m_pUpdateHint) && !RefreshCtrls())
        {
            AbortPageIfNecessary(); // display error...
        }
    }

    return bIsActivated;
}


BOOL CProductPropertyPageLicenses::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();

            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }

        ::SafeEnableWindow(
            &m_delBtn,
            &m_licenseList,
            CDialog::GetFocus(),
            (BOOL)(m_nLicensesTotal > 0)
            );

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CProductPropertyPageLicenses::OnColumnClickLicenses(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_licenseColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_licenseColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_licenseList.SortItems(CompareProductLicenses, 0); // use column info

    *pResult = 0;
}


void CProductPropertyPageLicenses::OnGetDispInfoLicenses(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
    ASSERT(plvItem);

    CLicense* pLicense = (CLicense*)plvItem->lParam;
    VALIDATE_OBJECT(pLicense, CLicense);

    switch (plvItem->iSubItem)
    {
    case LVID_SEPARATOR:
    {
        plvItem->iImage = 0;
        CString strLabel = _T("");
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_DATE:
    {
        BSTR bstrDate = pLicense->GetDateString();
        if( bstrDate != NULL)
        {
            lstrcpyn(plvItem->pszText, bstrDate, plvItem->cchTextMax);
            SysFreeString(bstrDate);

        }
        else
        {
            lstrcpy(plvItem->pszText, L"");
        }
    }
        break;

    case LVID_QUANTITY:
    {
        CString strLabel;
        strLabel.Format(_T("%ld"), pLicense->m_lQuantity);
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
    }
        break;

    case LVID_ADMIN:
        lstrcpyn(plvItem->pszText, pLicense->m_strUser, plvItem->cchTextMax);
        break;

    case LVID_COMMENT:
        lstrcpyn(plvItem->pszText, pLicense->m_strDescription, plvItem->cchTextMax);
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareProductLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pLicense1 ((CLicense*)lParam1)
#define pLicense2 ((CLicense*)lParam2)

    VALIDATE_OBJECT(pLicense1, CLicense);
    VALIDATE_OBJECT(pLicense2, CLicense);

    int iResult;

    switch (g_licenseColumnInfo.nSortedItem)
    {
    case LVID_DATE:
        iResult = pLicense1->m_lDate - pLicense2->m_lDate;
        break;

    case LVID_QUANTITY:
        iResult = pLicense1->GetQuantity() - pLicense2->GetQuantity();
        break;

    case LVID_ADMIN:
        iResult =pLicense1->m_strUser.CompareNoCase(pLicense2->m_strUser);
        break;

    case LVID_COMMENT:
        iResult = pLicense1->m_strDescription.CompareNoCase(pLicense2->m_strDescription);
        break;

    default:
        iResult = 0;
        break;
    }

    return g_licenseColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdpsht.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdpsht.cpp

Abstract:

    Product property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "prdpsht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CProductPropertySheet, CPropertySheet)

BEGIN_MESSAGE_MAP(CProductPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CProductPropertySheet)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CProductPropertySheet::CProductPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for product property sheet.

Arguments:

    nIDCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CProductPropertySheet::CProductPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for product property sheet.

Arguments:

    pszCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CProductPropertySheet::~CProductPropertySheet()

/*++

Routine Description:

    Destructor for product property sheet.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CProductPropertySheet::InitPages(CProduct* pProduct, BOOL bUserProperties)

/*++

Routine Description:

    Initializes property pages.

Arguments:

    pProduct - product object.
    bUserProperties - to recurse or not.

Return Values:

    None.

--*/

{
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    AddPage(&m_usersPage);
    m_usersPage.InitPage(pProduct, &m_fUpdateHint, bUserProperties);

    AddPage(&m_licensesPage);
    m_licensesPage.InitPage(pProduct, &m_fUpdateHint);

    AddPage(&m_serversPage);
    m_serversPage.InitPage(pProduct, &m_fUpdateHint);
}


void CProductPropertySheet::OnHelp()

/*++

Routine Description:

    Help button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CPropertySheet::OnCommandHelp(0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdppgu.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdppgu.h

Abstract:

    Product property page (users) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDPPGU_H_
#define _PRDPPGU_H_

class CProductPropertyPageUsers : public CPropertyPage
{
    DECLARE_DYNCREATE(CProductPropertyPageUsers)
private:
    CProduct*    m_pProduct;
    CObList      m_deleteList;
    DWORD*       m_pUpdateHint;
    BOOL         m_bUserProperties;
    BOOL         m_bAreCtrlsInitialized;

public:
    CProductPropertyPageUsers();
    ~CProductPropertyPageUsers();

    void InitPage(CProduct* pProduct, DWORD* pUpdateHint, BOOL bUserProperties = TRUE);
    void AbortPageIfNecessary();
    void AbortPage();

    void InitCtrls();
    BOOL RefreshCtrls();

    void ViewUserProperties();

    //{{AFX_DATA(CProductPropertyPageUsers)
    enum { IDD = IDD_PP_PRODUCT_USERS };
    CButton m_delBtn;
    CListCtrl m_userList;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CProductPropertyPageUsers)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CProductPropertyPageUsers)
    virtual BOOL OnInitDialog();
    afx_msg void OnDelete();
    afx_msg void OnDblClkUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareProductUsers(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _PRDPPGU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\pseatdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    pseatdlg.cpp

Abstract:

    Per seat confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "pseatdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CPerSeatLicensingDialog, CDialog)
    //{{AFX_MSG_MAP(CPerSeatLicensingDialog)
    ON_BN_CLICKED(IDC_PER_SEAT_AGREE, OnAgree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CPerSeatLicensingDialog::CPerSeatLicensingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CPerSeatLicensingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CPerSeatLicensingDialog)
    m_strStaticClients = _T("");
    //}}AFX_DATA_INIT

    m_strProduct = _T("");
}


void CPerSeatLicensingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPerSeatLicensingDialog)
    DDX_Control(pDX, IDC_PER_SEAT_AGREE, m_agreeBtn);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Text(pDX, IDC_PER_SEAT_STATIC_CLIENTS, m_strStaticClients);
    //}}AFX_DATA_MAP
}


BOOL CPerSeatLicensingDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    AfxFormatString1(
        m_strStaticClients, 
        IDS_PER_SEAT_LICENSING_1, 
        m_strProduct
        );

    CDialog::OnInitDialog();
    
    m_agreeBtn.SetCheck(0);
    m_okBtn.EnableWindow(FALSE);

    return TRUE;  
}


void CPerSeatLicensingDialog::OnAgree() 

/*++

Routine Description:

    Toggle okay button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_okBtn.EnableWindow(!m_okBtn.IsWindowEnabled());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sbs_res.h ===
#define SBS_RESOURCE_DLL    L"sbslimit.dll"
#define SBS_License_Error   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\prdpsht.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    prdpsht.h

Abstract:

    Product property sheet implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRDPSHT_H_
#define _PRDPSHT_H_

#include "prdppgu.h"
#include "prdppgl.h"
#include "prdppgs.h"

class CProductPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CProductPropertySheet)
private:
    CProductPropertyPageUsers    m_usersPage;
    CProductPropertyPageServers  m_serversPage;
    CProductPropertyPageLicenses m_licensesPage;

public:
    DWORD m_fUpdateHint;

public:
    CProductPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CProductPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    virtual ~CProductPropertySheet();

    void InitPages(CProduct* pProduct, BOOL bUserProperties = TRUE);
    
    //{{AFX_VIRTUAL(CProductPropertySheet)
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CProductPropertySheet)
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PRDPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\psrvdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    psrvdlg.h

Abstract:

    Per server confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PSRVDLG_H_
#define _PSRVDLG_H_

class CPerServerLicensingDialog : public CDialog
{
public:
    CString m_strProduct;
    CString m_strLicenses;

public:
    CPerServerLicensingDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CPerServerLicensingDialog)
    enum { IDD = IDD_PER_SERVER_LICENSING };
    CButton m_agreeBtn;
    CButton m_okBtn;
    CString m_strStaticClients;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CPerServerLicensingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);   
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CPerServerLicensingDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnAgree();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PSRVDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\pseatdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    pseatdlg.h

Abstract:

    Per seat confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PSEATDLG_H_
#define _PSEATDLG_H_

class CPerSeatLicensingDialog : public CDialog
{
public:
    CString m_strProduct;

public:
    CPerSeatLicensingDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CPerSeatLicensingDialog)
    enum { IDD = IDD_PER_SEAT_LICENSING };
    CButton m_agreeBtn;
    CButton m_okBtn;
    CString m_strStaticClients;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CPerSeatLicensingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX); 
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CPerSeatLicensingDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnAgree();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PSEATDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by llsmgr.rc
//
#define IDR_MAINFRAME                   100
#define IDB_SMALL_CTRLS                 200
#define IDB_LARGE_CTRLS                 201
#define IDI_LLSMGR_WARNING              202
#define IDM_POPUP                       203
#define IDM_LICENSE_SORT                204
#define IDD_SELECT_DOMAIN               300
#define IDD_NEW_MAPPING                 303
#define IDD_LICENSE_GROUPS              304
#define IDD_ADD_USERS                   305
#define IDD_CHOOSE_MODE                 306
#define IDD_PER_SERVER_LICENSING        307
#define IDD_PER_SEAT_LICENSING          308
#define IDD_SERVER_LICENSING            309
#define IDD_VIOLATION                   310
#define IDD_PP_PRODUCT_USERS            311
#define IDD_PP_PRODUCT_LICENSES         312
#define IDD_PP_PRODUCT_SERVERS          313
#define IDD_PP_USER_PRODUCTS            314
#define IDD_PP_MAPPING_SETTINGS         315
#define IDD_PP_SERVER_PRODUCTS          316
#define IDD_PP_SERVER_REPLICATION       317
#define IDP_OLE_INIT_FAILED             400
#define IDP_APP_INIT_FAILED             401
#define IDP_ERROR_UNSUCCESSFUL          402
#define IDP_ERROR_DROPPED_LINK          403
#define IDP_ERROR_INVALID_DOMAIN        404
#define IDP_ERROR_INVALID_MAPPING       405
#define IDP_ERROR_INVALID_COMPUTERNAME  406
#define IDP_ERROR_NO_LICENSES           407
#define IDP_ERROR_NO_PRIVILEGES         408
#define IDP_ERROR_NO_RPC_SERVER         409
#define IDP_ERROR_MEMBER_IN_GROUP       410
#define IDP_ERROR_NO_SELF_REPLICATION   411
#define IDP_ERROR_SERVER_NOT_CONFIGURED 412
#define IDP_ERROR_NO_RPC_SERVER_FORMAT  413
#define IDP_CONFIRM_REVOKE_LICENSE      500
#define IDP_CONFIRM_DELETE_LICENSE      501
#define IDP_CONFIRM_DELETE_USER         502
#define IDP_CONFIRM_DELETE_GROUP        503
#define IDP_CONFIRM_USE_ENTERPRISE      504
#define IDP_CONFIRM_NOT_USE_ENTERPRISE  505
#define IDP_CONFIRM_ENTERPRISE_CHANGE   506
#define IDP_CONFIRM_TO_PER_SEAT         507
#define IDP_CONFIRM_TO_PER_SERVER       508
#define IDS_LICENSING_MODE              600
#define IDS_PER_SERVER                  601
#define IDS_PER_SEAT                    602
#define IDS_LICENSES                    603
#define IDS_PRODUCTS                    604
#define IDS_PURCHASED                   605
#define IDS_QUANTITY                    606
#define IDS_DATE                        607
#define IDS_ADMINISTRATOR               608
#define IDS_DESCRIPTION                 609
#define IDS_LICENSES_PURCHASED          610
#define IDS_USER_NAME                   611
#define IDS_ENTERPRISE                  612
#define IDS_PROPERTIES_OF               613
#define IDS_PRODUCT                     614
#define IDS_COMMENT                     615
#define IDS_PURCHASE_HISTORY            616
#define IDS_PER_SEAT_CLIENTS            617
#define IDS_USER                        618
#define IDS_PER_SEAT_PURCHASED          619
#define IDS_PER_SERVER_PURCHASED        620
#define IDS_LICENSED_USAGE              621
#define IDS_UNLICENSED_USAGE            622
#define IDS_PRODUCTS_VIEW               623
#define IDS_GROUP_NAME                  624
#define IDS_USAGE_COUNT                 625
#define IDS_LAST_DATE_USED              626
#define IDS_SERVER_NAME                 627
#define IDS_PER_SEAT_LICENSING_1        628
#define IDS_PER_SERVER_LICENSING_1      629
#define IDS_LICENSING_MODE_1            630
#define IDS_LICENSING_MODE_2            631
#define IDS_DEFAULT_DOMAIN              632
#define IDS_UNLISTED_PRODUCT            633
#define IDS_PER_SEAT_CONSUMED           634
#define IDS_PER_SERVER_REACHED          635
#define IDS_REACHED                     636
#define IDS_NOT_APPLICABLE              637
#define IDS_SERVER_BROWSER              638
                                     /* 639 */
#define IDS_DATE_MENUOPT                640
#define IDS_PRODUCT_MENUOPT             641
#define IDS_QUANTITY_MENUOPT            642
#define IDS_ADMINISTRATOR_MENUOPT       643
#define IDS_COMMENT_MENUOPT             644
#define IDS_PER_SEAT_PURCHASED_MENUOPT  645
#define IDS_PER_SEAT_CONSUMED_MENUOPT   646
#define IDS_PER_SERVER_PURCHASED_MENUOPT 647
#define IDS_PER_SERVER_REACHED_MENUOPT  648
#define IDS_USER_NAME_MENUOPT           649
#define IDS_LICENSED_USAGE_MENUOPT      650
#define IDS_UNLICENSED_USAGE_MENUOPT    651
#define IDS_PRODUCTS_MENUOPT            652
#define IDP_SBS_RESTRICTED              653
#define IDC_VIEW_TAB_CTRL               1000
#define IDC_VIEW_LICENSE_LIST           1001
#define IDC_VIEW_PRODUCT_LIST           1002
#define IDC_VIEW_USER_LIST              1003
#define IDC_VIEW_USER_TREE              1004
#define IDC_VIEW_MAPPING_LIST           1005
#define IDC_VIEW_SERVER_TREE            1006
#define IDC_SELECT_DOMAIN_DOMAINS       1007
#define IDC_SELECT_DOMAIN_DOMAIN        1008
#define IDC_ADD_USERS_DOMAINS           1009
#define IDC_ADD_USERS_USERS             1010
#define IDC_ADD_USERS_ADD_USERS         1011
#define IDC_ADD_USERS_ADD               1012
#define IDC_ADD_USERS_DELETE            1013
#define IDC_NEW_LICENSE_PRODUCT         1014
#define IDC_NEW_LICENSE_COMMENT         1015
#define IDC_NEW_LICENSE_QUANTITY        1016
#define IDC_NEW_LICENSE_SPIN            1017
#define IDC_NEW_MAPPING_NAME            1018
#define IDC_NEW_MAPPING_DESCRIPTION     1019
#define IDC_NEW_MAPPING_LICENSES        1020
#define IDC_NEW_MAPPING_SPIN            1021
#define IDC_NEW_MAPPING_USERS           1022
#define IDC_NEW_MAPPING_ADD             1023
#define IDC_NEW_MAPPING_DELETE          1024
#define IDC_DEL_LICENSE_QUANTITY        1025
#define IDC_DEL_LICENSE_COMMENT         1026
#define IDC_DEL_LICENSE_SPIN            1027
#define IDC_DEL_LICENSE_PRODUCT         1028
#define IDC_MODE_STATIC_SUPPORTS        1029
#define IDC_MODE_STATIC_PER_SEAT        1030
#define IDC_MODE_STATIC_PER_SERVER      1031
#define IDC_MODE_RADIO_PER_SEAT         1032
#define IDC_MODE_RADIO_PER_SERVER       1033
#define IDC_MODE_LICENSES               1034
#define IDC_MODE_SPIN                   1035
#define IDC_PER_SERVER_STATIC_CLIENTS   1036
#define IDC_PER_SERVER_AGREE            1037
#define IDC_PER_SEAT_AGREE              1038
#define IDC_PER_SEAT_STATIC_CLIENTS     1039
#define IDC_SERVER_AGREE                1040
#define IDC_LICENSE_GROUPS_ADD          1041
#define IDC_LICENSE_GROUPS_DELETE       1042
#define IDC_LICENSE_GROUPS_MAPPINGS     1043
#define IDC_LICENSE_GROUPS_EDIT         1044
#define IDC_PP_MAPPING_SETTINGS_ADD     1045
#define IDC_PP_MAPPING_SETTINGS_DELETE  1046
#define IDC_PP_MAPPING_SETTINGS_USERS   1047
#define IDC_PP_MAPPING_SETTINGS_LICENSES 1048
#define IDC_PP_MAPPING_SETTINGS_SPIN    1049
#define IDC_PP_MAPPING_SETTINGS_DESCRIPTION 1050
#define IDC_PP_MAPPING_SETTINGS_NAME    1051
#define IDC_PP_PRODUCT_USERS_USERS      1052
#define IDC_PP_PRODUCT_USERS_DELETE     1053
#define IDC_PP_PRODUCT_LICENSES_TOTAL   1054
#define IDC_PP_PRODUCT_LICENSES_NEW     1055
#define IDC_PP_PRODUCT_LICENSES_LICENSES 1056
#define IDC_PP_PRODUCT_LICENSES_DELETE  1057
#define IDC_PP_PRODUCT_SERVERS_SERVERS  1058
#define IDC_PP_PRODUCT_SERVERS_EDIT     1059
#define IDC_PP_USER_PRODUCTS_DELETE     1060
#define IDC_PP_USER_PRODUCTS_PRODUCTS   1061
#define IDC_PP_USER_PRODUCTS_BACKOFFICE 1062
#define IDC_PP_SERVER_PRODUCTS_PRODUCTS 1063
#define IDC_PP_SERVER_PRODUCTS_EDIT     1064
#define IDC_PP_SERVER_REPLICATION_DC    1065
#define IDC_PP_SERVER_REPLICATION_ESRV  1066
#define IDC_PP_SERVER_REPLICATION_ESRV_NAME 1067
#define IDC_PP_SERVER_REPLICATION_AT    1068
#define IDC_PP_SERVER_REPLICATION_EVERY 1069
#define IDC_PP_SERVER_REPLICATION_SPIN_AT 1070
#define IDC_PP_SERVER_REPLICATION_SPIN_EVERY 1071
#define IDC_PP_SERVER_REPLICATION_AT_BORDER 1072
#define IDC_PP_SERVER_REPLICATION_AT_HOUR 1073
#define IDC_PP_SERVER_REPLICATION_AT_MINUTE 1074
#define IDC_PP_SERVER_REPLICATION_AT_SECOND 1075
#define IDC_PP_SERVER_REPLICATION_AT_AMPM 1076
#define IDC_PP_SERVER_REPLICATION_AT_SEP1 1077
#define IDC_PP_SERVER_REPLICATION_AT_SEP2 1078
#define IDC_PP_SERVER_REPLICATION_EVERY_VALUE 1079
#define IDC_MODE_ADD_PER_SERVER         1080
#define IDC_MODE_REMOVE_PER_SERVER      1081
#define IDC_PP_SERVER_REPLICATION_MASTER_GB         1082

#define ID_EDIT_DELETE                  1090

#define ID_NEW_LICENSE                  32771
#define ID_NEW_MAPPING                  32772
#define ID_SELECT_DOMAIN                32775
#define ID_VIEW_PRODUCTS                32776
#define ID_VIEW_LICENSES                32777
#define ID_VIEW_USERS                   32778
#define ID_VIEW_MAPPINGS                32779
#define ID_VIEW_SERVERS                 32780
#define ID_SELECT_FONT                  32782
#define ID_SAVE_SETTINGS                32783
#define ID_HELP_HTMLHELP                32784
#define ID_VIEW_ICONS                   32796
#define ID_VIEW_SMALL_ICONS             32797
#define MY_ID_VIEW_LIST                 32798
#define ID_VIEW_REPORT                  32799
#define ID_VIEW_DELETE                  32801
#define ID_VIEW_PROPERTIES              32802
#define ID_INIT_CTRLS                   32803
#define ID_APP_STARTUP                  32805
#define ID_SORT_COLUMN                  32806
#define ID_VIEW_REFRESH                 32807
#define ID_SORT_COLUMN0                 32808
#define ID_SORT_COLUMN1                 32809
#define ID_SORT_COLUMN2                 32810
#define ID_SORT_COLUMN3                 32811
#define ID_SORT_COLUMN4                 32812
#define ID_SORT_COLUMN5                 32813
#define ID_MRU_DOMAIN0                  32814
#define ID_MRU_DOMAIN1                  32815
#define ID_MRU_DOMAIN2                  32816
#define ID_MRU_DOMAIN3                  32817
#define ID_MRU_DOMAIN4                  32818
#define ID_MRU_DOMAIN5                  32819
#define ID_MRU_DOMAIN6                  32820
#define ID_MRU_DOMAIN7                  32821
#define ID_MRU_DOMAIN8                  32822
#define ID_MRU_DOMAIN9                  32823
#define ID_MRU_DOMAIN10                 32824
#define ID_MRU_DOMAIN11                 32825
#define ID_MRU_DOMAIN12                 32826
#define ID_MRU_DOMAIN13                 32827
#define ID_MRU_DOMAIN14                 32828
#define ID_MRU_DOMAIN15                 32829

#define ID_DUMMY                        65500

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        150
#define _APS_NEXT_COMMAND_VALUE         32830
#define _APS_NEXT_CONTROL_VALUE         1085
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\psrvdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    psrvdlg.cpp

Abstract:

    Per server confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "psrvdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CPerServerLicensingDialog, CDialog)
    //{{AFX_MSG_MAP(CPerServerLicensingDialog)
    ON_BN_CLICKED(IDC_PER_SERVER_AGREE, OnAgree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CPerServerLicensingDialog::CPerServerLicensingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CPerServerLicensingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CPerServerLicensingDialog)
    m_strStaticClients = _T("");
    //}}AFX_DATA_INIT
}


void CPerServerLicensingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPerServerLicensingDialog)
    DDX_Control(pDX, IDC_PER_SERVER_AGREE, m_agreeBtn);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Text(pDX, IDC_PER_SERVER_STATIC_CLIENTS, m_strStaticClients);
    //}}AFX_DATA_MAP
}


BOOL CPerServerLicensingDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    AfxFormatString2(
        m_strStaticClients, 
        IDS_PER_SERVER_LICENSING_1, 
        m_strLicenses, 
        m_strProduct
        );

    CDialog::OnInitDialog();
    
    m_agreeBtn.SetCheck(0);
    m_okBtn.EnableWindow(FALSE);

    return TRUE;  
}


void CPerServerLicensingDialog::OnAgree() 

/*++

Routine Description:

    Toggle okay button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_okBtn.EnableWindow(!m_okBtn.IsWindowEnabled());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sdomdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sdomdlg.h

Abstract:

    Select domain dialog implementation.

Author:

    Don Ryan (donryan) 20-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SDOMDLG_H_
#define _SDOMDLG_H_

class CSelectDomainDialog : public CDialog
{
private:
    BOOL  m_bIsFocusDomain;
    BOOL  m_bAreCtrlsInitialized;

public:
    DWORD m_fUpdateHint;
               
public:
    CSelectDomainDialog(CWnd* pParent = NULL);   

    void InitCtrls();
    void InsertDomains(HTREEITEM hParent, CDomains* pDomains);

    //{{AFX_DATA(CSelectDomainDialog)
    enum { IDD = IDD_SELECT_DOMAIN };
    CEdit m_domEdit;
    CTreeCtrl m_serverTree;
    CString m_strDomain;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CSelectDomainDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CSelectDomainDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnItemExpandingDomains(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedDomain(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkDomain(NMHDR* pNMHDR, LRESULT* pResult);
    virtual void OnOK();
    afx_msg void OnReturnDomains(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SDOMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sdomdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sdomdlg.cpp

Abstract:

    Select domain dialog implementation.

Author:

    Don Ryan (donryan) 20-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "sdomdlg.h"
#include <lmerr.h>
#include <lmcons.h>
#include <lmapibuf.h>
extern "C" {
    #include <icanon.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CSelectDomainDialog, CDialog)
    //{{AFX_MSG_MAP(CSelectDomainDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_SELECT_DOMAIN_DOMAINS, OnItemExpandingDomains)
    ON_NOTIFY(TVN_SELCHANGED, IDC_SELECT_DOMAIN_DOMAINS, OnSelChangedDomain)
    ON_NOTIFY(NM_DBLCLK, IDC_SELECT_DOMAIN_DOMAINS, OnDblclkDomain)
    ON_NOTIFY(NM_RETURN, IDC_SELECT_DOMAIN_DOMAINS, OnReturnDomains)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CSelectDomainDialog::CSelectDomainDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CSelectDomainDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for select domain dialog

Arguments:

    pParent - parent window handle.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CSelectDomainDialog)
    m_strDomain = _T("");
    //}}AFX_DATA_INIT

    m_bIsFocusDomain = FALSE;
    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CSelectDomainDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectDomainDialog)
    DDX_Control(pDX, IDC_SELECT_DOMAIN_DOMAIN, m_domEdit);
    DDX_Control(pDX, IDC_SELECT_DOMAIN_DOMAINS, m_serverTree);
    DDX_Text(pDX, IDC_SELECT_DOMAIN_DOMAIN, m_strDomain);
    //}}AFX_DATA_MAP
}


void CSelectDomainDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    TV_ITEM tvItem = {0};
    HTREEITEM htItem;
    TV_INSERTSTRUCT tvInsert;

    CString strLabel;

    tvItem.mask = TVIF_TEXT|
                  TVIF_PARAM|
                  TVIF_CHILDREN|
                  TVIF_SELECTEDIMAGE|
                  TVIF_IMAGE;

    tvItem.cChildren = TRUE;

    tvItem.iImage = BMPI_ENTERPRISE;
    tvItem.iSelectedImage = BMPI_ENTERPRISE;

    strLabel.LoadString(IDS_ENTERPRISE);
    tvItem.pszText = MKSTR(strLabel);

    tvItem.lParam = (LPARAM)(LPVOID)LlsGetApp();

    tvInsert.item         = tvItem;
    tvInsert.hInsertAfter = (HTREEITEM)TVI_ROOT;
    tvInsert.hParent      = (HTREEITEM)NULL;

    VERIFY(htItem = m_serverTree.InsertItem(&tvInsert));
    m_serverTree.SetImageList(&theApp.m_smallImages, TVSIL_NORMAL);

    m_bAreCtrlsInitialized = TRUE; // validate now...

    VERIFY(m_serverTree.Select(htItem, TVGN_CARET)); // redraw now...

    if (!IsConnectionDropped(LlsGetLastStatus()))
    {
        m_serverTree.Expand(htItem, TVE_EXPAND);
    }
    else if (LlsGetApp()->IsFocusDomain())
    {
        CDomain* pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetActiveDomain());
        VALIDATE_OBJECT(pDomain, CDomain);

        m_strDomain = pDomain->m_strName;
        UpdateData(FALSE); // upload...

        m_domEdit.SetSel(0,-1);
        m_domEdit.SetFocus();

        pDomain->InternalRelease(); // release now...

        m_bIsFocusDomain = TRUE;
    }
}


BOOL CSelectDomainDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;
}


BOOL CSelectDomainDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();
        }

        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}


void CSelectDomainDialog::OnDblclkDomain(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for WM_LBUTTONDBLCLK.

Arguments:

    pNMHDR - notification message header.
    pResult - return status.

Return Values:

    None.

--*/

{
    if (!m_strDomain.IsEmpty())
    {
        OnOK();
    }
    else
    {
        if (theApp.OpenDocumentFile(NULL)) // open enterprise
        {
            m_fUpdateHint = UPDATE_DOMAIN_SELECTED;
            EndDialog(IDOK);
        }
    }

    *pResult = 0;
}


void CSelectDomainDialog::OnItemExpandingDomains(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TVN_ITEMEXPANDING.

Arguments:

    pNMHDR - notification message header.
    pResult - return status.

Return Values:

    None.

--*/

{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    TV_ITEM tvItem = pNMTreeView->itemNew;

    if (!(tvItem.state & TVIS_EXPANDEDONCE))
    {
        BeginWaitCursor(); // hourglass...

        CApplication* pApplication = (CApplication*)tvItem.lParam;
        VALIDATE_OBJECT(pApplication, CApplication);

        CDomains* pDomains;

        if (pDomains = pApplication->m_pDomains)
        {
            pDomains->InternalAddRef();
        }
        else
        {
            VARIANT va;
            VariantInit(&va);

            pDomains = (CDomains*)MKOBJ(pApplication->GetDomains(va));
        }

        if (pDomains)
        {
            InsertDomains(tvItem.hItem, pDomains);
            pDomains->InternalRelease();
        }
        else
        {
            theApp.DisplayLastStatus();
        }

        EndWaitCursor(); // hourglass...
    }

    *pResult = 0;
}


void CSelectDomainDialog::OnOK()

/*++

Routine Description:

    Message handler for IDOK.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!UpdateData(TRUE))
        return;

    LPCTSTR pszDomain = m_strDomain;

    while (_istspace(*pszDomain))       //
        pszDomain = _tcsinc(pszDomain); // CString::TrimLeft does not work for UNICODE...
    m_strDomain = pszDomain;            //

    m_strDomain.TrimRight();

    if (!m_strDomain.IsEmpty())
    {
        DWORD NetStatus;

        pszDomain = m_strDomain;

        if ((pszDomain[0] == _T('\\')) &&
            (pszDomain[1] == _T('\\')))
        {
            NetStatus = NetpNameValidate(
                            NULL,
                            (LPTSTR)(pszDomain + 2),
                            NAMETYPE_COMPUTER,
                            0
                            );
        }
        else
        {
            NetStatus = NetpNameValidate(
                            NULL,
                            (LPTSTR)pszDomain,
                            NAMETYPE_DOMAIN,
                            0
                            );
        }

        if (NetStatus == ERROR_SUCCESS)
        {
            if (theApp.OpenDocumentFile(m_strDomain))
            {
                m_fUpdateHint = UPDATE_DOMAIN_SELECTED;
                EndDialog(IDOK);
            }
        }
        else
        {
            AfxMessageBox(IDP_ERROR_INVALID_DOMAIN);
        }
    }
    else
    {
        AfxMessageBox(IDP_ERROR_INVALID_DOMAIN);
    }
}


void CSelectDomainDialog::OnSelChangedDomain(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for TVN_SELCHANGED.

Arguments:

    pNMHDR - notification message header.
    pResult - return status.

Return Values:

    None.

--*/

{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    TV_ITEM tvItem = pNMTreeView->itemNew;

    if (tvItem.hItem != m_serverTree.GetRootItem())
    {
        CDomain* pDomain = (CDomain*)tvItem.lParam;
        VALIDATE_OBJECT(pDomain, CDomain);

        m_strDomain = pDomain->m_strName;
        UpdateData(FALSE); // upload...

        m_bIsFocusDomain = TRUE;
    }
    else if (tvItem.hItem == m_serverTree.GetRootItem())
    {
        m_strDomain = _T("");
        UpdateData(FALSE);

        m_bIsFocusDomain = FALSE;
    }

    *pResult = 0;
}


void CSelectDomainDialog::OnReturnDomains(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification message header.
    pResult - return status.

Return Values:

    None.

--*/

{
    OnDblclkDomain(pNMHDR, pResult);
}


void CSelectDomainDialog::InsertDomains(HTREEITEM hParent, CDomains* pDomains)

/*++

Routine Description:

    Inserts domain list.

Arguments:

    hParent - parent item.
    pDomains - domain collection.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pDomains, CDomains);

    TV_ITEM tvItem = {0};
    TV_INSERTSTRUCT tvInsert;
    long nDomains = pDomains->GetCount();

    tvItem.mask = TVIF_TEXT|
                  TVIF_PARAM|
                  TVIF_IMAGE|
                  TVIF_SELECTEDIMAGE;

    tvItem.iImage = BMPI_DOMAIN;
    tvItem.iSelectedImage = BMPI_DOMAIN;

    tvInsert.hInsertAfter = (HTREEITEM)TVI_LAST;
    tvInsert.hParent      = (HTREEITEM)hParent;

    VARIANT va;
    VariantInit(&va);

    for (va.vt = VT_I4, va.lVal = 0; va.lVal < nDomains; va.lVal++)
    {
        CDomain* pDomain = (CDomain*)MKOBJ(pDomains->GetItem(va));
        VALIDATE_OBJECT(pDomain, CDomain);

        tvItem.pszText = MKSTR(pDomain->m_strName);
        tvItem.lParam = (LPARAM)(LPVOID)pDomain;

        tvInsert.item = tvItem;
        m_serverTree.InsertItem(&tvInsert);

        pDomain->InternalRelease();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvldlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvldlg.h

Abstract:

    Server licensing dialog implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SRVLDLG_H_
#define _SRVLDLG_H_

class CServerLicensingDialog : public CDialog
{
public:
    CServerLicensingDialog(CWnd* pParent = NULL);

    //{{AFX_DATA(CServerLicensingDialog)
    enum { IDD = IDD_SERVER_LICENSING };
    CButton m_okBtn;
    CButton m_agreeBtn;
    BOOL    m_bAgree;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CServerLicensingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CServerLicensingDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnAgree();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SRVLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvcol.h

Abstract:

    Server collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SRVCOL_H_
#define _SRVCOL_H_

class CServers : public CCmdTarget
{
    DECLARE_DYNCREATE(CServers)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CServers(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CServers();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CServers)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CServers)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CServers)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SRVCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvcol.cpp

Abstract:

    Server collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServers, CCmdTarget)

BEGIN_MESSAGE_MAP(CServers, CCmdTarget)
    //{{AFX_MSG_MAP(CServers)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CServers, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CServers)
    DISP_PROPERTY_EX(CServers, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServers, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServers, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CServers, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CServers::CServers(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for server collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CDomain)));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CServers::~CServers()

/*++

Routine Description:

    Destructor for server collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServers::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CServers::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CServers::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CServers::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified server object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the server name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CServer* pServer;
    INT_PTR  iServer;

    VARIANT vServer;
    VariantInit(&vServer);

    if (iServer = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iServer--)
            {
                if (pServer = (CServer*)m_pObArray->GetAt(iServer))
                {
                    ASSERT(pServer->IsKindOf(RUNTIME_CLASS(CServer)));

                    if (!pServer->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pServer->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vServer, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vServer.lVal >= 0) && ((int)vServer.lVal < iServer))
            {
                if (pServer = (CServer*)m_pObArray->GetAt((int)vServer.lVal))
                {
                    ASSERT(pServer->IsKindOf(RUNTIME_CLASS(CServer)));
                    lpdispatch = pServer->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CServers::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvldlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvldlg.h

Abstract:

    Server licensing dialog implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "srvldlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CServerLicensingDialog, CDialog)
    //{{AFX_MSG_MAP(CServerLicensingDialog)
    ON_BN_CLICKED(IDC_SERVER_AGREE, OnAgree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CServerLicensingDialog::CServerLicensingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CServerLicensingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CServerLicensingDialog)
    m_bAgree = FALSE;
    //}}AFX_DATA_INIT
}


void CServerLicensingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerLicensingDialog)
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Control(pDX, IDC_SERVER_AGREE, m_agreeBtn);
    DDX_Check(pDX, IDC_SERVER_AGREE, m_bAgree);
    //}}AFX_DATA_MAP
}


BOOL CServerLicensingDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();

    m_agreeBtn.SetCheck(0);
    m_okBtn.EnableWindow(FALSE);

    return TRUE;
}


void CServerLicensingDialog::OnAgree()

/*++

Routine Description:

    Toggle okay button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_okBtn.EnableWindow(!m_okBtn.IsWindowEnabled());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvobj.h

Abstract:

    Server object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Modified to use LlsProductLicensesGet() to avoid race conditions in
           getting the correct number of concurrent licenses with secure products.
        o  Ported to LlsLocalService API to remove dependencies on configuration
           information being in the registry.

--*/

#ifndef _SRVOBJ_H_
#define _SRVOBJ_H_

class CServer : public CCmdTarget
{
    DECLARE_DYNCREATE(CServer)
private:
    enum Win2000State { uninitialized = 0, win2000, notwin2000 };
    Win2000State m_IsWin2000;
    CCmdTarget* m_pParent;
    CString     m_strController;
    CObArray    m_serviceArray;
    BOOL        m_bServicesRefreshed;

protected:
    HKEY        m_hkeyRoot;
    HKEY        m_hkeyLicense;
    HKEY        m_hkeyReplication;
    LLS_HANDLE  m_hLls;

public:
    CString     m_strName;
    CServices*  m_pServices;

public:
    CServer(CCmdTarget* pParent = NULL, LPCTSTR pName = NULL);

#ifdef CONFIG_THROUGH_REGISTRY
    inline HKEY GetReplRegHandle()
    { return m_hkeyReplication; }
#else
    inline LLS_HANDLE GetLlsHandle()
    { return m_hLls; }
#endif

    virtual ~CServer();

    BOOL InitializeIfNecessary();

    BOOL RefreshServices();
    void ResetServices();

    BOOL ConnectLls();
    void DisconnectLls();
    BOOL HaveAdminAuthority();
    BOOL IsWin2000();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CServer)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CServer)
    afx_msg LPDISPATCH GetApplication();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg BSTR GetController();
    afx_msg BOOL IsLogging();
    afx_msg BOOL IsReplicatingToDC();
    afx_msg BOOL IsReplicatingDaily();
    afx_msg long GetReplicationTime();
    afx_msg LPDISPATCH GetServices(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CServer)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    friend class CService;      // accesses m_hkeyLicense;
};

#define REG_KEY_SERVER_PARAMETERS   _T("SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")
                                   
#define REG_VALUE_USE_ENTERPRISE    _T("UseEnterprise")
#define REG_VALUE_ENTERPRISE_SERVER _T("EnterpriseServer")
#define REG_VALUE_REPLICATION_TYPE  _T("ReplicationType")
#define REG_VALUE_REPLICATION_TIME  _T("ReplicationTime")

#endif // _SRVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvppgp.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvppgp.cpp

Abstract:

    Server property page (services) implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Fixed to properly abort dialog upon ERROR_ACCESS_DENIED.
        o  Ported to LlsLocalService API to remove dependencies on configuration
           information being in the registry.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "srvppgp.h"
#include "lmoddlg.h"

#define LVID_PRODUCT                0
#define LVID_LICENSING_MODE         1
#define LVID_LICENSES_PURCHASED     2

#define LVCX_PRODUCT                40
#define LVCX_LICENSING_MODE         30
#define LVCX_LICENSES_PURCHASED     -1

static LV_COLUMN_INFO g_productColumnInfo = {

    0, 0, 3,
    {{LVID_PRODUCT,            IDS_PRODUCT,            0, LVCX_PRODUCT           },
     {LVID_LICENSING_MODE,     IDS_LICENSING_MODE,     0, LVCX_LICENSING_MODE    },
     {LVID_LICENSES_PURCHASED, IDS_LICENSES_PURCHASED, 0, LVCX_LICENSES_PURCHASED}},

};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServerPropertyPageProducts, CPropertyPage)

BEGIN_MESSAGE_MAP(CServerPropertyPageProducts, CPropertyPage)
    //{{AFX_MSG_MAP(CServerPropertyPageProducts)
    ON_BN_CLICKED(IDC_PP_SERVER_PRODUCTS_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnDblClkProducts)
    ON_NOTIFY(NM_RETURN, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnReturnProducts)
    ON_NOTIFY(NM_SETFOCUS, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnSetFocusProducts)
    ON_NOTIFY(NM_KILLFOCUS, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnKillFocusProducts)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnColumnClickProducts)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_PP_SERVER_PRODUCTS_PRODUCTS, OnGetDispInfoProducts)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CServerPropertyPageProducts::CServerPropertyPageProducts() : 
    CPropertyPage(CServerPropertyPageProducts::IDD)

/*++

Routine Description:

    Constructor for server property page (products).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CServerPropertyPageProducts)
    //}}AFX_DATA_INIT

    m_pServer = NULL;
    m_pUpdateHint = NULL;
    m_bAreCtrlsInitialized = FALSE;
}


CServerPropertyPageProducts::~CServerPropertyPageProducts()

/*++

Routine Description:

    Destructor for server property page (products).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


void CServerPropertyPageProducts::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerPropertyPageProducts)
    DDX_Control(pDX, IDC_PP_SERVER_PRODUCTS_EDIT, m_edtBtn);
    DDX_Control(pDX, IDC_PP_SERVER_PRODUCTS_PRODUCTS, m_productList);
    //}}AFX_DATA_MAP
}


void CServerPropertyPageProducts::InitCtrls()

/*++

Routine Description:

    Initializes property page controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_productList.SetFocus();
    m_edtBtn.EnableWindow(FALSE);

    m_bAreCtrlsInitialized = TRUE;

    ::LvInitColumns(&m_productList, &g_productColumnInfo);
}


void CServerPropertyPageProducts::InitPage(CServer* pServer, DWORD* pUpdateHint)

/*++

Routine Description:

    Initializes property page.

Arguments:

    pServer - Server object.
    pUpdateHint - update hint.

Return Values:

    None.

--*/

{
    ASSERT(pUpdateHint);
    VALIDATE_OBJECT(pServer, CServer);

    m_pServer = pServer;
    m_pUpdateHint = pUpdateHint;
}


void CServerPropertyPageProducts::AbortPageIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (    IsConnectionDropped(      LlsGetLastStatus() )
         || ( ERROR_ACCESS_DENIED  == LlsGetLastStatus() )
         || ( STATUS_ACCESS_DENIED == LlsGetLastStatus() ) )
    {
        AbortPage(); // bail...
    }
}


void CServerPropertyPageProducts::AbortPage()

/*++

Routine Description:

    Aborts property page.

Arguments:

    None.

Return Values:

    None.

--*/

{
//  *m_pUpdateHint = UPDATE_INFO_ABORT;
    GetParent()->PostMessage(WM_COMMAND, IDCANCEL); 
}


BOOL CServerPropertyPageProducts::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CPropertyPage::OnInitDialog();

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CServerPropertyPageProducts::OnDestroy()

/*++

Routine Description:

    Message handler for WM_DESTROY.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvReleaseObArray(&m_productList); // release now...
    CPropertyPage::OnDestroy();
}


BOOL CServerPropertyPageProducts::OnSetActive()

/*++

Routine Description:

    Activates property page.

Arguments:

    None.

Return Values:

    Returns true if focus accepted.

--*/

{
    BOOL bIsActivated;
    
    if (bIsActivated = CPropertyPage::OnSetActive())
    {
        if (IsServiceInfoUpdated(*m_pUpdateHint) && !RefreshCtrls()) 
        {
            AbortPageIfNecessary(); // display error...
        }    
    }

    return bIsActivated; 

}


BOOL CServerPropertyPageProducts::RefreshCtrls()

/*++

Routine Description:

    Refreshs property page controls.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed successfully.

--*/

{
    VALIDATE_OBJECT(m_pServer, CServer);

    BOOL bIsRefreshed = FALSE;

    VARIANT va;
    VariantInit(&va);

    BeginWaitCursor(); // hourglass...

    CServices* pServices = (CServices*)MKOBJ(m_pServer->GetServices(va));

    if (pServices)
    {
        VALIDATE_OBJECT(pServices, CServices);

        bIsRefreshed = ::LvRefreshObArray(        
                            &m_productList, 
                            &g_productColumnInfo, 
                            pServices->m_pObArray
                            );

        pServices->InternalRelease(); // add ref'd individually...
    }

    if (!bIsRefreshed)
    {
        ::LvReleaseObArray(&m_productList); // reset list now...
    }

    EndWaitCursor(); // hourglass...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);

    return bIsRefreshed;
}


void CServerPropertyPageProducts::OnEdit() 

/*++

Routine Description:

    View licensing mode of service.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CService* pService;

    if (pService = (CService*)::LvGetSelObj(&m_productList))
    {
        VALIDATE_OBJECT(pService, CService);

        CLicensingModeDialog lmodDlg;
        lmodDlg.InitDialog(pService);
        lmodDlg.DoModal();

        *m_pUpdateHint |= lmodDlg.m_fUpdateHint;

        if (IsUpdateAborted(lmodDlg.m_fUpdateHint))
        {
            AbortPage(); // don't display error...
        }
        else if (IsServiceInfoUpdated(lmodDlg.m_fUpdateHint) && !RefreshCtrls())
        {
            AbortPageIfNecessary(); // display error...
        }
    }
}


void CServerPropertyPageProducts::OnDblClkProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_DBLCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnEdit();
    *pResult = 0;
}


void CServerPropertyPageProducts::OnReturnProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for NM_RETURN.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    OnEdit();
    *pResult = 0;
}


void CServerPropertyPageProducts::OnSetFocusProducts(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_SETFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


void CServerPropertyPageProducts::OnKillFocusProducts(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_KILLFOCUS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    ::LvSelObjIfNecessary(&m_productList); // ensure selection...

    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    *pResult = 0;
}


BOOL CServerPropertyPageProducts::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRLS)
    {
        if (!m_bAreCtrlsInitialized)
        {
            InitCtrls();  
         
            if (!RefreshCtrls())
            {
                AbortPageIfNecessary(); // display error...
            }
        }
        
        ::SafeEnableWindow(
            &m_edtBtn,
            &m_productList,
            CDialog::GetFocus(),
            m_productList.GetItemCount() 
            );

        return TRUE; // processed...
    }
        
    return CDialog::OnCommand(wParam, lParam);
}


void CServerPropertyPageProducts::OnColumnClickProducts(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

    Notification handler for LVN_COLUMNCLICK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    g_productColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
    g_productColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

    m_productList.SortItems(CompareServerProducts, 0); // use column info

    *pResult = 0;
}


void CServerPropertyPageProducts::OnGetDispInfoProducts(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for LVN_GETDISPINFO.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{                   
    CString strLabel;
    LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;

    CService* pService = (CService*)plvItem->lParam;
    VALIDATE_OBJECT(pService, CService);

    switch (plvItem->iSubItem)
    {
    case LVID_PRODUCT:              
    {
        plvItem->iImage = pService->IsPerServer() ? BMPI_PRODUCT_PER_SERVER : BMPI_PRODUCT_PER_SEAT;
        BSTR bstrServiceName = pService->GetDisplayName();
        lstrcpyn(plvItem->pszText, bstrServiceName, plvItem->cchTextMax);
        SysFreeString(bstrServiceName);
    }
        break;

    case LVID_LICENSING_MODE:       
        strLabel.LoadString(pService->IsPerServer() ? IDS_PER_SERVER : IDS_PER_SEAT);         
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
        break;

    case LVID_LICENSES_PURCHASED:
        if (pService->IsPerServer())
        {
            strLabel.Format(_T("%ld"), pService->GetPerServerLimit());         
        }
        else
        {
            strLabel.LoadString(IDS_NOT_APPLICABLE);
        }
        lstrcpyn(plvItem->pszText, strLabel, plvItem->cchTextMax);
        break;
    }

    *pResult = 0;
}


int CALLBACK CompareServerProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

    Notification handler for LVM_SORTITEMS.

Arguments:

    lParam1 - object to sort.
    lParam2 - object to sort.
    lParamSort - sort criteria.

Return Values:

    Same as lstrcmp.

--*/

{
#define pService1 ((CService*)lParam1)
#define pService2 ((CService*)lParam2)

    VALIDATE_OBJECT(pService1, CService);
    VALIDATE_OBJECT(pService2, CService);

    int iResult;

    switch (g_productColumnInfo.nSortedItem)
    {
    case LVID_PRODUCT:              
        iResult = pService1->m_strName.CompareNoCase(pService2->m_strName);
        break;

    case LVID_LICENSING_MODE:       
        iResult = (DWORD)pService1->IsPerServer() - (DWORD)pService2->IsPerServer();
        break;

    case LVID_LICENSES_PURCHASED:
        iResult = pService1->GetPerServerLimit() - pService2->GetPerServerLimit();
        break;

    default:
        iResult = 0;
        break;
    }

    return g_productColumnInfo.bSortOrder ? -iResult : iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvpsht.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvpsht.h

Abstract:

    Server property sheet implementation.

Author:

    Don Ryan (donryan) 17-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
       o  Added definition for DoModal() to facilitate in keeping the
          replication property page from saving whenever it lost focus.

    Jeff Parham (jeffparh) 28-Feb-1996
       o  Removed DoModal() override as it is no longer needed (and in
          fact breaks) under MFC4.

--*/

#ifndef _SRVPSHT_H_
#define _SRVPSHT_H_

#include "srvppgr.h"
#include "srvppgp.h"

class CServerPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CServerPropertySheet)
private:
    CServerPropertyPageReplication m_replPage;
    CServerPropertyPageProducts    m_productPage;

public:
    DWORD m_fUpdateHint;

public:
    CServerPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CServerPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    virtual ~CServerPropertySheet();

    void InitPages(CServer* pServer);

    //{{AFX_VIRTUAL(CServerPropertySheet)
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CServerPropertySheet)
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SRVPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvpsht.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvpsht.cpp

Abstract:

    Server property sheet implementation.

Author:

    Don Ryan (donryan) 17-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
       o  Added definition for DoModal() to facilitate in keeping the
          replication property page from saving whenever it lost focus.

    Jeff Parham (jeffparh) 28-Feb-1996
       o  Removed DoModal() override as it is no longer needed (and in
          fact breaks) under MFC4.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "srvpsht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CServerPropertySheet, CPropertySheet)

BEGIN_MESSAGE_MAP(CServerPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CServerPropertySheet)
    ON_COMMAND(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CServerPropertySheet::CServerPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for property sheet.

Arguments:

    nIDCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CServerPropertySheet::CServerPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)

/*++

Routine Description:

    Constructor for property sheet.

Arguments:

    pszCaption - window caption.
    pParentWnd - parent window handle.
    iSelectPage - initial page selected.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_NONE;
}


CServerPropertySheet::~CServerPropertySheet()

/*++

Routine Description:

    Destructor for property sheet.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServerPropertySheet::InitPages(CServer* pServer)

/*++

Routine Description:

    Initializes property pages.

Arguments:

    pServer - server object.

Return Values:

    None.

--*/

{
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    AddPage(&m_productPage);
    m_productPage.InitPage(pServer, &m_fUpdateHint);

    AddPage(&m_replPage);
    m_replPage.InitPage(pServer);   // no update needed...
}


void CServerPropertySheet::OnHelp()

/*++

Routine Description:

    Help button support.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CPropertySheet::OnCommandHelp(0, 0L);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvppgr.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvppgr.cpp

Abstract:

    Server property page (repl) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Chandana Surlu 05-Apr-1995 Redid the replication dialog (mostly modeled after liccpa.cpl)

    JeffParh (jeffparh) 16-Dec-1996
       o  Disallowed server as own enterprise server.
       o  Changed "Start At" to use locale info for time format rather than
          private registry settings.  Merged OnClose() functionality into
          OnKillActive().
       o  Added warning of possible license loss when changing replication
          target server.
       o  No longer automatically saves when page is flipped.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "srvppgr.h"

extern "C"
{
#include <lmcons.h>
#include <icanon.h>
}   

#ifndef WS_EX_CLIENTEDGE
#define WS_EX_CLIENTEDGE 0x00000200L
#endif // WS_EX_CLIENTEDGE

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServerPropertyPageReplication, CPropertyPage)

BEGIN_MESSAGE_MAP(CServerPropertyPageReplication, CPropertyPage)
    //{{AFX_MSG_MAP(CServerPropertyPageReplication)
    ON_BN_CLICKED(IDC_PP_SERVER_REPLICATION_AT, OnAt)
    ON_BN_CLICKED(IDC_PP_SERVER_REPLICATION_DC, OnDc)
    ON_BN_CLICKED(IDC_PP_SERVER_REPLICATION_ESRV, OnEsrv)
    ON_BN_CLICKED(IDC_PP_SERVER_REPLICATION_EVERY, OnEvery)
    ON_WM_CTLCOLOR()
    ON_LBN_SETFOCUS(IDC_PP_SERVER_REPLICATION_AT_AMPM, OnSetfocusAmpm)
    ON_LBN_KILLFOCUS(IDC_PP_SERVER_REPLICATION_AT_AMPM, OnKillfocusAmpm)
    ON_EN_KILLFOCUS(IDC_PP_SERVER_REPLICATION_AT_HOUR, OnKillFocusHour)
    ON_EN_SETFOCUS(IDC_PP_SERVER_REPLICATION_AT_HOUR, OnSetFocusHour)
    ON_EN_KILLFOCUS(IDC_PP_SERVER_REPLICATION_AT_MINUTE, OnKillFocusMinute)
    ON_EN_SETFOCUS(IDC_PP_SERVER_REPLICATION_AT_MINUTE, OnSetFocusMinute)
    ON_EN_SETFOCUS(IDC_PP_SERVER_REPLICATION_AT_SECOND, OnSetFocusSecond)
    ON_EN_KILLFOCUS(IDC_PP_SERVER_REPLICATION_AT_SECOND, OnKillFocusSecond)
    ON_EN_SETFOCUS(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, OnSetfocusEvery)
    ON_EN_KILLFOCUS(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, OnKillfocusEvery)
    ON_EN_UPDATE(IDC_PP_SERVER_REPLICATION_ESRV_NAME, OnUpdateEsrvName)
    ON_EN_UPDATE(IDC_PP_SERVER_REPLICATION_AT_HOUR, OnUpdateAtHour)
    ON_EN_UPDATE(IDC_PP_SERVER_REPLICATION_AT_MINUTE, OnUpdateAtMinute)
    ON_EN_UPDATE(IDC_PP_SERVER_REPLICATION_AT_SECOND, OnUpdateAtSecond)
    ON_EN_UPDATE(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, OnUpdateEveryValue)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CServerPropertyPageReplication::CServerPropertyPageReplication() 
    : CPropertyPage(CServerPropertyPageReplication::IDD)

/*++

Routine Description:

    Constructor for server properties (replication).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CServerPropertyPageReplication)
    //}}AFX_DATA_INIT

    m_pServer   = NULL;

    m_bReplAt  = FALSE;
    m_bUseEsrv = FALSE;
    m_bOnInit =  TRUE;
    m_nHourMax = HOUR_MAX_24;
    m_nHourMin = HOUR_MIN_24;
}


CServerPropertyPageReplication::~CServerPropertyPageReplication()

/*++

Routine Description:

    Destructor for server properties (replication).

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServerPropertyPageReplication::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerPropertyPageReplication)
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_EVERY_VALUE, m_everyEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_ESRV_NAME, m_esrvEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT, m_atBtn);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_EVERY, m_everyBtn);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_DC, m_dcBtn);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_ESRV, m_esrvBtn);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_SPIN_AT, m_spinAt);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_SPIN_EVERY, m_spinEvery);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_BORDER, m_atBorderEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_SEP1, m_atSep1Edit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_SEP2, m_atSep2Edit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_HOUR, m_atHourEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_MINUTE, m_atMinEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_SECOND, m_atSecEdit);
    DDX_Control(pDX, IDC_PP_SERVER_REPLICATION_AT_AMPM, m_atAmPmEdit);
    //}}AFX_DATA_MAP
}


void CServerPropertyPageReplication::InitPage(CServer* pServer)

/*++

Routine Description:

    Initializes server property page (replication).

Arguments:

    pServer - server object.

Return Values:

    None.

--*/

{
    ASSERT_VALID(pServer);
    m_pServer = pServer;
}


BOOL CServerPropertyPageReplication::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BeginWaitCursor();

    GetProfile();
    
    CPropertyPage::OnInitDialog();

    if (!m_bIsMode24)
    {
        m_atAmPmEdit.InsertString(0, m_str1159);
        m_atAmPmEdit.InsertString(1, m_str2359);
        m_atAmPmEdit.InsertString(2, TEXT(""));      // fake it for the 24 hour mode
    }
    // Do the edit text limits
    m_everyEdit.LimitText(2);
    m_esrvEdit.LimitText(MAX_PATH);   // we'll eat up the \\ chars
    m_atHourEdit.LimitText(2);
    m_atMinEdit.LimitText(2);
    m_atSecEdit.LimitText(2);

    m_spinEvery.SetRange(INTERVAL_MIN, INTERVAL_MAX);

    if (Refresh())
    {
        // UpdateData(FALSE);
    }
    else
    {
        theApp.DisplayLastStatus();
    }

    m_atBorderEdit.ModifyStyleEx(0, WS_EX_CLIENTEDGE, SWP_DRAWFRAME);    

    if (m_bReplAt)
        m_atHourEdit.SetFocus();
    else
        m_everyEdit.SetFocus();

    if ( m_pServer->IsWin2000() )
    {
        m_esrvEdit.EnableWindow(FALSE);
        m_dcBtn.EnableWindow(FALSE);
        m_esrvBtn.EnableWindow(FALSE);

        CWnd * pWndMasterGB = GetDlgItem( IDC_PP_SERVER_REPLICATION_MASTER_GB );

        ASSERT( pWndMasterGB != NULL );

        if (pWndMasterGB != NULL)
        {
            pWndMasterGB->EnableWindow(FALSE);
        }
    }
    else
    {
        if (m_bUseEsrv)
            m_esrvEdit.SetFocus();
    }

    m_bOnInit = FALSE;


    EndWaitCursor();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CServerPropertyPageReplication::Refresh() 

/*++

Routine Description:

    Refreshs property page.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    if (m_bReplAt = m_pServer->IsReplicatingDaily())
    {
        DWORD dwTemp = m_pServer->GetReplicationTime();
        m_nHour = dwTemp / (60 * 60);
        m_nMinute = (dwTemp - (m_nHour * 60 * 60)) / 60;
        m_nSecond = dwTemp - (m_nHour * 60 * 60) - (m_nMinute * 60);
        m_nStartingHour = DEFAULT_EVERY;   // When the every button is selected, we always show the default.

        if (!m_bIsMode24)
        { // it's in 12 hour format
            if (m_nHour > 12)
            {
                m_bPM = TRUE;
                m_nHour -= 12;
            }
            else if (m_nHour == 12)
            {
                m_bPM = TRUE;
            }
            else
            {
                if (m_nHour == 0)
                    m_nHour = m_nHourMax;
                m_bPM = FALSE;
            }
        }
    }
    else
    {
        m_nStartingHour = m_pServer->GetReplicationTime() / 3600;
        if (!m_bIsMode24)
        // it's in 12 hour format
            m_nHour  = m_nHourMax;
        else
            m_nHour  = m_nHourMin;
        m_nMinute = MINUTE_MIN;
        m_nSecond = SECOND_MIN;
        m_bPM = FALSE;
    }


    m_bUseEsrv = !m_pServer->IsReplicatingToDC();
    
    if (m_bReplAt)
    {
        OnAt();
    }
    else
    {
        OnEvery();
    }

    if (m_bUseEsrv)
    {
        BSTR bstrEnterpriseServer = m_pServer->GetController();
        m_strEnterpriseServer = bstrEnterpriseServer;
        SysFreeString(bstrEnterpriseServer);
        OnEsrv();
    }
    else
    {
        OnDc();
    }

    return TRUE;
}


void CServerPropertyPageReplication::OnAt() 

/*++

Routine Description:

    Enables LLS_REPLICATION_TYPE_TIME controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    // change time edit control bg color
    m_atBorderEdit.Invalidate();
    m_atBorderEdit.UpdateWindow();
    m_atSep1Edit.Invalidate();
    m_atSep1Edit.UpdateWindow();
    m_atSep2Edit.Invalidate();
    m_atSep2Edit.UpdateWindow();

    if (!m_bOnInit) SetModified(TRUE);
    m_bReplAt = TRUE; 
    m_atBtn.SetCheck(TRUE);
    m_everyBtn.SetCheck(FALSE);

    TCHAR szTemp[3];

    if (m_bIsHourLZ)
    {
        wsprintf(szTemp, TEXT("%02u"), m_nHour);
        szTemp[2] = NULL;
        SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_HOUR, szTemp);
    }
    else
        SetDlgItemInt(IDC_PP_SERVER_REPLICATION_AT_HOUR, m_nHour);

    wsprintf(szTemp, TEXT("%02u"), m_nMinute);
    szTemp[2] = NULL;
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_MINUTE, szTemp);

    wsprintf(szTemp, TEXT("%02u"), m_nSecond);
    szTemp[2] = NULL;
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SECOND, szTemp);

    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SEP1, m_strSep1);
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SEP2, m_strSep1);

    if (m_bPM)
        m_atAmPmEdit.SetTopIndex(1);
    else
        m_atAmPmEdit.SetTopIndex(0);

    SetDlgItemText(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, TEXT(""));

    m_everyEdit.EnableWindow(FALSE);
    m_spinEvery.EnableWindow(FALSE);

    m_atHourEdit.EnableWindow(TRUE);
    m_atMinEdit.EnableWindow(TRUE);
    m_atSecEdit.EnableWindow(TRUE);
    m_spinAt.EnableWindow(TRUE);

    if ( m_bIsMode24 )
    {
       m_atAmPmEdit.ShowWindow( SW_HIDE );
    }
    else
    {
       m_atAmPmEdit.ShowWindow( SW_SHOWNOACTIVATE );
       m_atAmPmEdit.EnableWindow( TRUE );
    }

    m_atBtn.SetFocus();
}


void CServerPropertyPageReplication::OnEvery() 

/*++

Routine Description:

    Enables LLS_REPLICATION_TYPE_DELTA controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    // change time edit control bg color
    m_atBorderEdit.Invalidate();
    m_atBorderEdit.UpdateWindow();
    m_atSep1Edit.Invalidate();
    m_atSep1Edit.UpdateWindow();
    m_atSep2Edit.Invalidate();
    m_atSep2Edit.UpdateWindow();

    if (!m_bOnInit) SetModified(TRUE);
    m_bReplAt = FALSE;
    m_atBtn.SetCheck(FALSE);
    m_everyBtn.SetCheck(TRUE);

    SetDlgItemInt(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, m_nStartingHour);
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_HOUR, TEXT(""));
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_MINUTE, TEXT(""));
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SECOND, TEXT(""));
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SEP1, TEXT(""));
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SEP2, TEXT(""));
    m_atAmPmEdit.SetTopIndex(2);       // Have to fake this

    m_atHourEdit.EnableWindow(FALSE);
    m_atMinEdit.EnableWindow(FALSE);
    m_atSecEdit.EnableWindow(FALSE);
    m_spinAt.EnableWindow(FALSE);
    m_atAmPmEdit.EnableWindow(FALSE);
    m_atAmPmEdit.ShowWindow( SW_HIDE );

    m_everyEdit.EnableWindow(TRUE);
    m_spinEvery.EnableWindow(TRUE);
    m_everyBtn.SetFocus();
}


void CServerPropertyPageReplication::OnDc() 

/*++

Routine Description:

    Enables LLS_REPLICATION_TYPE_DELTA controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
    m_bUseEsrv = FALSE;
    m_dcBtn.SetCheck(TRUE);
    m_esrvBtn.SetCheck(FALSE);
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_ESRV_NAME, TEXT(""));
    m_esrvEdit.EnableWindow(FALSE);
    m_dcBtn.SetFocus();
}


void CServerPropertyPageReplication::OnEsrv() 

/*++

Routine Description:

    Enables LLS_REPLICATION_TYPE_DELTA controls.

Arguments:

    None.

Return Values:

    None.

--*/

{    
    if (!m_bOnInit) SetModified(TRUE);
    m_bUseEsrv = TRUE;
    m_dcBtn.SetCheck(FALSE);
    m_esrvBtn.SetCheck(TRUE);
    m_esrvEdit.EnableWindow(TRUE);
    SetDlgItemText(IDC_PP_SERVER_REPLICATION_ESRV_NAME, m_strEnterpriseServer);
    m_esrvBtn.SetFocus();
}


BOOL CServerPropertyPageReplication::OnKillActive()

/*++

Routine Description:

    Process property page (replication).

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    short nID;
    BOOL fBeep = TRUE;

    if ( EditValidate(&nID, &fBeep))
    {
        return TRUE;
    }
    else
    {   
        EditInvalidDlg(fBeep);
        return FALSE;
    }
}


HBRUSH CServerPropertyPageReplication::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 

/*++

Routine Description:

    Message handler for WM_CTLCOLOR.

Arguments:

    pDC - device context.
    pWnd - control window.
    nCtlColor - color selected.

Return Values:

    Brush of background color.

--*/

{
    if (    ( m_atBtn.GetCheck()             )
         && (    ( pWnd == &m_atSep1Edit   )
              || ( pWnd == &m_atSep2Edit   )
              || ( pWnd == &m_atBorderEdit ) ) )
    {
        return (HBRUSH)DefWindowProc(WM_CTLCOLOREDIT, (WPARAM)pDC->GetSafeHdc(), (LPARAM)pWnd->GetSafeHwnd());
    }
    else
    {
        return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
    }
}


void CServerPropertyPageReplication::GetProfile()

/*++

Routine Description:

    Loads international config info.

Arguments:

    None.

Return Values:

    None..

--*/

{
    int     cch;
    int     cchBuffer;
    LPTSTR  pszBuffer;
    TCHAR   szValue[ 2 ];

    // defaults in case of memory allocation failure
    m_strSep1   = TEXT( ":" );
    m_strSep2   = TEXT( ":" );
    m_str1159   = TEXT( "AM" );
    m_str2359   = TEXT( "PM" );
    m_bIsMode24 = FALSE;
    m_bIsHourLZ = FALSE;

    // time seperator
    cchBuffer = 16;
    pszBuffer = m_strSep1.GetBuffer( cchBuffer );
    ASSERT( NULL != pszBuffer );

    if ( NULL != pszBuffer )
    {
        cch = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, pszBuffer, cchBuffer );
        m_strSep1.ReleaseBuffer();
        ASSERT( cch > 0 );
        m_strSep2 = m_strSep1;
    }

    // AM string
    cchBuffer = 16;
    pszBuffer = m_str1159.GetBuffer( cchBuffer );
    ASSERT( NULL != pszBuffer );

    if ( NULL != pszBuffer )
    {
        cch = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S1159, pszBuffer, cchBuffer );
        m_str1159.ReleaseBuffer();
        ASSERT( cch > 0 );
    }

    // PM string
    cchBuffer = 16;
    pszBuffer = m_str2359.GetBuffer( cchBuffer );
    ASSERT( NULL != pszBuffer );

    if ( NULL != pszBuffer )
    {
        cch = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_S2359, pszBuffer, cchBuffer );
        m_str2359.ReleaseBuffer();
        ASSERT( cch > 0 );
    }

    // Leading zero for hours?
    cch = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_ITLZERO, szValue, sizeof( szValue ) / sizeof( TCHAR ) );
    ASSERT( cch > 0 );

    if ( cch > 0 )
    {
        m_bIsHourLZ = _wtoi( szValue );    
    }

    // time format; 0 = AM/PM, 1 = 24hr
    cch = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_ITIME, szValue, sizeof( szValue ) / sizeof( TCHAR ) );
    ASSERT( cch > 0 );

    if ( cch > 0 )
    {
        m_bIsMode24 = _wtoi( szValue );    
    }

    if (!m_bIsMode24)
    {
        m_nHourMax = HOUR_MAX_12;
        m_nHourMin = HOUR_MIN_12;
    }

    if ( NULL == pszBuffer )
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
    }
}


void CServerPropertyPageReplication::OnSetfocusAmpm() 

/*++

Routine Description:

    Message handler for Listbox control IDC_PP_SERVER_REPLICATION_AT_AMPM on message LBN_SETFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
    m_spinAt.SetRange(0, 1);
    m_spinAt.SetBuddy(&m_atAmPmEdit); 
}


void CServerPropertyPageReplication::OnKillfocusAmpm()

/*++

Routine Description:

    Message handler for Listbox control IDC_PP_SERVER_REPLICATION_AT_AMPM on message LBN_KILLFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    m_atAmPmEdit.SetCurSel(-1);
    
    //if (m_spinAt.GetBuddy() == &m_atAmPmEdit)
    //    m_spinAt.SendMessage(UDM_SETBUDDY, 0, 0);
}


void CServerPropertyPageReplication::OnSetFocusHour()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_HOUR on message EN_SETFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
    m_spinAt.SetRange(m_bIsMode24 ? 0 :1, m_bIsMode24 ? 23 : 12);
    m_spinAt.SetBuddy(&m_atHourEdit);
}


void CServerPropertyPageReplication::OnKillFocusHour()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_HOUR on message EN_KILLFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
   // if (m_spinAt.GetBuddy() == &m_atHourEdit)
   //     m_spinAt.SendMessage(UDM_SETBUDDY, 0, 0);
}


void CServerPropertyPageReplication::OnSetFocusMinute()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_MINUTE on message EN_SETFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
    m_spinAt.SetRange(0, 59);
    m_spinAt.SetBuddy(&m_atMinEdit); 
}


void CServerPropertyPageReplication::OnKillFocusMinute()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_MINUTE on message EN_KILLFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
  //  if (m_spinAt.GetBuddy() == &m_atMinEdit)
   //     m_spinAt.SendMessage(UDM_SETBUDDY, 0, 0);
}


void CServerPropertyPageReplication::OnSetFocusSecond()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_SECOND on message EN_SETFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
    m_spinAt.SetRange(0, 59);
    m_spinAt.SetBuddy(&m_atSecEdit);
}


void CServerPropertyPageReplication::OnKillFocusSecond()

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_SECOND on message EN_KILLFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
  //  if (m_spinAt.GetBuddy() == &m_atSecEdit)
  //      m_spinAt.SendMessage(UDM_SETBUDDY, 0, 0);
}

void CServerPropertyPageReplication::OnSetfocusEvery() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_EVERY_VALUE on message EN_SETFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
    if (!m_bOnInit) SetModified(TRUE);
}

void CServerPropertyPageReplication::OnKillfocusEvery() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_EVERY_VALUE on message EN_KILLFOCUS.

Arguments:

    None.

Return Values:

    None..

--*/

{
   // if (m_spinEvery.GetBuddy() == &m_everyEdit)
   //     m_spinEvery.SendMessage(UDM_SETBUDDY, 0, 0);
}

void CServerPropertyPageReplication::OnUpdateEsrvName() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_ESRV_NAME on message EN_UPDATE

Arguments:

    None.

Return Values:

    None..

--*/

{
  
    TCHAR szName[MAX_PATH + 3]; // MAX_PATH + 2 \ char's + null
    UINT nValue;
    if (!m_bOnInit) SetModified(TRUE);

    nValue = GetDlgItemText(IDC_PP_SERVER_REPLICATION_ESRV_NAME,  szName, MAX_PATH +3);
    szName[nValue] = NULL;

    if (!(wcsncmp(szName, TEXT("\\\\"), 2)))
        SetDlgItemText(IDC_PP_SERVER_REPLICATION_ESRV_NAME, szName + 2);
}

void CServerPropertyPageReplication::OnUpdateAtHour() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_HOUR on message EN_UPDATE

Arguments:

    None.

Return Values:

    None..

--*/

{

    TCHAR szNum[3];
    UINT nValue;
    short i;
    int iVal;
    BOOL fOk = TRUE;
    if (!m_bOnInit) SetModified(TRUE);
    
    nValue = GetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_HOUR, szNum, sizeof(szNum) / sizeof( TCHAR ));

    for (i=0;szNum[i];i++)
        if(!_istdigit(szNum[i]))
            fOk = FALSE;

    if (fOk)
    {
        iVal = _wtoi(szNum);

        if (!nValue)
        {
            if (m_bIsMode24)
            {
                m_nHour = 0;
                m_bPM = FALSE;
            }
            else
            {
                m_nHour = m_nHourMax;
                m_bPM = FALSE;
            }
        }
        else if ((iVal < (int)m_nHourMin) || (iVal > (int)m_nHourMax))
            fOk = FALSE;
    }

    if (!fOk)
        m_atHourEdit.Undo();
}

void CServerPropertyPageReplication::OnUpdateAtMinute() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_MINUTE on message EN_UPDATE

Arguments:

    None.

Return Values:

    None..

--*/

{

    TCHAR szNum[3];
    UINT nValue;
    short i;
    int iVal;
    BOOL fOk = TRUE;
    if (!m_bOnInit) SetModified(TRUE);
    
    nValue = GetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_MINUTE, szNum, sizeof(szNum) / sizeof( TCHAR ));

    for (i=0;szNum[i];i++)
        if(!_istdigit(szNum[i]))
            fOk = FALSE;

    if (fOk)
    {
        iVal = _wtoi(szNum);

        if (!nValue)
        {
            m_nSecond = MINUTE_MIN;
        }
        else if ((iVal < MINUTE_MIN) || (iVal > MINUTE_MAX))
            fOk = FALSE;
    }

    if (!fOk)
        m_atMinEdit.Undo();
}

void CServerPropertyPageReplication::OnUpdateAtSecond() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_AT_SECOND on message EN_UPDATE

Arguments:

    None.

Return Values:

    None..

--*/

{

    TCHAR szNum[3];
    UINT nValue;
    short i;
    int iVal;
    BOOL fOk = TRUE;
    if (!m_bOnInit) SetModified(TRUE);
    
    nValue = GetDlgItemText(IDC_PP_SERVER_REPLICATION_AT_SECOND, szNum, sizeof(szNum) / sizeof( TCHAR ));

    for (i=0;szNum[i];i++)
        if(!_istdigit(szNum[i]))
            fOk = FALSE;

    if (fOk)
    {
        iVal = _wtoi(szNum);

        if (!nValue)
        {
            m_nSecond = SECOND_MIN;
        }
        else if ((iVal < SECOND_MIN) || (iVal > SECOND_MAX))
            fOk = FALSE;
    }

    if (!fOk)
        m_atSecEdit.Undo();
}

void CServerPropertyPageReplication::OnUpdateEveryValue() 

/*++

Routine Description:

    Message handler for Edit control IDC_PP_SERVER_REPLICATION_EVERY_VALUE on message EN_UPDATE

Arguments:

    None.

Return Values:

    None..

--*/

{
    TCHAR szNum[3];
    UINT nValue;
    short i;
    int iVal;
    BOOL fOk = TRUE;
    if (!m_bOnInit) SetModified(TRUE);
    
    nValue = GetDlgItemText(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, szNum, sizeof(szNum) / sizeof( TCHAR ));

    for (i=0;szNum[i];i++)
        if(!_istdigit(szNum[i]))
            fOk = FALSE;

    if (fOk)
    {
        iVal = _wtoi(szNum);
        if (!nValue)
        {
            m_nStartingHour = DEFAULT_EVERY;
        }
        else if (iVal < 9)
        {
            m_nStartingHour = (DWORD) iVal;
        }
        else if ((iVal < INTERVAL_MIN) || (iVal > INTERVAL_MAX))
            fOk = FALSE;
        else
            m_nStartingHour = (DWORD) iVal;
    }

    if (!fOk)
        m_everyEdit.Undo();
}


BOOL CServerPropertyPageReplication::EditValidate(short *pnID, BOOL *pfBeep)
/*++

Routine Description:

    Validate all edit & other fields.

Arguments:

    None.

Return Values:

    short *pnID   Pass back the bad ID
    BOOL  *pfBeep Whether to Beep  

--*/

{
    UINT nValue;
    BOOL fValid = FALSE;
    TCHAR szTemp[MAX_PATH + 1];
    DWORD NumberOfHours, SecondsinHours;

    *pfBeep = TRUE;

    // only do this if license info is replicated to an ES

    do {
        if (m_esrvBtn.GetCheck())
        {
            if ( m_pServer->IsReplicatingToDC() )
            {
                // the user has changed the "UseEnterprise" value from "no" to "yes";
                // warn of possible license loss
                int     nButton;
                CString strMessage;

                AfxFormatString1( strMessage, IDP_CONFIRM_USE_ENTERPRISE, m_pServer->m_strName );
                
                nButton = AfxMessageBox( strMessage, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, IDP_CONFIRM_USE_ENTERPRISE );

                if ( IDYES != nButton )
                {
                    *pnID = IDC_PP_SERVER_REPLICATION_ESRV;
                    *pfBeep = FALSE;
                    fValid = FALSE;
                    m_esrvBtn.SetFocus();
                    break;
                }
            }

            nValue = GetDlgItemText( IDC_PP_SERVER_REPLICATION_ESRV_NAME, szTemp, MAX_PATH + 1);

            if (nValue == 0)
            {
                if ( m_pServer->IsWin2000() )
                {
                    // It is ok for Enterprise Server to be blank
                    fValid = TRUE;
                    szTemp[nValue] = UNICODE_NULL;
                    // 375761 JonN 8/9/99 do not break here, this is not an error
                }
                else
                {
                    *pnID = IDC_PP_SERVER_REPLICATION_ESRV_NAME;
                    m_esrvEdit.SetFocus();
                    m_esrvEdit.SetSel(MAKELONG(0, -1), FALSE);
                    break;
                }
            }
            else
            {
                fValid = TRUE; // we got a name, assume valid

                // 375761 JonN 8/9/99 moved this stuff into this "else"
                if (nValue > MAX_PATH)
                    nValue = MAX_PATH;

                // Validate server name
                if (I_NetNameValidate(NULL, szTemp, NAMETYPE_COMPUTER, LM2X_COMPATIBLE) != ERROR_SUCCESS)
                {
                    AfxMessageBox(IDP_ERROR_INVALID_COMPUTERNAME, MB_OK|MB_ICONSTOP);
                    *pnID = IDC_PP_SERVER_REPLICATION_ESRV_NAME;
                    *pfBeep = FALSE;
                    fValid = FALSE;
                    m_esrvEdit.SetFocus();
                    m_esrvEdit.SetSel(MAKELONG(0, -1), FALSE);
                    break;
                }

                ASSERT_VALID( m_pServer );
                if ( !m_pServer->m_strName.CompareNoCase( szTemp ) )
                {
                    // can't replicate to yourself
                    AfxMessageBox(IDP_ERROR_NO_SELF_REPLICATION, MB_OK|MB_ICONSTOP);
                    *pnID = IDC_PP_SERVER_REPLICATION_ESRV_NAME;
                    *pfBeep = FALSE;
                    fValid = FALSE;
                    m_esrvEdit.SetFocus();
                    m_esrvEdit.SetSel(MAKELONG(0, -1), FALSE);
                    break;
                }

                if ( m_strEnterpriseServer.CompareNoCase( szTemp ) && !m_pServer->IsReplicatingToDC() )
                {
                    // this server was already set to replicate to an enterprise server,
                    // but the user has changed the name of the enterprise server;
                    // warn of possible license loss
                    int     nButton;
                    CString strMessage;

                    AfxFormatString1( strMessage, IDP_CONFIRM_ENTERPRISE_CHANGE, m_pServer->m_strName );
                
                    nButton = AfxMessageBox( strMessage, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, IDP_CONFIRM_ENTERPRISE_CHANGE );

                    if ( IDYES != nButton )
                    {
                        *pnID = IDC_PP_SERVER_REPLICATION_ESRV_NAME;
                        *pfBeep = FALSE;
                        fValid = FALSE;
                        m_esrvEdit.SetFocus();
                        m_esrvEdit.SetSel(MAKELONG(0, -1), FALSE);
                        break;
                    }
                }
            }

            m_strEnterpriseServer = szTemp;
            m_bUseEsrv = TRUE;
        }
        else
        {
            if ( !m_pServer->IsReplicatingToDC() )
            {
                // the user has changed the "UseEnterprise" value from "yes" to "no";
                // warn of possible license loss
                int     nButton;
                CString strMessage;

                AfxFormatString1( strMessage, IDP_CONFIRM_NOT_USE_ENTERPRISE, m_pServer->m_strName );
                
                nButton = AfxMessageBox( strMessage, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, IDP_CONFIRM_NOT_USE_ENTERPRISE );

                if ( IDYES != nButton )
                {
                    *pnID = IDC_PP_SERVER_REPLICATION_ESRV;
                    *pfBeep = FALSE;
                    fValid = FALSE;
                    m_esrvBtn.SetFocus();
                    break;
                }
            }

            // Get rid of the Server Name.
            m_strEnterpriseServer = TEXT("");
            m_bUseEsrv = FALSE;
        }

        if (m_everyBtn.GetCheck())
        {
            nValue = GetDlgItemInt(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, &fValid, FALSE);
            *pnID = IDC_PP_SERVER_REPLICATION_EVERY_VALUE;
            if (fValid)
            {
                if (nValue < INTERVAL_MIN)
                {
                    fValid = FALSE;
                    m_nStartingHour = INTERVAL_MIN;
                    SetDlgItemInt(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, INTERVAL_MIN, FALSE);
                    m_everyEdit.SetFocus();
                    m_everyEdit.SetSel(MAKELONG(0, -1), FALSE);
                    break;
                }
                else if (nValue > INTERVAL_MAX)
                {
                    fValid = FALSE;
                    m_nStartingHour = INTERVAL_MAX;
                    SetDlgItemInt(IDC_PP_SERVER_REPLICATION_EVERY_VALUE, INTERVAL_MAX, FALSE);
                    m_everyEdit.SetFocus();
                    m_everyEdit.SetSel(MAKELONG(0, -1), FALSE);
                    break;
                }
                else
                    m_nStartingHour = nValue;
                    m_nReplicationTime = m_nStartingHour;
            }
            else
            {
                fValid = FALSE;
                m_everyEdit.SetFocus();
                m_everyEdit.SetSel(MAKELONG(0, -1), FALSE);
                break;
            }
            m_bReplAt = FALSE;
        }
        else
        {
            nValue = GetDlgItemInt(IDC_PP_SERVER_REPLICATION_AT_HOUR, &fValid, FALSE);
            if (fValid)
                 m_nHour = nValue;
            else
            {
                *pnID = IDC_PP_SERVER_REPLICATION_AT_HOUR;
                m_atHourEdit.SetFocus();
                m_atHourEdit.SetSel(MAKELONG(0, -1), FALSE);
                break;
            }

            nValue = GetDlgItemInt(IDC_PP_SERVER_REPLICATION_AT_MINUTE, &fValid, FALSE);
            if (fValid)
                 m_nMinute = nValue;
            else
            {
                *pnID = IDC_PP_SERVER_REPLICATION_AT_MINUTE;
                m_atMinEdit.SetFocus();
                m_atMinEdit.SetSel(MAKELONG(0, -1), FALSE);
                break;
            }

            nValue = GetDlgItemInt(IDC_PP_SERVER_REPLICATION_AT_SECOND, &fValid, FALSE);
            if (fValid)
                 m_nSecond = nValue;
            else
            {
                *pnID = IDC_PP_SERVER_REPLICATION_AT_SECOND;
                m_atSecEdit.SetFocus();
                m_atSecEdit.SetSel(MAKELONG(0, -1), FALSE);
                break;
            }

            if (!m_bIsMode24)
            {
                *pnID = IDC_PP_SERVER_REPLICATION_AT_AMPM;
                nValue = m_atAmPmEdit.GetTopIndex();
                if (nValue == 0) 
                {
                   m_bPM = FALSE;
                }
                else if (nValue == 1)
                {
                    m_bPM = TRUE;
                }
                else
                {
                    fValid = FALSE;
                    m_atAmPmEdit.SetFocus();
                    break;
                }
            }
            if (!m_bIsMode24)
            { // It's in 12 hour format
                if (m_bPM)
                {
                    NumberOfHours = 12 + m_nHour - ((m_nHour / 12) * 12);
                }
                else
                {
                    NumberOfHours = m_nHour - ((m_nHour / 12) * 12);
                }
            }
            else
            { // It's in 24 hour format
                NumberOfHours = m_nHour;
            }
            SecondsinHours = NumberOfHours * 60 * 60;
            m_nReplicationTime = SecondsinHours + (m_nMinute * 60) + m_nSecond; // Cheating. Use the same member
            m_bReplAt = TRUE;
        }


    } while(FALSE);

    return( fValid );
}

void CServerPropertyPageReplication::EditInvalidDlg(BOOL fBeep)

/*++

Routine Description:

    If any edit/listbox field has an invalid data item.

Arguments:

    BOOL fBeep Beep only if we haven't yet put up a MessageBox.

Return Values:

    None..

--*/

{
    if (fBeep)
        ::MessageBeep(MB_OK);
}

void CServerPropertyPageReplication::SaveReplicationParams()

/*++

Routine Description:

    Write to the remote registry.
    REG_VALUE_ENTERPRISE_SERVER   m_strEnterpriseServer
    REG_VALUE_USE_ENTERPRISE      m_bUseEsrv
    REG_VALUE_REPLICATION_TYPE    m_bReplAt
    REG_VALUE_REPLICATION_TIME    m_nReplicationTime

Arguments:

    None.

Return Values:

    None..

--*/

{   
    long Status;
    DWORD dwValue;

    ASSERT(m_bUseEsrv == m_esrvBtn.GetCheck());
    ASSERT(m_bReplAt == m_atBtn.GetCheck());

#ifdef CONFIG_THROUGH_REGISTRY
    do {

        dwValue = m_esrvBtn.GetCheck();
        Status = RegSetValueEx(m_pServer->GetReplRegHandle(),REG_VALUE_USE_ENTERPRISE,0,REG_DWORD,
                              (PBYTE)&dwValue, sizeof(DWORD));
        
        ASSERT(Status == ERROR_SUCCESS);
        if (Status != ERROR_SUCCESS) break;

        Status = RegSetValueEx(m_pServer->GetReplRegHandle(),   REG_VALUE_ENTERPRISE_SERVER, 0, REG_SZ,
                              (LPBYTE)MKSTR(m_strEnterpriseServer), (lstrlen(m_strEnterpriseServer) + 1) * sizeof(TCHAR));

        ASSERT(Status == ERROR_SUCCESS);
        if (Status != ERROR_SUCCESS) break;

        dwValue = m_atBtn.GetCheck();
        Status = RegSetValueEx(m_pServer->GetReplRegHandle(), REG_VALUE_REPLICATION_TYPE,0,REG_DWORD,
                              (PBYTE)&dwValue, sizeof(DWORD));

        ASSERT(Status == ERROR_SUCCESS);
        if (Status != ERROR_SUCCESS) break;

        dwValue = (m_bReplAt? m_nReplicationTime : (m_nStartingHour * 3600));
        Status = RegSetValueEx(m_pServer->GetReplRegHandle(), REG_VALUE_REPLICATION_TIME,0,REG_DWORD,
                              (PBYTE)&dwValue, sizeof(DWORD));
                           
        ASSERT(Status == ERROR_SUCCESS);
        if (Status != ERROR_SUCCESS) break;
    } while (FALSE);
#else
    if ( m_pServer->ConnectLls() )
    {
        LLS_SERVICE_INFO_0  ServiceInfo;

        ZeroMemory( &ServiceInfo, sizeof( ServiceInfo ) );

        ServiceInfo.UseEnterprise    = m_esrvBtn.GetCheck();
        ServiceInfo.EnterpriseServer = MKSTR(m_strEnterpriseServer);
        ServiceInfo.ReplicationType  = m_atBtn.GetCheck();
        ServiceInfo.ReplicationTime  =   ( LLS_REPLICATION_TYPE_TIME == ServiceInfo.ReplicationType )
                                       ? m_nReplicationTime
                                       : (m_nStartingHour * 3600);

        Status = ::LlsServiceInfoSet( m_pServer->GetLlsHandle(), 0, (LPBYTE) &ServiceInfo );
        LlsSetLastStatus( Status );

        if ( IsConnectionDropped( Status ) )
        {
            m_pServer->DisconnectLls();
        }
    }
    else
    {
        Status = LlsGetLastStatus();
    }
#endif

    if (Status != ERROR_SUCCESS)
    {
        theApp.DisplayStatus(Status);
    }
    else
    {
        SetModified(FALSE);
    }
}

void CServerPropertyPageReplication::OnOK()

/*++

Routine Description:

   Handler for Apply button.

Arguments:

   None.

Return Values:

   None.

--*/

{
   SaveReplicationParams();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvobj.cpp

Abstract:

    Server object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Modified to use LlsProductLicensesGet() to avoid race conditions in
           getting the correct number of concurrent licenses with secure products.
        o  Ported to LlsLocalService API to remove dependencies on configuration
           information being in the registry.

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include <lm.h>
#include <lmwksta.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServer, CCmdTarget)

BEGIN_MESSAGE_MAP(CServer, CCmdTarget)
    //{{AFX_MSG_MAP(CServer)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CServer, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CServer)
    DISP_PROPERTY_EX(CServer, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServer, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CServer, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServer, "Controller", GetController, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CServer, "IsLogging", IsLogging, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CServer, "IsReplicatingToDC", IsReplicatingToDC, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CServer, "IsReplicatingDaily", IsReplicatingDaily, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CServer, "ReplicationTime", GetReplicationTime, SetNotSupported, VT_I4)
    DISP_PROPERTY_PARAM(CServer, "Services", GetServices, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CServer, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CServer::CServer(CCmdTarget* pParent, LPCTSTR pName)

/*++

Routine Description:

    Constructor for server object.

Arguments:

    pParent - creator of object.
    pName - name of server.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CDomain)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);

    m_strName = pName;
    m_strController.Empty();

    m_pServices = NULL;
    m_serviceArray.RemoveAll();
    m_bServicesRefreshed = FALSE;

    m_hkeyRoot        = (HKEY)0L;
    m_hkeyLicense     = (HKEY)0L;
    m_hkeyReplication = (HKEY)0L;
   
    m_IsWin2000 = uninitialized;

    m_hLls = NULL;
}


CServer::~CServer()

/*++

Routine Description:

    Destructor for server object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pServices)
        m_pServices->InternalRelease();

#ifdef CONFIG_THROUGH_REGISTRY
    if (m_hkeyReplication)
        RegCloseKey(m_hkeyReplication);

    if (m_hkeyLicense)
        RegCloseKey(m_hkeyLicense);

    if (m_hkeyRoot)
        RegCloseKey(m_hkeyRoot);
#endif

    DisconnectLls();
}


void CServer::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetServices();
    delete this;
}


LPDISPATCH CServer::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


BSTR CServer::GetController()

/*++

Routine Description:

    Returns license controller for server.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    LONG Status;
    CString strValue = _T("");

    if (InitializeIfNecessary())
    {
#ifdef CONFIG_THROUGH_REGISTRY
        TCHAR szValue[256];

        DWORD dwType = REG_SZ;
        DWORD dwSize = sizeof(szValue);

        Status = RegQueryValueEx(
                    m_hkeyReplication,
                    REG_VALUE_ENTERPRISE_SERVER,
                    0,
                    &dwType,
                    (LPBYTE)szValue,
                    &dwSize
                    );

        LlsSetLastStatus(Status); // called api

        if (Status == ERROR_SUCCESS)
            strValue = szValue;
#else
        PLLS_SERVICE_INFO_0     pConfig = NULL;

        Status = ::LlsServiceInfoGet( m_hLls, 0, (LPBYTE *) &pConfig );

        if ( NT_SUCCESS( Status ) )
        {
            strValue = pConfig->EnterpriseServer;

            ::LlsFreeMemory( pConfig->ReplicateTo );
            ::LlsFreeMemory( pConfig->EnterpriseServer );
            ::LlsFreeMemory( pConfig );
        }
        else if ( IsConnectionDropped( Status ) )
        {
            DisconnectLls();
        }
#endif
    }

    return strValue.AllocSysString();
}


BSTR CServer::GetName()

/*++

Routine Description:

    Returns the name of the server.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CServer::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


LPDISPATCH CServer::GetServices(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    services registered in the server's registry or returns
    an individual service described by an index into the
    collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a service name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pServices)
    {
        m_pServices = new CServices(this, &m_serviceArray);
    }

    if (m_pServices)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshServices())
            {
                lpdispatch = m_pServices->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bServicesRefreshed)
            {
                lpdispatch = m_pServices->GetItem(index);
            }
            else if (RefreshServices())
            {
                lpdispatch = m_pServices->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CServer::IsLogging()

/*++

Routine Description:

    Returns true if server replicating license information.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return TRUE;    // CODEWORK...
}


BOOL CServer::RefreshServices()

/*++

Routine Description:

    Refreshs service object list.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetServices();

    LONG Status;

    if (InitializeIfNecessary())
    {
#ifdef CONFIG_THROUGH_REGISTRY
        TCHAR szValue[260];
        DWORD cchValue = sizeof(szValue)/sizeof(TCHAR);

        DWORD dwValue;
        DWORD dwValueType;
        DWORD dwValueSize;

        FILETIME ftLastWritten;

        DWORD index = 0L;
        int iService = 0;
        HKEY hkeyService = NULL;

        CString strServiceName;
        CString strServiceDisplayName;

        BOOL bIsPerServer;
        BOOL bIsReadOnly;

        long lPerServerLimit;

        while ((Status = RegEnumKeyEx(
                            m_hkeyLicense,
                            index,
                            szValue,
                            &cchValue,
                            NULL,               // lpdwReserved
                            NULL,               // lpszClass
                            NULL,               // lpcchClass
                            &ftLastWritten
                            )) == ERROR_SUCCESS)
        {
            strServiceName = szValue; // store for ctor...

            Status = RegOpenKeyEx(
                        m_hkeyLicense,
                        MKSTR(strServiceName),
                        0, // dwReserved
                        KEY_ALL_ACCESS,
                        &hkeyService
                        );

            if (Status != ERROR_SUCCESS)
                break; // abort...

            dwValueType = REG_SZ;
            dwValueSize = sizeof(szValue);

            Status = RegQueryValueEx(
                        hkeyService,
                        REG_VALUE_NAME,
                        0, // dwReserved
                        &dwValueType,
                        (LPBYTE)&szValue[0],
                        &dwValueSize
                        );

            if (Status != ERROR_SUCCESS)
                break; // abort...

            strServiceDisplayName = szValue;

            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            Status = RegQueryValueEx(
                        hkeyService,
                        REG_VALUE_MODE,
                        0, // dwReserved
                        &dwValueType,
                        (LPBYTE)&dwValue,
                        &dwValueSize
                        );

            if (Status != ERROR_SUCCESS)
                break; // abort...

            //
            // 0x0 = per seat mode
            // 0x1 = per server mode
            //

            bIsPerServer = (dwValue == 0x1);

            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            Status = RegQueryValueEx(
                        hkeyService,
                        REG_VALUE_FLIP,
                        0, // dwReserved
                        &dwValueType,
                        (LPBYTE)&dwValue,
                        &dwValueSize
                        );

            if (Status != ERROR_SUCCESS)
                break; // abort...

            //
            // 0x0 = can change mode
            // 0x1 = can't change mode
            //

            bIsReadOnly = (dwValue == 0x1);

            BOOL bGetLimitFromRegistry = TRUE;

            if ( ConnectLls() )
            {
                Status = LlsProductLicensesGet( m_hLls, MKSTR(strServiceDisplayName), LLS_LICENSE_MODE_PER_SERVER, &dwValue );

                if ( STATUS_SUCCESS == Status )
                {
                    bGetLimitFromRegistry = FALSE;
                }
            }

            if ( bGetLimitFromRegistry )
            {
                dwValueType = REG_DWORD;
                dwValueSize = sizeof(DWORD);

                Status = RegQueryValueEx(
                            hkeyService,
                            REG_VALUE_LIMIT,
                            0, // dwReserved
                            &dwValueType,
                            (LPBYTE)&dwValue,
                            &dwValueSize
                            );
            }

            if (Status != ERROR_SUCCESS)
                break; // abort...

            lPerServerLimit = (long)dwValue;

            CService* pService = new CService(this,
                                        strServiceName,
                                        strServiceDisplayName,
                                        bIsPerServer,
                                        bIsReadOnly,
                                        lPerServerLimit
                                        );

            m_serviceArray.SetAtGrow(iService++, pService);
            index++;

            cchValue = sizeof(szValue)/sizeof(TCHAR);

            RegCloseKey(hkeyService); // no longer needed...
            hkeyService = NULL;
        }

        if (hkeyService)
            RegCloseKey(hkeyService);

        if (Status == ERROR_NO_MORE_ITEMS)
            Status = ERROR_SUCCESS;

        LlsSetLastStatus(Status);     // called api

        if (Status == ERROR_SUCCESS)
        {
            m_bServicesRefreshed = TRUE;
        }
        else
        {
            ResetServices();
        }
#else
        DWORD   dwResumeHandle = 0;
        int     iService       = 0;

        do
        {
            PLLS_LOCAL_SERVICE_INFO_0   pServiceList = NULL;
            DWORD                       dwEntriesRead  = 0;
            DWORD                       dwTotalEntries = 0;

            Status = ::LlsLocalServiceEnum( m_hLls,
                                            0,
                                            (LPBYTE *) &pServiceList,
                                            LLS_PREFERRED_LENGTH,
                                            &dwEntriesRead,
                                            &dwTotalEntries,
                                            &dwResumeHandle );

            if ( NT_SUCCESS( Status ) )
            {
                DWORD   i;

                for ( i=0; i < dwEntriesRead; i++ )
                {
                    BOOL  bIsPerServer = ( LLS_LICENSE_MODE_PER_SERVER == pServiceList[ i ].Mode );
                    BOOL  bIsReadOnly  = ( 0 == pServiceList[ i ].FlipAllow );
                    DWORD dwConcurrentLimit;

                    // get number of per server license in case where product
                    //     is secure, and
                    //     ( is currently in per seat mode, or
                    //       new secure per server licenses have just been added and registry
                    //          has not been updated yet )
                    if ( STATUS_SUCCESS != LlsProductLicensesGet( m_hLls, pServiceList[ i ].DisplayName, LLS_LICENSE_MODE_PER_SERVER, &dwConcurrentLimit ) )
                    {
                        dwConcurrentLimit = pServiceList[ i ].ConcurrentLimit;
                    }

                    CService* pService = new CService( this,
                                                       pServiceList[ i ].KeyName,
                                                       pServiceList[ i ].DisplayName,
                                                       bIsPerServer,
                                                       bIsReadOnly,
                                                       dwConcurrentLimit );

                    m_serviceArray.SetAtGrow(iService++, pService);

                    ::LlsFreeMemory( pServiceList[ i ].KeyName           );
                    ::LlsFreeMemory( pServiceList[ i ].DisplayName       );
                    ::LlsFreeMemory( pServiceList[ i ].FamilyDisplayName );
                }

                ::LlsFreeMemory( pServiceList );
            }
        } while ( STATUS_MORE_ENTRIES == Status );

        LlsSetLastStatus( Status );     // called api

        if ( NT_SUCCESS( Status ) )
        {
            m_bServicesRefreshed = TRUE;
        }
        else
        {
            ResetServices();

            if ( IsConnectionDropped( Status ) )
            {
                DisconnectLls();
            }
        }
#endif
    }

    return m_bServicesRefreshed;
}


void CServer::ResetServices()

/*++

Routine Description:

    Resets service object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CService* pService;
    INT_PTR   iService = m_serviceArray.GetSize();

    while (iService--)
    {
        if (pService = (CService*)m_serviceArray[iService])
        {
            ASSERT(pService->IsKindOf(RUNTIME_CLASS(CService)));
            pService->InternalRelease();
        }
    }

    m_serviceArray.RemoveAll();
    m_bServicesRefreshed = FALSE;
}


BOOL CServer::InitializeIfNecessary()

/*++

Routine Description:

    Initialize registry keys if necessary.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
#ifdef CONFIG_THROUGH_REGISTRY
    LONG Status = ERROR_SUCCESS;

    if (!m_hkeyRoot)
    {
        Status = RegConnectRegistry(
                      MKSTR(m_strName),
                      HKEY_LOCAL_MACHINE,
                      &m_hkeyRoot
                      );

        LlsSetLastStatus(Status); // called api
    }

    if (!m_hkeyLicense && (Status == ERROR_SUCCESS))
    {
        ASSERT(m_hkeyRoot);

        Status = RegOpenKeyEx(
                    m_hkeyRoot,
                    REG_KEY_LICENSE,
                    0,                      // dwReserved
                    KEY_ALL_ACCESS,
                    &m_hkeyLicense
                    );

        LlsSetLastStatus(Status); // called api
    }

    if (!m_hkeyReplication && (Status == ERROR_SUCCESS))
    {
        ASSERT(m_hkeyRoot);

        Status = RegOpenKeyEx(
                    m_hkeyRoot,
                    REG_KEY_SERVER_PARAMETERS,
                    0,                      // dwReserved
                    KEY_ALL_ACCESS,
                    &m_hkeyReplication
                    );

        LlsSetLastStatus(Status); // called api
    }

    return (Status == ERROR_SUCCESS);
#else
    return ConnectLls();
#endif
}


BOOL CServer::IsReplicatingToDC()

/*++

Routine Description:

    Returns true if server replicating to domain controller.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    LONG Status;
    DWORD dwValue = 0;

    if (InitializeIfNecessary())
    {
#ifdef CONFIG_THROUGH_REGISTRY
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(
                    m_hkeyReplication,
                    REG_VALUE_USE_ENTERPRISE,
                    0,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize
                    );
#else
        PLLS_SERVICE_INFO_0     pConfig = NULL;

        Status = ::LlsServiceInfoGet( m_hLls, 0, (LPBYTE *) &pConfig );

        if ( NT_SUCCESS( Status ) )
        {
            dwValue = pConfig->UseEnterprise;

            ::LlsFreeMemory( pConfig->ReplicateTo );
            ::LlsFreeMemory( pConfig->EnterpriseServer );
            ::LlsFreeMemory( pConfig );
        }

        if ( IsConnectionDropped( Status ) )
        {
            DisconnectLls();
        }
#endif
        LlsSetLastStatus(Status); // called api
    }

    return !((BOOL)dwValue);
}


BOOL CServer::IsReplicatingDaily()

/*++

Routine Description:

    Returns true if server replicating daily at certain time.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    LONG Status;
    DWORD dwValue = 0;

    if (InitializeIfNecessary())
    {
#ifdef CONFIG_THROUGH_REGISTRY
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(
                    m_hkeyReplication,
                    REG_VALUE_REPLICATION_TYPE,
                    0,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize
                    );
#else
        PLLS_SERVICE_INFO_0     pConfig = NULL;

        Status = ::LlsServiceInfoGet( m_hLls, 0, (LPBYTE *) &pConfig );

        if ( NT_SUCCESS( Status ) )
        {
            dwValue = pConfig->ReplicationType;

            ::LlsFreeMemory( pConfig->ReplicateTo );
            ::LlsFreeMemory( pConfig->EnterpriseServer );
            ::LlsFreeMemory( pConfig );
        }

        if ( IsConnectionDropped( Status ) )
        {
            DisconnectLls();
        }
#endif

        LlsSetLastStatus(Status); // called api
    }

    return (dwValue == LLS_REPLICATION_TYPE_TIME);
}


long CServer::GetReplicationTime()

/*++

Routine Description:

    Returns time in seconds between replication or seconds
    from midnight if replicating daily.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    LONG Status;
    DWORD dwValue = 0;

    if (InitializeIfNecessary())
    {
#ifdef CONFIG_THROUGH_REGISTRY
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(
                    m_hkeyReplication,
                    REG_VALUE_REPLICATION_TIME,
                    0,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize
                    );
#else
        PLLS_SERVICE_INFO_0     pConfig = NULL;

        Status = ::LlsServiceInfoGet( m_hLls, 0, (LPBYTE *) &pConfig );

        if ( NT_SUCCESS( Status ) )
        {
            dwValue = pConfig->ReplicationTime;

            ::LlsFreeMemory( pConfig->ReplicateTo );
            ::LlsFreeMemory( pConfig->EnterpriseServer );
            ::LlsFreeMemory( pConfig );
        }

        if ( IsConnectionDropped( Status ) )
        {
            DisconnectLls();
        }
#endif

        LlsSetLastStatus(Status); // called api
    }

    return dwValue;
}


BOOL CServer::ConnectLls()

/*++

Routine Description:

    Connects to license service on this server.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS Status;

    if ( NULL == m_hLls )
    {
       CString strNetServerName = m_strName;

       if ( strNetServerName.Left(2).Compare( TEXT( "\\\\" ) ) )
       {
           strNetServerName = TEXT( "\\\\" ) + strNetServerName;
       }

       Status = LlsConnect( MKSTR(strNetServerName), &m_hLls );

       if ( STATUS_SUCCESS != Status )
       {
           m_hLls = NULL;
       }
       else if ( !HaveAdminAuthority() )
       {
           m_hLls = NULL;
           Status = ERROR_ACCESS_DENIED;
       }

       LlsSetLastStatus( Status );
    }

    return ( NULL != m_hLls );
}


void CServer::DisconnectLls()

/*++

Routine Description:

    Disconnects from license service on this server.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if ( NULL != m_hLls )
    {
       LlsClose( m_hLls );

       m_hLls = NULL;
    }
}


BOOL CServer::HaveAdminAuthority()

/*++

Routine Description:

    Checks whether the current user has admin authority on the server.

Arguments:

    None.

Return Values:

    BOOL.

--*/

{
    BOOL           bIsAdmin;
    CString        strNetShareName;

    strNetShareName = m_strName + TEXT( "\\ADMIN$" );

    if ( strNetShareName.Left(2).Compare( TEXT( "\\\\" ) ) )
    {
        strNetShareName = TEXT( "\\\\" ) + strNetShareName;
    }

#ifdef USE_WNET_API
    DWORD          dwError;
    NETRESOURCE    NetResource;

    ZeroMemory( &NetResource, sizeof( NetResource ) );

    NetResource.dwType       = RESOURCETYPE_DISK;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = MKSTR(strNetShareName);
    NetResource.lpProvider   = NULL;

    dwError = WNetAddConnection2( &NetResource, NULL, NULL, 0 );

    bIsAdmin = ( NO_ERROR == dwError );

    if ( NO_ERROR != dwError )
    {
        bIsAdmin = FALSE;
    }
    else
    {
        bIsAdmin = TRUE;

        WNetCancelConnection2( MKSTR(strNetShareName), 0, FALSE );
    }
#else
    NET_API_STATUS  NetStatus;
    USE_INFO_1      UseInfo;
    DWORD           dwErrorParm;

    ZeroMemory( &UseInfo, sizeof( UseInfo ) );

    UseInfo.ui1_remote = MKSTR( strNetShareName );

    NetStatus = NetUseAdd( NULL, 1, (LPBYTE) &UseInfo, &dwErrorParm );

    if ( NERR_Success != NetStatus )
    {
        bIsAdmin = FALSE;
    }
    else
    {
        bIsAdmin = TRUE;

        NetStatus = NetUseDel( NULL, MKSTR(strNetShareName), 0 );
        // ignore status
    }
#endif

   return bIsAdmin;
}


BOOL CServer::IsWin2000()

/*++

Routine Description:

    Checks whether the current server is Windows 2000 or greater.

Arguments:

    None.

Return Values:

    BOOL.

--*/

{
    if ( m_IsWin2000 == uninitialized )
    {
        if ( GetName() != NULL )
        {
            NET_API_STATUS NetStatus;
            PWKSTA_INFO_100 pWkstaInfo100 = NULL;

            NetStatus = NetWkstaGetInfo(
                            GetName(),
                            100,
                            (LPBYTE*)&pWkstaInfo100
                            );

            if (NetStatus == ERROR_SUCCESS)
            {
                if (pWkstaInfo100->wki100_ver_major < 5)
                {
                    m_IsWin2000 = notwin2000;
                }
                else
                {
                    m_IsWin2000 = win2000;
                }

                NetApiBufferFree(pWkstaInfo100);
            }
        }
    }

    // if still unitialized, assume win2000.

    return ( !(m_IsWin2000 == notwin2000) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvppgp.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvppgp.h

Abstract:

    Server property page (products) implementation.

Author:

    Don Ryan (donryan) 13-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SRVPPGP_H_
#define _SRVPPGP_H_

class CServerPropertyPageProducts : public CPropertyPage
{
    DECLARE_DYNCREATE(CServerPropertyPageProducts)
private:
    CServer*   m_pServer;
    DWORD*     m_pUpdateHint;
    BOOL       m_bAreCtrlsInitialized;

public:
    CServerPropertyPageProducts();
    ~CServerPropertyPageProducts();

    void InitPage(CServer* pServer, DWORD* pUpdateHint);
    void AbortPageIfNecessary();
    void AbortPage();    

    void InitCtrls();
    BOOL RefreshCtrls();

    //{{AFX_DATA(CServerPropertyPageProducts)
    enum { IDD = IDD_PP_SERVER_PRODUCTS };
    CButton m_edtBtn;
    CListCtrl m_productList;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CServerPropertyPageProducts)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CServerPropertyPageProducts)
    virtual BOOL OnInitDialog();
    afx_msg void OnEdit();
    afx_msg void OnDblClkProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturnProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocusProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClickProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfoProducts(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

int CALLBACK CompareServerProducts(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#endif // _SRVPPGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\srvppgr.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    srvppgr.h

Abstract:

    Server property page (repl) implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    JeffParh (jeffparh) 16-Dec-1996
       o  Disallowed server as own enterprise server.
       o  Changed "Start At" to use locale info for time format rather than
          private registry settings.  Merged OnClose() functionality into
          OnKillActive().
       o  Added warning of possible license loss when changing replication
          target server.
       o  No longer automatically saves when page is flipped.

--*/

#ifndef _SRVPPGR_H_
#define _SRVPPGR_H_

const DWORD INTERVAL_MIN = 1;
const DWORD INTERVAL_MAX = 72;
const DWORD HOUR_MIN_24 = 0;
const DWORD HOUR_MAX_24 = 23;
const DWORD HOUR_MIN_12 = 1;
const DWORD HOUR_MAX_12 = 12;
const DWORD MINUTE_MIN = 0;
const DWORD MINUTE_MAX = 59;
const DWORD SECOND_MIN = 0;
const DWORD SECOND_MAX = 59;
const DWORD DEFAULT_EVERY = 24;

class CServerPropertyPageReplication : public CPropertyPage
{
    DECLARE_DYNCREATE(CServerPropertyPageReplication)
private:
    CServer* m_pServer;

    BOOL     m_bReplAt;
    BOOL     m_bUseEsrv;
    DWORD    m_nStartingHour;
    DWORD    m_nHour;
    DWORD    m_nMinute;
    DWORD    m_nSecond;
    BOOL     m_bPM;
    CString  m_strEnterpriseServer;
    DWORD    m_nReplicationTime;
    BOOL     m_bOnInit;

    CString  m_str1159;
    CString  m_str2359;
    BOOL     m_bIsMode24;
    BOOL     m_bIsHourLZ;
    CString  m_strSep1;
    CString  m_strSep2;
    DWORD    m_nHourMax;
    DWORD    m_nHourMin;

    BOOL     EditValidate(short *pID, BOOL *pfBeep);
    void     EditInvalidDlg(BOOL fBeep);


public:
    DWORD    m_dwUpdateStatus;

public:
    CServerPropertyPageReplication();
    ~CServerPropertyPageReplication();

    void GetProfile();
    void InitPage(CServer* pServer);

    void SaveReplicationParams();

    BOOL Refresh();

    virtual BOOL OnKillActive();
    virtual void OnOK();

    //{{AFX_DATA(CServerPropertyPageReplication)
    enum { IDD = IDD_PP_SERVER_REPLICATION };
    CEdit   m_everyEdit;
    CEdit   m_esrvEdit;
    CButton m_atBtn;
    CButton m_everyBtn;
    CButton m_dcBtn;                                      
    CButton m_esrvBtn;
    CSpinButtonCtrl m_spinAt;
    CSpinButtonCtrl m_spinEvery;
    CEdit   m_atBorderEdit;
    CEdit   m_atSep1Edit;
    CEdit   m_atSep2Edit;
    CEdit   m_atHourEdit;
    CEdit   m_atMinEdit;
    CEdit   m_atSecEdit;
    CListBox m_atAmPmEdit;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CServerPropertyPageReplication)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CServerPropertyPageReplication)
    virtual BOOL OnInitDialog();
    afx_msg void OnAt();
    afx_msg void OnDc();
    afx_msg void OnEsrv();
    afx_msg void OnEvery();
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnSetfocusAmpm();
    afx_msg void OnKillfocusAmpm();
    afx_msg void OnKillFocusHour();
    afx_msg void OnSetFocusHour();
    afx_msg void OnKillFocusMinute();
    afx_msg void OnSetFocusMinute();
    afx_msg void OnSetFocusSecond();
    afx_msg void OnKillFocusSecond();
    afx_msg void OnSetfocusEvery();
    afx_msg void OnKillfocusEvery();
    afx_msg void OnUpdateEsrvName();
    afx_msg void OnUpdateAtHour();
    afx_msg void OnUpdateAtMinute();
    afx_msg void OnUpdateAtSecond();
    afx_msg void OnUpdateEveryValue();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SRVPPGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sstobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sstobj.h

Abstract:

    Server statistic object implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SSTOBJ_H_
#define _SSTOBJ_H_

class CServerStatistic : public CCmdTarget
{
    DECLARE_DYNCREATE(CServerStatistic)
private:
    CCmdTarget* m_pParent;

public:
    CString     m_strEntry;
    long        m_lMaxUses;
    long        m_lHighMark;
    BOOL        m_bIsPerServer;

public:
    CServerStatistic(
        CCmdTarget* pParent   = NULL,
        LPCTSTR     pEntry    = NULL,
        DWORD       dwFlags   = 0L,
        long        lMaxUses  = 0,
        long        lHighMark = 0
        );           
    virtual ~CServerStatistic();

    //{{AFX_VIRTUAL(CServerStatistic)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CServerStatistic)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg BSTR GetServerName();
    afx_msg long GetMaxUses();
    afx_msg long GetHighMark();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CServerStatistic)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

#endif // _SSTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\stacol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    stacol.h

Abstract:

    Statistic collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _STACOL_H_
#define _STACOL_H_

class CStatistics : public CCmdTarget
{
    DECLARE_DYNCREATE(CStatistics)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CStatistics(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CStatistics();

    //{{AFX_VIRTUAL(CStatistics)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CStatistics)
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CStatistics)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _STACOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\stacol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    stacol.cpp

Abstract:

    Statistic collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CStatistics, CCmdTarget)

BEGIN_MESSAGE_MAP(CStatistics, CCmdTarget)
    //{{AFX_MSG_MAP(CStatistics)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CStatistics, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CStatistics)
    DISP_PROPERTY_EX(CStatistics, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CStatistics, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CStatistics, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_FUNCTION(CStatistics, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CStatistics::CStatistics(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for statistic collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CUser)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CProduct))));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CStatistics::~CStatistics()

/*++

Routine Description:

    Destructor for statistic collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CStatistics::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CStatistics::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CStatistics::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long) m_pObArray->GetSize();
}


LPDISPATCH CStatistics::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified statistic object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a entry name or a number (VT_I4) indicating the
    position within collection.

Return Values:

    VT_DISPATCH.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CStatistic* pStatistic;
    INT_PTR     iStatistic;

    VARIANT vStatistic;
    VariantInit(&vStatistic);

    if (iStatistic = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iStatistic--)
            {
                if (pStatistic = (CStatistic*)m_pObArray->GetAt(iStatistic))
                {
                    ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CStatistic)));

                    if (!pStatistic->m_strEntry.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pStatistic->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vStatistic, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vStatistic.lVal >= 0) && ((int)vStatistic.lVal < iStatistic))
            {
                if (pStatistic = (CStatistic*)m_pObArray->GetAt((int)vStatistic.lVal))
                {
                    ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CStatistic)));
                    lpdispatch = pStatistic->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CStatistics::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sstobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sstobj.cpp

Abstract:

    Server statistic object implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServerStatistic, CCmdTarget)

BEGIN_MESSAGE_MAP(CServerStatistic, CCmdTarget)
    //{{AFX_MSG_MAP(CServerStatistic)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CServerStatistic, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CServerStatistic)
    DISP_PROPERTY_EX(CServerStatistic, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServerStatistic, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServerStatistic, "ServerName", GetServerName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CServerStatistic, "MaxUses", GetMaxUses, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CServerStatistic, "HighMark", GetHighMark, SetNotSupported, VT_I4)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CServerStatistic::CServerStatistic(
    CCmdTarget* pParent,
    LPCTSTR     pEntry,
    DWORD       dwFlags,
    long        lMaxUses,
    long        lHighMark
)

/*++

Routine Description:

    Constructor for statistic object.

Arguments:

    pParent - creator of object.
    pEntry - user or server product.
    dwFlags - details...
    lMaxUses - maximum number of uses on server.
    lHighMark - high water mark thus far.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CProduct)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pEntry && *pEntry);

    m_strEntry = pEntry;

    m_lMaxUses  = lMaxUses;
    m_lHighMark = lHighMark;

    m_bIsPerServer = (dwFlags & LLS_FLAG_PRODUCT_PERSEAT) ? FALSE : TRUE;
}


CServerStatistic::~CServerStatistic()

/*++

Routine Description:

    Destructor for statistic object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServerStatistic::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CServerStatistic::GetApplication() 

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CServerStatistic::GetHighMark() 

/*++

Routine Description:

    Returns number of accesses thus far.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lHighMark;
}


long CServerStatistic::GetMaxUses() 

/*++

Routine Description:

    Returns number of accesses available.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lMaxUses;
}


LPDISPATCH CServerStatistic::GetParent() 

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


BSTR CServerStatistic::GetServerName() 

/*++

Routine Description:

    Returns the name of server.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strEntry.AllocSysString();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sstcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sstcol.h

Abstract:

    Server statistic collection object implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SSTCOL_H_
#define _SSTCOL_H_

class CServerStatistics : public CCmdTarget
{
    DECLARE_DYNCREATE(CServerStatistics)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CServerStatistics(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CServerStatistics();

    //{{AFX_VIRTUAL(CServerStatistics)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CServerStatistics)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CServerStatistics)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SSTCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\sstcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    sstcol.cpp

Abstract:

    Server statistic collection object implementation.

Author:

    Don Ryan (donryan) 03-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServerStatistics, CCmdTarget)

BEGIN_MESSAGE_MAP(CServerStatistics, CCmdTarget)
    //{{AFX_MSG_MAP(CServerStatistics)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CServerStatistics, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CServerStatistics)
    DISP_PROPERTY_EX(CServerStatistics, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServerStatistics, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServerStatistics, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CServerStatistics, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CServerStatistics::CServerStatistics(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for statistic collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CProduct)));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CServerStatistics::~CServerStatistics()

/*++

Routine Description:

    Destructor for statistic collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServerStatistics::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CServerStatistics::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CServerStatistics::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CServerStatistics::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified statistic object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a entry name or a number (VT_I4) indicating the
    position within collection.

Return Values:

    VT_DISPATCH.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CServerStatistic* pStatistic;
    INT_PTR           iStatistic;

    VARIANT vStatistic;
    VariantInit(&vStatistic);

    if (iStatistic = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iStatistic--)
            {
                if (pStatistic = (CServerStatistic*)m_pObArray->GetAt(iStatistic))
                {
                    ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CServerStatistic)));

                    if (!pStatistic->m_strEntry.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pStatistic->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vStatistic, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vStatistic.lVal >= 0) && ((int)vStatistic.lVal < iStatistic))
            {
                if (pStatistic = (CServerStatistic*)m_pObArray->GetAt((int)vStatistic.lVal))
                {
                    ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CServerStatistic)));
                    lpdispatch = pStatistic->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CServerStatistics::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\staobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    statobj.cpp

Abstract:

    Statistic object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CStatistic, CCmdTarget)

BEGIN_MESSAGE_MAP(CStatistic, CCmdTarget)
    //{{AFX_MSG_MAP(CStatistic)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CStatistic, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CStatistic)
    DISP_PROPERTY_EX(CStatistic, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CStatistic, "LastUsed", GetLastUsed, SetNotSupported, VT_DATE)
    DISP_PROPERTY_EX(CStatistic, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CStatistic, "TotalUsed", GetTotalUsed, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CStatistic, "EntryName", GetEntryName, SetNotSupported, VT_BSTR)
    DISP_DEFVALUE(CStatistic, "EntryName")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CStatistic::CStatistic(
    CCmdTarget* pParent,
    LPCTSTR     pEntry,
    DWORD       dwFlags,
    long        lLastUsed,
    long        lTotalUsed
)

/*++

Routine Description:

    Constructor for statistic object.

Arguments:

    pParent - creator of object.
    pEntry - user or server product.
    dwFlags - details about license.
    lLastUsed - date user last used product.
    lTotalUsed - total times user used product.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CUser)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CProduct))));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pEntry && *pEntry);

    m_strEntry = pEntry;

    m_lLastUsed  = lLastUsed;
    m_lTotalUsed = lTotalUsed;

    m_bIsValid = dwFlags & LLS_FLAG_LICENSED;
}


CStatistic::~CStatistic()

/*++

Routine Description:

    Destructor for statistic object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CStatistic::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CStatistic::GetApplication() 

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


BSTR CStatistic::GetEntryName() 

/*++

Routine Description:

    Returns the name of user or server product.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strEntry.AllocSysString();
}


DATE CStatistic::GetLastUsed() 

/*++

Routine Description:

    Returns the date the user last used the server product.

Arguments:

    None.

Return Values:

    VT_DATE.

--*/

{
    return SecondsSince1980ToDate(m_lLastUsed);   
}


BSTR CStatistic::GetLastUsedString()

/*++

Routine Description:

    Returns the date last used as a string.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    VARIANT vaIn;
    VARIANT vaOut;

    VariantInit(&vaIn);
    VariantInit(&vaOut);

    vaIn.vt = VT_DATE;
    vaIn.date = SecondsSince1980ToDate(m_lLastUsed);

    BSTR bstrDate = NULL;

    if (SUCCEEDED(VariantChangeType(&vaOut, &vaIn, 0, VT_BSTR)))
    {
        bstrDate = vaOut.bstrVal;
    }

    return bstrDate;
}


LPDISPATCH CStatistic::GetParent() 

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


long CStatistic::GetTotalUsed() 

/*++

Routine Description:

    Returns total number of times client used product.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lTotalUsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\staobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    staobj.h

Abstract:

    Statistic object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _STAOBJ_H_
#define _STAOBJ_H_

class CStatistic : public CCmdTarget
{
    DECLARE_DYNCREATE(CStatistic)
private:
    CCmdTarget* m_pParent;

public:
    CString     m_strEntry;
    long        m_lLastUsed;
    long        m_lTotalUsed;
    BOOL        m_bIsValid;

public:
    CStatistic(
        CCmdTarget* pParent    = NULL,
        LPCTSTR     pEntry     = NULL,
        DWORD       dwFlags    = 0L,
        long        lLastUsed  = 0,
        long        lTotalUsed = 0
    );           
    virtual ~CStatistic();

    BSTR GetLastUsedString();
    
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStatistic)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CStatistic)
    afx_msg LPDISPATCH GetApplication();
    afx_msg DATE GetLastUsed();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetTotalUsed();
    afx_msg BSTR GetEntryName();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CStatistic)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _STAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	llsmgr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\svccol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    svccol.h

Abstract:

    Service collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SVCCOL_H_
#define _SVCCOL_H_

class CServices : public CCmdTarget
{
    DECLARE_DYNCREATE(CServices)
private:
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CServices(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CServices();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CServices)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CServices)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CServices)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _SVCCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef ASSERT
#  undef ASSERT
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <llsapi.h>

extern "C"
{
#  include <ntlsa.h>
}

#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcmn.h>
#include <afxdlgs.h>

#ifdef DBG

#define DBGMSG( x , y ) \
{ \
 TCHAR tchmsg[80]; \
 wsprintf( tchmsg , x , y ); \
 OutputDebugString( tchmsg );\
}

#else

#define DBGMSG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\svcobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    svcobj.h

Abstract:

    Service object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SVCOBJ_H_
#define _SVCOBJ_H_

class CService : public CCmdTarget
{
    DECLARE_DYNCREATE(CService)
private:
    CCmdTarget* m_pParent;

public:         
    CString     m_strName;
    CString     m_strDisplayName;

    BOOL        m_bIsPerServer;
    BOOL        m_bIsReadOnly;

    long        m_lPerServerLimit;

public:
    CService(
        CCmdTarget* pParent = NULL, 
        LPCTSTR     pName = NULL,
        LPCTSTR     pDisplayName = NULL,
        BOOL        bIsPerServer = FALSE,
        BOOL        bIsReadOnly = FALSE,
        long        lPerServerLimit = 0L
        );           
    virtual ~CService();

#ifdef CONFIG_THROUGH_REGISTRY
    HKEY GetRegKey();
#endif

    //{{AFX_VIRTUAL(CService)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CService)
    afx_msg LPDISPATCH GetApplication();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetPerServerLimit();
    afx_msg BOOL IsPerServer();
    afx_msg BOOL IsReadOnly();
    afx_msg BSTR GetDisplayName();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CService)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#define CalcServiceBitmap(svc) ((svc)->IsPerServer() ? BMPI_PRODUCT_PER_SERVER : BMPI_PRODUCT_PER_SEAT)

#endif // _SVCOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\svcobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    svcobj.cpp

Abstract:

    Service object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CService, CCmdTarget)

BEGIN_MESSAGE_MAP(CService, CCmdTarget)
    //{{AFX_MSG_MAP(CService)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CService, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CService)
    DISP_PROPERTY_EX(CService, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CService, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CService, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CService, "PerServerLimit", GetPerServerLimit, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CService, "IsPerServer", IsPerServer, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CService, "IsReadOnly", IsReadOnly, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CService, "DisplayName", GetDisplayName, SetNotSupported, VT_BSTR)
    DISP_DEFVALUE(CService, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CService::CService(
    CCmdTarget* pParent, 
    LPCTSTR     pName,
    LPCTSTR     pDisplayName,
    BOOL        bIsPerServer,
    BOOL        bIsReadOnly,
    long        lPerServerLimit
    )

/*++

Routine Description:

    Constructor for service object.

Arguments:

    pParent - creator of object.
    pName - name of service.
    pDisplayName - display name of service.
    bIsPerServer - true if service per server.
    bIsReadOnly - true if service read only.
    lPerServerLimit - per server limit.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CServer)));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);
    ASSERT(pDisplayName && *pDisplayName);

    m_strName         = pName;
    m_strDisplayName  = pDisplayName;

    m_bIsPerServer = bIsPerServer;
    m_bIsReadOnly  = bIsReadOnly;

    m_lPerServerLimit = lPerServerLimit;
}


CService::~CService()

/*++

Routine Description:

    Destructor for service object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here...
    //
}


void CService::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CService::GetApplication() 

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


BSTR CService::GetDisplayName() 

/*++

Routine Description:

    Returns the display name of the service.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strDisplayName.AllocSysString();
}


BSTR CService::GetName() 

/*++

Routine Description:

    Returns the name of the service.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CService::GetParent() 

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


long CService::GetPerServerLimit() 

/*++

Routine Description:

    Returns the number of clients allowed to use the service at any
    one time under per server licensing mode. 

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lPerServerLimit;
}


BOOL CService::IsPerServer() 

/*++

Routine Description:

    Returns true if service is in per server licensing mode.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsPerServer;
}


BOOL CService::IsReadOnly() 

/*++

Routine Description:

    Returns true if service allows changing of it's licensing mode.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsReadOnly;
}

#ifdef CONFIG_THROUGH_REGISTRY
HKEY CService::GetRegKey()

/*++

Routine Description:

    Returns registry key for service.

Arguments:

    None.

Return Values:

    HKEY or nul.

--*/
    
{
    HKEY hkeyLicense = NULL;
    HKEY hkeyService = NULL;

    LONG Status = ERROR_BADKEY;

    ASSERT(m_pParent && m_pParent->IsKindOf(RUNTIME_CLASS(CServer)));

    if (hkeyLicense = ((CServer*)m_pParent)->m_hkeyLicense)
    {
        Status = RegOpenKeyEx(                       
                    hkeyLicense,                 
                    MKSTR(m_strName), 
                    0,                  // dwReserved
                    KEY_ALL_ACCESS,                        
                    &hkeyService
                    ); 
    }

    LlsSetLastStatus(Status);

    return (Status == ERROR_SUCCESS) ? hkeyService : NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrcol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrcol.cpp

Abstract:

    User collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CUsers, CCmdTarget)

BEGIN_MESSAGE_MAP(CUsers, CCmdTarget)
    //{{AFX_MSG_MAP(CUsers)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CUsers, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CUsers)
    DISP_PROPERTY_EX(CUsers, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CUsers, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CUsers, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CUsers, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CUsers::CUsers(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for user collection object.

Arguments:

    pParent - creator of object.
    pObArray - object array to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CDomain)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CMapping)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CController))));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CUsers::~CUsers()

/*++

Routine Description:

    Destructor for user collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CUsers::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CUsers::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CUsers::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CUsers::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified user object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a user name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CUser*  pUser;
    INT_PTR iUser;

    VARIANT vUser;
    VariantInit(&vUser);

    if (iUser = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iUser--)
            {
                if (pUser = (CUser*)m_pObArray->GetAt(iUser))
                {
                    ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));

                    if (!pUser->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pUser->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vUser, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vUser.lVal >= 0) && ((int)vUser.lVal < iUser))
            {
                if (pUser = (CUser*)m_pObArray->GetAt((int)vUser.lVal))
                {
                    ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
                    lpdispatch = pUser->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CUsers::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrcol.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrcol.h

Abstract:

    User collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _USRCOL_H_
#define _USRCOL_H_

class CUsers : public CCmdTarget
{
    DECLARE_DYNCREATE(CUsers)
private:                  
    CCmdTarget* m_pParent;

public:
    CObArray*   m_pObArray;

public:
    CUsers(CCmdTarget* pParent = NULL, CObArray* pObArray = NULL);           
    virtual ~CUsers();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CUsers)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CUsers)
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg long GetCount();
    afx_msg LPDISPATCH GetItem(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CUsers)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _USRCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\svccol.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    svccol.cpp

Abstract:

    Service collection object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CServices, CCmdTarget)

BEGIN_MESSAGE_MAP(CServices, CCmdTarget)
    //{{AFX_MSG_MAP(CServices)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CServices, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CServices)
    DISP_PROPERTY_EX(CServices, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServices, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CServices, "Count", GetCount, SetNotSupported, VT_I4)
    DISP_FUNCTION(CServices, "Item", GetItem, VT_DISPATCH, VTS_VARIANT)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CServices::CServices(CCmdTarget* pParent, CObArray* pObArray)

/*++

Routine Description:

    Constructor for service collection object.

Arguments:

    pParent - creator of object.
    pObArray - object list to enumerate.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent && pParent->IsKindOf(RUNTIME_CLASS(CServer)));
#endif // ENABLE_PARENT_CHECK
    ASSERT_VALID(pObArray);

    m_pParent  = pParent;
    m_pObArray = pObArray;
}


CServices::~CServices()

/*++

Routine Description:

    Destructor for service collection object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    //
    // Nothing to do here.
    //
}


void CServices::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    delete this;
}


LPDISPATCH CServices::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}



long CServices::GetCount()

/*++

Routine Description:

    Returns number of items in collection.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    ASSERT_VALID(m_pObArray);
    return (long)m_pObArray->GetSize();
}


LPDISPATCH CServices::GetItem(const VARIANT FAR& index)

/*++

Routine Description:

    Retrieves specified service object from collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating the service name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pObArray);

    LPDISPATCH lpdispatch = NULL;

    CService* pService;
    INT_PTR   iService;

    VARIANT vService;
    VariantInit(&vService);

    if (iService = m_pObArray->GetSize())
    {
        if (index.vt == VT_BSTR)
        {
            while (iService--)
            {
                if (pService = (CService*)m_pObArray->GetAt(iService))
                {
                    ASSERT(pService->IsKindOf(RUNTIME_CLASS(CService)));

                    if (!pService->m_strName.CompareNoCase(index.bstrVal))
                    {
                        lpdispatch = pService->GetIDispatch(TRUE);
                        break;
                    }
                }
            }
        }
        else if (SUCCEEDED(VariantChangeType(&vService, (VARIANT FAR *)&index, 0, VT_I4)))
        {
            if (((int)vService.lVal >= 0) && ((int)vService.lVal < iService))
            {
                if (pService = (CService*)m_pObArray->GetAt((int)vService.lVal))
                {
                    ASSERT(pService->IsKindOf(RUNTIME_CLASS(CService)));
                    lpdispatch = pService->GetIDispatch(TRUE);
                }
            }
        }
    }

    return lpdispatch;
}


LPDISPATCH CServices::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrobj.cpp

Abstract:

    User object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
       o  Modified m_bIsValid and m_bIsBackOffice in constructor to fix
          comparison problem in CUserPropertyPageProducts.
          ((a != FALSE) && (b != FALSE) does not imply (a == b).)

--*/

#include "stdafx.h"
#include "llsmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CUser, CCmdTarget)

BEGIN_MESSAGE_MAP(CUser, CCmdTarget)
    //{{AFX_MSG_MAP(CUser)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CUser, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CUser)
    DISP_PROPERTY_EX(CUser, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CUser, "InUse", GetInUse, SetNotSupported, VT_I4)
    DISP_PROPERTY_EX(CUser, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CUser, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CUser, "Mapping", GetMapping, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CUser, "IsMapped", IsMapped, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CUser, "Unlicensed", GetUnlicensed, SetNotSupported, VT_I4)
    DISP_PROPERTY_PARAM(CUser, "Statistics", GetStatistics, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CUser, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CUser::CUser(
    CCmdTarget* pParent,
    LPCTSTR     pName,
    DWORD       dwFlags,
    long        lInUse,
    long        lUnlicensed,
    LPCTSTR     pMapping,
    LPCTSTR     pProducts       // blah...
)

/*++

Routine Description:

    Constructor for user object.

Arguments:

    pParent - creator of object.
    pName - name of user.
    dwFlags - details about user.
    lInUse - number of licenses consumed by user (legally).
    lUnicensed - number of licenses consumed by user (illegally).
    pMapping - license group (if member).
    pProducts - shorthand list of products.

Return Values:

    None.

--*/

{
    EnableAutomation();

#ifdef ENABLE_PARENT_CHECK
    ASSERT(pParent &&
          (pParent->IsKindOf(RUNTIME_CLASS(CDomain)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CMapping)) ||
           pParent->IsKindOf(RUNTIME_CLASS(CController))));
#endif // ENABLE_PARENT_CHECK

    m_pParent = pParent;

    ASSERT(pName && *pName);

    if (pParent && pParent->IsKindOf(RUNTIME_CLASS(CDomain)))
    {
        m_strName = ((CDomain*)m_pParent)->m_strName;
        m_strName += _T("\\");
        m_strName += pName;
    }
    else
        m_strName = pName;

    m_strMapping = pMapping;
    m_bIsMapped  = pMapping && *pMapping;

    m_lInUse        = lInUse;
    m_lUnlicensed   = lUnlicensed;
    m_bIsValid      = ( 0 != ( dwFlags & LLS_FLAG_LICENSED  ) );
    m_bIsBackOffice = ( 0 != ( dwFlags & LLS_FLAG_SUITE_USE ) );

    m_pStatistics = NULL;
    m_statisticArray.RemoveAll();
    m_bStatisticsRefreshed = FALSE;

    m_strProducts = pProducts;
}


CUser::~CUser()

/*++

Routine Description:

    Destructor for user object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pStatistics)
        m_pStatistics->InternalRelease();
}


void CUser::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetStatistics();
    delete this;
}


LPDISPATCH CUser::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


long CUser::GetInUse()

/*++

Routine Description:

    Returns the number of licenses that the user is consuming.

Arguments:

    None.

Return Values:

    VT_I4.

--*/

{
    return m_lInUse;
}


BSTR CUser::GetFullName()

/*++

Routine Description:

    Returns fully qualified name of user.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return GetName();
}


BSTR CUser::GetMapping()

/*++

Routine Description:

    Returns name of mapping user added to, if any.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strMapping.AllocSysString();
}


BSTR CUser::GetName()

/*++

Routine Description:

    Returns the name of the user.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CUser::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return m_pParent ? m_pParent->GetIDispatch(TRUE) : NULL;
}


LPDISPATCH CUser::GetStatistics(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    usage statistics recorded on the license controller
    pertaining to the user or returns an individual
    usage statistic pertaining to the user described
    by an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pStatistics)
    {
        m_pStatistics = new CStatistics(this, &m_statisticArray);
    }

    if (m_pStatistics)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshStatistics())
            {
                lpdispatch = m_pStatistics->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bStatisticsRefreshed)
            {
                lpdispatch = m_pStatistics->GetItem(index);
            }
            else if (RefreshStatistics())
            {
                lpdispatch = m_pStatistics->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CUser::IsMapped()

/*++

Routine Description:

    Returns true if user is mapped.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsMapped;
}


BOOL CUser::Refresh()

/*++

Routine Description:

    Refreshs user object.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS NtStatus;
    PLLS_USER_INFO_1 pUserInfo1 = NULL;

    NtStatus = ::LlsUserInfoGet(
                    LlsGetActiveHandle(),
                    MKSTR(m_strName),
                    1,
                    (LPBYTE*)&pUserInfo1
                    );

    if (NT_SUCCESS(NtStatus))
    {
        if (RefreshStatistics())
        {
            m_strMapping    = pUserInfo1->Group;
            m_bIsMapped     = pUserInfo1->Group && *pUserInfo1->Group;

            m_lInUse        = pUserInfo1->Licensed;
            m_lUnlicensed   = pUserInfo1->UnLicensed;
            m_bIsValid      = ( 0 != ( pUserInfo1->Flags & LLS_FLAG_LICENSED  ) );
            m_bIsBackOffice = ( 0 != ( pUserInfo1->Flags & LLS_FLAG_SUITE_USE ) );
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }

#ifndef DISABLE_PER_NODE_ALLOCATION

        ::LlsFreeMemory(pUserInfo1->Name);
        ::LlsFreeMemory(pUserInfo1->Group);

#endif // DISABLE_PER_NODE_ALLOCATION

        ::LlsFreeMemory(pUserInfo1);
    }

    LlsSetLastStatus(NtStatus);   // called api

    return NT_SUCCESS(NtStatus);
}


BOOL CUser::RefreshStatistics()

/*++

Routine Description:

    Refreshs statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetStatistics();

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iStatistic = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsUserProductEnum(
                        LlsGetActiveHandle(),
                        MKSTR(m_strName),
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CStatistic*              pStatistic;
            PLLS_USER_PRODUCT_INFO_1 pUserProductInfo1;

            pUserProductInfo1 = (PLLS_USER_PRODUCT_INFO_1)ReturnBuffer;

            ASSERT(iStatistic == m_statisticArray.GetSize());
            m_statisticArray.SetSize(m_statisticArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pStatistic = new CStatistic(
                                    this,
                                    pUserProductInfo1->Product,
                                    pUserProductInfo1->Flags,
                                    pUserProductInfo1->LastUsed,
                                    pUserProductInfo1->UsageCount
                                    );

                m_statisticArray.SetAt(iStatistic++, pStatistic);   // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pUserProductInfo1->Product);

#endif // DISABLE_PER_NODE_ALLOCATION

                pUserProductInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bStatisticsRefreshed = TRUE;
    }
    else
    {
        ResetStatistics();
    }

    return m_bStatisticsRefreshed;
}


void CUser::ResetStatistics()

/*++

Routine Description:

    Resets statistic object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CStatistic* pStatistic;
    INT_PTR     iStatistic = m_statisticArray.GetSize();

    while (iStatistic--)
    {
        if (pStatistic = (CStatistic*)m_statisticArray[iStatistic])
        {
            ASSERT(pStatistic->IsKindOf(RUNTIME_CLASS(CStatistic)));
            pStatistic->InternalRelease();
        }
    }

    m_statisticArray.RemoveAll();
    m_bStatisticsRefreshed = FALSE;
}


long CUser::GetUnlicensed()
{
    return m_lUnlicensed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrobj.h

Abstract:

    User object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _USROBJ_H_
#define _USROBJ_H_

class CUser : public CCmdTarget
{
    DECLARE_DYNCREATE(CUser)
private:
    CCmdTarget*  m_pParent;
    CObArray     m_statisticArray;
    BOOL         m_bStatisticsRefreshed;

public:
    CString      m_strName;
    CString      m_strMapping;
    CString      m_strProducts;     // blah...
    BOOL         m_bIsMapped;
    BOOL         m_bIsBackOffice;   // blah...
    BOOL         m_bIsValid;        
    long         m_lInUse;
    long         m_lUnlicensed;

    CStatistics* m_pStatistics;

public:
    CUser(
        CCmdTarget* pParent     = NULL,
        LPCTSTR     pName       = NULL, 
        DWORD       dwFlags     = 0L,
        long        lInUse      = 0L,
        long        lUnlicensed = 0L,
        LPCTSTR     pMapping    = NULL,
        LPCTSTR     pProducts   = NULL
        );
    virtual ~CUser();

    BOOL Refresh();

    BOOL RefreshStatistics();
    void ResetStatistics();

    BSTR GetFullName();

    //{{AFX_VIRTUAL(CUser)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CUser)
    afx_msg LPDISPATCH GetApplication();
    afx_msg long GetInUse();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg BSTR GetMapping();
    afx_msg BOOL IsMapped();
    afx_msg long GetUnlicensed();
    afx_msg LPDISPATCH GetStatistics(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CUser)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#define IsUserInViolation(usr)  (!(usr)->m_bIsValid)

#define CalcUserBitmap(usr)     (IsUserInViolation(usr) ? BMPI_VIOLATION : BMPI_USER)

#endif // _USROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\llsmgr\usrppgp.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    usrppgp.cpp

Abstract:

    User property page (products) implementation.

Author:

    Don Ryan (donryan) 05-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "usrppgp.h"
#include "prdpsht.h"

#define LV