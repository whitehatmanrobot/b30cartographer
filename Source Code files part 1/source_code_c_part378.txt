s like the domain's name.
    //

    ULONG DomainIndex;

    //
    // NT5 and above SAM tracks the client's version in the context. This
    // allows newer error codes to be returned ( otherwise not possible )
    // due to downlevel client limitations
    //

    ULONG ClientRevision;

    //
    // This field indicates whether an audit generation routine must be
    // called when this context block is deleted (which represents a
    // handle being deleted). This cannot be a bit field as this has to
    // be passed on to NtAccessCheckAndAuditAlarm
    //

    BOOLEAN AuditOnClose;

    //
    // Attribute level access
    //
    SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(WriteGrantedAccessAttributes)


    //
    //  The body of each object.
    //

    union {

        SAMP_SERVER_OBJECT Server;      // local-account object types
        SAMP_DOMAIN_OBJECT Domain;
        SAMP_GROUP_OBJECT Group;
        SAMP_ALIAS_OBJECT Alias;
        SAMP_USER_OBJECT User;

    } TypeBody;


} SAMP_OBJECT, *PSAMP_OBJECT;




///////////////////////////////////////////////////////////////////////////////
//
// Data structures used to store information in the registry
//
///////////////////////////////////////////////////////////////////////////////

//
// Fixed length portion of a revision 1 Server object
//

typedef struct _SAMP_V1_FIXED_LENGTH_SERVER {

    ULONG RevisionLevel;

} SAMP_V1_FIXED_LENGTH_SERVER, *PSAMP_V1_FIXED_LENGTH_SERVER;

//
// Fixed length portion of a Domain
// (previous release formats of this structure follow)
//
// Note: in version 1.0 of NT, the fixed length portion of
//       a domain was stored separate from the variable length
//       portion.  This allows us to compare the size of the
//       data read from disk against the size of a V1_0A form
//       of the fixed length data to determine whether it is
//       a Version 1 format or later format.
//
// Note: In NT4 SP3 the new domain format was introduced to
//      stored password encryption keys in the builtin & account domain
//      objects.
//
//

#define SAMP_DOMAIN_KEY_INFO_LENGTH 64

//
// This flag determines whether or not we are using a session key to
// encrypt secret data
//

#define SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED 0x1
//
// This is an Auth Flag that indicates that the machine has had
// a transition during NT4 upgrade
//

#define SAMP_DOMAIN_KEY_AUTH_FLAG_UPGRADE    0x2

typedef struct _SAMP_V1_0A_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;
    UCHAR           Unused2[3];                 // padding
    USHORT          DomainKeyAuthType;
    USHORT          DomainKeyFlags;
    UCHAR           DomainKeyInformation[SAMP_DOMAIN_KEY_INFO_LENGTH];  // new for NT4 SP3
    UCHAR           DomainKeyInformationPrevious[SAMP_DOMAIN_KEY_INFO_LENGTH];//new for whistler
    ULONG           CurrentKeyId;
    ULONG           PreviousKeyId;

} SAMP_V1_0A_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_FIXED_LENGTH_DOMAIN;

typedef struct _SAMP_V1_0A_W2K_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;
    UCHAR           Unused2[3];                 // padding
    USHORT          DomainKeyAuthType;
    USHORT          DomainKeyFlags;
    UCHAR           DomainKeyInformation[SAMP_DOMAIN_KEY_INFO_LENGTH];  // new for NT4 SP3

} SAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN;

typedef struct _SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;

} SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN;


typedef struct _SAMP_V1_0_FIXED_LENGTH_DOMAIN {

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER ModifiedCount;
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
    LARGE_INTEGER ForceLogoff;

    ULONG NextRid;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;

    BOOLEAN UasCompatibilityRequired;

} SAMP_V1_0_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0_FIXED_LENGTH_DOMAIN;






//
// Fixed length portion of a revision 1 group account
//
// Note:  MemberCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Member RID
//        list in the MEMBERS key.
//

typedef struct _SAMP_V1_FIXED_LENGTH_GROUP {

    ULONG RelativeId;
    ULONG Attributes;
    UCHAR AdminGroup;

} SAMP_V1_FIXED_LENGTH_GROUP, *PSAMP_V1_FIXED_LENGTH_GROUP;

typedef struct _SAMP_V1_0A_FIXED_LENGTH_GROUP {

    ULONG Revision;
    ULONG RelativeId;
    ULONG Attributes;
    ULONG Unused1;
    UCHAR AdminCount;
    UCHAR OperatorCount;

} SAMP_V1_0A_FIXED_LENGTH_GROUP, *PSAMP_V1_0A_FIXED_LENGTH_GROUP;


//
// Fixed length portion of a revision 1 alias account
//
// Note:  MemberCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Member RID
//        list in the MEMBERS key.
//

typedef struct _SAMP_V1_FIXED_LENGTH_ALIAS {

    ULONG RelativeId;

} SAMP_V1_FIXED_LENGTH_ALIAS, *PSAMP_V1_FIXED_LENGTH_ALIAS;



//
// Fixed length portion of a user account
// (previous release formats of this structure follow)
//
// Note:  GroupCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Group RID
//        list in the GROUPS key.
//
// Note: in version 1.0 of NT, the fixed length portion of
//       a user was stored separate from the variable length
//       portion.  This allows us to compare the size of the
//       data read from disk against the size of a V1_0A form
//       of the fixed length data to determine whether it is
//       a Version 1 format or later format.


//
// This is the fixed length user from NT3.51 QFE and SUR
//


typedef struct _SAMP_V1_0A_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;
    USHORT          Unused2;
    USHORT          OperatorCount;

} SAMP_V1_0A_FIXED_LENGTH_USER, *PSAMP_V1_0A_FIXED_LENGTH_USER;

//
// This is the fixed length user from NT3.5 and NT3.51
//


typedef struct _SAMP_V1_0_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;

} SAMP_V1_0_FIXED_LENGTH_USER, *PSAMP_V1_0_FIXED_LENGTH_USER;


//
// This is the fixed length user from NT3.1
//

typedef struct _SAMP_V1_FIXED_LENGTH_USER {

    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;

    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;

    USHORT CountryCode;
    USHORT CodePage;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT AdminCount;


} SAMP_V1_FIXED_LENGTH_USER, *PSAMP_V1_FIXED_LENGTH_USER;


//
// Domain account information is cached in memory in a sorted list.
// This allows fast return of information to user-interactive clients.
// One of these structures is part of the in-memory information for each domain.
//

typedef struct _PSAMP_DOMAIN_DISPLAY_INFORMATION {

    RTL_GENERIC_TABLE2 RidTable;
    ULONG TotalBytesInRidTable;

    RTL_GENERIC_TABLE2 UserTable;
    ULONG TotalBytesInUserTable;

    RTL_GENERIC_TABLE2 MachineTable;
    ULONG TotalBytesInMachineTable;

    RTL_GENERIC_TABLE2 InterdomainTable;
    ULONG TotalBytesInInterdomainTable;

    RTL_GENERIC_TABLE2 GroupTable;
    ULONG TotalBytesInGroupTable;


    //
    // These fields specify whether the cached information is valid.
    // If TRUE, the cache contains valid information
    // If FALSE,  trees are empty.
    //

    BOOLEAN UserAndMachineTablesValid;
    BOOLEAN GroupTableValid;

} SAMP_DOMAIN_DISPLAY_INFORMATION, *PSAMP_DOMAIN_DISPLAY_INFORMATION;


//
// Domain account information data structure used to pass data to the
// cache manipulation routines. This structure is the union of the cached
// data for all the account types that we keep in the cache. Other SAM routines
// can call fill this structure in without knowing which type of account
// requires which elements.
//

typedef struct _SAMP_ACCOUNT_DISPLAY_INFO {
    ULONG           Rid;
    ULONG           AccountControl;   // Also used as Attributes for groups
    UNICODE_STRING  Name;
    UNICODE_STRING  Comment;
    UNICODE_STRING  FullName;

} SAMP_ACCOUNT_DISPLAY_INFO, *PSAMP_ACCOUNT_DISPLAY_INFO;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Alias Membership Lists.                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_AL_REFERENCED_DOMAIN {

    ULONG DomainReference;
    PSID DomainSid;

} SAMP_AL_REFERENCED_DOMAIN, *PSAMP_AL_REFERENCED_DOMAIN;

typedef struct _SAMP_AL_REFERENCED_DOMAIN_LIST {

    ULONG SRMaximumLength;
    ULONG SRUsedLength;
    ULONG MaximumCount;
    ULONG UsedCount;
    PSAMP_AL_REFERENCED_DOMAIN Domains;

} SAMP_AL_REFERENCED_DOMAIN_LIST, *PSAMP_AL_REFERENCED_DOMAIN_LIST;

typedef struct _SAMP_AL_SR_REFERENCED_DOMAIN {

    ULONG Length;
    ULONG DomainReference;
    SID DomainSid;

} SAMP_AL_SR_REFERENCED_DOMAIN, *PSAMP_AL_SR_REFERENCED_DOMAIN;

typedef struct _SAMP_AL_SR_REFERENCED_DOMAIN_LIST {

    ULONG SRMaximumLength;
    ULONG SRUsedLength;
    ULONG MaximumCount;
    ULONG UsedCount;
    SAMP_AL_SR_REFERENCED_DOMAIN Domains[ANYSIZE_ARRAY];

} SAMP_AL_SR_REFERENCED_DOMAIN_LIST, *PSAMP_AL_SR_REFERENCED_DOMAIN_LIST;


//
// The Alias Membership Lists are global data structures maintained by SAM
// to provide rapid retrieval of Alias membership information.  There are
// two types of Lists, the Alias Member List which is used to retrieve members
// of Aliases and the Member Alias List which is used to retrieve the aliases
// that members belong to.  A pair of these lists exists for each local
// SAM Domain (currently, the BUILTIN and Accounts domain are the only two)
//
// Currently, these lists are used as memory caches.  They are generated at
// system boot from the information stored in the SAM Database in the Registry
// and SAM keeps them up to date when Alias memberships change.  Thus SAM
// API which perform lookup/read operations can use these lists instead of
// accessing the Registry keys directly.  At a future date, it may be possible
// to back up the lists directly to the Registry and make obsolete the current
// information for Alias membership stored there.  Because these lists are
// used as caches, they can be invalidated when the going gets tough, in which
// case, API will read their information directly from the Registry.
//
// Alias Member List
//
// This is the 'Alias-to-Member' List.  Given one or more Aliases, it is used to
// find their members.  One of these lists exists for each local SAM Domain.
// The Alias Member List specifies all/ of the information describing aliases
// in the local SAM Domain.  It is designed for fast retrieval of alias
// membership information for an account given the account's Sid.
//
// An Alias Member List is structured.  For each Alias in the list, the accounts that
// are mebers of the Alias are classified by their Referenced Domain.  If an
// account is a member of n aliases in the SAM Local Domain to which an Alias
// List relates, there will be n entries for the account in the Alias Member List -
//
// are classified by domain.  If an AccountSid is a member of n aliases in a given SAM
// Local Domain, there are n entries for it in the Alias Member List.
//
// The structure of an Alias Member List consists of three levels.  These are, from
// the top down:
//
// * The Alias Member List structure (SAMP_AL_ALIAS_LIST)
//
// The Alias Member List structure specifies all aliases in the local SAM Domain.
// One of these exists per local SAM domain.  It contains a list of Alias
// structures.
//
// * The Alias structure
//
// One Alias structure exists for each alias in the local SAM Domain.  An
// Alias structure contains an array of Domain structures.
//
// * The Domain structure
//
// The Domain structure describes a Domain which has one or more accounts
// belonging to one or more aliases in the local SAM domain.  The structure
// contains a list of these member accounts.
//
// The entire Alias Member List is self relative, facilitating easy storage and
// retrieval from backing storage.
//

typedef struct _SAMP_AL_DOMAIN {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG DomainReference;
    ULONG RidCount;
    ULONG Rids[ANYSIZE_ARRAY];

} SAMP_AL_DOMAIN, *PSAMP_AL_DOMAIN;

typedef struct _SAMP_AL_ALIAS {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG AliasRid;
    ULONG DomainCount;
    SAMP_AL_DOMAIN Domains[ANYSIZE_ARRAY];

} SAMP_AL_ALIAS, *PSAMP_AL_ALIAS;

typedef struct _SAMP_AL_ALIAS_MEMBER_LIST {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG AliasCount;
    ULONG DomainIndex;
    ULONG Enabled;
    SAMP_AL_ALIAS Aliases[ANYSIZE_ARRAY];

} SAMP_AL_ALIAS_MEMBER_LIST, *PSAMP_AL_ALIAS_MEMBER_LIST;

//
// Member Alias List.
//
// This is the 'Member to Alias' List.  Given one or more member account Sids,
// this list is used to find all the Aliases to which one or more of the
// members belongs.  One Member Alias List exists for each local SAM Domain.
// The list contains all of the membership relationships for aliases in the
// Domain.  The member accounts are grouped by sorted Rid within Domain
// Sid, and for each Rid the list contains an array of the Rids of the Aliases
// to which it belongs.
//
// This list is implemented in a Self-Relative format for easy backup and
// restore.  For now, the list is being used simply as a cache, which is
// constructed at system load, and updated whenever membership relationships
// change.  When the going gets tough, we just ditch the cache.  Later, it
// may be desirable to save this list to a backing store (e.g. to a Registry
// Key)
//
// The list is implemented as a 3-tier hierarchy.  These are described
// from the top down.
//
// Member Alias List (SAMP_AL_MEMBER_ALIAS_LIST)
//
// This top-level structure contains the list header.  The list header
// contains a count of the Member Domains and also the DomainIndex of the
// SAM Local Domain to which the list relates.
//
// Member Domain
//
// One of these exists for each Domain that contains one or more accounts
// that are members of one or more Aliases in the SAM local Domain.
//
// Member Account
//
// One of these exists for each account that is a member of one or more
// Aliases in the SAM Local Domain.  A Member Account structure specifies
// the Rid of the member and the Rid of the Aliases to which it belongs
// (only Aliases in the associated local SAM Domain are listed).
//

typedef struct _SAMP_AL_MEMBER_ACCOUNT {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG Rid;
    ULONG AliasCount;
    ULONG AliasRids[ ANYSIZE_ARRAY];

} SAMP_AL_MEMBER_ACCOUNT, *PSAMP_AL_MEMBER_ACCOUNT;

typedef struct _SAMP_AL_MEMBER_DOMAIN {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG RidCount;
    SID DomainSid;

} SAMP_AL_MEMBER_DOMAIN, *PSAMP_AL_MEMBER_DOMAIN;

typedef struct _SAMP_AL_MEMBER_ALIAS_LIST {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG DomainIndex;
    ULONG DomainCount;
    SAMP_AL_MEMBER_DOMAIN MemberDomains[ANYSIZE_ARRAY];

} SAMP_AL_MEMBER_ALIAS_LIST, *PSAMP_AL_MEMBER_ALIAS_LIST;

//
// Alias Information
//
// This is the top level structure which connects the Lists. One of these
// appears in the SAMP_DEFINED_DOMAINS structure.
//
//  The connection between the lists is as follows
//
//  SAMP_DEFINED_DOMAINS Contains SAMP_AL_ALIAS_INFORMATION
//
//  SAMP_AL_ALIAS_INFORMATION contains pointers to
//  SAMP_AL_ALIAS_MEMBER_LIST and SAMP_AL_MEMBER_ALIAS_LIST
//
//  SAMP_AL_ALIAS_MEMBER_LIST and SAMP_AL_MEMBER_ALIAS_LIST contain
//  the DomainIndex of the SAMP_DEFINED_DOMAINS structure.
//
//  Thus it is possible to navigate from any list to any other.
//

typedef struct _SAMP_AL_ALIAS_INFORMATION {

    BOOLEAN Valid;
    UNICODE_STRING AliasMemberListKeyName;
    UNICODE_STRING MemberAliasListKeyName;

    HANDLE AliasMemberListKeyHandle;
    HANDLE MemberAliasListKeyHandle;

    PSAMP_AL_ALIAS_MEMBER_LIST AliasMemberList;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList;

    SAMP_AL_REFERENCED_DOMAIN_LIST ReferencedDomainList;

} SAMP_AL_ALIAS_INFORMATION, *PSAMP_AL_ALIAS_INFORMATION;

typedef struct _SAMP_AL_SPLIT_MEMBER_SID {

    ULONG Rid;
    PSID DomainSid;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain;

} SAMP_AL_SPLIT_MEMBER_SID, *PSAMP_AL_SPLIT_MEMBER_SID;

typedef struct _SAMP_AL_SPLIT_MEMBER_SID_LIST {

    ULONG Count;
    PSAMP_AL_SPLIT_MEMBER_SID Sids;

} SAMP_AL_SPLIT_MEMBER_SID_LIST, *PSAMP_AL_SPLIT_MEMBER_SID_LIST;



//
// Information about the names and RID's of accounts for a domain
// (meant only for the BUILTIN domain which contains only a few aliases)
//
typedef struct _SAMP_ACCOUNT_NAME_CACHE {

    ULONG Count;
    struct {
        ULONG Rid;
        UNICODE_STRING Name;
    }*Entries;

}SAMP_ACCOUNT_NAME_CACHE, *PSAMP_ACCOUNT_NAME_CACHE;



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Information about each domain that is kept readily available in memory  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef struct _PSAMP_DEFINED_DOMAINS {

    //
    // This field contains a handle to a context open to the domain object.
    // This handle can be used to reference in-memory copies of all
    // attributes and is used when writing out changes to the object.
    //

    PSAMP_OBJECT Context;

    //
    // (Should keep the domain's security descriptor here)
    //




    //
    // This field contains the SID of the domain.
    //

    PSID Sid;

    //
    // This field contains the external name of this domain.  This is the
    // name by which the domain is known outside SAM and is the name
    // recorded by the LSA in the PolicyAccountDomainInformation
    // information class for the Policy Object.
    //

    UNICODE_STRING ExternalName;

    //
    // This field contains the internal name of this domain.  This is the
    // name by which the domain is known inside SAM.  It is set at
    // installation and never changes.
    //

    UNICODE_STRING InternalName;

    //
    // These fields contain standard security descriptors for new user,
    // group, and alias accounts within the corresponding domain.
    //
    // The following security descriptors are prepared:
    //
    //         AdminUserSD - Contains a SD appropriate for applying to
    //             a user object that is a member of the ADMINISTRATORS
    //             alias.
    //
    //         AdminGroupSD - Contains a SD appropriate for applying to
    //             a group object that is a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalUserSD - Contains a SD appropriate for applying to
    //             a user object that is NOT a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalGroupSD - Contains a SD appropriate for applying to
    //             a Group object that is NOT a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalAliasSD - Contains a SD appropriate for applying to
    //             newly created alias objects.
    //
    //
    //
    // Additionally, the following related information is provided:
    //
    //         AdminUserRidPointer
    //         NormalUserRidPointer
    //
    //             Points to the last RID of the ACE in the corresponding
    //             SD's DACL which grants access to the user.  This rid
    //             must be replaced with the user's rid being the SD is
    //             applied to the user object.
    //
    //
    //
    //         AdminUserSDLength
    //         AdminGroupSDLength
    //         NormalUserSDLength
    //         NormalGroupSDLength
    //         NormalAliasSDLength
    //
    //             The length, in bytes, of the corresponding security
    //             descriptor.
    //

    PSECURITY_DESCRIPTOR
               AdminUserSD,
               AdminGroupSD,
               NormalUserSD,
               NormalGroupSD,
               NormalAliasSD;

    PULONG     AdminUserRidPointer,
               NormalUserRidPointer;

    ULONG      AdminUserSDLength,
               AdminGroupSDLength,
               NormalUserSDLength,
               NormalGroupSDLength,
               NormalAliasSDLength;


    //
    // There are two copies of the fixed length domain information.
    // When a transaction is started, the "UnmodifiedFixed" field is copied
    // to the "CurrentFixed" field.  The CurrentFixed field is the field
    // all operations should be performed on (like allocating new RIDs).
    // When a write-lock is released, the CurrentFixed information will
    // either be automatically written out (if the transaction is to be
    // committed) or discarded (if the transaction is to be rolled back).
    // If the transaction is committed, then the CurrentField will also be
    // copied to the UnmodifiedFixed field, making it available for the next
    // transaction.
    //
    // This allows an operation to proceed, operating on fields
    // (specifically, the NextRid and ModifiedCount fields) without
    // regard to whether the operation will ultimately be committed or
    // rolled back.
    //

    SAMP_V1_0A_FIXED_LENGTH_DOMAIN
                                CurrentFixed,
                                UnmodifiedFixed;


    //
    // Flag Indicating wether CurrentFixed and Unmodified Fixed are valid
    //

    BOOLEAN     FixedValid;

    //
    // Serial Number for Netlogon ChangeLog
    //

    LARGE_INTEGER  NetLogonChangeLogSerialNumber;


    //
    // Cached display information
    //

    SAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    //
    // Cached Alias Information
    //

    SAMP_AL_ALIAS_INFORMATION AliasInformation;


    //
    // Indicates that the domain is a builtin domain
    //

    BOOLEAN    IsBuiltinDomain;

    //
    // Indicates that this is a mixed domain. This bit is set at startup
    // time.
    //

    BOOLEAN     IsMixedDomain;

    //
    // Indicates that this domain is the root domain of the forest.
    // this flag should be used only in DS case
    //

    BOOLEAN     IsForestRootDomain;

    //
    // Maintains the behaviour version of the domain
    //

    ULONG     BehaviorVersion;

    //
    // Keeps the LastLogonTimeStampSyncInterval in memory
    // 

    ULONG       LastLogonTimeStampSyncInterval;

    //
    // Maintains the server role. The server role is also maintained
    // in the current fixed and unmodified fixed structures, for the
    // sake of old code that references the role in these structures
    //


    DOMAIN_SERVER_ROLE  ServerRole;


    //
    // The Domain handle for DirFindEntry
    //

    ULONG               DsDomainHandle;


    //
    // The DNS Domain Information
    //

    UNICODE_STRING      DnsDomainName;

    //
    // Indicates that the domain allocates large sids
    //
    BOOLEAN IsExtendedSidDomain;

    //
    // Cached information about account names for
    // lookup purposes.  Does not require the SAM lock to
    // be referenced
    //
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;


} SAMP_DEFINED_DOMAINS, *PSAMP_DEFINED_DOMAINS;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// This structure is used to describe where the data for               //
// an object's variable length attribute is.  This is a                //
// self-relative structure, allowing it to be stored on disk           //
// and later retrieved and used without fixing pointers.               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_VARIABLE_LENGTH_ATTRIBUTE {
    //
    // Indicates the offset of data from the address of this data
    // structure.
    //

    LONG Offset;


    //
    // Indicates the length of the data.
    //

    ULONG Length;


    //
    // A 32-bit value that may be associated with each variable
    // length attribute.  This may be used, for example, to indicate
    // how many elements are in the variable-length attribute.
    //

    ULONG Qualifier;

}  SAMP_VARIABLE_LENGTH_ATTRIBUTE, *PSAMP_VARIABLE_LENGTH_ATTRIBUTE;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// The  following structures represent the On-Disk Structure of each   //
// object type.  Each object has a fixed length data portion and a     //
// variable length data portion.  Information in the object type       //
// descriptor indicates how many variable length attributes the object //
// has and whether the fixed and variable length data are stored       //
// together in one registry key attribute, or, alternatively, each is  //
// stored in its own registry key attribute.                           //
//                                                                     //
//                                                                     //
//                                                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// SERVER object on-disk structure                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_SERVER_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_FIXED_LENGTH_SERVER V1Fixed;


#if SAMP_SERVER_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_SERVER_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_SERVER_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_SERVER_OBJECT, *PSAMP_ON_DISK_SERVER_OBJECT;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// DOMAIN object on-disk structure                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_DOMAIN_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_DOMAIN V1Fixed;


#if SAMP_DOMAIN_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_DOMAIN_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_DOMAIN_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_DOMAIN_OBJECT, *PSAMP_ON_DISK_DOMAIN_OBJECT;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// USER object on-disk structure                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_USER_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_USER V1Fixed;


#if SAMP_USER_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_USER_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_USER_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_USER_OBJECT, *PSAMP_ON_DISK_USER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// GROUP object on-disk structure                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_GROUP_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;


#if SAMP_GROUP_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_GROUP_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_GROUP_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_GROUP_OBJECT, *PSAMP_ON_DISK_GROUP_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// ALIAS object on-disk structure                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_ALIAS_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_FIXED_LENGTH_ALIAS V1Fixed;


#if SAMP_ALIAS_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_ALIAS_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_ALIAS_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_ALIAS_OBJECT, *PSAMP_ON_DISK_ALIAS_OBJECT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Data structures associated with secret data                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This type is encapsulated within a UNICODE_STRING structure when storing
// secret data such as passwords or password histories. The length of the
// UNICODE_STRING should include the overhead of this structure. The pad
// field ensures that
//

#include <pshpack1.h>
typedef struct _SAMP_SECRET_DATA {
    USHORT KeyId;
    USHORT Flags;
    UCHAR Data[ANYSIZE_ARRAY];
} SAMP_SECRET_DATA, *PSAMP_SECRET_DATA;
#include <poppack.h>

//
// This macro calculates the space required for encrypting  a clear buffer of
// length _x_
//

#define SampSecretDataSize(_x_) (sizeof(SAMP_SECRET_DATA) - ANYSIZE_ARRAY * sizeof(UCHAR) + (_x_))

//
// This macro calculates the space required for decrypting a clear buffer of
// length _x_
//

#define SampClearDataSize(_x_) ((_x_) - (SampSecretDataSize(0)))

//
// This macro indentifies whether or not a unicode string structure contains
// encrypted data
//

#define SampIsDataEncrypted(_x_) ((((_x_)->Length % ENCRYPTED_LM_OWF_PASSWORD_LENGTH)==SampSecretDataSize(0)) && \
        (*(PUSHORT)((_x_)->Buffer) >= 1))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Enumerated types for manipulating group memberships                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _SAMP_MEMBERSHIP_DELTA {
    AddToAdmin,
    NoChange,
    RemoveFromAdmin
} SAMP_MEMBERSHIP_DELTA, *PSAMP_MEMBERSHIP_DELTA;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Notification information structure, used to generate delayed notification //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DELAYED_NOTIFICATION_INFORMATION {
     SECURITY_DB_OBJECT_TYPE    DbObjectType;
     SECURITY_DB_DELTA_TYPE     DeltaType;
     NT4SID                     DomainSid;
     ULONG                      Rid;
     UNICODE_STRING             AccountName;
     LARGE_INTEGER              SerialNumber;
} SAMP_DELAYED_NOTIFICATION_INFORMATION, *PSAMP_DELAYED_NOTIFICATION_INFORMATION;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                                                                           //
// The following typedefs were moved in from bldsam3.c so that sdconvert can //
// reference them                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// domain selector
//

typedef enum _SAMP_DOMAIN_SELECTOR {

    DomainBuiltin = 0,
    DomainAccount

} SAMP_DOMAIN_SELECTOR, *PSAMP_DOMAIN_SELECTOR;

//
// Types of protection that may be assigned to accounts
//

typedef ULONG SAMP_ACCOUNT_PROTECTION;

#define SAMP_PROT_SAM_SERVER                (0L)
#define SAMP_PROT_BUILTIN_DOMAIN            (1L)
#define SAMP_PROT_ACCOUNT_DOMAIN            (2L)
#define SAMP_PROT_ADMIN_ALIAS               (3L)
#define SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS  (4L)
#define SAMP_PROT_NORMAL_ALIAS              (5L)
#define SAMP_PROT_ADMIN_GROUP               (6L)
#define SAMP_PROT_NORMAL_GROUP              (7L)
#define SAMP_PROT_ADMIN_USER                (8L)
#define SAMP_PROT_NORMAL_USER               (9L)
#define SAMP_PROT_GUEST_ACCOUNT             (10L)
#define SAMP_PROT_TYPES                     (11L)

//
// Protection information for SAM objects
//

typedef struct _SAMP_PROTECTION {

    ULONG Length;
    PSECURITY_DESCRIPTOR Descriptor;
    PULONG RidToReplace;
    BOOLEAN RidReplacementRequired;

} SAMP_PROTECTION, *PSAMP_PROTECTION;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// These typedefs are for the prefetch mechanism in SAM to intelligently    //
// control the # of attributes being read when a context is created         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_PREFETCH_TABLE {
    ATTRTYP Attribute;
    ULONG   ExtendedField;
} SAMP_PREFETCH_TABLE;

#define USER_EXTENDED_FIELD_INTERNAL_SITEAFFINITY (0x00000001L)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Special Functions exported by SAM to NTDSA.dll that allows NTDSA to      //
//  inform about object changes                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampNetLogonNotificationRequired(
    PSID ObjectSid,
    SAMP_OBJECT_TYPE SampObjectType
    );

VOID
SampNotifyReplicatedInChange(
    IN PSID    ObjectSid,
    IN BOOL    WriteLockHeldByDs,
    IN SECURITY_DB_DELTA_TYPE  DeltaType,
    IN SAMP_OBJECT_TYPE    SampObjectType,
    IN PUNICODE_STRING     AccountName,
    IN ULONG   AccountControl,
    IN ULONG   GroupType,
    IN ULONG   CallerType,
    IN BOOL    MixedModeChange,
    IN BOOL    UserAccountControlChange
    );

VOID
SampNotifyAuditChange(
    IN PSID                       ObjectSid,
    IN SECURITY_DB_DELTA_TYPE     DeltaType,
    IN SAMP_OBJECT_TYPE           ObjectType,
    IN PUNICODE_STRING            AccountName,
    IN ULONG                      AccountControl,
    IN ULONG                      GroupType,
    IN ULONG                      CallerType,
    IN PPRIVILEGE_SET             Privileges,
    IN ULONG                      AuditType,
    IN PVOID                      AuditInfo
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Special Functions exported by SAM to NTDSA.dll that allows NTDSA to       //
//  collect auditing information                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
          

BOOLEAN
SampIsAuditingEnabled(
    IN ULONG DomainIndex,
    IN NTSTATUS Status
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Special Function exported by SAM to NTDSA.dll that allows NTDSA to       //
//  request SAM to invalidate the current rid range used by the DC           //
//  for new account creation                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInvalidateRidRange(BOOLEAN fAuthoritative);

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Special functions exported by SAM to ntdsa.dll that allows to set        //
// NT4 replication state                                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
SampGetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    );

NTSTATUS
SampSetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Special Functions exported to NTDSA.dll for loopback operations           //                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamISetMixedDomainFlag(
    IN SAMPR_HANDLE DomainHandle
    );


NTSTATUS
SamIDsSetObjectInformation(
    IN SAMPR_HANDLE ObjectHandle,
    IN DSNAME       *pObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    );


NTSTATUS
SamIDsCreateObjectInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PRPC_UNICODE_STRING  AccountName,
    IN ULONG UserAccountType, 
    IN ULONG GroupType,
    IN ACCESS_MASK  DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT PULONG  GrantedAccess,
    IN OUT PULONG RelativeId
    );


NTSTATUS
SamILoopbackConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SamIAddDSNameToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    );

NTSTATUS
SamIRemoveDSNameFromGroup(
    IN  SAMPR_HANDLE GroupHandle,
    IN DSNAME * DSName
    );

NTSTATUS
SamIAddDSNameToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG        Attribute,
    IN DSNAME * DSName
    );

NTSTATUS
SamIRemoveDSNameFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG        Attribute,
    IN DSNAME * DSName
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  THESE ROUTINES MUST NOT BE CALLED BY NON-SAM CODE !          //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Site support API's
//
NTSTATUS
SampFindUserSiteAffinity(
    IN PSAMP_OBJECT AccountContext,
    IN ATTRBLOCK* Attrs,
    OUT SAMP_SITE_AFFINITY *pSiteAffinity
    );

NTSTATUS
SampRefreshSiteAffinity(
    IN PSAMP_OBJECT AccountContext
    );

BOOLEAN
SampCheckForSiteAffinityUpdate(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        Flags,
    IN  PSAMP_SITE_AFFINITY pOldSA,
    OUT PSAMP_SITE_AFFINITY pNewSA,
    OUT BOOLEAN*            fDeleteOld
    );

NTSTATUS
SampInitSiteInformation(
    VOID
    );

NTSTATUS
SampUpdateSiteInfoCallback(
    PVOID
    );

BOOLEAN
SampIsGroupCachingEnabled(
    IN  PSAMP_OBJECT AccountContext
    );


NTSTATUS
SampExtractClientIpAddr(      
    IN PSAMP_OBJECT Context
    );

//
// SAM's shutdown notification routine
//


BOOL SampShutdownNotification( DWORD   dwCtrlType );


//
// Sub-Component initialization routines
//

BOOLEAN SampInitializeDomainObject(VOID);

NTSTATUS
SampInitializeRegistry (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL,
    BOOLEAN                     EnableSecretEncryption OPTIONAL
    );

NTSTATUS
SampReInitializeSingleDomain(
    ULONG Index
    );

//
// database and lock related services
//

VOID
SampAcquireReadLock(VOID);


VOID
SampReleaseReadLock(VOID);


VOID
SampMaybeAcquireReadLock(
    IN PSAMP_OBJECT Context,
    IN ULONG  Control,
    OUT BOOLEAN * fLockAcquired
    );

VOID
SampMaybeReleaseReadLock(
    IN BOOLEAN fLockAcquired
    );

NTSTATUS
SampAcquireWriteLock( VOID );


NTSTATUS
SampReleaseWriteLock(
    IN BOOLEAN Commit
    );

NTSTATUS
SampMaybeAcquireWriteLock(
    IN PSAMP_OBJECT Context,
    OUT BOOLEAN * fLockAcquired
    );

NTSTATUS
SampMaybeReleaseWriteLock(
    IN BOOLEAN fLockAcquired,
    IN BOOLEAN Commit
    );

VOID
SampAcquireSamLockExclusive(VOID);


VOID
SampReleaseSamLockExclusive(VOID);


BOOLEAN
SampCurrentThreadOwnsLock();



NTSTATUS
SampCommitChanges();

NTSTATUS
SampCommitAndRetainWriteLock(
    VOID
    );

NTSTATUS
SampCommitChangesToRegistry(
    BOOLEAN  * AbortDone
    );


VOID
SampSetTransactionDomain(
    IN ULONG DomainIndex
    );



//
// Context block manipulation services
//

PSAMP_OBJECT
SampCreateContext(
    IN SAMP_OBJECT_TYPE Type,
    IN ULONG   DomainIndex,
    IN BOOLEAN TrustedClient
    );

PSAMP_OBJECT
SampCreateContextEx(
    IN SAMP_OBJECT_TYPE Type,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN DsMode,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN LazyCommit,
    IN BOOLEAN PersistAcrossCalls,
    IN BOOLEAN BufferWrites,
    IN BOOLEAN OpenedByDCPromo,
    IN ULONG   DomainIndex
    );

VOID
SampDeleteContext(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampLookupContext(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    );

NTSTATUS
SampLookupContextEx(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN PRTL_BITMAP RequestedAttributeAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    );

VOID
SampReferenceContext(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampDeReferenceContext(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    );

NTSTATUS
SampDeReferenceContext2(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    );

//
// Context validation services.
//

VOID
SampAddNewValidContextAddress(
    IN PSAMP_OBJECT NewContext
    );


NTSTATUS
SampValidateContextAddress(
    IN PSAMP_OBJECT Context
    );

VOID
SampInvalidateContextAddress(
    IN PSAMP_OBJECT Context
    );

VOID
SampInsertContextList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );

VOID
SampRemoveEntryContextList(
    PLIST_ENTRY Entry
    ); 

VOID
SampInvalidateObjectContexts(
    IN PSAMP_OBJECT ObjectContext,
    IN ULONG Rid
    );

VOID
SampInvalidateContextListKeysByObjectType(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN BOOLEAN  Close
    );


//
// Unicode String related services - These use MIDL_user_allocate and
// MIDL_user_free so that the resultant strings can be given to the
// RPC runtime.
//

NTSTATUS
SampInitUnicodeString(
    OUT PUNICODE_STRING String,
    IN USHORT MaximumLength
    );

NTSTATUS
SampAppendUnicodeString(
    IN OUT PUNICODE_STRING Target,
    IN PUNICODE_STRING StringToAdd
    );

VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    );

VOID
SampFreeOemString(
    IN POEM_STRING String
    );

NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
SampUnicodeToOemString(
    IN POEM_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    );


NTSTATUS
SampRetrieveStringFromRegistry(
    IN HANDLE ParentKey,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Body
    );


NTSTATUS
SampPutStringToRegistry(
    IN BOOLEAN RelativeToDomain,
    IN PUNICODE_STRING SubKeyName,
    IN PUNICODE_STRING Body
    );

NTSTATUS
SampOpenDomainKey(
    IN PSAMP_OBJECT DomainContext,
    IN PRPC_SID DomainId,
    IN BOOLEAN SetTransactionDomain
    );

//
//  user, group and alias Account services
//


NTSTATUS
SampBuildAccountKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN PUNICODE_STRING AccountName
    );

NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    );

NTSTATUS
SampBuildAliasMembersKeyName(
    IN PSID AccountSid,
    OUT PUNICODE_STRING DomainKeyName,
    OUT PUNICODE_STRING AccountKeyName
    );

NTSTATUS
SampValidateNewAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampValidateAccountNameChange(
    IN PSAMP_OBJECT    AccountContext,
    IN PUNICODE_STRING NewAccountName,
    IN PUNICODE_STRING OldAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampIsAccountBuiltIn(
    ULONG Rid
    );



NTSTATUS
SampAdjustAccountCount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    );

NTSTATUS
SampRetrieveAccountCounts(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );

NTSTATUS
SampRetrieveAccountCountsDs(
    IN PSAMP_OBJECT DomainContext,
    IN BOOLEAN  GetApproximateCount, 
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );



NTSTATUS
SampEnumerateAccountNamesCommon(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationHandle,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned
    );


NTSTATUS
SampEnumerateAccountNames(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampLookupAccountRid(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    );

NTSTATUS
SampLookupAccountRidRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    );

NTSTATUS
SampLookupAccountName(
    IN ULONG                DomainIndex,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType
    );

NTSTATUS
SampLookupAccountNameDs(
    IN PSID                 DomainSid,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType,
    OUT PULONG              AccountType
    );

NTSTATUS
SampOpenAccount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AccountId,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *AccountHandle
    );

NTSTATUS
SampCreateAccountContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN AccountExists,
    OUT PSAMP_OBJECT *AccountContext
    );

NTSTATUS
SampCreateAccountContext2(
    IN PSAMP_OBJECT PassedInContext OPTIONAL,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN PULONG UserAccountControl OPTIONAL,
    IN PUNICODE_STRING AccountName OPTIONAL,
    IN ULONG   ClientRevision,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN CreateByPrivilege,
    IN BOOLEAN AccountExists,
    IN BOOLEAN OverrideLocalGroupCheck,
    IN PULONG  GroupType OPTIONAL,
    OUT PSAMP_OBJECT *AccountContext
    );

NTSTATUS
SampCreateAccountSid(
    PSAMP_OBJECT AccountContext,
    PSID *AccountSid
    );

NTSTATUS
SampRetrieveGroupV1Fixed(
    IN PSAMP_OBJECT GroupContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    );

NTSTATUS
SampReplaceGroupV1Fixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    );

NTSTATUS
SampEnforceSameDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG MemberRid
    );

NTSTATUS
SampEnforceCrossDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberSid,
    IN DSNAME * MemberName
    );

NTSTATUS
SampRetrieveUserV1aFixed(
    IN PSAMP_OBJECT UserContext,
    OUT PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    );

NTSTATUS
SampReplaceUserV1aFixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    );

NTSTATUS
SampUpdateAccountDisabledFlag(
    PSAMP_OBJECT Context,
    PULONG  pUserAccountControl
    );

NTSTATUS
SampRetrieveGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN PULONG MemberCount,
    IN PULONG  *Members OPTIONAL
    );

NTSTATUS
SampChangeAccountOperatorAccessToMember(
    IN PRPC_SID MemberSid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    );

NTSTATUS
SampChangeOperatorAccessToUser(
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    );

NTSTATUS
SampChangeOperatorAccessToUser2(
    IN PSAMP_OBJECT                    UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed,
    IN SAMP_MEMBERSHIP_DELTA           AddingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA           AddingToOperator
    );

NTSTATUS
SampQueryInformationUserInternal(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN BOOLEAN  LockHeld,
    IN ULONG    FieldsForUserallInformation,
    IN ULONG    ExtendedFieldsForUserInternal6Information,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    );

NTSTATUS
SampCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *AliasHandle,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *GroupHandle,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampWriteGroupType(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG        GroupType,
    IN BOOLEAN      SkipChecks
    );

NTSTATUS
SampWriteLockoutTime(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed,
    IN LARGE_INTEGER LockoutTime
    );


NTSTATUS
SampDsUpdateLockoutTime(
    IN PSAMP_OBJECT AccountContext
    );

NTSTATUS
SampDsUpdateLockoutTimeEx(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      ReplicateUrgently
    );


NTSTATUS
SampObtainEffectivePasswordPolicy(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN PSAMP_OBJECT AccountContext,
   IN BOOLEAN      WriteLockAcquired
   );

//
// Access validation and auditing related services
//

NTSTATUS
SampValidateDomainControllerCreation(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampValidateObjectAccess(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN ObjectCreation
    );

NTSTATUS
SampValidateObjectAccess2(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE      ClientToken,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN ChangePassword,
    IN BOOLEAN SetPassword
    );

BOOLEAN
SampIsAttributeAccessGranted(
    IN PRTL_BITMAP AccessGranted,
    IN PRTL_BITMAP AccessRequested
    );

VOID
SampSetAttributeAccess(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG SamAttribute,
    IN OUT PRTL_BITMAP AttributeAccessTable
    );

VOID
SampSetAttributeAccessWithWhichFields(
    IN ULONG WhichFields,
    IN OUT PRTL_BITMAP AttributeAccessTable
    );


VOID
SampNt4AccessToWritableAttributes(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ACCESS_MASK DesiredAccess,
    OUT PRTL_BITMAP Attributes
    );

VOID
SampAuditOnClose(
    IN PSAMP_OBJECT Context
    );


NTSTATUS
SampCreateNullToken(
    );

VOID
SampDeleteObjectAuditAlarm(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampAuditAnyEvent(
    IN PSAMP_OBJECT         AccountContext,
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                NewValueInfo      OPTIONAL
    );


VOID
SampAuditDomainChange(
    IN NTSTATUS StatusCode,
    IN PSID DomainSid,
    IN PUNICODE_STRING DomainName,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PSAMP_OBJECT DomainContext
    );


VOID
SampAuditDomainChangeDs(
    IN ULONG DomainContext,
    IN PVOID NewValueInfo
    );   


VOID
SampAuditUserChange(
    IN PSAMP_OBJECT AccountContext,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PUNICODE_STRING AccountName,
    IN PULONG AccountRid,
    IN ULONG PrevAccountControl, 
    IN ULONG AccountControl,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOL Add
    );


VOID
SampAuditUserChangeDs(
    IN ULONG DomainIndex,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountControl,
    IN PULONG Rid,
    IN PPRIVILEGE_SET Privileges,
    IN PVOID NewValueInfo,
    IN BOOL Add
    );
  

VOID
SampAuditGroupChange(
    IN ULONG DomainIndex,
    IN PSAMP_OBJECT GroupContext,
    IN PVOID InformationClass,
    IN BOOL IsAliasInformationClass,
    IN PUNICODE_STRING AccountName,
    IN PULONG  AccountRid, 
    IN ULONG   GroupType,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOL Add
    );


VOID
SampAuditGroupChangeDs(
    IN ULONG DomainIndex,
    IN PUNICODE_STRING AccountName,
    IN PULONG Rid,
    IN ULONG GroupType,
    IN PPRIVILEGE_SET Privileges,
    IN PVOID AttrVals,
    IN BOOL Add
    );


VOID
SampAuditGroupTypeChange(
    PSAMP_OBJECT GroupContext,
    BOOLEAN OldSecurityEnabled,
    BOOLEAN NewSecurityEnabled,
    NT5_GROUP_TYPE OldNT5GroupType,
    NT5_GROUP_TYPE NewNT5GroupType
    );


VOID
SampAuditGroupMemberChange(
    IN PSAMP_OBJECT    GroupContext,
    IN BOOLEAN AddMember,
    IN PWCHAR  MemberStringName,
    IN PULONG  MemberRid  OPTIONAL,
    IN PSID    MemberSid  OPTIONAL
    );

VOID
SampAuditAccountEnableDisableChange(
    PSAMP_OBJECT AccountContext, 
    ULONG NewUserAccountControl, 
    ULONG OldUserAccountControl,
    PUNICODE_STRING AccountName
    );
 

VOID
SampAuditAccountNameChange(
    IN PSAMP_OBJECT     AccountContext,
    IN PUNICODE_STRING  NewAccountName,
    IN PUNICODE_STRING  OldAccountName
    );

VOID
SampAuditUserDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           AccountControl
    );

VOID
SampAuditGroupDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           GroupType
    );

NTSTATUS
SampAuditSidHistory(
    IN PSAMP_OBJECT Context,
    IN DSNAME      *pObject
    );

NTSTATUS
SampAuditUpdateAuditNotificationDs(
    IN SAMP_AUDIT_NOTIFICATION_UPDATE_TYPE Type,
    IN PSID Sid,
    IN PVOID Value
    );

NTSTATUS
SampConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG       ClientRevision,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN InternalCaller
    );

NTSTATUS
SampDsProtectSamObject(
    IN PVOID Parameter                                   
    );


NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    );


//
// Authenticated RPC and SPX support services
//


ULONG
SampSecureRpcInit(
    PVOID Ignored
    );

BOOLEAN
SampStartNonNamedPipeTransports(
    );

NTSTATUS
SampValidateRpcProtSeq(
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );


//
// Directory Service Backup/Restore support
//
ULONG
SampDSBackupRestoreInit(
    PVOID Ignored
    );


//
// Logging support routines
//


//
// This variable controls what is printed to the log.  Changeable 
// via the registry key CCS\Control\Lsa\SamLogLevel
//
extern ULONG SampLogLevel;

//
// Turns on logging for account lockout
//
#define  SAMP_LOG_ACCOUNT_LOCKOUT  0x00000001

NTSTATUS
SampInitLogging(
    VOID
    );

VOID
SampLogLevelChange(
    HANDLE hLsaKey
    );

VOID
SampLogPrint(
    IN ULONG LogLevel,
    IN LPSTR Format,
    ...
    );

#define SAMP_PRINT_LOG(x, _args_)        \
    if (((x) & SampLogLevel) == (x)) {   \
        SampLogPrint _args_ ;            \
    }

//
// Notification package routines.
//

//
// Indicates that the password has been manually expired
//
#define SAMP_PWD_NOTIFY_MANUAL_EXPIRE    0x00000001
//
// Indicates that the account has been unlocked
//
#define SAMP_PWD_NOTIFY_UNLOCKED         0x00000002
//
// Indicates that the user's password has been set or changedsd
//
#define SAMP_PWD_NOTIFY_PWD_CHANGE       0x00000004
//
// Indicats the account is a machine account
//
#define SAMP_PWD_NOTIFY_MACHINE_ACCOUNT  0x00000008

NTSTATUS
SampPasswordChangeNotify(
    IN ULONG        Flags,
    PUNICODE_STRING UserName,
    ULONG           RelativeId,
    PUNICODE_STRING NewPassword,
    IN BOOLEAN      Loopback
    );

NTSTATUS
SampPasswordChangeFilter(
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    );

NTSTATUS
SampLoadNotificationPackages(
    );

NTSTATUS
SampDeltaChangeNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

NTSTATUS
SampStoreUserPasswords(
    IN PSAMP_OBJECT Context,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN NtPasswordPresent,
    IN BOOLEAN CheckPasswordRestrictions,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType,
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo OPTIONAL,
    IN OUT PUNICODE_STRING ClearPassword OPTIONAL,
    IN PULONG ChangedUserAccountControl OPTIONAL,
    OUT PUNICODE_STRING  PasswordToNotify OPTIONAL,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    );

NTSTATUS
SampDsSetPasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING NewClearPassword
    );

NTSTATUS
SampDsChangePasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING OldClearPassword,
    IN PUNICODE_STRING NewClearPassword
    );





//
// Security Descriptor production services
//


NTSTATUS
SampInitializeDomainDescriptors(
    ULONG Index
    );

NTSTATUS
SampGetNewAccountSecurity(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampGetNewAccountSecurityNt4(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN ULONG DomainIndex,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
SampGetDomainObjectSDFromDsName(
    IN DSNAME   *DomainObjectDsName,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );


NTSTATUS
SampModifyAccountSecurity(
    IN PSAMP_OBJECT     Context,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN PSECURITY_DESCRIPTOR OldDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampBuildSamProtection(
    IN PSID WorldSid,
    IN PSID AdminsAliasSid,
    IN ULONG AceCount,
    IN PSID AceSid[],
    IN ACCESS_MASK AceMask[],
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PULONG DescriptorLength,
    OUT PSECURITY_DESCRIPTOR *Descriptor,
    OUT PULONG *RidToReplace OPTIONAL
    );


NTSTATUS
SampValidatePassedSD(
    IN ULONG                          Length,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    );

//
// Group related services
//

NTSTATUS
SampChangeGroupAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampChangeAliasAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampChangeUserAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    IN ULONG UserAccountControl,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampReplaceUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    );

NTSTATUS
SampComputePasswordExpired(
    IN BOOLEAN PasswordExpired,
    OUT PLARGE_INTEGER PasswordLastSet
    );

NTSTATUS
SampSetUserAccountControl(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed,
    IN BOOLEAN      ChangePrimaryGroupId,
    OUT BOOLEAN     *AccountUnlocked,
    OUT BOOLEAN     *AccountGettingMorphed,
    OUT BOOLEAN     *KeepOldPrimaryGroupMembership
    );

NTSTATUS
SampAssignPrimaryGroup(
    IN PSAMP_OBJECT Context,
    IN ULONG GroupRid
    );

NTSTATUS
SampAddUserToGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    );

NTSTATUS
SampRemoveUserFromGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    );

NTSTATUS
SampValidateDSName(
    IN PSAMP_OBJECT AccountContext,
    IN DSNAME * DSName,
    OUT PSID    * Sid,
    OUT DSNAME  **ImprovedDSName
    );

NTSTATUS
SampDsCheckSidType(
    IN  PSID    Sid,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cEnterpriseSids,
    IN  PSID    *rgEnterpriseSids,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    );

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   );

NTSTATUS
SampDsCreateForeignSecurityPrincipal(
    IN PSID pSid,
    IN DSNAME * DomainObjectName,
    OUT DSNAME ** ppDsName
    );

NTSTATUS
SampCheckGroupTypeBits(
    IN ULONG DomainIndex,
    IN ULONG GroupType
    );

ULONG
SampGetAccountTypeFromGroupType(
    IN ULONG GroupType
    );

NTSTATUS
SampMaintainPrimaryGroupIdChange(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        NewPrimaryGroupId,
    IN ULONG        OldPrimaryGroupId,
    IN BOOLEAN      KeepOldPrimaryGroupMembership
    );

//
// Alias related services
//

NTSTATUS
SampAlBuildAliasInformation(
    );

NTSTATUS
SampAlDelayedBuildAliasInformation(
    IN PVOID Parameter
    );

NTSTATUS
SampAlInvalidateAliasInformation(
    IN ULONG DomainIndex
    );

NTSTATUS
SampAlQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );

NTSTATUS
SampAlQueryMembersOfAlias(
    IN SAMPR_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlAddMembersToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlRemoveMembersFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlLookupMembersInAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG AliasRid,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PULONG MembershipCount
    );

NTSTATUS
SampAlDeleteAlias(
    IN SAMPR_HANDLE *AliasHandle
    );

NTSTATUS
SampAlRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    );

NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    IN PULONG MemberCount,
    IN PSID **Members OPTIONAL
    );


NTSTATUS
SampRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN PDSNAME AccountNameInDs OPTIONAL,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    );

NTSTATUS
SampAlSlowQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    IN DSNAME ** DsNameArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );

NTSTATUS
SampRetrieveAliasMembership(
    IN PSID Account,
    IN DSNAME * AccountDn OPTIONAL,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    );

NTSTATUS
SampInitAliasNameCache(
    VOID
    );


//
// User related services
//


NTSTATUS
SampGetPrivateUserData(
    PSAMP_OBJECT UserContext,
    OUT PULONG DataLength,
    OUT PVOID *Data
    );

NTSTATUS
SampSetPrivateUserData(
    PSAMP_OBJECT UserContext,
    IN ULONG DataLength,
    IN PVOID Data
    );
NTSTATUS
SampRetrieveUserGroupAttribute(
    IN ULONG UserRid,
    IN ULONG GroupRid,
    OUT PULONG Attribute
    );

NTSTATUS
SampAddGroupToUserMembership(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive,
    OUT PBOOLEAN PrimaryGroup
    );

NTSTATUS
SampSetGroupAttributesOfUser(
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid
    );

NTSTATUS
SampRemoveMembershipUser(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive
    );

BOOLEAN
SampStillInLockoutObservationWindow(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    );

NTSTATUS
SampDsRemoveDuplicateRids(
    IN DSNAME * DomainObject,
    IN ULONG ObjectRid
    );

NTSTATUS
SampCreateDefaultUPN(
    IN PUNICODE_STRING AccountName,
    IN ULONG           DomainIndex,
    OUT PUNICODE_STRING UPN
    );

//
// Cached display information services
//

NTSTATUS
SampInitializeDisplayInformation (
    ULONG DomainIndex
    );

NTSTATUS
SampMarkDisplayInformationInvalid (
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampUpdateDisplayInformation (
    PSAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo OPTIONAL,
    PSAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo OPTIONAL,
    SAMP_OBJECT_TYPE            ObjectType
    );


//
// Miscellaneous services
//

BOOLEAN
SampValidateComputerName(
    IN  PWSTR Name,
    IN  ULONG Length
    );

LARGE_INTEGER
SampAddDeltaTime(
    IN LARGE_INTEGER Time,
    IN LARGE_INTEGER DeltaTime
    );

NTSTATUS
SampCreateFullSid(
    PSID    DomainSid,
    ULONG   Rid,
    PSID    *AccountSid
    );

NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    OUT PSID *DomainSid,
    OUT ULONG *Rid
    );

BOOLEAN SampIsWellKnownSid(
    IN PSID Sid
    );

BOOLEAN SampIsSameDomain(
    IN PSID AccountSid,
    IN PSID DomainSid
    );

VOID
SampNotifyNetlogonOfDelta(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    );

NTSTATUS
SampGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
SampSetAccountDomainPolicy(
    IN PUNICODE_STRING AccountDomainName,
    IN PSID            AccountDomainSid
    );

//
// The Operation GUID used to indicate the default objects and memberships
// for win2k to ws03 upgrade are complete
//
#define SAMP_WIN2K_TO_WS03_UPGRADE L"6E157EDF-4E72-4052-A82A-EC3F91021A22"

NTSTATUS
SampMarkChangeApplied(
    IN LPWSTR OperationalGuid
    );

NTSTATUS
SampUpgradeSamDatabase(
    ULONG Revision
    );

NTSTATUS
SampCheckDomainUpdates(
    PVOID pv
    );

NTSTATUS
SampAbortSingleLoopbackTask(
    IN OUT PVOID  *VoidNotifyItem
    );

NTSTATUS
SampProcessSingleLoopbackTask(
    IN PVOID  *VoidNotifyItem
    );

VOID
SampAddLoopbackTaskForBadPasswordCount(
    IN PUNICODE_STRING AccountName
    );

NTSTATUS
SampAddLoopbackTaskDeleteTableElement(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );
                                                    
NTSTATUS
SampAddLoopbackTaskForAuditing(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                AlteredState      OPTIONAL
    );

NTSTATUS
SampOpenUserInServer(
    PUNICODE_STRING UserName,
    BOOLEAN Unicode,
    IN BOOLEAN TrustedClient,
    SAMPR_HANDLE * UserHandle
    );

BOOLEAN
SampIncrementBadPasswordCount(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN PUNICODE_STRING  MachineName OPTIONAL
    );

NTSTATUS
SampConvertUiListToApiList(
    IN  PUNICODE_STRING UiList OPTIONAL,
    OUT PUNICODE_STRING ApiList,
    IN BOOLEAN BlankIsDelimiter
    );

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    );

NTSTATUS
SampFillGuidAndSid(
    IN OUT DSNAME *DSName
    );


//
// found in dsupgrad.lib
//

NTSTATUS
SampRegistryToDsUpgrade (
    WCHAR* wcszRegPath
    );

NTSTATUS
SampValidateDomainCache(
    VOID
    );

NTSTATUS
SampDsResolveSids(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );

NTSTATUS
SampDsLookupObjectByAlternateId(
    IN PDSNAME DomainRoot,
    IN ULONG AttributeId,
    IN PUNICODE_STRING AlternateId,
    OUT PDSNAME *Object
    );

BOOLEAN
SampIsSetupInProgress(
    OUT BOOLEAN *Upgrade OPTIONAL
    );

ULONG
SampDefaultPrimaryGroup(
    PSAMP_OBJECT    UserContext,
    ULONG           AccountType
    );

NTSTATUS
SampGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    );


//
// Role change support services
//
BOOL
SampIsRebootAfterPromotion(
    OUT PULONG PromoteData
    );

NTSTATUS
SampPerformPromotePhase2(
     IN ULONG PromoteData
     );

NTSTATUS
SampGetAdminPasswordFromRegistry(
    OUT USER_INTERNAL1_INFORMATION *InternalInfo1 OPTIONAL
    );

BOOLEAN
SampUsingDsData();


//
// Latency Counter support
//

typedef struct _SAMP_LATENCY
{
    CRITICAL_SECTION Lock;

    // array of last cLatencies latencies
    ULONG  *Latencies;
    // number of elements in Latencies
    ULONG  cLatencies;
    // current tail of circular array in Latencies
    ULONG  iLatencies;
    // the current sum of all elements in Latencies
    ULONG  Sum;
    // the perf counter (in DSSTAT space)
    ULONG  PerfCounterId;

} SAMP_LATENCY, *PSAMP_LATENCY;


NTSTATUS
SampInitLatencyCounter (
    PSAMP_LATENCY Info,
    ULONG         Id,
    ULONG         SlotCount
    );


VOID
SampUpdateLatencyCounter(
    PSAMP_LATENCY Info,
    ULONG         New
    );

//
// Old RPC stub routine definitions used in SamIFree()
//

void _fgs__RPC_UNICODE_STRING (RPC_UNICODE_STRING  * _source);
void _fgs__SAMPR_RID_ENUMERATION (SAMPR_RID_ENUMERATION  * _source);
void _fgs__SAMPR_ENUMERATION_BUFFER (SAMPR_ENUMERATION_BUFFER  * _source);
void _fgs__SAMPR_SR_SECURITY_DESCRIPTOR (SAMPR_SR_SECURITY_DESCRIPTOR  * _source);
void _fgs__SAMPR_GET_GROUPS_BUFFER (SAMPR_GET_GROUPS_BUFFER  * _source);
void _fgs__SAMPR_GET_MEMBERS_BUFFER (SAMPR_GET_MEMBERS_BUFFER  * _source);
void _fgs__SAMPR_LOGON_HOURS (SAMPR_LOGON_HOURS  * _source);
void _fgs__SAMPR_ULONG_ARRAY (SAMPR_ULONG_ARRAY  * _source);
void _fgs__SAMPR_SID_INFORMATION (SAMPR_SID_INFORMATION  * _source);
void _fgs__SAMPR_PSID_ARRAY (SAMPR_PSID_ARRAY  * _source);
void _fgs__SAMPR_RETURNED_USTRING_ARRAY (SAMPR_RETURNED_USTRING_ARRAY  * _source);
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION (SAMPR_DOMAIN_GENERAL_INFORMATION  * _source);
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 (SAMPR_DOMAIN_GENERAL_INFORMATION2  * _source);
void _fgs__SAMPR_DOMAIN_OEM_INFORMATION (SAMPR_DOMAIN_OEM_INFORMATION  * _source);
void _fgs__SAMPR_DOMAIN_NAME_INFORMATION (SAMPR_DOMAIN_NAME_INFORMATION  * _source);
void _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION (SAMPR_DOMAIN_REPLICATION_INFORMATION  * _source);
void _fgu__SAMPR_DOMAIN_INFO_BUFFER (SAMPR_DOMAIN_INFO_BUFFER  * _source, DOMAIN_INFORMATION_CLASS _branch);
void _fgu__SAMPR_GROUP_INFO_BUFFER (SAMPR_GROUP_INFO_BUFFER  * _source, GROUP_INFORMATION_CLASS _branch);
void _fgu__SAMPR_ALIAS_INFO_BUFFER (SAMPR_ALIAS_INFO_BUFFER  * _source, ALIAS_INFORMATION_CLASS _branch);
void _fgu__SAMPR_USER_INFO_BUFFER (SAMPR_USER_INFO_BUFFER  * _source, USER_INFORMATION_CLASS _branch);
void _fgu__SAMPR_DISPLAY_INFO_BUFFER (SAMPR_DISPLAY_INFO_BUFFER  * _source, DOMAIN_DISPLAY_INFORMATION _branch);



//
// SAM object attribute manipulation services
//



VOID
SampInitObjectInfoAttributes();

NTSTATUS
SampStoreObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    );

NTSTATUS
SampDeleteAttributeKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    );

NTSTATUS
SamIGetFixedAttributes(                 // Export used in samwrite.c
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    );

NTSTATUS
SampSetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN PVOID FixedData
    );

NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    );

NTSTATUS
SampSetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PUNICODE_STRING Attribute
    );

NTSTATUS
SampGetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *Sid
    );

NTSTATUS
SampSetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute
    );

NTSTATUS
SampGetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG Revision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
SampSetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSECURITY_DESCRIPTOR Attribute,
    IN ULONG Length
    );

NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampSetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PULONG Attribute,
    IN ULONG UsedCount,
    IN ULONG LengthCount
    );

NTSTATUS
SampGetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLARGE_INTEGER *LargeIntArray,
    OUT PULONG Count
    );

NTSTATUS
SampSetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLARGE_INTEGER Attribute,
    IN ULONG Count
    );

NTSTATUS
SampGetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *SidArray,
    OUT PULONG Length,
    OUT PULONG Count
    );

NTSTATUS
SampSetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute,
    IN ULONG Length,
    IN ULONG Count
    );

NTSTATUS
SampGetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLOGON_HOURS LogonHours
    );

NTSTATUS
SampSetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    );

VOID
SampFreeAttributeBuffer(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampRtlConvertUlongToUnicodeString(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN ULONG DigitCount,
    IN BOOLEAN AllocateDestinationString,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
SampRtlWellKnownPrivilegeCheck(
    BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    );

NTSTATUS
SampImpersonateClient(
    OUT BOOLEAN *fImpersonatingAnonymous 
    );

VOID
SampRevertToSelf(
    IN  BOOLEAN fImpersonatingAnonymous 
    );


//
// Routines to support Extended Sid's
//
VOID
SampInitEmulationSettings(
    IN HKEY LsaKey 
    );

BOOLEAN
SampIsExtendedSidModeEmulated(
    IN ULONG *Mode
    );

// BOOLEAN
//  SampIsContextFromExtendedSidDomain(
//    SAMP_OBJECT Context
//    );
#define SampIsContextFromExtendedSidDomain(x) \
      SampDefinedDomains[(x)->DomainIndex].IsExtendedSidDomain



//
// Encryption and Decryption services
//

USHORT
SampGetEncryptionKeyType();

NTSTATUS
SampDecryptSecretData(
    OUT PUNICODE_STRING ClearData,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING EncryptedData,
    IN ULONG Rid
    );

NTSTATUS
SampEncryptSecretData(
    OUT PUNICODE_STRING EncryptedData,
    IN USHORT KeyId,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING ClearData,
    IN ULONG Rid
    );

NTSTATUS
SampInitializeSessionKey(
    VOID
    );

VOID
SampCheckNullSessionAccess(
    IN HKEY LsaKey 
    );

VOID
SampInitOwfPasswordChangeRestriction(
    IN HKEY LsaKey 
    );

NTSTATUS
SampExtendedEnumerationAccessCheck(
    IN BOOLEAN TrustedClient,
    IN OUT BOOLEAN * pCanEnumEntireDomain 
    );


//
//  Data to support replication of single objects
//
extern CRITICAL_SECTION SampReplicateQueueLock;


//
// The Following 2 functions convert between account Control and Flags
//

NTSTATUS
SampFlagsToAccountControl(
    IN ULONG Flags,
    OUT PULONG UserAccountControl
    );



ULONG
SampAccountControlToFlags(
    IN ULONG Flags
    );


//
// The following function calculates LM and NT OWF Passwords
//

NTSTATUS
SampCalculateLmAndNtOwfPasswords(
    IN PUNICODE_STRING ClearNtPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

//
// Initialize Sam Global well known Sids
//

NTSTATUS
SampInitializeWellKnownSids( VOID );


//
// SampDsGetPrimaryDomainStart is used to correctly set the starting index in the
// SampDefinedDomains array whenever it is accessed in the SAM code. In the
// case of an NT workstation or member server, the first two entries of the
// array correspond to registry data, hence the index is started at zero. In
// the case of a domain controller, the DS-based data is not stored in the
// first two elements (those may be used for crash-recovery data, still ob-
// tained from the registry), but rather in subsequent array elements, hence
// is start at index DOMAIN_START_DS.
//

ULONG
SampDsGetPrimaryDomainStart(VOID);


//
// SampIsMixedDomain returns wether the domain has downlevel domain controllers
// present. SampIsMixedDomain checks the value of an attribute on the domain
// object
//

NTSTATUS
SampGetDsDomainSettings(
    BOOLEAN *MixedDomain, 
    ULONG * BehaviorVersion, 
    ULONG * LastLogonTimeStampSyncInterval
    );


//
// This routine determines if Sid is either the builtin domain, or a
// member of the builtin domain
//
BOOLEAN
SampIsMemberOfBuiltinDomain(
    IN PSID Sid
    );

//
// This routine performs a special security check before group membership changes
// for "sensitive" groups
//

NTSTATUS
SampCheckForSensitiveGroups(SAMPR_HANDLE AccountHandle);

//
// The Following Functions Ensure that all threads not executing with the
// SAM lock held are finished with their current activity before the
// DS shutdown sequence is initiated.
//

NTSTATUS
SampInitializeShutdownEvent();

NTSTATUS
SampIncrementActiveThreads(VOID);

VOID
SampDecrementActiveThreads(VOID);

VOID
SampWaitForAllActiveThreads(
    IN PSAMP_SERVICE_STATE PreviousServiceState OPTIONAL
    );

//
// Functions to upgrade the SAM database and fix SAM bugs
//

NTSTATUS
SampUpgradeSamDatabase(
    ULONG Revision
    );

BOOLEAN
SampGetBootOptions(
    VOID
    );


BOOLEAN
SampIsDownlevelDcUpgrade(
    VOID
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 2-3 tree generic table routines                                     //
// These should be moved to RTL directory if a general need arises.    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


VOID
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    );

PVOID
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    );

BOOLEAN
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );

PVOID
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );

PVOID
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    );

PVOID
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    );

PVOID
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    );

ULONG
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    );

BOOLEAN
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    );

//////////////////////////////////////////////////
NTSTATUS
SampCheckAccountNameTable(
    IN PSAMP_OBJECT    Context,
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampDeleteElementFromAccountNameTable(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );


NTSTATUS
SampInitializeAccountNameTable(
    );

PVOID
SampAccountNameTableAllocate(
    ULONG   BufferSize
    );

VOID
SampAccountNameTableFree(
    PVOID   Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampAccountNameTableCompare(
    PVOID   Node1,
    PVOID   Node2
    );

LONG
SampCompareDisplayStrings(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN IgnoreCase
    );


/////////////////////////////////////////////////////////

NTSTATUS
SampGetCurrentOwnerAndPrimaryGroup(
    OUT PTOKEN_OWNER * Owner,
    OUT PTOKEN_PRIMARY_GROUP * PrimaryGroup
    );

NTSTATUS
SampGetCurrentUser(
    IN HANDLE ClientToken OPTIONAL,
    OUT PTOKEN_USER * User,
    OUT BOOL        * Administrator
    );

NTSTATUS
SampGetCurrentClientSid(
    IN  HANDLE   ClientToken OPTIONAL,
    OUT PSID    *ppSid,
    OUT BOOL    *Administrator
    );


NTSTATUS
SampInitializeActiveContextTable(
    );

PVOID
SampActiveContextTableAllocate(
    ULONG   BufferSize
    );

VOID
SampActiveContextTableFree(
    PVOID   Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampActiveContextTableCompare(
    PVOID   Node1,
    PVOID   Node2
    );

NTSTATUS
SampIncrementActiveContextCount(
    PSAMP_OBJECT    Context
    );

VOID
SampDecrementActiveContextCount(
    PVOID   ElementInActiveContextTable
    );



/////////////////////////////////////////////////////////


VOID
SampMapNtStatusToClientRevision(
   IN ULONG ClientRevision,
   IN OUT NTSTATUS *pNtStatus
   );

ULONG
SampClientRevisionFromHandle(
   PVOID handle
   );

//
// Performance counter functions
//

VOID
SampUpdatePerformanceCounters(
    DWORD               dwStat,
    DWORD               dwOperation,
    DWORD               dwChange
    );


//
// Functions for manipulating supplemental credentials
//
VOID
SampFreeSupplementalCredentialList(
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialList
    );

NTSTATUS
SampAddSupplementalCredentialsToList(
    IN OUT PSAMP_SUPPLEMENTAL_CRED *SupplementalCredentialList,
    IN PUNICODE_STRING PackageName,
    IN PVOID           CredentialData,
    IN ULONG           CredentialLength,
    IN BOOLEAN         ScanForConflict,
    IN BOOLEAN         Remove
    );

NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr
    );

NTSTATUS
SampConvertCredentialsFromListToAttr(
    IN OUT PUNICODE_STRING OldUserParameters,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    );

NTSTATUS
SampRetrieveCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SampRetrieveCredentialsFromList(
    IN OUT PUNICODE_STRING OldUserParameters,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SampCreateSupplementalCredentials(
    IN PVOID            UpdateInfo,        
    IN ATTRBLOCK        *AttrBlockIn,
    OUT ATTRBLOCK       *AttrBlockOut
    );

NTSTATUS
SampDecryptSupplementalCredentials(
    IN PUNICODE_STRING  EncryptedSuppCredentials,
    IN ULONG            Rid,
    OUT PUNICODE_STRING SupplementalCredentials
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shared global variables                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


extern NT_PRODUCT_TYPE SampProductType;
extern BOOLEAN SampUseDsData;

extern BOOLEAN SampRidManagerInitialized;

extern RTL_RESOURCE SampLock;
extern BOOLEAN SampTransactionWithinDomainGlobal;
extern ULONG SampTransactionDomainIndexGlobal;

extern RTL_CRITICAL_SECTION SampContextListCritSect; 

extern RTL_GENERIC_TABLE2   SampAccountNameTable;
extern RTL_CRITICAL_SECTION SampAccountNameTableCriticalSection; 
extern PRTL_CRITICAL_SECTION SampAccountNameTableCritSect; 


extern RTL_GENERIC_TABLE2   SampActiveContextTable;
extern RTL_CRITICAL_SECTION SampActiveContextTableLock;


extern SAMP_SERVICE_STATE SampServiceState;

extern BOOLEAN SampSuccessAccountAuditingEnabled;
extern BOOLEAN SampFailureAccountAuditingEnabled;


extern HANDLE SampKey;
extern PRTL_RXACT_CONTEXT SampRXactContext;

extern SAMP_OBJECT_INFORMATION SampObjectInformation[ SampUnknownObjectType ];

extern LIST_ENTRY SampContextListHead;

extern ULONG SampDefinedDomainsCount;
extern PSAMP_DEFINED_DOMAINS SampDefinedDomains;
extern UNICODE_STRING SampFixedAttributeName;
extern UNICODE_STRING SampVariableAttributeName;
extern UNICODE_STRING SampCombinedAttributeName;

extern UNICODE_STRING SampNameDomains;
extern UNICODE_STRING SampNameDomainGroups;
extern UNICODE_STRING SampNameDomainAliases;
extern UNICODE_STRING SampNameDomainAliasesMembers;
extern UNICODE_STRING SampNameDomainUsers;
extern UNICODE_STRING SampNameDomainAliasesNames;
extern UNICODE_STRING SampNameDomainGroupsNames;
extern UNICODE_STRING SampNameDomainUsersNames;

extern UNICODE_STRING SampBackSlash;
extern UNICODE_STRING SampNullString;
extern UNICODE_STRING SampSamSubsystem;
extern UNICODE_STRING SampServerObjectName;


extern LARGE_INTEGER SampImmediatelyDeltaTime;
extern LARGE_INTEGER SampNeverDeltaTime;
extern LARGE_INTEGER SampHasNeverTime;
extern LARGE_INTEGER SampWillNeverTime;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
// 

#if DBG
extern BOOLEAN SampLastLogonTimeStampSyncByMinute;
#endif 


extern LM_OWF_PASSWORD SampNullLmOwfPassword;
extern NT_OWF_PASSWORD SampNullNtOwfPassword;

extern TIME LastUnflushedChange;
extern BOOLEAN FlushThreadCreated;
extern BOOLEAN FlushImmediately;

extern LONG SampFlushThreadMinWaitSeconds;
extern LONG SampFlushThreadMaxWaitSeconds;
extern LONG SampFlushThreadExitDelaySeconds;

//
// Warning: these SIDs are only defined during the first boot of setup,
// when the code in bldsam3.c for building the SAM database, has been
// run. On a normal build they are both NULL.
//

extern PSID SampBuiltinDomainSid;
extern PSID SampAccountDomainSid;

extern PSID SampWorldSid;
extern PSID SampAnonymousSid;
extern PSID SampLocalSystemSid;
extern PSID SampAdministratorUserSid;
extern PSID SampAdministratorsAliasSid;
extern PSID SampAccountOperatorsAliasSid;
extern PSID SampAuthenticatedUsersSid;
extern PSID SampPrincipalSelfSid;
extern PSID SampBuiltinDomainSid;
extern PSID SampNetworkSid;
extern PSID SampDomainAdminsGroupSid;
extern PSID SampEnterpriseDomainControllersSid;
extern PSID SampNetworkServiceSid;



extern HANDLE  SampNullSessionToken;
extern BOOLEAN SampNetwareServerInstalled;
extern BOOLEAN SampIpServerInstalled;
extern BOOLEAN SampAppletalkServerInstalled;
extern BOOLEAN SampVinesServerInstalled;

extern UCHAR SampSecretSessionKey[SAMP_SESSION_KEY_LENGTH];
extern UCHAR SampSecretSessionKeyPrevious[SAMP_SESSION_KEY_LENGTH];
extern BOOLEAN SampSecretEncryptionEnabled;
extern ULONG   SampCurrentKeyId;
extern ULONG   SampPreviousKeyId;
extern BOOLEAN SampUpgradeInProcess;

extern SAMP_DS_TRANSACTION_CONTROL SampDsTransactionType;
extern DSNAME* RootObjectName;
extern BOOLEAN SampLockHeld;

//
// This Flag is TRUE when DS failed to start.
//
extern BOOLEAN SampDsInitializationFailed;
//
// This flag is TRUE when the DS has been successfully initialized
//
extern BOOLEAN SampDsInitialized;

//
// For Tagged tracing support
//

extern ULONG SampTraceTag;
extern ULONG SampTraceFileTag;

//
// SAM server object name holder
//
extern DSNAME * SampServerObjectDsName;




//
// Event to tell waiting threads that the
// system is about to shut down
//

extern HANDLE SampAboutToShutdownEventHandle;

//
// Flags to determine if certain containers exist; these flags are valid
// after SampInitialize returns
//
extern BOOLEAN SampDomainControllersOUExists;
extern BOOLEAN SampUsersContainerExists;
extern BOOLEAN SampComputersContainerExists;

//
//
// Global pointer (to heap memory) to store well known container's
// distinguished name
//
extern DSNAME * SampDomainControllersOUDsName;
extern DSNAME * SampUsersContainerDsName;
extern DSNAME * SampComputersContainerDsName;
extern DSNAME * SampComputerObjectDsName;




//
// Global tests the value of a key in the registry for a hard/soft logon
// policy in the event of GC failures.
//
extern BOOLEAN SampIgnoreGCFailures;

//
// Flag to indicate whether the Promote is coming from NT4 PDC or a
// stand along Windows 2000 Server
//
extern BOOLEAN SampNT4UpgradeInProgress;

//
// This flag indicates whether null sessions (world) should be allowed to
// list users in the domain and members of groups.
//
extern BOOLEAN SampRestrictNullSessions;

//
// This flag indicates that we do not store the LM hash. This can be
// enabled by setting a Registry Key
//

extern BOOLEAN SampNoLmHash;

//
// This flag when set disables netlogon notifications in the upgrade path
//

extern BOOLEAN SampDisableNetlogonNotification;


//
// This flag indicates whether or not to enforce giving site affinity to
// clients outside our site by looking at the client's IP address.
//
extern BOOLEAN SampNoGcLogonEnforceKerberosIpCheck;

//
// This flag indicates whether or not to enforce that only interactive
// logons via NTLM are to be given site affinity
//
extern BOOLEAN SampNoGcLogonEnforceNTLMCheck;

//
// This flags indicates whether or not to replicate password set/change
// operations urgently.
//
extern BOOLEAN SampReplicatePasswordsUrgently;

//
// This flag is enabled on personal and professional to force guest 
// access for all network operations
//
extern BOOLEAN SampForceGuest;

//
// This flag indicates whether or not the local machine is joined to a domain
// 
extern BOOLEAN SampIsMachineJoinedToDomain;

//
// This flag tells if we are running Personal SKU
// 
extern BOOLEAN SampPersonalSKU;


//
// This flag is typically enabled on personal machines to limit security
// concerns when using blank passwords
//
extern BOOLEAN SampLimitBlankPasswordUse;


//
// This flag controls SAM's behavior with respect to Account Lockout.
// When on, the act of an account being locked out will be audited but the 
// account won't actually be locked out.
//
extern BOOLEAN SampAccountLockoutTestMode;


//
// This flag is set to TRUE when the appropriate Domain Operation GUID
// is created in the DomainUpdates container in the DS.  The operation
// indicates that all computer objects are correctly ACL'ed for netjoin
// to work, thus SAM no longer needs to grant extra access on computer
// objects for thier effective owner.
//
extern BOOLEAN SampComputerObjectACLApplied;


//
// This flag controls the single object replication that can occur when 
// an authentication fails locally, but succeeds at the PDC
//
extern BOOLEAN          SampDisableSingleObjectRepl;


//
// This global variable controls how SAM restricts OWF password change API.
// 
// 0 - old behavior, client can change password through OWF password change API,
//     and the new password remains unexpired.
// 
// 1 - .NET Server default behavior, client can change password through 
//     OWF password change API (SamrChangePasswordUser), but the password
//     expires immediately.
// 
// 2 - more secure behavior, client cann't use OWF password change API.
//     this API (SamrChangePasswordUser) will be totally shutted down.
//
// Default value for .NET server is 1. 
// 
// The value of this global variable will be based on REGISTRY KEY setting
// System\\CurrentControlSet\\Control\\Lsa\\SamRestrictOwfPasswordChange 
// 
// NOTE: All restrictions are NOT applied to SYSTEM or members of Builtin 
//       Administrators Alias Group.
//
extern ULONG    SampRestrictOwfPasswordChange;

//
// This flag indicates whether the default objects and memberships needed 
// WS03 exist.  Note, future releases can benefit by making this a revision
// instead of a flag.
//
extern BOOLEAN SampWS03DefaultsApplied;


//
// Latency Information
//
extern SAMP_LATENCY SampResourceGroupsLatencyInfo;
extern SAMP_LATENCY SampAccountGroupsLatencyInfo;

//
//  Handy macro for LockoutTime
//
// BOOLEAN
// SAMP_LOCKOUT_SET(
//     IN PSAMP_OBJECT x
//    );
//
#define SAMP_LOCKOUT_TIME_SET(x) \
     (BOOLEAN)( ((x)->TypeBody.User.LockoutTime.QuadPart)!=0)


ULONG
SampPositionOfHighestBit(
    ULONG Flag
    );

NTSTATUS
SampSetupDsObjectNotifications(
    VOID
);

NTSTATUS
SampInitWellKnownSDTable(
    VOID
);


NTSTATUS
SampGetCachedObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );


NTSTATUS
SampDoAccountsUpgradeDuringPDCTransfer(
    IN PVOID Parameter
    );


NTSTATUS
SampGenerateRandomPassword(
    IN LPWSTR Password,
    IN ULONG  Length
    );


NTSTATUS
SampDsProtectFPOContainer(
    PVOID p
    );

NTSTATUS
SampMakeNullTerminateString(
    IN  PUNICODE_STRING UnicodeString,
    OUT LPWSTR *ppStringWithNullTerminator
    );

NTSTATUS
SampDsControlAccessRightCheck(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN GUID *ControlAccessRightToCheck
    );

NTSTATUS
SampValidatePwdSettingAttempt(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN ULONG UserAccountControl,
    IN GUID *ControlAccessRightToCheck
    );

NTSTATUS
SampIsPwdSettingAttemptGranted(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN ULONG UserAccountControl,
    IN GUID *ControlAccessRightToCheck,
    OUT BOOLEAN *fGranted
    );

//
// General helper functions from utility.c
//
LPSTR
SampGetPDCString(
    VOID
    );

LPSTR
SampGetUserString(
    IN DSNAME *User                    
    );

BOOL
SampAvoidPdcOnWan(
    VOID
    );

#endif // _NTSAMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\sdcache.c ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation

Module Name:

    sdcache.c

Abstract:

    This file contains routines to implement cached Server Object / Domain Object 
    Security Descriptor

Author:

    Shaohua Yin ( SHAOYIN ) Oct. 10, 2000

Environment:

    User Mode - Win32

Revision History:



--*/



#include <samsrvp.h>
#include <seopaque.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>
#include <ntdsguid.h>
#include <mappings.h>
#include <dsevent.h>
#include <permit.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <dbgutilp.h>
#include <dsmember.h>
#include <malloc.h>
#include <attids.h>
#include <filtypes.h>





#define SampServerClientHandle              0
#define SampAccountDomainClientHandle       1
#define SampBuiltinDomainClientHandle       2

#define SampServerObjectSDIndex     0
#define SampAccountDomainSDIndex    1
#define SampBuiltinDomainSDIndex    2


//
// declare private routines
//

BOOL
SampNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    );

VOID
SampNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    );

VOID
SampProcessWellKnownSDChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    );

VOID
SampProcessAccountDomainChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    );

VOID
SampProcessDefaultObjectChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    );

NTSTATUS
SampUpdateWellKnownSD(
    PVOID pv
    );

NTSTATUS
SampDelayedFreeSD(
    PVOID pv
    );


//
// Variables to point to the cached well known object Security Descriptor
// 

PSECURITY_DESCRIPTOR SampServerObjectSD = NULL;  
PSECURITY_DESCRIPTOR SampAccountDomainObjectSD = NULL;  
PSECURITY_DESCRIPTOR SampBuiltinDomainObjectSD = NULL;  

//
// Variables to point Domain Object DS Name, note: they are not hold the domain dsname, 
// but just a pointer to SampDefinedDomains[i].Context->ObjectNameInDs
// 

DSNAME * SampAccountDomainDsName = NULL;
DSNAME * SampBuiltinDomainDsName = NULL;


//
// Each element in this table is an object in the DS that SAM needs to be
// notified of when a change occurs.
//
typedef struct _DIR_NOTIFY_TABLE_ENTRY    {
    PDSNAME *ppObjectDsName;
    PF_PFI pfPrepareForImpersonate;
    PF_TD  pfTransmitData;             
    PF_SI  pfStopImpersonating;
    DWORD  hClient;
} DIR_NOTIFY_TABLE_ENTRY; 


DIR_NOTIFY_TABLE_ENTRY  SampDirNotifyTable[] =
{
    {
        &SampServerObjectDsName, 
        SampNotifyPrepareToImpersonate, 
        SampProcessDefaultObjectChange,
        SampNotifyStopImpersonation,
        SampServerClientHandle
    },

    {
        &SampAccountDomainDsName, 
        SampNotifyPrepareToImpersonate,
        SampProcessAccountDomainChange,
        SampNotifyStopImpersonation,
        SampAccountDomainClientHandle
    },

    {
        &SampBuiltinDomainDsName, 
        SampNotifyPrepareToImpersonate,
        SampProcessDefaultObjectChange,
        SampNotifyStopImpersonation,
        SampBuiltinDomainClientHandle
    }
};


//
// This table is a list of objects in the DS whose security descriptor
// is cached by SAM.
//

typedef struct _SD_CACHE_TABLE_ENTRY    {
    PDSNAME *ppObjectDsName;
    PSECURITY_DESCRIPTOR *ppSD;
    DWORD  hClient;
} SD_CACHE_TABLE; 


SD_CACHE_TABLE  SampWellKnownSDTable[] =
{
    {
        &SampServerObjectDsName, 
        &SampServerObjectSD,
        SampServerClientHandle
    },

    {
        &SampAccountDomainDsName, 
        &SampAccountDomainObjectSD,
        SampAccountDomainClientHandle
    },

    {
        &SampBuiltinDomainDsName, 
        &SampBuiltinDomainObjectSD,
        SampBuiltinDomainClientHandle
    }
};


ULONG cSampWellKnownSDTable = 
        sizeof(SampWellKnownSDTable) / 
        sizeof(SD_CACHE_TABLE);

NTSTATUS
SampWellKnownNotifyRegister(
    PDSNAME pObjectDsName,
    PF_PFI pfPrepareForImpersonate,
    PF_TD  pfTransmitData,
    PF_SI  pfStopImpersonating,
    DWORD  hClient
    )
/*++

Routine Description:

    This routine registers DS object change notification routines.

    NOTE: the caller should have a open DS transaction.

Parameters:

    pObjectDsName - pointer to the object dsname

    pfPrepareForImpersonate - pointer to prepare routine 

    pfTransmitData - pointer to notification routine 

    pfStopImpersonating - pointer to cleanup routine

    hClient - client identifier

Return Values:

    NtStatus code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SEARCHARG   SearchArg;
    NOTIFYARG   NotifyArg;
    NOTIFYRES*  NotifyRes = NULL; 
    ENTINFSEL   EntInfSel;
    ATTR        Attr;
    FILTER      Filter;
    ULONG       DirError;

    ASSERT( SampExistsDsTransaction() );


    //
    // init notify arg
    //
    NotifyArg.pfPrepareForImpersonate = pfPrepareForImpersonate;
    NotifyArg.pfTransmitData = pfTransmitData;
    NotifyArg.pfStopImpersonating = pfStopImpersonating;
    NotifyArg.hClient = hClient;

    //
    // init search arg
    // 
    RtlZeroMemory(&SearchArg, sizeof(SEARCHARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&Filter, sizeof(ATTR));
    RtlZeroMemory(&Attr, sizeof(ATTR));

    SearchArg.pObject = pObjectDsName;

    InitCommarg(&SearchArg.CommArg);
    SearchArg.choice = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC = TRUE;

    SearchArg.pSelection = &EntInfSel;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;

    SearchArg.pFilter = &Filter;
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    //
    // Call Dir* API
    // 
    DirError = DirNotifyRegister(&SearchArg, &NotifyArg, &NotifyRes); 
                                                            
    if ( NULL == NotifyRes ) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &NotifyRes->CommRes);

    }

    SampClearErrors();

    return( NtStatus );
}


NTSTATUS
SampGetObjectSDByDsName(
    PDSNAME pObjectDsName,
    PSECURITY_DESCRIPTOR *ppSD
    )
/*++

Routine Description:

    This routine reads DS, get security descriptor of this object

    NOTE: the caller should have a DS transaction opened before 
          calling this routine

Parameter:

    pObjectDsName - object ds name

    ppSD -- pointer to hold security descriptor

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       DirError;
    READARG     ReadArg;
    READRES    *ReadRes = NULL;
    COMMARG    *CommArg = NULL;
    ATTR        Attr;
    ATTRBLOCK   ReadAttrBlock;
    ENTINFSEL   EntInfSel;


    ASSERT( SampExistsDsTransaction() );

    //
    // Init Read Argument
    // 
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = pObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);


    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadRes->CommRes);
    }

    if (NT_SUCCESS(NtStatus))
    {
        ATTRBLOCK   AttrBlock;

        ASSERT(NULL != ReadRes);


        AttrBlock = ReadRes->entry.AttrBlock;

        if ( (1 == AttrBlock.attrCount) &&
             (NULL != AttrBlock.pAttr) &&
             (1 == AttrBlock.pAttr[0].AttrVal.valCount) &&
             (NULL != AttrBlock.pAttr[0].AttrVal.pAVal) )
        {
            ULONG   SDLength = 0;

            SDLength = AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;

            *ppSD = RtlAllocateHeap(RtlProcessHeap(), 0, SDLength);

            if (NULL == (*ppSD))
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {

                RtlZeroMemory((*ppSD), SDLength);

                RtlCopyMemory(*ppSD,
                              AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                              SDLength
                              );
            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    return( NtStatus );    
}


NTSTATUS
SampSetupDsObjectNotifications(
    VOID
)
/*++

Routine Description:

    This routine initializes the registers notifications for elements in
    SampDirNotifyTable.
    
Parameter: 

    None.
    
Return Value:
    
    NtStatus Code     

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DsNameLen = 0;
    ULONG       DomainIndex = 0;
    ULONG       i;

    //
    // copy Builtin domain object DSName
    //    

    DomainIndex = SampDsGetPrimaryDomainStart();
    DsNameLen = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs->structLen;

    SampBuiltinDomainDsName = RtlAllocateHeap(RtlProcessHeap(), 0, DsNameLen);
    if (NULL == SampBuiltinDomainDsName) 
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlZeroMemory(SampBuiltinDomainDsName, DsNameLen);
    RtlCopyMemory(SampBuiltinDomainDsName, 
                  SampDefinedDomains[DomainIndex].Context->ObjectNameInDs,
                  DsNameLen
                  );

    //
    // Copy Account Domain object DSName 
    // 

    DomainIndex ++;
    DsNameLen = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs->structLen;

    SampAccountDomainDsName = RtlAllocateHeap(RtlProcessHeap(), 0, DsNameLen);
    if (NULL == SampAccountDomainDsName) 
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlZeroMemory(SampAccountDomainDsName, DsNameLen);
    RtlCopyMemory(SampAccountDomainDsName, 
                  SampDefinedDomains[DomainIndex].Context->ObjectNameInDs,
                  DsNameLen
                  );

    //
    // Begin a DS transaction if required
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Register DS object change notification routine.
    // if succeed, go ahead cache object security descriptor.
    // otherwise leave the SD to NULL
    // 

    for (i = 0; i < RTL_NUMBER_OF(SampDirNotifyTable); i++ )
    {
        // 
        // register notification routine
        // 

        NtStatus = SampWellKnownNotifyRegister(
                        *SampDirNotifyTable[i].ppObjectDsName, 
                        SampDirNotifyTable[i].pfPrepareForImpersonate,
                        SampDirNotifyTable[i].pfTransmitData,
                        SampDirNotifyTable[i].pfStopImpersonating,
                        SampDirNotifyTable[i].hClient
                        );

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // Object doesn't exist, don't setup for notifications
            //
            NtStatus = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(NtStatus) )
        {
            goto Error;
        }
    }

Error:

    if ( !NT_SUCCESS(NtStatus) )
    {
        if (SampBuiltinDomainDsName)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, SampBuiltinDomainDsName);
            SampBuiltinDomainDsName = NULL;
        }

        if (SampAccountDomainDsName)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, SampAccountDomainDsName); 
            SampAccountDomainDsName = NULL;
        }
    }

    //
    // End the DS transaction
    // 

    SampMaybeEndDsTransaction(TransactionCommit);

    return( NtStatus );
}



NTSTATUS
SampInitWellKnownSDTable(
    VOID
)
/*++

Routine Description:

    This routine initializes the SampWellKnownSDTable[], basically we cache
    server object and domain objects (account and builtin domain) security 
    descriptor, because they are not changed very frequently. 
    
    Also SAM registers the DS change notification routines, thus that object
    change can trigger the cached security descriptor been updated. 
    
Parameter: 

    None.
    
Return Value:
    
    NtStatus Code     

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;


    //
    // Begin a DS transaction if required
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Cache object security descriptor for each element in SampWellKnownSD
    // Table.
    // 

    for (i = 0; i < cSampWellKnownSDTable; i++ )
    {
        PSECURITY_DESCRIPTOR pSD = NULL;

        //
        // The global names of the objects should have already have been
        // setup by SampSetupDsObjectNotifications
        //
        ASSERT(NULL != *SampWellKnownSDTable[i].ppObjectDsName);

        //
        // init the SD pointer to NULL
        // 

        *(SampWellKnownSDTable[i].ppSD) = NULL;


        //
        // get well known object security descriptor
        // 

        NtStatus = SampGetObjectSDByDsName(
                        *SampWellKnownSDTable[i].ppObjectDsName,
                        &pSD
                        );

        if ( NT_SUCCESS(NtStatus) )
        {
            *(SampWellKnownSDTable[i].ppSD) = pSD;

        } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // Object doesn't exist, don't cache
            //
            NtStatus = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(NtStatus) )
        {
            goto Error;
        }
    }

Error:

    //
    // End the DS transaction
    // 

    SampMaybeEndDsTransaction(TransactionCommit);

    return( NtStatus );
}



BOOL
SampServerNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampProcessWellKnownSDChange.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampServerNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampProcessWellKnownSDChange, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}






VOID
SampProcessWellKnownSDChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    )
/*++

Routine Description:

    This routine is called if Server / Domain Object have been modified.  

    Though we don't know which attribute has been changed, we'd better
    update the cached object security descriptor.

    for better performance, we can read DS object Meta data to tell whether
    security descriptor been changed or not. 

Parameter:
    
    hClient - client identifier
    
    hServer - server identifier
    
    EntInf  - pointer to entry info

Return Value:

    None.

--*/
{
    ULONG   i, Index;
    PVOID   pv = NULL;
    PVOID   PtrToFree = NULL;

    //
    // determine which object needs to be updated
    // 

    for (i = 0; i < cSampWellKnownSDTable; i++ )
    {
        if (hClient == SampWellKnownSDTable[i].hClient)
        {
            Index = i;
            break;
        }
    }

    if (i >= cSampWellKnownSDTable)
    {
        ASSERT( FALSE && "Invalid client identifier\n");
        return;
    }

    //
    // invalidate cached object SD
    // 
    
    pv = NULL;
    PtrToFree = InterlockedExchangePointer(
                    SampWellKnownSDTable[Index].ppSD,
                    pv
                    );

    if ( PtrToFree )
    {
        LsaIRegisterNotification(
                        SampDelayedFreeSD,
                        PtrToFree,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        3600,     // wait for 60 min
                        NULL      // no handle
                        );
    }
    

    //
    // Update cached object SD
    // 

    pv = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ULONG));

    if (NULL == pv) {
        return;
    }

    RtlZeroMemory(pv, sizeof(ULONG));

    *(ULONG *)pv = Index;
    
    LsaIRegisterNotification(
                        SampUpdateWellKnownSD,
                        pv,
                        NOTIFIER_TYPE_IMMEDIATE,
                        0,      // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        0,      // do it now
                        NULL    // no handle
                        );

    return;
}



NTSTATUS
SampUpdateWellKnownSD(
    PVOID pv
    )
/*++

Routine Description:

    This routine updates SampWellKnownSDTable[], value of pv
    indicates which element needs to be updated.  

    NOTE: cached SD should have already been invalidated

Parameter:

    pv - value tells the index of entry in the table

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR     pSD = NULL;
    BOOLEAN     fTransOpen = TRUE;
    PVOID       PtrToFree = NULL;
    ULONG       Index = 0;

    ASSERT( NULL != pv );

    if (NULL == pv)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fTransOpen = TRUE;

    //
    // get the new security descriptor
    // 

    Index = * (ULONG *)pv;
    NtStatus = SampGetObjectSDByDsName(
                        *SampWellKnownSDTable[Index].ppObjectDsName,
                        &pSD
                        );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }


    //
    // update cached security descriptor if everything is fine
    // 

    PtrToFree = InterlockedExchangePointer(
                        SampWellKnownSDTable[Index].ppSD,
                        pSD
                        );

    if ( PtrToFree )
    {
        LsaIRegisterNotification(
                        SampDelayedFreeSD,
                        PtrToFree,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        3600,     // wait for 60 min
                        NULL      // no handle
                        );
    }

Cleanup:

    if ( fTransOpen )
    {
        NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

        IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? 
                                                  TransactionCommit : TransactionAbort
                                                );
    }

    // if not succeed, try again
    if ( !NT_SUCCESS(NtStatus) )
    {
        LsaIRegisterNotification(
                        SampUpdateWellKnownSD,
                        pv,
                        NOTIFIER_TYPE_INTERVAL,
                        0,            // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        60,           // wait for 1 min
                        NULL          // no handle
                        );
    }
    else
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pv);
    }

    return( NtStatus );
}





NTSTATUS
SampGetCachedObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )
/*++

Routine Description:

    This routine get object security descriptor from well known SD table

Parameter:
    
    Context - object context
    
    SecurityDescriptorLength - object SD length

    SecurityDescriptor - place to hold SD 

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i, Index = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;


    //
    // init return values
    // 

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    
    //
    // scan well known object SD table first
    // 
    
    switch (Context->ObjectType)
    {
    case SampServerObjectType:

        Index = SampServerObjectSDIndex;
        break;

    case SampDomainObjectType:

        if (IsBuiltinDomain(Context->DomainIndex))
        {
            Index = SampBuiltinDomainSDIndex;
        }
        else
        {
            Index = SampAccountDomainSDIndex;
        }

        break;

    default:

        ASSERT(FALSE && "Incorrect SAM object type\n");
        break;
    }

    pSD = *(SampWellKnownSDTable[Index].ppSD);

    //
    // if the well known object (server / domain) SD is available, 
    // get it from the table, other return error. So that caller can 
    // read DS backing store.
    // 

    if (NULL == pSD)
    {
        return( STATUS_UNSUCCESSFUL ); 
    }
    else
    {
        ULONG   SDLength = RtlLengthSecurityDescriptor( pSD );

        *SecurityDescriptor = RtlAllocateHeap(RtlProcessHeap(), 0, SDLength);

        if (NULL == *SecurityDescriptor)
        {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
        else
        {
            RtlZeroMemory(*SecurityDescriptor, SDLength);

            RtlCopyMemory(*SecurityDescriptor, pSD, SDLength);

            *SecurityDescriptorLength = SDLength;
        }
    }

    return( NtStatus );
}


NTSTATUS
SampDelayedFreeSD(
    PVOID pv
    )
{
    if ( pv ) {

        RtlFreeHeap( RtlProcessHeap(), 0, pv );
    }

    return STATUS_SUCCESS;
}



VOID
SampProcessAccountDomainChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    )
/*++

Routine Description:

    This routine handles the notification that the account domain object
    has changed.

Parameter:
    
    hClient - client identifier
    
    hServer - server identifier
    
    EntInf  - pointer to entry info

Return Value:

    None.

--*/
{

    //
    // Update the cached security descriptor
    //

    SampProcessWellKnownSDChange(hClient,
                                 hServer,
                                 EntInf);

    //
    // Refresh the well known containers globals.
    //

    LsaIRegisterNotification(
                    SampInitWellKnownContainersDsNameAsync,
                    RootObjectName,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    0,        // go!
                    NULL      // no handle
                    );


}


VOID
SampProcessDefaultObjectChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    )
/*++

Routine Description:

    This routine handles the notification that a request object changed in
    the DS.  hClient identifies which object has changed.

Parameter:
    
    hClient - client identifier
    
    hServer - server identifier
    
    EntInf  - pointer to entry info

Return Value:

    None.

--*/
{
    //
    // Update the cached security descriptor
    //

    SampProcessWellKnownSDChange(hClient,
                                 hServer,
                                 EntInf);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samtrace.h ===
#ifndef _SAMTRACE_H
#define _SAMTRACE_H

/*++

copyright (c) 1998 Microsoft Corporation

Module Name:

    SAMTRACE.H
    
Abstract:

    Inplement SAM server event trace by using WMI trace infrastructure.
    
Author:
    
    01-Dec-1998  ShaoYin
    
Revision History:

    
--*/    


//
//
// included headers
//
// 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>


#include <wmistr.h>
#include <evntrace.h>



extern unsigned long    SampEventTraceFlag;
extern TRACEHANDLE      SampTraceRegistrationHandle;
extern TRACEHANDLE      SampTraceLoggerHandle;
extern BOOLEAN          SampTraceLogEventInDetail;


ULONG
_stdcall
SampInitializeTrace(PVOID Param);


VOID
SampTraceEvent(
    IN ULONG WmiEventType, 
    IN ULONG TraceGuid 
    );


//
// This is the control Guid for the group of Guids traced below
// 
DEFINE_GUID ( /* 8e598056-8993-11d2-819e-0000f875a064 */
    SampControlGuid, 
    0x8e598056, 
    0x8993, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 8c89045c-3f5d-4289-939a-fb854000cb6b */
    SampConnectGuid,
    0x8c89045c,
    0x3f5d,
    0x4289,
    0x93, 0x9a, 0xfb, 0x85, 0x40, 0x00, 0xcb, 0x6b
    );


DEFINE_GUID ( /* dbc0ceab-cff3-4c0f-85f2-0c2107142f36 */
    SampCloseHandleGuid,
    0xdbc0ceab,
    0xcff3,
    0x4c0f,
    0x85, 0xf2, 0x0c, 0x21, 0x07, 0x14, 0x2f, 0x36
    );


DEFINE_GUID ( /* 74e10cbb-202e-4a97-871d-8547972b5141 */
    SampSetSecurityObjectGuid,
    0x74e10cbb,
    0x202e,
    0x4a97,
    0x87, 0x1d, 0x85, 0x47, 0x97, 0x2b, 0x51, 0x41
    );


DEFINE_GUID ( /* 676347f3-fd20-4e7d-90b1-77e35f84af9a */
    SampQuerySecurityObjectGuid,
    0x676347f3,
    0xfd20,
    0x4e7d,
    0x90, 0xb1, 0x77, 0xe3, 0x5f, 0x84, 0xaf, 0x9a
    );



DEFINE_GUID ( /* f8012701-7e99-49c5-b832-1db8bc4a610d */
    SampShutdownSamServerGuid,
    0xf8012701,
    0x7e99,
    0x49c5,
    0xb8, 0x32, 0x1d, 0xb8, 0xbc, 0x4a, 0x61, 0x0d
    );



DEFINE_GUID ( /* a11e5d6b-353d-4bf6-97a8-ede4cba45524 */
    SampLookupDomainInSamServerGuid,
    0xa11e5d6b,
    0x353d,
    0x4bf6,
    0x97, 0xa8, 0xed, 0xe4, 0xcb, 0xa4, 0x55, 0x24
    );



DEFINE_GUID ( /* 7c65ceb0-75ba-46b9-884e-67e038c5b003 */
    SampEnumerateDomainsInSamServerGuid,
    0x7c65ceb0,
    0x75ba,
    0x46b9,
    0x88, 0x4e, 0x67, 0xe0, 0x38, 0xc5, 0xb0, 0x03
    );



DEFINE_GUID ( /* 6e1f2449-f1f3-4634-b51f-46e2c6625892 */
    SampOpenDomainGuid,
    0x6e1f2449,
    0xf1f3,
    0x4634,
    0xb5, 0x1f, 0x46, 0xe2, 0xc6, 0x62, 0x58, 0x92
    );



DEFINE_GUID ( /* 89399c21-4aaf-408e-ba39-ab831a1298d5 */
    SampQueryInformationDomainGuid,
    0x89399c21,
    0x4aaf,
    0x408e,
    0xba, 0x39, 0xab, 0x83, 0x1a, 0x12, 0x98, 0xd5
    );



DEFINE_GUID ( /* 45309ef4-c59e-425e-b95b-19f1c5a3c55a */
    SampSetInformationDomainGuid,
    0x45309ef4,
    0xc59e,
    0x425e,
    0xb9, 0x5b, 0x19, 0xf1, 0xc5, 0xa3, 0xc5, 0x5a
    );


DEFINE_GUID ( /* c8eb5e5c-899c-11d2-819e-0000f875a064 */ 
    SampCreateGroupInDomainGuid,
    0xc8eb5e5c, 
    0x899c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 5d11e02f-0c36-4180-ad07-89062c9df9ec */
    SampEnumerateGroupsInDomainGuid,
    0x5d11e02f,
    0x0c36,
    0x4180,
    0xad, 0x07, 0x89, 0x06, 0x2c, 0x9d, 0xf9, 0xec
    );


DEFINE_GUID ( /* 39511dbe-899b-11d2-819e-0000f875a064 */
    SampCreateUserInDomainGuid,
    0x39511dbe, 
    0x899b, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* abb14b68-899b-11d2-819e-0000f875a064 */
    SampCreateComputerInDomainGuid,
    0xabb14b68, 
    0x899b, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 07ffaa1d-34f6-49cd-b541-2f0d7dff15c4 */
    SampEnumerateUsersInDomainGuid,
    0x07ffaa1d,
    0x34f6,
    0x49cd,
    0xb5, 0x41, 0x2f, 0x0d, 0x7d, 0xff, 0x15, 0xc4
    );



DEFINE_GUID ( /* 5e612efd-c05e-4f76-bced-f5607aa3d46e */
    SampCreateAliasInDomainGuid,
    0x5e612efd,
    0xc05e,
    0x4f76,
    0xbc, 0xed, 0xf5, 0x60, 0x7a, 0xa3, 0xd4, 0x6e
    );


DEFINE_GUID ( /* f1fea491-bfa6-436c-a178-a70d03b4fb1a */
    SampEnumerateAliasesInDomainGuid,
    0xf1fea491,
    0xbfa6,
    0x436c,
    0xa1, 0x78, 0xa7, 0x0d, 0x03, 0xb4, 0xfb, 0x1a
    );


DEFINE_GUID ( /* 1cf5fd19-1ac1-4324-84f7-970a634a91ee */
    SampGetAliasMembershipGuid,
    0x1cf5fd19,
    0x1ac1,
    0x4324,
    0x84, 0xf7, 0x97, 0x0a, 0x63, 0x4a, 0x91, 0xee
    );


DEFINE_GUID ( /* a41d90bc-899d-11d2-819e-0000f875a064 */     
    SampLookupNamesInDomainGuid,
    0xa41d90bc, 
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );

    
DEFINE_GUID ( /* 25059476-899f-11d2-819e-0000f875a064 */
    SampLookupIdsInDomainGuid, 
    0x25059476,
    0x899f, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );



DEFINE_GUID ( /* b41d7bdf-4249-4651-ac0f-1879be0d5c0c */
    SampOpenGroupGuid,
    0xb41d7bdf,
    0x4249,
    0x4651,
    0xac, 0x0f, 0x18, 0x79, 0xbe, 0x0d, 0x5c, 0x0c
    );



DEFINE_GUID ( /* 632fcc78-6057-48f9-8d5f-4bb0f73d3cd1 */
    SampQueryInformationGroupGuid,
    0x632fcc78,
    0x6057,
    0x48f9,
    0x8d, 0x5f, 0x4b, 0xb0, 0xf7, 0x3d, 0x3c, 0xd1
    );



DEFINE_GUID ( /* 26106246-4473-4295-841b-4a51c6afc3db */
    SampSetInformationGroupGuid,
    0x26106246,
    0x4473,
    0x4295,
    0x84, 0x1b, 0x4a, 0x51, 0xc6, 0xaf, 0xc3, 0xdb
    );



DEFINE_GUID ( /* f9d2ba6a-899c-11d2-819e-0000f875a064 */
    SampAddMemberToGroupGuid, 
    0xf9d2ba6a, 
    0x899c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 5f7c4ba5-d6a4-4625-900e-48fa7811e06a */
    SampDeleteGroupGuid,
    0x5f7c4ba5,
    0xd6a4,
    0x4625,
    0x90, 0x0e, 0x48, 0xfa, 0x78, 0x11, 0xe0, 0x6a
    );

    
DEFINE_GUID ( /* 250959aa-899d-11d2-819e-0000f875a064 */
    SampRemoveMemberFromGroupGuid, 
    0x250959aa,
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    


DEFINE_GUID ( /* 5954bc51-c5ec-4aaa-831c-6f2c1b2515b6 */
    SampGetMembersInGroupGuid,
    0x5954bc51,
    0xc5ec,
    0x4aaa,
    0x83, 0x1c, 0x6f, 0x2c, 0x1b, 0x25, 0x15, 0xb6
    );



DEFINE_GUID ( /* 0254ba6d-7ff0-4bfe-a3f9-8fd8da667641 */
    SampSetMemberAttributesOfGroupGuid,
    0x0254ba6d,
    0x7ff0,
    0x4bfe,
    0xa3, 0xf9, 0x8f, 0xd8, 0xda, 0x66, 0x76, 0x41
    );



DEFINE_GUID ( /* ba41c883-592f-4ab9-b2a9-c6263b011fe7 */
    SampOpenAliasGuid,
    0xba41c883,
    0x592f,
    0x4ab9,
    0xb2, 0xa9, 0xc6, 0x26, 0x3b, 0x01, 0x1f, 0xe7
    );



DEFINE_GUID ( /* 419f025a-bf06-4673-af66-d230bec2af02 */
    SampQueryInformationAliasGuid,
    0x419f025a,
    0xbf06,
    0x4673,
    0xaf, 0x66, 0xd2, 0x30, 0xbe, 0xc2, 0xaf, 0x02
    );



DEFINE_GUID ( /* e712d39d-a3a6-4224-a1bd-4717b24e4e8c */
    SampSetInformationAliasGuid,
    0xe712d39d,
    0xa3a6,
    0x4224,
    0xa1, 0xbd, 0x47, 0x17, 0xb2, 0x4e, 0x4e, 0x8c
    );


DEFINE_GUID ( /* fbfe2540-452b-41bb-9219-dfb6fd1a129b */
    SampDeleteAliasGuid,
    0xfbfe2540,
    0x452b,
    0x41bb,
    0x92, 0x19, 0xdf, 0xb6, 0xfd, 0x1a, 0x12, 0x9b
    );



DEFINE_GUID ( /* 3a2e63d1-5dc4-4168-85ea-3e331f88ce83 */
    SampAddMemberToAliasGuid,
    0x3a2e63d1,
    0x5dc4,
    0x4168,
    0x85, 0xea, 0x3e, 0x33, 0x1f, 0x88, 0xce, 0x83
    );



DEFINE_GUID ( /* 6ba1639c-afc4-454e-b3e0-5e8f7fc39af9 */
    SampRemoveMemberFromAliasGuid,
    0x6ba1639c,
    0xafc4,
    0x454e,
    0xb3, 0xe0, 0x5e, 0x8f, 0x7f, 0xc3, 0x9a, 0xf9
    );



DEFINE_GUID ( /* 5cec3d52-6eeb-474d-b468-58362888f1b0 */
    SampGetMembersInAliasGuid,
    0x5cec3d52,
    0x6eeb,
    0x474d,
    0xb4, 0x68, 0x58, 0x36, 0x28, 0x88, 0xf1, 0xb0
    );



DEFINE_GUID ( /* b8d2bc4a-1525-4386-bb1c-6bb2e24eb001 */
    SampOpenUserGuid,
    0xb8d2bc4a,
    0x1525,
    0x4386,
    0xbb, 0x1c, 0x6b, 0xb2, 0xe2, 0x4e, 0xb0, 0x01
    );



DEFINE_GUID ( /* c2a0e094-a178-4372-b4fe-a33e48c3585c */
    SampDeleteUserGuid,
    0xc2a0e094,
    0xa178,
    0x4372,
    0xb4, 0xfe, 0xa3, 0x3e, 0x48, 0xc3, 0x58, 0x5c
    );



DEFINE_GUID ( /* e1cb227a-6d55-4282-a5f7-6fa4a5922c0b */
    SampQueryInformationUserGuid,
    0xe1cb227a,
    0x6d55,
    0x4282,
    0xa5, 0xf7, 0x6f, 0xa4, 0xa5, 0x92, 0x2c, 0x0b
    );



DEFINE_GUID ( /* bc80e27f-6b74-4da9-abfc-2e4e82b81000 */
    SampSetInformationUserGuid,
    0xbc80e27f,
    0x6b74,
    0x4da9,
    0xab, 0xfc, 0x2e, 0x4e, 0x82, 0xb8, 0x10, 0x00
    );


DEFINE_GUID ( /* 45fc997e-899d-11d2-819e-0000f875a064 */    
    SampChangePasswordUserGuid,
    0x45fc997e,
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 19b30cde-3e41-4cff-83c8-3df2779f840c */
    SampChangePasswordComputerGuid,
    0x19b30cde,
    0x3e41,
    0x4cff,
    0x83, 0xc8, 0x3d, 0xf2, 0x77, 0x9f, 0x84, 0x0c
    );


    
DEFINE_GUID ( /* 62bef71e-899d-11d2-819e-0000f875a064 */    
    SampSetPasswordUserGuid, 
    0x62bef71e, 
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    
DEFINE_GUID ( /* 880217b8-899d-11d2-819e-0000f875a064 */    
    SampSetPasswordComputerGuid, 
    0x880217b8,
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    
DEFINE_GUID ( /* 1f228de8-8a6c-11d2-819e-0000f875a064 */
    SampPasswordPushPdcGuid, 
    0x1f228de8, 
    0x8a6c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );

    
DEFINE_GUID ( /* 0e3913c5-9760-4ced-b133-004a64e8d53c */
    SampGetGroupsForUserGuid,
    0x0e3913c5,
    0x9760,
    0x4ced,
    0xb1, 0x33, 0x00, 0x4a, 0x64, 0xe8, 0xd5, 0x3c
    );


DEFINE_GUID ( /* eb225178-f5f0-42b7-895b-db89276f647a */
    SampQueryDisplayInformationGuid,
    0xeb225178,
    0xf5f0,
    0x42b7,
    0x89, 0x5b, 0xdb, 0x89, 0x27, 0x6f, 0x64, 0x7a
    );



DEFINE_GUID ( /* aceb7864-9a14-4c73-8ed0-94ec53f6651c */
    SampGetDisplayEnumerationIndexGuid,
    0xaceb7864,
    0x9a14,
    0x4c73,
    0x8e, 0xd0, 0x94, 0xec, 0x53, 0xf6, 0x65, 0x1c
    );



DEFINE_GUID ( /* 4ff7a7db-43ca-470a-8b64-3003e2d22042 */
    SampGetUserDomainPasswordInformationGuid,
    0x4ff7a7db,
    0x43ca,
    0x470a,
    0x8b, 0x64, 0x30, 0x03, 0xe2, 0xd2, 0x20, 0x42
    );



DEFINE_GUID ( /* 8919f267-a053-4669-aa69-2da0d4a20d92 */
    SampRemoveMemberFromForeignDomainGuid,
    0x8919f267,
    0xa053,
    0x4669,
    0xaa, 0x69, 0x2d, 0xa0, 0xd4, 0xa2, 0x0d, 0x92
    );



DEFINE_GUID ( /* ff0c6ce2-9528-4a91-b9c7-bcf834b6f79a */
    SampGetDomainPasswordInformationGuid,
    0xff0c6ce2,
    0x9528,
    0x4a91,
    0xb9, 0xc7, 0xbc, 0xf8, 0x34, 0xb6, 0xf7, 0x9a
    );



DEFINE_GUID ( /* 2e991575-c2ed-42a7-97ff-a0d6571f1862 */
    SampSetBootKeyInformationGuid,
    0x2e991575,
    0xc2ed,
    0x42a7,
    0x97, 0xff, 0xa0, 0xd6, 0x57, 0x1f, 0x18, 0x62
    );



DEFINE_GUID ( /* 33be4128-d02e-4b6f-949e-ab77cc8164b1 */
    SampGetBootKeyInformationGuid,
    0x33be4128,
    0xd02e,
    0x4b6f,
    0x94, 0x9e, 0xab, 0x77, 0xcc, 0x81, 0x64, 0xb1
    );


//
// The following "typedef enum" actually is the index of LPGUID in 
// the table of SampTraceGuids[] (defined in samtrace.c). We should 
// always change SampTraceGuids[] if we add any other entry 
// in the following enum type.  
// 
    
    
typedef enum _SAMPTRACE_GUIDS {

    SampGuidConnect,
    SampGuidCloseHandle,
    SampGuidSetSecurityObject,
    SampGuidQuerySecurityObject,
    SampGuidShutdownSamServer,
    SampGuidLookupDomainInSamServer,
    SampGuidEnumerateDomainsInSamServer,
    SampGuidOpenDomain,
    SampGuidQueryInformationDomain,
    SampGuidSetInformationDomain,
    SampGuidCreateGroupInDomain,
    SampGuidEnumerateGroupsInDomain,
    SampGuidCreateUserInDomain,
    SampGuidCreateComputerInDomain,
    SampGuidEnumerateUsersInDomain,
    SampGuidCreateAliasInDomain,
    SampGuidEnumerateAliasesInDomain,
    SampGuidGetAliasMembership,
    SampGuidLookupNamesInDomain,
    SampGuidLookupIdsInDomain,
    SampGuidOpenGroup,
    SampGuidQueryInformationGroup,
    SampGuidSetInformationGroup,
    SampGuidAddMemberToGroup,
    SampGuidDeleteGroup,
    SampGuidRemoveMemberFromGroup,
    SampGuidGetMembersInGroup,
    SampGuidSetMemberAttributesOfGroup,
    SampGuidOpenAlias,
    SampGuidQueryInformationAlias,
    SampGuidSetInformationAlias,
    SampGuidDeleteAlias,
    SampGuidAddMemberToAlias,
    SampGuidRemoveMemberFromAlias,
    SampGuidGetMembersInAlias,
    SampGuidOpenUser,
    SampGuidDeleteUser,
    SampGuidQueryInformationUser,
    SampGuidSetInformationUser,
    SampGuidChangePasswordUser,
    SampGuidChangePasswordComputer,
    SampGuidSetPasswordUser,
    SampGuidSetPasswordComputer,
    SampGuidPasswordPushPdc,
    SampGuidGetGroupsForUser,
    SampGuidQueryDisplayInformation,
    SampGuidGetDisplayEnumerationIndex,
    SampGuidGetUserDomainPasswordInformation,
    SampGuidRemoveMemberFromForeignDomain,
    SampGuidGetDomainPasswordInformation,
    SampGuidSetBootKeyInformation,
    SampGuidGetBootKeyInformation

} SAMPTRACE_GUID;    


typedef struct _SAMP_EVENT_TRACE_INFO
{
    EVENT_TRACE_HEADER  EventTrace;
    MOF_FIELD           EventInfo[4];

}   SAMP_EVENT_TRACE_INFO, *PSAMP_EVENT_TRACE_INFO;
    
#endif /* _SAMTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\sdconvrt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Sdconvert.h

Abstract:

    This file contains services and type definitions pertaining to the 
    conversin of NT5 and NT4 SAM security descriptors

    


Author:

    Murli Satagopan (MURLIS)

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SDCONVRT_

#define _SDCONVRT_

//
// Access Right mapping Table -- The access right mapping table is
// specify the relationship between the NT4 SAM access rights and
// the DS rights. For every SAM access right there is an entry in
// the table which represents the access right as a DS access mask
// and property GUID
//


typedef struct _ACCESSRIGHT_MAPPING_TABLE {
    ACCESS_MASK SamAccessRight;
    ACCESS_MASK DsAccessMask;    
    USHORT ObjectTypeListIndex;
    USHORT Level;
    ULONG cGuids;
    const GUID  * DsGuid;
    
} ACCESSRIGHT_MAPPING_TABLE;


//
//
// The reverse Mapping table contains a SAM access mask entry for each DS access mask
// on a per property basis. The 16 specific rights of the DS is divided into 8 bit
// halves and for each combination of these, the corresponding SAM access mask is 
// stored. Given a Ds access mask and Type GUID this table can be use to 
// very quickly compute the corresponding SAM access mask.
//
//
typedef struct _REVERSE_MAPPING_TABLE_ENTRY {
    USHORT SamSpecificRightsHi[256]; 
    USHORT SamSpecificRightsLo[256]; 
} REVERSE_MAPPING_TABLE;


//
// The Sid Access mask table is used by NT5 to NT4 down non match algorithm
// down conversion code. This table is used to group the access masks in by
// type guid and Sid from a set of ACLS
//

typedef struct _SID_ACCESS_MASK_TABLE_ENTRY {
    PSID Sid;
    ACCESS_MASK * AccessAllowedMasks;
    ACCESS_MASK * AccessDeniedMasks;
    ACCESS_MASK   StandardAllowedMask;
    ACCESS_MASK   StandardDeniedMask;
} SID_ACCESS_MASK_TABLE;


//
// The ACE table is used to hold information regarding the default Dacls to be
// put on NT5 SAM security descriptors. An ace table lists the aces in the Dacl
//
//

typedef struct _ACE_TABLE_ENTRY {
    ULONG             AceType;
    PSID              *Sid;
    ACCESS_MASK       AccessMask;
    BOOLEAN           IsObjectGuid;
    const GUID        *TypeGuid;
    const GUID        *InheritGuid;
} ACE_TABLE;


//
// The NT4_ACE_TABLE structure is used by routines that try to recognize standard
// NT4 SAM Sids. These tables hold the SID and Access Masks of Ace's present in NT4
// DACL's
//

typedef struct _NT4_ACE_TABLE_ENTRY {
    PSID    *Sid;
    ACCESS_MASK AccessMask;
} NT4_ACE_TABLE;

typedef void ACE;

#define ACL_CONVERSION_CACHE_SIZE 10 // just a 10 element cache 

typedef struct _ACL_CONVERSION_CACHE_ELEMENT {
    NT4SID SidOfPrincipal;
    BOOLEAN fValid;
    BOOLEAN fAdmin;
} ACL_CONVERSION_CACHE_ELEMENT;

typedef struct _ACL_CONVERSION_CACHE {
    CRITICAL_SECTION Lock;
    ACL_CONVERSION_CACHE_ELEMENT Elements[ACL_CONVERSION_CACHE_SIZE];
} ACL_CONVERSION_CACHE;




//
// ACL Conversion cache routines
//

NTSTATUS
SampInitializeAclConversionCache();


VOID
SampInvalidateAclConversionCache();

BOOLEAN
SampLookupAclConversionCache(
    IN PSID SidToLookup,
    OUT BOOLEAN *fAdmin
    );

VOID
SampAddToAclConversionCache(
    IN PSID SidToAdd, 
    IN BOOLEAN fAdmin
    );
 
//
//
// Some Defines
//
//

#define MAX_SCHEMA_GUIDS 256
#define OBJECT_CLASS_GUID_INDEX 0
#define MAX_ACL_SIZE     2048
#define GEMERIC_MASK     0xF0000000


//
//    SAM well known Sids
//
//

#define ADMINISTRATOR_SID        (&(SampAdministratorsAliasSid))
#define ACCOUNT_OPERATOR_SID     (&(SampAccountOperatorsAliasSid))   
#define WORLD_SID                (&(SampWorldSid))
#define PRINCIPAL_SELF_SID        (&(SampPrincipalSelfSid))
#define AUTHENTICATED_USERS_SID  (&(SampAuthenticatedUsersSid))
#define BUILTIN_DOMAIN_SID       (&(SampBuiltinDomainSid))


#define DS_SPECIFIC_RIGHTS  (RIGHT_DS_CREATE_CHILD |\
                                RIGHT_DS_DELETE_CHILD |\
                                RIGHT_DS_LIST_CONTENTS |\
                                RIGHT_DS_SELF_WRITE |\
                                RIGHT_DS_READ_PROPERTY |\
                                RIGHT_DS_WRITE_PROPERTY)


//
//
// Function Prototypes
//
//

//
// Init Function for external clients like DS upgrade
//
//

NTSTATUS
SampInitializeSdConversion();


//
// Computes the reverse access rights plus does some misc initialization
//
//

NTSTATUS
SampInitializeAccessRightsTable();


//
// Access Check based on NT5 SD and NT4 SAM access Mask
//
//

NTSTATUS
SampDoNt5SdBasedAccessCheck(
    IN  PSAMP_OBJECT Context,
    IN  PVOID   Nt5Sd,
    IN  PSID    PrincipalSelfSid,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG   Nt4SamAccessMask,
    IN  BOOLEAN ObjectCreation,
    IN  GENERIC_MAPPING * Nt4SamGenericMapping,
    IN  HANDLE  ClientToken,
    OUT ACCESS_MASK * GrantedAccess,
    OUT PRTL_BITMAP   GrantedAccessAttributes,
    OUT NTSTATUS * AccessCheckStatus
    );


//
//  NT4 to NT5 upgradation of security descriptor
//
//

NTSTATUS
SampConvertNt4SdToNt5Sd(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT CONTEXT OPTIONAL,
    OUT PVOID * Nt5Sd
    );

NTSTATUS
SampPropagateSelectedSdChanges(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT CONTEXT OPTIONAL,
    OUT PVOID * Nt5Sd
    );


//
// NT5 to NT4 down conversion
//
//

NTSTATUS
SampConvertNt5SdToNt4SD(
    IN PVOID Nt5Sd,
    IN PSAMP_OBJECT Context,
    IN PSID SelfSid,
    OUT PVOID * Nt4Sd
    );


//
// Building NT5 security descriptors
//
//


NTSTATUS
SampBuildEquivalentNt5Protection(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN ChangePassword,
    IN PSID Owner,
    IN PSID Group,
    IN PACL Sacl,
    IN PSAMP_OBJECT Context OPTIONAL,
    PSECURITY_DESCRIPTOR * Nt5Sd,
    PULONG Nt5SdLength
    );

NTSTATUS
SampGetDefaultSecurityDescriptorForClass(
    ULONG   DsClassId,
    PULONG  SecurityDescriptorLength,
    BOOLEAN TrustedClient,
    PSECURITY_DESCRIPTOR    *SecurityDescriptor
    );

NTSTATUS
SampMakeNewSelfRelativeSecurityDescriptor(
    PSID    Owner,
    PSID    Group,
    PACL    Dacl,
    PACL    Sacl,
    PULONG  SecurityDescriptorLength,
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    );


//
//
// Some easy to use routines for SD, ACL and ACE manipulation
//
//
//

PACL 
GetDacl(
    IN PSECURITY_DESCRIPTOR Sd
    );


PACL 
GetSacl(
    IN PSECURITY_DESCRIPTOR Sd
    );

PSID 
GetOwner(
     IN PSECURITY_DESCRIPTOR Sd
     );
                
PSID 
GetGroup(
     IN PSECURITY_DESCRIPTOR Sd
     );


ULONG 
GetAceCount(
    IN PACL Acl
    );

ACE * 
GetAcePrivate(
    IN PACL Acl,
    ULONG AceIndex
    );


ACCESS_MASK 
AccessMaskFromAce(
                IN ACE * Ace
                );


PSID SidFromAce(
        IN ACE * Ace
        );

BOOLEAN
IsAccessAllowedAce(
    ACE * Ace
    );


BOOLEAN
IsAccessAllowedObjectAce(
    ACE * Ace
    );


BOOLEAN
AdjustAclSize(PACL Acl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\security.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This file contains services which perform access validation on
    attempts to access SAM objects.  It also performs auditing on
    both open and close operations.


Author:

    Jim Kelly    (JimK)  6-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntseapi.h>
#include <seopaque.h>
#include <sdconvrt.h>
#include <dslayer.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()

#include <attids.h>             // ATT_SCHEMA_ID_GUID
#include <ntdsguid.h>           // GUID_CONTROL_DsInstallReplica
#include "permit.h"             // for DS_GENERIC_MAPPING




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampRemoveAnonymousAccess(
    IN OUT PSECURITY_DESCRIPTOR *    Sd,
    IN OUT PULONG                    SdLength,
    IN ULONG    AccessToRemove,
    IN SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampCreateUserToken(
    IN PSAMP_OBJECT UserContext,
    IN HANDLE       PassedInToken,
    IN HANDLE       *UserToken
    );

BOOLEAN
SampIsForceGuestEnabled();

BOOLEAN
SampIsClientLocal();



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIImpersonateNullSession(
    )
/*++

Routine Description:

    Impersonates the null session token

Arguments:

    None

Return Value:

    STATUS_CANNOT_IMPERSONATE - there is no null session token to imperonate

--*/
{
    SAMTRACE("SampImpersonateNullSession");

    if (SampNullSessionToken == NULL) {
        return(STATUS_CANNOT_IMPERSONATE);
    }
    return( NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &SampNullSessionToken,
                sizeof(HANDLE)
                ) );

}

NTSTATUS
SamIRevertNullSession(
    )
/*++

Routine Description:

    Reverts a thread from impersonating the null session token.

Arguments:

    None

Return Value:

    STATUS_CANNOT_IMPERSONATE - there was no null session token to be
        imperonating.

--*/
{

    HANDLE NullHandle = NULL;

    SAMTRACE("SampRevertNullSession");

    if (SampNullSessionToken == NULL) {
        return(STATUS_CANNOT_IMPERSONATE);
    }

    return( NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &NullHandle,
                sizeof(HANDLE)
                ) );

}





NTSTATUS
SampValidateDomainControllerCreation(
    IN PSAMP_OBJECT Context
    )
/*++
Routine Description:

    This routine will check whether the client has enough right
    to convert a machine (workstation or standalone server) account
    to a Server Trust Account (replica domain controller).

    1. Retrieve Domain NC head, which is Account Domain

        1.1 Get Domain NC head Security Descriptor

    2. Fill the Object List

    3. Impersonate Client

    4. Access Check

    5. Unimpersonate Client

    Note: Should only be called in DS case.

Parameters:

    Context - The handle value that will be assigned if the access validation
        is successful.

Return Values:

    STATUS_SUCCESS  -- the client has enough right to create a Server
                       Trust Account

    STATUS_ACCESS_DENIED -- not enough right

    other Error code.

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    PSAMP_OBJECT            DomainContext = NULL;
    OBJECT_TYPE_LIST        ObjList[2];
    DWORD                   Results[2];
    DWORD                   GrantedAccess[2];
    PSECURITY_DESCRIPTOR    pSD = NULL;
    GENERIC_MAPPING         GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK             DesiredAccess;
    ULONG           cbSD = 0;
    GUID            ClassGuid;
    ULONG           ClassGuidLength = sizeof(GUID);
    BOOLEAN         bTemp = FALSE;
    PSID            PrincipleSelfSid = NULL;
    UNICODE_STRING  ObjectName;
    BOOLEAN         FreeObjectName = FALSE;
    BOOLEAN         ImpersonatingNullSession = FALSE;

    SAMTRACE("SampValidateDomainControllerCreation");

    //
    // Get this object itself SID
    // (except for the Server Object, because server object does not have SID)
    //
    if (SampServerObjectType != Context->ObjectType)
    {
        PrincipleSelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

        if (NULL == PrincipleSelfSid)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Get this object's Object Name
    //
    RtlZeroMemory(&ObjectName, sizeof(UNICODE_STRING));

    if (Context->ObjectNameInDs->NameLen > 0)
    {
        ObjectName.Length = ObjectName.MaximumLength =
                        (USHORT) Context->ObjectNameInDs->NameLen * sizeof(WCHAR);
        ObjectName.Buffer = Context->ObjectNameInDs->StringName;
    }
    else if (SampServerObjectType != Context->ObjectType)
    {
        //
        // If the name is not there at least the SID must be there
        //
        ASSERT(Context->ObjectNameInDs->SidLen > 0);

        NtStatus = RtlConvertSidToUnicodeString(&ObjectName, (PSID)&(Context->ObjectNameInDs->Sid), TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
        FreeObjectName = TRUE;
    }


    //
    // Get the domain
    //

    Domain = &SampDefinedDomains[ Context->DomainIndex ];

    DomainContext = Domain->Context;

    //
    // It should not be the Builtin Domain
    //

    ASSERT(!Domain->IsBuiltinDomain && "Shouldn't Be Builtin Domain");

    //
    // It should not be in registry mode
    //
    ASSERT(IsDsObject(DomainContext));

    //
    // Get the Domain's Security Descriptor
    //

    NtStatus = SampGetDomainObjectSDFromDsName(
                            DomainContext->ObjectNameInDs,
                            &cbSD,
                            &pSD
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Get the Class GUID
    //

    NtStatus = SampGetClassAttribute(
                                DomainContext->DsClassId,
                                ATT_SCHEMA_ID_GUID,
                                &ClassGuidLength,
                                &ClassGuid
                                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ASSERT(ClassGuidLength == sizeof(GUID));

    //
    // Setup Object List
    //

    ObjList[0].Level = ACCESS_OBJECT_GUID;
    ObjList[0].Sbz = 0;
    ObjList[0].ObjectType = &ClassGuid;
    //
    // Every control access guid is considered to be in it's own property
    // set. To achieve this, we treat control access guids as property set
    // guids.
    //
    ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjList[1].Sbz = 0;
    ObjList[1].ObjectType = (GUID *)&GUID_CONTROL_DsInstallReplica;


    //
    // Assume full access
    //

    Results[0] = 0;
    Results[1] = 0;

    //
    // Impersonate the client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Allow a chance to break before the access check
    //

    IF_SAMP_GLOBAL(BREAK_ON_CHECK)
        DebugBreak();


    //
    // Set the desired access
    //

    DesiredAccess = RIGHT_DS_CONTROL_ACCESS;

    //
    // Map the desired access to contain no
    // generic accesses.
    //

    MapGenericMask(&DesiredAccess, &GenericMapping);


    NtStatus = NtAccessCheckByTypeResultListAndAuditAlarm(
                                &SampSamSubsystem,          // SubSystemName
                                (PVOID) Context,            // HandleId or NULL
                                &SampObjectInformation[ Context->ObjectType ].ObjectTypeName, // ObjectTypyName
                                &ObjectName,                // ObjectName
                                pSD,                        // Domain NC head's SD
                                PrincipleSelfSid,           // This machine account's SID
                                DesiredAccess,              // Desired Access
                                AuditEventDirectoryServiceAccess,   // Audit Type
                                0,                          // Flags
                                ObjList,                    // Object Type List
                                2,                          // Object Typy List Length
                                &GenericMapping,            // Generic Mapping
                                FALSE,                      // Object Creation
                                GrantedAccess,              // Granted Status
                                Results,                    // Access Status
                                &bTemp);                    // Generate On Close

    //
    // Stop impersonating the client
    //

    SampRevertToSelf(ImpersonatingNullSession);

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Ok, we checked access, Now, access is granted if either
        // we were granted access on the entire object (i.e. Results[0]
        // is NULL ) or we were granted explicit rights on the access
        // guid (i.e. Results[1] is NULL).
        //

        if ( Results[0] && Results[1] )
        {
            NtStatus = STATUS_ACCESS_DENIED;
        }
    }


Error:

    if (NULL != pSD)
    {
        MIDL_user_free(pSD);
    }

    if (FreeObjectName)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, ObjectName.Buffer);
    }

    return NtStatus;

}




NTSTATUS
SampIsPwdSettingAttemptGranted(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN ULONG UserAccountControl,
    IN GUID *ControlAccessRightToCheck,
    OUT BOOLEAN *fGranted
    )
/**

Routine Description:

    This routine simply check whether the desired ControlAccessRight is granted
    or not by callying SampValidatePwdSettingAttempt() - the worker
    routine.
    
    fGranted -> TRUE:  if SampValidatePwdSettingAttempt() returns SUCCESS    

    fGranted -> FALSE: if SampValidatePwdSettingAttempt() returns ACCESS_DENIED

    fGranted -> NotSet: if SampValidatePwdSettingAttempt() returns other error

Parameters:
    
    Context - User or Domain Context. Used to find out whether
              this is trusted client    

    ClientToken - Client Token for access ck (if passed in)

    UserAccountControl - check whether it is a machine account or not

    ControlAccessRightToCheck - specify the GUID of the DS ControlAccessRight 
                                to check

    fGranted - out parameter                                

Return Values:

    NTSTATUS Code:
        STATUS_SUCCESS
        other error

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    //
    // init return value
    // 

    *fGranted = FALSE;


    //
    // call the worker routine
    // 

    NtStatus = SampValidatePwdSettingAttempt(
                        Context, 
                        ClientToken, 
                        UserAccountControl,
                        ControlAccessRightToCheck
                        );

    if (STATUS_SUCCESS == NtStatus)
    {
        // 
        // the desired ControlAccessRight is granted
        //

        *fGranted = TRUE;
    }
    else if (STATUS_ACCESS_DENIED == NtStatus)
    {
        // 
        // the desired ControlAccessRight is NOT granted
        //

        NtStatus = STATUS_SUCCESS;
        *fGranted = FALSE;
    }


    return( NtStatus );
}


NTSTATUS
SampValidatePwdSettingAttempt(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN ULONG UserAccountControl,
    IN GUID *ControlAccessRightToCheck
    )
/*++
Routine Description:

    this routine is a wrapper of the worker routine - SampDsControlAccessRightCheck(). 
    
    it checks the UserAccountControl of the target account, then decide whether
    the desired DsControlAccessRight should be checked or not. 
    
    Machine accounts are not subject to UnexpirePwd and PwdNotRequiredBit change 
    access checks.  

Parameters: 

    Context - User or Domain Context. Used to find out whether
              this is trusted client    

    ClientToken - Client Token for access ck (if passed in)

    UserAccountControl - target account user account control

    ControlAccessRightToCheck - specify the GUID of the DS ControlAccessRight 
                                to check

Return Values:

    NtStatus Code
--*/
{

    //
    // ControlAccessRight is always granted to 
    // 
    // 1. Trusted Client
    // 2. Registry Mode client (because ControlAccessRight is only for DS mode)
    // 

    if ( Context->TrustedClient || !IsDsObject(Context) ) 
    {
        return( STATUS_SUCCESS );
    }

    //
    // ControlAccessRight UpdatePasswordNotRequiredBit and UnexpirePassword  
    // are always granted if the target object is a machine
    // 

    if ((USER_MACHINE_ACCOUNT_MASK & UserAccountControl) &&
        (IsEqualGUID(ControlAccessRightToCheck, &GUID_CONTROL_UpdatePasswordNotRequiredBit) ||
         IsEqualGUID(ControlAccessRightToCheck, &GUID_CONTROL_UnexpirePassword))
        )
    {
        return( STATUS_SUCCESS );
    }


    return( SampDsControlAccessRightCheck(Context,
                                          ClientToken,
                                          ControlAccessRightToCheck)
            );

}





NTSTATUS
SampDsControlAccessRightCheck(
    IN PSAMP_OBJECT Context,
    IN HANDLE ClientToken OPTIONAL,
    IN GUID *ControlAccessRightToCheck
    )
/*++
Routine Description:

    This routine checks whether the passed in controlAccessRight
    has been granted to the current client or not. The access check 
    is conducted against the domain NC head.

    We will first get Domain NC head (domain object)'s nTSecurityDescriptor 
    from SAM well known object SD-Cache, then call NtAccessCheck API
    to verify whether the passed in ControlAccessRight is granted or not.    
    if not, return access denied error.

    Routine always returns SUCCESS for 

        1. trusted client 
        2. registry mode


Parameters:

    Context - User or Domain Context. Used to find out whether
              this is trusted client    

    ClientToken - Client Token for access ck (if passed in)

    ControlAccessRightToCheck - specify the GUID of the DS ControlAccessRight 
                                to check

Return Values:

    NTSTATUS Code:
        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        other error

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    PSAMP_OBJECT            DomainContext = NULL;
    OBJECT_TYPE_LIST        ObjList[2];
    DWORD                   Results[2];
    DWORD                   GrantedAccess[2];
    GENERIC_MAPPING         GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK             DesiredAccess;
    ULONG                   ClassGuidLength = sizeof(GUID);
    GUID                    ClassGuid;
    ULONG                   cbSD = 0;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    UNICODE_STRING          ObjectName;
    BOOLEAN                 bTemp = FALSE;
    BOOLEAN                 ImpersonatingNullSession = FALSE;


    SAMTRACE("SampDsControlAccessRightCheck");




    //
    // ControlAccessRight is always granted to 
    // 
    // 1. Trusted Client
    // 2. Registry Mode client (because ControlAccessRight is only for DS mode)
    // 

    if ( Context->TrustedClient || !IsDsObject(Context) ) 
    {
        return( STATUS_SUCCESS );
    }


    //
    // Get account domain context
    //

    Domain = &SampDefinedDomains[ DOMAIN_START_DS + 1 ];
    DomainContext = Domain->Context;



    //
    // Get account domain Object Name
    //

    RtlZeroMemory(&ObjectName, sizeof(UNICODE_STRING));
    ObjectName.Length = (USHORT) DomainContext->ObjectNameInDs->NameLen * sizeof(WCHAR);
    ObjectName.MaximumLength = ObjectName.Length;
    ObjectName.Buffer = DomainContext->ObjectNameInDs->StringName;



    //
    // Get Account Domain Object Security Descriptor (remember to free)
    //

    NtStatus = SampGetObjectSD(
                        DomainContext,
                        &cbSD,
                        &pSD
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // SampGetClassAttribute requires a thread state. 
    //

    NtStatus = SampDoImplicitTransactionStart(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the Class GUID
    //

    NtStatus = SampGetClassAttribute(
                                DomainContext->DsClassId,
                                ATT_SCHEMA_ID_GUID,
                                &ClassGuidLength,
                                &ClassGuid
                                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ASSERT(ClassGuidLength == sizeof(GUID));


    //
    // Setup Object List - the first should be the object Class GUID
    //                     and the level should always be 0 
    //

    ObjList[0].Level = ACCESS_OBJECT_GUID;
    ObjList[0].Sbz = 0;
    ObjList[0].ObjectType = &ClassGuid;



    //
    // Every control access guid is considered to be in it's own property
    // set. To achieve this, we treat control access guids as property set
    // guids.
    //

    ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjList[1].Sbz = 0;
    ObjList[1].ObjectType = ControlAccessRightToCheck;



    //
    // Assume full access
    //

    Results[0] = 0;
    Results[1] = 0;


    //
    // Set the desired access
    //

    DesiredAccess = RIGHT_DS_CONTROL_ACCESS;

    //
    // Map the desired access to contain no
    // generic accesses.
    //

    MapGenericMask(&DesiredAccess, &GenericMapping);



    //
    // Allow a chance to break before the access check
    //

    IF_SAMP_GLOBAL(BREAK_ON_CHECK)
        DebugBreak();


    //
    // Call the access check routine
    //

    if (ARGUMENT_PRESENT(ClientToken))
    {
        CHAR                  PrivilegeSetBuffer[256];
        PRIVILEGE_SET         *PrivilegeSet = (PRIVILEGE_SET *)PrivilegeSetBuffer;
        ULONG                 PrivilegeSetLength = sizeof(PrivilegeSetBuffer);

        RtlZeroMemory(PrivilegeSet,PrivilegeSetLength);

        NtStatus = NtAccessCheckByTypeResultList(
                                pSD,            // Domain NC head SD
                                NULL,           // PrincipleSelfSid
                                ClientToken,    // ClientToken
                                DesiredAccess,  // DesiredAccess
                                ObjList,        // Object Type List
                                2,              // Object Type List Length
                                &GenericMapping,// Generic Mapping
                                PrivilegeSet,   // PrivilegeSet
                                &PrivilegeSetLength,    // PrivilegeSet Length
                                GrantedAccess,  // Granted Access
                                Results         // Access Status
                                );
    }
    else
    {
        //
        // Impersonate the client  (Client Token is not passed in)
        //

        NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        NtStatus = NtAccessCheckByTypeResultListAndAuditAlarm(
                                &SampSamSubsystem,          // SubSystemName
                                (PVOID) DomainContext,      // HandleId or NULL
                                &SampObjectInformation[ SampDomainObjectType ].ObjectTypeName, // ObjectTypyName
                                &ObjectName,                // ObjectName
                                pSD,                        // Domain NC head's SD
                                NULL,                       // PrincipleSelfSid
                                DesiredAccess,              // Desired Access
                                AuditEventDirectoryServiceAccess,   // Audit Type
                                0,                          // Flags
                                ObjList,                    // Object Type List
                                2,                          // Object Typy List Length
                                &GenericMapping,            // Generic Mapping
                                FALSE,                      // Object Creation
                                GrantedAccess,              // Granted Status
                                Results,                    // Access Status
                                &bTemp);                    // Generate On Close


        //
        // Stop impersonating the client
        //

        SampRevertToSelf(ImpersonatingNullSession);
    }




    if (NT_SUCCESS(NtStatus))
    {
        //
        // Ok, we checked access, Now, access is granted if either
        // we were granted access on the entire object (i.e. Results[0]
        // is NULL ) or we were granted explicit rights on the access
        // guid (i.e. Results[1] is NULL).
        //

        if ( Results[0] && Results[1] )
        {
            NtStatus = STATUS_ACCESS_DENIED;
        }
    }


Error:

    if (NULL != pSD)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pSD);
    }


    return( NtStatus );
}




NTSTATUS
SampValidateObjectAccess(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK  DesiredAccess,
    IN BOOLEAN      ObjectCreation
    )
{
    return(SampValidateObjectAccess2(
                Context,
                DesiredAccess,
                NULL,
                ObjectCreation,
                FALSE,
                FALSE
                ));
}

NTSTATUS
SampValidateObjectAccess2(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE      ClientToken,
    IN BOOLEAN     ObjectCreation,
    IN BOOLEAN     ChangePassword,
    IN BOOLEAN     SetPassword
    )

/*++

Routine Description:

    This service performs access validation on the specified object.
    The security descriptor of the object is expected to be in a sub-key
    of the ObjectRootKey named "SecurityDescriptor".


    This service:

        1) Retrieves the target object's SecurityDescriptor from the
           the ObjectRootKey or from the DS in DS mode.

        2) Impersonates the client.  If this fails, and we have a
            null session token to use, imperonate that.

        3) Uses NtAccessCheckAndAuditAlarm() to validate access to the
           object, In DS mode it uses   SampDoNt5SdBasedAccessCheck which does the
           mapping from downlevel to NT5 rights before the access check.

        4) Stops impersonating the client.

    Upon successful completion, the passed context's GrantedAccess mask
    and AuditOnClose fields will be properly set to represent the results
    of the access validation.  If the AuditOnClose field is set to TRUE,
    then the caller is responsible for calling SampAuditOnClose() when
    the object is closed.


     This function also has a different behaviour for loopback clients. For loopback
     clients the access mask that is specifies is the one on which we do the access check.
     After we successfully access check for those rights we grant all the remaining rights.
     This is because the access mask specifies those rights which the DS did not know how
     to access ck for  ( like control access right on change password ) and the DS has already
     access checked for all the remainder rights that are really required.



Arguments:

    Context - The handle value that will be assigned if the access validation
        is successful.

    DesiredAccess - Specifies the accesses being requested to the target
        object. In the loopback case ( context is marked as a loopback client ) specifies
        the access that we need to check above what the DS has checked . Typically used to
        check accesses such as change password that the DS does not know how to check for.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.


    ChangePasswordOperation


    SetPasswordOperation



Return Value:

    STATUS_SUCCESS - Indicates access has been granted.

    Other values that may be returned are those returned by:

            NtAccessCheckAndAuditAlarm()




--*/
{

    NTSTATUS NtStatus=STATUS_SUCCESS,
             IgnoreStatus=STATUS_SUCCESS,
             AccessStatus=STATUS_SUCCESS;
    ULONG SecurityDescriptorLength;
    PSECURITY_DESCRIPTOR SecurityDescriptor =NULL;
    ACCESS_MASK MappedDesiredAccess;
    BOOLEAN TrustedClient;
    BOOLEAN LoopbackClient;
    SAMP_OBJECT_TYPE ObjectType;
    PUNICODE_STRING ObjectName = NULL;
    ULONG DomainIndex;
    ULONG AllAccess = 0;
    BOOLEAN fNoAccessRequested = FALSE;
    ULONG   AccessToRestrictAnonymous = 0;
    HANDLE UserToken = INVALID_HANDLE_VALUE;
    PSID    SelfSid = NULL;
    ULONG   LocalGrantedAccess = 0;

    SAMTRACE("SampValidateObjectAccess");

    //
    // Extract various fields from the account context
    //

    TrustedClient = Context->TrustedClient;
    LoopbackClient= Context->LoopbackClient;
    ObjectType    = Context->ObjectType;
    DomainIndex   = Context->DomainIndex;

    //
    // Map the desired access
    //

    MappedDesiredAccess = DesiredAccess;
    RtlMapGenericMask(
        &MappedDesiredAccess,
        &SampObjectInformation[ ObjectType ].GenericMapping
        );

    //
    // Calculate the string to use as an object name for auditing
    //

    NtStatus = STATUS_SUCCESS;

    switch (ObjectType) {

    case SampServerObjectType:
        ObjectName = &SampServerObjectName;
        AllAccess  = SAM_SERVER_ALL_ACCESS;
        AccessToRestrictAnonymous = 0;
        break;

    case SampDomainObjectType:
        ObjectName = &SampDefinedDomains[DomainIndex].ExternalName;
        AllAccess  = DOMAIN_ALL_ACCESS;
        AccessToRestrictAnonymous = DOMAIN_LIST_ACCOUNTS | DOMAIN_READ_PASSWORD_PARAMETERS;
        break;

    case SampUserObjectType:
        ObjectName = &Context->RootName;
        AllAccess = USER_ALL_ACCESS;
        AccessToRestrictAnonymous = USER_LIST_GROUPS;
        break;

    case SampGroupObjectType:
        ObjectName = &Context->RootName;
        AllAccess = GROUP_ALL_ACCESS;
        AccessToRestrictAnonymous = GROUP_LIST_MEMBERS;
        break;

    case SampAliasObjectType:
        ObjectName = &Context->RootName;
        AllAccess = ALIAS_ALL_ACCESS;
        AccessToRestrictAnonymous = ALIAS_LIST_MEMBERS;
        break;

    default:
        ASSERT(FALSE && "Invalid Object Type");
        break;
    }


    ASSERT(AllAccess && "AllAccess not initialized\n");

    if (TrustedClient) {
        Context->GrantedAccess = LoopbackClient?AllAccess:MappedDesiredAccess;
        Context->AuditOnClose  = FALSE;
        return(STATUS_SUCCESS);
    }

    if (LoopbackClient) {

        //
        // A loopback client means Ntdsa calling back into SAM.
        // The only case an access ck needs to be perfomed by
        // SAM is if it is a change password or a set password
        // operation. In all other cases, ntdsa has already peformed
        // an access ck -- the values are being looped through SAM only
        // other types of validation -- like account name uniqueness
        //

        if ((!ChangePassword) && (!SetPassword))
        {
            Context->GrantedAccess = AllAccess;
            Context->AuditOnClose = FALSE;
            return(STATUS_SUCCESS);
        }
    }

    //
    // Fetch the security descriptor
    //

    NtStatus = SampGetObjectSD(
                    Context,
                    &SecurityDescriptorLength, 
                    &SecurityDescriptor
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    //
    // Password change case is special. If it is a change password operation,
    // then we need to validate Access to change password on the user object.
    // We special case change password to appear as an authentication protocol
    // -- this is done in general by performing the access ck using a Token
    // that only contains the SELF and EVERYONE SIDs.There are special caveats
    // involving use of ForceGuest and LimitBlankPasswordAccess settings which
    // alter the composition of the token.
    //

    if (ChangePassword)
    {
        
         ASSERT(DesiredAccess == USER_CHANGE_PASSWORD);
         ASSERT(SampUserObjectType == ObjectType);

         NtStatus  = SampCreateUserToken(Context,ClientToken,&UserToken);
         if (!NT_SUCCESS(NtStatus))
         {
             goto Error;
         }
    }
    else if (SampUserObjectType == ObjectType)
    {
        //
        // Do not access check for change password
        // on user objects, unless the change password
        // boolean is set. This is because various scenarios
        // need the access ck to be delayed till the time
        // of the actual change password and not perform
        // this opeation at handle open time.
        // We'll know to access ck if requested.
        //

        DesiredAccess &= ~(USER_CHANGE_PASSWORD);
        MappedDesiredAccess &= ~(USER_CHANGE_PASSWORD);
    }

    //
    // If the desired access field is 0 and the handle is being opened by SAM
    // itself, then allow the handle open. It could be that the real caller did not
    // have any access and therefore the access ck below could fail. The 0 desired 
    // access trick is used in internal handle opens, to delay the access ck to 
    // the time when the operations is being performed to when the handle is being
    // opened.
    //

    if ((Context->OpenedBySystem) && (0==DesiredAccess))
    {
        Context->GrantedAccess = 0;
        Context->AuditOnClose  = FALSE;
        NtStatus = STATUS_SUCCESS;
        AccessStatus = STATUS_SUCCESS;
        goto Error;
    }

    //
    // Perform the access check. Note we do different things for DS mode and
    // Registry mode
    //

    if (IsDsObject(Context))
    {
        
        //
        // Call the DS mode access check routine.
        // The DS mode access check routine is different from a simple access
        // check. The reason for this is that in SAM the access rights are 
        // defined based on attribute groups as defined in ntsam.h. The security
        // descriptor however is retrieved from the DS, and the acls have
        // their access masks set in terms of DS access mask constants. Therefore
        // a corresponding mapping needs to be performed during the time of the
        // access check.
        //
     
        NtStatus =  SampDoNt5SdBasedAccessCheck(
                        Context,
                        SecurityDescriptor,
                        NULL,
                        ObjectType,
                        DesiredAccess,
                        ObjectCreation,
                        &SampObjectInformation[ ObjectType ].GenericMapping,
                        (UserToken!=INVALID_HANDLE_VALUE)?
                                UserToken:ClientToken,
                        &Context->GrantedAccess,
                        &Context->WriteGrantedAccessAttributes,
                        &AccessStatus    
                        );
         
    }
    else
    {    
        
        //
        // If  we are restricting null
        // session access, remove the anonymous domain list account
        // access.
        //

        if (SampRestrictNullSessions ) {

            NtStatus = SampRemoveAnonymousAccess(
                                    &SecurityDescriptor,
                                    &SecurityDescriptorLength,
                                    AccessToRestrictAnonymous,
                                    ObjectType
                                    );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

     
        if (UserToken!=INVALID_HANDLE_VALUE)
        {
            CHAR    PrivilegeSetBuffer[256];
            PRIVILEGE_SET  *PrivilegeSet = (PRIVILEGE_SET *)PrivilegeSetBuffer;
            ULONG          PrivilegeSetLength = sizeof(PrivilegeSetBuffer);

            //
            // Access validate the client
            //
             
            NtStatus = NtAccessCheck (
                            SecurityDescriptor,
                            UserToken,
                            MappedDesiredAccess,
                            &SampObjectInformation[ObjectType].GenericMapping,
                            PrivilegeSet,
                            &PrivilegeSetLength,
                            &Context->GrantedAccess,
                            &AccessStatus
                            );
        }
        else
        {
            
               

            BOOLEAN ImpersonatingNullSession = FALSE;

            //
            // Impersonate the client.  If RPC impersonation fails because
            // it is not supported (came in unauthenticated), then impersonate
            // the null session.
            //

            NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
            
      
            if (NT_SUCCESS(NtStatus)) {

                //
                // Because of bug 411289, the NtAccessCheck* API's don't return
                // ACCESS_DENIED when presented with 0 access.  Because clients
                // may already expect this behavoir, only return ACCESS_DENIED
                // when the client really doesn't have any access. We want to
                // return ACCESS_DENIED to prevent anonymous clients from acquiring
                // handles.
                //
                if ( MappedDesiredAccess == 0 ) {
                    fNoAccessRequested = TRUE;
                    MappedDesiredAccess = MAXIMUM_ALLOWED;
                }

                NtStatus = NtAccessCheckAndAuditAlarm(
                               &SampSamSubsystem,
                               (PVOID)Context,
                               &SampObjectInformation[ ObjectType ].ObjectTypeName,
                               ObjectName,
                               SecurityDescriptor,
                               MappedDesiredAccess,
                               &SampObjectInformation[ ObjectType ].GenericMapping,
                               ObjectCreation,
                               &Context->GrantedAccess,
                               &AccessStatus,
                               &Context->AuditOnClose
                               );

                if ( fNoAccessRequested ) {

                    MappedDesiredAccess = 0;

                    if ( NT_SUCCESS( NtStatus )
                     &&  NT_SUCCESS( AccessStatus ) ) {

                        Context->GrantedAccess = 0;
                    }
                }

                //
                // Stop impersonating the client
                //

                SampRevertToSelf(ImpersonatingNullSession);

            }
        }
    }
        
  
Error:

    //
    // Free up the security descriptor
    //

    if (NULL!=SecurityDescriptor) {

        MIDL_user_free( SecurityDescriptor );

    }

    if (UserToken!=INVALID_HANDLE_VALUE)
    {
        NtClose(UserToken);
    }
    

    //
    // If we got an error back from the access check, return that as
    // status.  Otherwise, return the access check status.
    //

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

  
    return(AccessStatus);
}


NTSTATUS
SampRemoveAnonymousAccess(
    IN OUT PSECURITY_DESCRIPTOR *    Sd,
    IN OUT PULONG                    SdLength,
    IN ULONG                         AccessToRemove,
    IN SAMP_OBJECT_TYPE              ObjectType
    )

/*++

Routine Description:

    This routine removes removes the DOMAIN_LIST_ACCOUNTS bit from the
    World ACE and adds an ace granting it to AUTHENTICATED USERS.

Parameters:

    Sd - Is a pointer to a pointer to asecurity descriptor of a SAM DOMAIN
         object. If the SD needs to be changed a new one will be allocated
         and this one freed.

    SdLength - Length of the security descriptor, which will be modified
        if a new SD is allocated.

Returns:

    None.

--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS,
        Status = STATUS_SUCCESS;
    PACL
        Dacl;

    ULONG
        i,
        AceCount;

    PACE_HEADER
        Ace;

    ACCESS_MASK GrantedAccess = 0;

    BOOLEAN
        DaclPresent = FALSE,
        DaclDefaulted = FALSE;


    NtStatus = RtlGetDaclSecurityDescriptor( *Sd,
                                             &DaclPresent,
                                             &Dacl,
                                             &DaclDefaulted
                                            );

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    if ( !DaclPresent || (Dacl == NULL)) {
        return(STATUS_SUCCESS);
    }

    if ((AceCount = Dacl->AceCount) == 0) {
        return(STATUS_SUCCESS);
    }

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if ( (RtlEqualSid( SampWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart )) ||
                     (RtlEqualSid( SampAnonymousSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ))) {

                    //
                    // Turn off the access to remove
                    //

                    GrantedAccess |= (((PACCESS_ALLOWED_ACE)Ace)->Mask) & (AccessToRemove);
                    ((PACCESS_ALLOWED_ACE)Ace)->Mask &= ~(AccessToRemove);
                }
            }
        }
    }

    //
    // If AccessToRemove was granted everyone, add an ACE for
    // AUTHENTICATED USER granting it AccessToRemove
    //

    if (GrantedAccess != 0 ) {
        PSECURITY_DESCRIPTOR SdCopy = NULL;
        PSECURITY_DESCRIPTOR NewSd = NULL;
        PACL NewDacl = NULL;
        ULONG NewDaclSize;
        ULONG TempSize;
        SECURITY_DESCRIPTOR TempSd;

        //
        // Copy the SD to absolute so we can modify it.
        //

        Status = RtlCopySecurityDescriptor(
                    *Sd,
                    &SdCopy
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Now get the create a new dacl
        //

        NewDaclSize = Dacl->AclSize +
                        sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                        RtlLengthSid(SampAuthenticatedUsersSid);

        NewDacl = MIDL_user_allocate(NewDaclSize);

        if (NewDacl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = RtlCreateAcl( NewDacl, NewDaclSize, ACL_REVISION2);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Add the ACEs from the old DACL into this DACL.
        //

        Status = RtlAddAce(
                    NewDacl,
                    ACL_REVISION2,
                    0,
                    FirstAce(Dacl),
                    Dacl->AclSize - sizeof(ACL)
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Add the new ace
        //

        Status = RtlAddAccessAllowedAce(
                    NewDacl,
                    ACL_REVISION2,
                    GrantedAccess,
                    SampAuthenticatedUsersSid
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Build a dummy SD to pass to RtlSetSecurityObject that contains
        // the new DACL.
        //

        Status = RtlCreateSecurityDescriptor(
                    &TempSd,
                    SECURITY_DESCRIPTOR_REVISION1
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = RtlSetDaclSecurityDescriptor(
                    &TempSd,
                    TRUE,               // DACL present,
                    NewDacl,
                    FALSE               // not defaulted
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Now merge the existing SD with the new security descriptor
        //

        Status = RtlSetSecurityObject(
                    DACL_SECURITY_INFORMATION,
                    &TempSd,
                    &SdCopy,
                    &SampObjectInformation[ObjectType].GenericMapping,
                    NULL                // no token
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Now copy the SD, which into one allocated with MIDL_user_allocate
        //


        TempSize = RtlLengthSecurityDescriptor( SdCopy );
        NewSd = MIDL_user_allocate(TempSize);
        if (NewSd == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            NewSd,
            SdCopy,
            TempSize
            );

        MIDL_user_free(*Sd);
        *Sd = NewSd;
        *SdLength = TempSize;
        NewSd = NULL;

Cleanup:
        if (SdCopy != NULL) {
            RtlFreeHeap(RtlProcessHeap(),0, SdCopy );
        }
        if (NewDacl != NULL) {
            MIDL_user_free(NewDacl);
        }
        if (NewSd != NULL) {
            MIDL_user_free(NewSd);
        }
    }

    return Status;
}

TOKEN_SOURCE SourceContext;


NTSTATUS
SampCreateNullToken(
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    LARGE_INTEGER ExpirationTime;
    LUID LogonId = SYSTEM_LUID;

    SAMTRACE("SampCreateNullToken");



    UserId.User.Sid = SampAnonymousSid;
    UserId.User.Attributes = 0;
    GroupIds.GroupCount = 0;
    Privileges.PrivilegeCount = 0;
    PrimaryGroup.PrimaryGroup = SampAnonymousSid;
    ExpirationTime.LowPart = 0xfffffff;
    ExpirationTime.LowPart = 0x7ffffff;


    //
    // Build a token source for SAM.
    //

    Status = NtAllocateLocallyUniqueId( &SourceContext.SourceIdentifier );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    strncpy(SourceContext.SourceName,"SamSS   ",sizeof(SourceContext.SourceName));


    //
    // Set the object attributes to specify an Impersonation impersonation
    // level.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
    ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ImpersonationQos.EffectiveOnly = TRUE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status = NtCreateToken(
                 &SampNullSessionToken,    // Handle
                 (TOKEN_ALL_ACCESS),       // DesiredAccess
                 &ObjectAttributes,        // ObjectAttributes
                 TokenImpersonation,       // TokenType
                 &LogonId,                  // Authentication LUID
                 &ExpirationTime,          // Expiration Time
                 &UserId,                  // User ID
                 &GroupIds,                // Group IDs
                 &Privileges,              // Privileges
                 NULL,                     // Owner
                 &PrimaryGroup,            // Primary Group
                 NULL,                     // Default Dacl
                 &SourceContext            // TokenSource
                 );

    return Status;

}


NTSTATUS
SampCreateUserToken(
    IN PSAMP_OBJECT UserContext,
    IN  HANDLE      PassedInToken,
    OUT HANDLE      *UserToken
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    LARGE_INTEGER ExpirationTime;
    LUID LogonId = SYSTEM_LUID;
    PSID UserSid = NULL;
    BOOLEAN EnableLimitBlankPasswordUse = FALSE;

    SAMTRACE("SampCreateUserToken");


    //
    // Test  for LimitBlankPasswordUse
    //

    if ((SampLimitBlankPasswordUse) && (!SampUseDsData))
    {
        BOOL Administrator = FALSE;
        NT_OWF_PASSWORD  NtOwfPassword;
        LM_OWF_PASSWORD  LmOwfPassword;
        BOOLEAN          LmPasswordNonNull = FALSE,
                         NtPasswordNonNull = FALSE,
                         NtPasswordPresent = FALSE,
                         PasswordPresent   = TRUE;
                         
        //
        // Get the caller
        //

        Status = SampGetCurrentClientSid(PassedInToken, &UserSid, &Administrator);
        if (!NT_SUCCESS(Status)) {

            goto Error;
        }

        //
        // Check if current password is blank
        //

        Status = SampRetrieveUserPasswords(
                        UserContext,
                        &LmOwfPassword,
                        &LmPasswordNonNull,
                        &NtOwfPassword,
                        &NtPasswordPresent,
                        &NtPasswordNonNull
                        );

        if (!NT_SUCCESS(Status)) {
         
            goto Error;
        }

       
        PasswordPresent = (( NtPasswordPresent && NtPasswordNonNull)
                             || ( LmPasswordNonNull));

        if ((Administrator )
            ||(RtlEqualSid(UserSid,SampLocalSystemSid))
            ||(PasswordPresent)) {
            
            // 
            // In these cases limit blank password use does not apply
            // Don't restrict an admin or local system, or if a password
            // is present on an account
            //

            MIDL_user_free(UserSid);
            UserSid = NULL;
        }
        else {

            EnableLimitBlankPasswordUse = TRUE;
        }
    }

    if ((SampIsForceGuestEnabled() || EnableLimitBlankPasswordUse)
            && !SampIsClientLocal())
    {
        //
        // if force guest or is enabled 
        // or LimitBlankPasswordUse is enabled and client is not local
        // then build a token with only the anonymous SID in 
        // it
        //
        
        UserId.User.Sid = SampAnonymousSid;
        UserId.User.Attributes = 0;
        GroupIds.GroupCount = 1;
        GroupIds.Groups[0].Sid = SampNetworkSid;
        GroupIds.Groups[0].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = SampNetworkSid;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }
    else if (EnableLimitBlankPasswordUse)
    {
        UserId.User.Sid = UserSid;
        UserId.User.Attributes = 0;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = UserSid;
        GroupIds.GroupCount = 0;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }
    else
    {

        //
        // Get the user Sid
        //

        Status = SampCreateFullSid(
                    SampDefinedDomains[UserContext->DomainIndex].Sid,
                    UserContext->TypeBody.User.Rid,
                    &UserSid
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        UserId.User.Sid = UserSid;
        UserId.User.Attributes = 0;
        GroupIds.GroupCount = 1;
        GroupIds.Groups[0].Sid = SampWorldSid;
        GroupIds.Groups[0].Attributes = SE_GROUP_MANDATORY| SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = SampWorldSid;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }


    //
    // Build a token source for SAM.
    //

    //
    // Set the object attributes to specify an Impersonation impersonation
    // level.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
    ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ImpersonationQos.EffectiveOnly = TRUE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status = NtCreateToken(
                 UserToken,                // Handle
                 (TOKEN_ALL_ACCESS),       // DesiredAccess
                 &ObjectAttributes,        // ObjectAttributes
                 TokenImpersonation,       // TokenType
                 &LogonId,                  // Authentication LUID
                 &ExpirationTime,          // Expiration Time
                 &UserId,                  // User ID
                 &GroupIds,                // Group IDs
                 &Privileges,              // Privileges
                 NULL,                     // Owner
                 &PrimaryGroup,            // Primary Group
                 NULL,                     // Default Dacl
                 &SourceContext            // TokenSource
                 );

Error:

    if (NULL!=UserSid)
    {
        MIDL_user_free(UserSid);
    }

    return Status;

}

ULONG
SampSecureRpcInit(
    PVOID Ignored
    )
/*++

Routine Description:

    This routine waits for the NTLMSSP service to start and then registers
    security information with RPC to allow authenticated RPC to be used to
    SAM.  It also registers an SPX endpoint if FPNW is installed.

Arguments:

    Ignored - required parameter for starting a thread.

Return Value:

    None.

--*/
{

#define MAX_RPC_RETRIES 30

    ULONG RpcStatus = ERROR_SUCCESS;
    ULONG LogStatus = ERROR_SUCCESS;
    ULONG RpcRetry;
    ULONG RpcSleepTime = 10 * 1000;     // retry every ten seconds
    RPC_BINDING_VECTOR * BindingVector = NULL;
    RPC_POLICY rpcPolicy;
    BOOLEAN AdditionalTransportStarted = FALSE;

    SAMTRACE("SampSecureRpcInit");

    if( !DsaWaitUntilServiceIsRunning( "rpcss" ) ) {

        RpcStatus = GetLastError();        
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Error while waiting for rpc to start: %d\n",
                   RpcStatus));
        goto ErrorReturn;
    }

    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;

    RpcStatus = RpcServerRegisterAuthInfoW(
                    NULL,                   // server principal name
                    RPC_C_AUTHN_WINNT,
                    NULL,                   // no get key function
                    NULL                    // no get key argument
                    );

    if (RpcStatus != 0) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Could not register auth. info: %d\n",
                   RpcStatus));

        goto ErrorReturn;
    }

    //
    // If the Netware server is installed, register the SPX protocol.
    // Since the transport may not be loaded yet, retry a couple of times
    // if we get a CANT_CREATE_ENDPOINT error (meaning the transport isn't
    // there).
    //

    if (SampNetwareServerInstalled) {
        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqExW(
                            L"ncacn_spx",
                            10,
                            NULL,           // no security descriptor
                            &rpcPolicy
                            );

            //
            // If it succeded break out of the loop.
            //
            if (RpcStatus == ERROR_SUCCESS) {
                break;
            }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Could not register SPX endpoint: %d\n",
                       RpcStatus));

            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with TcpIp
    //

    if (SampIpServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqExW(
                            L"ncacn_ip_tcp",
                            10,
                            NULL,           // no security descriptor
                            &rpcPolicy
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Could not register TCP endpoint: %d\n",
                       RpcStatus));
            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with apple talk
    //

    if (SampAppletalkServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqW(
                            L"ncacn_at_dsp",
                            10,
                            NULL            // no security descriptor
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrint(("SAMSS:  Could not register Appletalk endpoint: %d\n", RpcStatus ));
            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with Vines
    //

    if (SampVinesServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqW(
                            L"ncacn_vns_spp",
                            10,
                            NULL            // no security descriptor
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrint(("SAMSS:  Could not register Vines endpoint: %d\n", RpcStatus ));
            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }
    }

    //
    // If we started an additional transport, go on to register the endpoints
    //

    if (AdditionalTransportStarted) {

        RpcStatus = RpcServerInqBindings(&BindingVector);
        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Could not inq bindings: %d\n",
                       RpcStatus));

            goto ErrorReturn;
        }
        RpcStatus = RpcEpRegister(
                        samr_ServerIfHandle,
                        BindingVector,
                        NULL,                   // no uuid vector
                        L""                     // no annotation
                        );
        RpcBindingVectorFree(&BindingVector);
        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Could not register endpoints: %d\n",
                       RpcStatus));

            goto ErrorReturn;
        }

    }

ErrorReturn:

    //
    // RpcStatus's will contain more serious errors
    //
    if ( RpcStatus != ERROR_SUCCESS ) {
        LogStatus = RpcStatus;
    }

    if ( LogStatus != ERROR_SUCCESS ) {

        if (!(SampIsSetupInProgress(NULL)))
        {
            SampWriteEventLog(
                EVENTLOG_ERROR_TYPE,
                0,  // Category
                SAMMSG_RPC_INIT_FAILED,
                NULL, // User Sid
                0, // Num strings
                sizeof(ULONG), // Data size
                NULL, // String array
                (PVOID)&LogStatus // Data
                );
        }
    }
    
    return(RpcStatus);
}


BOOLEAN
SampStartNonNamedPipeTransports(
    )
/*++

Routine Description:

    This routine checks to see if we should listen on a non-named pipe
    transport.  We check the registry for flags indicating that we should
    listen on Tcp/Ip and SPX. There is a flag
    in the registry under system\currentcontrolset\Control\Lsa\
    NetwareClientSupport and TcpipClientSupport indicating whether or not
    to setup the endpoint.


Arguments:


Return Value:

    TRUE - Netware (FPNW or SmallWorld) is installed and the SPX endpoint
        should be started.

    FALSE - Either Netware is not installed, or an error occurred while
        checking for it.
--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG SpxFlag;

    SAMTRACE("SampStartNonNamedPipeTransport");

    SampNetwareServerInstalled = FALSE;

    //
    // Decision of IpServerInstalled to be true was made by a registery value in
    //  system\currentcontrolset\Control\Lsa\TcpipClientSupport. However, to enable
    //  Sam(r)ValidatePassword to work over TCP, this value has to be TRUE by default.
    //
    SampIpServerInstalled = TRUE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(FALSE);
    }

    //
    // Query the NetwareClientSupport value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"NetWareClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );

    SampDumpNtQueryValueKey(&KeyName,
                            KeyValuePartialInformation,
                            KeyValueInformation,
                            KeyValueLength,
                            &ResultLength);


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampNetwareServerInstalled = TRUE;
            }
        }

    }
    
    //
    // Query the AppletalkClientSupport  value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"AppletalkClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampAppletalkServerInstalled = TRUE;
            }
        }

    }

    //
    // Query the VinesClientSupport  value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"VinesClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampVinesServerInstalled = TRUE;
            }
        }

    }


    NtClose(KeyHandle);

    if ( SampNetwareServerInstalled || SampIpServerInstalled
      || SampAppletalkServerInstalled || SampVinesServerInstalled )
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    };
}

VOID
SampCheckNullSessionAccess(
    IN HKEY LsaKey 
    )
/*++

Routine Description:

    This routine checks to see if we should restict null session access.
    in the registry under system\currentcontrolset\Control\Lsa\
    RestrictAnonymous indicating whether or not to restrict access.
    If access is restricted then you need to be an authenticated user to
    get DOMAIN_LIST_ACCOUNTS or GROUP_LIST_MEMBERS or ALIAS_LIST_MEMBERS
    access.

Arguments:

    LsaKey -- an open key to Control\LSA
    
Return Value:

    None - this routines sets the SampRestictNullSessionAccess global.

--*/
{
    DWORD WinError;
    DWORD dwSize, dwValue, dwType;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(LsaKey,
                                "RestrictAnonymous",
                                NULL,
                                &dwType,
                                (LPBYTE)&dwValue,
                                &dwSize);
    
    if ((ERROR_SUCCESS == WinError) && 
        (REG_DWORD == dwType) &&
        (1 <= dwValue)) {
        SampRestrictNullSessions = TRUE;
    } else {
        SampRestrictNullSessions = FALSE;
    }

    if (!SampRestrictNullSessions) {

        //
        // Try again with the SAM specific key.  Note that "RestrictAnonymous"
        // key is global to NT and several different components read it and
        // behave differently.  "RestrictAnonymousSam" controls the SAM
        // behavior only.
        //
        dwSize = sizeof(dwValue);
        WinError = RegQueryValueExA(LsaKey,
                                    "RestrictAnonymousSam",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwValue,
                                    &dwSize);
        
        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 <= dwValue)) {
            SampRestrictNullSessions = TRUE;
        }
    }
}




NTSTATUS
SampDsGetObjectSDAndClassId(
    IN PDSNAME   ObjectDsName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT ULONG    *SecurityDescriptorLength,
    OUT ULONG    *ObjectClass
    )
/*++
Routine Description:

    this routine read security descriptor and object class of the object 
    from DS
    
Parameters:

    ObjectDsName - Object Name in DS
    
    SecurityDescriptor - Security descriptor of the object 
    
    SecurityDescriptorLength - Length of security descriptor
    
    ObjectClass - Object Class of this object    

Return Value:


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0, i;
    READARG     ReadArg;
    READRES     *ReadRes = NULL;
    COMMARG     *CommArg = NULL;
    ENTINFSEL   EntInf;
    ATTR        Attr[2];
    ATTRVAL     *pAVal;


    
    //
    // initialize return values
    // 

    *SecurityDescriptor = NULL;
    *SecurityDescriptorLength = 0;
    *ObjectClass = 0;


    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInf, sizeof(ENTINF));
    RtlZeroMemory(Attr, sizeof(ATTR) * 2);


    Attr[0].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr[1].attrTyp = ATT_OBJECT_CLASS; 


    EntInf.AttrTypBlock.attrCount = 2;
    EntInf.AttrTypBlock.pAttr = Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = ObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError,&ReadRes->CommRes);
    }

    SampClearErrors();

    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(NULL != ReadRes->entry.AttrBlock.pAttr);

        for (i = 0; i < ReadRes->entry.AttrBlock.attrCount; i++)
        {
            pAVal = ReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal; 
            ASSERT((NULL != pAVal[0].pVal) && (0 != pAVal[0].valLen));

            if (ATT_NT_SECURITY_DESCRIPTOR == ReadRes->entry.AttrBlock.pAttr[i].attrTyp)
            {
                *SecurityDescriptor = MIDL_user_allocate(pAVal[0].valLen);
                if (NULL == *SecurityDescriptor)
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                else
                {
                    *SecurityDescriptorLength = pAVal[0].valLen;
                    RtlZeroMemory(*SecurityDescriptor,pAVal[0].valLen);
                    RtlCopyMemory(*SecurityDescriptor,
                                  pAVal[0].pVal,
                                  pAVal[0].valLen
                                  );
                }
            }
            else if (ATT_OBJECT_CLASS == ReadRes->entry.AttrBlock.pAttr[i].attrTyp)
            {
                *ObjectClass = *((UNALIGNED ULONG *) pAVal[0].pVal);
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
                break;
            }
        }
    }


    return( NtStatus );
}


NTSTATUS
SampExtendedEnumerationAccessCheck(
    IN BOOLEAN TrustedClient,
    IN OUT BOOLEAN * pCanEnumEntireDomain
    )
/*++

Routine Description:

    This routine tries to determine whether the caller can enumerate the
    entire domain or not. It is a hotfix for Windows 2000 SP2. 
    
    Enumerate entire domain can be costly, especially for a large domain. 
    
    To put a stop of this enumerate everybody behaviour and do not break
    any down level applications, we introduce an extended access control 
    right, SAM-Enumerate-Entire-Domain, which applies on Server Object ONLY. 
    By using this new access control right, administrators can shut down 
    those downlevel enumeration API's (SamEnum*, SampQueryDisplayInformation) 
    alone to everyone except a subset of people. 

    If a downlevel enumerate call is made, in addition to DS object 
    permissions, the permissions on SAM server object is checked. If the 
    security descriptor on server object does not allow access to execute
    Enumeration API, the client is limited to ONLY one ds paged search.
    For the small subset of people who have been granted this permission, 
    they can enumerate the entire domain in the old fashion.
  

Parameters:

    pCanEnumEntireDomain - pointer to boolean, used to return the result of
                           access check


Return Value:

    STATUS_SUCCESS
        pCanEnumEntireDomain - TRUE    caller has the permission
                             - FALSE   caller doesn't have the permission

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG       SecurityDescriptorLength;
    ULONG       ObjectClass;

    GUID                ClassGuid; 
    ULONG               ClassGuidLength = sizeof(GUID);
    OBJECT_TYPE_LIST    ObjList[2];
    DWORD               Results[2];
    DWORD               GrantedAccess[2];
    GENERIC_MAPPING     GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK         DesiredAccess;
    BOOLEAN             bTemp = FALSE;
    BOOLEAN             ImpersonatingNullSession = FALSE;  
    

    //
    // Should only be called in real DS mode, I mean "real" - after Dcpromo
    // for Trusted Client, always allow them to enumerate all.
    // 
    if (!SampUseDsData || TrustedClient)
    {
        *pCanEnumEntireDomain = TRUE;
        return( STATUS_SUCCESS );
    }


    // 
    // init return value
    // 

    *pCanEnumEntireDomain = TRUE;

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    // 
    // retrieve the special security descriptor and DS class ID 
    // 

    NtStatus = SampDsGetObjectSDAndClassId(
                            SampServerObjectDsName,
                            &SecurityDescriptor,
                            &SecurityDescriptorLength,
                            &ObjectClass
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the Class GUID
    // 
    
    NtStatus = SampGetClassAttribute(
                                ObjectClass, 
                                ATT_SCHEMA_ID_GUID,
                                &ClassGuidLength, 
                                &ClassGuid
                                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    
    ASSERT(ClassGuidLength == sizeof(GUID));


    // 
    // Setup Object List
    // 
    
    ObjList[0].Level = ACCESS_OBJECT_GUID;
    ObjList[0].Sbz = 0;
    ObjList[0].ObjectType = &ClassGuid;    
    //
    // Every control access guid is considered to be in it's own property
    // set. To achieve this, we treat control access guids as property set
    // guids. 
    //
    ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjList[1].Sbz = 0;
    ObjList[1].ObjectType = (GUID *)&GUID_CONTROL_DsSamEnumEntireDomain;

    //
    // Assume full access
    //

    Results[0] = 0;
    Results[0] = 0;

    //
    // Impersonate the client
    // 
    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set the desired access;
    // 

    DesiredAccess = RIGHT_DS_CONTROL_ACCESS;

    //
    // Map the desired access to contain no generic access
    // 
    MapGenericMask(&DesiredAccess, &GenericMapping);

    NtStatus = NtAccessCheckByTypeResultListAndAuditAlarm(
                                &SampSamSubsystem,          // SubSystemName
                                (PVOID) NULL,               // HandleId or NULL
                                &SampObjectInformation[ SampServerObjectType ].ObjectTypeName, // ObjectTypeName
                                &SampServerObjectName,      // ObjectName
                                SecurityDescriptor,         // SD
                                NULL,                       // This machine account's SID
                                DesiredAccess,              // Desired Access 
                                AuditEventDirectoryServiceAccess,   // Audit Type
                                0,                          // Flags
                                ObjList,                    // Object Type List
                                2,                          // Object Typy List Length
                                &GenericMapping,            // Generic Mapping
                                FALSE,                      // Object Creation 
                                GrantedAccess,              // Granted Status
                                Results,                    // Access Status
                                &bTemp);                    // Generate On Close
    
    // 
    // Stop impersonating the client
    // 
    
    SampRevertToSelf(ImpersonatingNullSession);
    
    if (NT_SUCCESS(NtStatus))
    {
        // 
        // Ok, we checked access, Now, access is granted if either 
        // we were granted access on the entire object (i.e. Results[0] 
        // is NULL ) or we were granted explicit rights on the access
        // guid (i.e. Results[1] is NULL). 
        // 
        
        if ( Results[0]  && Results[1] )
        {
            *pCanEnumEntireDomain = FALSE;
        }
    }

Error:

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);

    if (SecurityDescriptor)
    {
        MIDL_user_free(SecurityDescriptor);
    }

    return( NtStatus );
}




VOID
SampRevertToSelf(
    BOOLEAN fImpersonatingAnonymous
    )
/*++

  This function reverts to Self using the correct function based on
  DS mode / registry mode


--*/
{
    if (SampUseDsData)
    {
        UnImpersonateAnyClient();
    }
    else
    {
        if (fImpersonatingAnonymous)
        {
            SamIRevertNullSession();
        }
        else
        {
            RpcRevertToSelf();
        }
    }
}


NTSTATUS
SampImpersonateClient(
    BOOLEAN * fImpersonatingAnonymous
    )
/*++

    This function impersonates a client by calling the appropriate
    routines depending upon DS mode / Registry Mode

--*/
{
    *fImpersonatingAnonymous = FALSE;

    if (SampUseDsData) {

        return (I_RpcMapWin32Status(ImpersonateAnyClient()));
    } else {

        NTSTATUS NtStatus;

        NtStatus = I_RpcMapWin32Status(RpcImpersonateClient( NULL));

        if (NtStatus == RPC_NT_CANNOT_SUPPORT) {
            
            NtStatus = SamIImpersonateNullSession();

            *fImpersonatingAnonymous = TRUE;
        }

        return (NtStatus);
    }
}

BOOLEAN
SampIsForceGuestEnabled()
/*++

    Routine Description

    Checks to see if the force guest setting is enabled.
    Force guest is enabled if the reg key is set or if this
    is the personal edition. Force guest is never enabled
    on DC's

    1. On joined machines (includes DC's), the forceguest regkey is ignored and 
       assumed to be 0 (no dumb down).

    2. On unjoined machines (including servers),  NTLM follows the reg key 
       setting HKLM\System\CurrentControlSet\Control\Lsa\ForceGuest
       - Exception to #2: On PERsonal, which is always unjoined, the reg key is 
         ignored and assumed to be 1 (dumb down).

    

  --*/
{
     OSVERSIONINFOEXW osvi;

    //
    // Force guest is never enabled for DC's ie DS mode
    //

    if (SampUseDsData)
    {
        return(FALSE);
    }
    else
    {
        //
        // Determine if we are running Personal SKU
        // Force Guest is always enabled in personal SKU
        //

        if (SampPersonalSKU)
        {
            return TRUE;
        } 
        else if (SampIsMachineJoinedToDomain)
        {
            //
            // ForceGuest is always disabled if machine is joined to a Domain
            // 
            return( FALSE );
        }
    }

    //
    // if the force guest key is turned on then return the value.
    //

    return(SampForceGuest);
    
}

BOOLEAN
SampIsClientLocal()
/*++

  This routine tests if the client is a local named pipe based caller.

  TRUE is returned if the client is a local named pipe  based caller
  FALSE is returned otherwise.

--*/
{
    NTSTATUS NtStatus;
    ULONG    ClientLocalFlag = FALSE;

    NtStatus = I_RpcMapWin32Status(I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag));
    if ((NT_SUCCESS(NtStatus)) && ( ClientLocalFlag))
    {
        return(TRUE);
    }

    return(FALSE);
}


NTSTATUS
SampGetCurrentClientSid(
    IN  HANDLE   ClientToken OPTIONAL,
    OUT PSID    *ppSid,
    OUT BOOL     *Administrator
    )
/*++
Routine Description:

    This routine gets the current client SID, 

Parameter:

    ppSid - used to return the client SID
    
Return Value:

    NtStatus

    ppSid - caller is responsible to free it

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PTOKEN_USER User = NULL;


    //
    // Initialize return value
    // 

    *ppSid = NULL;

    // 
    // Get Sid
    // 
    NtStatus = SampGetCurrentUser( ClientToken, &User, Administrator );

    if (NT_SUCCESS(NtStatus))
    {
        ULONG   SidLength = RtlLengthSid(User->User.Sid);

        //
        // allocate memory
        // 
        *ppSid = MIDL_user_allocate(SidLength);

        if (NULL == (*ppSid))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            //
            // copy over
            // 
            RtlZeroMemory(*ppSid, SidLength);
            RtlCopyMemory(*ppSid, User->User.Sid, SidLength);
        }
    }


    if (User)
        MIDL_user_free(User);

    return(NtStatus);
}

NTSTATUS
SampGetCurrentOwnerAndPrimaryGroup(
    OUT PTOKEN_OWNER * Owner,
    OUT PTOKEN_PRIMARY_GROUP * PrimaryGroup
    )
/*++

    Routine Description

        This routine Impersonates the Client and obtains the owner and
        its primary group from the Token

    Parameters:

        Owner -- The Owner sid is returned in here
        PrimaryGroup The User's Primary Group is returned in here

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{

    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    BOOLEAN     fImpersonating = FALSE;
    ULONG       RequiredLength=0;
    NTSTATUS    NtStatus  = STATUS_SUCCESS;
    BOOLEAN     ImpersonatingNullSession = FALSE;


    //
    // Initialize Return Values
    //

    *Owner = NULL;
    *PrimaryGroup = NULL;

    //
    // Impersonate the Client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    fImpersonating = TRUE;

    //
    // Grab the User's Sid
    //

    NtStatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,            //OpenAsSelf
                   &ClientToken
                   );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Query the Client Token For User's SID
    //

    NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenOwner,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *Owner = MIDL_user_allocate(RequiredLength);
        if (NULL==*Owner)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenOwner,
                        *Owner,
                        RequiredLength,
                        &RequiredLength
                        );

    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Query the Client Token For User's PrimaryGroup
    //

    RequiredLength = 0;

    NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenPrimaryGroup,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *PrimaryGroup = MIDL_user_allocate(RequiredLength);
        if (NULL==*PrimaryGroup)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenPrimaryGroup,
                        *PrimaryGroup,
                        RequiredLength,
                        &RequiredLength
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

    }


Error:

    //
    // Clean up on Error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if (*Owner)
        {
            MIDL_user_free(*Owner);
            *Owner = NULL;
        }

        if (*PrimaryGroup)
        {
            MIDL_user_free(*PrimaryGroup);
            *PrimaryGroup = NULL;
        }
    }

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (INVALID_HANDLE_VALUE!=ClientToken)
        NtClose(ClientToken);

    return NtStatus;

}




NTSTATUS
SampGetCurrentUser(
    IN  HANDLE        UserToken OPTIONAL,
    OUT PTOKEN_USER * User,
    OUT BOOL        * Administrator
    )
/*++

    Routine Description

        This routine Impersonates the Client and obtains the user
        field from the Token. If a user token is passed in then
        the user token is used instead of impersonation

    Parameters:

        UserToken -- The user's token can be optionally passed in here
        User -- The user's SID and attribute are returned in here

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{

    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    HANDLE      TokenToQuery;
    BOOLEAN     fImpersonating = FALSE;
    ULONG       RequiredLength=0;
    NTSTATUS    NtStatus  = STATUS_SUCCESS;
    BOOLEAN     ImpersonatingNullSession = FALSE;


    //
    // Initialize Return Values
    //

    *User = NULL;

    if (ARGUMENT_PRESENT(UserToken))
    {
        TokenToQuery = UserToken;
    }
    else
    {
        //
        // Impersonate the Client
        //

        NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        fImpersonating = TRUE;

        //
        // Grab the Client Token
        //

        NtStatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       TRUE,            //OpenAsSelf
                       &ClientToken
                       );

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        TokenToQuery = ClientToken;
    }

    //
    // Query the Client Token For User's SID
    //

    NtStatus = NtQueryInformationToken(
                    TokenToQuery,
                    TokenUser,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *User = MIDL_user_allocate(RequiredLength);
        if (NULL==*User)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        TokenToQuery,
                        TokenUser,
                        *User,
                        RequiredLength,
                        &RequiredLength
                        );
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    if (!CheckTokenMembership(
            TokenToQuery,SampAdministratorsAliasSid,Administrator))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


Error:

    //
    // Clean up on Error
    //


    if (!NT_SUCCESS(NtStatus))
    {
        if (*User)
        {
            MIDL_user_free(*User);
            *User = NULL;
        }
    }

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (INVALID_HANDLE_VALUE!=ClientToken)
        NtClose(ClientToken);

    return NtStatus;

}


NTSTATUS
SampValidateRpcProtSeq(
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    )
/*++

Routine Description:

    This routine obtains the client binding which is analyzed to determine 
    if the protocol sequence and endpoint are supported.  

Arguments:

    BindingHandle - This is the RPC client binding handle.  If non-NULL it
                    will be used to obtain the server binding handle. 
                    Otherwise, Rpc will conjure the server binding handle.
    
Return Value:

    STATUS_SUCCESS -- The call is allowed, protseq/endpoint are supported.
    
    RPC_NT_PROTSEQ_NOT_SUPPORTED -- The call is denied because either the
                                    incoming protocol sequence is not
                                    installed or recognized, or RPC was 
                                    unable to successfully determine it.
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RPC_STATUS RpcStatus = RPC_S_OK;
    RPC_BINDING_HANDLE ServerBinding = NULL;
    LPWSTR StringBinding = NULL;
    LPWSTR ProtocolSequence = NULL;
    BOOL fAllowProtSeq = FALSE;
    
    //
    // Obtain a partially bound server binding handle
    // 
    RpcStatus = RpcBindingServerFromClient(
                    BindingHandle,
                    &ServerBinding
                    );
    
    if (RPC_S_OK != RpcStatus) {
        
        goto Cleanup;  
    }
    
    RpcStatus = RpcBindingToStringBindingW(
                    ServerBinding,
                    &StringBinding
                    );
    
    if (RPC_S_OK != RpcStatus) {
        
        goto Cleanup;  
    }
    
    RpcStatus = RpcStringBindingParseW(
                    StringBinding,
                    NULL,
                    &ProtocolSequence,
                    NULL,
                    NULL,
                    NULL
                    );
    
    if (RPC_S_OK != RpcStatus) {
        
        goto Cleanup;  
    }
    
    //
    // Ensure the protocol sequence is supported before allowing the call.
    //
    if (_wcsicmp(NP_PROTSEQW,(LPCWSTR)ProtocolSequence) == 0) {
        //
        // Names pipes
        //
        fAllowProtSeq = TRUE;
        
    } else if (SampIpServerInstalled &&
               (_wcsicmp(TCP_PROTSEQW,(LPCWSTR)ProtocolSequence) == 0)) {
        //
        // Tcp/Ip 
        //
        fAllowProtSeq = TRUE; 
        
    } else if (SampNetwareServerInstalled &&
               (_wcsicmp(SPX_PROTSEQW,(LPCWSTR)ProtocolSequence) == 0)) {
        //
        // SPX / Netware
        //
        fAllowProtSeq = TRUE;
        
    } else if (SampAppletalkServerInstalled &&
               (_wcsicmp(AT_PROTSEQW,(LPCWSTR)ProtocolSequence) == 0)) {
        //
        // AppleTalk
        //
        fAllowProtSeq = TRUE;
    }

Cleanup:

    if (!fAllowProtSeq) {
        //
        // If anything went wrong or the protocol sequence isn't supported
        // we'll return RPC_NT_PROTSEQ_NOT_SUPPORTED, actually an NTSTATUS. 
        //
        NtStatus = RPC_NT_PROTSEQ_NOT_SUPPORTED;
    }      
     
    if (StringBinding) {
        RpcStringFree(&StringBinding);    
    }
    
    if (ProtocolSequence) {
        RpcStringFree(&ProtocolSequence);    
    }
        
    if (ServerBinding) {
        RpcBindingFree(&ServerBinding);
    }
    
    return NtStatus;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\sdconvrt.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    sdconvrt.c

Abstract:

      This File contains Routines to convert between NT5 security descriptors as
      defined in Dsrights.doc and NT4 Sam Security Descriptors.


Author:

    Murli Satagopan ( MURLIS ) 27-September -1996

Environment:

    User Mode - Win32

Revision History:



--*/


//
// SYNOPSIS
//
//
//
//  ACCESS RIGHTS MAPPING TABLES:
//
//    The access right mapping table contains the equivalent, per property DS access right and
//    type guid for each access right. At startup a reverse mapping table is constructed. The
//    reverse mapping table list the set of SAM access rights for each DS access mask on a per
//    property set guid basis. Since 32 bits of the access mask will result in 4 billion entries
//    in the table we cannot build this straight away. The following logic is used to reduce the
//    size of the table . The standard rights portion is always associated with the Object Type
//    that we are accessing. ie in a access check we shall use the standard rights from the granted
//    access corresponding to the Object Type of the object itself. The remaining 16 bits are split
//    into two halves, one half for the lower 8 bits and one half for the higher 8 bits. A set of
//    SAM access mask is computed for each combination of 256 for each of the halves. When a real
//    16 bit access mask is given, the low combination is looked up, then the high cobination is
//    looked up and then ored together to form the combined access mask. This can be done, since
//    each SAM right is exactly one DS right on a property GUID.
//
//
//
// ACCESS  CHECKING
//
//    The way the access checking works is as follows:
//
//       We impersonate client, grab the token and do a AccessCheckByType Result List asking for maximum
//       allowed access. We pass in a objecttype list which contains an entry for each object type
//       encountered in the access rights mapping table for that object. The function returns the granted access
//       for each objectType GUID. We walk these granted access, lookup the reverse mapping table and
//       and compute the SAM access granted by virtue of the granted access on the object type GUID.
//       Once we get the computed SAM access mask, we compare it with the desired access mask, and then
//       pass or fail the access check.
//
//
//  NT4 SD to NT5 SD conversion
//
//      Here we try to distinguish standard patterns. For Domain, Server, the pattern is declared standard.
//      For Groups, ALiases we distinguish between Admin and Non Admin. For Users, Admin , Non Admin Change
//      Password and Non Admin Non Change Password. If we cannot distinguish, then we use a different algorithm
//      that proceeds as follows.
//
//          1. The Group , Owner and Sacl are copied as such. Conversion only affects the DACL
//          2. We walk the NT4 Dacl, Acl by Acl. As we walk we build a SID access mask table. The
//             The Sid access mask table contains one entry for each Sid in the NT4 Dacl and list
//             of DS Accesses that are allowed or denied for this Sid. This access list is maintained
//             as an array of access masks per ObjectType GUID for the appropriate SAM object.
//
//          3. Once the Sid access mask table is constructed then we walk this table and add Object
//             Aces to represent each of the permissions that were explicity denied or granted to
//             each Sid in the NT4 Dacl.
//
//  NT5 to NT4 SD Conversion
//
//      We get the reverse membership and check wether he is a member of Administrators Alias ( CliffV - what if
//      he is administrator by privilege ) . For users then check the the NT5 Security descriptor for password change
//      also. For Domain, Server, we straightaway build the default security descriptor.
//
//
//
//

#include <samsrvp.h>
#include <seopaque.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>
#include <ntdsguid.h>
#include <mappings.h>
#include <dsevent.h>
#include <permit.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <dbgutilp.h>
#include <dsmember.h>
#include <malloc.h>
#include <attids.h>
#include <aclapi.h>

//
// GUID on which unused SAM property rights map to. This guid is never present anywhere
// else, so such rights will never be granted/ denied.
//

const GUID GUID_FOR_UNUSED_SAM_RIGHTS={0x7ed84960,0xad10,0x11d0,0x8a,0x92,0x00,0xaa,0x00,0x6e,0x05,0x29};

//
// Used for the description attribute of group, alias and user objects
//
const GUID GUID_PS_PUBLIC_INFORMATION  = {0xe48d0154,0xbcf8,0x11d1,0x87,0x02,0x00,0xc0,0x4f,0xb9,0x60,0x50};


//
// TABLES  -----------------------------------------------------------------------
//


//
//
// ACE tables list the Aces in Dacls to be used for Default Sds for NT5 SAM objects
//
//

ACE_TABLE ServerAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        WORLD_SID,
        GENERIC_READ|GENERIC_EXECUTE,
        FALSE,
        NULL,
        NULL
    }
};

ACE_TABLE DomainAceTable[] =

{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY|RIGHT_DS_LIST_CONTENTS,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        GENERIC_READ,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_READ|GENERIC_EXECUTE|RIGHT_DS_CREATE_CHILD|RIGHT_DS_DELETE_CHILD,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    }
};


ACE_TABLE GroupAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_SendTo,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        GENERIC_READ|RIGHT_DS_WRITE_PROPERTY_EXTENDED,
        FALSE,
        &GUID_A_MEMBER,
        NULL
    }
};

ACE_TABLE GroupAdminAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_SendTo,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        GENERIC_READ|RIGHT_DS_WRITE_PROPERTY_EXTENDED,
        FALSE,
        &GUID_A_MEMBER,
        NULL
    }
};






ACE_TABLE UserAceTable[] =
{

    //
    // Change password right needs to be given
    // to world, because when the user logs on
    // for the first time, and must change password
    // is set to true, at that point there is no
    // token, and the user is not yet authenticated.
    //
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};

ACE_TABLE UserAdminAceTable[] =
{


    //
    // Change password right needs to be given
    // to world, because when the user logs on
    // for the first time, and must change password
    // is set to true, at that point there is no
    // token, and the user is not yet authenticated.
    //
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        GENERIC_WRITE,
        FALSE,
        &GUID_PS_MEMBERSHIP,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};





ACE_TABLE UserNoPwdAceTable[] =
{
    {
        ACCESS_DENIED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_DENIED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};


//------------------------------------------------------
//
//
//    Access Right Mapping Tables and object type lists
//
//            These Table maps the DownLevel SAM
//            access rights to those of DS. The object type list
//            arrays consist of the object type guids that are
//            referenced in the Access Rights Mapping Tables and
//            are also ordered so that they can be directly passed
//            into the AccessCheckByTypeResultList function. Further
//            the object type list index field in the Access RightMapping
//            table is set to the corresponding index in the
//            ObjectType list array. This is is used by security descriptor
//            conversion routines to easily find the corresponding object type
//            in the Object Type List
//
//            In the tables the Object Class GUID is the object class of the
//            base class. Routines are supposed to fixup the Object Class by
//            querying the actual object's class GUID from the DS schema cache
//
//


//
//  Server Object , Access Rights Mapping Table
//

OBJECT_TYPE_LIST  ServerObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *) &GUID_C_SAM_SERVER}
};

ACCESSRIGHT_MAPPING_TABLE  ServerAccessRightMappingTable[] =
{
    {
        SAM_SERVER_CONNECT,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_SHUTDOWN,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_INITIALIZE,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_CREATE_DOMAIN,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_ENUMERATE_DOMAINS,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_LOOKUP_DOMAIN,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    }
};


OBJECT_TYPE_LIST  DomainObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *)&GUID_C_DOMAIN},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_PS_DOMAIN_PASSWORD},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCK_OUT_OBSERVATION_WINDOW},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCKOUT_DURATION},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCKOUT_THRESHOLD},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MAX_PWD_AGE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MIN_PWD_AGE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MIN_PWD_LENGTH},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_PWD_HISTORY_LENGTH},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_PWD_PROPERTIES},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_PS_DOMAIN_OTHER_PARAMETERS},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_SERVER_STATE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_SERVER_ROLE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MODIFIED_COUNT},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_UAS_COMPAT},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_FORCE_LOGOFF},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_DOMAIN_REPLICA},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_OEM_INFORMATION},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_CONTROL_DomainAdministerServer}
};

ACCESSRIGHT_MAPPING_TABLE  DomainAccessRightMappingTable[] =
{
    {
        DOMAIN_READ_PASSWORD_PARAMETERS,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_PASSWORD },

    {
        DOMAIN_WRITE_PASSWORD_PARAMS,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_PASSWORD },

    {
        DOMAIN_READ_OTHER_PARAMETERS,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_OTHER_PARAMETERS },

    {
        DOMAIN_WRITE_OTHER_PARAMETERS,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_OTHER_PARAMETERS },

    {
        DOMAIN_CREATE_USER,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN  },

    {
        DOMAIN_CREATE_GROUP,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN  },

    {
        DOMAIN_CREATE_ALIAS,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_GET_ALIAS_MEMBERSHIP,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_LIST_ACCOUNTS,
        RIGHT_DS_LIST_CONTENTS,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_LOOKUP,
        RIGHT_DS_LIST_CONTENTS,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_ADMINISTER_SERVER,
        RIGHT_DS_CONTROL_ACCESS,
        4,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_DomainAdministerServer }
};


OBJECT_TYPE_LIST  GroupObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0 , (GUID *)&GUID_C_GROUP},
    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_GENERAL_INFO},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DISPLAY_NAME},
    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_MEMBERSHIP},
        {ACCESS_PROPERTY_GUID,0,(GUID *)&GUID_A_MEMBER},
    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_PUBLIC_INFORMATION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DESCRIPTION},
};


ACCESSRIGHT_MAPPING_TABLE GroupAccessRightMappingTable[] =
{
    {
        GROUP_READ_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO  },

    {
        GROUP_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        GROUP_ADD_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        GROUP_REMOVE_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        GROUP_LIST_MEMBERS,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER  },
};


OBJECT_TYPE_LIST  AliasObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0 , (GUID *)&GUID_C_GROUP},
        {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_GENERAL_INFO},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_MEMBERSHIP},
            {ACCESS_PROPERTY_GUID,0,(GUID *)&GUID_A_MEMBER},
        {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_PUBLIC_INFORMATION},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DESCRIPTION},
};


ACCESSRIGHT_MAPPING_TABLE AliasAccessRightMappingTable[] =
{
    {
        ALIAS_READ_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO  },

    {
        ALIAS_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },
    {
        ALIAS_ADD_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        ALIAS_REMOVE_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        ALIAS_LIST_MEMBERS,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER  },
};

//
// User access right mapping table
//
//
//

OBJECT_TYPE_LIST  UserObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *) &GUID_C_USER},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_GENERAL_INFO},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DISPLAY_NAME},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_USER_ACCOUNT_RESTRICTIONS},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_ACCOUNT_EXPIRES},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PWD_LAST_SET},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_ACCOUNT_CONTROL},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_PARAMETERS},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_USER_LOGON},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_BAD_PWD_COUNT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_HOME_DIRECTORY},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_HOME_DRIVE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LAST_LOGOFF},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LAST_LOGON},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_COUNT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_HOURS},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_WORKSTATION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PROFILE_PATH},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SCRIPT_PATH},

    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_PUBLIC_INFORMATION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DESCRIPTION},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_MEMBERSHIP},
        {ACCESS_PROPERTY_GUID,      0,      (GUID *) &GUID_A_IS_MEMBER_OF_DL},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_CONTROL_UserChangePassword},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_CONTROL_UserForceChangePassword},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_FOR_UNUSED_SAM_RIGHTS}
};

//
// N.B. This table must be in the same order as the UserObjectTypeList
// table above
//
ULONG UserAttributeMappingTable[] = 
{
    0,  // object guid

    0,  // general info property set
    SAMP_FIXED_USER_CODEPAGE,
    SAMP_FIXED_USER_COUNTRY_CODE,
    SAMP_FIXED_USER_SID,
    SAMP_FIXED_USER_PRIMARY_GROUP_ID,
    SAMP_USER_ACCOUNT_NAME,
    SAMP_USER_USER_COMMENT,
    SAMP_USER_FULL_NAME,

    0, // Account restrictions property set
    SAMP_FIXED_USER_ACCOUNT_EXPIRES,
    SAMP_FIXED_USER_PWD_LAST_SET,
    SAMP_FIXED_USER_ACCOUNT_CONTROL,
    SAMP_USER_PARAMETERS,

    0, // User Logon property set
    SAMP_FIXED_USER_BAD_PWD_COUNT,
    SAMP_USER_HOME_DIRECTORY,
    SAMP_USER_HOME_DIRECTORY_DRIVE,
    SAMP_FIXED_USER_LAST_LOGOFF,
    SAMP_FIXED_USER_LAST_LOGON,
    SAMP_FIXED_USER_LOGON_COUNT,
    SAMP_USER_LOGON_HOURS,
    SAMP_USER_WORKSTATIONS,
    SAMP_USER_PROFILE_PATH,
    SAMP_USER_SCRIPT_PATH,

    0, // Personal Information Property Set
    SAMP_USER_ADMIN_COMMENT,

    // The rest are not related to attributes settable via
    // SamrSetInformationUser
    0,
    0,
    0,
    0,
    0
};

ACCESSRIGHT_MAPPING_TABLE UserAccessRightMappingTable[] =
{
    {
        USER_READ_GENERAL,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_READ_PREFERENCES,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_WRITE_PREFERENCES,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_READ_LOGON,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_LOGON },

    {
        USER_READ_ACCOUNT,
        RIGHT_DS_READ_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_ACCOUNT_RESTRICTIONS },

    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_LOGON },
    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },
    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_ACCOUNT_RESTRICTIONS },
    {
        USER_CHANGE_PASSWORD,
        RIGHT_DS_CONTROL_ACCESS,
        6,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_UserChangePassword },

    {
        USER_FORCE_PASSWORD_CHANGE,
        RIGHT_DS_CONTROL_ACCESS,
        7,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_UserForceChangePassword },

    {
        USER_LIST_GROUPS,
        RIGHT_DS_READ_PROPERTY,
        5,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_IS_MEMBER_OF_DL },

    {
        USER_READ_GROUP_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        5,
        0,
        ACCESS_PROPERTY_SET_GUID,
        &GUID_FOR_UNUSED_SAM_RIGHTS },

    {
        USER_WRITE_GROUP_INFORMATION,
        RIGHT_DS_WRITE_PROPERTY,
        5,
        0,
        ACCESS_PROPERTY_SET_GUID,
        &GUID_FOR_UNUSED_SAM_RIGHTS },
};



ULONG   cServerObjectTypes = ARRAY_COUNT(ServerObjectTypeList);
ULONG   cDomainObjectTypes = ARRAY_COUNT(DomainObjectTypeList);
ULONG   cGroupObjectTypes  = ARRAY_COUNT(GroupObjectTypeList);
ULONG   cAliasObjectTypes  = ARRAY_COUNT(AliasObjectTypeList);
ULONG   cUserObjectTypes   = ARRAY_COUNT(UserObjectTypeList);

//
//  Reverse Mapping Table for each type
//
//

REVERSE_MAPPING_TABLE * ServerReverseMappingTable;
REVERSE_MAPPING_TABLE * DomainReverseMappingTable;
REVERSE_MAPPING_TABLE * GroupReverseMappingTable;
REVERSE_MAPPING_TABLE * AliasReverseMappingTable;
REVERSE_MAPPING_TABLE * UserReverseMappingTable;



GENERIC_MAPPING  DsGenericMap = DS_GENERIC_MAPPING;

//
// NT4 ACE tables describing the NT4 Dacls. All Aces
// in NT4 Dacls are access Allowed Aces.
//
//
NT4_ACE_TABLE NT4GroupNormalTable[] =
{
    { WORLD_SID, GROUP_READ|GROUP_EXECUTE },
    { ADMINISTRATOR_SID, GROUP_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, GROUP_ALL_ACCESS }
};

NT4_ACE_TABLE NT4GroupAdminTable[] =
{
    { WORLD_SID, GROUP_READ|GROUP_EXECUTE },
    { ADMINISTRATOR_SID, GROUP_ALL_ACCESS }
};

NT4_ACE_TABLE NT4AliasNormalTable[] =
{
    { WORLD_SID, ALIAS_READ|ALIAS_EXECUTE },
    { ADMINISTRATOR_SID, ALIAS_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, ALIAS_ALL_ACCESS }
};

NT4_ACE_TABLE NT4AliasAdminTable[] =
{
    { WORLD_SID, ALIAS_READ|ALIAS_EXECUTE },
    { ADMINISTRATOR_SID, ALIAS_ALL_ACCESS }
};

//
// Note the Principal Self Sid is used in here to
// denote that the User's Sid itself. NT4 systems do
// not employ the principal self Sid. The match routines
// are however designed to match the principal Self Sid to
// any Sid in the account domain.
//

NT4_ACE_TABLE NT4UserNormalTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE},
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID,USER_WRITE}
};


NT4_ACE_TABLE NT4UserNoChangePwdTable[] =
{
    { WORLD_SID, (USER_READ|USER_EXECUTE) &(~(USER_CHANGE_PASSWORD)) },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID, (USER_WRITE)&(~(USER_CHANGE_PASSWORD)) }
};

NT4_ACE_TABLE NT4UserNoChangePwdTable2[] =
{
    { WORLD_SID, (USER_READ|USER_EXECUTE) &(~(USER_CHANGE_PASSWORD)) },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS }
};

NT4_ACE_TABLE NT4UserAdminTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID, USER_WRITE}
};

NT4_ACE_TABLE NT4UserRestrictedAccessTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE},
    { PRINCIPAL_SELF_SID,USER_WRITE|DELETE|USER_FORCE_PASSWORD_CHANGE},
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS }

};



//----------------------------------------------------------------------------------

//
//
// Function prototype declarations
//
//
//
//
//

NTSTATUS
SampComputeReverseAccessRights(
  ACCESSRIGHT_MAPPING_TABLE  * MappingTable,
  ULONG cEntriesInMappingTable,
  POBJECT_TYPE_LIST  ObjectTypeList,
  ULONG cObjectTypes,
  REVERSE_MAPPING_TABLE ** ReverseMappingTable
  );


NTSTATUS
SampRecognizeStandardNt4Sd(
    IN PVOID   Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG DsClassId,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT BOOLEAN *ChangePassword,
    OUT BOOLEAN *Admin,
    OUT PVOID * Nt5Sd
    );

NTSTATUS
SampCheckIfAdmin(
    PSID SidOfPrincipal,
    BOOLEAN * Admin
    );

NTSTATUS
SampCheckIfChangePasswordAllowed(
    PSECURITY_DESCRIPTOR Nt5Sd,
    PSID  UserSid,
    BOOLEAN * ChangePasswordAllowed
    );

NTSTATUS
SampCreateNT5Dacl(
    ACE_TABLE * AceTable,
    ULONG       cEntries,
    IN  PSAMP_OBJECT    Context OPTIONAL,
    PACL        Dacl
    );

NTSTATUS
SampBuildNt4DomainProtection(
    PSECURITY_DESCRIPTOR * Nt4DomainDescriptor,
    PULONG  DescriptorLength
    );

NTSTATUS
SampBuildNt4ServerProtection(
    PSECURITY_DESCRIPTOR * Nt4ServerDescriptor,
    PULONG  DescriptorLength
    );

NTSTATUS
SampInitializeWellKnownSidsForDsUpgrade( VOID );

VOID
SampRecognizeNT4GroupDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    );

VOID
SampRecognizeNT4AliasDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    );

VOID
SampRecognizeNT4UserDacl(
    PACL    NT4Dacl,
    PSAMP_OBJECT Context,
    BOOLEAN *Standard,
    BOOLEAN *Admin,
    BOOLEAN *ChangePassword,
    OUT PSID * Owner
    );

BOOLEAN
SampMatchNT4Aces(
    NT4_ACE_TABLE *AceTable,
    ULONG         cEntriesInAceTable,
    PACL          NT4Dacl
    );

NTSTATUS
SampAddNT5ObjectAces(
    SID_ACCESS_MASK_TABLE *SidAccessMaskTable,
    ULONG   AceCount,
    POBJECT_TYPE_LIST   ObjectTypeList,
    ULONG   cObjectTypes,
    PSAMP_OBJECT    Context,
    PACL    NT5Dacl
    );



//----------------------------------------------------------------------------------
//
//  Initialization Routines
//
//
//


NTSTATUS
SampInitializeSdConversion()
/*
    This routine is intended to be called by Dsupgrad. It builds the well known Sid
    array as SamInitialize is not called in this process

    Parameters None

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

*/
{
    NTSTATUS NtStatus;

    NtStatus = SampInitializeWellKnownSidsForDsUpgrade();
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampInitializeAccessRightsTable();
    }

    return NtStatus;
}


NTSTATUS
SampInitializeAccessRightsTable()
/*++
    Routine Description

          This does the following

            1. Initializes the Reverse Mapping Table, which is used to
               perform fast access checks.
            2. Initializes the DS generic Map

    Parameters

          None

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Initialize the ACL conversion cache
    //

    NtStatus = SampInitializeAclConversionCache();

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    //
    // Compute the Reverse access rights for each object type.
    //

    NtStatus = SampComputeReverseAccessRights(
                    ServerAccessRightMappingTable,
                    ARRAY_COUNT(ServerAccessRightMappingTable),
                    ServerObjectTypeList,
                    cServerObjectTypes,
                    &ServerReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    NtStatus = SampComputeReverseAccessRights(
                    DomainAccessRightMappingTable,
                    ARRAY_COUNT(DomainAccessRightMappingTable),
                    DomainObjectTypeList,
                    cDomainObjectTypes,
                    &DomainReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampComputeReverseAccessRights(
                    GroupAccessRightMappingTable,
                    ARRAY_COUNT(GroupAccessRightMappingTable),
                    GroupObjectTypeList,
                    cGroupObjectTypes,
                    &GroupReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;

     NtStatus = SampComputeReverseAccessRights(
                    AliasAccessRightMappingTable,
                    ARRAY_COUNT(AliasAccessRightMappingTable),
                    AliasObjectTypeList,
                    cAliasObjectTypes,
                    &AliasReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    NtStatus = SampComputeReverseAccessRights(
                    UserAccessRightMappingTable,
                    ARRAY_COUNT(UserAccessRightMappingTable),
                    UserObjectTypeList,
                    cUserObjectTypes,
                    &UserReverseMappingTable
                    );

Error:

    return NtStatus;

}


NTSTATUS
SampComputeReverseAccessRights(
  ACCESSRIGHT_MAPPING_TABLE  * MappingTable,
  ULONG cEntriesInMappingTable,
  POBJECT_TYPE_LIST  ObjectTypeList,
  ULONG cObjectTypes,
  REVERSE_MAPPING_TABLE ** ReverseMappingTable
  )
  /*++

  Routine  Description:

        This routine computes the reverse mapping table and an
        object type list given acces rights table. The entries in the reverse
        mapping table are in the same order as in the object type list.

        The reverse Mapping Table consists of one Entry for Each Object Type
        GUID in the Object Type List. Each Entry consists of the Sam Access Rights
        granted for 256 Low 8 bit combinations of DS access Mask and 256 hi 8 bit
        combinations of Ds Access Masks.

  Parameters:

        MappingTable -- Pointer to the access right mapping table
        cEntriesInMappingTable -- No of entries in the mapping table
        ObjectTypeList         -- The Object type list ( list of GUIDS representing the
                                  SAM classes or properties that we are intereseted in ).
        cObjectTypes           -- No of entries in the object type list
        ReverseMappingTable    -- Reverse Mapping table that is computed

  Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i,j;
    ULONG DsAccessMask;


    *ReverseMappingTable = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            cObjectTypes * sizeof(REVERSE_MAPPING_TABLE)
                            );

    if (NULL==*ReverseMappingTable)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(*ReverseMappingTable,
                   cObjectTypes * sizeof(REVERSE_MAPPING_TABLE)
                   );

    //
    // For Each Guid in the object type list
    //

    for (i=0;i<cObjectTypes;i++)
    {

        //
        // For each access Ds Access Mask that we may supply for that GUID
        //

        for (DsAccessMask=0;DsAccessMask<256;DsAccessMask++)
        {

            //
            // Go through the mapping table and match by Guid
            // Note we consider only an 8 bit mask at a time as we divide the 16 specific
            // rights into 2 groups of 8. For each of the 256 combinations in each,
            // we will compute the SAM access rights corresponding to them. This way
            // we will have 2 sets of SAM access rights, one corresponding to the
            // lo 8 bit combinations, and one to the hi 8 bit combinations. The
            // assumption being made in here is that each SAM access right is a
            // combination of ds access rights in only one 8 bit half, on some
            // object type . This assumption is very much valid today,
            // as each SAM right is infact a single Ds right, on some object type. Since we
            // should not be defining new NT4 SAM access rights, we should be covered
            // for the future.
            //


            for (j=0;j<cEntriesInMappingTable;j++)
            {
                if (memcmp(ObjectTypeList[i].ObjectType,
                          MappingTable[j].DsGuid,
                          sizeof(GUID))==0)
                {
                    //
                    // if GUID Matched, then check wether the Ds access mask supplied
                    // in the mapping table satisfies the access Mask
                    //

                    if ((MappingTable[j].DsAccessMask)==(DsAccessMask &
                            MappingTable[j].DsAccessMask))
                    {
                        //
                        // This Mask grants the Required Access. So add the Sam
                        // access right defined in the mapping table to this combination
                        // of guid and access mask. Remember i indexes over the Guids,
                        // in the object type list and DsAccessMask indexes over the
                        // DS access mask.

                        (*ReverseMappingTable)[i].SamSpecificRightsLo[DsAccessMask]
                            |=MappingTable[j].SamAccessRight;
                    }

                    //
                    // Do the Same for the next 8 bits
                    //
                    //

                    if ((MappingTable[j].DsAccessMask)==((DsAccessMask*256) &
                            MappingTable[j].DsAccessMask))
                    {
                        //
                        // This Mask grants the Required Access. So add the Sam
                        // access right defined in the mapping table to this combination
                        // of guid and access mask. Remember i indexes over the Guids,
                        // in the object type list and DsAccessMask indexes over the
                        // DS access mask.

                        (*ReverseMappingTable)[i].SamSpecificRightsHi[DsAccessMask]
                            |=MappingTable[j].SamAccessRight;
                    }


                }
            }
        }
    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {

        if (*ReverseMappingTable)
        {
            RtlFreeHeap(RtlProcessHeap(),0,*ReverseMappingTable);
            *ReverseMappingTable = NULL;
        }
    }


    return NtStatus;
}


//------------------------------------------------------------------------------------
//
//
//  A Set of private wrappers for some of the comonly called RTl functions
//  which make coding a little easier as well as more readable. The functions
//  are self explanatory. At some point in time if performance is a concern
//  then these should be replaced by macros.
//
//
//


PACL GetDacl(
    IN PSECURITY_DESCRIPTOR Sd
    )
{
    BOOL     Status;
    PACL     Dacl = NULL;
    PACL     DaclToReturn = NULL;
    BOOL     DaclPresent;
    BOOL     DaclDefaulted;

    Status = GetSecurityDescriptorDacl(
                    Sd,
                    &DaclPresent,
                    &Dacl,
                    &DaclDefaulted
                    );
    if ((Status)
        && DaclPresent
        && !DaclDefaulted)
    {
        DaclToReturn = Dacl;
    }

    return DaclToReturn;

}

PACL GetSacl(
    IN PSECURITY_DESCRIPTOR Sd
    )
{
    BOOL     Status;
    PACL     Sacl = NULL;
    PACL     SaclToReturn = NULL;
    BOOL     SaclPresent;
    BOOL     SaclDefaulted;

    Status = GetSecurityDescriptorSacl(
                    Sd,
                    &SaclPresent,
                    &Sacl,
                    &SaclDefaulted
                    );
    if ((Status)
        && SaclPresent
        && !SaclDefaulted)
    {
        SaclToReturn = Sacl;
    }

    return SaclToReturn;

}

PSID GetOwner(
     IN PSECURITY_DESCRIPTOR Sd
     )
{
    BOOL     Status;
    PSID     OwnerToReturn = NULL;
    PSID     Owner;
    BOOL     OwnerDefaulted;

    Status = GetSecurityDescriptorOwner(
                    Sd,
                    &Owner,
                    &OwnerDefaulted
                    );
    if (Status)
    {
        OwnerToReturn = Owner;
    }

    return OwnerToReturn;
}

PSID GetGroup(
     IN PSECURITY_DESCRIPTOR Sd
     )
{
    BOOL     Status;
    PSID     GroupToReturn = NULL;
    PSID     Group;
    BOOL     GroupDefaulted;

    Status = GetSecurityDescriptorGroup(
                    Sd,
                    &Group,
                    &GroupDefaulted
                    );
    if (Status)
    {
        GroupToReturn = Group;
    }

    return GroupToReturn;
}


ULONG GetAceCount(
    IN PACL Acl
    )
{
    ULONG   AceCount = 0;


    AceCount = Acl->AceCount;

    return AceCount;
}


ACE * GetAcePrivate(
    IN PACL Acl,
    ULONG AceIndex
    )
{
    BOOL Status;
    ACE * Ace = NULL;

    Status = GetAce(
                 Acl,
                 AceIndex,
                 &Ace
                 );
    if (!Status)
        Ace = NULL;

    return Ace;
}

ACCESS_MASK AccessMaskFromAce(
                IN ACE * Ace
                )
{
    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    ULONG      Mask = 0;

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        Mask =
           ((ACCESS_ALLOWED_ACE *) Ace)->Mask;
        break;

    case ACCESS_DENIED_ACE_TYPE:
        Mask =
           ((ACCESS_DENIED_ACE *) Ace)->Mask;
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        Mask =
           ((SYSTEM_AUDIT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        Mask =
           ((SYSTEM_ALARM_ACE *) Ace)->Mask;
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        Mask =
           ((COMPOUND_ACCESS_ALLOWED_ACE *) Ace)->Mask;
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        Mask =
           ((ACCESS_ALLOWED_OBJECT_ACE *) Ace)->Mask;
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        Mask =
           ((ACCESS_DENIED_OBJECT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        Mask =
           ((SYSTEM_AUDIT_OBJECT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        Mask =
           ((SYSTEM_ALARM_OBJECT_ACE *) Ace)->Mask;
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return Mask;

}

PSID SidFromAce(
        IN ACE * Ace
        )
{
    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    PSID      SidStart = NULL;

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        SidStart =
           &(((ACCESS_ALLOWED_ACE *) Ace)->SidStart);
        break;

    case ACCESS_DENIED_ACE_TYPE:
        SidStart =
           &(((ACCESS_DENIED_ACE *) Ace)->SidStart);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        SidStart =
           &(((SYSTEM_AUDIT_ACE *) Ace)->SidStart);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        SidStart =
           &(((SYSTEM_ALARM_ACE *) Ace)->SidStart);
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        SidStart =
           &(((COMPOUND_ACCESS_ALLOWED_ACE *) Ace)->SidStart);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return SidStart;

}

BOOLEAN
IsAccessAllowedAce(
    ACE * Ace
    )
{
    return ( (ACCESS_ALLOWED_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessDeniedAce(
    ACE * Ace
    )
{
    return ( (ACCESS_DENIED_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessAllowedObjectAce(
    ACE * Ace
    )
{
    return ( (ACCESS_ALLOWED_OBJECT_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessDeniedObjectAce(
    ACE * Ace
    )
{
    return ( (ACCESS_DENIED_OBJECT_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}




BOOLEAN
AdjustAclSize(PACL Acl)
{
    ULONG_PTR AclStart;
    ULONG_PTR AclEnd;
    BOOLEAN ReturnStatus = FALSE;
    ACE * Ace;

    if ((FindFirstFreeAce(Acl,&Ace))
            && (NULL!=Ace))
    {
        AclStart = (ULONG_PTR)Acl;
        AclEnd   = (ULONG_PTR)Ace;

        Acl->AclSize = (USHORT)(AclEnd-AclStart);
        ReturnStatus = TRUE;
    }

    return ReturnStatus;
}




VOID DumpAce(ACE * Ace)
{
#if DBG

    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    PSID         Sid       = SidFromAce(Ace);
    GUID         *ObjectType;

    if (NULL == Ace)
    {
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Invalid Ace (NULL)\n"));
        return;
    }

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Ace\n"));
        break;

    case ACCESS_DENIED_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Denied Ace\n"));
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Audit Ace\n"));
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Alarm Ace\n"));
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Compound Ace\n"));
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((ACCESS_ALLOWED_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Denied Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((ACCESS_DENIED_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Audit Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((SYSTEM_AUDIT_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Alarm Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((SYSTEM_ALARM_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    default:
        ASSERT(FALSE);
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Unknown Ace Type\n"));
        return;
    }

    SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Mask = %x\n",AccessMaskFromAce(Ace)));
    SampDiagPrint(SD_DUMP,("[SAMSS] \t Sid ="));
    SampDumpBinaryData(Sid,RtlLengthSid(Sid));
    SampDiagPrint(SD_DUMP,("[SAMSS]\n"));
#endif

}

VOID DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR Sd
    )
{
#if DBG
    ULONG Length;
    ULONG i;

    if (NULL!=Sd)
    {
        PSID  Owner = GetOwner(Sd);
        PSID  Group = GetGroup(Sd);
        PACL  Dacl  = GetDacl(Sd);
        PACL  Sacl  = GetSacl(Sd);


        if (NULL!=Owner)
        {
            Length = RtlLengthSid(Owner);
            SampDiagPrint(SD_DUMP,("[SAMSS] Owner = "));
            SampDumpBinaryData((BYTE *)Owner,Length);
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Owner = NULL\n"));
        }

        if (NULL!=Group)
        {
            Length = RtlLengthSid(Group);
            SampDiagPrint(SD_DUMP,("[SAMSS] Group = "));
            SampDumpBinaryData((BYTE *)Group,Length);
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Group = NULL\n"));
        }


         if (NULL!=Dacl)
        {
            ULONG   AceCount;

            SampDiagPrint(SD_DUMP,("[SAMSS] Dacl=\n"));

            AceCount = GetAceCount(Dacl);
            for (i=0;i<AceCount;i++)
            {
                ACE * Ace;

                SampDiagPrint(SD_DUMP,("[SAMSS] ACE %d\n",i));
                Ace = GetAcePrivate(Dacl,i);
                if (Ace)
                    DumpAce(Ace);
            }
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Dacl = NULL\n"));
        }


        if (NULL!=Sacl)
        {

            ULONG   AceCount;

            SampDiagPrint(SD_DUMP,("[SAMSS] Sacl=\n\n"));

            AceCount = GetAceCount(Sacl);
            for (i=0;i<AceCount;i++)
            {
                ACE * Ace;

                SampDiagPrint(SD_DUMP,("[SAMSS] ACE %d\n",i));
                Ace = GetAcePrivate(Sacl,i);
                if (Ace)
                    DumpAce(Ace);
            }

        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Sacl = NULL\n"));
        }

    }
    else
     SampDiagPrint(SD_DUMP,("[SAMSS] Security Descriptor = NULL\n"));

#endif
}



//-------------------------------------------------------------------------------------------------------
//
//
//  ACCESS Check Functions
//
//

ULONG
DsToSamAccessMask(
    SAMP_OBJECT_TYPE ObjectType,
    ULONG DsAccessMask
    )
/*

  Routine Description:

        Given a Ds Access Mask on an Access Allowed ACE, treat it as
        access allowed on all object types and return the appropriate
        SAM access mask . This function is not currently used today
        but can be used tp validate the reverse mapping table

  Parameters
        DsAccessMask

  Return Value

      SAM access mask

*/
{

    ACCESSRIGHT_MAPPING_TABLE  * MappingTable;
    ULONG               cEntriesInMappingTable;
    ULONG               Index;
    ULONG               SamAccessRight = 0;


    //
    // Choose the Appropriate Mapping Table and Object Type List
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
        MappingTable =  DomainAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(DomainAccessRightMappingTable);
        break;
    case SampGroupObjectType:
        MappingTable = GroupAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(GroupAccessRightMappingTable);
        break;
    case SampAliasObjectType:
        MappingTable = AliasAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(AliasAccessRightMappingTable);
        break;
    case SampUserObjectType:
        MappingTable = UserAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(UserAccessRightMappingTable);
        break;
    default:
        goto Error;
    }

    //
    // Walk through the mapping table and for each entry that satisfies the
    // given mask, add the correspond Sam access right
    //

    for (Index=0;Index<cEntriesInMappingTable;Index++)
    {
        if ((MappingTable[Index].DsAccessMask & DsAccessMask)
            == (MappingTable[Index].DsAccessMask))
        {
            //
            // Mask is satisfied, add the right
            //

            SamAccessRight |= MappingTable[Index].SamAccessRight;
        }
    }

Error:

    return SamAccessRight;
}





NTSTATUS
SampDoNt5SdBasedAccessCheck(
    IN  PSAMP_OBJECT        Context,
    IN  PVOID               Nt5Sd,
    IN  PSID                PrincipalSelfSid,
    IN  SAMP_OBJECT_TYPE    ObjectType,
    IN  ULONG               Nt4SamAccessMask,
    IN  BOOLEAN             ObjectCreation,
    IN  GENERIC_MAPPING     *Nt4SamGenericMapping,
    IN  HANDLE              ClientToken,
    OUT ACCESS_MASK         *GrantedAccess,
    OUT PRTL_BITMAP         WriteGrantedAccessAttributes,
    OUT NTSTATUS            *AccessCheckStatus
    )
/*++
    Routine Description

        Given an NT5 Security Descriptor and an NT4 SAM access Mask,
        this does an access check using the Nt5 Access check functions,
        after mapping the NT4 SAM access Mask

    Parameters:

        Context           -- Open Handle to the object that is being access checked.
                            The access Check routine may derive any additional information
                            about the object through the context.
        Nt5Sd             -- NT 5 Security Descriptor
        PrincipalSelfSid  -- For security principals, the Sid of the object
                            that is being access checked
        ObjectType        -- SAM Object Type
        Nt4SamAccessMask  -- This is the NT 4 SAM access Mask

        ObjectCreation    -- Indicates that the object is being created

        Nt4SamGenericMapping -- This is the NT4 SAM generic mapping structure

        ClientToken       -- Optional parameter for client token

        GrantedAccess     -- The granted access in terms of the NT4 SAM access mask is
                            given in here
        
                                    
        WriteGrantedAccessAttributes -- a bitmap of attributes that can be
                                        written
                                                                    
        AccessCheckStatus -- Returns the result of the Access Check

    Return Values

        STATUS_SUCCESS upon successful check
        STATUS_ACCESS_DENIED otherwise

--*/
{
    NTSTATUS    NtStatus;

    REVERSE_MAPPING_TABLE *ReverseMappingTable = NULL;
    POBJECT_TYPE_LIST      ObjectTypeList = NULL,
                           LocalObjectTypeList;


    ULONG                 cObjectTypes;
    ULONG                 Nt5DesiredAccess;
    ACCESS_MASK           GrantedAccesses[MAX_SCHEMA_GUIDS];
    NTSTATUS              AccessStatuses[MAX_SCHEMA_GUIDS];

    ACCESS_MASK           SamAccessMaskComputed=0;
    ACCESS_MASK           Nt4AccessMaskAsPassedIn = Nt4SamAccessMask;
    BOOLEAN               MaximumAllowedAskedFor = (BOOLEAN)((Nt4SamAccessMask & MAXIMUM_ALLOWED)!=0);
    ACCESS_MASK           MaximumAccessMask;
    NTSTATUS              ChkStatus = STATUS_SUCCESS;

    ULONG                 i;

    GUID                  ClassGuid;
    ULONG                 ClassGuidLength=sizeof(GUID);
    UNICODE_STRING        ObjectName;
    BOOLEAN               FreeObjectName = FALSE;

    BOOLEAN               fAtLeastOneSAMAccessGranted = FALSE;
    BOOLEAN               ImpersonatingNullSession = FALSE;

    ULONG                 *AttributeMappingTable = NULL;

    SampDiagPrint(NT5_ACCESS_CHECKS,("[SAMSS] NT5 ACCESS CHECK ENTERED \n"));

    //
    // Initliaze the granted access
    //
    *GrantedAccess = 0;
    RtlClearAllBits(WriteGrantedAccessAttributes);


    //
    // Get a name for auditing
    //

    RtlZeroMemory(&ObjectName,sizeof(UNICODE_STRING));

    if (Context->ObjectNameInDs->NameLen>0)
    {
        ObjectName.Length = ObjectName.MaximumLength =
                      (USHORT) Context->ObjectNameInDs->NameLen * sizeof(WCHAR);
        ObjectName.Buffer = Context->ObjectNameInDs->StringName;
    }
    else
    {
        //
        // If the name is not there at least the SID must be there
        //

        ASSERT(Context->ObjectNameInDs->SidLen >0);

        NtStatus = RtlConvertSidToUnicodeString(&ObjectName, (PSID)&(Context->ObjectNameInDs->Sid), TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        FreeObjectName = TRUE;
    }

    //
    // Get the self sid
    //

    if ((!ARGUMENT_PRESENT(PrincipalSelfSid)) &&
            (SampServerObjectType != ObjectType))
        {
            PrincipalSelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

            if (NULL == PrincipalSelfSid)
            {
                // Can't get SID for Security Principal. Set Error
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
        }

    //
    // Get the Appropriate MappingTable
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
        ObjectTypeList = DomainObjectTypeList;
        cObjectTypes = cDomainObjectTypes;
        ReverseMappingTable = DomainReverseMappingTable;
        break;
    case SampGroupObjectType:
        ObjectTypeList = GroupObjectTypeList;
        cObjectTypes = cGroupObjectTypes;
        ReverseMappingTable = GroupReverseMappingTable;
        break;
    case SampAliasObjectType:
        ObjectTypeList = AliasObjectTypeList;
        cObjectTypes = cAliasObjectTypes;
        ReverseMappingTable = AliasReverseMappingTable;
        break;
    case SampUserObjectType:
        ObjectTypeList = UserObjectTypeList;
        cObjectTypes = cUserObjectTypes;
        ReverseMappingTable = UserReverseMappingTable;
        AttributeMappingTable = UserAttributeMappingTable;
        break;
    case SampServerObjectType:
        ObjectTypeList = ServerObjectTypeList;
        cObjectTypes = cServerObjectTypes;
        ReverseMappingTable = ServerReverseMappingTable;
        break;
    default:
        ASSERT(FALSE && "Invalid Object Type Specified");
        NtStatus = STATUS_INTERNAL_ERROR;
        return NtStatus;
    }

   //
   //  Print out diagnostics if asked for regarding the Object Types and the
   //  security descriptor
   //

   SampDiagPrint(NT5_ACCESS_CHECKS,("[SAMSS]\tcObjectTypes=%x\n",cObjectTypes));

   IF_SAMP_GLOBAL(SD_DUMP)
       DumpSecurityDescriptor(Nt5Sd);


   //
   //  Make a local copy of the object type list
   //

   SAMP_ALLOCA(LocalObjectTypeList, cObjectTypes * sizeof(ObjectTypeList));
   if (NULL==LocalObjectTypeList)
   {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Error;
   }

   RtlCopyMemory(
       LocalObjectTypeList,
       ObjectTypeList,
       cObjectTypes * sizeof(ObjectTypeList)
       );


   //
   // Fix up the Class of the object. It is important to note that the object class
   // guid for the ACCESS_OBJECT_GUID level is a constant GUID that represents the base
   // SAM class. We really have to fixup with the actual class guid of the object that
   // we are processing from the DS's schema cache.
   //

   NtStatus = SampGetClassAttribute(
                Context->DsClassId,
                ATT_SCHEMA_ID_GUID,
                &ClassGuidLength,
                &ClassGuid
                );
   if (!NT_SUCCESS(NtStatus))
   {
       goto Error;
   }

   ASSERT(ClassGuidLength == sizeof(GUID));

   LocalObjectTypeList[OBJECT_CLASS_GUID_INDEX].ObjectType = &ClassGuid;

   //
   // Ask for maximum available access
   //

   MaximumAccessMask = MAXIMUM_ALLOWED|(Nt4SamAccessMask & ACCESS_SYSTEM_SECURITY);

   RtlZeroMemory(AccessStatuses,cObjectTypes * sizeof(ULONG));
   RtlZeroMemory(GrantedAccesses,cObjectTypes * sizeof(ULONG));

   //
   // Impersonate the client
   //

   if (!ARGUMENT_PRESENT(ClientToken))
   {
       NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
       if (!NT_SUCCESS(NtStatus))
           goto Error;
   }

   //
   // Allow a chance to break before the access check.
   //

   IF_SAMP_GLOBAL(BREAK_ON_CHECK)
       DebugBreak();

   //
   // Call the access check routine
   //

   if (ARGUMENT_PRESENT(ClientToken))
   {
       CHAR                  PrivilegeSetBuffer[256];
       PRIVILEGE_SET         *PrivilegeSet = (PRIVILEGE_SET *)PrivilegeSetBuffer;
       ULONG                 PrivilegeSetLength = sizeof(PrivilegeSetBuffer);


       RtlZeroMemory(PrivilegeSet,PrivilegeSetLength);

       ChkStatus =   NtAccessCheckByTypeResultList(
                        Nt5Sd,
                        PrincipalSelfSid,
                        ClientToken,
                        MaximumAccessMask,
                        ObjectTypeList,
                        cObjectTypes,
                        &DsGenericMap,
                        PrivilegeSet,
                        &PrivilegeSetLength,
                        GrantedAccesses,
                        AccessStatuses
                        );
   }
   else
   {
        ChkStatus =  NtAccessCheckByTypeResultListAndAuditAlarm(
                        &SampSamSubsystem,
                        (PVOID)Context,
                        &SampObjectInformation[ ObjectType ].ObjectTypeName,
                        &ObjectName,
                        Nt5Sd,
                        PrincipalSelfSid,
                        MaximumAccessMask,
                        AuditEventDirectoryServiceAccess,
                        0,
                        ObjectTypeList,
                        cObjectTypes,
                        &DsGenericMap,
                        ObjectCreation,
                        GrantedAccesses,
                        AccessStatuses,
                        &Context->AuditOnClose
                        );
   }


   //
   // Stop impersonating the client
   //

   if (!ARGUMENT_PRESENT(ClientToken))
   {
        SampRevertToSelf(ImpersonatingNullSession);
   }

   //
   // Use the Reverse MappingTable to compute the SAM access Mask
   //

   if (NT_SUCCESS(ChkStatus))
   {
       for(i=0;i<cObjectTypes;i++)
       {

           if ((AccessStatuses[i])==STATUS_SUCCESS)
           {

               ULONG RightsAdded=0;
               ULONG StandardRightsAdded = 0;

               //
               // in the Standard rights only for the case that represents the particular
               // object's Type. Since we build the type list we know guarentee the offset
               // of the appropriate Object type GUID for the class to be equal to the constant
               // be 0. OBJECT_CLASS_GUID_INDEX is defined to be 0

               if (i==OBJECT_CLASS_GUID_INDEX)
               {

                   StandardRightsAdded =  (GrantedAccesses[i]) & (STANDARD_RIGHTS_ALL|
                                                ACCESS_SYSTEM_SECURITY);


                   SamAccessMaskComputed |= StandardRightsAdded;

                   SampDiagPrint(NT5_ACCESS_CHECKS,
                       ("[SAMSS] Object Class GUID, Standard Rights added are %x \n",
                            StandardRightsAdded));
               }



               //
               // Lookup the Reverse Mapping Table to determine the SAM rights added from
               // the set of DS specific rights granted
               //

               //
               // Or in the SAM rights corresponding to Lower 8 bit half DS rights
               //

               RightsAdded |= (ULONG) ReverseMappingTable[i].SamSpecificRightsLo
                    [GrantedAccesses[i] & ((ULONG ) 0xFF)];


               //
               // Or in the SAM access rights corresponding Upper 8 bit half DS
               // rights
               //

               RightsAdded |= (ULONG) ReverseMappingTable[i].SamSpecificRightsHi
                    [(GrantedAccesses[i] & ((ULONG) 0xFF00))>>8];



               // 
               // if any SAM access right OR Standard Access Right is granted, 
               // set the boolean
               // Note: check RightsAdded before domain object access right 
               //       DOMAIN_CREATE_USER is granted. 
               // 

               if ((0 != RightsAdded) || (0 != StandardRightsAdded))
               {
                   fAtLeastOneSAMAccessGranted = TRUE;
               }

               //
               // Always Grant DOMAIN_CREATE Access. The Creation code will let the DS
               // do the access check, so that appropriate container etc can be included
               // in the access check evaluation
               //

               if (SampDomainObjectType==ObjectType)
               {
                   RightsAdded |= DOMAIN_CREATE_USER
                                    |DOMAIN_CREATE_GROUP|DOMAIN_CREATE_ALIAS;
               }

               //
               // Add these rights to the SAM rights we are adding
               //
               //

               SamAccessMaskComputed |=RightsAdded;


               SampDiagPrint(NT5_ACCESS_CHECKS,
                   ("[SAMSS]\t\t GUID=%x-%x-%x-%x, GrantedAccess = %x,RightsAdded = %x\n",
                            ((ULONG *) ObjectTypeList[i].ObjectType)[0],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[1],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[2],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[3],
                            GrantedAccesses[i],
                            RightsAdded
                            ));

               //
               // On user objects check if we have access to user parameters. Save this
               // around to use it when querying user parms alone if did not have read
               // account but had this.
               //

               if ((SampUserObjectType==ObjectType)
                 && (GrantedAccesses[i] & RIGHT_DS_READ_PROPERTY)
                 && (ObjectTypeList[i].ObjectType == &GUID_A_USER_PARAMETERS))
               {
                    Context->TypeBody.User.UparmsInformationAccessible = TRUE;
               }


               //
               // Determine what attributes are writable if applicable
               //
               if (AttributeMappingTable) {
                   ASSERT(ObjectType == SampUserObjectType);
                   if (GrantedAccesses[i] & RIGHT_DS_WRITE_PROPERTY) {
                       SampSetAttributeAccess(ObjectType,
                                              AttributeMappingTable[i],
                                              WriteGrantedAccessAttributes);
                   }
               }
           }
           else
           {
               //
               // Ignore the access check if did'nt pass for that GUID
               // Print the failure message in case we want to debug
               //
               //

               SampDiagPrint(NT5_ACCESS_CHECKS,
                   ("[SAMSS]\t\t GUID=%x-%x-%x-%x FAILED Status = %x\n",
                            ((ULONG *) ObjectTypeList[i].ObjectType)[0],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[1],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[2],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[3],
                            AccessStatuses[i]
                            ));
           }



       }


       //
       //  At this point we have the Passed in SAM access Mask and
       //  the available SAM rights as computed by the Access Check
       //  by type result list. 3 cases
       //      1. Client did not ask for maximum allowed bit
       //      2. Client asked for maximum allowed but also other access
       //      3. Client asked only for maximum allowed
       //


       //
       // Reset the Maximum allowed bit
       //

       Nt4SamAccessMask &= ~((ULONG) MAXIMUM_ALLOWED);

       //
       //  Use the SAM generic access Mask to compute the accesses required for each generic
       //  access bit.
       //


       RtlMapGenericMask(&Nt4SamAccessMask,Nt4SamGenericMapping);

       if (((SamAccessMaskComputed & Nt4SamAccessMask) != Nt4SamAccessMask)
        || !fAtLeastOneSAMAccessGranted )
       {

           // Case 1 and Fail
           // Case 2 and Fail
           // case 3 the GrantedAccesses (returned by NT API, such as
           //        NtAccessCheckByTypeResultListAndAuditAlarm ) can not be
           //        mapped to any SAM Access Right
           //        Or if no accesses were granted at all

           //
           // The access is that is present is less than the access that is requested
           // FAIL the access Check

           *AccessCheckStatus = STATUS_ACCESS_DENIED;
           RtlClearAllBits(WriteGrantedAccessAttributes);

       }
       else
       {

           // Case 1 and Pass
           // Case 2 and Pass
           // Case 3 certain SAM Access Right has been mapped and granted 

           //
           // Pass the access check.
           //

           *AccessCheckStatus = STATUS_SUCCESS;
           if (MaximumAllowedAskedFor)
           {
               // case 2 and pass.
               // case 3: the GrantedAccesses mapped to certain SAM Access Right 
               *GrantedAccess = SamAccessMaskComputed;
           }
           else
           {
               // case 1 and pass
               *GrantedAccess = Nt4SamAccessMask;

           }

       }
   }
   else
   {
       ULONG Status = GetLastError();
       SampDiagPrint(NT5_ACCESS_CHECKS,
         ("[SAMSS]\t\t AccessCheckAPI failed, Status = %x, cObjects = %x\n",
                Status,cObjectTypes));

       NtStatus = STATUS_ACCESS_DENIED;
       RtlClearAllBits(WriteGrantedAccessAttributes);
   }


   //
   // Print Message reagarding access check for Diagnostics of problems in
   // checked builds
   //

   SampDiagPrint(NT5_ACCESS_CHECKS,
     ("[SAMSS]: NT5 ACCESS CK FINISH: Status=%x,Granted=%x,Desired=%x,Computed=%x\n",
            *AccessCheckStatus,*GrantedAccess,Nt4SamAccessMask,
            SamAccessMaskComputed));

Error:

   if (FreeObjectName)
   {
       RtlFreeHeap(RtlProcessHeap(),0,ObjectName.Buffer);
   }

   return NtStatus;
}




//--------------------------------------------------------------------------------------------------------------
//
//        SECURITY Descriptor Convertion Functions
//
//
//




NTSTATUS
SampAddNT5ObjectAces(
    SID_ACCESS_MASK_TABLE *SidAccessMaskTable,
    ULONG   AceCount,
    POBJECT_TYPE_LIST   ObjectTypeList,
    ULONG   cObjectTypes,
    PSAMP_OBJECT    Context,
    PACL    NT5Dacl
    )
/*++

    Routine Description:

        This routines adds the appropriate ACE's to the Dacl specified in NT5Dacl,
        by using the information in the Sid Access Mask table

    Parameters:

        SidAccessMaskTable -- The Sid Access Mask Table
        AceCount           -- Count of Aces in the original NT4 Dacl that was used
                              to construct the Sid access Mask Table. This is used
                              as the maximum possible length for the Sid access mask
                              table.
        ObjectTypeList     -- The Object type list for the specified class
        Context            -- Optional parameter, gives an open context to the object.
                              Used to obtain the actual Class Id of the object.

        NT5Dacl            -- The Dacl to which the ACE's need to be added

    Return Values;

        STATUS_SUCCESS

--*/
{
    ULONG       i,j,k;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    GUID        ClassGuid;
    ULONG       ClassGuidLength=sizeof(GUID);
    ACCESS_MASK MappedAccessMask = GENERIC_ALL;

    //
    // Obtain the actual Class GUID of the object whose security descriptor is being
    // converted
    //

    if (ARGUMENT_PRESENT(Context))
    {
        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                Context->DsClassId,
                ATT_SCHEMA_ID_GUID,
                &ClassGuidLength,
                &ClassGuid
                );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        ASSERT(ClassGuidLength==sizeof(GUID));
    }


    //
    // Add Aces walking through the Sid Access Mask Table
    //

    for (i=0;i<AceCount;i++)
    {
        if (NULL!=SidAccessMaskTable[i].Sid)
        {
            //
            // Add Denied Aces for specific rights for this Sid
            //

            for (j=0;j<cObjectTypes;j++)
            {
                if (0!=SidAccessMaskTable[i].AccessDeniedMasks[j])
                {
                    GUID * ObjectTypeToUse;

                    //
                    // if a Context argument was specified then use the Class
                    // guid obtained from the schema cache for the ACCESS_OBJECT_GUID
                    // level. The GUID in the object type list actually represents the
                    // base class.
                    //

                    if ((ARGUMENT_PRESENT(Context))
                            && (ACCESS_OBJECT_GUID==ObjectTypeList[j].Level))
                    {
                        ObjectTypeToUse = &ClassGuid;
                    }
                    else
                    {
                        ObjectTypeToUse = ObjectTypeList[j].ObjectType;
                    }

                    //
                    //  Add an access denied ACE to the NT5 Dacl
                    //

                    if (!AddAccessDeniedObjectAce(
                            NT5Dacl,
                            ACL_REVISION_DS,
                            0,
                            SidAccessMaskTable[i].AccessDeniedMasks[j],
                            ObjectTypeToUse,
                            NULL,
                            SidAccessMaskTable[i].Sid
                            ))
                    {
                        NtStatus = STATUS_UNSUCCESSFUL;
                        goto Error;
                    }
                }
            }

            //
            // Add Denied Rights for standard rights for this Sid
            //

            if (0!=SidAccessMaskTable[i].StandardDeniedMask)
            {
                if (!AddAccessDeniedAce(
                        NT5Dacl,
                        ACL_REVISION_DS,
                        SidAccessMaskTable[i].StandardDeniedMask,
                        SidAccessMaskTable[i].Sid
                    ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

            //
            // Add Allowed Aces for specific rights for this Sid
            //

            for (j=0;j<cObjectTypes;j++)
            {
                if (0!=SidAccessMaskTable[i].AccessAllowedMasks[j])
                {
                    GUID * ObjectTypeToUse;

                    //
                    // if a Context argument was specified then use the Class
                    // guid for the ACCESS_OBJECT_GUID level
                    //
                    if ((ARGUMENT_PRESENT(Context))
                            && (ACCESS_OBJECT_GUID==ObjectTypeList[j].Level))
                    {
                        ObjectTypeToUse = &ClassGuid;
                    }
                    else
                    {
                        ObjectTypeToUse = ObjectTypeList[j].ObjectType;
                    }

                    if (!AddAccessAllowedObjectAce(
                                    NT5Dacl,
                                    ACL_REVISION_DS,
                                    0,
                                    SidAccessMaskTable[i].AccessAllowedMasks[j],
                                    ObjectTypeToUse,
                                    NULL,
                                    SidAccessMaskTable[i].Sid
                                    ))
                    {
                        NtStatus = STATUS_UNSUCCESSFUL;
                        goto Error;
                    }
                }
            }

            //
            // Add Allowed Rights for standard rights for this Sid
            //

            if (0!=SidAccessMaskTable[i].StandardAllowedMask)
            {
                if (!AddAccessAllowedAce(
                        NT5Dacl,
                        ACL_REVISION_DS,
                        SidAccessMaskTable[i].StandardAllowedMask,
                        SidAccessMaskTable[i].Sid
                    ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

        }
    }



    //
    // No matter what Add an Ace that gives Administrators All Access
    // This is needed as the set of DS rights is a superset of the SAM
    // rights and Administrators need to have access to all "DS
    // aspects" of the object regardless of how the SAM rights are set.
    //

    RtlMapGenericMask(
        &(MappedAccessMask),
        &DsGenericMap
        );

    if (!AddAccessAllowedAce(
            NT5Dacl,
            ACL_REVISION_DS,
            MappedAccessMask,
            *ADMINISTRATOR_SID
            ))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Adjust the size of the ACL so that we consume less disk
    //

    if (!AdjustAclSize(NT5Dacl))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }



Error:

    return NtStatus;

}




NTSTATUS
SampConvertNt5SdToNt4SD(
    IN PVOID Nt5Sd,
    IN PSAMP_OBJECT Context,
    IN PSID SelfSid,
    OUT PVOID * Nt4Sd
    )
/*++

    Routine Description

        This routine converts an NT5 DS security descriptor into an NT4
        SAM security Descriptor.

    Parameters:

        Nt5Sd -- NT5 Security Descriptor
        ObjectType -- The Sam Object Type
        SelfSid    -- Sid to use for the constant PRINCIPAL_SELF_SID
        Nt4Sd      -- Out parameter for the NT4 Descriptor

    Return Codes:
        STATUS_SUCCESS
        Other Error codes indicating type of failure
--*/
{

    BOOLEAN  StandardSd = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN Admin, ChangePasswordAllowed;
    ULONG Nt4SdLength;
    ULONG AccountRid;
    PACL Dacl = NULL;
    ULONG AceCount = 0;
    SAMP_OBJECT_TYPE ObjectType = Context->ObjectType;


    Dacl = GetDacl(Nt5Sd);

    if ((NULL==Dacl)
        || (GetAceCount(Dacl)==0))
    {
        //
        // If the Dacl was NULL or Ace is zero in the Dacl
        // there is no need to convert as in the conversion
        // we basically convert the Aces in the Dacl
        //

        ULONG   Len;

        Len = GetSecurityDescriptorLength(Nt5Sd);
        *Nt4Sd = MIDL_user_allocate(Len);

        if (NULL==*Nt4Sd)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(*Nt4Sd,Nt5Sd,Len);
    }

    else
    {

        switch(ObjectType)
        {

            //
            // For Domain and Server objects, NT4 SAM does not allow any customization
            // of the security descriptor ( except through SetSecurityObject ),
            // so directly return the standard NT4 descriptor built by bldsam3
            //

        case SampDomainObjectType:

            NtStatus = SampBuildNt4DomainProtection(
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;

        case SampServerObjectType:


            NtStatus = SampBuildNt4ServerProtection(
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;

            //
            // For group / alias objects we are intersted in finding wether the security
            // descriptor of interest is Admin or not. So call the reverse membership
            // routine and see if it is a member of any administrators Alias
            //

        case SampGroupObjectType:
        case SampAliasObjectType:


            NtStatus = SampSplitSid(SelfSid,NULL, &AccountRid);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfAdmin(SelfSid, & Admin);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Call the NT4 Samp routine to build the security descriptor
            //
            //

            NtStatus = SampGetNewAccountSecurityNt4(
                            ObjectType,
                            Admin,
                            TRUE,
                            FALSE,
                            AccountRid,
                            Context->DomainIndex,
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;


            //
            // For User objects we need to know wether change password is allowed or
            // not apart from Admin / Non Admin
            //

        case SampUserObjectType:


            NtStatus = SampSplitSid(SelfSid,NULL, &AccountRid);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfAdmin(SelfSid, & Admin);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfChangePasswordAllowed(
                            Nt5Sd,
                            SelfSid,
                            &ChangePasswordAllowed
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Call the NT4 Samp routine to build the security descriptor
            //
            //

            NtStatus = SampGetNewAccountSecurityNt4(
                            ObjectType,
                            Admin,
                            TRUE,
                            FALSE,
                            AccountRid,
                            Context->DomainIndex,
                            Nt4Sd,
                            &Nt4SdLength
                            );

            if (!NT_SUCCESS(NtStatus))
                goto Error;

            if (!ChangePasswordAllowed && !Admin)
            {
                ACE * UsersAce;
                PACL Nt4Dacl;

                Nt4Dacl = GetDacl(*Nt4Sd);
                if (NULL!=Nt4Dacl)
                {
                    //
                    // Get the 4th ACE, which corresponds to Users Sid
                    //

                    UsersAce = GetAcePrivate(Nt4Dacl,3);
                    if (NULL!=UsersAce)
                    {
                        ACCESS_MASK * SamAccessMask;

                        SamAccessMask =
                                &(((ACCESS_ALLOWED_ACE *) UsersAce)
                                    ->Mask);

                        (*SamAccessMask)&=~((ACCESS_MASK) USER_CHANGE_PASSWORD);
                    }

                    //
                    // Get the first Ace which corresponds to World Sid
                    //
                    UsersAce = GetAcePrivate(Nt4Dacl,0);
                    if ((NULL!=UsersAce) && (RtlEqualSid(*WORLD_SID,SidFromAce(UsersAce))))
                    {
                        ACCESS_MASK * SamAccessMask;

                        SamAccessMask =
                                &(((ACCESS_ALLOWED_ACE *) UsersAce)
                                    ->Mask);

                        (*SamAccessMask)&=~((ACCESS_MASK) USER_CHANGE_PASSWORD);
                    }



                }
            }
            break;

        default:

            ASSERT(FALSE);
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;

        }
    }


Error:

     SampDiagPrint(SD_CONVERSION,("[SAMSS]  Leaving NT5 To NT4 Conversion, Status= %0x\n",NtStatus));

     IF_SAMP_GLOBAL(SD_CONVERSION)
     {
         IF_SAMP_GLOBAL(SD_DUMP)
         {
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT5 Security Descriptor = \n"));
             DumpSecurityDescriptor(Nt5Sd);
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT4 Security Descriptor = \n"));
             DumpSecurityDescriptor(*Nt4Sd);
         }
     }

 return NtStatus;

}

NTSTATUS
SampConvertNt4SdToNt5Sd(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN  PSAMP_OBJECT Context OPTIONAL,
    OUT PVOID * Nt5Sd
    )

/*++

    Routine Description

        This is the entry point routine for a generic NT4 SAM
        to NT5 SD

    Parameters

        Nt4Sd      -- The NT4 Security descriptor
        ObjectType -- The SAM object Type
        Nt5Sd      -- The Nt5 Security Descriptor

    Return Values

  --*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG   NtSdLength;
    SECURITY_DESCRIPTOR_CONTROL Control;
    ULONG    Revision;
    ULONG    DsClassId;
    BOOLEAN  StandardSd;
    BOOLEAN  ChangePassword, Admin;



    SampDiagPrint(SD_CONVERSION,("[SAMSS] Performing NT4 To NT5 Coversion\n"));


    //
    // Do Some Parameter Validations
    //

    if (!RtlValidSecurityDescriptor(Nt4Sd))
    {
        return STATUS_INVALID_PARAMETER;
    }

    NtStatus = RtlGetControlSecurityDescriptor(
                    Nt4Sd,
                    &Control,
                    &Revision
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    if (Revision > SECURITY_DESCRIPTOR_REVISION)
        return STATUS_INVALID_PARAMETER;

    //
    // Get the Class Id
    //

    if (ARGUMENT_PRESENT(Context))
    {
        DsClassId = Context->DsClassId;
    }
    else
    {
        DsClassId = SampDsClassFromSamObjectType(ObjectType);
    }

    //
    // Identify if the security descriptor is a standard one,
    // in which case retrieve the corresponding standard one
    //

    NtStatus = SampRecognizeStandardNt4Sd(
                    Nt4Sd,
                    ObjectType,
                    DsClassId,
                    Context,
                    &ChangePassword,
                    &Admin,
                    Nt5Sd
                    );


Error:

     SampDiagPrint(SD_CONVERSION,("[SAMSS]  Leaving NT4 To NT5 Conversion, Status= %0x\n",NtStatus));

     IF_SAMP_GLOBAL(SD_CONVERSION)
     {
         IF_SAMP_GLOBAL(SD_DUMP)
         {
             SampDiagPrint(SD_CONVERSION,("[SAMSS] ObjectType = %d\n",ObjectType));
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT4 Security Descriptor = \n"));
             DumpSecurityDescriptor(Nt4Sd);
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT5 Security Descriptor = \n"));
             DumpSecurityDescriptor(*Nt5Sd);
         }
     }


    return NtStatus;
}

NTSTATUS
SampRecognizeStandardNt4Sd(
    IN PVOID   Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG DsClassId,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT BOOLEAN *ChangePassword,
    OUT BOOLEAN *Admin,
    OUT PVOID * Nt5Sd
    )
/*++

  Routine Description:

    Tries to recognize a standard NT4 Sd and returns the NT5 Sd if the
    recognition. Recognition focuses on determining the Admin and change password
    nature of the object

  Parameters

        Nt4Sd       -- NT4 SAM SD
        ObjectType  -- SAM object Type
        DsClassId   -- The DS Class Id
        Context     -- Optional In parameter to the context
        ChangePassword -- For user objects indicates that self can change password
        Admin       -- user/group is /was a member of administrators.
        Nt5Sd       -- if Nt4Sd was a standard security descriptor, then in
                       that case return the corresponding NT5 Security
                       descriptor

  Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
--*/
{

    ULONG   AceCount;
    PACL    Nt4Dacl;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG   Nt5SdLength;
    ULONG   DefaultSecurityDescriptorLength;
    PSECURITY_DESCRIPTOR DefaultSecurityDescriptor=NULL;
    PSID    OwnerSid = NULL;
    BOOLEAN StandardSd = TRUE;

    //
    // Initialize return values
    //

    *Nt5Sd = NULL;
    *ChangePassword = TRUE;
    *Admin = FALSE;


    //
    // Using the Sam global flag we can always
    // enable the full conversion. This is useful to test
    // the full conversion routine.
    //

    IF_SAMP_GLOBAL(FORCE_FULL_SD_CONVERSION)
    {
        return STATUS_SUCCESS;
    }                 

    //
    // Get the Default Security Descriptor For Class
    //

    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                    DsClassId,
                    &DefaultSecurityDescriptorLength,
                    TRUE, // Trusted Client
                    &DefaultSecurityDescriptor
                    );
    
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Get the Dacl and walk ACL by ACL
    // to select the correct NT5 security
    // Descriptor
    //

    Nt4Dacl = GetDacl(Nt4Sd);


    if ((NULL==Nt4Dacl)
        ||(GetAceCount(Nt4Dacl)==0))
    {

        //
        // If the Dacl was NULL then No ACL conversion
        // is required
        //

        NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                        GetOwner(Nt4Sd), // Pass through Ownner
                        GetGroup(Nt4Sd), // Pass through Group
                        NULL,            // Set Dacl to NULL
                        GetSacl(DefaultSecurityDescriptor), // Set Sacl To Schema Default
                        &Nt5SdLength,
                        Nt5Sd            // Get the new security descriptor
                        );
    }
    else
    {

        //
        // We have a Non Null Dacl. Will need to walk the DACL and
        // find out whether it matches the standard security descriptor
        //

        switch(ObjectType)
        {

        case SampDomainObjectType:
        case SampServerObjectType:

            //
            // For Domain and Server object's we completely ignore the
            // the Dacl on the NT4 object, and proceed to create a
            // a standard Dacl of our own
            //

            break;

        case SampGroupObjectType:

            //
            // We need to distinguish between Admin and Non Admin case
            //

            SampRecognizeNT4GroupDacl(Nt4Dacl, &StandardSd, Admin);
            break;

        case SampAliasObjectType:

            //
            // We need to distinguish between Admin and Non Admin case
            //

            SampRecognizeNT4AliasDacl(Nt4Dacl, &StandardSd, Admin);
            break;

        case SampUserObjectType:

            //
            // We need to distinguish between Admin, Non Admin, Change Password and Non Change
            // Password in non admin case. Also for machine accounts we try to grab the owner
            //
            SampRecognizeNT4UserDacl(Nt4Dacl, Context, &StandardSd, Admin, ChangePassword, &OwnerSid);
            break;

        default:

            ASSERT(FALSE && "Invalid Object Type");
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        //
        // Get the dacl from the schema, but remember, we need to
        // preserve the Admin and Change Password nature across
        // an NT4 upgrade. The standard schema default is for the non
        // admin and change password allowed case
        //
        
        if (!(*Admin) && (*ChangePassword))
        {
            //
            // Reset to schema default
            //

            NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                            (NULL!=OwnerSid)?OwnerSid:GetOwner(Nt4Sd), // Pass through Ownner
                            GetGroup(Nt4Sd), // Pass through Group
                            GetDacl(DefaultSecurityDescriptor), // Set Dacl to NULL
                            GetSacl(DefaultSecurityDescriptor), // Set Sacl To Schema Default
                            &Nt5SdLength,
                            Nt5Sd            // Get the new security descriptor
                            );
        }
        else
        { 
            //
            // Build the equivalent NT5 Protections
            //

            NtStatus = SampBuildEquivalentNt5Protection(
                            ObjectType,
                            *Admin,
                            *ChangePassword,
                            GetOwner(Nt4Sd), // Pass Through Owner
                            GetGroup(Nt4Sd), // Pass Through Group
                            GetSacl(DefaultSecurityDescriptor), // Reset Sacl To Schema Default Sacl
                            Context,
                            Nt5Sd,
                            &Nt5SdLength
                            );
        }

    }

Error:

    if (NULL!=DefaultSecurityDescriptor)
    {
        MIDL_user_free(DefaultSecurityDescriptor);
        DefaultSecurityDescriptor = NULL;
    }

    return NtStatus;

}

VOID
SampRecognizeNT4GroupDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 Group Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL

      Return Values:

            None
--*/
{
    if (SampMatchNT4Aces(NT4GroupAdminTable,ARRAY_COUNT(NT4GroupAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
    }
    else if (SampMatchNT4Aces(NT4GroupNormalTable,ARRAY_COUNT(NT4GroupNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
    }
    else
    {
        *Standard = FALSE;
    }
}

VOID
SampRecognizeNT4AliasDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 Alias Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL

      Return Values:

            None
--*/
{

    if (SampMatchNT4Aces(NT4AliasAdminTable,ARRAY_COUNT(NT4AliasAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
    }
    else if (SampMatchNT4Aces(NT4AliasNormalTable,ARRAY_COUNT(NT4AliasNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
    }
    else
    {
        *Standard = FALSE;
    }
}


VOID
SampRecognizeNT4UserDacl(
    PACL    NT4Dacl,
    PSAMP_OBJECT Context,
    BOOLEAN *Standard,
    BOOLEAN *Admin,
    BOOLEAN *ChangePassword,
    OUT PSID * OwnerSid
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 User Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Context -- Pointer to SAMP_OBJECT, used to get the RID of itself.
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL
            ChangePassword TRUE is returned here if user had change password rights
            OwnerOfMachine If the account was created through SeMachineAccount privilege then
                           get the owner of the machine.

      Return Values:

            None
--*/
{

    //
    // Initialize the return value
    //
    *OwnerSid = NULL;

    if (SampMatchNT4Aces(NT4UserAdminTable,ARRAY_COUNT(NT4UserAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
        *ChangePassword = TRUE;
    }
    else if (SampMatchNT4Aces(NT4UserNormalTable,ARRAY_COUNT(NT4UserNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
        *ChangePassword = TRUE;
    }
    else if ((SampMatchNT4Aces(NT4UserNoChangePwdTable, ARRAY_COUNT(NT4UserNoChangePwdTable),NT4Dacl)) ||
                (SampMatchNT4Aces(NT4UserNoChangePwdTable2, ARRAY_COUNT(NT4UserNoChangePwdTable2),NT4Dacl)))
    {
        *Standard = TRUE;
        *Admin = FALSE;
        *ChangePassword = FALSE;
    }
    else if (SampMatchNT4Aces(NT4UserRestrictedAccessTable, ARRAY_COUNT(NT4UserRestrictedAccessTable),NT4Dacl))
    {
        ACE * Ace = NULL;
        ULONG i;

        *Standard = TRUE;
        *Admin = FALSE;
        *ChangePassword = TRUE;

        for (i=0;i<ARRAY_COUNT(NT4UserRestrictedAccessTable);i++)
        {
            Ace = GetAcePrivate(NT4Dacl,i);
            if ((NULL!=Ace) && ((AccessMaskFromAce(Ace)) == (USER_WRITE|DELETE|USER_FORCE_PASSWORD_CHANGE)))
            {
                NTSTATUS NtStatus = STATUS_SUCCESS;
                PSID     AccountSid = NULL;
                PSID     TempSid = NULL;

                // Get the SID of the owner
                TempSid = SidFromAce(Ace);

                //
                // Only do the check when Context is presented.
                //
                if (ARGUMENT_PRESENT(Context))
                {
                    //
                    // If this is a machine account and DomainSidForNt4SdConversion
                    // is not NULL, then compare the Sid of the owner and the
                    // Sid of the machine account itself, they should not be
                    // the same. (DsClassId should have been set correctly already,
                    // DomainSidForNt4SdConversion is only been set during dcpromo
                    // time.)
                    //
                    //
                    if (CLASS_COMPUTER == Context->DsClassId &&
                        (NULL != Context->TypeBody.User.DomainSidForNt4SdConversion)
                       )
                    {
                        // Create the SID of this machine account itself
                        NtStatus = SampCreateFullSid(
                                        Context->TypeBody.User.DomainSidForNt4SdConversion, // Domain Sid
                                        Context->TypeBody.User.Rid,     // Rid
                                        &AccountSid
                                        );

                        if (NT_SUCCESS(NtStatus))
                        {
                            //
                            // If the Sid of the owner and the Sid of this
                            // machine account are not the same, then set the
                            // OwnerSid to the SID in the DACL.
                            //
                            if ( !RtlEqualSid(TempSid, AccountSid) )
                            {
                                KdPrintEx((DPFLTR_SAMSS_ID,
                                           DPFLTR_INFO_LEVEL,
                                           "Machine Account's Owner has been set to according to the NT4 DACL.\n"));

                                Context->TypeBody.User.PrivilegedMachineAccountCreate = TRUE;
                                *OwnerSid = TempSid;
                            }

                            MIDL_user_free(AccountSid);
                        }
                    }
                }
                break;
            } // end of if statement
        } // end of for statement
    }
    else
    {
        *Standard = FALSE;
    }
}


BOOLEAN
SampMatchNT4Aces(
    NT4_ACE_TABLE *AceTable,
    ULONG         cEntriesInAceTable,
    PACL          NT4Dacl
    )
/*++

    Given a table structure describing the Aces in a standard NT4 Dacl,
    and the NT4 Ace, this routine tries to find wether the given standard
    table structure matches the Nt4Dacl supplied. The Aces are walked in both
    forward and reverse order, as NT4 replication reverses the order of Aces.

    The principal self Sid in the Ace table is treated like a wildcarded Sid.

    Parameters:

        AceTable - A table describing the NT4 Aces in the table
        cEntriesinAceTable - Provides the number of entries in the Ace Table
        NT4Dacl -- The NT4 Dacl,

    Return Values

        TRUE or FALSE depending upon the Dacl matched or not
--*/
{
    ULONG   AceCount;
    ACE     *Ace[4];
    BOOLEAN Match = FALSE;
    ULONG   i;


    AceCount = GetAceCount(NT4Dacl);

    if (AceCount>ARRAY_COUNT(Ace))
    {
        return FALSE;
    }

    if (cEntriesInAceTable==AceCount)
    {

        //
        // Candidate for a match
        //

        BOOL forwardMatch = TRUE;
        BOOL reverseMatch = FALSE;

        //
        // Get hold of interesting ACES
        //

        for (i=0;i<cEntriesInAceTable;i++)
        {
            Ace[i] = GetAcePrivate(NT4Dacl,i);
        }

        //
        // Check wether it is a standard ACE, by comapring ACE by ACE, going forward
        //

        for (i=0;i<cEntriesInAceTable;i++)
        {
            if (
                !( 
                   (NULL != Ace[i]) 
                &&
                   (IsAccessAllowedAce(Ace[i]))
                && (
                     (RtlEqualSid(*(AceTable[i].Sid),SidFromAce(Ace[i])))
                     // Prinicpal self Sid in table matches any Sid
                     || (RtlEqualSid(*(AceTable[i].Sid), *PRINCIPAL_SELF_SID))
                   )
                && (AceTable[i].AccessMask == AccessMaskFromAce(Ace[i]))
                )
               )
            {
                forwardMatch = FALSE;
                break;
            }
        }

        //
        // NT4 Replication Reverses order of Aces. Check wether by reversing
        // we are able to match
        //

        if (!forwardMatch)
        {
            reverseMatch = TRUE;

            for (i=0;i<cEntriesInAceTable;i++)
            {
                ULONG   TablIndx = cEntriesInAceTable-i-1;

                if (
                    !(
                       (NULL != Ace[i])
                    && 
                       (IsAccessAllowedAce(Ace[i]))
                    && (
                        (RtlEqualSid(*(AceTable[TablIndx].Sid),SidFromAce(Ace[i])))
                        // Prinicpal self Sid in table matches any Sid
                        || (RtlEqualSid(*(AceTable[TablIndx].Sid), *PRINCIPAL_SELF_SID))
                       )
                    && (AceTable[TablIndx].AccessMask == AccessMaskFromAce(Ace[i]))
                    )
                   )
                {
                    reverseMatch = FALSE;
                    break;
                }
            }
        }

        if (forwardMatch || reverseMatch)
        {
            Match = TRUE;
        }
    }

    return Match;
}




NTSTATUS
SampCheckIfAdmin(
    PSID SidOfPrincipal,
    BOOLEAN * Admin
    )
/*++

  Routine Description:

        Checks to see if SidOfPrincipal is member of administrators alias


  Parameters

    SidOfPrincipal  - Sid of principal
    Admin           - bool returning Admin or non Admin

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *DsNameOfPrincipal = NULL;
    PSID   *DsSids = NULL;

    *Admin = FALSE;

    if (RtlEqualSid(SidOfPrincipal,*ADMINISTRATOR_SID))
    {

        //
        // Admin Alias itself is passed in. Getting reverse
        // membership for it will get nothing back
        //

        *Admin = TRUE;
    }
    else if (SampLookupAclConversionCache(SidOfPrincipal,Admin))
    {
        //
        // ACL Conversion Cache Lookup Succeed, the Admin bit
        // would now be set depending upon saves state in cache
        //

    }
    else
    {


        //
        // Check wether the passed in SID itself an administrator Sid
        //



        NtStatus = SampDsObjectFromSid(
                        SidOfPrincipal,
                        &DsNameOfPrincipal
                        );
        if (NT_SUCCESS(NtStatus))
        {
            ULONG Count;
            ULONG Index;

            NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // NT5 To NT4 Descriptor Conversion requests No G.C This is because
            // the only real NT4 Client who wants to query the Security Descriptor
            // is NT4 Replication, and in a mixed domain we should not have
            // NT5 style cross domain memberships.
            //

            NtStatus = SampDsGetReverseMemberships(
                            DsNameOfPrincipal,
                            SAM_GET_MEMBERSHIPS_TWO_PHASE|SAM_GET_MEMBERSHIPS_NO_GC,
                            &Count,
                            &DsSids);

            if (NT_SUCCESS(NtStatus))
            {
                for (Index=0;Index<Count;Index++)
                {
                    ULONG Rid;

                    NtStatus = SampSplitSid(
                                    DsSids[Index],
                                    NULL,
                                    &Rid
                                    );
                    if ((NT_SUCCESS(NtStatus))
                        && (DOMAIN_ALIAS_RID_ADMINS == Rid))
                    {
                        *Admin=TRUE;
                         break;
                    }


                }

                //
                // O.K Now add this result to the cache
                //

                SampAddToAclConversionCache(SidOfPrincipal,(*Admin));

            }
        }
        else if (STATUS_NOT_FOUND==NtStatus)
        {
            //
            // We could not find this SID in the DS. So apparently
            // it is not a member of anything, so it is not an
            // administrator
            //

            *Admin = FALSE;
            NtStatus = STATUS_SUCCESS;
        }
    }

Error:

    if (NULL!=DsSids)
        THFree(DsSids);

    if (DsNameOfPrincipal) {
        MIDL_user_free(DsNameOfPrincipal);
    }

    return NtStatus;
}





NTSTATUS
SampCheckIfChangePasswordAllowed(
    IN  PSECURITY_DESCRIPTOR Nt5Sd,
    IN  PSID     UserSid,
    OUT  BOOLEAN *ChangePasswordAllowed
    )
/*++

    Checks wether Password Change is allowed for an NT5 Sd
    No User Sid need be passed , as PRINCIPAL_SELF_SID denotes user

    Parameters

        Nt5Sd  -- Nt5 Security descriptor
        UserSid -- The Sid of the user.
        ChangePasswod -- Boolean returning password change

    Return Values

        STATUS_SUCCESS

 --*/

{
    PACL Dacl= NULL;

    //
    // Initialize Change Password Allowed to FALSE
    //
    *ChangePasswordAllowed=FALSE;
    Dacl = GetDacl(Nt5Sd);
    if (NULL!=Dacl)
    {
        ULONG AceCount;
        ULONG Index;

        //
        // Walk each ACE and try to find a deny/allowed ACE that denies/grants the right
        // to change password for either world, user's sid, or principal self SID.
        // This is the same algorithm used by win2k UI to figure out if a given
        // win2k ACL on a user object allows change password right on that user object.
        //

        AceCount = GetAceCount(Dacl);
        for (Index=0;Index<AceCount;Index++)
        {
            ACE * Ace;

            Ace = GetAcePrivate(Dacl,Index);

            //
            // Object ACE that has the control access right for
            // User Change Password
            //

            if (
                  (NULL!=Ace)
               && (IsAccessAllowedObjectAce(Ace))
               && (
                    (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                  )
               && (NULL!=RtlObjectAceObjectType(Ace))
               && (memcmp(RtlObjectAceObjectType(Ace),
                            &(GUID_CONTROL_UserChangePassword),
                            sizeof(GUID))==0)
               )
            {
                 *ChangePasswordAllowed = TRUE;
                 break;
            }

            //
            // Access Allowed Ace for DS control access
            //

            else if ((NULL!=Ace)
                && (IsAccessAllowedAce(Ace))
                && (
                      (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                   )
                && ((AccessMaskFromAce(Ace))& RIGHT_DS_CONTROL_ACCESS))
            {
                *ChangePasswordAllowed = TRUE;
                break;
            }

            //
            // Access denied Object ACE for DS control access
            //
              if (
                  (NULL!=Ace)
               && (IsAccessDeniedObjectAce(Ace))
               && (
                    (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                  )
               && (NULL!=RtlObjectAceObjectType(Ace))
               && (memcmp(RtlObjectAceObjectType(Ace),
                            &(GUID_CONTROL_UserChangePassword),
                            sizeof(GUID))==0)
               )
            {
                 *ChangePasswordAllowed = FALSE;
                 break;
            }

            //
            // Access Allowed Ace for DS control access
            //

            else if ((NULL!=Ace)
                && (IsAccessDeniedAce(Ace))
                && (
                      (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                   )
                && ((AccessMaskFromAce(Ace))& RIGHT_DS_CONTROL_ACCESS))
            {
                *ChangePasswordAllowed = FALSE;
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildEquivalentNt5Protection(
    SAMP_OBJECT_TYPE ObjectType,
    BOOLEAN Admin,
    BOOLEAN ChangePassword,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Sacl,
    IN PSAMP_OBJECT Context OPTIONAL,
    PSECURITY_DESCRIPTOR * Nt5Sd,
    PULONG  Nt5SdLength
    )
/*++

  Routine Description:

    Given the Admin and Change Password Nature of a security principal, SampBuildNT5Protection
        builds a standard NT5 Security descriptor, that most closely matches the corresponding standard
        NT4 Security Descriptor, with the same Admin and Change Password Nature.

  Parameters:

    ObjectType          -- SAM object type
    Admin                       -- Indicates Admin. This bit is ignored at present.
    ChangePassword  -- For user objects wether user has right to change password
    OwnerSId        -- Owner
    GroupSid        -- Group
    Sacl            -- SystemAcl
    Nt5SD           -- Nt5SD , just built
    Nt5SdLength     -- Length of the Nt5 Sd

  Return Values

     STATUS_SUCCESS -- Upon Successful Completion
     Other Error codes to return proper Failure indication upon Failure

--*/
{
    NTSTATUS NtStatus;
    ULONG   Index =0;
    SECURITY_DESCRIPTOR SdAbsolute;
    CHAR    SaclBuffer[MAX_ACL_SIZE];
    CHAR    DaclBuffer[MAX_ACL_SIZE];
    PACL    SaclToSet = (ACL *) SaclBuffer;
    PACL    Dacl = (ACL *) DaclBuffer;
    ACE_TABLE *AceTableToUse = NULL;
    ULONG     cEntriesInAceTable = 0;
    ULONG     SdLength;

    //
    // Create the security descriptor
    //
    *Nt5Sd = NULL;
    *Nt5SdLength = 0;
    if (!InitializeSecurityDescriptor(&SdAbsolute,SECURITY_DESCRIPTOR_REVISION))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Create Dacl
    //

    if (!InitializeAcl(Dacl,sizeof(DaclBuffer),ACL_REVISION_DS))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }



    //
    // Set the owner, default the owner to administrators alias
    //

    if (NULL==OwnerSid)
    {
        OwnerSid = *ADMINISTRATOR_SID;  // Administrator is the default owner
    }

    if (!SetSecurityDescriptorOwner(&SdAbsolute,OwnerSid,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Set the group, default the group to administrators alias
    //

    if (NULL==GroupSid)
    {
        GroupSid = *ADMINISTRATOR_SID;
    }

    if (!SetSecurityDescriptorGroup(&SdAbsolute,GroupSid,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Get the System ACL to Set
    //

    if (NULL!=Sacl)
    {
        SaclToSet = Sacl;
    }
    else
    {
        //
        // Build a default system ACL
        //
        //

        //
        // Create the SACL in it. Set the SAcl revision to ACL_REVISION_DS.
        //

        if (!InitializeAcl(SaclToSet,sizeof(SaclBuffer),ACL_REVISION_DS))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        NtStatus = AddAuditAccessAce(
                    SaclToSet,
                    ACL_REVISION_DS,
                    STANDARD_RIGHTS_WRITE|
                    DELETE |
                    WRITE_DAC|
                    ACCESS_SYSTEM_SECURITY,
                    *WORLD_SID,
                    TRUE,
                    TRUE
                    );

         if (!NT_SUCCESS(NtStatus))
            goto Error;

         if (!AdjustAclSize(SaclToSet))
         {
             NtStatus = STATUS_UNSUCCESSFUL;
             goto Error;
         }
    }

    //
    // Set the Sacl
    //

    if (!SetSecurityDescriptorSacl(&SdAbsolute,TRUE,SaclToSet,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Get the Dacl to Set
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
         AceTableToUse = DomainAceTable;
         cEntriesInAceTable = ARRAY_COUNT(DomainAceTable);
         break;

    case SampServerObjectType:
         AceTableToUse = ServerAceTable;
         cEntriesInAceTable = ARRAY_COUNT(ServerAceTable);
         break;

    case SampGroupObjectType:
    case SampAliasObjectType:

         if (!Admin)
         {
            AceTableToUse = GroupAceTable;
            cEntriesInAceTable = ARRAY_COUNT(GroupAceTable);
         }
         else
         {
            AceTableToUse = GroupAdminAceTable;
            cEntriesInAceTable = ARRAY_COUNT(GroupAdminAceTable);
         }

         break;


    case SampUserObjectType:
         if ((!ChangePassword) && (!Admin))
         {
             AceTableToUse = UserNoPwdAceTable;
             cEntriesInAceTable = ARRAY_COUNT(UserNoPwdAceTable);
         }
         else if (!Admin)
         {
            AceTableToUse = UserAceTable;
            cEntriesInAceTable = ARRAY_COUNT(UserAceTable);
         }
         else
         {
            AceTableToUse = UserAdminAceTable;
            cEntriesInAceTable = ARRAY_COUNT(UserAdminAceTable);
         }


         break;

    default:

        ASSERT(FALSE);
        break;
    }

    NtStatus = SampCreateNT5Dacl(
                  AceTableToUse,
                  cEntriesInAceTable,
                  Context,
                  Dacl
                  );

    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Set the Dacl
    //

    if (!SetSecurityDescriptorDacl(&SdAbsolute,TRUE,Dacl,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now convert this security descriptor to self relative form
    //

    SdLength =  GetSecurityDescriptorLength(&SdAbsolute);
    *Nt5Sd = MIDL_user_allocate(SdLength);
    if (NULL==*Nt5Sd)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    if (!MakeSelfRelativeSD(&SdAbsolute,*Nt5Sd,&SdLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        if (*Nt5Sd)
        {
            MIDL_user_free(*Nt5Sd);
            *Nt5Sd = NULL;
        }
    }

    *Nt5SdLength = SdLength;

Error:

    return NtStatus;
}


NTSTATUS
SampCreateNT5Dacl(
    ACE_TABLE * AceTable,
    ULONG       cEntries,
    PSAMP_OBJECT Context OPTIONAL,
    PACL        Dacl
    )
/*

  Routine Description:

    THis routine walks through the ACE table and creates a Dacl,
    as specified in the ACE Table

  Parameters:

    AceTable -- The Ace Table to use for knowledge about Aces in the Dacl
    cEntires -- The number of entries in the Ace table
    Context  -- If an Open context is provided then this context is used to
                subsutitue the Class Guid of the actual object by fetching it
                from the DS. Else the one in the ACE table is used, which corresponds
                to the class GUID of the Base object Type. Each Ace table entry has
                a boolean field which tells this function wether the GUID in the
                corresponding entry refers to the class GUID.
    Dacl     -- The constructed Dacl is returned in here

  Return Values

    STATUS_SUCCESS
    Other Error codes upon failure

  */
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    Index = 0;
    ULONG     ClassGuidLength=sizeof(GUID);
    GUID      ClassGuid;
    GUID      *ClassGuidInAceTable;

    //
    // Obtain the actual Class GUID of the object whose security descriptor is being
    // converted. Also obtain the default class GUID in the Ace Table. Before adding
    // the Aces we will substitute the class guid of the actual class.
    //

    if (ARGUMENT_PRESENT(Context))
    {
        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                        Context->DsClassId,
                        ATT_SCHEMA_ID_GUID,
                        &ClassGuidLength,
                        &ClassGuid
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }



    for (Index=0;Index<cEntries;Index++)
    {
        ULONG MappedAccessMask;

        MappedAccessMask =  AceTable[Index].AccessMask;

        RtlMapGenericMask(
            &(MappedAccessMask),
            &DsGenericMap
            );

        switch(AceTable[Index].AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if (!AddAccessAllowedAce(
                            Dacl,
                            ACL_REVISION_DS,
                            MappedAccessMask,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if (!AddAccessDeniedAce(
                            Dacl,
                            ACL_REVISION_DS,
                            MappedAccessMask,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }
            break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:


            if (!AddAccessAllowedObjectAce(
                            Dacl,
                            ACL_REVISION_DS,
                            0,
                            MappedAccessMask,
                            ((ARGUMENT_PRESENT(Context))&& AceTable[Index].IsObjectGuid)?
                               (&ClassGuid):(GUID *) AceTable[Index].TypeGuid,
                            (GUID *) AceTable[Index].InheritGuid,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if (!AddAccessDeniedObjectAce(
                            Dacl,
                            ACL_REVISION_DS,
                            0,
                            MappedAccessMask,
                            ((ARGUMENT_PRESENT(Context))&& AceTable[Index].IsObjectGuid)?
                                (&ClassGuid):((GUID *) AceTable[Index].TypeGuid),
                            (GUID *) AceTable[Index].InheritGuid,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            break;

        default:
            break;
        }
    }

 //
 // Adjust the size of the ACL so that we consume less disk
 //

 if (!AdjustAclSize(Dacl))
 {
     NtStatus = STATUS_UNSUCCESSFUL;
 }

Error:

    return NtStatus;
}

NTSTATUS
SampGetDefaultSecurityDescriptorForClass(
    ULONG   DsClassId,
    PULONG  SecurityDescriptorLength,
    BOOLEAN TrustedClient,
    PSECURITY_DESCRIPTOR    *SecurityDescriptor
    )
/*++

    SampGetDefaultSecurityDescriptorForClass queries the Schema to obtain the default security
    descriptor for the class. It tries to obtain the owner and group fields by impersonating
    and grabbing the user's Sid. If the owner and group fields is not present or if it is a
    trusted client then the Administrator's SID is used instead.

    Parameters:

        DsClassId                The DS Class Id of the class whose security descriptor
                                 we desire
        SecurityDescriptorLength The length of the security descriptor is returned in here
        TrustedClient            Indicates Trusted Clients. No impersonation is done for
                                 trusted clients.
        SecurityDescriptor       The Security Descriptor that we want.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PTOKEN_OWNER Owner=NULL;
    PTOKEN_PRIMARY_GROUP PrimaryGroup=NULL;
    PSECURITY_DESCRIPTOR TmpSecurityDescriptor = NULL;
    ULONG                TmpSecurityDescriptorLength = 0;
    

    ASSERT(NULL!=SecurityDescriptor);
    ASSERT(NULL!=SecurityDescriptorLength);

    //
    // Query the schema asking for default security descriptor. Determine how much
    // memory to alloc
    //

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    NtStatus = SampGetClassAttribute(
                                    DsClassId,
                                    ATT_DEFAULT_SECURITY_DESCRIPTOR,
                                    SecurityDescriptorLength,
                                    NULL
                                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {

        //
        // Allocate a buffer for the security descriptor
        //

        *SecurityDescriptor = MIDL_user_allocate(*SecurityDescriptorLength);
        if (NULL==*SecurityDescriptor)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                                        DsClassId,
                                        ATT_DEFAULT_SECURITY_DESCRIPTOR,
                                        SecurityDescriptorLength,
                                        *SecurityDescriptor
                                        );
    }
    else
    {
        //
        // Case where there is no security descriptor in the schema
        //

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(NtStatus))
    {
        
        //
        // For a Non Trusted Client obtain the User and Primary
        // group Sid by Querying the Token
        //

        if (!TrustedClient)
        {
            NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                            &Owner,
                            &PrimaryGroup
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }
        
        //
        // Make a new security descriptor , setting the owner and the group
        // to that of
        //

        NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                        (Owner)?Owner->Owner:SampDomainAdminsGroupSid,
                        (PrimaryGroup)?PrimaryGroup->PrimaryGroup:SampDomainAdminsGroupSid,
                        GetDacl(*SecurityDescriptor),
                        GetSacl(*SecurityDescriptor),
                        &TmpSecurityDescriptorLength,
                        &TmpSecurityDescriptor
                        );

        if (NT_SUCCESS(NtStatus))
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = TmpSecurityDescriptor;
            *SecurityDescriptorLength = TmpSecurityDescriptorLength;
        }

    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*SecurityDescriptor)
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = NULL;
        }
        *SecurityDescriptorLength = 0;
    }

    if (Owner)
        MIDL_user_free(Owner);

    if (PrimaryGroup)
        MIDL_user_free(PrimaryGroup);
    
    return NtStatus;
}


NTSTATUS
SampMakeNewSelfRelativeSecurityDescriptor(
    PSID    Owner,
    PSID    Group,
    PACL    Dacl,
    PACL    Sacl,
    PULONG  SecurityDescriptorLength,
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

      Routine Description:

      Given the 4 components of a security descriptor this routine makes a new
      self relative Security descriptor.

      Parameters:

        Owner -- The Sid of the owner
        Group -- The Sid of the group
        Dacl  -- The Dacl to Use
        Sacl  -- The Sacl to Use

      Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL
--*/
{

    SECURITY_DESCRIPTOR SdAbsolute;
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    if (!InitializeSecurityDescriptor(&SdAbsolute,SECURITY_DESCRIPTOR_REVISION))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Set the owner, default the owner to administrators alias
    //


    if (NULL!=Owner)
    {
        if (!SetSecurityDescriptorOwner(&SdAbsolute,Owner,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }




    if (NULL!=Group)
    {
        if (!SetSecurityDescriptorGroup(&SdAbsolute,Group,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }


    //
    // Set the Dacl if there is one
    //

    if (NULL!=Dacl)
    {
        if (!SetSecurityDescriptorDacl(&SdAbsolute,TRUE,Dacl,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }

    //
    // Set the Sacl if there is one
    //

    if (NULL!=Sacl)
    {
        if (!SetSecurityDescriptorSacl(&SdAbsolute,TRUE,Sacl,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }

    //
    // Make a new security Descriptor
    //

    *SecurityDescriptorLength =  GetSecurityDescriptorLength(&SdAbsolute);
    *SecurityDescriptor = MIDL_user_allocate(*SecurityDescriptorLength);
    if (NULL==*SecurityDescriptor)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }


    if (!MakeSelfRelativeSD(&SdAbsolute,*SecurityDescriptor,SecurityDescriptorLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        if (*SecurityDescriptor)
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = NULL;
        }
    }

Error:


    return NtStatus;
}



NTSTATUS
SampInitializeWellKnownSidsForDsUpgrade( VOID )
/*++

Routine Description:

    This routine initializes some global well-known sids.  This
    is needed for the upgrade case, as we do not call SamInitialize

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_NO_MEMORY - Couldn't allocate memory for the sids.

--*/
{
    NTSTATUS
        NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        DomainInfo;

    //
    //      WORLD is s-1-1-0
    //  ANONYMOUS is s-1-5-7
    //

    SID_IDENTIFIER_AUTHORITY
            WorldSidAuthority       =   SECURITY_WORLD_SID_AUTHORITY,
            NtAuthority             =   SECURITY_NT_AUTHORITY;

    SAMTRACE("SampInitializeWellKnownSids");


    NtStatus = RtlAllocateAndInitializeSid(
                   &NtAuthority,
                   1,
                   SECURITY_ANONYMOUS_LOGON_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &SampAnonymousSid
                   );
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlAllocateAndInitializeSid(
                       &WorldSidAuthority,
                       1,                      //Sub authority count
                       SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                       0, 0, 0, 0, 0, 0, 0,
                       &SampWorldSid
                       );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = RtlAllocateAndInitializeSid(
                            &NtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &SampAdministratorsAliasSid
                            );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = RtlAllocateAndInitializeSid(
                                &NtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                                0, 0, 0, 0, 0, 0,
                                &SampAccountOperatorsAliasSid
                                );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = RtlAllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &SampAuthenticatedUsersSid
                                    );
                    if (NT_SUCCESS(NtStatus)) {
                        NtStatus = RtlAllocateAndInitializeSid(
                                        &NtAuthority,
                                        1,
                                        SECURITY_PRINCIPAL_SELF_RID,
                                        0,0, 0, 0, 0, 0, 0,
                                        &SampPrincipalSelfSid
                                        );

                    }
                }
            }

        }
    }

    return(NtStatus);
}




NTSTATUS
SampBuildNt4DomainProtection(
    PSECURITY_DESCRIPTOR * Nt4DomainDescriptor,
    PULONG  DescriptorLength
    )
/*++
    Builds a Default NT4 Descriptor for SAM domain objects
    Calls the Build Sam Routines

    Parameters:

        Nt4DomainDescriptor -- The NT4 Domain security Descriptor that
        is to be built

        DescriptorLength    -- The length of the Descriptor

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure

--*/
{
    NTSTATUS    NtStatus;
    PSID        AceSid[3];
    ACCESS_MASK AceMask[3];
    PSECURITY_DESCRIPTOR    LocalDescriptor = NULL;
    GENERIC_MAPPING  DomainMap    =  {DOMAIN_READ,
                                      DOMAIN_WRITE,
                                      DOMAIN_EXECUTE,
                                      DOMAIN_ALL_ACCESS
                                      };


    *Nt4DomainDescriptor = NULL;
    *DescriptorLength = 0;

    AceSid[0]  = *(WORLD_SID);
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ);

    AceSid[1]  = *(ADMINISTRATOR_SID);
    AceMask[1] = (DOMAIN_ALL_ACCESS);


    AceSid[2]  = *(ACCOUNT_OPERATOR_SID);
    AceMask[2] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER  |
                                                 DOMAIN_CREATE_GROUP |
                                                 DOMAIN_CREATE_ALIAS);

    NtStatus = SampBuildSamProtection(
                    *WORLD_SID,
                    *ADMINISTRATOR_SID,
                    3,//AceCount,
                    AceSid,
                    AceMask,
                    &DomainMap,
                    FALSE,
                    DescriptorLength,
                    &LocalDescriptor,
                    NULL
                    );

    if (NT_SUCCESS(NtStatus))
    {
        *Nt4DomainDescriptor = MIDL_user_allocate(*DescriptorLength);
        if (NULL!=*Nt4DomainDescriptor)
        {
            RtlCopyMemory(
                *Nt4DomainDescriptor,
                LocalDescriptor,
                *DescriptorLength
                );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }

        RtlFreeHeap(RtlProcessHeap(),0,LocalDescriptor);
        LocalDescriptor = NULL;
    }

    return NtStatus;
}

NTSTATUS
SampBuildNt4ServerProtection(
    PSECURITY_DESCRIPTOR * Nt4ServerDescriptor,
    PULONG  DescriptorLength
    )
/*++

    Builds a Default NT4 Descriptor for SAM Server objects

    Calls the Build Sam Routines

    Parameters:

        Nt4DomainDescriptor -- The NT4 Domain security Descriptor that
        is to be built

        DescriptorLength    -- The length of the Descriptor

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure


--*/
{
    NTSTATUS    NtStatus;
    PSID        AceSid[2];
    ACCESS_MASK AceMask[2];
    PSECURITY_DESCRIPTOR    LocalDescriptor = NULL;
    GENERIC_MAPPING  ServerMap    =  {SAM_SERVER_READ,
                                      SAM_SERVER_WRITE,
                                      SAM_SERVER_EXECUTE,
                                      SAM_SERVER_ALL_ACCESS
                                      };


    AceSid[0]  = *(WORLD_SID);
    AceMask[0] = (SAM_SERVER_EXECUTE | SAM_SERVER_READ);

    AceSid[1]  = *(ADMINISTRATOR_SID);
    AceMask[1] = (SAM_SERVER_ALL_ACCESS);


    *Nt4ServerDescriptor = NULL;
    *DescriptorLength = 0;

    NtStatus = SampBuildSamProtection(
                    *WORLD_SID,
                    *ADMINISTRATOR_SID,
                    2,//AceCount,
                    AceSid,
                    AceMask,
                    &ServerMap,
                    FALSE,
                    DescriptorLength,
                    &LocalDescriptor,
                    NULL
                    );

    if (NT_SUCCESS(NtStatus))
    {
        *Nt4ServerDescriptor = MIDL_user_allocate(*DescriptorLength);
        if (NULL!=*Nt4ServerDescriptor)
        {
            RtlCopyMemory(
                *Nt4ServerDescriptor,
                LocalDescriptor,
                *DescriptorLength
                );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }

        RtlFreeHeap(RtlProcessHeap(),0,LocalDescriptor);
        LocalDescriptor = NULL;
    }

    return NtStatus;
}


NTSTATUS
SampSetChangePasswordAces(
    PACL OrigDacl,
    BOOLEAN fAllowChangePassword,
    PACL *pNewDacl
    )
/*++

    Routine Description:

        SampSetChangePasswordAces creates a new DACL based on OrigDacl and 
        depending on fAllowChangePassword grants or denies the 
        UserChangePassword right.  The new DACL is returned in pNewDacl 
        and must be freed with LocalFree.
        
        If fAllowChangePassword is TRUE then any ACEs for WORLD_SID or
        PRINCIPAL_SELF denying the UserChangePassword right will be removed.
        Furthermore, an allow ACE for WORLD_SID and PRINCIPAL_SELF_SID will be
        added granting the UserChangePassword right.
        
        If fAllowChangePassword is FALSE ACEs are added to the SD to deny the
        right.
        
        This routine is specifically designed to manage the UserChangePassword
        right on user object security descriptors.
        
    Parameters:

        OrigDacl             -- NT5 security descriptor, remains unchanged.
        fAllowChangePassword -- Indicates whether to grant or deny the
                                change password right.
        pNewDacl             -- Upon success, a new Dacl containing changes 
                                based on fAllowChangePassword.  Upon failure 
                                this pointer will be NULL.                                

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    //
    // We will be adding/removing two ACEs
    //
    EXPLICIT_ACCESS rgNewEntries[2];
    OBJECTS_AND_SID rgObjectsAndSid[2];  
    RtlZeroMemory(rgNewEntries, sizeof(rgNewEntries));
    RtlZeroMemory(rgObjectsAndSid, sizeof(rgObjectsAndSid));
    
    //
    // Initialize output SD.
    //
    *pNewDacl = NULL;
    
    //
    // Build the trustee structs for change password
    //
    rgNewEntries[0].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
    rgNewEntries[0].grfAccessMode = fAllowChangePassword ? 
        GRANT_ACCESS : DENY_ACCESS;
    rgNewEntries[0].grfInheritance = NO_INHERITANCE;
    
    BuildTrusteeWithObjectsAndSid(
        &(rgNewEntries[0].Trustee),
        &(rgObjectsAndSid[0]),
        (GUID*)&GUID_CONTROL_UserChangePassword,
        NULL, // inherit guid
        SampPrincipalSelfSid
        );
    
    rgNewEntries[1].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
    rgNewEntries[1].grfAccessMode = fAllowChangePassword ? 
        GRANT_ACCESS : DENY_ACCESS;
    rgNewEntries[1].grfInheritance = NO_INHERITANCE;
    
    BuildTrusteeWithObjectsAndSid(
        &(rgNewEntries[1].Trustee),
        &(rgObjectsAndSid[1]),
        (GUID*)&GUID_CONTROL_UserChangePassword,
        NULL, // inherit guid
        SampWorldSid
        );
    
    //
    // Update the ACEs in the DACL.  This API performs removal of 
    // conflicting ACEs and canonicalization of the DACL as needed.
    //
    Win32Err = SetEntriesInAcl(
                   2, 
                   (PEXPLICIT_ACCESS)rgNewEntries, 
                   OrigDacl, 
                   pNewDacl
                   );
                              
    if (ERROR_SUCCESS != Win32Err) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    
    ASSERT(IsValidAcl(*pNewDacl));
    
Error:
    
    return NtStatus;

}


NTSTATUS
SampPropagateSelectedSdChanges(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT Context,
    OUT PVOID * Nt5Sd
    )
/*++

    Routine Description:

        SampPropagateSelectedSdChanges propagates only selected aspects of the Dacl in the
        NT4 security descriptor. This allows downlevel clients to perform essential functions
        like change password without losing information in the actual NT5 security descriptor
        on the object.

    Parameters:

        Nt4Sd      -- The NT4 security descriptor
        ObjectType -- The object type of the object whose security descriptor we want to modify
        Context    -- An open context to the object whose security descriptor is being modified
        Nt5Sd      -- The security descriptor in which essential elements of the NT4 Sd have been
                      propagated is returned in here.

    Return Values:

        STATUS_SUCCESS
        
        Error status.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PVOID       TmpNt5Sd = NULL;
    PVOID       SDToFree = NULL;
    BOOLEAN     Admin , ChangePassword;
    BOOLEAN     ChangePasswordAllowedOnCurrent;
    PVOID       CurrentSD = NULL;
    ULONG       CurrentSDLength = 0;
    PACL        NewDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    ULONG       NewSDLen = 0;
    
    *Nt5Sd = NULL;

    ASSERT(IsDsObject(Context));
    ASSERT(!Context->TrustedClient);


    //
    // Retrieve the current security descriptor
    //

    NtStatus = SampGetObjectSD(
                   Context,
                   &CurrentSDLength,
                   &CurrentSD
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (SampUserObjectType==ObjectType)
    {

        SDToFree = CurrentSD;

        //
        // First Parse the passed in NT4 DACL and see if it is a change password allowed /denied type
        //

        NtStatus = SampRecognizeStandardNt4Sd(
                        Nt4Sd,
                        ObjectType,
                        Context->DsClassId,
                        Context,
                        &ChangePassword,
                        &Admin,
                        &TmpNt5Sd
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Check the current Status of Password change / Admin ness
        //

        ASSERT(Context->ObjectNameInDs->SidLen >0);

        NtStatus = SampCheckIfChangePasswordAllowed(
                        CurrentSD,
                        &Context->ObjectNameInDs->Sid,
                        &ChangePasswordAllowedOnCurrent
                        );

        if (!NT_SUCCESS(NtStatus))
        {   
            goto Error;
        }

        if (ChangePassword != ChangePasswordAllowedOnCurrent)
        {
            NtStatus = SampSetChangePasswordAces(GetDacl(CurrentSD), 
                                                 ChangePassword, 
                                                 &NewDacl
                                                 );
                
            if (!NT_SUCCESS(NtStatus))
            {   
                goto Error;
            }
            
            //
            // Build a new self relative security descriptor with the new DACL.
            //
            
            NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                           GetOwner(CurrentSD),
                           GetGroup(CurrentSD),
                           NewDacl,
                           GetSacl(CurrentSD),
                           &NewSDLen,
                           &NewSD   
                           );   
            
            if (!NT_SUCCESS(NtStatus)) 
            {
                goto Error;
            }
            
            *Nt5Sd = NewSD;
        }
        else
        {
            //
            // No changes that we propagate so we'll keep the same DACL.
            //
            
            SDToFree = NULL;
            *Nt5Sd = CurrentSD;
        }   
    }
    else
    {
        //
        // Don't allow untrusted callers to change the SD through the downlevel
        // interface, fail the call silently
        //

        *Nt5Sd = CurrentSD;
    }

Error:

    if (NULL != SDToFree)
    {
        MIDL_user_free(SDToFree);
        SDToFree = NULL;
    }
    
    if (NULL != TmpNt5Sd) 
    {
        MIDL_user_free(TmpNt5Sd);
        TmpNt5Sd = NULL;
    }
    
    if (NULL != NewDacl) 
    {
        MIDL_user_free(NewDacl);
        NewDacl = NULL;
    }
    
    return(NtStatus);

}


//--------------------------------------------------------------------------
//
// ACL conversion routines implement a small cache to quickly lookup if a given
// SID is of Admin nature or not. This allows us to not take the hit of looking
// up a reverse membership list when looking up domain controllers
//

ACL_CONVERSION_CACHE SampAclConversionCache;

NTSTATUS
SampInitializeAclConversionCache()
/*++

  Routine Description

  This routine initializes the ACL conversion cache.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Set a high spin count so that contentions do not result in
    // high context switch overhead.
    //

    NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                    &SampAclConversionCache.Lock,
                    100
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Mark the Cache as Invalid
    //

    SampInvalidateAclConversionCache();

Error:

    return (NtStatus);
}


VOID
SampInvalidateAclConversionCache()
/*++

    Routine Description

    This routine invalidates the ACL conversion cache.


--*/
{
    ULONG i;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);
    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Well Enter critical section failed. There is nothing we can do
        // about it. We cannot invalidate the cache without entering the critical
        // section.
        //


        return;
    }

    for (i=0;i<ACL_CONVERSION_CACHE_SIZE;i++)
    {
        SampAclConversionCache.Elements[i].fValid = FALSE;
    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);

}

BOOLEAN
SampLookupAclConversionCache(
    IN PSID SidToLookup,
    OUT BOOLEAN *fAdmin
    )
/*++

  This routine looks up in the acl conversion cache. The cache is hashed using the
  RID of the account. Hash conflicts are handled by simply throwing out the pre-
  existing entry

  Paramters

        SidToLookup -- The SID which we want to lookup
        fAdmin      -- On a successful lookup indicates and admin/non admin

   Return Values

        TRUE -- Successful lookup
        FALSE -- Failed lookup.


--*/
{

    BOOLEAN fMatch = FALSE;
    ULONG   Rid=0;
    ULONG   Hash=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Get the RID
    //

    Rid = *(RtlSubAuthoritySid(SidToLookup,*(RtlSubAuthorityCountSid(SidToLookup))-1));

    Hash = Rid % ACL_CONVERSION_CACHE_SIZE;

    //
    // Enter the Lock protecting the Cache
    //

    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);

    //
    // If we cannot grab a critical section exit without declaring a match.
    //

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    if ((SampAclConversionCache.Elements[Hash].fValid) &&
        (RtlEqualSid(&SampAclConversionCache.Elements[Hash].SidOfPrincipal,SidToLookup)))
    {
        //
        // Test Succeeded . Call it a match
        //

         *fAdmin = SampAclConversionCache.Elements[Hash].fAdmin;
         fMatch = TRUE;
    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);

    return(fMatch);
}


VOID
SampAddToAclConversionCache(
    IN PSID SidToAdd,
    IN BOOLEAN fAdmin
    )
/*++

  Routine Description

    This routine adds a SID to the ACL conversion cache. The Cache is hashed by RID and
    hash conflicts are handled by throwing out the existing entry.

  Parameters

    Sid -- Sid to Add
    fAdmin -- Indicates that the concerned SID is a member of
              the administrators group.

  Return Values

    None ( Void Function )

--*/
{
    ULONG   Rid=0;
    ULONG   Hash=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Get the RID
    //

    Rid = *(RtlSubAuthoritySid(SidToAdd,*(RtlSubAuthorityCountSid(SidToAdd))-1));

    Hash = Rid % (ACL_CONVERSION_CACHE_SIZE);

    //
    // Enter the Lock protecting the Cache
    //

    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);

    //
    // If we cannot grab a critical section exit doing anything
    //

    if (!NT_SUCCESS(NtStatus))
    {
        return;
    }

    //
    // Test if the entry already exists
    //

    if (!((SampAclConversionCache.Elements[Hash].fValid) &&
        (RtlEqualSid(&SampAclConversionCache.Elements[Hash].SidOfPrincipal,SidToAdd))))
    {
        //
        // Entry Does not already exist, add the entry
        //

        NtStatus = RtlCopySid(
                        sizeof(NT4SID),
                        &SampAclConversionCache.Elements[Hash].SidOfPrincipal,
                        SidToAdd
                        );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Successfully copied
            //

            SampAclConversionCache.Elements[Hash].fAdmin = fAdmin;
            SampAclConversionCache.Elements[Hash].fValid = TRUE;
        }

    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);
}

BOOLEAN
SampIsAttributeAccessGrantedActual(
    IN PRTL_BITMAP AccessGranted,
    IN PRTL_BITMAP AccessRequested
    )
/*++

Routine  Description:

    This routine checks that all bits that are set in AccessRequested are
    also set in AccessGranted.  If so, then TRUE is returned; FALSE otherwise.

Parameters:

    See description.

Return Values

    See description.

--*/
{
    ULONG i;
    for (i = 0; i < MAX_SAM_ATTRS; i++) {
        if (RtlCheckBit(AccessRequested, i)
        && !RtlCheckBit(AccessGranted, i)) {
            return FALSE;
        }
    }
    return TRUE;

}

BOOLEAN
SampIsAttributeAccessGranted(
    IN PRTL_BITMAP  AccessGranted,
    IN PRTL_BITMAP  AccessRequested
    )
/*++

Routine  Description:

    This routine checks that all bits that are set in AccessRequested are
    also set in AccessGranted.  If so, then TRUE is returned; FALSE otherwise.
    
    Each bitmap above represents either the request or the granting of access
    to a particular attribute (on a SAM object). Currently this is only
    used for write access to SAM User attributes that are writable via the 
    SAM RPC interface.  Each such attribute has two representations: a 
    "WhichFields" value (eg. USER_ALL_BADPASSWORDCOUNT) defined in ntsam.h and 
    an internal representation for SAM (SAMP_FIXED_USER_BAD_PWD_COUNT).  
    The index into the table SampWhichFieldToSamAttr (see table below) of a 
    particular attribute is the bit in the bitmap that represents the 
    attribute.  For example, bit 1 in the AccessGranted means that the caller 
    has write access to code page, and if the bit is set in AccessRequested, 
    this means that the caller has requested a write to that attribute.
    
    Hence an attribute level access amounts to making sure that for every
    bit in AccessRequested, the same bit is set in AccessGranted.   

Parameters:

    See description.
    
Return Values

    See description.

--*/
{
    ULONG i;

    //
    // AccessGrantedActual is the passed in bitmap of attributes
    // that are granted access plus any additional attributes granted
    // during this routine.
    //
    SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(AccessGrantedActual)
    SAMP_INIT_SAM_ATTRIBUTE_BITMASK(AccessGrantedActual);

    //
    // Copy the granted access into AccessGrantedActual
    //
    SAMP_COPY_SAM_ATTRIBUTE_BITMASK(AccessGrantedActual, *AccessGranted);

    //
    // Determine if any additional access should be granted
    //
    if (!SampComputerObjectACLApplied) {

        SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(UserAccountControlAttrAccess)
        SAMP_INIT_SAM_ATTRIBUTE_BITMASK(UserAccountControlAttrAccess);

        //
        // The effective owner of the computer can't be determined -- only
        // grant samaccountname and full name if the caller has access
        // to the account restrictions property set.
        //

        SampSetAttributeAccess(SampUserObjectType,
                               SAMP_FIXED_USER_ACCOUNT_CONTROL,
                              &UserAccountControlAttrAccess);


        if (SampIsAttributeAccessGrantedActual(AccessGranted,
                                               &UserAccountControlAttrAccess)) {

           //
           // The caller has the right to write to the user account control
           // attribute.  Prior to this fix, such callers would also
           // gain access to the following attributes
           //
           SampSetAttributeAccessWithWhichFields(USER_ALL_WRITE_ACCOUNT_MASK,
                                                 &AccessGrantedActual);

        }

    }

    return SampIsAttributeAccessGrantedActual(&AccessGrantedActual,
                                              AccessRequested);
}


//
// This table is used to translate WhichFields in SamrSetInformationUser
// to SAM attributes, as well as provide an offset into the Context's
// attribute array.
//

struct
{
    ULONG WhichField;
    ULONG SamAttribute;

} SampWhichFieldToSamAttr [] =
{
    {USER_ALL_ADMINCOMMENT,          SAMP_USER_ADMIN_COMMENT},         
    {USER_ALL_CODEPAGE,              SAMP_FIXED_USER_CODEPAGE},        
    {USER_ALL_COUNTRYCODE,           SAMP_FIXED_USER_COUNTRY_CODE},    
    {USER_ALL_USERID,                SAMP_FIXED_USER_SID},             
    {USER_ALL_PRIMARYGROUPID,        SAMP_FIXED_USER_PRIMARY_GROUP_ID},
    {USER_ALL_USERNAME,              SAMP_USER_ACCOUNT_NAME},          
    {USER_ALL_USERCOMMENT,           SAMP_USER_USER_COMMENT},          
    {USER_ALL_FULLNAME,              SAMP_USER_FULL_NAME},             

    {USER_ALL_ACCOUNTEXPIRES,        SAMP_FIXED_USER_ACCOUNT_EXPIRES},
    {USER_ALL_PASSWORDLASTSET,       SAMP_FIXED_USER_PWD_LAST_SET},   
    {USER_ALL_USERACCOUNTCONTROL,    SAMP_FIXED_USER_ACCOUNT_CONTROL},
    {USER_ALL_PARAMETERS,            SAMP_USER_PARAMETERS},           

    {USER_ALL_BADPASSWORDCOUNT,      SAMP_FIXED_USER_BAD_PWD_COUNT}, 
    {USER_ALL_HOMEDIRECTORY,         SAMP_USER_HOME_DIRECTORY},      
    {USER_ALL_HOMEDIRECTORYDRIVE,    SAMP_USER_HOME_DIRECTORY_DRIVE},
    {USER_ALL_LASTLOGOFF,            SAMP_FIXED_USER_LAST_LOGOFF},   
    {USER_ALL_LASTLOGON,             SAMP_FIXED_USER_LAST_LOGON},    
    {USER_ALL_LOGONCOUNT,            SAMP_FIXED_USER_LOGON_COUNT},   
    {USER_ALL_LOGONHOURS,            SAMP_USER_LOGON_HOURS},         
    {USER_ALL_WORKSTATIONS,          SAMP_USER_WORKSTATIONS},        
    {USER_ALL_PROFILEPATH,           SAMP_USER_PROFILE_PATH},        
    {USER_ALL_SCRIPTPATH,            SAMP_USER_SCRIPT_PATH}         
};

VOID
SampSetAttributeAccess(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG SamAttribute,
    IN OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine  Description:

    This routine sets the appropriate bit in AttributesAccessTable that
    indicates that SamAttribute (as defined in mappings.h) is accessible.

Parameters:

    ObjectType -- the object type corresponding to the GrantedAccess
    
    SamAttribute -- #define of a SAM attribute in mappings.h
    
    AttributeAccessTable -- a bitmap of attributes

Return Values

    None.

--*/
{
    ULONG i;

    //
    // Only user object is supported now
    //
    ASSERT(ObjectType == SampUserObjectType);
    if (ObjectType == SampUserObjectType) {
        //
        // Find the element in the table
        //
        for (i = 0; i < ARRAY_COUNT(SampWhichFieldToSamAttr); i++) {
            if (SamAttribute == SampWhichFieldToSamAttr[i].SamAttribute) {
                RtlSetBits(AttributeAccessTable, i, 1);
                break;
            }
        }
    }

    return;
}

VOID
SampSetAttributeAccessWithWhichFields(
    IN ULONG WhichFields,
    IN OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine  Description:

    This routine sets the appropriate bits in AttributesAccessTable that
    indicates that the SamAttributes represented by the WhichFields are
    accessible.

Parameters:

    WhichFields -- from ntsam.h
    
    AttributeAccessTable -- a bitmap of attributes

Return Values

    None.

--*/
{
    ULONG i;
    for (i = 0; i < ARRAY_COUNT(SampWhichFieldToSamAttr); i++) {
        if (WhichFields & SampWhichFieldToSamAttr[i].WhichField) {
            RtlSetBits(AttributeAccessTable, i, 1);
        }
    }
}


VOID
SampNt4AccessToWritableAttributes(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ACCESS_MASK GrantedAccess,
    OUT PRTL_BITMAP Attributes
    )
/*++

Routine  Description:

    This routine sets what attributes are writeable based on the Nt4
    access mask.

Parameters:

    ObjectType -- the object type corresponding to the GrantedAccess
    
    GrantedAccess -- Nt4 access mask
    
    Attributes -- bitmap of attributes                

Return Values

    None.

--*/
{
    ASSERT(ObjectType == SampUserObjectType);
    if (ObjectType == SampUserObjectType) {

        ULONG WhichFields = 0;
        if (GrantedAccess & USER_WRITE_PREFERENCES) {
            WhichFields |= USER_ALL_WRITE_PREFERENCES_MASK;
        }
    
        if (GrantedAccess & USER_WRITE_ACCOUNT) {
            WhichFields |= USER_ALL_WRITE_ACCOUNT_MASK;
        }
    
        SampSetAttributeAccessWithWhichFields(WhichFields,
                                              Attributes);
    }

    return;
}

BOOLEAN
SamIIsAttributeProtected(
    IN GUID *Attribute
    )
/*++

Routine  Description:

    This routine returns TRUE if the passed in attribute is one whose
    property set can't change.  The reason why it can't change is that
    SAM has a hard coded table assuming the default property in order to 
    perform downlevel access mapping.

Parameters:

    Attribute -- a guid, from ntdsguid.h, that represents the attribute in 
                 in question

Return Values

    See description.                             

--*/
{
    ULONG i, j;

    struct {
        OBJECT_TYPE_LIST  *List;
        ULONG             Count;
    } ObjectTypeLists[] = { 

        {ServerObjectTypeList, RTL_NUMBER_OF(ServerObjectTypeList)},
        {DomainObjectTypeList, RTL_NUMBER_OF(DomainObjectTypeList)},
        {GroupObjectTypeList,  RTL_NUMBER_OF(GroupObjectTypeList)},
        {AliasObjectTypeList,  RTL_NUMBER_OF(AliasObjectTypeList)},
        {UserObjectTypeList,   RTL_NUMBER_OF(UserObjectTypeList)}
    };

    for (i = 0; i < RTL_NUMBER_OF(ObjectTypeLists); i++) {
        for (j = 0; j < ObjectTypeLists[i].Count; j++) {
            if ((ObjectTypeLists[i].List[j].Level == ACCESS_PROPERTY_GUID)
             && IsEqualGUID(Attribute, ObjectTypeLists[i].List[j].ObjectType)  ) {
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\server.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This file contains services related to the SAM "server" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    08-Oct-1996 ChrisMay
        Added crash-recovery code.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dnsapi.h>
#include <samtrace.h>
#include <dslayer.h>
#include <attids.h>
#include "validate.h"




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamrConnect4(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG ClientRevision,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    See SamrConnect3.

    N.B.  This routine is here just so a particular NT4 samlib.dll can
    connect to an NT5 samsrv.dll.  This particular samsrv.dll is used by
    Boeing and when it was delivered to them, the dll mistakenly had
    an extra RPC function which now causes interoperability problems.

    This extra function solves this problem.

Arguments:

    See SamrConnect3.

Return Value:

    See SamrConnect3.


--*/
{
    return SamrConnect3( ServerName,
                         ServerHandle,
                         ClientRevision,
                         DesiredAccess );

}

NTSTATUS
SamrConnect3(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG ClientRevision,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established.
    This is different from the SamConnect call in that the entire server
    name is passed instead of just the first character.


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SamrConnect3");

    //
    // Drop calls over invalid / uninstalled protocol sequences
    //
    NtStatus = SampValidateRpcProtSeq((RPC_BINDING_HANDLE)NULL);
    
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.



    TrustedClient = FALSE;


    return SampConnect(
                ServerName,
                ServerHandle,
                ClientRevision,
                DesiredAccess,
                TrustedClient,
                FALSE,
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}



NTSTATUS
SamrConnect2(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established.
    This is different from the SamConnect call in that the entire server
    name is passed instead of just the first character.


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SamrConnect2");

    //
    // Drop calls over invalid / uninstalled protocol sequences
    //
    NtStatus = SampValidateRpcProtSeq((RPC_BINDING_HANDLE)NULL);
    
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.

    TrustedClient = FALSE;


    return SampConnect(
                ServerName,
                ServerHandle,
                SAM_CLIENT_PRE_NT5,
                DesiredAccess,
                TrustedClient,
                FALSE,
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}


NTSTATUS
SamrConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SamrConnect");

    //
    // Drop calls over invalid / uninstalled protocol sequences
    //
    NtStatus = SampValidateRpcProtSeq((RPC_BINDING_HANDLE)NULL);
    
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.


    TrustedClient = FALSE;

    return SampConnect(
                NULL,
                ServerHandle,
                SAM_CLIENT_PRE_NT5,
                DesiredAccess,
                TrustedClient,
                FALSE,
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}

NTSTATUS
SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN     TrustedClient
    )

/*++

Routine Description:

    This service is the in process SAM connect routine  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    TrustedClient - Indicates that the caller is a trusted client.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SampConnect().


--*/
{

    SAMTRACE("SamIConnect");

    return SampConnect(NULL,
                       ServerHandle,
                       SAM_CLIENT_LATEST,
                       DesiredAccess,
                       TrustedClient,
                       FALSE,
                       FALSE,        // NotSharedByMultiThreads
                       FALSE
                       );

}




NTSTATUS
SampConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG       ClientRevision,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN InternalCaller
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


    NOTE: If the caller is trusted, then the DesiredAccess parameter may
          NOT contain any Generic access types or MaximumAllowed.  All
          mapping must be done by the caller.

Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.

    TrustedClient - Indicates whether the client is known to be part of
        the trusted computer base (TCB).  If so (TRUE), no access validation
        is performed and all requested accesses are granted.  If not
        (FALSE), then the client is impersonated and access validation
        performed against the SecurityDescriptor on the SERVER object.

    LoopbackClient - Indicates that the caller is a loopback client. If
        so (TRUE), SAM lock will not be acquired. If not (FALSE), we will
        grab SAM lock.

    NotSharedByMultiThread - Indicates that the ServerHandle would be
        Shared by multiple threads or not. RPC clients will not share SAM handle.
        Only in process client (netlogon, lsa, kerberos) will have a global
        ServerHandle or domain handle shared across multiple callers.

    InternalCaller - Indicates that the client is an internal caller that


Return Value:


    STATUS_SUCCESS - The SERVER object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.

    Other values as may be returned from:

            NtAccessCheckAndAuditAlarm()


--*/
{
    NTSTATUS            NtStatus;
    PSAMP_OBJECT        Context;
    BOOLEAN             fLockAcquired = FALSE;
    BOOLEAN             fAcquireLockAttemp = FALSE;

    UNREFERENCED_PARAMETER( ServerName ); //Ignored by this routine

    SAMTRACE_EX("SamIConnect");

    //
    // If the SAM server is not initialized, reject the connection.
    //

    if ((SampServiceState != SampServiceEnabled) && (!InternalCaller )){

        return(STATUS_INVALID_SERVER_STATE);
    }
    
    //
    // Do WMI start type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidConnect
                   );

    //
    // Create the server context
    // we don't use DomainIndex field in Server Object, so
    // feel free to use any thing - SampDsGetPrimaryDomainStart();
    // or in the future, find the correct domain index to support multiple
    // hosted domain.
    //

    Context = SampCreateContextEx(SampServerObjectType, // type
                                  TrustedClient,        // trusted client
                                  SampUseDsData,        // ds mode
                                  NotSharedByMultiThreads, // NotSharedByMultiThreads
                                  LoopbackClient,       // LoopbackClient
                                  FALSE,                // laze commit
                                  FALSE,                // persis across calls
                                  FALSE,                // Buffer writes
                                  FALSE,                // Opened By DCPromo
                                  SampDsGetPrimaryDomainStart() // DomainIndex
                                  );

    if (Context != NULL) {

        //
        // Grab SAM lock if necessary
        //

        SampMaybeAcquireReadLock(Context,
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &fLockAcquired);
        fAcquireLockAttemp = TRUE;

        if (SampUseDsData)
        {
            SetDsObject(Context);

            //
            // Windows 2000 and Whistler support only a single domain to
            // be hosted on a DC. Future releases may host more than 1 domain.
            // Add Logic Here for figuring out which Domain to connect to
            // for multiple hosted domain support.
            //

            Context->ObjectNameInDs = SampServerObjectDsName;

            NtStatus = SampMaybeBeginDsTransaction( TransactionRead );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
        else
        {


            //
            // The RootKey for a SERVER object is the root of the SAM database.
            // This key should not be closed when the context is deleted.
            //

            Context->RootKey = SampKey;
        }

        //
        // Set the Client Revision
        //

        Context->ClientRevision = ClientRevision;


        //
        // The rootkeyname has been initialized to NULL inside CreateContext.
        //

        //
        // Perform access validation ...
        //

        NtStatus = SampValidateObjectAccess(
                       Context,                 //Context
                       DesiredAccess,           //DesiredAccess
                       FALSE                    //ObjectCreation
                       );



        //
        // if we didn't pass the access test, then free up the context block
        // and return the error status returned from the access validation
        // routine.  Otherwise, return the context handle value.
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDeleteContext( Context );
        } else {
            (*ServerHandle) = Context;
        }

    } else {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

Error:

    if (SampUseDsData)
    {
        SampMaybeEndDsTransaction(TransactionCommit);
    }

    if (fAcquireLockAttemp)
    {
        SampMaybeReleaseReadLock( fLockAcquired );
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // Do a WMI end type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidConnect
                   );

    return(NtStatus);

}

NTSTATUS
SamILoopbackConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    )

/*++

Routine Description:

    This service is does the connect operation for DS loopback.
    It calls SampConnect setting the trusted bit and loopback client


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.

    TrusteClient - Flag indicating trusted client status.  Used to bypass
        certain validation checks - eg: group member validation during
        adds for cross domain move.

Return Value:

    Status values returned by SamIConnect().


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE_EX("SamLoopbackConnect");

    //
    // Call SampConnect as trusted client, as we wish to avoid
    // the access ck on the SAM server object.
    //
    // Call SampConnect as loopback client, as we don't need the lock
    //
    NtStatus = SampConnect(NULL,                // Server Name
                           ServerHandle,        // return Server Handle
                           SAM_CLIENT_LATEST,   // Client Revision
                           DesiredAccess,       // DesiredAccess
                           TRUE,                // Trusted Client
                           TRUE,                // Loopback Client
                           TRUE,                // NotSharedByMultiThreads
                           FALSE                // Internal Caller
                           );

    if (NT_SUCCESS(NtStatus))
    {
        ((PSAMP_OBJECT) (*ServerHandle))->TrustedClient = TrustedClient;
        ((PSAMP_OBJECT) (*ServerHandle))->LoopbackClient = TRUE;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamrShutdownSamServer(
    IN SAMPR_HANDLE ServerHandle
    )

/*++

Routine Description:

    This service shuts down the SAM server.

    In the long run, this routine will perform an orderly shutdown.
    In the short term, it is useful for debug purposes to shutdown
    in a brute force un-orderly fashion.

Arguments:

    ServerHandle - Received from a previous call to SamIConnect().

Return Value:

    STATUS_SUCCESS - The services completed successfully.


    STATUS_ACCESS_DENIED - The caller doesn't have the appropriate access
        to perform the requested operation.


--*/
{

    NTSTATUS            NtStatus, IgnoreStatus;
    PSAMP_OBJECT        ServerContext;
    SAMP_OBJECT_TYPE    FoundType;

    SAMTRACE_EX("SamrShutdownSamServer");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidShutdownSamServer
                   );

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // Validate type of, and access to server object.
    //

    ServerContext = (PSAMP_OBJECT)ServerHandle;
    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_SHUTDOWN,            // DesiredAccess
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {


        //
        // Signal the event that will cut loose the main thread.
        // The main thread will then exit - causing the walls to
        // come tumbling down.
        //

        IgnoreStatus = RpcMgmtStopServerListening(0);
        ASSERT(NT_SUCCESS(IgnoreStatus));



        //
        // De-reference the server object
        //

        IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the write lock and roll-back the transaction
    //

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidShutdownSamServer
                   );

    return(NtStatus);

}


NTSTATUS
SamrLookupDomainInSamServer(
    IN SAMPR_HANDLE ServerHandle,
    IN PRPC_UNICODE_STRING Name,
    OUT PRPC_SID *DomainId
    )

/*++

Routine Description:

    This service

Arguments:

    ServerHandle - A context handle returned by a previous call
    to SamConnect().

    Name - contains the name of the domain to look up.

    DomainSid - Receives a pointer to a buffer containing the SID of
        the domain.  The buffer pointed to must be deallocated by the
        caller using MIDL_user_free() when no longer needed.


Return Value:


    STATUS_SUCCESS - The services completed successfully.

    STATUS_ACCESS_DENIED - The caller doesn't have the appropriate access
        to perform the requested operation.

    STATUS_NO_SUCH_DOMAIN - The specified domain does not exist at this
        server.


    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.




--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            ServerContext;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   i, SidLength;
    BOOLEAN                 DomainFound;
    BOOLEAN                 fLockAcquired = FALSE;
    PSID                    FoundSid;
    ULONG                   DomainStart;
    WCHAR                   *NullTerminatedName = NULL;
    WCHAR                   *DnsDomainName = NULL;

    SAMTRACE_EX("SamrLookupDomainInSamServer");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupDomainInSamServer
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainId != NULL);
    ASSERT ((*DomainId) == NULL);
    (*DomainId) = NULL;

    if( !SampValidateRpcUnicodeString( Name ) || Name->Buffer == NULL ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);

        goto Error;
    }



    //
    // The name passed in may not be null terminated
    //


    NullTerminatedName  = MIDL_user_allocate(Name->Length+sizeof(WCHAR));
    if (NULL==NullTerminatedName)
    {
        NtStatus = STATUS_NO_MEMORY;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    RtlCopyMemory(NullTerminatedName,Name->Buffer,Name->Length);

    //
    // NULL terminate the name
    //

    NullTerminatedName[Name->Length/sizeof(WCHAR)] = 0;


    //
    // Acquire Read lock if necessary
    //

    ServerContext = (PSAMP_OBJECT)ServerHandle;
    SampMaybeAcquireReadLock(ServerContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // If Product Type is DC, and not recovering from a crash, then use
    // DS-based domains information, otherwise fall back to the registry.
    //

    DomainStart = SampDsGetPrimaryDomainStart();



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_LOOKUP_DOMAIN,
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {



        //
        // Set our default completion status
        //

        NtStatus = STATUS_NO_SUCH_DOMAIN;


        //
        // Search the list of defined domains for a match.
        //

        DomainFound = FALSE;
        for (i = DomainStart;
             (i<SampDefinedDomainsCount && (!DomainFound));
             i++ ) {

            UNICODE_STRING UDnsDomainName = SampDefinedDomains[i].DnsDomainName;

            if (DnsDomainName) {
                MIDL_user_free(DnsDomainName);
                DnsDomainName = NULL;
            }

            if (NULL != UDnsDomainName.Buffer) {
                DnsDomainName = MIDL_user_allocate(UDnsDomainName.Length+sizeof(WCHAR));
                if (NULL == DnsDomainName) {
                    NtStatus = STATUS_NO_MEMORY;
                    break;
                }
                RtlCopyMemory(DnsDomainName,UDnsDomainName.Buffer,UDnsDomainName.Length);
                DnsDomainName[UDnsDomainName.Length/sizeof(WCHAR)] = L'\0';
            }

             if (
                    (RtlEqualDomainName(&SampDefinedDomains[i].ExternalName, (PUNICODE_STRING)Name) )
                    || ((NULL!=DnsDomainName) &&
                         (DnsNameCompare_W(DnsDomainName, NullTerminatedName)))
                ) {


                 DomainFound = TRUE;


                 //
                 // Allocate and fill in the return buffer
                 //

                SidLength = RtlLengthSid( SampDefinedDomains[i].Sid );
                FoundSid = MIDL_user_allocate( SidLength );
                if (FoundSid != NULL) {
                    NtStatus =
                        RtlCopySid( SidLength, FoundSid, SampDefinedDomains[i].Sid );

                    if (!NT_SUCCESS(NtStatus) ) {
                        MIDL_user_free( FoundSid );
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;
                    }

                    (*DomainId) = FoundSid;
                }
                else
                {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
             }

        }

        //
        // De-reference the  object
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampDeReferenceContext( ServerContext, FALSE );

        } else {

            IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
        }
    }



    //
    // Free the read lock
    //
    SampMaybeReleaseReadLock(fLockAcquired);

    //
    // Free the null terminated name
    //

    if (NULL!=NullTerminatedName)
        MIDL_user_free(NullTerminatedName);

    if (DnsDomainName) {
        MIDL_user_free(DnsDomainName);
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    if (!NT_SUCCESS(NtStatus)) {
        if ((*DomainId)) {
            MIDL_user_free((*DomainId));
            (*DomainId) = NULL;
        }
    }

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupDomainInSamServer
                   );

    return(NtStatus);
}


NTSTATUS
SamrEnumerateDomainsInSamServer(
    IN SAMPR_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the domains defined in the account database.
    Since there may be more domains than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires SAM_SERVER_ENUMERATE_DOMAINS access to the
    SamServer object.

Arguments:

    ConnectHandle - Handle obtained from a previous SamConnect call.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer where the information
        is placed.  The information returned is contiguous
        SAM_RID_ENUMERATION data structures.  However, the
        RelativeId field of each of these structures is not valid.
        This buffer must be freed when no longer needed using
        SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have the access required
        to enumerate the domains.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is
        currently disabled.



--*/
{
    NTSTATUS                    NtStatus, IgnoreStatus;
    ULONG                       i;
    PSAMP_OBJECT                Context = NULL;
    SAMP_OBJECT_TYPE            FoundType;
    ULONG                       TotalLength = 0;
    ULONG                       NewTotalLength;
    PSAMP_ENUMERATION_ELEMENT   SampHead, NextEntry, NewEntry;
    BOOLEAN                     LengthLimitReached = FALSE;
    PSAMPR_RID_ENUMERATION      ArrayBuffer;
    ULONG                       ArrayBufferLength;
    ULONG                       DsDomainStart = SampDsGetPrimaryDomainStart();
    BOOLEAN                     fLockAcquired = FALSE;

    SAMTRACE_EX("SamrEnumerateDomainsInSamServer");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateDomainsInSamServer
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (ServerHandle != NULL);
    ASSERT (EnumerationContext != NULL);
    ASSERT (  Buffer  != NULL);
    ASSERT ((*Buffer) == NULL);
    ASSERT (CountReturned != NULL);


    //
    // Initialize the list of names being returned.
    // This is a singly linked list.
    //

    SampHead = NULL;


    //
    // Initialize the count returned
    //

    (*CountReturned) = 0;



    //
    // Acquire Read Lock if neccessary
    //

    Context = (PSAMP_OBJECT)ServerHandle;
    SampMaybeAcquireReadLock(Context,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   Context,
                   SAM_SERVER_ENUMERATE_DOMAINS,
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Enumerating domains is easy.  We keep a list in memory.
        // All we have to do is use the enumeration context as an
        // index into the defined domains array.
        //



        //
        // Set our default completion status
        // Note that this is a SUCCESS status code.
        // That is NT_SUCCESS(STATUS_MORE_ENTRIES) will return TRUE.

        //

        NtStatus = STATUS_MORE_ENTRIES;

        //
        // If Product Type is DC and it is not recovering from a crash,
        // then reference DS-based domain data instead of the registry-
        // based data. Otherwise, use the registry-based domain data.
        //

        if (TRUE == SampUseDsData)
        {
            // Domain Controller
            if ((ULONG)(*EnumerationContext) < DsDomainStart)
                 *EnumerationContext = DsDomainStart;
        }


        //
        // Search the list of defined domains for a match.
        //

        for ( i = (ULONG)(*EnumerationContext);
              ( (i < SampDefinedDomainsCount) &&
                (NT_SUCCESS(NtStatus))        &&
                (!LengthLimitReached)           );
              i++ ) {


            //
            // See if there is room for the next name.  If TotalLength
            // is still zero then we haven't yet even gotten one name.
            // We have to return at least one name even if it exceeds
            // the length request.
            //


            NewTotalLength = TotalLength +
                             sizeof(UNICODE_STRING) +
                             (ULONG)SampDefinedDomains[i].ExternalName.Length +
                             sizeof(UNICODE_NULL);

            if ( (NewTotalLength < PreferedMaximumLength)  ||
                 (TotalLength == 0) ) {

                if (NewTotalLength > SAMP_MAXIMUM_MEMORY_TO_USE) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {


                    TotalLength = NewTotalLength;
                    (*CountReturned) += 1;

                    //
                    // Room for this name as well.
                    // Allocate a new return list entry, and a buffer for the
                    // name.
                    //

                    NewEntry = MIDL_user_allocate(sizeof(SAMP_ENUMERATION_ELEMENT));
                    if (NewEntry == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        NewEntry->Entry.Name.Buffer =
                            MIDL_user_allocate(
                                (ULONG)SampDefinedDomains[i].ExternalName.Length +
                                sizeof(UNICODE_NULL)
                                );

                        if (NewEntry->Entry.Name.Buffer == NULL) {
                            MIDL_user_free(NewEntry);
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            //
                            // Copy the name into the return buffer
                            //

                            RtlCopyMemory( NewEntry->Entry.Name.Buffer,
                                           SampDefinedDomains[i].ExternalName.Buffer,
                                           SampDefinedDomains[i].ExternalName.Length
                                           );
                            NewEntry->Entry.Name.Length = SampDefinedDomains[i].ExternalName.Length;
                            NewEntry->Entry.Name.MaximumLength = NewEntry->Entry.Name.Length + (USHORT)sizeof(UNICODE_NULL);
                            UnicodeTerminate((PUNICODE_STRING)(&NewEntry->Entry.Name));


                            //
                            // The Rid field of the ENUMERATION_INFORMATION is not
                            // filled in for domains.
                            // Just for good measure, set it to zero.
                            //

                            NewEntry->Entry.RelativeId = 0;



                            //
                            // Now add this to the list of names to be returned.
                            //

                            NewEntry->Next = (PSAMP_ENUMERATION_ELEMENT)SampHead;
                            SampHead = NewEntry;
                        }

                    }
                }

            } else {

                LengthLimitReached = TRUE;

            }

        }




        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Set the enumeration context
            //

            (*EnumerationContext) = (*EnumerationContext) + (*CountReturned);



            //
            // If we are returning the last of the names, then change our
            // status code to indicate this condition.
            //

            if ( ((*EnumerationContext) >= SampDefinedDomainsCount) ) {

                NtStatus = STATUS_SUCCESS;
            }




            //
            // Build a return buffer containing an array of the
            // SAM_RID_ENUMERATIONs pointed to by another
            // buffer containing the number of elements in that
            // array.
            //

            (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_ENUMERATION_BUFFER) );

            if ( (*Buffer) == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                (*Buffer)->EntriesRead = (*CountReturned);

                ArrayBufferLength = sizeof( SAM_RID_ENUMERATION ) *
                                     (*CountReturned);
                ArrayBuffer  = MIDL_user_allocate( ArrayBufferLength );
                (*Buffer)->Buffer = ArrayBuffer;

                if ( ArrayBuffer == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    MIDL_user_free( (*Buffer) );

                }   else {

                    //
                    // Walk the list of return entries, copying
                    // them into the return buffer
                    //

                    NextEntry = SampHead;
                    i = 0;
                    while (NextEntry != NULL) {

                        NewEntry = NextEntry;
                        NextEntry = NewEntry->Next;

                        ArrayBuffer[i] = NewEntry->Entry;
                        i += 1;

                        MIDL_user_free( NewEntry );
                    }

                }

            }
        }




        if ( !NT_SUCCESS(NtStatus) ) {

            //
            // Free the memory we've allocated
            //

            NextEntry = SampHead;
            while (NextEntry != NULL) {

                NewEntry = NextEntry;
                NextEntry = NewEntry->Next;

                MIDL_user_free( NewEntry->Entry.Name.Buffer );
                MIDL_user_free( NewEntry );
            }

            (*EnumerationContext) = 0;
            (*CountReturned)      = 0;
            (*Buffer)             = NULL;

        }

        //
        // De-reference the  object
        // Note that NtStatus could be STATUS_MORE_ENTRIES, which is a
        // successful return code - we want to make sure we return that,
        // without wiping it out here.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SampDeReferenceContext( Context, FALSE );

        } else {

            IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        }
    }



    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock( fLockAcquired );


    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateDomainsInSamServer
                   );

    return(NtStatus);

}

NTSTATUS
SamrConnect5(
    IN  PSAMPR_SERVER_NAME ServerName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG InVersion,
    IN  SAMPR_REVISION_INFO  *InRevisionInfo,
    OUT ULONG  *OutVersion,
    OUT SAMPR_REVISION_INFO *OutRevisionInfo,
    OUT SAMPR_HANDLE *ServerHandle
    )
/*++

Routine Description:

    This routine establishes a RPC binding handle to the local SAM server.

    The difference between this SamrConnect and others is that this allows
    for the server to communicate to the client what features are currently
    supported (in addition to the client telling the server what revision
    the client is at).

Arguments:

    ServerName      - Name of the node this SAM reside on.  Ignored by this
                      routine.

    DesiredAccess   - Specifies the accesses desired to the SERVER object.

    InVersion       - the version of the InRevisionInfo

    InRevisionInfo  - information about the client

    OutVersion      - the version of OutRevisionInfo the server is returning to
                      the client

    OutRevisionInfo - information about the server sent back to the client

    ServerHandle    - If the connection is successful, the value returned
                      via this parameter serves as a context handle to the
                      opened SERVER object.


Return Value:


    STATUS_SUCCESS - The SERVER object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.

    STATUS_ACCESS_DENIED - client not granted a handle

    STATUS_NOT_SUPPORTED - the client message is not understood

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Drop calls over invalid / uninstalled protocol sequences
    //
    NtStatus = SampValidateRpcProtSeq((RPC_BINDING_HANDLE)NULL);
    
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }
    
    if (InVersion != 1) {
        return STATUS_NOT_SUPPORTED;
    }

    NtStatus = SampValidateRevisionInfo( InRevisionInfo, InVersion, TRUE );

    if( !NT_SUCCESS( NtStatus ) ) {
        return NtStatus;
    }

    //
    // Set the version of the out revision information
    //
    *OutVersion = 1;
    RtlZeroMemory(OutRevisionInfo, sizeof(*OutRevisionInfo));

    NtStatus = SampConnect(ServerName,
                           ServerHandle,
                           InRevisionInfo->V1.Revision,
                           DesiredAccess,
                           FALSE, // not trusted
                           FALSE, // not loopback
                           TRUE,  // NotSharedByMultiThreads
                           FALSE  // not an internal caller
                           );

    if (NT_SUCCESS(NtStatus)) {

        ULONG Features;

        OutRevisionInfo->V1.Revision = SAM_NETWORK_REVISION_LATEST;

        if ( SampIsExtendedSidModeEmulated(&Features) ) {
            OutRevisionInfo->V1.SupportedFeatures = Features;
        }
    }

    return NtStatus;
}


NTSTATUS
SampDsProtectSamObject(
    IN PVOID Parameter
    )
/*++
Routine Description:

    This routine updates SystemFlags attribute on SAM  object to prevent
    it from being deleted or renamed.

        Read object first, OR the systemFlags bit, then update if necessary

Parameters:

    Parameter -- the DSNAME of the object to protect.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       RetCode = 0;
    DSNAME      *Target = (DSNAME*) Parameter;
    ULONG       SystemFlags = 0;
    COMMARG     *pCommArg = NULL;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    ATTR        ReadAttr[2];
    ATTRBLOCK   ReadAttrBlock;
    ENTINFSEL   EntInfSel;
    MODIFYARG   ModArg;
    MODIFYRES   *pModRes = NULL;
    ATTR        Attr[2];
    ATTRVAL     AttrVal[2];
    ATTRVALBLOCK    AttrValBlock[2];
    BOOLEAN     fEndDsTransaction = FALSE;
    ULONG       i;
    BOOLEAN     fIsSystemCritical = FALSE;
    BOOLEAN     fIsSystemCriticalExists = FALSE;
    ATTRMODLIST SystemFlagModList;
    ATTRMODLIST IsCriticalModList;
    BOOLEAN     fSystemFlagsChanged = FALSE, fIsCriticalChanged = FALSE;
    ULONG       UlongTrue = 1;
    ULONG       DesiredServerSystemFlags = (FLAG_DISALLOW_DELETE        |
                                            FLAG_DOMAIN_DISALLOW_RENAME |
                                            FLAG_DOMAIN_DISALLOW_MOVE);


    RtlZeroMemory(&SystemFlagModList, sizeof(SystemFlagModList));
    RtlZeroMemory(&IsCriticalModList, sizeof(IsCriticalModList));

    //
    // open a DS transaction
    //

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    fEndDsTransaction = TRUE;


    //
    // read the original value of SystemFlags attribute
    //
    memset( &ReadArg, 0, sizeof(ReadArg) );
    memset( &EntInfSel, 0, sizeof(EntInfSel) );
    memset( ReadAttr, 0, sizeof(ReadAttr) );

    ReadAttr[0].attrTyp = ATT_SYSTEM_FLAGS;
    ReadAttr[1].attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
    ReadAttrBlock.attrCount = RTL_NUMBER_OF(ReadAttr);
    ReadAttrBlock.pAttr = ReadAttr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = Target;

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg( pCommArg );

    //
    // call DS routine
    //
    RetCode = DirRead(&ReadArg, &pReadRes);
    if (NULL == pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode, &pReadRes->CommRes);
    }
    SampClearErrors();

    if ( NT_SUCCESS(NtStatus) )
    {
        for (i = 0; i < pReadRes->entry.AttrBlock.attrCount; i++) {

            switch (pReadRes->entry.AttrBlock.pAttr[i].attrTyp) {
            case ATT_SYSTEM_FLAGS:
                SystemFlags = *((ULONG *)pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal);
                break;
            case ATT_IS_CRITICAL_SYSTEM_OBJECT:
                fIsSystemCriticalExists = TRUE;
                fIsSystemCritical = (*((ULONG *)pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)) == 0 ? FALSE : TRUE;
                break;
            default:
                NOTHING;
            }
        }
    }
    else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        // fail with other error
        goto Error;
    }


    if ((SystemFlags & DesiredServerSystemFlags) !=  DesiredServerSystemFlags){

        //
        // Need to update system flags
        //
        SystemFlags |= DesiredServerSystemFlags;

        AttrVal[0].valLen = sizeof(ULONG);
        AttrVal[0].pVal = (PUCHAR) &SystemFlags;

        AttrValBlock[0].valCount = 1;
        AttrValBlock[0].pAVal = &AttrVal[0];

        Attr[0].attrTyp = ATT_SYSTEM_FLAGS;
        Attr[0].AttrVal = AttrValBlock[0];

        SystemFlagModList.choice = AT_CHOICE_REPLACE_ATT;
        SystemFlagModList.AttrInf = Attr[0];

        fSystemFlagsChanged = TRUE;

    }

    if (!fIsSystemCriticalExists ||
        !fIsSystemCritical) {

        fIsSystemCritical = TRUE;

        AttrVal[1].valLen = sizeof(ULONG);
        AttrVal[1].pVal = (PUCHAR) &UlongTrue;

        AttrValBlock[1].valCount = 1;
        AttrValBlock[1].pAVal = &AttrVal[1];

        Attr[1].attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
        Attr[1].AttrVal = AttrValBlock[1];

        IsCriticalModList.choice = fIsSystemCriticalExists ? AT_CHOICE_REPLACE_ATT : AT_CHOICE_ADD_ATT;
        IsCriticalModList.AttrInf = Attr[1];

        fIsCriticalChanged = TRUE;
    }



    //
    // Fill the ModArg if anything needs changing
    //
    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = Target;
    ModArg.count = 0;

    if (fSystemFlagsChanged) {
        ModArg.FirstMod = SystemFlagModList;
        ModArg.count++;
        if (fIsCriticalChanged) {
            ModArg.FirstMod.pNextMod = &IsCriticalModList;
            ModArg.count++;
        }
    } else if (fIsCriticalChanged) {
        ModArg.count++;
        ModArg.FirstMod = IsCriticalModList;
    }

    if (ModArg.count == 0) {
        goto Error;
    }

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyEntry(&ModArg, &pModRes);
    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

Error:

    if (fEndDsTransaction)
    {
        SampMaybeEndDsTransaction( TransactionCommit );
    }

    //
    // register worker routine again if failed
    //
    if (!NT_SUCCESS(NtStatus))
    {
        LsaIRegisterNotification(
                    SampDsProtectSamObject,
                    Target,
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    300,        // wait for 5 minutes: 300 secound
                    NULL
                    );
    } else {

        midl_user_free(Target);
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\secdescr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SecDescr.c

Abstract:

    This file contains services related to the establishment of and modification
    of security descriptors for SAM objects.

    Note that there are a couple of special security descriptors that this routine
    does not build.  These are the security descriptors for the DOMAIN_ADMIN group,
    the ADMIN user account, and the SAM object.  For the first release, in which
    creation of domains is not supported, the DOMAIN object's security descriptor
    is also not created here.

    These security descriptors are built by the program that initializes a SAM
    database.


Author:

    Jim Kelly    (JimK)  14-Oct-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <sdconvrt.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <dslayer.h>
#include <sdconvrt.h>
#include <samtrace.h>
#include "validate.h"




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampCheckForDescriptorRestrictions(
    IN PSAMP_OBJECT             Context,
    IN SAMP_OBJECT_TYPE         ObjectType,
    IN ULONG                    ObjectRid,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    );





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services available for use throughout SAM                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampInitializeDomainDescriptors(
    ULONG Index
    )
/*++


Routine Description:

    This routine initializes security descriptors needed to protect
    user, group, and alias objects.

    These security descriptors are placed in the SampDefinedDomains[] array.

    This routine expects all SIDs to be previously initialized.

    The following security descriptors are prepared:

            AdminUserSD - Contains a SD appropriate for applying to
                a user object that is a member of the ADMINISTRATORS
                alias.

            AdminGroupSD - Contains a SD appropriate for applying to
                a group object that is a member of the ADMINISTRATORS
                alias.

            NormalUserSD - Contains a SD appropriate for applying to
                a user object that is NOT a member of the ADMINISTRATORS
                alias.

            NormalGroupSD - Contains a SD appropriate for applying to
                a Group object that is NOT a member of the ADMINISTRATORS
                alias.

            NormalAliasSD - Contains a SD appropriate for applying to
                newly created alias objects.



    Additionally, the following related information is provided:

            AdminUserRidPointer
            NormalUserRidPointer

                Points to the last RID of the ACE in the corresponding
                SD's DACL which grants access to the user.  This rid
                must be replaced with the user's rid being the SD is
                applied to the user object.



            AdminUserSDLength
            AdminGroupSDLength
            NormalUserSDLength
            NormalGroupSDLength
            NormalAliasSDLength

                The length, in bytes, of the corresponding security
                descriptor.




Arguments:

    Index - The index of the domain whose security descriptors are being
        created.  The Sid field of this domain's data structure is already
        expected to be set.

Return Value:

    STATUS_SUCCESS - The security descriptors have been successfully initialized.

    STATUS_INSUFFICIENT_RESOURCES - Heap could not be allocated to produce the needed
        security descriptors.

--*/
{

    NTSTATUS Status;
    ULONG Size;

    PSID AceSid[10];          // Don't expect more than 10 ACEs in any of these.
    ACCESS_MASK AceMask[10];  // Access masks corresponding to Sids

    GENERIC_MAPPING  AliasMap     =  {ALIAS_READ,
                                      ALIAS_WRITE,
                                      ALIAS_EXECUTE,
                                      ALIAS_ALL_ACCESS
                                      };

    GENERIC_MAPPING  GroupMap     =  {GROUP_READ,
                                      GROUP_WRITE,
                                      GROUP_EXECUTE,
                                      GROUP_ALL_ACCESS
                                      };

    GENERIC_MAPPING  UserMap      =  {USER_READ,
                                      USER_WRITE,
                                      USER_EXECUTE,
                                      USER_ALL_ACCESS
                                      };


    SID_IDENTIFIER_AUTHORITY
            BuiltinAuthority      =   SECURITY_NT_AUTHORITY;


    ULONG   AdminsSidBuffer[8],
            AccountSidBuffer[8];

    PSID    AdminsAliasSid        =   &AdminsSidBuffer[0],
            AccountAliasSid       =   &AccountSidBuffer[0],
            AnySidInAccountDomain =   NULL;

    SAMTRACE("SampInitializeDomainDescriptors");


    //
    // Make sure the buffer we've alloted for the simple sids above
    // are large enough.
    //
    //
    //      ADMINISTRATORS and ACCOUNT_OPERATORS aliases
    //      are  is S-1-5-20-x (2 sub-authorities)
    //
    ASSERT( RtlLengthRequiredSid(2) <= ( 8 * sizeof(ULONG) ) );


    ////////////////////////////////////////////////////////////////////////////////////
    //                                                                                //
    // Initialize the SIDs we'll need.
    //                                                                                //
    ////////////////////////////////////////////////////////////////////////////////////


    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;

    //
    // Initialize a SID that can be used to represent accounts
    // in this domain.
    //
    // This is the same as the domain sid found in the DefinedDomains[]
    // array except it has one more sub-authority.
    // It doesn't matter what the value of the last RID is because it
    // is always replaced before use.
    //

    Size = RtlLengthSid( SampDefinedDomains[Index].Sid ) + sizeof(ULONG);
    AnySidInAccountDomain = RtlAllocateHeap( RtlProcessHeap(), 0, Size);
    if (NULL==AnySidInAccountDomain)
    {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( AnySidInAccountDomain != NULL );
    Status = RtlCopySid(
                Size,
                AnySidInAccountDomain,
                SampDefinedDomains[Index].Sid );
    ASSERT(NT_SUCCESS(Status));
    (*RtlSubAuthorityCountSid( AnySidInAccountDomain )) += 1;








    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    //
    //
    //
    //
    //   The following security is assigned to groups that are made
    //   members of the ADMINISTRATORS alias.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //   All other aliases and groups must be assigned the following
    //   security:
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant           Grant
    //              WORLD               Administrators  AccountOperators Alias
    //              (Execute | Read)    GenericAll      GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //
    //   The following security is assigned to users  that are made a
    //   member of the ADMINISTRATORS alias.  This includes direct
    //   inclusion or indirect inclusion through group membership.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant            Grant          Grant
    //              WORLD            Administrators User's SID
    //              (Execute | Read) GenericAll     GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //   All other users must be assigned the following
    //   security:
    //
    //      Owner: AccountOperators Alias
    //      Group: AccountOperators Alias
    //
    //      Dacl:   Grant            Grant          Grant                   Grant
    //              WORLD            Administrators Account Operators Alias User's SID
    //              (Execute | Read) GenericAll     GenericAll              GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    // Note  that because we are going to cram these ACLs directly
    // into the backing store, we must map the generic accesses
    // beforehand.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////





    //
    // We're not particularly good about freeing memory on error
    // conditions below.  Generally speaking, if this doens't
    // initialize correctly, the system is hosed.
    //


    //
    // Normal Alias SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].NormalAliasSDLength, // Descriptor
                 &SampDefinedDomains[Index].NormalAliasSD,       // Descriptor
                 NULL                                            // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }





    //
    // Admin Group SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].AdminGroupSDLength,  // Descriptor
                 &SampDefinedDomains[Index].AdminGroupSD,        // Descriptor
                 NULL                                           // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }



    //
    // Normal GROUP SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (GROUP_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].NormalGroupSDLength,  // Descriptor
                 &SampDefinedDomains[Index].NormalGroupSD,        // Descriptor
                 NULL                                             // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }




    //
    // Admin User SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AnySidInAccountDomain;
    AceMask[2] = (USER_WRITE);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // Not user object
                 &SampDefinedDomains[Index].AdminUserSDLength,  // Descriptor
                 &SampDefinedDomains[Index].AdminUserSD,        // Descriptor
                 &SampDefinedDomains[Index].AdminUserRidPointer // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }



    //
    // Normal User SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);

    AceSid[3]  = AnySidInAccountDomain;
    AceMask[3] = (USER_WRITE);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // Not user object
                 &SampDefinedDomains[Index].NormalUserSDLength,  // Descriptor
                 &SampDefinedDomains[Index].NormalUserSD,        // Descriptor
                 &SampDefinedDomains[Index].NormalUserRidPointer // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }

done:


    RtlFreeHeap( RtlProcessHeap(), 0, AnySidInAccountDomain );


    return(Status);

}


NTSTATUS
SampBuildSamProtection(
    IN PSID WorldSid,
    IN PSID AdminsAliasSid,
    IN ULONG AceCount,
    IN PSID AceSid[],
    IN ACCESS_MASK AceMask[],
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PULONG DescriptorLength,
    OUT PSECURITY_DESCRIPTOR *Descriptor,
    OUT PULONG *RidToReplace OPTIONAL
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the SAM objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.

    The owner and group of each security descriptor will be set
    to:

                    Owner:  Administrators Alias
                    Group:  Administrators Alias


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity)



Arguments:

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    GenericMap - Points to a generic mapping for the target object type.


    UserObject - Indicates whether the target SAM object is a User object
        or not.  If TRUE (it is a User object), then the resultant
        protection will be set up indicating Rid replacement is necessary.


    DescriptorLength - Receives the length of the resultant SD.

    Descriptor - Receives a pointer to the resultant SD.

    RidToReplace - Is required aif userObject is TRUE and will be set
        to point to the user's RID.


Return Value:

    TBS.

--*/
{

    NTSTATUS                Status;

    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative;
    PACL                    TmpAcl;
    PACCESS_ALLOWED_ACE     TmpAce;
    PSID                    TmpSid;
    ULONG                   Length, i;
    PULONG                  RidLocation = NULL;
    BOOLEAN                 IgnoreBoolean;
    ACCESS_MASK             MappedMask;

    SAMTRACE("SampBuildSamProtection");

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //


    Status = RtlCreateSecurityDescriptor(
                 &Absolute,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    //
    // Owner
    //

    Status = RtlSetOwnerSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    //
    // Group
    //

    Status = RtlSetGroupSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }




    //
    // Discretionary ACL
    //
    //      Calculate its length,
    //      Allocate it,
    //      Initialize it,
    //      Add each ACE
    //      Add it to the security descriptor
    //

    Length = (ULONG)sizeof(ACL);
    for (i=0; i<AceCount; i++) {

        Length += RtlLengthSid( AceSid[i] ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length
    }

    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    for (i=0; i<AceCount; i++) {
        MappedMask = AceMask[i];
        RtlMapGenericMask( &MappedMask, GenericMap );
        Status = RtlAddAccessAllowedAce (
                     TmpAcl,
                     ACL_REVISION2,
                     MappedMask,
                     AceSid[i]
                     );
        ASSERT( NT_SUCCESS(Status) );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
    }

    Status = RtlSetDaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }




    //
    // Sacl
    //


    Length = (ULONG)sizeof(ACL) +
             RtlLengthSid( WorldSid ) +
             RtlLengthSid( SampAnonymousSid ) +
             2*((ULONG)sizeof(SYSTEM_AUDIT_ACE) - (ULONG)sizeof(ULONG));  //Subtract out SidStart field length
    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 (GenericMap->GenericWrite | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY)& ~READ_CONTROL,
                 WorldSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 GenericMap->GenericWrite | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                 SampAnonymousSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlSetSaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }






    //
    // Convert the Security Descriptor to Self-Relative
    //
    //      Get the length needed
    //      Allocate that much memory
    //      Copy it
    //      Free the generated absolute ACLs
    //

    Length = 0;
    Status = RtlAbsoluteToSelfRelativeSD( &Absolute, NULL, &Length );
    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    Relative = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(Relative != NULL);
    if (NULL==Relative)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = RtlAbsoluteToSelfRelativeSD(&Absolute, Relative, &Length );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }


    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Dacl );
    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Sacl );




    //
    // If the object is a user object, then get the address of the
    // last RID of the SID in the last ACE in the DACL.
    //

    if (UserObject == TRUE) {

        Status = RtlGetDaclSecurityDescriptor(
                    Relative,
                    &IgnoreBoolean,
                    &TmpAcl,
                    &IgnoreBoolean
                    );
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        Status = RtlGetAce ( TmpAcl, AceCount-1, (PVOID *)&TmpAce );
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        TmpSid = (PSID)(&TmpAce->SidStart),

        RidLocation = RtlSubAuthoritySid(
                          TmpSid,
                          (ULONG)(*RtlSubAuthorityCountSid( TmpSid ) - 1)
                          );
    }


    //
    // Set the result information
    //

    (*DescriptorLength) = Length;
    (*Descriptor)       = Relative;
    if (ARGUMENT_PRESENT(RidToReplace)) {
        ASSERT(UserObject && "Must be User Object\n");
        (*RidToReplace) = RidLocation;
    }



    return(Status);

}

NTSTATUS
SampGetNewAccountSecurity(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )


/*++

Routine Description:

    This service creates a standard self-relative security descriptor
    for a new USER, GROUP or ALIAS account.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


Arguments:

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS alias).

    TrustedClient - Indicates whether the client is a trusted client
        or not.  TRUE indicates the client is trusted, FALSE indicates
        the client is not trusted.

    RestrictCreatorAccess - Indicates whether or not the creator's
        access to the object is to be restricted according to
        specific rules.  Also indicates whether or not the account
        is to be given any access to itself.  An account will only
        be given access to itself if there are no creator access
        restrictions.

        The following ObjectTypes have restriction rules that may
        be requested:

            User:
                    - Admin is assigned as owner of the object.
                    - Creator is given (DELETE | USER_WRITE) access.


    NewAccountRid - The relative ID of the new account.

        Context - In the DS case this context gives an open context to the object
                in question. This open context is used to consider the class of the
                DS object while constucting the security descriptor.

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{

    NTSTATUS    NtStatus;

    //
    // Check wether we are running from the DS. If yes then we should
    // call the new SampBuildNt5Protection call
    //

    if (IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context))
    {
        //
        //  If we are using the Ds, then we should never be constructing a default
        //  security descriptor, but rather getting the security descriptor from
        //  the schema.
        //

        ASSERT(FALSE);
        NtStatus = STATUS_INTERNAL_ERROR;


    }
    else
    {
        NtStatus = SampGetNewAccountSecurityNt4(
                        ObjectType,
                        Admin,
                        TrustedClient,
                        RestrictCreatorAccess,
                        NewAccountRid,
                        SampTransactionDomainIndex,
                        NewDescriptor,
                        DescriptorLength
                        );
    }

    return NtStatus;
}




NTSTATUS
SampGetNewAccountSecurityNt4(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN ULONG   DomainIndex,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )


/*++

Routine Description:

    This service creates a standard self-relative security descriptor
    for a new USER, GROUP or ALIAS account.



Arguments:

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS alias).

    TrustedClient - Indicates whether the client is a trusted client
        or not.  TRUE indicates the client is trusted, FALSE indicates
        the client is not trusted.

    RestrictCreatorAccess - Indicates whether or not the creator's
        access to the object is to be restricted according to
        specific rules.  Also indicates whether or not the account
        is to be given any access to itself.  An account will only
        be given access to itself if there are no creator access
        restrictions.

        The following ObjectTypes have restriction rules that may
        be requested:

            User:
                    - Admin is assigned as owner of the object.
                    - Creator is given (DELETE | USER_WRITE) access.


    NewAccountRid - The relative ID of the new account.

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    ULONG                AccountSidBuffer[8];
    PSID                 AccountAliasSid = &AccountSidBuffer[0];

    SECURITY_DESCRIPTOR  DaclDescriptor;
    NTSTATUS             NtStatus = STATUS_SUCCESS;
    NTSTATUS             IgnoreStatus;
    HANDLE               ClientToken = INVALID_HANDLE_VALUE;
    ULONG                DataLength = 0;
    ACCESS_ALLOWED_ACE   *NewAce = NULL;
    PACL                 NewDacl = NULL;
    PACL                 OldDacl = NULL;
    PSECURITY_DESCRIPTOR StaticDescriptor = NULL;
    PSECURITY_DESCRIPTOR LocalDescriptor = NULL;
    PTOKEN_GROUPS        ClientGroups = NULL;
    PTOKEN_OWNER         SubjectOwner = NULL;
    PSID                 SubjectSid = NULL;
    ULONG                AceLength = 0;
    ULONG                i;
    BOOLEAN              AdminAliasFound = FALSE;
    BOOLEAN              AccountAliasFound = FALSE;
    BOOLEAN              DaclPresent, DaclDefaulted;

    GENERIC_MAPPING GenericMapping;
    GENERIC_MAPPING AliasMap     =  {ALIAS_READ,
                                     ALIAS_WRITE,
                                     ALIAS_EXECUTE,
                                     ALIAS_ALL_ACCESS
                                     };

    GENERIC_MAPPING GroupMap     =  {GROUP_READ,
                                     GROUP_WRITE,
                                     GROUP_EXECUTE,
                                     GROUP_ALL_ACCESS
                                     };

    GENERIC_MAPPING UserMap      =  {USER_READ,
                                     USER_WRITE,
                                     USER_EXECUTE,
                                     USER_ALL_ACCESS
                                     };

    BOOLEAN              ImpersonatingNullSession = FALSE;

    SAMTRACE("SampGetNewAccountSecurity");

    //
    // Security account objects don't pick up security in the normal
    // fashion in the release 1 timeframe.  They are assigned a well-known
    // security descriptor based upon their object type.
    //
    // Notice that all the accounts with tricky security are created when
    // the domain is created (e.g., admin groups and admin user account).
    //

    switch (ObjectType) {

    case SampGroupObjectType:

        ASSERT(RestrictCreatorAccess == FALSE);

        //
        // NewAccountRid parameter is ignored for groups.
        //

        if (Admin == TRUE) {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].AdminGroupSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].AdminGroupSDLength;
        } else {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].NormalGroupSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].NormalGroupSDLength;
        }

        GenericMapping = GroupMap;

        break;


    case SampAliasObjectType:

        ASSERT(RestrictCreatorAccess == FALSE);

        //
        // Admin and NewAccountRid parameters are ignored for aliases.
        //

        StaticDescriptor =
            SampDefinedDomains[DomainIndex].NormalAliasSD;
        (*DescriptorLength) =
            SampDefinedDomains[DomainIndex].NormalAliasSDLength;

        GenericMapping = AliasMap;

        break;


    case SampUserObjectType:

        if (Admin == TRUE) {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].AdminUserSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].AdminUserSDLength;
            (*SampDefinedDomains[DomainIndex].AdminUserRidPointer)
                = NewAccountRid;

        } else {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].NormalUserSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].NormalUserSDLength;
            (*SampDefinedDomains[DomainIndex].NormalUserRidPointer)
                = NewAccountRid;
        }

        GenericMapping = UserMap;

        break;

    }

    //
    // We have a pointer to SAM's static security descriptor.  Copy it
    // into a heap buffer that RtlSetSecurityObject() will like.
    //

    LocalDescriptor = RtlAllocateHeap( RtlProcessHeap(), 0, (*DescriptorLength) );

    if ( LocalDescriptor == NULL ) {

        (*NewDescriptor) = NULL;
        (*DescriptorLength) = 0;

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        LocalDescriptor,
        StaticDescriptor,
        (*DescriptorLength)
        );

    //
    // If the caller is to have restricted access to this account,
    // then remove the last ACE from the ACL (the one intended for
    // the account itself).
    //

    if (RestrictCreatorAccess) {
        NtStatus = RtlGetDaclSecurityDescriptor(
                       LocalDescriptor,
                       &DaclPresent,
                       &OldDacl,
                       &DaclDefaulted
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        ASSERT(DaclPresent);
        ASSERT(OldDacl->AceCount >= 1);

        OldDacl->AceCount -= 1;  // Remove the last ACE from the ACL.
    }


    //
    // If the caller is not a trusted client, see if the caller is an
    // administrator or an account operator.  If not, add an ACCESS_ALLOWED
    // ACE to the DACL that gives full access to the creator (or restricted
    // access, if so specified).
    //

    if ( !TrustedClient ) {

        NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

        if (NT_SUCCESS(NtStatus)) {   // if (ImpersonatingClient)

            NtStatus = NtOpenThreadToken(
                           NtCurrentThread(),
                           TOKEN_QUERY,
                           TRUE,            //OpenAsSelf
                           &ClientToken
                           );

            //
            // Stop impersonating the client
            //

            SampRevertToSelf(ImpersonatingNullSession);

            if (NT_SUCCESS(NtStatus)) {     // if (TokenOpened)




                //
                // See if the caller is an administrator or an account
                // operator.  First, see how big
                // a buffer we need to hold the caller's groups.
                //

                NtStatus = NtQueryInformationToken(
                               ClientToken,
                               TokenGroups,
                               NULL,
                               0,
                               &DataLength
                               );

                if ( ( NtStatus == STATUS_BUFFER_TOO_SMALL ) &&
                    ( DataLength > 0 ) ) {

                    ClientGroups = MIDL_user_allocate( DataLength );

                    if ( ClientGroups == NULL ) {

                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        //
                        // Now get a list of the caller's groups.
                        //

                        NtStatus = NtQueryInformationToken(
                                       ClientToken,
                                       TokenGroups,
                                       ClientGroups,
                                       DataLength,
                                       &DataLength
                                       );

                        if ( NT_SUCCESS( NtStatus ) ) {


                            //
                            // Build the SID of the ACCOUNT_OPS alias, so we
                            // can see if the user is included in it.
                            //

                            RtlInitializeSid(
                                AccountAliasSid,
                                &BuiltinAuthority,
                                2 );

                            *(RtlSubAuthoritySid( AccountAliasSid,  0 )) =
                                SECURITY_BUILTIN_DOMAIN_RID;

                            *(RtlSubAuthoritySid( AccountAliasSid,  1 )) =
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS;

                            //
                            // See if the ADMIN or ACCOUNT_OPS alias is in
                            // the caller's groups.
                            //

                            for ( i = 0; i < ClientGroups->GroupCount; i++ ) {

                                SubjectSid = ClientGroups->Groups[i].Sid;
                                ASSERT( SubjectSid != NULL );

                                if ( RtlEqualSid( SubjectSid, SampAdministratorsAliasSid  ) ) {

                                    AdminAliasFound = TRUE;
                                    break;
                                }
                                if ( RtlEqualSid( SubjectSid, AccountAliasSid ) ) {

                                    AccountAliasFound = TRUE;
                                    break;
                                }
                            }

                            //
                            // If the callers groups did not include the admins
                            // alias, add an ACCESS_ALLOWED ACE for the owner.
                            //

                            if ( !AdminAliasFound && !AccountAliasFound ) {

                                //
                                // First, find out what size buffer we need
                                // to get the owner.
                                //

                                NtStatus = NtQueryInformationToken(
                                               ClientToken,
                                               TokenOwner,
                                               NULL,
                                               0,
                                               &DataLength
                                               );

                                if ( ( NtStatus == STATUS_BUFFER_TOO_SMALL ) &&
                                    ( DataLength > 0 ) ) {

                                    SubjectOwner = MIDL_user_allocate( DataLength );

                                    if ( SubjectOwner == NULL ) {

                                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                                    } else {

                                        //
                                        // Now, query the owner that will be
                                        // given access to the object
                                        // created.
                                        //

                                        NtStatus = NtQueryInformationToken(
                                                       ClientToken,
                                                       TokenOwner,
                                                       SubjectOwner,
                                                       DataLength,
                                                       &DataLength
                                                       );

                                        if ( NT_SUCCESS( NtStatus ) ) {

                                            //
                                            // Create an ACE that gives the
                                            // owner full access.
                                            //

                                            AceLength = sizeof( ACE_HEADER ) +
                                                        sizeof( ACCESS_MASK ) +
                                                        RtlLengthSid(
                                                            SubjectOwner->Owner );

                                            NewAce = (ACCESS_ALLOWED_ACE *)
                                                    MIDL_user_allocate( AceLength );

                                            if ( NewAce == NULL ) {

                                                NtStatus =
                                                    STATUS_INSUFFICIENT_RESOURCES;

                                            } else {

                                                NewAce->Header.AceType =
                                                    ACCESS_ALLOWED_ACE_TYPE;

                                                NewAce->Header.AceSize = (USHORT) AceLength;
                                                NewAce->Header.AceFlags = 0;
                                                NewAce->Mask = USER_ALL_ACCESS;

                                                //
                                                // If the creator's access is
                                                // to be restricted, change the
                                                // AccessMask.
                                                //

                                                if (RestrictCreatorAccess) {
                                                    NewAce->Mask = DELETE     |
                                                                   USER_WRITE |
                                                                   USER_FORCE_PASSWORD_CHANGE;
                                                }

                                                RtlCopySid(
                                                    RtlLengthSid(
                                                        SubjectOwner->Owner ),
                                                    (PSID)( &NewAce->SidStart ),
                                                    SubjectOwner->Owner );

                                                //
                                                // Allocate a new, larger ACL and
                                                // copy the old one into it.
                                                //

                                                NtStatus =
                                                    RtlGetDaclSecurityDescriptor(
                                                        LocalDescriptor,
                                                        &DaclPresent,
                                                        &OldDacl,
                                                        &DaclDefaulted
                                                        );

                                                if ( NT_SUCCESS( NtStatus ) ) {

                                                    NewDacl = MIDL_user_allocate(
                                                                  OldDacl->AclSize +
                                                                  AceLength );

                                                    if ( NewDacl == NULL ) {

                                                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                                                    } else {

                                                        RtlCopyMemory(
                                                            NewDacl,
                                                            OldDacl,
                                                            OldDacl->AclSize
                                                            );

                                                        NewDacl->AclSize =
                                                            OldDacl->AclSize +
                                                            (USHORT) AceLength;

                                                        //
                                                        // Add the new ACE
                                                        // to the new ACL.
                                                        //

                                                        NtStatus = RtlAddAce(
                                                            NewDacl,
                                                            ACL_REVISION2,
                                                            1,                      // add after first ACE (world)
                                                            (PVOID)NewAce,
                                                            AceLength
                                                            );
                                                    }  // end_if (allocated NewDacl)
                                                } // end_if (get DACL from SD)
                                            } // end_if (allocated NewAce)
                                        } // end_if (Query TokenOwner Succeeded)
                                    } // end_if (Allocated TokenOwner buffer)
                                } // end_if (Query TokenOwner size Succeeded)
                            } // end_if (not admin)
                        } // end_if (Query TokenGroups Succeeded)
                    } // end_if (Allocated TokenGroups buffer)
                } // end_if (Query TokenGroups size Succeeded)

                IgnoreStatus = NtClose( ClientToken );
                ASSERT(NT_SUCCESS(IgnoreStatus));

            }  // end_if (TokenOpened)
        } // end_if (ImpersonatingClient)
    } // end_if (TrustedClient)

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // If we created a new DACL above, stick it on the security
        // descriptor.
        //

        if ( NewDacl != NULL ) {

            NtStatus = RtlCreateSecurityDescriptor(
                           &DaclDescriptor,
                           SECURITY_DESCRIPTOR_REVISION1
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Set the DACL on the LocalDescriptor.  Note that this
                // call will RtlFreeHeap() the old descriptor, and allocate
                // a new one.
                //

                DaclDescriptor.Control = SE_DACL_PRESENT;
                DaclDescriptor.Dacl = NewDacl;

                NtStatus = RtlSetSecurityObject(
                               DACL_SECURITY_INFORMATION,
                               &DaclDescriptor,
                               &LocalDescriptor,
                               &GenericMapping,
                               NULL
                               );
            }
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Copy the security descriptor and length into buffers for the
        // caller.  AceLength is 0 if we didn't add an ACE to the DACL
        // above.
        //

        (*DescriptorLength) = (*DescriptorLength) + AceLength;

        (*NewDescriptor) = MIDL_user_allocate( (*DescriptorLength) );

        if ( (*NewDescriptor) == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyMemory(
                (*NewDescriptor),
                LocalDescriptor,
                (*DescriptorLength)
                );
        }
    }

    //
    // Free up local items that may have been allocated.
    //

    if ( LocalDescriptor != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, LocalDescriptor );
    }

    if ( ClientGroups != NULL ) {
        MIDL_user_free( ClientGroups );
    }

    if ( SubjectOwner != NULL ) {
        MIDL_user_free( SubjectOwner );
    }

    if ( NewAce != NULL ) {
        MIDL_user_free( NewAce );
    }

    if ( NewDacl != NULL ) {
        MIDL_user_free( NewDacl );
    }


    if ( !NT_SUCCESS( NtStatus ) ) {

        (*NewDescriptor) = NULL;
        (*DescriptorLength) = 0;
    }

    return( NtStatus );
}


NTSTATUS
SampModifyAccountSecurity(
    IN PSAMP_OBJECT Context,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN PSECURITY_DESCRIPTOR OldDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )
/*++

Routine Description:

    This service modifies a self-relative security descriptor
    for a USER or GROUP to add or remove account operator access.


Arguments:

    Context    -- Takes the Context of the object whose security Descriptor
       needs to be modified. The object's context is required in the DS
       case where information regarding the actual class of the object is
       used in constructing the security descriptor.

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS or an operator alias).

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    ULONG                AccountSidBuffer[8];
    PSID                 AccountAliasSid = &AccountSidBuffer[0];
    NTSTATUS             NtStatus = STATUS_SUCCESS;
    NTSTATUS             IgnoreStatus;
    ULONG                Length;
    ULONG                i,j;
    ULONG                AccountOpAceIndex;
    ULONG                AceCount;
    PACL                 OldDacl;
    PACL                 NewDacl = NULL;
    BOOLEAN              DaclDefaulted;
    BOOLEAN              DaclPresent;
    ACL_SIZE_INFORMATION AclSizeInfo;
    PACCESS_ALLOWED_ACE  Ace;
    PGENERIC_MAPPING     GenericMapping;
    ACCESS_MASK          AccountOpAccess;
    SECURITY_DESCRIPTOR  AbsoluteDescriptor;
    PSECURITY_DESCRIPTOR  LocalDescriptor = NULL;

    GENERIC_MAPPING GroupMap     =  {GROUP_READ,
                                     GROUP_WRITE,
                                     GROUP_EXECUTE,
                                     GROUP_ALL_ACCESS
                                     };

    GENERIC_MAPPING UserMap      =  {USER_READ,
                                     USER_WRITE,
                                     USER_EXECUTE,
                                     USER_ALL_ACCESS
                                     };

    SAMTRACE("SampModifyAccountSecurity");



    if (IsDsObject(Context))
    {
       //
           // We should never ever need to modify account security the way
           // NT4.0 used to do
           //

                ASSERT(FALSE);

    }
    else
    {



        NtStatus = RtlCopySecurityDescriptor(
                        OldDescriptor,
                        &LocalDescriptor
                        );

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Build the SID of the ACCOUNT_OPS alias, so we
        // can see if is in the DACL or we can add it to the DACL.
        //

        RtlInitializeSid(
            AccountAliasSid,
            &BuiltinAuthority,
            2
            );

        *(RtlSubAuthoritySid( AccountAliasSid,  0 )) =
            SECURITY_BUILTIN_DOMAIN_RID;

        *(RtlSubAuthoritySid( AccountAliasSid,  1 )) =
            DOMAIN_ALIAS_RID_ACCOUNT_OPS;

        //
        // The approach is to set up an absolute security descriptor that
        // contains the new DACL, and then merge that into the existing
        // security descriptor.
        //


        IgnoreStatus = RtlCreateSecurityDescriptor(
                            &AbsoluteDescriptor,
                            SECURITY_DESCRIPTOR_REVISION1
                            );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Figure out the access granted to account operators and the
        // generic mask to use.
        //

        if (ObjectType == SampUserObjectType) {
            AccountOpAccess = USER_ALL_ACCESS;
            GenericMapping = &UserMap;
        } else if (ObjectType == SampGroupObjectType) {
            AccountOpAccess = GROUP_ALL_ACCESS;
            GenericMapping = &GroupMap;
        } else {
            //
            // This doesn't apply to aliases, domains, or servers.
            //
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Get the old DACL off the passed in security descriptor.
        //

        IgnoreStatus = RtlGetDaclSecurityDescriptor(
                            OldDescriptor,
                            &DaclPresent,
                            &OldDacl,
                            &DaclDefaulted
                            );

        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // We will only modify the DACL if it is present
        //

        if (!DaclPresent) {
            *NewDescriptor = LocalDescriptor;
            *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
            return(STATUS_SUCCESS);
        }

        //
        // Get the count of ACEs
        //

        IgnoreStatus = RtlQueryInformationAcl(
                            OldDacl,
                            &AclSizeInfo,
                            sizeof(AclSizeInfo),
                            AclSizeInformation
                            );


        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Calculate the lenght of the new ACL.
        //

        Length = (ULONG)sizeof(ACL);
        AccountOpAceIndex = 0xffffffff;


        for (i = 0; i < AclSizeInfo.AceCount; i++) {
            IgnoreStatus = RtlGetAce(
                                OldDacl,
                                i,
                                (PVOID *) &Ace
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));

            //
            // Check if this is an access allowed ACE, and the ACE is for
            // the Account Operators alias.
            //

            if ( (Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) &&
                 RtlEqualSid( AccountAliasSid,
                              &Ace->SidStart ) ) {

                AccountOpAceIndex = i;
                continue;
            }
            Length += Ace->Header.AceSize;
        }


        if (!Admin) {

            //
            // If we are making this account not be an admin account and it already
            // has an account operator ace, we are done.
            //

            if ( AccountOpAceIndex != 0xffffffff ) {

                *NewDescriptor = LocalDescriptor;
                *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
                return(STATUS_SUCCESS);
            } else {

                //
                // Add the size of an account operator ace to the required length
                //

                Length += sizeof(ACCESS_ALLOWED_ACE) +
                            RtlLengthSid(AccountAliasSid) -
                            sizeof(ULONG);
            }

        }

        NewDacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

        if (NewDacl == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        IgnoreStatus = RtlCreateAcl( NewDacl, Length, ACL_REVISION2);
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Add the old ACEs back into this ACL.
        //

        for (i = 0, j = 0; i < AclSizeInfo.AceCount; i++) {
            if (i == AccountOpAceIndex) {
                ASSERT(Admin);
                continue;
            }
            //
            // Add back in the old ACEs
            //

            IgnoreStatus = RtlGetAce(
                                OldDacl,
                                i,
                                (PVOID *) &Ace
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));

            IgnoreStatus = RtlAddAce (
                                NewDacl,
                                ACL_REVISION2,
                                j,  // note: constant value of 0 implies
                                    // adding the ACE at the front
                                Ace,
                                Ace->Header.AceSize
                                );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        //
        // If we are making this account not be an administrator, add the
        // access allowed ACE for the account operator. This ACE is always
        // the second to last one.
        //

        if (!Admin) {
            IgnoreStatus = RtlAddAccessAllowedAce(
                                NewDacl,
                                ACL_REVISION2,
                                AccountOpAccess,
                                AccountAliasSid
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        //
        // Insert this DACL into the security descriptor.
        //

        IgnoreStatus = RtlSetDaclSecurityDescriptor (
                            &AbsoluteDescriptor,
                            TRUE,                   // DACL present
                            NewDacl,
                            FALSE                   // DACL not defaulted
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Now call RtlSetSecurityObject to merge the existing security descriptor
        // with the new DACL we just created.
        //


        NtStatus = RtlSetSecurityObject(
                        DACL_SECURITY_INFORMATION,
                        &AbsoluteDescriptor,
                        &LocalDescriptor,
                        GenericMapping,
                        NULL
                        );
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        *NewDescriptor = LocalDescriptor;
        *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
        LocalDescriptor = NULL;
    }
Cleanup:

    if ( NewDacl != NULL ) {
        RtlFreeHeap(RtlProcessHeap(),0, NewDacl );
    }
    if (LocalDescriptor != NULL) {
        RtlDeleteSecurityObject(&LocalDescriptor);
    }

    return( NtStatus );
}




NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store.




Arguments:

    Context - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;

    SAMTRACE("SampGetObjectSD");

    (*SecurityDescriptorLength) = 0;

    //
    // for server and domain object, get security descriptor from in memory
    // cache. Any failure here is treated as a cache miss.
    // In fact, there are only two errors returned
    //
    //      Cached SD is not available - SAM has a separate thread to update it later.
    //                                   proceed with SampGetAccessAttribute() here
    //
    //      Resource failure - will return immediately
    //

    if (IsDsObject(Context) &&
        (SampServerObjectType == Context->ObjectType ||SampDomainObjectType == Context->ObjectType)
        )
    {
        NtStatus = SampGetCachedObjectSD(
                        Context,
                        SecurityDescriptorLength,
                        SecurityDescriptor
                        );

        //
        // STATUS_UNSUCCESSFUL from the above routine means a cache miss,
        // should proceed with SampGetAccessAttribute().
        //
        // return for all the other cases.
        //
        if (STATUS_UNSUCCESSFUL != NtStatus)
        {
            return( NtStatus );
        }
    }


    NtStatus = SampGetAccessAttribute(
                    Context,
                    SAMP_OBJECT_SECURITY_DESCRIPTOR,
                    TRUE, // Make copy
                    &Revision,
                    SecurityDescriptor
                    );

    if (NT_SUCCESS(NtStatus)) {

        if ( SAMP_UNKNOWN_REVISION( Revision ) )
        {
            NtStatus = STATUS_UNKNOWN_REVISION;
        }


        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free( (*SecurityDescriptor) );
            *SecurityDescriptor = NULL;
        }
    }


    if (NT_SUCCESS(NtStatus)) {
        *SecurityDescriptorLength = GetSecurityDescriptorLength(
                                        (*SecurityDescriptor) );
    }

    return(NtStatus);
}


NTSTATUS
SampGetDomainObjectSDFromDsName(
    IN DSNAME   *DomainObjectDsName,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store
    based upon the object's DS name.

    MUST be running in DS mode


Arguments:

    DomainObjectDsName - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;

    ATTRTYP  SDType[] = {SAMP_DOMAIN_SECURITY_DESCRIPTOR};
    ATTRVAL  SDVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(SDAttrBlock,SDType,SDVal);
    ATTRBLOCK   ReadSDAttrBlock;
    ULONG       ValLength = 0;


    SAMTRACE("SampGetDomainObjectSDFromDsName");


    ASSERT(DomainObjectDsName);

    (*SecurityDescriptorLength) = 0;

    //
    // Get the domain object security descriptor
    //
    NtStatus = SampDsRead(DomainObjectDsName,
                          0,
                          SampDomainObjectType,
                          &SDAttrBlock,
                          &ReadSDAttrBlock
                          );

    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(ReadSDAttrBlock.attrCount == 1);
        ASSERT(ReadSDAttrBlock.pAttr[0].attrTyp == SAMP_DOMAIN_SECURITY_DESCRIPTOR);
        ASSERT(ReadSDAttrBlock.pAttr[0].AttrVal.valCount == 1);

        ValLength = ReadSDAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;

        *SecurityDescriptor = MIDL_user_allocate(ValLength);

        if (NULL == (*SecurityDescriptor))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            RtlZeroMemory(*SecurityDescriptor, ValLength);
            RtlCopyMemory(*SecurityDescriptor,
                          ReadSDAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                          ValLength
                          );
            *SecurityDescriptorLength = ValLength;

        }
    }

    return(NtStatus);
}




NTSTATUS
SamrSetSecurityObject(
    IN SAMPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This function (SamrSetSecurityObject) takes a well formed Security
    Descriptor provided by the caller and assigns specified portions of
    it to an object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

    This API is modelled after the NtSetSecurityObject() system service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Indicates which security information is to
        be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.


    SecurityDescriptor - A pointer to a well formed self-relative Security
        Descriptor and corresponding length.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates something about security descriptor
        is not valid.  This may indicate that the structure of the descriptor is
        not valid or that a component of the descriptor specified via the
        SecurityInformation parameter is not present in the security descriptor.

    STATUS_INVALID_PARAMETER - Indicates no security information was specified.

    STATUS_LAST_ADMIN - Indicates the new SD could potentially lead
        to the administrator account being unusable and therefore
        the new protection is being rejected.

--*/
{

    NTSTATUS                        NtStatus, IgnoreStatus, TmpStatus;
    PSAMP_OBJECT                    Context;
    SAMP_OBJECT_TYPE                FoundType;
    SECURITY_DB_OBJECT_TYPE         SecurityDbObjectType;
    ACCESS_MASK                     DesiredAccess;
    PSECURITY_DESCRIPTOR            RetrieveSD, SetSD;
    PISECURITY_DESCRIPTOR_RELATIVE  PassedSD;
    ULONG                           RetrieveSDLength;
    ULONG                           ObjectRid;
    ULONG                           SecurityDescriptorIndex;
    HANDLE                          ClientToken;
    BOOLEAN                         NotificationType = TRUE;
    BOOLEAN                         ImpersonatingNullSession = FALSE;


    SAMTRACE_EX("SamrSetSecurityObject");

    //
    // WMI Event Trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetSecurityObject
                   );


    //
    // Check input parameter
    //

    if( !SampValidateSD( SecurityDescriptor ) ) {

        NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    PassedSD = (PISECURITY_DESCRIPTOR_RELATIVE)(SecurityDescriptor->SecurityDescriptor);

    //
    // Set the desired access based upon the specified SecurityInformation
    //

    DesiredAccess = 0;
    if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }
    if ( SecurityInformation & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= WRITE_OWNER;
    }
    if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
        DesiredAccess |= WRITE_DAC;
    }

    //
    // If no information was specified, then return invalid parameter.
    //

    if (DesiredAccess == 0) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Make sure the specified fields are present in the provided security descriptor.
    // You can't mess up an SACL or DACL, but you can mess up an owner or group.
    // Security descriptors must have owner and group fields.
    //

    if ( (SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
        if (PassedSD->Owner == 0) {
            NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }
    }


    if ( (SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
        if (PassedSD->Group == 0) {
            NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }
    }

    //
    // See if the handle is valid and opened for the requested access
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    Context = (PSAMP_OBJECT)ObjectHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampUnknownObjectType,           // ExpectedType
                   &FoundType
                   );

    switch ( FoundType ) {

        case SampServerObjectType: {

            SecurityDescriptorIndex = SAMP_SERVER_SECURITY_DESCRIPTOR;
            ObjectRid = 0L;
            NotificationType = FALSE;
            break;
        }

        case SampDomainObjectType: {


            SecurityDbObjectType = SecurityDbObjectSamDomain;
            SecurityDescriptorIndex = SAMP_DOMAIN_SECURITY_DESCRIPTOR;
            ObjectRid = 0L;
            break;
        }

        case SampUserObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamUser;
            SecurityDescriptorIndex = SAMP_USER_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.User.Rid;
            break;
        }

        case SampGroupObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamGroup;
            SecurityDescriptorIndex = SAMP_GROUP_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.Group.Rid;
            break;
        }

        case SampAliasObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamAlias;
            SecurityDescriptorIndex = SAMP_ALIAS_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.Alias.Rid;
            break;
        }

        default: {

            NotificationType = FALSE;
            if (NT_SUCCESS(NtStatus))
            {
                ASSERT(FALSE && "Invalid SAM Object Type\n");
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
    }

    //
    // Do not let non trusted clients set Sacls in the SetSecurityInterface. ACL conversion
    // always resets sacls to schema default.
    //

    if ((NT_SUCCESS(NtStatus))
        && (IsDsObject(Context))
        && (!Context->TrustedClient)
        && (SecurityInformation & SACL_SECURITY_INFORMATION))
    {
        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus)) {


        //
        // Get the security descriptor
        //


        RetrieveSD = NULL;
        RetrieveSDLength = 0;
        NtStatus = SampGetObjectSD( Context, &RetrieveSDLength, &RetrieveSD);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Make sure the descriptor does not break any Administrator
            // restrictions.
            //

            NtStatus = SampCheckForDescriptorRestrictions( Context,
                                                           FoundType,
                                                           ObjectRid,
                                                           PassedSD );

            if (NT_SUCCESS(NtStatus)) {

                //
                // copy the retrieved descriptor into process heap so we can use RTL routines.
                //

                SetSD = NULL;
                if (NT_SUCCESS(NtStatus)) {

                    SetSD = RtlAllocateHeap( RtlProcessHeap(), 0, RetrieveSDLength );
                    if ( SetSD == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {
                        RtlCopyMemory( SetSD, RetrieveSD, RetrieveSDLength );
                    }
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // if the caller is replacing the owner and he is not
                    // trusted, then a handle to the impersonation token is
                    // necessary. If the caller is trusted then take process
                    // token.
                    //

                    ClientToken = 0;
                    if ( (SecurityInformation & OWNER_SECURITY_INFORMATION) ) {

                        if(!Context->TrustedClient) {

                            NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

                            if (NT_SUCCESS(NtStatus)) {

                                NtStatus = NtOpenThreadToken(
                                               NtCurrentThread(),
                                               TOKEN_QUERY,
                                               TRUE,            //OpenAsSelf
                                               &ClientToken
                                               );
                                ASSERT( (ClientToken == 0) || NT_SUCCESS(NtStatus) );



                                //
                                // Stop impersonating the client
                                //

                                SampRevertToSelf(ImpersonatingNullSession);
                            }
                        }
                        else {

                            //
                            // trusted client
                            //

                            NtStatus = NtOpenProcessToken(
                                            NtCurrentProcess(),
                                            TOKEN_QUERY,
                                            &ClientToken );

                            ASSERT( (ClientToken == 0) || NT_SUCCESS(NtStatus) );

                        }

                    }

                    if (NT_SUCCESS(NtStatus)) {

                            PSECURITY_DESCRIPTOR SDToSet = NULL;
                            PSECURITY_DESCRIPTOR NT5SD = NULL;

                            //
                            // For the NT5 Domain Controller Case, upgrade to NT5 security
                            // Descriptor
                            //

                            if (IsDsObject(Context))
                            {
                                PSECURITY_DESCRIPTOR Nt4Sd = PassedSD;



                                // Upgrade the security descriptor to NT5 and set it
                                // on the object for trusted clients. For non trusted
                                // clients, Propagate only some things ( like change
                                // password from the NT4 Security Descriptor.

                                if (Context->TrustedClient)
                                {
                                    NtStatus = SampConvertNt4SdToNt5Sd(
                                                    Nt4Sd,
                                                    Context->ObjectType,
                                                    Context,
                                                    &NT5SD
                                                    );
                                }
                                else
                                {
                                    NtStatus = SampPropagateSelectedSdChanges(
                                                    Nt4Sd,
                                                    Context->ObjectType,
                                                    Context,
                                                    &NT5SD
                                                    );
                                }
                                                    
                                if (NT_SUCCESS(NtStatus)) 
                                {
                                    SDToSet = NT5SD;
                                }                   
                            }
                            else
                            {
                                //
                                // Registry Case
                                //

                                SDToSet = PassedSD;
                            }

                        if (NT_SUCCESS(NtStatus)) 
                        {
                            //
                            // Build the replacement security descriptor.
                            // This must be done in process heap to satisfy the needs of the RTL
                            // routine.
                            //

                            NtStatus = RtlSetSecurityObject(
                                           SecurityInformation,
                                           SDToSet,
                                           &SetSD,
                                           &SampObjectInformation[FoundType].GenericMapping,
                                           ClientToken
                                           );

                            if (ClientToken != 0) {
                                IgnoreStatus = NtClose( ClientToken );
                                ASSERT(NT_SUCCESS(IgnoreStatus));
                            }

                            if (NULL!=NT5SD)
                                MIDL_user_free(NT5SD);

                            if (NT_SUCCESS(NtStatus))
                            {

                                //
                                // Apply the security descriptor back onto the object.
                                //

                                NtStatus = SampSetAccessAttribute(
                                               Context,
                                               SecurityDescriptorIndex,
                                               SetSD,
                                               RtlLengthSecurityDescriptor(SetSD)
                                               );
                            }
                        }
                    }
                }
            }

            //
            // Free up allocated memory
            //

            if (RetrieveSD != NULL) {
                MIDL_user_free( RetrieveSD );
            }
            if (SetSD != NULL) {
                RtlFreeHeap( RtlProcessHeap(), 0, SetSD );
            }

        }

        //
        // De-reference the object
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampDeReferenceContext( Context, TRUE );

        } else {

            IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        }

    } //end_if



    //
    // Commit the changes to disk.
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if ( NotificationType && NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectType,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );
        }
    }



    //
    // Release lock and propagate errors
    //

    TmpStatus = SampReleaseWriteLock( FALSE );

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetSecurityObject
                   );

    return(NtStatus);


}

NTSTATUS
SampValidatePassedSD(
    IN ULONG                          Length,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    )

/*++

Routine Description:

    This routine validates that a passed security descriptor is valid and does
    not extend beyond its expressed length.


Parameters:

    Length - The length of the security descriptor.  This should be what RPC
        used to allocate memory to receive the security descriptor.

    PassedSD - Points to the security descriptor to inspect.


Return Values:

    STATUS_SUCCESS - The security descriptor is valid.

    STATUS_BAD_DESCRIPTOR_FORMAT - Something was wrong with the security
        descriptor.  It might have extended beyond its limits or had an
        invalid component.



--*/
{
    NTSTATUS    NtStatus;

    PACL        Acl;
    PSID        Sid;
    PUCHAR      SDEnd;
    BOOLEAN     Present, IgnoreBoolean;

    SAMTRACE("SampValidatePassedSD");


    if (Length < SECURITY_DESCRIPTOR_MIN_LENGTH) {
        return(STATUS_BAD_DESCRIPTOR_FORMAT);
    }

    SDEnd = (PUCHAR)PassedSD + Length;


    try {



        //
        // Verify that the security descriptor is in
        // self relative form
        //

        if (!((((PISECURITY_DESCRIPTOR_RELATIVE)PassedSD)->Control)
                & SE_SELF_RELATIVE)){

            return (STATUS_BAD_DESCRIPTOR_FORMAT);
        }

        //
        // Make sure the DACL is within the SD
        //

        NtStatus = RtlGetDaclSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Present,
                        &Acl,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Present) {
            if (Acl != NULL) {

                //
                // Make sure the ACl header is in the buffer.
                //

                if ( (((PUCHAR)Acl)>SDEnd) ||
                     (((PUCHAR)Acl)+sizeof(ACL) > SDEnd) ||
                     (((PUCHAR)Acl) < (PUCHAR)PassedSD) ) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is within the buffer
                //
                // 1. Self AclSize should be less than the length of
                //    the passed SD as the SD should be in self relative
                //    format
                // 2. The end of the ACL should be within the security
                //    descriptor
                //

                if ( (Acl->AclSize > Length) ||
                     (((PUCHAR)Acl)+Acl->AclSize > SDEnd)) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is valid
                //

                if (!RtlValidAcl( Acl )) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }
            }
        }



        //
        // Make sure the SACL is within the SD
        //

        NtStatus = RtlGetSaclSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Present,
                        &Acl,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Present) {
            if (Acl != NULL) {

                //
                // Make sure the ACl header is in the buffer.
                //
                //
                // 1. Self AclSize should be less than the length of
                //    the passed SD as the SD should be in self relative
                //    format
                // 2. The end of the ACL should be within the security
                //    descriptor
                //

                if ( (((PUCHAR)Acl)>SDEnd) ||
                     (((PUCHAR)Acl)+sizeof(ACL) > SDEnd) ||
                     (((PUCHAR)Acl) < (PUCHAR)PassedSD) ) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is within the buffer
                //

                if ( (Acl->AclSize > Length) ||
                    (((PUCHAR)Acl)+Acl->AclSize > SDEnd)) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is valid
                //

                if (!RtlValidAcl( Acl )) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }
            }
        }


        //
        // Make sure the Owner SID is within the SD
        //

        NtStatus = RtlGetOwnerSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Sid,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Sid != NULL) {

            //
            // Make sure the SID header is in the SD
            //

            if ( (((PUCHAR)Sid)>SDEnd) ||
                 (((PUCHAR)Sid)+sizeof(SID)-(ANYSIZE_ARRAY*sizeof(ULONG)) > SDEnd) ||
                 (((PUCHAR)Sid) < (PUCHAR)PassedSD) ) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure there aren't too many sub-authorities
            //

            if (((PISID)Sid)->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure the rest of the SID is within the SD
            //

            if ( ((PUCHAR)Sid)+RtlLengthSid(Sid) > SDEnd) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }

        }



        //
        // Make sure the Group SID is within the SD
        //

        NtStatus = RtlGetGroupSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Sid,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Sid != NULL) {

            //
            // Make sure the SID header is in the SD
            //

            if ( (((PUCHAR)Sid)>SDEnd) ||
                 (((PUCHAR)Sid)+sizeof(SID)-(ANYSIZE_ARRAY*sizeof(ULONG)) > SDEnd) ||
                 (((PUCHAR)Sid) < (PUCHAR)PassedSD) ) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure there aren't too many sub-authorities
            //

            if (((PISID)Sid)->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure the rest of the SID is within the SD
            //

            if ( ((PUCHAR)Sid)+RtlLengthSid(Sid) > SDEnd) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }

        }




    } except(EXCEPTION_EXECUTE_HANDLER) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }  // end_try




    return(STATUS_SUCCESS);
}

NTSTATUS
SampCheckForDescriptorRestrictions(
    IN PSAMP_OBJECT             Context,
    IN SAMP_OBJECT_TYPE         ObjectType,
    IN ULONG                    ObjectRid,
    IN PISECURITY_DESCRIPTOR_RELATIVE  PassedSD
    )

/*++

Routine Description:

    This function ensures that the passed security descriptor,
    which is being applied to an object of type 'FoundType' with
    a Rid of value 'ObjectRid', does not violate any policies.
    For example, you can not set protection on the Administrator
    user account such that the administrator is unable to change
    her password.



Parameters:

    Context - The caller's context.  This is used to determine
        whether the caller is trusted or not.  If the caller is
        trusted, then there are no restrictions.

    ObjectType - The type of object the new security descriptor
        is being applied to.

    ObjectRid - The RID of the object the new security descriptor
        is being applied to.

    PassedSD - The security descriptor passed by the client.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_LAST_ADMIN - Indicates the new SD could potentially lead
        to the administrator account being unusable and therefore
        the new protection is being rejected.



--*/
{

    NTSTATUS
        NtStatus;

    BOOLEAN
        DaclPresent = FALSE,
        AdminSid,
        Done,
        IgnoreBoolean;

    PACL
        Dacl = NULL;

    ACL_SIZE_INFORMATION
        DaclInfo;

    PACCESS_ALLOWED_ACE
        Ace;

    ACCESS_MASK
        Accesses,
        Remaining;

    ULONG
        AceIndex;

    GENERIC_MAPPING
        UserMap      =  {USER_READ,
                         USER_WRITE,
                         USER_EXECUTE,
                         USER_ALL_ACCESS};

    SAMTRACE("SampCheckForDescriptorRestrictions");

    //
    // No checking for trusted client operations
    //

    if (Context->TrustedClient) {
        return(STATUS_SUCCESS);
    }



    NtStatus = RtlGetDaclSecurityDescriptor ( (PSECURITY_DESCRIPTOR)PassedSD,
                                               &DaclPresent,
                                               &Dacl,
                                               &IgnoreBoolean    //DaclDefaulted
                                               );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        return(STATUS_BAD_DESCRIPTOR_FORMAT);
    }


    if (!DaclPresent) {

        //
        // Not replacing the DACL
        //

        return(STATUS_SUCCESS);
    }

    if (Dacl == NULL) {

        //
        // Assigning "World all access"
        //

        return(STATUS_SUCCESS);
    }

    if (!RtlValidAcl(Dacl)) {
        return(STATUS_INVALID_ACL);
    }

    NtStatus = RtlQueryInformationAcl ( Dacl,
                                        &DaclInfo,
                                        sizeof(ACL_SIZE_INFORMATION),
                                        AclSizeInformation
                                        );
    ASSERT(NT_SUCCESS(NtStatus));




    //
    // Enforce Administrator user policies
    //

    NtStatus = STATUS_SUCCESS;
    if (ObjectRid == DOMAIN_USER_RID_ADMIN) {

        ASSERT(ObjectType == SampUserObjectType);

        //
        // For the administrator account, the ACL must grant
        // these accesses:
        //

        Remaining = USER_READ_GENERAL            |
                    USER_READ_PREFERENCES        |
                    USER_WRITE_PREFERENCES       |
                    USER_READ_LOGON              |
                    USER_READ_ACCOUNT            |
                    USER_WRITE_ACCOUNT           |
                    USER_CHANGE_PASSWORD         |
                    USER_FORCE_PASSWORD_CHANGE   |
                    USER_LIST_GROUPS             |
                    USER_READ_GROUP_INFORMATION  |
                    USER_WRITE_GROUP_INFORMATION;

        //
        // to these SIDs:
        //
        //      <domain>\Administrator
        //      <builtin>\Administrators
        //
        // It doesn't matter which accesses are granted to which SIDs,
        // as long as collectively all the accesses are granted.
        //

        //
        // Walk the ACEs collecting accesses that are granted to these
        // SIDs.  Make sure there are no DENYs that prevent them from
        // being granted.
        //

        Done = FALSE;
        for ( AceIndex=0;
              (AceIndex < DaclInfo.AceCount) && !Done;
              AceIndex++) {

            NtStatus = RtlGetAce ( Dacl, AceIndex, &((PVOID)Ace) );

            //
            // Don't do anything with inherit-only ACEs
            //

            if ((Ace->Header.AceFlags & INHERIT_ONLY_ACE) == 0) {

                //
                // Note that we expect ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE
                // to be identical structures in the following switch statement.
                //

                switch (Ace->Header.AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_DENIED_ACE_TYPE:
                    {
                        //
                        // Is this an interesting SID
                        //

                        AdminSid =
                            RtlEqualSid( ((PSID)(&Ace->SidStart)),
                                         SampAdministratorUserSid)
                            ||
                            RtlEqualSid( ((PSID)(&Ace->SidStart)),
                                         SampAdministratorsAliasSid);
                        if (AdminSid) {

                            //
                            // Map the accesses granted or denied
                            //

                            Accesses = Ace->Mask;
                            RtlMapGenericMask( &Accesses, &UserMap );

                            if (Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

                                Remaining &= ~Accesses;
                                if (Remaining == 0) {

                                    //
                                    // All necessary accesses granted
                                    //

                                    Done = TRUE;
                                }

                            } else {
                                ASSERT(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE);

                                if (Remaining & Accesses) {

                                    //
                                    // We've just been denied some necessary
                                    // accesses that haven't yet been granted.
                                    //

                                    Done = TRUE;
                                }
                            }

                        }

                        break;
                    }

                default:
                    break;
                } // end_switch

                if (Done) {
                    break;
                }
            }

        } // end_for

        if (Remaining != 0) {
            NtStatus = STATUS_LAST_ADMIN;
        }


    } // end_if (Administrator Account)



    return(NtStatus);
}



NTSTATUS
SamrQuerySecurityObject(
    IN SAMPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSAMPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This function (SamrQuerySecurityObject) returns to the caller requested
    security information currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

    This API is modelled after the NtQuerySecurityObject() system
    service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    SecurityDescriptor - Provides a pointer to a structure to be filled
        in with a security descriptor containing the requested security
        information.  This information is returned in the form of a
        self-relative security descriptor.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.


--*/
{
    NTSTATUS                        NtStatus, IgnoreStatus;
    PSAMP_OBJECT                    Context;
    SAMP_OBJECT_TYPE                FoundType;
    ACCESS_MASK                     DesiredAccess;
    PSAMPR_SR_SECURITY_DESCRIPTOR   RpcSD;
    PSECURITY_DESCRIPTOR            RetrieveSD, ReturnSD;
    ULONG                           RetrieveSDLength, ReturnSDLength;


    SAMTRACE_EX("SamrQuerySecurityObject");


    //
    // WMI Event Trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQuerySecurityObject
                   );

    ReturnSD = NULL;



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (*SecurityDescriptor == NULL);







    //
    // Set the desired access based upon the requested SecurityInformation
    //

    DesiredAccess = 0;
    if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }
    if ( SecurityInformation &  (DACL_SECURITY_INFORMATION  |
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)
       ) {
        DesiredAccess |= READ_CONTROL;
    }





    //
    // Allocate the first block of returned memory
    //

    RpcSD = MIDL_user_allocate( sizeof(SAMPR_SR_SECURITY_DESCRIPTOR) );
    if (RpcSD == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    RpcSD->Length = 0;
    RpcSD->SecurityDescriptor = NULL;



    //
    // See if the handle is valid and opened for the requested access
    //


    SampAcquireReadLock();
    Context = (PSAMP_OBJECT)ObjectHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampUnknownObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Get the security descriptor
        //


        RetrieveSDLength = 0;
        NtStatus = SampGetObjectSD( Context, &RetrieveSDLength, &RetrieveSD);

        if (NT_SUCCESS(NtStatus)) {

            //
            // For NT5 Domain Controllers convert the security descriptor
            // back to a NT4 Format
            //

            if (IsDsObject(Context))
            {
                PSID    SelfSid = NULL;
                PSECURITY_DESCRIPTOR    Nt5SD = RetrieveSD;

                RetrieveSD = NULL;

                if (SampServerObjectType != Context->ObjectType)
                {
                    SelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

                    if (NULL == SelfSid)
                    {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                //
                // The Self Sid will be NULL for the server object case
                //

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampConvertNt5SdToNt4SD(
                                   Nt5SD,
                                   Context,
                                   SelfSid,
                                   &RetrieveSD
                                  );
                }

                MIDL_user_free(Nt5SD);
            }

            if (NT_SUCCESS(NtStatus))
            {


                //
                // Recompute the retireve SD length as the length might
                // have changed during conversion
                //

                RetrieveSDLength = GetSecurityDescriptorLength(RetrieveSD);

                //
                // blank out the parts that aren't to be returned
                //

                if ( !(SecurityInformation & SACL_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Control  &= ~SE_SACL_PRESENT;
                }


                if ( !(SecurityInformation & DACL_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Control  &= ~SE_DACL_PRESENT;
                }


                if ( !(SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Owner = 0;
                }


                if ( !(SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Group = 0;
                }


                //
                // Determine how much memory is needed for a self-relative
                // security descriptor containing just this information.
                //


                ReturnSDLength = 0;
                NtStatus = RtlMakeSelfRelativeSD(
                               RetrieveSD,
                               NULL,
                               &ReturnSDLength
                               );
                ASSERT(!NT_SUCCESS(NtStatus));

                if (NtStatus == STATUS_BUFFER_TOO_SMALL) {


                    ReturnSD = MIDL_user_allocate( ReturnSDLength );
                    if (ReturnSD == NULL) {

                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {


                        //
                        // make an appropriate self-relative security descriptor
                        //

                        NtStatus = RtlMakeSelfRelativeSD(
                                       RetrieveSD,
                                       ReturnSD,
                                       &ReturnSDLength
                                       );
                    }

                }

            }
            //
            // Free up the retrieved SD
            //

            if (RetrieveSD != NULL) {
                MIDL_user_free( RetrieveSD );
            }

        }



        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();



    //
    // If we succeeded, set up the return buffer.
    // Otherwise, free any allocated memory.
    //

    if (NT_SUCCESS(NtStatus)) {

        RpcSD->Length = ReturnSDLength;
        RpcSD->SecurityDescriptor = (PUCHAR)ReturnSD;
        (*SecurityDescriptor) = RpcSD;

    } else {

        MIDL_user_free( RpcSD );
        if (ReturnSD != NULL) {
            MIDL_user_free(ReturnSD);
        }
        (*SecurityDescriptor) = NULL;
    }


    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:
    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQuerySecurityObject
                   );


    return(NtStatus);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\site.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    site.c

Abstract:

    This file contains the routines to maintain the global site information.


    Thoery of Operation for Maintaining Global Site info
    ----------------------------------------------------

    SAM maintains global state about the site that the server is in as well
    as the site settings for this site.  Of course, both pieces of information
    could change at any time, and SAM should not need to be restarted in
    order to have these changes take effect.

    SampSiteInfo is a global that contains: the GUID of our Ntds Settings
    object, the GUID of our site and the Options for our site.  Certain
    notifications (to be discussed shortly) will cause this information to
    be updated.  The update occurs in the following manner:

    1)  the SampSiteInfoLock critical section is acquired
    2)  a DS transaction is started
    3)  our DSA is read, located by GUID
    4)  we trim the returned string name by 3 to obtain the site DN
    5)  the site DN is read to obtain the site GUID; SampSiteInfo is updated
    6)  the well known RDN "Ntds Site Settings" is appended to the site DN
        and this object is read to obtain the Options attribute; SampSiteInfo
        is updated
    7)  a notification on the "Ntds Site Settings" obtain is registered (via
        (DirNotifyRegister)
    8)  Any old notification is removed (DirNotifyUnRegsiter) ( a non fatal
        operation)
    9)  the DS transaction is ended
    10) the SampSiteInfoLock critical section is released
    11) if an fatal error occurred then reshedule update task in one minute


    The above algorithm is executed in the context of a "task"
    (SampUpdateSiteInfo) scheduled via LsaIRegisterNotification.  The task is

    1) run once during startup
    2) scheduled to run whenever a notification occurs due to a change to the
       Site Settings object
    3) scheduled to run whenever a notification occurs due to a site change
       (SamINotifyServerDelta)
    4) scheduled whenever an error occurs during its execution

    Since multiple instances of SampUpdateSiteInfo can be running at once,
    the code is gaurded by SampSiteInfoLock.  This is needed to synchronize
    not the update of the variable SampSiteInfo, but to serialize the calls to
    DirNotifyRegister and DirNotifyUnRegister.

    This mechanism is bootstrapped by using GetConfigurationName to obtain
    the Ntds Settings object GUID the first time SampUpdateSiteInfo is run.


Author:

    Colin Brace   (ColinBr)  28-Feb-2000

Environment:

    User Mode - Win32

Revision History:

    ColinBr        28-Feb-00

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntdsa.h>
#include <filtypes.h>
#include <attids.h>
#include <dslayer.h>
#include <dsdomain.h>
#include <samtrace.h>
#include <malloc.h>
#include <dsconfig.h>
#include <mappings.h>
#include <winsock2.h>
#define _AVOID_REPL_API
#include <nlrepl.h>
#include <stdlib.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Data                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// Global infomation about our current site
//
typedef struct _SAMP_SITE_INFORMATION {

    GUID    NtdsSettingsGuid;
    GUID    SiteGuid;
    ULONG   Options;  // on Ntds Settings object
    LPWSTR  SiteName;

} SAMP_SITE_INFORMATION, *PSAMP_SITE_INFORMATION;

PSAMP_SITE_INFORMATION SampSiteInfo = NULL;

//
// A lock to prevent concurrent updates on the global site information
//
CRITICAL_SECTION SampSiteInfoLock;

#define SampLockSiteInfo()                                      \
{                                                               \
    NTSTATUS _IgnoreStatus;                                     \
   _IgnoreStatus = RtlEnterCriticalSection(&SampSiteInfoLock);  \
   ASSERT(NT_SUCCESS(_IgnoreStatus));                           \
}

#define SampUnLockSiteInfo()                                    \
{                                                               \
    NTSTATUS _IgnoreStatus;                                     \
   _IgnoreStatus = RtlLeaveCriticalSection(&SampSiteInfoLock);  \
   ASSERT(NT_SUCCESS(_IgnoreStatus));                           \
}

//
// A global to indicate whether we need to log a successful
// site information update.  This is only necessary if we hit
// a failure and needed to reschdule the refresh.
//
BOOLEAN SampLogSuccessfulSiteUpdate;

//
// This global remembers the handle returned by DirRegisterNotify
// so that the notification can be removed.
//
DWORD SampSiteNotificationHandle;

// Since the handle can be 0, we need more state to indicate whether it
// is set
BOOLEAN SampSiteNotificationHandleSet = FALSE;


//
// An Empty site affinity
//
SAMP_SITE_AFFINITY SampNullSiteAffinity;

#define GCLESS_DEFAULT_SITE_STICKINESS_DAYS  180

#define ENTRY_HAS_EXPIRED(entry, standard) \
    ((-1) == CompareFileTime((FILETIME*)&(entry),(FILETIME*)&(standard)))

#define ENTRY_IS_EMPTY(x)  (!memcmp((x), &SampNullSiteAffinity, sizeof(SampNullSiteAffinity)))




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SampUpdateSiteInfo(
    VOID
    );

NTSTATUS
SampSetupSiteNotification(
    IN DSNAME *ObjectDN,
    IN UCHAR Scope
    );

NTSTATUS
SampDelayedFreeCallback(
    PVOID pv
    );

VOID
SampFreeSiteInfo(
    IN PSAMP_SITE_INFORMATION *p
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
NTSTATUS
SampInitSiteInformation(
    VOID
    )
/*++

Routine Description:

    This routine is called during SAM's initialiazation path.  Its purpose
    is to initialize the global site information.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, or a fatal resourse error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Size;

    if ( !SampUseDsData ) {

        return STATUS_SUCCESS;
    }
    // Init the critical section
    try {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(&SampSiteInfoLock, 100);
    } except ( 1 ) {
        NtStatus =  STATUS_NO_MEMORY;
    }
    if (!NT_SUCCESS(NtStatus))
        return (NtStatus);

    // Init the global structure
    SampSiteInfo = NULL;

    RtlZeroMemory( &SampNullSiteAffinity, sizeof(SampNullSiteAffinity));

    SampLogSuccessfulSiteUpdate = FALSE;

    // Fill the global structure and setup the notification
    SampUpdateSiteInfo();

    return STATUS_SUCCESS;

}



NTSTATUS
SampGetSiteDNInfo(
    IN  DSNAME*  DsaDN,
    OUT DSNAME** pSiteDN OPTIONAL,
    OUT DSNAME** pSiteSettingsDN OPTIONAL
    )
/*++

Routine Description:

    This routine determines the current site dn and ntds site settings
    dn.  No transaction is needed or started.

Arguments:

    pSiteDN - a heap allocated DSNAME if the Site; caller must free with
              midl_user_free

    pSiteSettingsDN - a heap allocated DSNAME if the Site; caller must free with
              midl_user_free

Return Value:

    STATUS_SUCCESS, or a fatal resourse error

--*/
{

    NTSTATUS   NtStatus = STATUS_SUCCESS;
    DSNAME     *SiteDN = NULL;
    DSNAME     *SiteSettingsDN = NULL;
    LPWSTR      SiteSettingsCN = L"NTDS Site Settings";
    ULONG       Size;

    NtStatus = STATUS_NO_MEMORY;
    SiteDN = (DSNAME*) midl_user_allocate(DsaDN->structLen);
    if ( SiteDN ) {
        RtlZeroMemory(SiteDN, DsaDN->structLen);
        if ( TrimDSNameBy(DsaDN, 3, SiteDN) == 0) {

            Size = DsaDN->structLen + sizeof(SiteSettingsCN);

            SiteSettingsDN = (DSNAME*)midl_user_allocate(Size);
            if ( SiteSettingsDN ) {
                RtlZeroMemory(SiteSettingsDN, Size);
                AppendRDN(SiteDN,
                          SiteSettingsDN,
                          Size,
                          SiteSettingsCN,
                          0,
                          ATT_COMMON_NAME
                          );
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    if ( !NT_SUCCESS(NtStatus) ) {
        if ( SiteDN ) midl_user_free(SiteDN);
        if ( SiteSettingsDN ) midl_user_free(SiteSettingsDN);
        return NtStatus;
    }

    if ( pSiteDN ) {
        *pSiteDN = SiteDN;
    } else {
        midl_user_free(SiteDN);
    }

    if ( pSiteSettingsDN) {
        *pSiteSettingsDN = SiteSettingsDN;
    } else {
        midl_user_free(SiteSettingsDN);
    }

    return STATUS_SUCCESS;

}

VOID
SampUpdateSiteInfo(
    VOID
    )
/*++

Routine Description:

    This routine queries the DS for the current site information.
    Site information includes the site GUID, site RDN, the Ntds Site
    Settings object GUID, and the Options attribute on the Ntds Site
    Settings object.

    It is legal for the Ntds Site Settings object to not exist
    (i.e. deleted).  In this case the Options attribute is treated
    as if it were zero.

    The global site information cache update can fail from resource
    failures or database read errors.  If the update fails an event is
    logged and the operation is rescheduled.  When the update succeeds
    following a prior failure an event is logged indicating whether group
    caching has been enabled or disabled.

Arguments:

    None

Return Value:

    None -- on error, it reschedules itself to run.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS NtStatus2;
    ULONG    DirError = 0;
    DSNAME   *SiteSettingsDN = NULL;
    DSNAME   *SiteDN = NULL;
    GUID     NullGuid = {0};
    DSNAME   *DsaDN = NULL;
    DSNAME   Buffer;

    WCHAR    *SiteNameBuffer;
    ULONG    SiteNameLength;
    ATTRTYP  AttrType;

    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    ENTINFSEL   EntInf;
    ATTR        Attr;
    BOOLEAN     fTransOpen = FALSE;
    BOOLEAN     fGroupCacheNowEnabled = FALSE;

    PSAMP_SITE_INFORMATION NewSiteInfo = NULL;

    PSAMP_SITE_INFORMATION OldSiteInfo = NULL;

    PVOID      PtrToFree = NULL;

    // This only makes sense on a DC
    ASSERT( SampUseDsData );
    if ( !SampUseDsData ) {
        return;
    }

    // Lock the global structure before the transaction start
    SampLockSiteInfo();

    //
    // Allocate the new structure
    //
    NewSiteInfo = midl_user_allocate(sizeof(*NewSiteInfo));

    if (NULL == NewSiteInfo ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(NewSiteInfo, sizeof(*NewSiteInfo));

    //
    // Remember the old version
    //
    OldSiteInfo = SampSiteInfo;

    //
    // Bootstrap ourselves by getting our DSA guid from global memory
    // in ntdsa (which is where GetConfigurationName gets if from)
    //
    if ( NULL == OldSiteInfo ) {

        ULONG Size = 0;

        NtStatus = GetConfigurationName(
                        DSCONFIGNAME_DSA,
                        &Size,
                        NULL
                        );
        ASSERT(STATUS_BUFFER_TOO_SMALL == NtStatus);
        SAMP_ALLOCA(DsaDN,Size);
        if (NULL!=DsaDN) {
            NtStatus = GetConfigurationName(
                           DSCONFIGNAME_DSA,
                           &Size,
                           DsaDN
                           );

            ASSERT(NT_SUCCESS(NtStatus));

            RtlCopyMemory(&NewSiteInfo->NtdsSettingsGuid,
                          &DsaDN->Guid,
                          sizeof(GUID));
        } else {

           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
           goto Cleanup;
        }


    } else {

        RtlCopyMemory(&NewSiteInfo->NtdsSettingsGuid,
                      &OldSiteInfo->NtdsSettingsGuid,
                      sizeof(GUID));
    }
    ASSERT(!IsEqualGUID(&NullGuid, &NewSiteInfo->NtdsSettingsGuid));


    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    fTransOpen = TRUE;


    //
    // Read the dsa object so we can determine the site.  Note that
    // asking GetConfigurationName is not guaranteed to work since the
    // global data in ntdsa is not guaranteed to be updated by the time
    // we are notified here in SAM.
    //
    if (NULL == DsaDN) {

        // Set up a GUID based name
        DsaDN = &Buffer;
        RtlZeroMemory(DsaDN,  sizeof(Buffer));
        RtlCopyMemory(&DsaDN->Guid, &NewSiteInfo->NtdsSettingsGuid, sizeof(GUID));
        DsaDN->structLen = sizeof(DSNAME);

        RtlZeroMemory(&Attr, sizeof(ATTR));
        RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadArg, sizeof(READARG));

        Attr.attrTyp = ATT_OBJ_DIST_NAME;

        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &Attr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EntInf;
        ReadArg.pObject = DsaDN;

        InitCommarg(&(ReadArg.CommArg));

        DirError = DirRead(&ReadArg, &pReadRes);

        if (NULL == pReadRes){
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
           NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
        }
        THClearErrors();

        if (NT_SUCCESS(NtStatus)) {

           ASSERT(1==pReadRes->entry.AttrBlock.attrCount);
           ASSERT(ATT_OBJ_DIST_NAME == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);
           DsaDN = (DSNAME*)pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;

        }  else {

            // Can't read the DSA object? This is fatal.
            goto Cleanup;
        }
    }
    ASSERT(DsaDN && (DsaDN->NameLen > 0));


    //
    // Get the ntds site settings object
    //
    NtStatus = SampGetSiteDNInfo( DsaDN,
                                 &SiteDN,
                                 &SiteSettingsDN );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) ) {
        goto Cleanup;
    }

    //
    // Set the site name
    //
    SAMP_ALLOCA(SiteNameBuffer, (SiteDN->NameLen * sizeof(WCHAR)));
    if (NULL == SiteNameBuffer) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    SiteNameLength = SiteDN->NameLen;
    DirError = GetRDNInfoExternal(SiteDN,
                                  SiteNameBuffer,
                                  &SiteNameLength,
                                  &AttrType);
    ASSERT(0 == DirError && (SiteNameLength > 0));

    NewSiteInfo->SiteName = midl_user_allocate((SiteNameLength + 1) * sizeof(WCHAR));
    if (NewSiteInfo->SiteName) {
        RtlCopyMemory(NewSiteInfo->SiteName, SiteNameBuffer, SiteNameLength*sizeof(WCHAR));
        NewSiteInfo->SiteName[SiteNameLength] = L'\0';
    } else {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Read the options field
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    Attr.attrTyp = ATT_OPTIONS;

    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = SiteSettingsDN;

    InitCommarg(&(ReadArg.CommArg));

    DirError = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes){
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
       NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
    }
    THClearErrors();

    if (NT_SUCCESS(NtStatus)) {

       ASSERT(1==pReadRes->entry.AttrBlock.attrCount);
       ASSERT(ATT_OPTIONS == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);
       ASSERT( sizeof(DWORD) == pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen);

       NewSiteInfo->Options = *((DWORD*)pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);

    } else if (NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE ||
               NtStatus == STATUS_OBJECT_NAME_NOT_FOUND){

        //
        // If the Options attribute isn't present or if the Ntds Site Settings
        // object isn't present this is equivelent to an Options attribute with
        // no flags set.  STATUS_OBJECT_NAME_NOT_FOUND can happen when the DC
        // changes site between the call to GetConfigurationName and the
        // SampMaybeBeginDsTransaction or if the object is deleted.
        //
        NewSiteInfo->Options = 0;
        NtStatus = STATUS_SUCCESS;

    } else {

        //
        // There should be no other kinds of error codes on a read.
        //
        ASSERT( NT_SUCCESS( NtStatus ) );

        goto Cleanup;
    }

    //
    // Read the site object to get its GUID
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    Attr.attrTyp = ATT_OBJ_DIST_NAME;

    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = SiteDN;

    InitCommarg(&(ReadArg.CommArg));

    DirError = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes){
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
       NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
    }
    THClearErrors();

    if (NT_SUCCESS(NtStatus)) {

        RtlCopyMemory(&NewSiteInfo->SiteGuid,
                      &ReadArg.pObject->Guid,
                      sizeof(GUID));
    } else {

        // There should be no other kinds of error codes on a read
        // Object name not found can happen when the DC changes site
        // between the call to GetConfigurationName and the
        // SampMaybeBeginDsTransaction, in this case, simply
        // reschedule
        if (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus) {
            ASSERT( NT_SUCCESS( NtStatus ) );
        }
        goto Cleanup;
    }


    //
    // Re-register a notification on the new site
    //
    NtStatus = SampSetupSiteNotification( SiteSettingsDN,
                                          SE_CHOICE_BASE_ONLY );
    if ( !NT_SUCCESS(NtStatus)) {

        //
        // If the site has no Ntds Site Settings child object register
        // for notification if and when one is created.
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus) {

            THClearErrors();

            NtStatus = SampSetupSiteNotification( SiteDN,
                                                  SE_CHOICE_IMMED_CHLDRN );
            ASSERT(NT_SUCCESS(NtStatus));
        }

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
    }


    fGroupCacheNowEnabled = ((NewSiteInfo->Options &
                              NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) ==
                              NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED);


    //
    // We have a new value; note the use of InterlockExchangePointer.
    // Since there is no read lock on the value, other threads could
    // be accessing it now
    //
    PtrToFree = InterlockedExchangePointer(&SampSiteInfo, NewSiteInfo);
    NewSiteInfo = NULL;
    if ( PtrToFree ) {
            LsaIRegisterNotification(
                    SampDelayedFreeCallback,
                    PtrToFree,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    3600,     // wait for 60 min
                    NULL      // no handle
                    );
    }

Cleanup:


    if ( fTransOpen ) {
        NtStatus2 = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                               TransactionCommit :
                                               TransactionAbort );
        if (!NT_SUCCESS(NtStatus2) && NT_SUCCESS(NtStatus)) {
            NtStatus = NtStatus2;
        }
    }

    // Release the site info
    SampUnLockSiteInfo();

    if ( SiteSettingsDN ) {
        midl_user_free( SiteSettingsDN );
    }

    if ( SiteDN ) {
        midl_user_free( SiteDN );
    }

    if ( NewSiteInfo ) {
        SampFreeSiteInfo(&NewSiteInfo);
    }

    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // Notify the user on failure and try again.
        //
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,     // no category
                          SAMMSG_SITE_INFO_UPDATE_FAILED,
                          NULL,  // no sid
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        LsaIRegisterNotification(
                SampUpdateSiteInfoCallback,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                60,           // wait for 1 min
                NULL          // no handle
                );

        SampLogSuccessfulSiteUpdate = TRUE;


    } else {

        if ( SampLogSuccessfulSiteUpdate ) {

            if ( fGroupCacheNowEnabled ) {

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_ON,
                                  NULL,  // no sid
                                  0,
                                  0,
                                  NULL,
                                  NULL);
            } else {

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_OFF,
                                  NULL,  // no sid
                                  0,
                                  0,
                                  NULL,
                                  NULL);
            }



            SampLogSuccessfulSiteUpdate = FALSE;
        }
    }

    return;

}



BOOLEAN
SampIsGroupCachingEnabled(
    IN PSAMP_OBJECT AccountContext
    )
/*++

Routine Description:

    This routine determines whether SAM should use group caching or
    not.  To disable the entire feature, simply hard code this routine
    to return FALSE.  Otherwise, it will return a status based on the
    role of the machine (GC or not) and the current settings of the site
    object.

    If the global site information cache has not been successfully
    initialized (i.e. resource allocation failure), SampSiteInfo will be
    NULL implying the Options attribute is zero and group caching is
    disabled.

Arguments:

    None.

Return Value:

    TRUE if SAM should use group caching; FALSE otherwise.

--*/
{
    PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

    if (
        // We've successfully obtained site information
        SiteInfo &&
        // No GC logon setting has to be enabled for site
        ((SiteInfo->Options & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) ==
                         NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) &&
        // Domain is not in mixed mode
        (!DownLevelDomainControllersPresent(AccountContext->DomainIndex)) &&
        // The DC is not a GC
        (!SampAmIGC())
        )
    {
        return(TRUE);
    }

    return(FALSE);
}



BOOL
SampSiteNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampSiteNotifyProcessDelta.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampSiteNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampSiteNotifyProcessDelta, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}


NTSTATUS
SampUpdateSiteInfoCallback(
    PVOID pv
/*++

Routine Description:

    This routine is a wrapper for SampUpdateSiteInfo.  Its purpose is to
    be used as a callback when registering a callback in the LSA's process
    wide thread pool.  When SampUpdateSiteInfo() fails is reschedules
    itself to run using this routine.

Arguments:

    pv -- unused.

Return Value:

    STATUS_SUCCESS

--*/
    )
{
    SampUpdateSiteInfo();

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pv);
}
VOID
SampSiteNotifyProcessDelta(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    This routine is a callback for notifications to the Site or Ntds Site
    Settings objects.  A callback to SampUpdateSiteInfoCallback is registered.

Arguments:

    hClient - ignored
    hServer - ignored
    EntInf  - the pointer to the requested data

Return Value:

    None.

--*/
{
    //
    // Normally, one would simply use the EntInf structure
    // however since updates to the SampSiteInfo are serialized
    // it is a violation to grab the lock _inside_ a transaction
    // So register a callback so that we can get a fresh view
    // of the database after grabbing the lock.
    //
    LsaIRegisterNotification(
            SampUpdateSiteInfoCallback,
            NULL,
            NOTIFIER_TYPE_INTERVAL,
            0,            // no class
            NOTIFIER_FLAG_ONE_SHOT,
            1,          // wait for a second
            NULL        // no handle
            );

    return;
}

NTSTATUS
SampSetupSiteNotification(
    IN DSNAME* ObjectDN,
    IN UCHAR Scope
    )
/*++

Routine Description:

    This routine registers SAM to be notified when the speicified objects
    are changed.  The objects included in the notification registration
    are defined by a search rooted at ObjectDn and scoped by the value
    of Scope.

Arguments:

    ObjectDN -- The base DN for the search defining which objects can
                generate change notifications.

    Scope -- Specifies the scope of the search that defines which objects
             can generate change notifications.

             SE_CHOICE_BASE_ONLY
             SE_CHOICE_IMMED_CHLDRN
             SE_CHOICE_WHOLE_SUBTREE

Return Value:

    STATUS_SUCCESS, or resource error

--*/
{


    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0;

    SEARCHARG   searchArg;
    NOTIFYARG   notifyArg;
    NOTIFYRES*  notifyRes = NULL;
    ENTINFSEL   entInfSel;
    ATTR        attr;
    FILTER      filter;

    DWORD       oldHandle = SampSiteNotificationHandle;
    BOOLEAN     oldHandleSet = SampSiteNotificationHandleSet;

    //
    // init notify arg
    //
    notifyArg.pfPrepareForImpersonate = SampSiteNotifyPrepareToImpersonate;
    notifyArg.pfTransmitData = SampSiteNotifyProcessDelta;
    notifyArg.pfStopImpersonating = SampSiteNotifyStopImpersonation;
    notifyArg.hClient = 0;

    //
    // init search arg
    //
    ZeroMemory(&searchArg, sizeof(SEARCHARG));
    ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
    ZeroMemory(&filter, sizeof(FILTER));
    ZeroMemory(&attr, sizeof(ATTR));


    searchArg.pObject = ObjectDN;

    InitCommarg(&searchArg.CommArg);
    searchArg.choice = Scope;
    searchArg.bOneNC = TRUE;

    searchArg.pSelection = &entInfSel;
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    entInfSel.AttrTypBlock.attrCount = 0;
    entInfSel.AttrTypBlock.pAttr = NULL;

    searchArg.pFilter = &filter;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    DirError = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);

    if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &notifyRes->CommRes);

    }

    if ( NT_SUCCESS(NtStatus)) {

        SampSiteNotificationHandle = notifyRes->hServer;
        SampSiteNotificationHandleSet = TRUE;

        if ( oldHandleSet ) {

            //
            // Remove the old notification
            //
            DirError = DirNotifyUnRegister(oldHandle,
                                           &notifyRes);
            ASSERT( 0 == DirError );
        }
    }

    return NtStatus;

}

#define SampNamesMatch(x, y)                                        \
  ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,                  \
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS,    \
                                (x)->Buffer,                        \
                                (x)->Length/sizeof(WCHAR),          \
                                (y)->Buffer,                        \
                                (y)->Length/sizeof(WCHAR) )))

BOOLEAN
SampCheckForSiteAffinityUpdate(
    IN  PSAMP_OBJECT          AccountContext,
    IN  ULONG                 Flags,
    IN  PSAMP_SITE_AFFINITY pOldSA,
    OUT PSAMP_SITE_AFFINITY pNewSA,
    OUT BOOLEAN*            fDeleteOld
    )
/*++

Routine Description:

    This routine takes an existing Site Affinity value and determines
    if it needs updating. See spec for details of algorithm.

Arguments:

    AccountContext -- the account that may have some site affinity

    Flags -- Flags as passed to SamIUpdateLogonStatistics

    pOldSA -- existing Site Affinity value.

    pNewSA -- new Site Affinity value to write

    fDeleteOld -- flag to indicate whether to delete old SA; set to TRUE
                  if a new value is to be written; FALSE otherwise

Return Value:

    TRUE if a new Site Affinity needs to be written to the DS
    FALSE otherwise

--*/
{
    BOOLEAN fUpdate = FALSE;
    DWORD   err;
    ULONG   siteStickiness;
    LARGE_INTEGER timeTemp, timeBestAfter;
    PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

    if ( !SampIsGroupCachingEnabled(AccountContext) ) {
        return FALSE;
    }

    if (SiteInfo == NULL) {
        return FALSE;
    }

    if (!AccountContext->TypeBody.User.fCheckForSiteAffinityUpdate) {
        return FALSE;
    }

    (*fDeleteOld) = FALSE;

    err = GetConfigParam(GCLESS_SITE_STICKINESS,
                         &siteStickiness,
                         sizeof(siteStickiness));
    if (err) {
        siteStickiness = GCLESS_DEFAULT_SITE_STICKINESS_DAYS*24*60;
    }
    // Update at the half the frequency
    //
    // Note that the "half" is implemented by dividing the number of seconds
    // not minutes so that settings of small values like 1, or 3 minutes are
    // effective.
    //
    timeTemp.QuadPart = Int32x32To64(siteStickiness * 60/2, SAMP_ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    if ( ENTRY_IS_EMPTY(pOldSA) ) {
        fUpdate = TRUE;
    } else if (ENTRY_HAS_EXPIRED(pOldSA->TimeStamp, timeBestAfter)) {
        fUpdate = TRUE;
        *fDeleteOld = TRUE;
    }


    if (fUpdate) {

        //
        // Make sure that the client is from our site
        //
        if ( SampNoGcLogonEnforceKerberosIpCheck
         &&  AccountContext->TypeBody.User.ClientInfo.Type == SamClientIpAddr) {

            //
            // An IP address was given -- see if it is in one of our subnets if
            // we have any
            //
            BOOL NotInSite = FALSE;
            ULONG i;
            DWORD NetStatus;
            SOCKET_ADDRESS SocketAddress;
            SOCKADDR SockAddr;
            LPWSTR SiteName = NULL;
            UNICODE_STRING OurSite, ClientSite;

            RtlInitUnicodeString(&OurSite, SiteInfo->SiteName);

            RtlZeroMemory(&SocketAddress, sizeof(SocketAddress));
            RtlZeroMemory(&SockAddr, sizeof(SockAddr));
            SocketAddress.iSockaddrLength = sizeof(SockAddr);
            SocketAddress.lpSockaddr = &SockAddr;
            SockAddr.sa_family = AF_INET;
            ((PSOCKADDR_IN)&SockAddr)->sin_addr.S_un.S_addr = AccountContext->TypeBody.User.ClientInfo.Data.IpAddr;

            NetStatus = I_NetLogonAddressToSiteName(&SocketAddress,
                                                    &SiteName);
            if ( 0 == NetStatus
              && SiteName != NULL ) {

                RtlInitUnicodeString(&ClientSite, SiteName);

                if (!SampNamesMatch(&ClientSite, &OurSite)) {
                    NotInSite = TRUE;
                }

            }

            if (SiteName) {
                I_NetLogonFree(SiteName);
            }

            if (NotInSite) {
                return FALSE;
            }
        }

        if ( SampNoGcLogonEnforceNTLMCheck
          && (Flags & USER_LOGON_TYPE_NTLM)
          && !( (Flags & USER_LOGON_INTER_FAILURE)
             || (Flags & USER_LOGON_INTER_SUCCESS_LOGON)) ) {
            //
            // If this is not an interactive logon attempt
            // don't update the site affinity
            //
            return FALSE;
        }

    }

    if (fUpdate) {

        //
        // Since a GUID is a large structure, safely extract the pointer
        // to make sure the compiler uses the same value while deferencing
        // the GUID.
        //
        pNewSA->SiteGuid = SiteInfo->SiteGuid;
        GetSystemTimeAsFileTime((FILETIME*)&pNewSA->TimeStamp);
    }

    return fUpdate;
}

NTSTATUS
SampFindUserSiteAffinity(
    IN PSAMP_OBJECT AccountContext,
    IN ATTRBLOCK* Attrs,
    OUT SAMP_SITE_AFFINITY *pSiteAffinity
    )
/*++

Routine Description:

    This routine iterates through the given AttrBlock looking for the site
    affinity attribute.  If found, it then searches for a value that corresponds
    to the current site. If found that value is returned via pSiteAffinity

Arguments:

    AccountContext -- the account that may have some site affinity

    Attrs -- an attrblock of attributes

    pSiteAffinity -- the site affinity if found

Return Value:

    STATUS_SUCCESS if site affinity value exists

    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_SITE_AFFINITY *pSA = NULL;
    GUID SiteGuid;
    ULONG i, j;
    // don't optimize this variable
    PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

    if ( !SampIsGroupCachingEnabled(AccountContext) ) {
        return STATUS_UNSUCCESSFUL;
    }

    if (NULL == SiteInfo) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Since a GUID is a large structure, safely extract the pointer
    // to make sure the compiler uses the same value while deferencing
    // the GUID.
    //
    RtlCopyMemory(&SiteGuid, &SiteInfo->SiteGuid, sizeof(GUID));

    //
    // Iterate through looking for a value that matches
    // our site
    //
    for (i = 0; i < Attrs->attrCount; i++) {

        if ( Attrs->pAttr[i].attrTyp == SAMP_FIXED_USER_SITE_AFFINITY ) {
            //
            // Found the attribute -- now find a value for our site,
            // if any
            //
            ATTRVALBLOCK *pAttrVal = &Attrs->pAttr[i].AttrVal;
            for (j = 0; j < pAttrVal->valCount; j++ ) {


                ASSERT(pAttrVal->pAVal[j].valLen == sizeof(SAMP_SITE_AFFINITY));\
                pSA = (SAMP_SITE_AFFINITY*) pAttrVal->pAVal[j].pVal;

                if (IsEqualGUID(&pSA->SiteGuid, &SiteGuid)) {

                    // Got it
                    break;

                } else {
                    pSA = NULL;
                }
            }
        }
    }

    if ( pSA ) {
        RtlCopyMemory( pSiteAffinity, pSA, sizeof(SAMP_SITE_AFFINITY) );
    } else {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return NtStatus;
}


NTSTATUS
SampDelayedFreeCallback(
    PVOID pv
    )
{
    if ( pv ) {

        SampFreeSiteInfo( (PSAMP_SITE_INFORMATION*) &pv );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SampRefreshSiteAffinity(
    IN PSAMP_OBJECT AccountContext
    )

/*++

Routine Description:

    This routine performs a database to obtain the site affinity.

    N.B. This routine can start a transaction that is left open for the caller.

Arguments:

    AccountContext -- the account that may have some site affinity

Return Value:

    STATUS_SUCCESS; an unexpected resource error otherwise

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    ATTRBLOCK AttrToRead;
    ATTR      SAAttr;
    ATTRBLOCK AttrRead;
    SAMP_SITE_AFFINITY NewSA;

    ASSERT(AccountContext);
    ASSERT(AccountContext->ObjectNameInDs);

    RtlZeroMemory(&AttrToRead, sizeof(AttrToRead));
    RtlZeroMemory(&SAAttr, sizeof(SAAttr));
    RtlZeroMemory(&AttrRead, sizeof(AttrRead));

    AttrToRead.attrCount =1;
    AttrToRead.pAttr = &(SAAttr);

    SAAttr.AttrVal.valCount =0;
    SAAttr.AttrVal.pAVal = NULL;
    SAAttr.attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;

    NtStatus = SampDsRead(AccountContext->ObjectNameInDs,
                        0,
                        AccountContext->ObjectType,
                        &AttrToRead,
                        &AttrRead);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampFindUserSiteAffinity(AccountContext,
                                            &AttrRead,
                                            &NewSA);

        if (NT_SUCCESS(NtStatus)) {

            // Found it -- update the context
            AccountContext->TypeBody.User.SiteAffinity = NewSA;

        } else {

            // No SA to our site? Set to zero
            RtlZeroMemory(&AccountContext->TypeBody.User.SiteAffinity,
                          sizeof(AccountContext->TypeBody.User.SiteAffinity));
            NtStatus = STATUS_SUCCESS;
        }

    } else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus) {

        // No SA at all? Set to zero
        RtlZeroMemory(&AccountContext->TypeBody.User.SiteAffinity,
                      sizeof(AccountContext->TypeBody.User.SiteAffinity));
        NtStatus = STATUS_SUCCESS;

    }

    return NtStatus;

}


VOID
SampFreeSiteInfo(
    PSAMP_SITE_INFORMATION *pp
    )
{
    PSAMP_SITE_INFORMATION p = *pp;
    if (p) {
        if (p->SiteName) {
            midl_user_free( p->SiteName);
        }
        midl_user_free( p);
        *pp = NULL;
    }
}


NTSTATUS
SampGetClientIpAddr(
    OUT LPSTR *NetworkAddr
)
/*++

Routine Description:

    This routine attempts to extract the network address of the client
    caller from information available from RPC.

Arguments:

    NetworkAddr - Network Address

Return Value:

    STATUS_SUCCESS; an unexpected RPC error otherwise

--*/
{
    RPC_BINDING_HANDLE ServerBinding = NULL;
    LPSTR StringBinding = NULL;
    ULONG Error = 0;

    //
    // Derive a partially bound handle with the client's network address.
    //
    Error = RpcBindingServerFromClient(NULL, &ServerBinding);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcBindingServerFromClient failed %d\n",
                   Error));
        goto Cleanup;
    }

    //
    // Convert binding handle into string form, which contains, amongst
    // other things, the network address of the client.
    //
    Error = RpcBindingToStringBindingA(ServerBinding, &StringBinding);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcBindingToStringBinding failed %d\n",
                   Error));
        goto Cleanup;
    }

    //
    // Parse out the network address.
    //
    Error = RpcStringBindingParseA(StringBinding,
                                   NULL,
                                   NULL,
                                   NetworkAddr,
                                   NULL,
                                   NULL);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcStringBindingParse failed %d\n",
                   Error));
        goto Cleanup;
    }

Cleanup:

    if (StringBinding) {
        RpcStringFreeA(&StringBinding);
    }
    if (ServerBinding) {
        RpcBindingFree(&ServerBinding);
    }

    return I_RpcMapWin32Status(Error);

}

NTSTATUS
SampExtractClientIpAddr(
    IN PSAMP_OBJECT Context
    )
/* ++

Routine Description:

    This routine attempts to extract the IP address of the client
    caller from information available from RPC.  If an IP address is
    present, this routine places the address in the ClientInfo
    structure of the Context.

Arguments:

    Context - the SAM representation of the RPC context handle

Return Value:

    STATUS_SUCCESS; an unexpected RPC error otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD ClientIpAddr;
    LPSTR NetworkAddr = NULL;

    Status = SampGetClientIpAddr( &NetworkAddr );

    if( NT_SUCCESS( Status ) ) {

        //
        // Extract the Ip Address, inet_addr will return 0 if NetworkAddr
        // is a ' ' and INADDR_NONE if the string can not be mapped to an IP.
        //

        ClientIpAddr = inet_addr( NetworkAddr );

        if( INADDR_NONE != ClientIpAddr && 0 != ClientIpAddr ) {

            Context->TypeBody.User.ClientInfo.Type = SamClientIpAddr;
            Context->TypeBody.User.ClientInfo.Data.IpAddr = ClientIpAddr;
        }
    }

    if( NetworkAddr ) {

        RpcStringFreeA(&NetworkAddr);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\syskey.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    syskey.c

Abstract:

    This file contains services related to syskeying the machine.


Author:

    Murli Satagopan    (MurliS)  1 October 1998

Environment:

    User Mode - Win32

Revision History:


--*/
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntlsa.h>
#include "lmcons.h"                                    // LM20_PWLEN
#include "msaudite.h"
#include <nlrepl.h>                   // I_NetNotifyMachineAccount prototype
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <cryptdll.h>
#include <pek.h>
#include "sdconvrt.h"
#include "dslayer.h"
#include <samtrace.h>
#include "validate.h"

BOOLEAN
SampIsMachineSyskeyed();

NTSTATUS
SampUpdateEncryption(
    IN SAMPR_HANDLE ServerHandle
    );

BOOLEAN
SampSyskeysAreInconsistent = FALSE;


NTSTATUS
SampClearPreviousPasswordEncryptionKey(
   IN PSAMP_OBJECT DomainContext,
   PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WriteLockHeld = FALSE;
    SAMP_OBJECT_TYPE FoundType;
    BOOLEAN  ContextReferenced = FALSE;


    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    WriteLockHeld = TRUE;

    //
    // Reference the context
    //

    Status = SampLookupContext(
                DomainContext,
                0,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ContextReferenced = TRUE;

    V1aFixed->PreviousKeyId = 0;

    //
    // Store them back to the in memory context
    //

    Status = SampSetFixedAttributes(
                DomainContext,
                V1aFixed
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                DomainContext,
                TRUE // Use the existing key handle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // We don't want these changes replicated so set transaction within
    // domain to be false.
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Commit the changes. We have to munch with the defined domains
    // because they are only updated on a transaction within a domain
    // and we don't want a transaction within a domain.
    //

    Status = SampDeReferenceContext(DomainContext, TRUE);
    ContextReferenced = FALSE;

    Status = SampCommitAndRetainWriteLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Update in memory state
    //

    RtlCopyMemory(
        &SampDefinedDomains[DomainContext->DomainIndex].UnmodifiedFixed,
        V1aFixed,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
        );

    SampPreviousKeyId = 0;

Cleanup:

    if (ContextReferenced)
    {
        SampDeReferenceContext(DomainContext,FALSE);
    }

    if (WriteLockHeld)
    {
        SampReleaseWriteLock(FALSE);
    }

    return(Status);
}

NTSTATUS
SampPerformSyskeyAccessCheck(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING OldBootKey,
    IN PRPC_UNICODE_STRING NewBootKey
    )
{
    PSAMP_OBJECT DomainContext = NULL;
    SAMP_OBJECT_TYPE FoundType;
    NTSTATUS     Status = STATUS_SUCCESS;
    NTSTATUS     IgnoreStatus,TempStatus;

    //
    // Acquire the read Lock
    //

    SampAcquireReadLock();

    //
    // Reference the domain handle, once so that an
    // access check can be enforced; the check enforces that the
    // handle passed in by the client was opened with
    // DOMAIN_WRITE_PASSWORD_PARAMS
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    Status = SampLookupContext(
                DomainContext,
                DOMAIN_WRITE_PASSWORD_PARAMS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (NT_SUCCESS(Status))
    {

        //
        // If that passed, now validate that the old syskey
        // passed in genuine.
        //

        KEEncKey EncryptedPasswordEncryptionKey;
        KEClearKey DecryptionKey;
        ULONG      DecryptStatus;
        KEClearKey SessionKey;

        RtlCopyMemory(
            &EncryptedPasswordEncryptionKey,
            SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].UnmodifiedFixed.DomainKeyInformation,
            sizeof(EncryptedPasswordEncryptionKey)
            );

        DecryptionKey.dwLength = sizeof(KEClearKey);
        DecryptionKey.dwVersion = KE_CUR_VERSION;


        RtlCopyMemory(
            DecryptionKey.ClearKey,
            OldBootKey->Buffer,
            KE_KEY_SIZE
            );

        DecryptStatus = KEDecryptKey(
                            &DecryptionKey,
                            &EncryptedPasswordEncryptionKey,
                            &SessionKey,
                            0                   // flags
                            );

        if (KE_OK!=DecryptStatus)
        {
            Status = STATUS_WRONG_PASSWORD;
        }


        RtlSecureZeroMemory(&SessionKey,sizeof(SessionKey));
        
        //
        // Dereference the context. Do not commit
        //

        IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
    }

    SampReleaseReadLock();

    return(Status);
}

NTSTATUS
SampChangeSyskeyInDs(
    IN WX_AUTH_TYPE BootOptions,
    IN PRPC_UNICODE_STRING NewBootKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TempStatus;

    //
    // Begin a DS transaction to set the information in the DS.
    //

    Status = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Make the change in the DS.
    //

    Status = DsChangeBootOptions(
                (WX_AUTH_TYPE)BootOptions,
                0,
                NewBootKey->Buffer,
                NewBootKey->Length
                );

    //
    // Commit or rollback the change in the DS.
    //

    TempStatus = SampMaybeEndDsTransaction(
                    (NT_SUCCESS(Status)) ?
                     TransactionCommit:TransactionAbort
                     );


    if ( NT_SUCCESS(Status) )
    {
        Status = TempStatus;
    }

    return(Status);
}


NTSTATUS
SampSetBootKeyInformationInRegistrySAM(
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL,
    IN PRPC_UNICODE_STRING NewBootKey,
    IN BOOLEAN EnablingEncryption,
    IN BOOLEAN ChangingSyskey,
    IN BOOLEAN ChangingPasswordEncryptionKey,
    OUT PUNICODE_STRING NewEncryptionKey
    )
/*++

  Routine Description:

    This routine is used to change the syskey, or password encryption
    key in registy SAM. It is also used to enable syskey encryption
    in registy SAM

  Arguments:

    BootOptions - Boot options to store, may be:
        SamBootKeyNone - don't do any special encryption of secrets
        SamBootKeyStored - Store a password somewhere which is used for
            encrypting secrets
        SamBootKeyPassword - Prompt the user for a password boot key.
        SamBootKeyDisk - Store the boot key on a disk.
        SamBootKeyChangePasswordEncryptionKey -- change the password encryption keys
    OldBootKey - When changing the boot key this contains the old boot key.
    NewBootKey - When setting or changing the boot key this contains the
        new boot key.

    EnablingEncryption -- Set to true when we are enabling syskey by default.
                          In this condition we should not call LSA ( LSA should
                          already be syskey'd ).

    ChangingSyskey     -- Set to true to indicate that the operation requested by
                          the client is to change the syskey

    ChangingPasswordEncryptionKey -- Set to true to indicate that the operation requested
                          by the client is to change the password encryption key

    NewEncryptionKey   -- If a new password encryption key were generated, this parameter
                          returns in the clear


  Return Values:

    STATUS_SUCCESS - The call succeeded.
    STATUS_INVALID_PARAMETER - The mix of parameters was illegal, such as
       not providing a new password when enabling encryption

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT DomainContext = NULL;
    ULONG DomainIndex = 0;
    SAMP_OBJECT_TYPE FoundType;
    USHORT DomainKeyAuthType = 0;
    USHORT DomainKeyFlags = 0;
    BOOLEAN ChangingType = FALSE;
    KEClearKey OldInputKey;
    KEClearKey InputKey;
    KEClearKey PasswordEncryptionKey;
    KEEncKey EncryptedPasswordEncryptionKey;
    ULONG KeStatus;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    BOOLEAN     ContextReferenced = FALSE;
    BOOLEAN     UpdateEncryption = FALSE;
    BOOLEAN     RXactActive = FALSE;
    BOOLEAN     WriteLockHeld = FALSE;


    //
    // Convert the boot option to an auth type
    //

    DomainKeyFlags = SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED;
    DomainKeyAuthType = (USHORT) BootOptions;

    //
    // If this is a change of the password encryption key and a previous
    // attempt at changing the password encryption key has failed, then
    // first attempt to get all user accounts to the latest key before
    // proceeding on changing the password encryption key.
    //

    if ((0!=SampPreviousKeyId) && (ChangingPasswordEncryptionKey))
    {
        Status = SampUpdateEncryption(NULL);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Acquire the SAM Write Lock; In Registry mode this starts a registry
    // transaction.
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    WriteLockHeld = TRUE;

    if (SampUseDsData)
    {
        //
        // In DS mode begin a Registry transaction by hand -acquire lock
        // will not do because we are in DS mode. We will use this registry
        // transaction to update the key information in the safe boot hive
        //

        Status = RtlStartRXact( SampRXactContext );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        RXactActive = TRUE;
    }

    //
    // Use the domain context in SampDefinedDomains. Using the defined domains below will result
    // in safe boot context in DS mode, and a normal domain context in DS mode. The code below
    // will apply the new syskey to the regular SAM hive on workstations and servers and to the
    // the safe boot hive in DS mode.
    //

    DomainContext = (SAMPR_HANDLE)
                        SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context;


    //
    // Reference the context; we have already performed an access check, so O.K to pass in a 0 for
    // desired options.
    //

    Status = SampLookupContext(
                DomainContext,
                0,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    ContextReferenced = TRUE;

    DomainIndex = DomainContext->DomainIndex;

    //
    // We don't want this change to replicate to NT 4.0 BDC's. Normally in registry mode there
    // are no NT 4.0 BDC's to worry about and in DS mode generally the serial # and change log
    // is managed through notifications by the DS. However there is one important special case
    // in the system -- this is the case of GUI setup when upgrading from an NT 4.0 DC. In this
    // instance, we are still registry mode ( DS is created on subsequent dcpromo ), and having
    // SampTransactionWithinDomain set will cause change notifications to the netlogon.log
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Get the fixed length data for the domain so we can modify it.
    //

    Status = SampGetFixedAttributes(
                DomainContext,
                TRUE, // make copy
                (PVOID *)&V1aFixed
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Initialize input key to be the new syskey
    //

    RtlSecureZeroMemory(
        &InputKey,
        sizeof(KEClearKey)
        );

    InputKey.dwVersion = KE_CUR_VERSION;
    InputKey.dwLength = sizeof(KEClearKey);
    RtlCopyMemory(
        InputKey.ClearKey,
        NewBootKey->Buffer,
        NewBootKey->Length
        );

    //
    // Intiialized old input key to be the old syskey
    // Note: We have already verified at this point that the
    // old syskey is present for all cases except the case
    // where the system is enabling encryption for the first
    // time.
    //

    RtlSecureZeroMemory(
            &OldInputKey,
            sizeof(KEClearKey)
            );

    if (ARGUMENT_PRESENT(OldBootKey))
    {

        OldInputKey.dwVersion = KE_CUR_VERSION;
        OldInputKey.dwLength = sizeof(KEClearKey);

        RtlCopyMemory(
            OldInputKey.ClearKey,
            OldBootKey->Buffer,
            OldBootKey->Length
            );
    }

    //
    // Check to see if they are setting or changing a password
    // or wanting to change password encryption keys.
    //

    if (ChangingSyskey) {

        //
        // Get the old information out of the domain structures
        //

        RtlCopyMemory(
            &EncryptedPasswordEncryptionKey,
            V1aFixed->DomainKeyInformation,
            sizeof(KEEncKey)
            );

        //
        // Re-encrypt the domain structures with the new syskey
        // provided.
        //

        ASSERT(ARGUMENT_PRESENT(OldBootKey));

        KeStatus = KEChangeKey(
                        &OldInputKey,
                        &InputKey,
                        &EncryptedPasswordEncryptionKey,
                        0                       // no flags
                        );
        if (KeStatus == KE_BAD_PASSWORD) {
            Status = STATUS_WRONG_PASSWORD;
            goto Cleanup;
        }
        if (KeStatus != KE_OK) {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        //
        // if the boot option type is being changed then,
        // update the type information in SAM
        //

        if (V1aFixed->DomainKeyAuthType != DomainKeyAuthType) {

            V1aFixed->DomainKeyAuthType = DomainKeyAuthType;
        }
    } else {

        //
        // Our intention is to either generate a new password encryption
        // key, or change the existing password encryption key.
        // Either way, generate the session key now.
        //

        // Note:
        // KEEncryptKey is a misnomer ... it not only encrypts the key, it
        // also generates a new key that is used to encrypt passwords.
        //

        if (KEEncryptKey(
                &InputKey,
                &EncryptedPasswordEncryptionKey,
                &PasswordEncryptionKey,
                0                               // no flags
                ) != KE_OK)
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }


        if (ARGUMENT_PRESENT(NewEncryptionKey))
        {
            NewEncryptionKey->Length = NewEncryptionKey->MaximumLength = sizeof(PasswordEncryptionKey.ClearKey);
            NewEncryptionKey->Buffer = MIDL_user_allocate(sizeof(PasswordEncryptionKey.ClearKey));
            if (NULL==NewEncryptionKey->Buffer)
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                NewEncryptionKey->Buffer,
                PasswordEncryptionKey.ClearKey,
                NewEncryptionKey->Length
                );
        }

        //
        // Update the boot options if we are enabling syskey
        // Leave the boot options alone if we are updating the
        // password encryption key.
        //

        if (EnablingEncryption)
        {
            V1aFixed->DomainKeyFlags = DomainKeyFlags;
            V1aFixed->DomainKeyAuthType = DomainKeyAuthType;
            V1aFixed->CurrentKeyId = 1;
            V1aFixed->PreviousKeyId = 0;
        }

        if (ChangingPasswordEncryptionKey)
        {
            //
            // If we are changing the password encryption key then
            // we need to re-encrypt all the passwords now. The
            // algorithm that we follow is as follows
            //
            //     1. Update and roll over the key
            //     2. Write out any passwords. One or more passwords
            //        are re-written
            //
            //
            // Set the previous key value equal to the current key
            // value. Note this is a safe operation to copy the value
            // of the key before the commit, as we have already ensured
            // that we do not have any password encrypted using the
            // the previous key value.
            //

            RtlCopyMemory(
                SampSecretSessionKeyPrevious,
                SampSecretSessionKey,
                sizeof(SampSecretSessionKey)
                );

            RtlCopyMemory(
                &V1aFixed->DomainKeyInformationPrevious,
                &V1aFixed->DomainKeyInformation,
                sizeof(V1aFixed->DomainKeyInformation)
                );

            V1aFixed->PreviousKeyId = V1aFixed->CurrentKeyId;
            V1aFixed->CurrentKeyId++;

            //
            // Set the boolean to update the encryption on all
            // passwords. After we commit this change, we will
            // re-encrypt all passwords
            //

            UpdateEncryption = TRUE;

        }

    }

    //
    // Now update the structures we are changing.
    //

    RtlCopyMemory(
        V1aFixed->DomainKeyInformation,
        &EncryptedPasswordEncryptionKey,
        sizeof(EncryptedPasswordEncryptionKey)
        );

    //
    // Store them back to the in memory context
    //

    Status = SampSetFixedAttributes(
                DomainContext,
                V1aFixed
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                DomainContext,
                TRUE // Use the existing key handle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // We don't want these changes replicated so set transaction within
    // domain to be false.
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Commit the changes. We have to munch with the defined domains
    // because they are only updated on a transaction within a domain
    // and we don't want a transaction within a domain.
    //

    Status = SampDeReferenceContext(DomainContext, TRUE);
    ContextReferenced = FALSE;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }



    if (SampUseDsData)
    {
        //
        // In DS mode , commit the registry transaction by hand
        // as CommitAndRetainWriteLock will not commit the write
        // lock.
        //

        Status = RtlApplyRXact(SampRXactContext);
        RXactActive = FALSE;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Commit the changes, requesting an immediate flush.
    // Note the write lock is still being retained after the commit
    // to update in memory state
    //

    FlushImmediately = TRUE;
    Status = SampCommitAndRetainWriteLock();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the new data into the in-memory object now that it has been
    // committed to disk.
    //

    RtlCopyMemory(
        &SampDefinedDomains[DomainIndex].UnmodifiedFixed,
        V1aFixed,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
        );

    //
    // Update the new password encryption key in memory
    //

    if (EnablingEncryption || ChangingPasswordEncryptionKey)
    {
        RtlCopyMemory(
            SampSecretSessionKey,
            PasswordEncryptionKey.ClearKey,
            sizeof(PasswordEncryptionKey.ClearKey)
            );
    }

    SampCurrentKeyId = V1aFixed->CurrentKeyId;
    SampPreviousKeyId = V1aFixed->PreviousKeyId;

    //
    // Release the Write Lock
    //

    SampReleaseWriteLock(FALSE);
    WriteLockHeld = FALSE;

    //
    // Changes have been committed at this point, if required update encryption
    //

    if (UpdateEncryption)
    {
        //
        // We don't allow this operation in DS mode.
        //

        ASSERT(!SampUseDsData);

        Status = SampUpdateEncryption(NULL);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // At this point, we have written out the new key, the previous key and updated
        // the encryption. It is now time to clear out the previous key
        //

        Status = SampClearPreviousPasswordEncryptionKey(
                        DomainContext,
                        V1aFixed
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

Cleanup:

    //
    // Otherwise rollback any changes
    //

    if ((DomainContext != NULL) && (ContextReferenced)) {
        (VOID) SampDeReferenceContext(DomainContext, FALSE);
    }

    //
    // If we are in DS mode then abort the registry transaction by Hand
    //

    if (RXactActive)
    {
       RtlAbortRXact( SampRXactContext );
       RXactActive = FALSE;
    }


    if (WriteLockHeld)
    {
        SampReleaseWriteLock(FALSE);
    }


    RtlSecureZeroMemory(
        &PasswordEncryptionKey,
        sizeof(PasswordEncryptionKey)
        );

    RtlSecureZeroMemory(
        &InputKey,
        sizeof(InputKey)
        );

    RtlSecureZeroMemory(
        &OldInputKey,
        sizeof(OldInputKey)
        );

    if (V1aFixed != NULL) {
        MIDL_user_free(V1aFixed);
    }

    return(Status);

}


NTSTATUS
SampSetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL ,
    IN PRPC_UNICODE_STRING NewBootKey,
    IN BOOLEAN SuppressAccessCk,
    IN BOOLEAN EnablingSyskey,
    IN BOOLEAN ChangingSyskey,
    IN BOOLEAN ChangingPasswordEncryptionKey,
    OUT PUNICODE_STRING NewEncryptionKey OPTIONAL,
    OUT BOOLEAN * SyskeyChangedInLsa
    )
/*++

Routine Description:

    This routine enables secret data encryption and sets the flag indicating
    how the password is obtained. If we weren't previously encrypting
    secret data then NewBootKey must not be NULL. If we were already
    encrypting secret data and NewBootKey is non-null then we are changing
    the password and OldBootKey must be non-null.

    You can't disable encryption after enabling it.


Arguments:

    DomainHandle - Handle to a domain object open for DOMAIN_WRITE_PASSWORD_PARAMS.
    BootOptions - Boot options to store, may be:
        SamBootKeyNone - don't do any special encryption of secrets
        SamBootKeyStored - Store a password somewhere which is used for
            encrypting secrets
        SamBootKeyPassword - Prompt the user for a password boot key.
        SamBootKeyDisk - Store the boot key on a disk.
    OldBootKey - When changing the boot key this contains the old boot key.
    NewBootKey - When setting or changing the boot key this contains the
        new boot key.

    SuppressAccessCk   -- Set to true when called from an inprocess caller, to
                          suppress the ck on the domain handle
    EnablingEncryption -- Set to true when we are enabling syskey by default.
                          In this condition we should not call LSA ( LSA should
                          already be syskey'd ).

    ChangingSyskey     -- Set to true to indicate that the operation requested by
                          the client is to change the syskey

    ChangingPasswordEncryptionKey -- Set to true to indicate that the operation requested
                          by the client is to change the password encryption key

    NewEncryptionKey   -- If a new password encryption key were generated, this parameter
                          returns in the clear

    SyskeyChangedInLsa -- TRUE if the syskey was changed in LSA. This is used in error
                          handling, as the syskey could have been changed in LSA, but then
                          not changed in SAM/ DS.

Return Value:

    STATUS_SUCCESS - The call succeeded.
    STATUS_INVALID_PARAMETER - The mix of parameters was illegal, such as
       not providing a new password when enabling encryption

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT DomainContext = NULL;
    ULONG DomainIndex = 0;
    SAMP_OBJECT_TYPE FoundType;

    //
    // Initialize return values
    //

    *SyskeyChangedInLsa = FALSE;

    //
    // On a domain controller when we syskey we change state in the DS,
    // as well in the registry for the safe mode hives. If a domain controller
    // is booted into safe mode we will not allow the syskey settings to be
    // changed.
    //

    if (LsaISafeMode())
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // if SAM and LSA syskey's are inconsistent then fail the call,
    // no further syskey change is allowed till reboot. Syskey's could
    // become inconsistent, if a previous call to this routine, changed
    // the syskey value in LSA, but not in SAM. The syskey logic maintains
    // the old syskey, encrypted with the new syskey, so there is recovery possible
    // for one failure, but not further; till the next reboot. The condition
    // below ensures that subsequent requests to change the syskey will be failed
    // till the reboot if one failure occurs.
    //

    if (SampSyskeysAreInconsistent)
    {
        return STATUS_INVALID_SERVER_STATE;
    }

    //
    // We don't allow changing of password encryption keys ( presently ) on a
    // domain controller
    //

    if ((SampUseDsData) && (ChangingPasswordEncryptionKey))
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If a previous password encryption key change was attempted and was unsuccessful,
    // then block a subsequent syskey change till the password encryption key change
    // is successful
    //

    if ((0!=SampPreviousKeyId) && (ChangingSyskey))
    {
        return STATUS_INVALID_SERVER_STATE;
    }


    //
    // Validate the boot options
    //

    switch(BootOptions) {
    case SamBootKeyStored:
    case SamBootKeyPassword:
    case SamBootKeyDisk:

        //
        // These 3 options are used to change how the syskey is supplied
        // at startup.
        //

    case SamBootChangePasswordEncryptionKey:

        //
        // This option implies a change of the password encryption keys
        //
        break;

        //
        // SamBootKeyNone was used in NT 4.0 to denote a machine that is
        // not syskey'd. In w2k and whistler we are always syskey'd, so
        //
    case SamBootKeyNone:
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the new NewBootKey is not specified then fail the call
    // with STATUS_INVALID_PARAMETER. Since we are syskey'd by default
    // this parameter must be supplied. The NewBootKey parameter in this
    // function is a new syskey. Since we do not support a mode where
    // we are not syskey'd or allow the caller to remove syskey, therefore
    // fail the call now.
    //

    if ((NULL==NewBootKey) || (NewBootKey->Length > KE_KEY_SIZE))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If encryption is already enabled and they haven't provided
    // an old syskey, fail now.
    //

    if (!EnablingSyskey) {
        if (!ARGUMENT_PRESENT(OldBootKey)) {
             Status = STATUS_INVALID_PARAMETER;
            return(STATUS_INVALID_PARAMETER);
        } else if (OldBootKey->Length != KE_KEY_SIZE) {
            Status = STATUS_INVALID_PARAMETER;
            return(STATUS_INVALID_PARAMETER);
        }
    }

    //
    // The caller can do only one of 3 things -- EnablingSyskey, ChangingSyskey
    // or ChangingPasswordEncryptionKey. Check that the caller is indeed
    // requesting exactly one of these operations
    //

    if (EnablingSyskey ) {
        if (ChangingSyskey ||ChangingPasswordEncryptionKey) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    else if (ChangingSyskey) {
        if (ChangingPasswordEncryptionKey) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    else if (!ChangingPasswordEncryptionKey) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Perform an access ck first. The caller can request a suppression
    // of an access check. This happens only at boot time, where it is the
    // system that is wanting to syskey the machine and hence suppresses
    // the access check. Syskey Access check verfies that the caller has
    // write rights on domain password parameters and also does an authentication
    // check that the old syskey passed in checks out O.K
    //

    if (!SuppressAccessCk)
    {
        Status = SampPerformSyskeyAccessCheck(
                        DomainHandle,
                        OldBootKey,
                        NewBootKey
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // First Set the boot key and Boot option in the LSA.
    //

    if (ChangingSyskey)
    {

        Status = LsaISetBootOption(
                    BootOptions,
                    OldBootKey->Buffer,
                    OldBootKey->Length,
                    NewBootKey->Buffer,
                    NewBootKey->Length
                    );

        if (NT_SUCCESS(Status))
        {
            //
            // If the syskey was changed in the LSA, return that
            // info to the caller. For client initiated call, we
            // are not allowed to fail the client RPC call, if the
            // syskey has been changed in LSA
            //

            *SyskeyChangedInLsa = TRUE;
        }
    }
    else if (ChangingPasswordEncryptionKey)
    {
        Status = LsaIChangeSecretCipherKey(
                    NewBootKey->Buffer
                    );
    }


    //
    // If Change in LSA was failed bail now. Note recovery is still
    // possble if the change in LSA succeeds, but changes in SAM or
    // DS are failed. The reason for this is that we store the old
    // syskey in lsa, and at boot time know to retry with the older
    // key.
    //

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Next change the syskey in the DS. If the DS operation succeeds
    // then proceed on to changing the syskey in SAM. If the DS
    // option fails, then bail right now. The error handling comment
    // above will apply. No Syskey change in DS is attempted if this
    // is not DS mode.
    //

    if ((SampUseDsData ) &&
       (ChangingSyskey || EnablingSyskey))
    {

        Status = SampChangeSyskeyInDs(
                    (WX_AUTH_TYPE) BootOptions,
                    NewBootKey
                    );
        //
        // Bail right away if DS failed
        //

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // At this point syskey has been changed in LSA, and the DS. The syskey
    // needs to be changed in Registry SAM. In DS mode these are the SAM
    // hives used for restore mode.
    //

    Status = SampSetBootKeyInformationInRegistrySAM(
                    BootOptions,
                    OldBootKey,
                    NewBootKey,
                    EnablingSyskey,
                    ChangingSyskey,
                    ChangingPasswordEncryptionKey,
                    NewEncryptionKey
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:

    if (ARGUMENT_PRESENT(NewBootKey) && (NewBootKey->Buffer != NULL)) {
        RtlSecureZeroMemory(
            NewBootKey->Buffer,
            NewBootKey->Length
            );
    }

    if (ARGUMENT_PRESENT(OldBootKey) && (OldBootKey->Buffer != NULL)) {
        RtlSecureZeroMemory(
            OldBootKey->Buffer,
            OldBootKey->Length
            );
    }

    return(Status);


}

NTSTATUS
SamrSetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL ,
    IN PRPC_UNICODE_STRING NewBootKey OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  fSyskeyChangedInLsa = FALSE;


    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetBootKeyInformation
                   );

    //
    // Since we are syskey'd by default on a w2k server, old and new keys
    // must be supplied
    //

    if (  (OldBootKey == NULL) ||
          (OldBootKey->Length != KE_KEY_SIZE) ||
          (OldBootKey->Buffer == NULL)  ||
          (NewBootKey == NULL) ||
          (NewBootKey->Length != KE_KEY_SIZE) ||
          (NewBootKey->Buffer == NULL) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Error;

    }

    //
    // Check input parameters
    //

    if( !SampValidateRpcUnicodeString( OldBootKey ) ||
        !SampValidateRpcUnicodeString( NewBootKey ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    Status = SampSetBootKeyInformation(
                DomainHandle,
                BootOptions,
                OldBootKey,
                NewBootKey,
                FALSE, // suppress access check
                FALSE, // Enabling syskey
                (SamBootChangePasswordEncryptionKey!=BootOptions),  // Changing syskey
                (SamBootChangePasswordEncryptionKey==BootOptions),  // Changing password encryption key
                NULL,
                &fSyskeyChangedInLsa
                );

    //
    // If the syskey was changed in lsa but not in SAM/DS the above call will fail, but the boolean
    // fSyskeyChangedInLsa will be true. In that case we are not allowed to fail this call.
    //

    if (fSyskeyChangedInLsa)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // if the syskey was changed in LSA and not in SAM, then block
            // further changes to the syskey. This is because SAM can recover
            // only if the syskey is out of date by just one key
            // This blocking is implemented by setting the global boolean
            // Reboot would clear the boolean as well as set the recovery
            // logic.
            //
            SampSyskeysAreInconsistent = TRUE;
        }
        Status = STATUS_SUCCESS;
    }

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetBootKeyInformation
                   );

    return(Status);
}


NTSTATUS
SamIGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++

Routine Description:

    This routine returns the boot options for the domain. It is only
    valid when called from the AccountDomain.


Arguments:

    DomainHandle - Handle to the account domain object open for
        DOMAIN_READ_PASSWORD_PARAMETERS
    BootOptions - Receives the boot options from the domain.


Return Value:

    STATUS_SUCCESS - The call succeeded.

--*/
{
    NTSTATUS Status;
    PSAMP_OBJECT DomainContext;
    ULONG DomainIndex;
    SAMP_OBJECT_TYPE FoundType;

    //
    // Not Supported in DS Mode
    //

    if (TRUE==SampUseDsData)
    {
        *BootOptions = DsGetBootOptions();
        return STATUS_SUCCESS;
    }




    SampAcquireReadLock();

    if (0!=DomainHandle)
    {
        DomainContext = (PSAMP_OBJECT)DomainHandle;
    }
    else
    {
        DomainContext = SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context;
    }

    Status = SampLookupContext(
                DomainContext,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );
    if (!NT_SUCCESS(Status)) {
        DomainContext = NULL;
        goto Cleanup;
    }

    // it is only valid if called from AccountDomain
    if ( IsBuiltinDomain(DomainContext->DomainIndex) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify that the caller passed in the correct domain handle
    //

    DomainIndex = DomainContext->DomainIndex;

    *BootOptions = (SAMPR_BOOT_TYPE) SampDefinedDomains[DomainIndex].UnmodifiedFixed.DomainKeyAuthType;

Cleanup:

    if (DomainContext != NULL) {

        (VOID) SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    return(Status);
}

NTSTATUS
SamrGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++

Routine Description:

    This routine returns the boot options for the domain. It is only
    valid when called from the AccountDomain.

Arguments:

    DomainHandle - Handle to the account domain object open for
        DOMAIN_READ_PASSWORD_PARAMETERS
    BootOptions - Receives the boot options from the domain.


Return Value:

    STATUS_SUCCESS - The call succeeded.

--*/
{
    NTSTATUS Status;
    PSAMP_OBJECT DomainContext;
    ULONG DomainIndex;
    SAMP_OBJECT_TYPE FoundType;
    ULONG            LsaBootType;

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetBootKeyInformation
                   );


    SampAcquireReadLock();


    DomainContext = (PSAMP_OBJECT)DomainHandle;

    Status = SampLookupContext(
                DomainContext,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );
    if (!NT_SUCCESS(Status)) {
        DomainContext = NULL;
        goto Cleanup;
    }

    // it is only valid if called from AccountDomain
    if ( IsBuiltinDomain(DomainContext->DomainIndex) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = LsaIGetBootOption(&LsaBootType);

    if (NT_SUCCESS(Status))
    {
        *BootOptions = (SAMPR_BOOT_TYPE)LsaBootType;
    }

Cleanup:

    if (DomainContext != NULL) {

        (VOID) SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetBootKeyInformation
                   );

    return(Status);
}

NTSTATUS
SampApplyDefaultSyskey()

/*++

  Routine Description

    This routine changes the system such that the system is syskey'd so that
    the system stores the key ( scattered in the registry ). It first checks
    the system state before it embarks on syskey'ing the system

--*/
{
    UCHAR Syskey[16]; // the syskey is 128 bits in size
    ULONG SyskeyLength = sizeof(Syskey);
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RPC_UNICODE_STRING NewBootKey;
    UNICODE_STRING     PasswordEncryptionKey;
    BOOLEAN            fSyskeyChangedInLsa = FALSE;


    //
    // init local variable
    // 
    RtlInitUnicodeString(&PasswordEncryptionKey, NULL);


    //
    // First Check to see if the machine is syskey'd
    //

     if (!SampIsMachineSyskeyed() && !LsaISafeMode())
    {

        // Set the upgrade flag
        SampUpgradeInProcess = TRUE;



        //
        // Query the syskey from LSA.
        //

        NtStatus = LsaIHealthCheck(
                        NULL,
                        LSAI_SAM_STATE_RETRIEVE_SESS_KEY,
                        Syskey,
                        &SyskeyLength
                        );

        if (!NT_SUCCESS(NtStatus))
        {

            //
            // This means that SAM is not syskey'd and LSA is not syskey'd. This will happen only
            // when upgrading a non syskey'd system.
            //


            //
            // Tell the LSA to generate a new Syskey and also generate its own password encryption
            // key etc.
            //

            NtStatus =  LsaIHealthCheck(
                            NULL,
                            LSAI_SAM_GENERATE_SESS_KEY,
                            NULL,
                            0
                            );

            //
            // If that succeeded, then query the syskey from Lsa.
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = LsaIHealthCheck(
                                NULL,
                                LSAI_SAM_STATE_RETRIEVE_SESS_KEY,
                                Syskey,
                                &SyskeyLength
                                );
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

        ASSERT(SyskeyLength==sizeof(Syskey));



        //
        // Save it in SAM. If this operation fails, the machine is syskey with system
        // saves key, but is not syskey'd according to SAM. THe machine will still continue
        // to boot correctly as SAM will tell winlogon on next boot that all is o.k and discard
        // the passed in syskey. SAM will re syskey the machine upon next boot.
        //

        NewBootKey.Buffer = (WCHAR *) Syskey;
        NewBootKey.Length = sizeof(Syskey);
        NewBootKey.MaximumLength = sizeof(Syskey);

        NtStatus = SampSetBootKeyInformation(
                        SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context,
                        SamBootKeyStored,
                        NULL,
                        &NewBootKey,
                        TRUE, // Suppress access check
                        TRUE, // Enabling syskey
                        FALSE,// Changing syskey
                        FALSE,// Changing password encryption key
                        &PasswordEncryptionKey,
                        &fSyskeyChangedInLsa
                        );



        if (NT_SUCCESS(NtStatus))
        {
            RtlCopyMemory(
                SampSecretSessionKey,
                PasswordEncryptionKey.Buffer,
                PasswordEncryptionKey.Length
                );

            SampCurrentKeyId = 1;
            SampPreviousKeyId = 0;
            SampSecretEncryptionEnabled = TRUE;
        }
    }


Error:

    // free resource
    if (NULL != PasswordEncryptionKey.Buffer)
    {
        RtlSecureZeroMemory(PasswordEncryptionKey.Buffer, PasswordEncryptionKey.Length);
        MIDL_user_free(PasswordEncryptionKey.Buffer);
        memset(&PasswordEncryptionKey, 0, sizeof(PasswordEncryptionKey));
    }

    // Clear the upgrade flag ( it might have been set in this routine
    SampUpgradeInProcess = FALSE;

    //
    // Clear the syskey in the LSA
    //

     LsaIHealthCheck(
                    NULL,
                    LSAI_SAM_STATE_CLEAR_SESS_KEY,
                    NULL,
                    0
                    );

    return(NtStatus);
}



BOOLEAN
SampIsMachineSyskeyed()
{

    //
    // If the safe boot hive is syskey'd or registry mode is syskey'd then
    // we are syskey'd
    //

    if ((SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX]
            .UnmodifiedFixed.DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) != 0)
    {
        return (TRUE);
    }

    //
    // Else if we are in DS mode , and DS is syskey'd then we are syskey'd
    //

    if (SampUseDsData && (SamBootKeyNone!=DsGetBootOptions()))
    {
        return(TRUE);
    }



    return(FALSE);
}

NTSTATUS
SampInitializeSessionKey(
    VOID
    )
/*++

Routine Description:

    This routine initializes the session key information by reading the
    stored data from the Sam defined domains structures and decrypting
    it with the key provided by winlogon. This routine also adds a default
    syskey if it detects that the machine is not syskey'd

Arguments:



Return Value:

    TRUE - Successfully initialize the session key information.
    FALSE - Something failed during initialization

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccountDomainIndex = -1, BuiltinDomainIndex = -1, Index;
    HANDLE WinlogonHandle = NULL;
    UCHAR PasswordBuffer[16];
    ULONG PasswordBufferSize = sizeof(PasswordBuffer);
    KEClearKey DecryptionKey;
    KEClearKey OldDecryptionKey;
    KEClearKey SessionKey;
    KEEncKey EncryptedSessionKey;
    BOOLEAN  PreviousSessionKeyExists = FALSE;
    ULONG Tries = 0;
    ULONG DecryptStatus = KE_OK;
    ULONG KeyLength;
    UNICODE_STRING NewSessionKey;
    ULONG          SampSessionKeyLength;




    //
    // In DS mode, use the safe boot account domain, in registry mode use
    // the normal account domain.
    //

    AccountDomainIndex = SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX;

    //
    // Figure out whether or not we are doing encryption.
    // If we are syskey'd then set the global SampSecretEncryption enabled
    // to true
    //

    SampSecretEncryptionEnabled = FALSE;
    if ((SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyFlags &
        SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) != 0) {

        //
        // Set the boolean according to whether syskey encryption is
        // enabled or not.
        //

        SampSecretEncryptionEnabled = TRUE;
    }

    DecryptionKey.dwLength = sizeof(KEClearKey);
    DecryptionKey.dwVersion = KE_CUR_VERSION;

    RtlSecureZeroMemory(
            DecryptionKey.ClearKey,
            KE_KEY_SIZE
            );

    OldDecryptionKey.dwLength = sizeof(KEClearKey);
    OldDecryptionKey.dwVersion = KE_CUR_VERSION;

        
    RtlSecureZeroMemory(
            OldDecryptionKey.ClearKey,
            KE_KEY_SIZE
            );

    if (SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.PreviousKeyId!=0)
    {
        PreviousSessionKeyExists = TRUE;
    }

    //
    // Query the Syskey from LSA
    //

    Status = LsaIHealthCheck(
                NULL,
                LSAI_SAM_STATE_RETRIEVE_SESS_KEY,
                DecryptionKey.ClearKey,
                &KeyLength
                );

    if (NT_SUCCESS(Status))
    {

        if (!SampSecretEncryptionEnabled)
        {
            //
            // if secret encryption is not enabled just bail.
            //

            goto Cleanup;
        }

        //
        // LSA has the key, get the key from LSA and decrypt the password encryption
        // key
        //

        //
        // Build the input parameters for the key decryption routine.
        //

        RtlCopyMemory(
            &EncryptedSessionKey,
            SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
            sizeof(EncryptedSessionKey)
            );

        DecryptStatus = KEDecryptKey(
                            &DecryptionKey,
                            &EncryptedSessionKey,
                            &SessionKey,
                            0                   // flags
                            );

        if (KE_BAD_PASSWORD==DecryptStatus)
        {
            //
            // We have encountered a key mismatch betweeen SAM and LSA. This could be because
            // a change of syskey failed after changing the syskey in the LSA. If so retrieve
            // the old syskey from LSA and
            //

            Status = LsaIHealthCheck(
                        NULL,
                        LSAI_SAM_STATE_OLD_SESS_KEY,
                        OldDecryptionKey.ClearKey,
                        &KeyLength
                        );

            if (NT_SUCCESS(Status))
            {
                ULONG KeStatus;

                 RtlCopyMemory(
                        &EncryptedSessionKey,
                        SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                        sizeof(EncryptedSessionKey)
                        );

                 DecryptStatus = KEDecryptKey(
                                    &OldDecryptionKey,
                                    &EncryptedSessionKey,
                                    &SessionKey,
                                    0                   // flags
                                    );

                 if (KE_OK==DecryptStatus)
                 {
                      KEEncKey NewEncryptedSessionKey;


                      //
                      // Since we don't allow a syskey change after a failure to change password
                      // encryption key and don't allow a password encryption after a failure to
                      // change syskey; we cannot be in a state where we need to recover using an
                      // old syskey and simultaneously also recover from a failure to change password
                      // encryption key, using an old password encryption key.
                      //

                      ASSERT(!PreviousSessionKeyExists);

                     //
                     // We decrypted O.K with old key, change the database here; to encrypt with the new key
                     //

                      RtlCopyMemory(
                            &NewEncryptedSessionKey,
                            SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                            sizeof(NewEncryptedSessionKey)
                            );

                      KeStatus = KEChangeKey(
                                    &OldDecryptionKey,
                                    &DecryptionKey,
                                    &NewEncryptedSessionKey,
                                    0  // no flags
                                    );

                      //
                      // We just decrypted fine with the old key
                      //

                      ASSERT(KE_OK==KeStatus);


                     //
                     // Now update the structures we are changing.
                     //

                     Status = SampAcquireWriteLock();
                     if (!NT_SUCCESS(Status))
                     {
                         goto Cleanup;
                     }

                     SampSetTransactionDomain(AccountDomainIndex);

                     RtlCopyMemory(
                        SampDefinedDomains[AccountDomainIndex].CurrentFixed.DomainKeyInformation,
                        &NewEncryptedSessionKey,
                        sizeof(NewEncryptedSessionKey)
                        );

                    //
                    // Commit the change
                    //

                    Status = SampReleaseWriteLock(TRUE);
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                }
                else
                {
                    ASSERT(FALSE && "Syskey Mismatch");
                    Status = STATUS_UNSUCCESSFUL;
                    goto Cleanup;

                }
            }
        }
        else if (DecryptStatus !=KE_OK)
        {
            ASSERT(FALSE && "Syskey Mismatch");
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // If we are here then the key has been encrypted correctly
        // either by new or old syskey.
        //

        RtlCopyMemory(
            SampSecretSessionKey,
            SessionKey.ClearKey,
            KE_KEY_SIZE
            );

        //
        // Get the previous session key
        //

        if (PreviousSessionKeyExists)
        {
             KEEncKey EncryptedSessionKeyPrevious;
             KEClearKey SessionKeyPrevious;
             ULONG      TempDecryptStatus;



             RtlCopyMemory(
                 &EncryptedSessionKeyPrevious,
                 SampDefinedDomains[AccountDomainIndex].CurrentFixed.DomainKeyInformationPrevious,
                 sizeof(EncryptedSessionKeyPrevious)
                 );

             TempDecryptStatus = KEDecryptKey(
                                    &DecryptionKey,
                                    &EncryptedSessionKeyPrevious,
                                    &SessionKeyPrevious,
                                    0
                                    );

             //
             // The decryption should decrypt fine, as we just used
             // the syskey to decrypt the latest password encryption key
             //
             ASSERT(KE_OK == TempDecryptStatus);

             RtlCopyMemory(
                SampSecretSessionKeyPrevious,
                SessionKeyPrevious.ClearKey,
                KE_KEY_SIZE
                );

             RtlSecureZeroMemory(
                 &SessionKeyPrevious,
                 sizeof(KEClearKey)
                 );
        }

        SampCurrentKeyId = SampDefinedDomains[AccountDomainIndex].CurrentFixed.CurrentKeyId;
        SampPreviousKeyId = SampDefinedDomains[AccountDomainIndex].CurrentFixed.PreviousKeyId;

        //
        // Assert that we either don't have an old key, or if we have an old key it is not
        // more than one off in terms of key sequence with the current key.
        //

        ASSERT((SampPreviousKeyId==0) || (SampCurrentKeyId==(SampPreviousKeyId+1)));

        RtlSecureZeroMemory(
            &SessionKey,
            sizeof(KEClearKey)
            );

    }
    else if ((SampProductType!=NtProductLanManNt ) || (SampIsDownlevelDcUpgrade()))
    {
        //
        //
        // Fall back to calling Winlogon to obtain the key information
        // do so , only if we are booting to registry mode. If booting to
        // DS mode, then DS will do this fallback. This should happen
        // really only during GUI setup. Note we do not test for SampUseDsData as this
        // variable is not set during this time
        //

        Status = WxConnect(
                    &WinlogonHandle
                    );

        //
        // If encryption is not enabled, tell winlogon. If winlogon isn't running
        // the LPC server, that is o.k. This may happen in NT4 as the act of "syskeying"
        // a DC was not transacted. Therefore to successfully upgrade a damaged NT4 machine
        // we have this test.
        //

        if (!SampSecretEncryptionEnabled)
        {

                (VOID) WxReportResults(
                            WinlogonHandle,
                            STATUS_SUCCESS
                            );

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }


        //
        // If encryption is enabled and there is no LPC server, fail now.
        //

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        for (Tries = 0; Tries < SAMP_BOOT_KEY_RETRY_COUNT ; Tries++ )
        {

            DecryptionKey.dwLength = sizeof(KEClearKey);
            DecryptionKey.dwVersion = KE_CUR_VERSION;
            RtlSecureZeroMemory(
                DecryptionKey.ClearKey,
                KE_KEY_SIZE
                );

            KeyLength = KE_KEY_SIZE;
            Status = WxGetKeyData(
                        WinlogonHandle,
                        (WX_AUTH_TYPE) SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyAuthType,
                        KeyLength,
                        DecryptionKey.ClearKey,
                        &KeyLength
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // Build the input parameters for the key decryption routine.
            //

            RtlCopyMemory(
                &EncryptedSessionKey,
                SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                sizeof(EncryptedSessionKey)
                );

            DecryptStatus = KEDecryptKey(
                                &DecryptionKey,
                                &EncryptedSessionKey,
                                &SessionKey,
                                0                   // flags
                                );


            Status = WxReportResults(
                        WinlogonHandle,
                        ((DecryptStatus == KE_OK) ? STATUS_SUCCESS :
                            ((DecryptStatus == KE_BAD_PASSWORD) ?
                                STATUS_WRONG_PASSWORD :
                                STATUS_INTERNAL_ERROR))
                            );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            if (DecryptStatus == KE_OK)
            {
                break;
            }

        }

        if (DecryptStatus != KE_OK) {
            Status = STATUS_WRONG_PASSWORD;
            goto Cleanup;
        }



        //
        // Initialize the RC4key for use and clear the session key from memory
        //

        RtlCopyMemory(
            SampSecretSessionKey,
            SessionKey.ClearKey,
            KE_KEY_SIZE
            );

        SampCurrentKeyId = 1;
        SampPreviousKeyId = 0;

        RtlSecureZeroMemory(
            &SessionKey,
            sizeof(KEClearKey)
            );

        //
        // Notify LSA of SAM's password encryption key, to unroll any
        // any secrets encrypted with the password encryption key
        //

        SampSessionKeyLength =  SAMP_SESSION_KEY_LENGTH;
        LsaIHealthCheck( NULL,
                         LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION,
                         ( PVOID )&SampSecretSessionKey,
                          &SampSessionKeyLength);

        //
        // Pass the syskey to LSA so, that it can be used in encryption of
        // secrets. Set the upgrade in progress bit, so that LSA can come back
        // and make sam calls to retrieve boot state.
        //

        SampUpgradeInProcess = TRUE;


        LsaIHealthCheck(
            NULL,
            LSAI_SAM_STATE_SESS_KEY,
            ( PVOID )&DecryptionKey.ClearKey,
            &KeyLength
            );

        SampUpgradeInProcess = FALSE;

        //
        // Eat the key
        //

        RtlSecureZeroMemory(
           &DecryptionKey,
           sizeof(KEClearKey)
           );


    }
    else
    {
        //
        // DC is being upgraded and we are in GUI setup
        // reset the status to STATUS_SUCCESS
        // and proceed over, the DS will initialize the password
        // encryption key. It is assumed that no changes to the
        // Safe boot hives are made during the GUI setup phase
        // of a DC upgrade.
        //

         Status = STATUS_SUCCESS;
    }

Cleanup:

    if (WinlogonHandle != NULL) {
        NtClose(WinlogonHandle);
    }

    return(Status);
}


BOOLEAN
SamIIsSetupInProgress(OUT BOOLEAN * fUpgrade)
{
  return(SampIsSetupInProgress(fUpgrade));
}

BOOLEAN
SamIIsDownlevelDcUpgrade()
{
  return(SampIsDownlevelDcUpgrade());
}

BOOLEAN
SamIIsRebootAfterPromotion()
{
  ULONG PromoteData;
  return((BOOLEAN)SampIsRebootAfterPromotion(&PromoteData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\string.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file contains services for retrieving and replacing string field
    values.


Author:

    Jim Kelly    (JimK)  10-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampGetUnicodeStringField(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING *String
    )

/*++

Routine Description:

    This service retrieves a unicode string from a named sub-key of
    the root key provided in the Context argument.

    The returned unicode string is returned in two buffers allocated
    using MIDL_user_allocate() and are therefore suitable for returning as
    [out] parameters of an RPC call.  The first buffer will be the unicode
    string body.  The second buffer will contain the unicode string
    characters and will include 2 bytes of zeros.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to an active context block whose RootKey is valid.

    SubKeyName - The name of the sub-key containing the unicode string
        to retrieve.

    String - Receives a pointer to a set of allocated buffers containing
        the unicode string.  The buffers are allocated using
        MIDL_userAllocate().  If any errors are returned, these buffers
        will not be allocated.

Return Value:


    STATUS_SUCCESS - The string value has been successfully retrieved.

    STATUS_NO_MEMORY - There was insufficient memory to allocate a
        buffer to read the unicode string into.

    STATUS_INTERNAL_ERROR - The value of the sub-key seems to have changed
        during the execution of this service.  This should not happen since
        the service must be called with the WRITE LOCK held.

    Other error values are those returned by:

            NtQueryValueKey()


--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    HANDLE SubKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG StringLength, ActualStringLength, IgnoreKeyValueType;
    PUNICODE_STRING StringBody;
    PCHAR CharacterBuffer;
    LARGE_INTEGER LastWriteTime;

    SAMTRACE("SampGetUnicodeStringField");

    //
    // Prepare for failure
    //

    *String = NULL;


    //
    // Open the named sub-key ...
    //

    InitializeObjectAttributes(
        &ObjectAttributes,          // Resultant object attributes
        SubKeyName,                 // Relative Name
        OBJ_CASE_INSENSITIVE,       // Attributes
        Context->RootKey,           // Parent key handle
        NULL                        // SecurityDescriptor
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(       // Don't use NtCreateKey() - it must already exist
                   &SubKeyHandle,
                   KEY_READ,
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Query the length of the unicode string in the sub-key
    //

    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyValueType,
                   NULL,                    // No buffer yet
                   &StringLength,
                   &LastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyValueType,
                                NULL,
                                &StringLength,
                                &LastWriteTime);

    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = NtClose( SubKeyHandle );
        return(NtStatus);
    }



    //
    // Allocate buffers for both the string body and the
    // character buffer.
    //

    CharacterBuffer = MIDL_user_allocate( StringLength + sizeof(UNICODE_NULL) );
    StringBody      = MIDL_user_allocate( sizeof(UNICODE_STRING) );

    if ((CharacterBuffer == NULL) || (StringBody == NULL)) {

        //
        // We couldn't allocate pool ...
        //

        IgnoreStatus = NtClose( SubKeyHandle );

        if (CharacterBuffer != NULL) {
            MIDL_user_free( CharacterBuffer );
        }
        if (StringBody != NULL) {
            MIDL_user_free( StringBody );
        }

        return(STATUS_NO_MEMORY);
    }



    //
    // Initialize the string body
    //

    StringBody->Length        = (USHORT)StringLength;
    StringBody->MaximumLength = (USHORT)StringLength + (USHORT)sizeof(UNICODE_NULL);
    StringBody->Buffer        = (PWSTR)CharacterBuffer;

    //
    // Read the string value into the character buffer.
    //

    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyValueType,
                   CharacterBuffer,
                   &ActualStringLength,
                   &LastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyValueType,
                                CharacterBuffer,
                                &ActualStringLength,
                                &LastWriteTime);

    if (NT_SUCCESS(NtStatus)) {
        if (ActualStringLength != StringLength) {

            //
            // Hmmm - we just queuried the length and got StringLength.
            //        Then we read the buffer and its different, yet the
            //        whole time we've held the write lock.  Something
            //        has messed up our database.
            //

            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        IgnoreStatus = NtClose( SubKeyHandle );

        MIDL_user_free( CharacterBuffer );
        MIDL_user_free( StringBody );

        return(NtStatus);
    }


    //
    // Null terminate the string
    //

    UnicodeTerminate(StringBody);
    *String = StringBody;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\upgrade.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    This is the file for a simple connection test to SAM.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <msaudite.h>
#include <ntdsa.h>
#include <attids.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <malloc.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global data structures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
ULONG AdministrativeRids[] = {
    DOMAIN_ALIAS_RID_ADMINS,
    DOMAIN_ALIAS_RID_SYSTEM_OPS,
    DOMAIN_ALIAS_RID_PRINT_OPS,
    DOMAIN_ALIAS_RID_BACKUP_OPS,
    DOMAIN_ALIAS_RID_ACCOUNT_OPS
    };

#define ADMINISTRATIVE_ALIAS_COUNT (sizeof(AdministrativeRids)/sizeof(ULONG))

#define RTLP_RXACT_KEY_NAME L"RXACT"
#define RTLP_RXACT_KEY_NAME_SIZE (sizeof(RTLP_RXACT_KEY_NAME) - sizeof(WCHAR))

#define SAMP_FIX_18471_KEY_NAME L"\\Registry\\Machine\\Security\\SAM\\Fix18471"
#define SAMP_FIX_18471_SHORT_KEY_NAME L"Fix18471"
#define SAMP_LSA_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




BOOLEAN
SampMatchDomainPrefix(
    IN PSID AccountSid,
    IN PSID DomainSid
    )

/*++

Routine Description:

    This function compares the domain sid to the domain prefix of an
    account sid.

Arguments:

    AccountSid - Specifies the account Sid to be compared. The Sid is assumed to be
        syntactically valid.

    DomainSid - Specifies the domain Sid to compare against.


Return Value:

    TRUE - The account Sid is from the Domain specified by the domain Sid

    FALSE - The domain prefix of the account Sid did not match the domain.

--*/

{
    //
    // Check if the account Sid has one more subauthority than the
    // domain Sid.
    //

    if (*RtlSubAuthorityCountSid(DomainSid) + 1 !=
        *RtlSubAuthorityCountSid(AccountSid)) {
        return(FALSE);
    }

    if (memcmp(
            RtlIdentifierAuthoritySid(DomainSid),
            RtlIdentifierAuthoritySid(AccountSid),
            sizeof(SID_IDENTIFIER_AUTHORITY) ) ) {

        return(FALSE);
    }

    //
    // Compare the sub authorities
    //

    if (memcmp(
            RtlSubAuthoritySid(DomainSid, 0) ,
            RtlSubAuthoritySid(AccountSid, 0) ,
            *RtlSubAuthorityCountSid(DomainSid)
            ))
    {
        return(FALSE);
    }

    return(TRUE);

}



NTSTATUS
SampCreate18471Key(
    )
/*++

Routine Description:

    This routine creates the 18471 key used to transaction this fix.

Arguments:


Return Value:

    Codes from the NT registry APIs

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;


    //
    // Open the 18471 key in the registry to see if an upgrade is in
    // progress
    //


    //
    // Start a transaction with to  create this key.
    //

    Status = SampAcquireWriteLock();

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Create the fix18471 key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME
        );

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyName,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    //
    // Commit this change
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );
    } else {
        (void) SampReleaseWriteLock( FALSE );
    }

    return(Status);
}

NTSTATUS
SampAddAliasTo18471Key(
    IN ULONG AliasRid
    )
/*++

Routine Description:

    This routine creates the 18471 key used to transaction this fix.

Arguments:


Return Value:

    Codes from the NT registry APIs

--*/
{
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;

    //
    // Build the key name.  It will be "fix18471\rid_in_hex"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );


    Status = SampAcquireWriteLock();

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Open the Lsa key in the registry
    //

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyNameString,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    //
    // Commit this change
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );

    } else {
        (void) SampReleaseWriteLock( FALSE );
    }

    return(Status);
}



NTSTATUS
SampAddMemberRidTo18471Key(
    IN ULONG AliasRid,
    IN ULONG MemberRid
    )
/*++

Routine Description:

    This routine adds a key for this member under the key for this alias
    to the current registry transaction.

Arguments:

    AliasRid - the rid of the alias

    MemberRid - The rid of the member of the alias

Returns:

    Errors from the RtlRXact APIs

--*/
{
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;


    //
    // Build the full key name.  It is of the form:
    // "fix18471\alias_rid\member_rid"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    wcscat(
        KeyName,
        L"\\"
        );

    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                MemberRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );

    //
    // Add this action to the RXact
    //

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyNameString,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    return(Status);

}

NTSTATUS
SampCheckMemberUpgradedFor18471(
    IN ULONG AliasRid,
    IN ULONG MemberRid
    )
/*++

Routine Description:

    This routine checks if the SAM upgrade flag is set. The upgrade
    flag is:

    HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\lsa
        UpgradeSam = REG_DWORD 1


Arguments:


Return Value:

    TRUE - The flag was set

    FALSE - The flag was not set or the value was not present

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;


    //
    // Build the full key name.  It is of the form:
    // "fix18471\alias_rid\member_rid"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    wcscat(
        KeyName,
        L"\\"
        );

    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                MemberRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );


    //
    // Open the member  key in the registry
    //


    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameString,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    Status = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    NtClose(KeyHandle);
    return(Status);

}

VOID
SampBuild18471CleanupKey(
    OUT PUNICODE_STRING KeyName,
    IN PWCHAR AliasName,
    IN ULONG AliasNameLength,
    IN PWCHAR MemberName,
    IN ULONG MemberNameLength
    )
/*++

Routine Description:

    Builds the key "Fix18471\alias_rid\member_rid"

Arguments:


Return Value:

    None

--*/
{
    PUCHAR Where = (PUCHAR) KeyName->Buffer;

    RtlCopyMemory(
        Where,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\",
        sizeof(SAMP_FIX_18471_SHORT_KEY_NAME)   // terminating NULL used for '\'
        );

    Where  += sizeof(SAMP_FIX_18471_SHORT_KEY_NAME);

    RtlCopyMemory(
        Where,
        AliasName,
        AliasNameLength
        );
    Where += AliasNameLength;

    //
    // If there is a member name to this alias, add it now.
    //

    if (MemberName != NULL) {
        RtlCopyMemory(
            Where,
            L"\\",
            sizeof(WCHAR)
            );
        Where += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            MemberName,
            MemberNameLength
            );
        Where += MemberNameLength;

    }

    KeyName->Length = (USHORT) (Where - (PUCHAR) KeyName->Buffer);
    ASSERT(KeyName->Length <= KeyName->MaximumLength);
}


NTSTATUS
SampCleanup18471(
    )
/*++

Routine Description:

    Cleans up the transaction log left by fixing bug 18471.  This routine
    builds a transaction with all the keys in the log and then commits
    the transaction

Arguments:

    None.

Return Value:

    Status codes from the NT registry APIs and NT RXact APIs

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE RootKey = NULL;
    HANDLE AliasKey = NULL;
    UCHAR Buffer[sizeof(KEY_BASIC_INFORMATION) + 15 * sizeof(WCHAR)];
    UCHAR Buffer2[sizeof(KEY_BASIC_INFORMATION) + 15 * sizeof(WCHAR)];
    UNICODE_STRING KeyName;
    WCHAR KeyBuffer[100];
    PKEY_BASIC_INFORMATION BasicInfo = (PKEY_BASIC_INFORMATION) Buffer;
    PKEY_BASIC_INFORMATION BasicInfo2 = (PKEY_BASIC_INFORMATION) Buffer2;
    ULONG BasicInfoLength;
    ULONG Index, Index2;

    //
    // Open the 18471 key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_KEY_NAME
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | DELETE), &ObjectAttributes, 0);

    Status = NtOpenKey(
                &RootKey,
                KEY_READ | DELETE,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(Status)) {

        //
        // If the error was that the key did not exist, then there
        // is nothing to cleanup, so return success.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            return(STATUS_SUCCESS);
        }
        return(Status);
    }

    //
    // Create a transaction to add all the keys to delete to
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Now enumerate all the subkeys of the root 18471 key
    //

    Index = 0;
    do
    {

        Status = NtEnumerateKey(
                    RootKey,
                    Index,
                    KeyBasicInformation,
                    BasicInfo,
                    sizeof(Buffer),
                    &BasicInfoLength
                    );

        SampDumpNtEnumerateKey(Index,
                               KeyBasicInformation,
                               BasicInfo,
                               sizeof(Buffer),
                               &BasicInfoLength);

        //
        //
        // Check if this is the RXACT key. If it is, we don't want
        // to add it to the delete log.
        //
        // Otherwise open this key and enumerate all the subkeys of it.
        //

        if (NT_SUCCESS(Status) &&
            ((BasicInfo->NameLength != RTLP_RXACT_KEY_NAME_SIZE) ||
                memcmp(
                    BasicInfo->Name,
                    RTLP_RXACT_KEY_NAME,
                    RTLP_RXACT_KEY_NAME_SIZE
                    ) ) ) {

            KeyName.Buffer = BasicInfo->Name;
            KeyName.Length = (USHORT) BasicInfo->NameLength;
            KeyName.MaximumLength = KeyName.Length;

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                RootKey,
                NULL
                );

            //
            // Open the key for the alias rid.  This really should
            // succeed
            //

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            Status = NtOpenKey(
                        &AliasKey,
                        KEY_READ,
                        &ObjectAttributes
                        );
            if (!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Enumerate all the subkeys (the alias members) and add them
            // to the transaction
            //

            Index2 = 0;
            do
            {
                Status = NtEnumerateKey(
                            AliasKey,
                            Index2,
                            KeyBasicInformation,
                            BasicInfo2,
                            sizeof(Buffer2),
                            &BasicInfoLength
                            );

                SampDumpNtEnumerateKey(Index2,
                                       KeyBasicInformation,
                                       BasicInfo2,
                                       sizeof(Buffer2),
                                       &BasicInfoLength);

                if (NT_SUCCESS(Status)) {

                    //
                    // Build the name of this key from the alias rid and the
                    // member rid
                    //

                    KeyName.Buffer = KeyBuffer;
                    KeyName.MaximumLength = sizeof(KeyBuffer);

                    SampBuild18471CleanupKey(
                        &KeyName,
                        BasicInfo->Name,
                        BasicInfo->NameLength,
                        BasicInfo2->Name,
                        BasicInfo2->NameLength
                        );

                    Status = RtlAddActionToRXact(
                                SampRXactContext,
                                RtlRXactOperationDelete,
                                &KeyName,
                                0,
                                NULL,
                                0
                                );


                }
                Index2++;

            } while (NT_SUCCESS(Status));

            NtClose(AliasKey);
            AliasKey = NULL;

            //
            // If we suffered a serious error, get out of here now
            //

            if (!NT_SUCCESS(Status)) {
                if (Status != STATUS_NO_MORE_ENTRIES) {
                    break;
                } else {
                    Status = STATUS_SUCCESS;
                }
            }

            //
            // Add the alias RID key to the RXact now - we need to add it
            // after deleting all the children
            //

            KeyName.Buffer = KeyBuffer;
            KeyName.MaximumLength = sizeof(KeyBuffer);
            SampBuild18471CleanupKey(
                &KeyName,
                BasicInfo->Name,
                BasicInfo->NameLength,
                NULL,
                0
                );


            Status = RtlAddActionToRXact(
                        SampRXactContext,
                        RtlRXactOperationDelete,
                        &KeyName,
                        0,
                        NULL,
                        0
                        );

        }

        Index++;
    } while (NT_SUCCESS(Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME
        );

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationDelete,
                &KeyName,
                0,
                NULL,
                0
                );

    if (NT_SUCCESS(Status)) {

        //
        // Write the new server revision to indicate that this
        // upgrade has been performed
        //

        SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;
        PSAMP_OBJECT ServerContext;

        //
        // We need to read the fixed attributes of the server objects.
        // Create a context to do that.
        //
        // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

        ServerContext = SampCreateContext( SampServerObjectType, 0, TRUE );

        if ( ServerContext != NULL ) {

            ServerContext->RootKey = SampKey;

            ServerFixedAttributes.RevisionLevel = SAMP_NT4_SERVER_REVISION;

            Status = SampSetFixedAttributes(
                        ServerContext,
                        &ServerFixedAttributes
                        );
            if (NT_SUCCESS(Status)) {
                Status = SampStoreObjectAttributes(
                            ServerContext,
                            TRUE
                            );
            }

            SampDeleteContext( ServerContext );
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    //
    // Apply the RXACT and delete the remaining keys.
    //

Cleanup:

    //
    // Cleanup any floating bits from above.
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );
    } else {
        (VOID) SampReleaseWriteLock( FALSE );
    }

    if (RootKey != NULL) {
        NtClose(RootKey);
    }

    ASSERT(AliasKey == NULL);


    return(Status);

}

NTSTATUS
SampFixBug18471 (
    IN ULONG Revision
    )
/*++

Routine Description:

    This routine fixes bug 18471, that SAM does not adjust the protection
    on groups that are members of administrative aliases in the builtin
    domain. It fixes this by opening a fixed set of known aliases
    (Administrators, Account Operators, Backup Operators, Print Operators,
    and Server Operators), and enumerating their members.  To fix this,
    we will remove all the members of these aliases (except the
    Administrator user account) and re-add them.

Arguments:

    Revision - Revision of the Sam server.

Return Value:


    Note:


--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               Index, Index2;
    PSID                BuiltinDomainSid = NULL;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    PSID                AccountDomainSid;
    ULONG               AccountDomainIndex = 0xffffffff;
    ULONG               BuiltinDomainIndex = 0xffffffff;
    SAMPR_PSID_ARRAY    AliasMembership;
    ULONG               MemberRid;
    ULONG               SdRevision;
    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG               SecurityDescriptorLength;
    SAMP_OBJECT_TYPE    MemberType;
    PSAMP_OBJECT        MemberContext;
    PSAMP_OBJECT        AliasContext;
    SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed;
    SAMP_V1_0A_FIXED_LENGTH_USER UserV1Fixed;

    //
    // Check the revision on the server to see if this upgrade has
    // already been performed.
    //


    if (Revision >= 0x10003) {

        //
        // This upgrade has already been performed.
        //

        goto Cleanup;
    }


    //
    // Build a the BuiltIn domain SID.
    //

    BuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));

    if ( BuiltinDomainSid == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid( BuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( BuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;


    //
    // Lookup the index of the account domain
    //

    for (Index = 0;
         Index < SampDefinedDomainsCount ;
         Index++ ) {

        if (RtlEqualSid( BuiltinDomainSid, SampDefinedDomains[Index].Sid)) {
            BuiltinDomainIndex = Index;
        } else {
            AccountDomainIndex = Index;
        }
    }

    ASSERT(AccountDomainIndex < SampDefinedDomainsCount);
    ASSERT(BuiltinDomainIndex < SampDefinedDomainsCount);

    AccountDomainSid = SampDefinedDomains[AccountDomainIndex].Sid;

    //
    // Create out transaction log
    //

    Status = SampCreate18471Key();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }




    //
    // Now loop through and open the aliases we are intersted in
    //

    for (Index = 0;
         Index < ADMINISTRATIVE_ALIAS_COUNT ;
         Index++ )
    {

        SampSetTransactionDomain( BuiltinDomainIndex );

        SampAcquireReadLock();

        Status = SampCreateAccountContext(
                    SampAliasObjectType,
                    AdministrativeRids[Index],
                    TRUE,                       // Trusted client
                    FALSE,
                    TRUE,                       // Account exists
                    &AliasContext
                    );

        if ( !NT_SUCCESS(Status) ) {

            SampReleaseReadLock();
            if (Status == STATUS_NO_SUCH_ALIAS) {
                Status = STATUS_SUCCESS;
                continue;
            } else {

                goto Cleanup;
            }
        }


        //
        // Get the members in the alias so we can remove and re-add them
        //

        Status = SampRetrieveAliasMembers(
                    AliasContext,
                    &(AliasMembership.Count),
                    (PSID **)&(AliasMembership.Sids)
                    );

        SampDeleteContext(AliasContext);
        SampReleaseReadLock();
        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Write that we are opening this alias to the log.  We don't need
        // to do this for administrators, since for them we the update is
        // idempotent.
        //

        if (AdministrativeRids[Index] != DOMAIN_ALIAS_RID_ADMINS) {
            Status = SampAddAliasTo18471Key(
                        AdministrativeRids[Index]
                        );
            if (!NT_SUCCESS(Status)) {
                break;
            }
        }


        //
        // Loop through the members and split each sid.  For every
        // member in the account domain , remove it and re-add it from
        // this alias.
        //




        for (Index2 = 0; Index2 < AliasMembership.Count ; Index2++ )
        {
            //
            // Check to see if this account is in the account domain
            //

            if ( SampMatchDomainPrefix(
                    (PSID) AliasMembership.Sids[Index2].SidPointer,
                    AccountDomainSid
                    ) )
            {

                //
                // Get the RID for this member
                //

                MemberRid = *RtlSubAuthoritySid(
                                AliasMembership.Sids[Index2].SidPointer,
                                *RtlSubAuthorityCountSid(
                                    AliasMembership.Sids[Index2].SidPointer
                                ) - 1
                                );

                //
                // Now remove and re-add the administratie nature of this
                // membership
                //

                if (AdministrativeRids[Index] == DOMAIN_ALIAS_RID_ADMINS) {

                    Status = SampAcquireWriteLock();
                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    SampSetTransactionDomain( AccountDomainIndex );

                    //
                    // Try to create a context for the account as a group.
                    //

                    Status = SampCreateAccountContext(
                                     SampGroupObjectType,
                                     MemberRid,
                                     TRUE, // Trusted client
                                     FALSE,
                                     TRUE, // Account exists
                                     &MemberContext
                                     );

                    if (!NT_SUCCESS( Status ) ) {

                        //
                        // If this ID does not exist as a group, that's fine -
                        // it might be a user or might have been deleted.
                        //

                        SampReleaseWriteLock( FALSE );
                        if (Status == STATUS_NO_SUCH_GROUP) {
                            Status = STATUS_SUCCESS;
                            continue;
                        }
                        break;
                    }

                    //
                    // Now set a flag in the group itself,
                    // so that when users are added and removed
                    // in the future it is known whether this
                    // group is in an ADMIN alias or not.
                    //

                    Status = SampRetrieveGroupV1Fixed(
                                   MemberContext,
                                   &GroupV1Fixed
                                   );

                    if ( NT_SUCCESS(Status)) {

                        GroupV1Fixed.AdminCount = 1;

                        Status = SampReplaceGroupV1Fixed(
                                    MemberContext,
                                    &GroupV1Fixed
                                    );
                        //
                        // Modify the security descriptor to
                        // prevent account operators from adding
                        // anybody to this group
                        //

                        if ( NT_SUCCESS( Status ) ) {

                            Status = SampGetAccessAttribute(
                                        MemberContext,
                                        SAMP_GROUP_SECURITY_DESCRIPTOR,
                                        FALSE, // don't make copy
                                        &SdRevision,
                                        &OldDescriptor
                                        );

                            if (NT_SUCCESS(Status)) {

                                Status = SampModifyAccountSecurity(
                                            MemberContext,
                                            SampGroupObjectType,
                                            TRUE, // this is an admin
                                            OldDescriptor,
                                            &SecurityDescriptor,
                                            &SecurityDescriptorLength
                                            );
                            }

                            if ( NT_SUCCESS( Status ) ) {

                                //
                                // Write the new security descriptor into the object
                                //

                                Status = SampSetAccessAttribute(
                                               MemberContext,
                                               SAMP_USER_SECURITY_DESCRIPTOR,
                                               SecurityDescriptor,
                                               SecurityDescriptorLength
                                               );

                                MIDL_user_free( SecurityDescriptor );
                            }



                        }
                        if (NT_SUCCESS(Status)) {

                            //
                            // Add the modified group to the current transaction
                            // Don't use the open key handle since we'll be deleting the context.
                            //

                            Status = SampStoreObjectAttributes(MemberContext, FALSE);

                        }

                    }

                    //
                    // Clean up the group context
                    //

                    SampDeleteContext(MemberContext);

                    //
                    // we don't want the modified count to change
                    //

                    SampSetTransactionWithinDomain(FALSE);

                    if (NT_SUCCESS(Status)) {
                        Status = SampReleaseWriteLock( TRUE );
                    } else {
                        (VOID) SampReleaseWriteLock( FALSE );
                    }

                }
                else
                {


                    //
                    // Check to see if we've already upgraded this member
                    //

                    Status = SampCheckMemberUpgradedFor18471(
                                AdministrativeRids[Index],
                                MemberRid);

                    if (NT_SUCCESS(Status)) {

                        //
                        // This member already was upgraded.
                        //

                        continue;
                    } else {

                        //
                        // We continue on with the upgrade
                        //

                        Status = STATUS_SUCCESS;
                    }

                    //
                    // Change the operator account for the other
                    // aliases.
                    //

                    if (NT_SUCCESS(Status)) {

                        Status = SampAcquireWriteLock();
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }

                        SampSetTransactionDomain( AccountDomainIndex );

                        Status = SampChangeAccountOperatorAccessToMember(
                                    AliasMembership.Sids[Index2].SidPointer,
                                    NoChange,
                                    AddToAdmin
                                    );

                        //
                        // If that succeeded, add this member to the log
                        // as one that was upgraded.
                        //

                        if (NT_SUCCESS(Status)) {
                            Status = SampAddMemberRidTo18471Key(
                                        AdministrativeRids[Index],
                                        MemberRid
                                        );

                        }

                        //
                        // We don't want the modified count to be updated so
                        // make this not a domain transaction
                        //

                        SampSetTransactionWithinDomain(FALSE);
                                                if (NT_SUCCESS(Status)) {
                            Status = SampReleaseWriteLock( TRUE );
                        } else {
                            (VOID) SampReleaseWriteLock( FALSE );
                        }

                    }

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                }
            }
        }

        SamIFree_SAMPR_PSID_ARRAY(
            &AliasMembership
            );
        AliasMembership.Sids = NULL;


        //
        // If something up above failed or the upgrade was already done,
        // exit now.
        //

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

Cleanup:

    if (BuiltinDomainSid != NULL) {
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            BuiltinDomainSid
            );
    }

    if (NT_SUCCESS(Status)) {
        Status = SampCleanup18471();
    }
    return(Status);
}


NTSTATUS
SampUpdateEncryption(
    IN SAMPR_HANDLE ServerHandle OPTIONAL
    )
/*++

    This routine walks the set of users and groups and updates the 
    encryption on them to reflect being syskey'd or a change of the
    password encryption key


    Parameter:

        ServerContext

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE DomainHandle = NULL;
    PSAMP_OBJECT UserObject = NULL;
    PSAMP_OBJECT ServerContext = NULL;
    SAMPR_HANDLE LocalServerHandle = NULL;
    SAM_ENUMERATE_HANDLE EnumerationContext = 0;
    PSAMPR_ENUMERATION_BUFFER EnumBuffer = NULL;
    ULONG CountReturned;
    BOOLEAN EnumerationDone = FALSE;
    ULONG PrivateDataLength;
    PVOID PrivateData = NULL;
    BOOLEAN LockHeld = FALSE;
    ULONG   DomainIndex,Index;

#define MAX_SAM_PREF_LENGTH 0xFFFF


    if (!ARGUMENT_PRESENT(ServerHandle))
    {
        Status = SamIConnect(
                    NULL,
                    &LocalServerHandle,
                    SAM_SERVER_ALL_ACCESS,
                    TRUE
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        ServerContext = (PSAMP_OBJECT) LocalServerHandle;
    }
    else
    {
        ServerContext = (PSAMP_OBJECT) ServerHandle;
    }

    Status = SamrOpenDomain(
                ServerContext,
                DOMAIN_LOOKUP |
                    DOMAIN_LIST_ACCOUNTS |
                    DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If we aren't supposed to super-encrypt the passwords than just return
    // success now before encrypting everything.
    //

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;
    if ((SampDefinedDomains[DomainIndex].UnmodifiedFixed.DomainKeyFlags &
        SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) == 0) {

       Status = STATUS_SUCCESS;
       goto Cleanup;
    }

    //
    // Now enumerate through all users and get/set their private data
    //

    while (!EnumerationDone) {

        Status = SamrEnumerateUsersInDomain(
                    DomainHandle,
                    &EnumerationContext,
                    0,                          // no UserAccountControl,
                    &EnumBuffer,
                    MAX_SAM_PREF_LENGTH,
                    &CountReturned
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
        if (Status != STATUS_MORE_ENTRIES) {

            EnumerationDone = TRUE;
        } else {
            ASSERT(CountReturned != 0);
        }
        ASSERT(CountReturned == EnumBuffer->EntriesRead);

        for (Index = 0; Index < CountReturned ; Index++ ) {

            //
            // Create an account context for each user to read the user off
            // the disk
            //

            Status = SampAcquireWriteLock();
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            LockHeld = TRUE;

            SampSetTransactionDomain( DomainIndex );

            Status = SampCreateAccountContext(
                        SampUserObjectType,
                        EnumBuffer->Buffer[Index].RelativeId,
                        TRUE, // Trusted client
                        FALSE,
                        TRUE, // Account exists
                        &UserObject
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampGetPrivateUserData(
                        UserObject,
                        &PrivateDataLength,
                        &PrivateData
                        );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampSetPrivateUserData(
                        UserObject,
                        PrivateDataLength,
                        PrivateData
                        );


            MIDL_user_free(PrivateData);
            PrivateData = NULL;

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampStoreObjectAttributes(
                        UserObject,
                        FALSE
                        );

            SampDeleteContext(UserObject);
            UserObject = NULL;
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // we don't want the modified count to change
            //

            SampSetTransactionWithinDomain(FALSE);

            Status = SampReleaseWriteLock( TRUE );
            LockHeld = FALSE;
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        }

        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumBuffer );
        EnumBuffer = NULL;
    }

Cleanup:

    //
    // If the lock is still held at this point, we must have failed so
    // release the lock and rollback the transaction
    //

    if (LockHeld) {
        ASSERT(!NT_SUCCESS(Status));
        SampReleaseWriteLock( FALSE );
        LockHeld = FALSE;
    }

    if (UserObject != NULL) {
        SampDeleteContext(UserObject);
    }

    if (DomainHandle != NULL) {
        SamrCloseHandle(&DomainHandle);
    }

    if (LocalServerHandle!=NULL ) {
        SamrCloseHandle(&LocalServerHandle);
    }
    
    if (EnumBuffer != NULL) {
        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumBuffer );

    }

    return(Status);
        
}
        



NTSTATUS
SampPerformSyskeyUpgrade(
    IN ULONG Revision,
    IN BOOLEAN UpdateEncryption
    )
/*++

Routine Description:

    If the revision is less than SAMP_WIN2k_REVISION this routine 
    will enumerate through
    all users and read their private data and then restored their private
    data. This will guarantee that it has been re-encrypted using a stronger
    encryption mechanism than just the RID.


Arguments:

    Revision - The revision stored in the Server fixed length attributes

Return Value:


    Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    ULONG Index;
    BOOLEAN LockHeld = FALSE;
    ULONG NewRevision = SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION;
    PSAMP_OBJECT ServerContext = NULL;
    ULONG        i;
    SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;


   
    //
    // If the change corresponding to the NT4 Sp3 Upgrade's
    // reencrypting secret data was made then don't need to 
    // upgrade again.
    //

    if (Revision >= NewRevision) {
        return(STATUS_SUCCESS);
    }

    //
    // w2k was syskey'd but did not contain space for the previous
    // key. So on upgrade from win2k just force a write to the
    // domain object to get the appropriate update
    //

    if (Revision==SAMP_WIN2K_REVISION) {
        UpdateEncryption = FALSE;
    }

    //
    // Force an upgrade to the domain object to the current revision
    // level by reading and writing back the fixed data. SAM normally
    // has logic to read multiple revisions, but the DS upgrader code only
    // has the capability to manipulate the latest revision, because it
    // bypasses the normal Sam attribute handling functions. Further we
    // know that only the domain object has changed from NT4 SP1 to NT4 SP3
    // and reading and flushing the domain object by hand again will cause
    // it to be in the latest revision format. Also note that all revisions
    // to other classes of objects ( groups, users etc) were made on or before
    // NT version 3.5. Since we need to support backward compatibility only
    // with 3.5.1 it is not necessary to modify the DS upgrader code. 
    //
   
    
    for (i=0;i<SampDefinedDomainsCount;i++)
    {
        PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
            V1aFixed;

        Status = SampAcquireWriteLock();
        if (!NT_SUCCESS(Status))
            goto Cleanup;

         LockHeld = TRUE;

        //
        // If the domain is hosted in the registry then 
        // perform the write. This is not applicable to DS domains
        // in DS mode, the safeboot hives will undergo this upgrade
        //

        if (!IsDsObject(SampDefinedDomains[i].Context))
        {
            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain(i);

            Status = SampGetFixedAttributes(
                        SampDefinedDomains[i].Context,
                        FALSE, // make copy
                        &V1aFixed);

            if (!NT_SUCCESS(Status))
                goto Cleanup;

            Status = SampSetFixedAttributes(
                        SampDefinedDomains[i].Context,
                        V1aFixed);

            if (!NT_SUCCESS(Status))
                goto Cleanup;

          
            Status = SampStoreObjectAttributes(
                        SampDefinedDomains[i].Context,
                        TRUE
                        );
            if (!NT_SUCCESS(Status))
                goto Cleanup;

            //
            // Decrement the serial number by 1 to compensate for
            // the increment in the commit
            //
       
            SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart-=1;
        }

        Status = SampReleaseWriteLock(TRUE);
        LockHeld = FALSE;
        if (!NT_SUCCESS(Status))
            goto Cleanup;
           
    }

    //
    // We can't use the normal connect API because SAM is still
    // initializing.
    //

    SampAcquireReadLock();

    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

    ServerContext = SampCreateContext(
                        SampServerObjectType,
                        0,
                        TRUE                   // TrustedClient
                        );

    if (ServerContext != NULL) {

        //
        // The RootKey for a SERVER object is the root of the SAM database.
        // This key should not be closed when the context is deleted.
        //

        ServerContext->RootKey = SampKey;
    } else {
        SampReleaseReadLock();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    
    SampReleaseReadLock();


    if (UpdateEncryption)
    {        
        Status = SampUpdateEncryption(
                        (SAMPR_HANDLE) ServerContext
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Now update the server object to indicate that the revision has
    // been updated.
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    LockHeld = TRUE;


    //
    // We need to read the fixed attributes of the server objects.
    // Create a context to do that.
    //


    ServerFixedAttributes.RevisionLevel = NewRevision;

    Status = SampSetFixedAttributes(
                ServerContext,
                &ServerFixedAttributes
                );

    if (NT_SUCCESS(Status)) {
        Status = SampStoreObjectAttributes(
                    ServerContext,
                    FALSE
                    );
    }

    SampDeleteContext( ServerContext );
    ServerContext = NULL;


    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampReleaseWriteLock( TRUE );
    LockHeld = FALSE;

Cleanup:


    //
    // We need to hold the lock while deleting this
    //

    if (ServerContext != NULL) {
        if (!LockHeld) {
            SampAcquireReadLock();
        }
        SampDeleteContext( ServerContext );
        if (!LockHeld) {
            SampReleaseReadLock();
        }
    }

    //
    // If the lock is still held at this point, we must have failed so
    // release the lock and rollback the transaction
    //

    if (LockHeld) {
        ASSERT(!NT_SUCCESS(Status));
        SampReleaseWriteLock( FALSE );
    }

    return(Status);
}

NTSTATUS
SampUpdateRevision(IN ULONG Revision )
{
    PSAMP_OBJECT ServerContext = NULL;
    BOOLEAN      fWriteLockAcquired = FALSE;
    NTSTATUS     Status = STATUS_SUCCESS;
    SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;

 
    //
    // Acquire the write lock
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status))
    {
       goto Cleanup;
    }

    fWriteLockAcquired = TRUE;

    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

    ServerContext = SampCreateContext(
                        SampServerObjectType,
                        0,
                        TRUE                   // TrustedClient
                        );

    if (ServerContext != NULL) {

        //
        // The RootKey for a SERVER object is the root of the SAM database.
        // This key should not be closed when the context is deleted.
        //

        ServerContext->RootKey = SampKey;
    } else {
        
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    ServerFixedAttributes.RevisionLevel = Revision;
    Status = SampSetFixedAttributes(
                ServerContext,
                &ServerFixedAttributes
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                ServerContext,
                FALSE
                );


Cleanup:

    if (NULL!=ServerContext)
    {
        SampDeleteContext( ServerContext );
        ServerContext = NULL;
    }


    if (fWriteLockAcquired)
    {
        Status = SampReleaseWriteLock( NT_SUCCESS(Status)?TRUE:FALSE );
    }


    return(Status);

}

NTSTATUS
SampUpgradeSamDatabase(
    IN ULONG Revision
    )
/*++

Routine Description:

    Upgrades the SAM database. This is the registry mode upgrade routine.

Arguments:

    Revision - The revision stored in the Server fixed length attributes

Return Value:


    Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  fUpgrade = FALSE;
    BOOLEAN  SampUseDsDataTmp;

    

    //
    // Set the upgrade flag so we can access SAM objects
    //

    SampUpgradeInProcess = TRUE;

    if (!SampUseDsData)
    {
        Status = SampFixBug18471(Revision);
    }

    if (NT_SUCCESS(Status)) 
    {

        
        BOOLEAN UpdateEncryption=TRUE;

        //
        // The following upgrade is performed for 2 reasons
        // 1. To create a field in the registry structure for the
        //    password encryption key if necessary
        //
        // 2. To update all accounts with new syskey encryption. In
        //    DS mode we perform this for the safe boot hives.
        //    Since a significant fraction of the SAM code forks off
        //    into DS path, based on the boolean SampUseDsData, therefore
        //    reset the global to false and then restore it to original value
        //    before and after the operation. This way we are assured of
        //    always accessing the registry.
        //
        // 3. The encryption is not updated in case this is a domain controller 
        //    as do not want the performance penalty of the walking 
        //    through all user accounts. Skipping the update occurs only if
        //    this is a domain controller going through GUI setup. The other
        //    case is a freshly DcPromo'd machine, in which case we update the
        //    encryption for the safeboot hives.
        //

        if ((SampProductType==NtProductLanManNt) && 
                 (SampIsSetupInProgress(&fUpgrade)) && fUpgrade)
        {
             UpdateEncryption = FALSE;
        }
        SampUseDsDataTmp = SampUseDsData;
        SampUseDsData = FALSE;
        Status = SampPerformSyskeyUpgrade(Revision,UpdateEncryption);
        SampUseDsData = SampUseDsDataTmp;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Upgrade the default user and group information if necessary.
        // This upgrade is done during GUI setup or on reboot after a
        // dcpromo. On domain controllers this
        // upgrade happens on the safeboot hives.
        //

        ULONG PromoteData;


        if ((SampIsRebootAfterPromotion(&PromoteData)) || (SampIsSetupInProgress(NULL))) {


            SampUseDsDataTmp = SampUseDsData;
            SampUseDsData = FALSE;

            //
            // Disable netlogon notifications if we are upgrading the safe boot hive
            //

            if (TRUE==SampUseDsDataTmp)
            {
               SampDisableNetlogonNotification = TRUE;
            }

            //
            // The database revision has been updated, so run through all the
            // groups for a possible upgrade
            //

            Status = SampPerformPromotePhase2(SAMP_PROMOTE_INTERNAL_UPGRADE);

            if (!NT_SUCCESS(Status)) {

                ASSERT( NT_SUCCESS(Status) );
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: New account creation failed with: 0x%x\n",
                           Status));

                //
                // Don't fail the install because of this
                //

                Status = STATUS_SUCCESS;
            }
            


            SampUseDsData = SampUseDsDataTmp;
            SampDisableNetlogonNotification = FALSE;

        }
    }

   

    return(Status);
}


NTSTATUS
SampDsProtectFPOContainer(
    PVOID p
    )
/*++

    Routine Description:

        For win2k installations that were installed prior to win2krtm, the 
        FPO container is not properly configured to rename safe etc.  
        This routine ensures that it is.

    Parameters:

        p -- unused

    Return Values:

        STATUS_SUCCESS, reschedules on error

--*/
{
    NTSTATUS    NtStatus;

    WCHAR           ContainerNameBuffer[]=L"ForeignSecurityPrincipals";
    UNICODE_STRING  ContainerName;
    DSNAME          *FpoContainer = NULL;
    BOOLEAN         fTransaction = FALSE;
    PVOID           pItem;


    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }
    fTransaction = TRUE;

    //
    // If there is already a well known container, stop now
    //
    NtStatus = SampDsGetWellKnownContainerDsName(RootObjectName,
                                                 (GUID*)&GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE,
                                                 &FpoContainer);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Nothing to do since the well known attribute reference exists
        //
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus)
     &&  (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus)  ) {
        //
        // This is a fatal error
        //
        goto Error;

    }
    NtStatus = STATUS_SUCCESS;
    THClearErrors();

    //
    // Create the DS Name
    //

    ContainerName.Length = sizeof(ContainerNameBuffer)-sizeof(WCHAR);
    ContainerName.MaximumLength = sizeof(ContainerNameBuffer)-sizeof(WCHAR);
    ContainerName.Buffer = ContainerNameBuffer;

    NtStatus = SampDsCreateDsName2(RootObjectName,&ContainerName,SAM_NO_LOOPBACK_NAME,&FpoContainer);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    pItem = LsaIRegisterNotification(
                    SampDsProtectSamObject,
                    FpoContainer,
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    300,        // wait for 5 minutes: 300 secound
                    NULL
                    );
    if (pItem) {
        // SampDsProtectSamObject will free the memory
        FpoContainer = NULL;            
    }

Error:


    if (fTransaction) {
        NTSTATUS Status2;
        Status2 = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                             TransactionCommit    : 
                                             TransactionAbort );

        // The transaction is only for read -- ok to ignore transaction
        // end status

    }

    if (!NT_SUCCESS(NtStatus)) {

        //
        // The only expected error is a resource failure -- reschedule.
        //

        LsaIRegisterNotification(
                        SampDsProtectFPOContainer,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        30,     // wait for 30 secs
                        NULL      // no handle
                        );


    }

    if (FpoContainer) {
        midl_user_free(FpoContainer);
    }


    return STATUS_SUCCESS;

}


//
// from ridmgr.c
//
BOOL
SampNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    );

VOID
SampNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    );

//
// See Whistler Specification "UpgradeManagement" for names
//
#define SAMP_SYSTEM_CN          L"System"
#define SAMP_OPERATIONS_CN      L"Operations"
#define SAMP_DOMAIN_UPDATES_CN  L"DomainUpdates"

NTSTATUS
SampUpgradeGetObjectSDByDsName(
    IN PDSNAME pObjectDsName,
    OUT PSECURITY_DESCRIPTOR *ppSD
    )
/*++

Routine Description:

    This routine reads DS, get security descriptor of this object

Parameter:

    pObjectDsName - object ds name

    ppSD -- pointer to hold security descriptor

Return Value:

    NtStatus Code

--*/
{
    ULONG Size;

    return SampDsReadSingleAttribute(pObjectDsName,
                                     ATT_NT_SECURITY_DESCRIPTOR,
                                     ppSD,
                                    &Size);

}

NTSTATUS
SampGetConfigurationNameHelper(
    IN DSCONFIGNAME Name,
    OUT DSNAME **DsName
    )

//
// Small allocation wrapper using midl_user_allocate around
// GetConfiguarationName
//
{
    NTSTATUS Status = STATUS_SUCCESS;        
    ULONG Length = 0;

    Status = GetConfigurationName(
                Name,
                &Length,
                NULL
                );

    if (STATUS_BUFFER_TOO_SMALL == Status) {

        *DsName = midl_user_allocate(Length);
        if (NULL != *DsName) {

            Status = GetConfigurationName(Name,
                                         &Length,
                                         *DsName);
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;

}

NTSTATUS
SampGetOperationDn(
    IN DSNAME *OperationsContainerDn, OPTIONAL
    IN WCHAR* Task, OPTIONAL
    OUT DSNAME** OperationDn
    )
/*++

Routine Description:

    This routine returns the DN of the CN=Operations,CN=DomainUpdates,CN=System
    ... DN if OperationsContainerDn is NULL.  Otherwise it returns the DN
    of the task ( CN=<guid>,CN=Operations,CN=DomainUpdates,CN=System...)

    
Arguments:

    OperationsContainerDn -- the operations contains DN, if present
    
    Task -- the stringized GUID of the task
    
    OperationDn -- the requested DN

Return Value:

    STATUS_SUCCESS, resource error otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    Length;
    DWORD    err;
    DSNAME  *DomainObject = NULL;
    ULONG    SizeOfCommonName =  (sizeof(L"CN=,")/sizeof(WCHAR));

    if (OperationsContainerDn) {

        ASSERT(NULL != Task);

        //
        // Simple case -- given the CN=Operations,CN=... DN, return
        // task object
        //
        Length = (ULONG)DSNameSizeFromLen(OperationsContainerDn->NameLen + 
                                          wcslen(Task) + 
                                          SizeOfCommonName); 
    
        (*OperationDn) = midl_user_allocate(Length);
        if (NULL == (*OperationDn)) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Exit;
        }
        err = AppendRDN(OperationsContainerDn,
                        (*OperationDn),
                        Length,
                        Task,
                        0,
                        ATT_COMMON_NAME);
        ASSERT(0 == err);

    } else {

        //
        // Return the CN=Operations,CN=DomainUpdates,CN=System,CN= ... DN
        // 
        PDSNAME SystemObject = NULL,
                UpdateObject = NULL, 
                OperationsObject = NULL;

        Status = SampGetConfigurationNameHelper(DSCONFIGNAME_DOMAIN,
                                                &DomainObject);
        if ( !NT_SUCCESS(Status) ) {
            goto Exit;
        }

        Length = (ULONG)DSNameSizeFromLen( DomainObject->NameLen + 
                                           wcslen(SAMP_SYSTEM_CN) +
                                           SizeOfCommonName);
        SAMP_ALLOCA(SystemObject,Length);
        if (NULL == SystemObject) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Exit;
        }
        err = AppendRDN(DomainObject,
                        SystemObject,
                        Length,
                        SAMP_SYSTEM_CN,
                        0,
                        ATT_COMMON_NAME);
        ASSERT(0 == err);
    
        Length = (ULONG)DSNameSizeFromLen( SystemObject->NameLen + 
                                           wcslen(SAMP_DOMAIN_UPDATES_CN) +
                                           SizeOfCommonName);
        SAMP_ALLOCA(UpdateObject,Length);
        if (NULL == UpdateObject) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Exit;
        }
        err = AppendRDN(SystemObject,
                        UpdateObject,
                        Length,
                        SAMP_DOMAIN_UPDATES_CN,
                        0,
                        ATT_COMMON_NAME);
        ASSERT(0 == err);
    
        Length = (ULONG)DSNameSizeFromLen( UpdateObject->NameLen + 
                                           wcslen(SAMP_OPERATIONS_CN) +
                                           SizeOfCommonName);
    
        (*OperationDn) = midl_user_allocate(Length);
        if (NULL == (*OperationDn)) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Exit;
        }
        err = AppendRDN(UpdateObject,
                        (*OperationDn),
                        Length, 
                        SAMP_OPERATIONS_CN,
                        0,
                        ATT_COMMON_NAME);
        ASSERT(0 == err);
    }

Exit:

    if (DomainObject) {
        midl_user_free(DomainObject);
    }

    return Status;
}



NTSTATUS
SampHasChangeBeenApplied(
    IN  DSNAME   *TaskDn,
    OUT BOOLEAN *pfChangeApplied
    )
/*++

Routine Description:

    This routine checks for the existence of the task, TaskDn.
    If the object exists, *pfChangeApplied is TRUE, FALSE otherwise.

Arguments:

    TaskDn -- the task ID object to look for
    
    pfChangeApplied -- set to TRUE if object exists

Return Value:

    STATUS_SUCCESS, resource error otherwise

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;


    *pfChangeApplied = FALSE;

    //
    // Check for existence.  Every object has a security descriptor.
    //
    Status = SampUpgradeGetObjectSDByDsName(TaskDn,
                                            &pSD);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Object not there, ok return success and that change hasn't been
        // done.
        //
        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS(Status)) {

        //
        // The object was found -- nothing to do
        //
        *pfChangeApplied = TRUE;
    }

    if (pSD) {
        midl_user_free(pSD);
    }

    return Status;
}


//
// This task indicates that all computer objects in the domain have been
// properly ACL'ed and that SAM no longer needs to grant the "effective"
// owner of computer objects extra rights in order for netjoin and
// computer rename to work.
//
#define SAMP_COMPUTER_OBJECT_ACCESS  L"7FFEF925-405B-440A-8D58-35E8CD6E98C3"

struct {

    WCHAR*   TaskId;
    BOOLEAN *GlobalFlag;
} SampDomainUpgradeTasks [] =
{
    {SAMP_COMPUTER_OBJECT_ACCESS, &SampComputerObjectACLApplied},
    {SAMP_WIN2K_TO_WS03_UPGRADE,  &SampWS03DefaultsApplied},
};

NTSTATUS
SampCheckForDomainChanges(
    IN DSNAME *OperationsDn,
    OUT BOOLEAN *fReady
    )
/*++

Routine Description:

    This routine determines if all the ACL changes for necessary for bug 16386 have been applied to the 
    domain.  

Arguments:

    OperationsDn -- the DN of the operations container
    
    fReady -- set to TRUE if all necessary task objects are present, otherwise FALSE              

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    //
    // Init the out parameter
    //
    *fReady = TRUE;

    for (i = 0; i < RTL_NUMBER_OF(SampDomainUpgradeTasks); i++) {

        DSNAME *TaskDn = NULL;

        //
        // Determine the DN of the operation
        //

        Status = SampGetOperationDn(OperationsDn,
                                    SampDomainUpgradeTasks[i].TaskId,
                                   &TaskDn);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }

        //
        // See if it has been applied
        //

        Status = SampHasChangeBeenApplied(TaskDn,
                                          SampDomainUpgradeTasks[i].GlobalFlag);
        midl_user_free(TaskDn);
        TaskDn = NULL;

        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }

        if (!(*SampDomainUpgradeTasks[i].GlobalFlag)) {

            // A required task is not ready -- make a note to reschedule
            *fReady = FALSE;
        }
    }

Exit:

    return Status;
}

NTSTATUS
SampProcessOperationsDn(
    PVOID p
    )
/*++

Routine Description:

    This routine is called when the "Operations" container changes.  Its purpose is to determine
    if certain domain wide tasks have been completed (and if so, set appropriate global state)

Arguments:

    p -- the hServer provided by DirNotifyRegister callback
    
Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME *OperationsDn = NULL;
    BOOLEAN fTransaction = FALSE;
    BOOLEAN fRequiredTasksDone;
    ULONG hServer = PtrToUlong(p);

    //
    // Get the "Operation" DN
    //
    Status = SampGetOperationDn(NULL,
                                NULL,
                                &OperationsDn);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Start a DS transaction
    //
    Status = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    fTransaction = TRUE;


    //
    // Check the state of the objects
    //
    Status = SampCheckForDomainChanges(OperationsDn,
                                      &fRequiredTasksDone);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (fRequiredTasksDone) {

        NOTIFYRES *pNotifyRes = NULL;


        //
        // We don't need to be notified anymore
        //

        DirNotifyUnRegister(hServer,
                            &pNotifyRes);
    }

Exit:

    if (fTransaction) {
        (VOID)  SampMaybeEndDsTransaction( NT_SUCCESS(Status) ?
                                             TransactionCommit :
                                             TransactionAbort );
    }

    if (OperationsDn) {
        midl_user_free(OperationsDn);
    }

    return STATUS_SUCCESS;

}

VOID
SampNotifyProcessOperationsDn(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    This routine is callback for the "Operations" container changes.  It simply registers
    another callback (that will run in a different thread) to read the operation container
    and process the change.
    
Arguments:

    hClient - client identifier

    hServer - server identifier

    EntInf  - pointer to entry info

Return Value:

    None.

--*/
{
    LsaIRegisterNotification(
            SampProcessOperationsDn,
            ULongToPtr(hServer),
            NOTIFIER_TYPE_INTERVAL,
            0,        // no class
            NOTIFIER_FLAG_ONE_SHOT,
            0,        // go!
            NULL      // no handle
            );
}

NTSTATUS
SampCheckDomainUpdates(
    PVOID pv
    )
/*++

Routine Description:

    This routine applies any fixes to the domain necessary for a service pack.
    It is data driven off of the global array SampDomainUpgradeTasks.
    
    All tasks are recorded by creating an object in the 
    
    CN=Operations,CN=DomainUpdates,CN=System container.  See
    UpgradeManagement.doc for details.
    
    On failure, it reschedules to run in one minutes.  The failure that
    is expected is a resource failure.

Arguments:

    pv -- unused.

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  fTransaction = FALSE;
    ULONG    i;
    DSNAME   *OperationsDn = NULL;
    BOOLEAN  fRequiredTasksDone = FALSE;

    //
    // Get the "Operation" DN
    //
    Status = SampGetOperationDn(NULL,
                                NULL,
                                &OperationsDn);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Start a DS transaction
    //
    Status = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    fTransaction = TRUE;

    Status = SampCheckForDomainChanges(OperationsDn,
                                      &fRequiredTasksDone);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (!fRequiredTasksDone) {

        //
        // We are not ready to perform new access check, setup a notification on OperationsDn 
        // so that we alerted when the domain could be ready 
        //
        ULONG       DirError = 0;
        SEARCHARG   searchArg;
        NOTIFYARG   notifyArg;
        NOTIFYRES*  notifyRes = NULL;
        ENTINFSEL   entInfSel;
        ATTR        attr;
        FILTER      filter;
    
        //
        // init notify arg
        //
        notifyArg.pfPrepareForImpersonate = SampNotifyPrepareToImpersonate;
        notifyArg.pfTransmitData = SampNotifyProcessOperationsDn;
        notifyArg.pfStopImpersonating = SampNotifyStopImpersonation;
        notifyArg.hClient = 0;
    
        //
        // init search arg
        //
        ZeroMemory(&searchArg, sizeof(SEARCHARG));
        ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
        ZeroMemory(&filter, sizeof(FILTER));
        ZeroMemory(&attr, sizeof(ATTR));
    
        searchArg.pObject = OperationsDn;
    
        InitCommarg(&searchArg.CommArg);
        searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        searchArg.bOneNC = TRUE;
    
        searchArg.pSelection = &entInfSel;
        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
        entInfSel.AttrTypBlock.attrCount = 1;
        entInfSel.AttrTypBlock.pAttr = &attr;
        attr.attrTyp = ATT_OBJECT_CLASS;
    
        searchArg.pFilter = &filter;
        filter.choice = FILTER_CHOICE_ITEM;
        filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;
    
        DirError = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);
    
        if (NULL==notifyRes) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
           Status = SampMapDsErrorToNTStatus(DirError,&notifyRes->CommRes);
        }
    }

    //
    // Done
    //

Exit:

    if (fTransaction) {
        NTSTATUS Status2;

        Status2 = SampMaybeEndDsTransaction( NT_SUCCESS(Status) ?
                                             TransactionCommit :
                                             TransactionAbort );
        if (NT_SUCCESS(Status)) {
            Status = Status2;
        }
    }

    if (OperationsDn) {
        midl_user_free(OperationsDn);
    }


    if (!NT_SUCCESS(Status)) {

        //
        // Try again
        //
        LsaIRegisterNotification(
                SampCheckDomainUpdates,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                60,       // wait for a min
                NULL      // no handle
                );

    }

    return STATUS_SUCCESS;
}



NTSTATUS 
SampUpgradeMakeObject(
    IN  DSNAME   *ObjectName
    )
/*++

Routine Description:

    This routine adds a container object with the DN "ObjectName"

Arguments:

    ObjectName -- the full DN of the desired object

Return Value:

    STATUS_SUCCESS, a resource error otherwise.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    ULONG     err = 0;
    ADDARG    AddArg = {0};
    ADDRES   *AddRes = NULL;
    ULONG     ObjectClass = CLASS_CONTAINER;
    ATTRBLOCK ObjectClassBlock = {0};
    ATTRVAL   ObjectClassVal = {sizeof(ULONG), (PUCHAR)&ObjectClass};

    //
    // Build the request; note the pAttr can be re'alloc'ed by the core
    // so needs to be THAlloc'ed here.
    //
    ObjectClassBlock.attrCount = 1;
    ObjectClassBlock.pAttr = THAlloc(sizeof(ATTR));
    if (NULL == ObjectClassBlock.pAttr) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    ObjectClassBlock.pAttr->attrTyp = ATT_OBJECT_CLASS;
    ObjectClassBlock.pAttr->AttrVal.valCount = 1;
    ObjectClassBlock.pAttr->AttrVal.pAVal = &ObjectClassVal;

    AddArg.pObject = ObjectName;
    AddArg.AttrBlock = ObjectClassBlock;
    BuildStdCommArg(&AddArg.CommArg);

    //
    // Add the object
    //
    err = DirAddEntry(&AddArg, &AddRes);
    if (NULL== AddRes) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        Status = SampMapDsErrorToNTStatus(err,&AddRes->CommRes);
    }
    SampClearErrors();

Exit:

    return Status;
}


NTSTATUS
SampMarkChangeApplied(
    IN LPWSTR OperationalGuid
    )
/*++

Routine Description:

    This routine is called when the "Operations" container changes.  Its purpose is to determine
    if certain domain wide tasks have been completed (and if so, set appropriate global state)

Arguments:

    p -- the hServer provided by DirNotifyRegister callback
    
Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME *OperationsDn = NULL;
    DSNAME *TaskDn = NULL;
    BOOLEAN fTransaction = FALSE;

    //
    // Get the "Operation" DN
    //
    Status = SampGetOperationDn(NULL,
                                NULL,
                                &OperationsDn);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = SampGetOperationDn(OperationsDn,
                                OperationalGuid,
                               &TaskDn);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Make the object
    //
    Status = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    fTransaction = TRUE;

    Status = SampUpgradeMakeObject(TaskDn);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

Exit:

    if (fTransaction) {
        NTSTATUS Status2;

        Status2 = SampMaybeEndDsTransaction( NT_SUCCESS(Status) ?
                                             TransactionCommit :
                                             TransactionAbort );
        if (NT_SUCCESS(Status)) {
            Status = Status2;
        }
    }

    if (OperationsDn) {
        midl_user_free(OperationsDn);
    }

    if (TaskDn) {
        midl_user_free(TaskDn);
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\user.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    user.c

Abstract:

    This file contains services related to the SAM "user" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    10-Oct-1996 ChrisMay
        Added SamIOpenUserByAlternateId for new security packages.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <lmcons.h>
#include <nturtl.h>
#include <ntlsa.h>              // need for nlrepl.h
#include <nlrepl.h>             // I_NetNotifyMachineAccount prototype
#include <msaudite.h>
#include <rc4.h>                // rc4_key(), rc4()
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>             // ATT_*
#include <dslayer.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <lmaccess.h>
#include <malloc.h>
#include <samtrace.h>
#include <dnsapi.h>
#include <cryptdll.h>
#include <notify.h>
#include <md5.h>
#include <safeboot.h>
#include <rng.h>
#include "validate.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LARGE_INTEGER
SampGetPasswordMustChange(
    IN ULONG UserAccountControl,
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );


NTSTATUS
SampStorePasswordExpired(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN PasswordExpired
    );


NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    );

NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );

NTSTATUS
SampReplaceUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN ULONG MembershipCount,
    IN PGROUP_MEMBERSHIP Membership
    );

NTSTATUS
SampRetrieveUserLogonHours(
    IN PSAMP_OBJECT Context,
    OUT PLOGON_HOURS LogonHours
    );


NTSTATUS
SampDeleteUserKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampCheckPasswordHistory(
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength,
    IN ULONG HistoryAttributeIndex,
    IN PSAMP_OBJECT Context,
    IN BOOLEAN CheckHistory,
    OUT PUNICODE_STRING OwfHistoryBuffer
    );

NTSTATUS
SampAddPasswordHistory(
    IN PSAMP_OBJECT Context,
    IN ULONG HistoryAttributeIndex,
    IN PUNICODE_STRING NtOwfHistoryBuffer,
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength
    );

NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    );

USHORT
SampQueryBadPasswordCount(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    );

VOID
SampUpdateAccountLockedOutFlag(
    PSAMP_OBJECT Context,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    PBOOLEAN IsLocked
    );

NTSTATUS
SampCheckForAccountLockout(
    IN PSAMP_OBJECT AccountContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN BOOLEAN  V1aFixedRetrieved
    );

PVOID
DSAlloc(
    IN ULONG Length
    );


NTSTATUS
SampEnforceDefaultMachinePassword(
    PSAMP_OBJECT AccountContext,
    PUNICODE_STRING NewPassword,
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo
    );


NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION  PasswordChangeFailureInfo OPTIONAL
    );

PWSTR
SampLocalStringToken(
    PWSTR    String,
    PWSTR    Token,
    PWSTR    * NextStringStart
    );


NTSTATUS
SampSetPasswordUpdateOnContext(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING ClearPassword
    );

NTSTATUS
SampObtainEffectivePasswordPolicyWithDomainIndex(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   );

NTSTATUS
SampDsUpdateLastLogonTimeStamp(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER LastLogon,
    IN ULONG SyncInterval
    );


VOID
SampGetRequestedAttributesForUser(
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN ULONG WhichFields,
    OUT PRTL_BITMAP AttributeAccessTable
    );

NTSTATUS
SampValidatePresentAndStoredCombination(
    IN BOOLEAN NtPresent,
    IN BOOLEAN LmPresent,
    IN BOOLEAN StoredNtPasswordPresent,
    IN BOOLEAN StoredNtPasswordNonNull,
    IN BOOLEAN StoredLmPasswordNonNull
    );


NTSTATUS
SampCopyA2D2Attribute(
    IN PUSER_ALLOWED_TO_DELEGATE_TO_LIST Src,
    OUT PUSER_ALLOWED_TO_DELEGATE_TO_LIST *Dest
    );

NTSTATUS
SampRestrictAndRandomizeKrbtgtPassword(
    IN PSAMP_OBJECT        AccountContext,
    IN OUT PUNICODE_STRING ClearTextPassword,
    IN OUT PNT_OWF_PASSWORD NtOwf,
    IN OUT PLM_OWF_PASSWORD LmOwf,
    OUT BOOLEAN * LmPresent,
    OUT PUNICODE_STRING     UpdatedClearPassword,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType
    );

NTSTATUS
SampObtainLockoutInfoWithDomainIndex(
   OUT PDOMAIN_LOCKOUT_INFORMATION LockoutInformation,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   );

VOID
SampQueueReplicationRequest(
    IN GUID *Guid
    );

DWORD
SampProcessReplicationRequest(
    PVOID p // unused
    );
   



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamrOpenUser(
        IN SAMPR_HANDLE DomainHandle,
        IN ACCESS_MASK DesiredAccess,
        IN ULONG UserId,
        OUT SAMPR_HANDLE *UserHandle
    )


/*++

    This API opens an existing user  in the account database.  The user
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the user  must be
    declared at this time.

    This call returns a handle to the newly opened user  that may be
    used for successive operations on the user.   This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.   These access types are reconciled
        with the Discretionary Access Control list of the user  to
        determine whether the accesses will be granted or denied.

    UserId -  Specifies the relative ID value of the user  to be
        opened.

    UserHandle -  Receives a handle referencing the newly opened
        user.   This handle will be required in successive calls to
        operate on the user.

Return Values:

    STATUS_SUCCESS - The user  was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_USER  - The specified user  does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE    FoundType;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT) DomainHandle;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenUser
                   );


    NtStatus = SampOpenAccount(
                   SampUserObjectType,
                   DomainHandle,
                   DesiredAccess,
                   UserId,
                   FALSE,
                   UserHandle
                   );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Don't check Domain Password Policy read access for loopback client
        // Because for loopback client, we have already checked the
        // DOMAIN_READ_PASSWORD_PARAMETERS access when we opened the DomainHandle
        // if password change operation is detected.
        //

        if ( DomainContext->TrustedClient || DomainContext->LoopbackClient )
        {
            ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = TRUE;
        }
        else
        {
            //
            // If the domain handle allows reading the password
            // parameters, note that in the context to make life
            // easy for SampGetUserDomainPasswordInformation().
            //
            if (RtlAreAllAccessesGranted( DomainContext->GrantedAccess, DOMAIN_READ_PASSWORD_PARAMETERS))
            {
                ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = TRUE;
            }
            else
            {
                ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = FALSE;
            }

        }
    }


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenUser
                   );

    return(NtStatus);
}


NTSTATUS
SamrDeleteUser(
    IN OUT SAMPR_HANDLE *UserHandle
    )


/*++

Routine Description:

    This API deletes a user from the account database.  If the account
    being deleted is the last account in the database in the ADMIN
    group, then STATUS_LAST_ADMIN is returned, and the Delete fails.

    Note that following this call, the UserHandle is no longer valid.

Parameters:

    UserHandle - The handle of an opened user to operate on.  The handle must be
        openned for DELETE access.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_LAST_ADMIN - Cannot delete the last enabled administrator account

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    UNICODE_STRING              UserName;
    NTSTATUS                    NtStatus, IgnoreStatus, TmpStatus;
    PSAMP_OBJECT                AccountContext = (PSAMP_OBJECT)(*UserHandle);
    PSAMP_DEFINED_DOMAINS       Domain = NULL;
    SAMP_OBJECT_TYPE            FoundType;
    PSID                        AccountSid = NULL;
    PGROUP_MEMBERSHIP           Groups = NULL;
    ULONG                       ObjectRid,
                                GroupCount,
                                DomainIndex,
                                i;
    BOOLEAN                     fLockAcquired = FALSE;

    DECLARE_CLIENT_REVISION(*UserHandle);


    SAMTRACE_EX("SamrDeleteUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteUser
                   );


    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //
    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {


        ObjectRid = AccountContext->TypeBody.User.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // built-in accounts can't be deleted, unless the caller is trusted
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( ObjectRid );
        }


        if (!IsDsObject(AccountContext))
        {

            //
            // Get the list of groups this user is a member of.
            // Remove the user from each group. Need not do this
            // for DS Case
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampRetrieveUserMembership(
                               AccountContext,
                               FALSE, // Make copy
                               &GroupCount,
                               &Groups
                               );


                if (NT_SUCCESS(NtStatus)) {

                    ASSERT( GroupCount >  0);
                    ASSERT( Groups != NULL );


                    //
                    // Remove the user from each group.
                    //

                    for ( i=0; i<GroupCount && NT_SUCCESS(NtStatus); i++) {

                        NtStatus = SampRemoveUserFromGroup(
                                       AccountContext,
                                       Groups[i].RelativeId,
                                       ObjectRid
                                       );
                    }
                }
            }

            //
            // So far, so good.  The user has been removed from all groups.
            // Now remove the user from all aliases
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampCreateAccountSid(AccountContext, &AccountSid);

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampRemoveAccountFromAllAliases(
                                   AccountSid,
                                   NULL,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
                }
            }
        }

        //
        // Get the AccountControl flags for when we update
        // the display cache, and to let Netlogon know if this
        // is a machine account that is going away.
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );
        }

        //
        // Now we just need to clean up the user keys themselves.
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // First get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE,    // Make copy
                           &UserName
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // This must be done before we invalidate contexts, because our
                // own handle to the group gets closed as well.
                //

                if (IsDsObject(AccountContext))
                {
                    NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                  0     // delete object itself only
                                                  );

                    //
                    // In Windows 2000 (NT5), an object has children cannot be
                    // deleted till its children are deleted first. Thus for
                    // Net API compatibility, we have to change the
                    // delete behavior from a delete object to delete tree.
                    //

                    if ((!AccountContext->LoopbackClient) &&
                        (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                       )
                    {
                        //
                        // We only checked the right and access control for
                        // deleting the object itself, not check the right to
                        // delete all the children underneath, so turn off fDSA
                        // here, let core DS do the rest of check.
                        //

                        SampSetDsa(FALSE);

                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                      SAM_DELETE_TREE
                                                      );
                    }


                    if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                    {
                        //
                        // Decrement the group count
                        //

                        NtStatus = SampAdjustAccountCount(SampUserObjectType, FALSE );
                    }

                }
                else
                {
                    NtStatus = SampDeleteUserKeys( AccountContext );
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // We must invalidate any open contexts to this user.
                    // This will close all handles to the user's keys.
                    // THIS IS AN IRREVERSIBLE PROCESS.
                    //

                    SampInvalidateObjectContexts( AccountContext, ObjectRid );

                    //
                    // Commit the whole mess
                    //

                    NtStatus = SampCommitAndRetainWriteLock();

                    if ( NT_SUCCESS( NtStatus ) ) {

                        SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                        //
                        // Update the cached Alias Information in Registry Mode
                        // in DS mode, Alias Information is updated through
                        // SampNotifyReplicatedInChange
                        //

                        if (!IsDsObject(AccountContext))
                        {
                            IgnoreStatus = SampAlRemoveAccountFromAllAliases(
                                               AccountSid,
                                               FALSE,
                                               NULL,
                                               NULL,
                                               NULL
                                               );

                            //
                            // Update the display information
                            //

                            AccountInfo.Name = UserName;
                            AccountInfo.Rid = ObjectRid;
                            AccountInfo.AccountControl = V1aFixed.UserAccountControl;
                            RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                            RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                            IgnoreStatus = SampUpdateDisplayInformation(
                                                            &AccountInfo,
                                                            NULL,
                                                            SampUserObjectType
                                                            );
                            ASSERT(NT_SUCCESS(IgnoreStatus));
                        }



                        //
                        // Audit the deletion before we free the write lock
                        // so that we have access to the context block.
                        //

                        //
                        // N.B. Deletion audits in the DS are performed in
                        // the notification routine on transaction commit.
                        //
                        if (SampDoAccountAuditing(DomainIndex) &&
                            (!IsDsObject(AccountContext)) &&
                            NT_SUCCESS(NtStatus) ) {

                            SampAuditUserDelete(DomainIndex,
                                                &UserName,
                                                &ObjectRid,
                                                V1aFixed.UserAccountControl
                                                );
                        }

                        //
                        // Notify netlogon of the change
                        //

                        SampNotifyNetlogonOfDelta(
                            SecurityDbDelete,
                            SecurityDbObjectSamUser,
                            ObjectRid,
                            &UserName,
                            (DWORD) FALSE,  // Replicate immediately
                            NULL            // Delta data
                            );

                        //
                        // Do delete auditing
                        //

                        if (NT_SUCCESS(NtStatus)) {

                            SampDeleteObjectAuditAlarm(AccountContext);
                        }
                    }
                }

                SampFreeUnicodeString( &UserName );
            }
        }

        //
        // De-reference the object, discarding changes, and delete the context
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the user, delete the context and
            // let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*UserHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //
    //
    //

    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    //
    // If necessary, free the AccountSid.
    //

    if (AccountSid != NULL) {

        MIDL_user_free(AccountSid);
        AccountSid = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteUser
                   );

    return(NtStatus);
}


NTSTATUS
SamrQueryInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )
{
    //
    // This is a thin veil to SamrQueryInformationUser2().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //

    return( SamrQueryInformationUser2(UserHandle, UserInformationClass, Buffer ) );
}


NTSTATUS
SamrQueryInformationUser2(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    User object QUERY information routine.

Arguments:

    UserHandle - RPC context handle for an open user object.

    UserInformationClass - Type of information being queried.

    Buffer - To receive the output (queried) information.


Return Value:


    STATUS_INVALID_INFO_CLASS - An unknown information class was requested.
        No information has been returned.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        return(the requested information in.


--*/
{
    NTSTATUS    NtStatus;
    ULONG       WhichFields;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrQueryInformationUser2");


    WhichFields = USER_ALL_READ_GENERAL_MASK         |
                              USER_ALL_READ_LOGON_MASK           |
                              USER_ALL_READ_ACCOUNT_MASK         |
                              USER_ALL_READ_PREFERENCES_MASK     |
                              USER_ALL_READ_TRUSTED_MASK;

    NtStatus = SampQueryInformationUserInternal(
                    UserHandle,
                    UserInformationClass,
                    FALSE,
                    WhichFields,
                    0,
                    Buffer
                    );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return NtStatus;
}

NTSTATUS
SampQueryInformationUserInternal(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN BOOLEAN  LockHeld,
    IN ULONG    FieldsForUserAllInformation,
    IN ULONG    ExtendedFieldsForUserInternal6Information,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )
/*++

Routine Description:

    Internal User object QUERY information routine.

Arguments:

    UserHandle - RPC context handle for an open user object.

    UserInformationClass - Type of information being queried.

    Buffer - To receive the output (queried) information.


Return Value:


    STATUS_INVALID_INFO_CLASS - An unknown information class was requested.
        No information has been returned.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        return(the requested information in.


--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    PUSER_ALL_INFORMATION   All;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i, WhichFields = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 NoErrorsYet;
    LM_OWF_PASSWORD         LmOwfPassword;
    NT_OWF_PASSWORD         NtOwfPassword;
    BOOLEAN                 NtPasswordNonNull, LmPasswordNonNull;
    BOOLEAN                 NtPasswordPresent;

    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[64];
    ULONG                   AllocatedBufferCount = 0;
    LARGE_INTEGER           TempTime;
    BOOLEAN                 LockAcquired = FALSE;

    SAMTRACE("SampQueryInformationUserInternal");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationUser
                   );


    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
            if (NULL!=NewBuffer)                                        \
                RtlSecureZeroMemory(NewBuffer,Size);                          \
        }                                                               \



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }


    //
    // Set the desired access based upon information class.
    //
    switch (UserInformationClass) {

    case UserInternal3Information:
    case UserAllInformation:
    case UserInternal6Information:

        //
        // For trusted clients, we will return everything.  For
        // others, we will return everything that they have access to.
        // In either case, we'll have to look at some variables in the
        // context so we'll do the work after the SampLookupContext()
        // below.
        //

        DesiredAccess = 0;
        break;

    case UserAccountInformation:

        DesiredAccess = (USER_READ_GENERAL      |
                        USER_READ_PREFERENCES   |
                        USER_READ_LOGON         |
                        USER_READ_ACCOUNT);
        break;

    case UserGeneralInformation:
    case UserPrimaryGroupInformation:
    case UserNameInformation:
    case UserAccountNameInformation:
    case UserFullNameInformation:
    case UserAdminCommentInformation:

        DesiredAccess = USER_READ_GENERAL;
        break;


    case UserPreferencesInformation:

        DesiredAccess = (USER_READ_PREFERENCES |
                        USER_READ_GENERAL);
        break;


    case UserLogonInformation:

        DesiredAccess = (USER_READ_GENERAL      |
                        USER_READ_PREFERENCES   |
                        USER_READ_LOGON         |
                        USER_READ_ACCOUNT);
        break;

    case UserLogonHoursInformation:
    case UserHomeInformation:
    case UserScriptInformation:
    case UserProfileInformation:
    case UserWorkStationsInformation:

        DesiredAccess = USER_READ_LOGON;
        break;


    case UserControlInformation:
    case UserExpiresInformation:
    case UserParametersInformation:

        DesiredAccess = USER_READ_ACCOUNT;
        break;



    case UserInternal1Information:
    case UserInternal2Information:

        //
        // These levels are only queryable by trusted clients.  The code
        // below will check AccountContext->TrustedClient after calling
        // SampLookupContext, and only return the data if it is TRUE.
        //

        DesiredAccess = (ACCESS_MASK)0;    // Trusted client; no need to verify
        break;


    case UserSetPasswordInformation:        // Can't query password
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto Error;

    } // end_switch




    //
    // Allocate the info structure
    //

    switch (UserInformationClass)
    {
    case UserInternal6Information:
        AllocateBuffer(*Buffer,sizeof(USER_INTERNAL6_INFORMATION));
        break;
    default:
        AllocateBuffer(*Buffer, sizeof(SAMPR_USER_INFO_BUFFER) );
    }

    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }




    AccountContext = (PSAMP_OBJECT)UserHandle;

    //
    // Acquire the Read lock if required
    //

    if (!LockHeld)
    {
        SampMaybeAcquireReadLock(AccountContext,
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &LockAcquired);
    }

    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                    AccountContext,
                    DesiredAccess,
                    SampUserObjectType,           // ExpectedType
                    &FoundType
                    );


    if ((STATUS_ACCESS_DENIED==NtStatus)
        && (UserParametersInformation==UserInformationClass)
        && (IsDsObject(AccountContext))
        && ( AccountContext->TypeBody.User.UparmsInformationAccessible))
    {

        //
        // In DS mode if we are asking for user parms, check if the saved access ck
        // indicates that we have access to that then allow the read to proceed
        //

         NtStatus = SampLookupContext(
                        AccountContext,
                        0,
                        SampUserObjectType,           // ExpectedType
                        &FoundType
                        );
    }




    if (NT_SUCCESS(NtStatus)) {

        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.
        //

        switch (UserInformationClass) {

        case UserInternal3Information:
        case UserInternal6Information:
            //
            // Only trusted clients may query for this class.
            //

            if ( !AccountContext->TrustedClient ) {
                NtStatus = STATUS_INVALID_INFO_CLASS;
                break;
            }

            //
            // Drop through to the UserAll case
            //

        case UserAllInformation: {

            //
            // We weren't able to check the security stuff above, so do
            // it now.
            //

            if ( AccountContext->TrustedClient ) {

                //
                // Give everything to trusted clients, except fields that
                // can't be queried at all.
                //

                if ( 0==FieldsForUserAllInformation)
                {
                     WhichFields = USER_ALL_READ_GENERAL_MASK |
                                   USER_ALL_READ_LOGON_MASK |
                                   USER_ALL_READ_ACCOUNT_MASK |
                                   USER_ALL_READ_PREFERENCES_MASK |
                                   USER_ALL_READ_TRUSTED_MASK;
                }
                else
                {

                     WhichFields = FieldsForUserAllInformation;
                }

            } else {


                //
                // Only return fields that the caller has access to.
                //

                WhichFields = 0;

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_GENERAL ) ) {

                    WhichFields |= USER_ALL_READ_GENERAL_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_LOGON ) ) {

                    WhichFields |= USER_ALL_READ_LOGON_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_ACCOUNT ) ) {

                    WhichFields |= USER_ALL_READ_ACCOUNT_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_PREFERENCES ) ) {

                    WhichFields |= USER_ALL_READ_PREFERENCES_MASK;
                }

                if ( WhichFields == 0 ) {

                    //
                    // Caller doesn't have access to ANY fields.
                    //

                    NtStatus = STATUS_ACCESS_DENIED;
                    break;
                }
            }
        }

        //
        // fall through to pick up the V1aFixed information
        //

        case UserGeneralInformation:
        case UserPrimaryGroupInformation:
        case UserPreferencesInformation:
        case UserLogonInformation:
        case UserAccountInformation:
        case UserControlInformation:
        case UserExpiresInformation:
        case UserInternal2Information:

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );


            break;

        default:

            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            PUSER_INTERNAL6_INFORMATION Internal6 = NULL;

            //
            // case on the type information requested
            //

            switch (UserInformationClass) {

            case UserInternal6Information:

                 Internal6 = (PUSER_INTERNAL6_INFORMATION) (*Buffer);


                 if ((ExtendedFieldsForUserInternal6Information &
                            USER_EXTENDED_FIELD_A2D2 ) &&
                     (NULL!=AccountContext->TypeBody.User.A2D2List))

                 {
                     if (!AccountContext->TypeBody.User.A2D2Present)
                     {
                         NtStatus = STATUS_INVALID_PARAMETER;
                         break;
                     }

                     NtStatus = SampCopyA2D2Attribute(
                                    AccountContext->TypeBody.User.A2D2List,
                                    &Internal6->A2D2List
                                    );

                     if (NT_SUCCESS(NtStatus)){
                         RegisterBuffer(Internal6->A2D2List);
                         Internal6->ExtendedFields |= USER_EXTENDED_FIELD_A2D2;
                     }
                 }

                 if ((NT_SUCCESS(NtStatus)) &&
                     (ExtendedFieldsForUserInternal6Information &
                            USER_EXTENDED_FIELD_SPN ) &&
                     (NULL!=AccountContext->TypeBody.User.SPNList))

                 {
                     if (!AccountContext->TypeBody.User.SPNPresent)
                     {
                         NtStatus = STATUS_INVALID_PARAMETER;
                         break;
                     }

                     NtStatus = SampCopyA2D2Attribute(
                                    AccountContext->TypeBody.User.SPNList,
                                    &Internal6->RegisteredSPNs
                                    );

                     if (NT_SUCCESS(NtStatus)){
                         RegisterBuffer(Internal6->RegisteredSPNs);
                         Internal6->ExtendedFields |= USER_EXTENDED_FIELD_SPN;
                     }
                 }

                 if ((NT_SUCCESS(NtStatus)) &&
                    (ExtendedFieldsForUserInternal6Information
                                        & USER_EXTENDED_FIELD_UPN ))
                 {
                    NtStatus = SampDuplicateUnicodeString(
                                    &AccountContext->TypeBody.User.UPN,
                                    &Internal6->UPN
                                    );

                     if (NT_SUCCESS(NtStatus)){
                         RegisterBuffer(Internal6->UPN.Buffer);
                         Internal6->ExtendedFields |= USER_EXTENDED_FIELD_UPN;
                         Internal6->UPNDefaulted =  AccountContext->TypeBody.User.UpnDefaulted;
                     }
                 }

                 if ((NT_SUCCESS(NtStatus)) &&
                     (ExtendedFieldsForUserInternal6Information
                                        & USER_EXTENDED_FIELD_KVNO ))
                 {
                     if (!AccountContext->TypeBody.User.KVNOPresent)
                     {
                         NtStatus = STATUS_INVALID_PARAMETER;
                         break;
                     }

                     Internal6->ExtendedFields |= USER_EXTENDED_FIELD_KVNO;
                     Internal6->KeyVersionNumber = AccountContext->TypeBody.User.KVNO;
                 }


                 if ((NT_SUCCESS(NtStatus)) &&
                     (ExtendedFieldsForUserInternal6Information
                                        & USER_EXTENDED_FIELD_LOCKOUT_THRESHOLD ))
                 {
                     Internal6->ExtendedFields |= USER_EXTENDED_FIELD_LOCKOUT_THRESHOLD;
                     Internal6->LockoutThreshold =
                        SampDefinedDomains[AccountContext->DomainIndex].UnmodifiedFixed.LockoutThreshold;
                 }

            case UserInternal3Information:
            case UserAllInformation:


                //
                // All and Internal3 are the same except Internal3 has
                // an extra field. Internal6 is the same as internal 3
                // information, except that it has more extra fields.
                //

                All = (PUSER_ALL_INFORMATION)(*Buffer);

                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                if ((NT_SUCCESS(NtStatus)) &&
                    (WhichFields & ( USER_ALL_PASSWORDMUSTCHANGE |
                     USER_ALL_NTPASSWORDPRESENT )) ) {

                    //
                    // These fields will need some info from
                    // SampRetrieveUserPasswords().
                    //

                    NtStatus = SampRetrieveUserPasswords(
                                    AccountContext,
                                    &LmOwfPassword,
                                    &LmPasswordNonNull,
                                    &NtOwfPassword,
                                    &NtPasswordPresent,
                                    &NtPasswordNonNull
                                    );
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERNAME ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->All.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->UserName.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_FULLNAME ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->FullName.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERID ) ) {

                    All->UserId = V1aFixed.UserId;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PRIMARYGROUPID ) ) {

                    All->PrimaryGroupId = V1aFixed.PrimaryGroupId;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_ADMINCOMMENT ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->AdminComment)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->AdminComment.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERCOMMENT ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->UserComment) // Body
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->UserComment.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_HOMEDIRECTORY ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->HomeDirectory.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_HOMEDIRECTORYDRIVE ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->HomeDirectoryDrive.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_SCRIPTPATH ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->ScriptPath.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PROFILEPATH ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->ProfilePath.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_WORKSTATIONS ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->WorkStations.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LASTLOGON ) ) {

                    All->LastLogon = V1aFixed.LastLogon;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LASTLOGOFF ) ) {

                    All->LastLogoff = V1aFixed.LastLogoff;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LOGONHOURS ) ) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&(All->LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if (All->LogonHours.LogonHours != NULL) {

                            RegisterBuffer(All->LogonHours.LogonHours);
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_BADPASSWORDCOUNT ) ) {

                    All->BadPasswordCount = SampQueryBadPasswordCount( AccountContext, &V1aFixed );

                    if (UserInformationClass == UserInternal3Information) {
                        (*Buffer)->Internal3.LastBadPasswordTime = V1aFixed.LastBadPasswordTime;
                    }

                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LOGONCOUNT ) ) {

                    All->LogonCount = V1aFixed.LogonCount;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDCANCHANGE ) ) {

                    if ( !NtPasswordNonNull && !LmPasswordNonNull ) {

                        //
                        // Null passwords can be changed immediately.
                        //

                        All->PasswordCanChange = SampHasNeverTime;

                    } else {

                        All->PasswordCanChange = SampAddDeltaTime(
                                                     V1aFixed.PasswordLastSet,
                                                     Domain->UnmodifiedFixed.MinPasswordAge);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields &
                     (USER_ALL_PASSWORDMUSTCHANGE|USER_ALL_PASSWORDEXPIRED) ) ) {

                    All->PasswordMustChange = SampGetPasswordMustChange(
                                                  V1aFixed.UserAccountControl,
                                                  V1aFixed.PasswordLastSet,
                                                  Domain->UnmodifiedFixed.MaxPasswordAge);
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDEXPIRED ) ) {

                    LARGE_INTEGER TimeNow;

                    NtStatus = NtQuerySystemTime( &TimeNow );
                    if (NT_SUCCESS(NtStatus)) {
                        if ( TimeNow.QuadPart >= All->PasswordMustChange.QuadPart) {

                            All->PasswordExpired = TRUE;

                        } else {

                            All->PasswordExpired = FALSE;
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDLASTSET ) ) {

                    All->PasswordLastSet = V1aFixed.PasswordLastSet;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_ACCOUNTEXPIRES ) ) {

                    All->AccountExpires = V1aFixed.AccountExpires;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERACCOUNTCONTROL ) ) {

                    All->UserAccountControl = V1aFixed.UserAccountControl;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PARAMETERS ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PARAMETERS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->Parameters)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->Parameters.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_COUNTRYCODE ) ) {

                    All->CountryCode = V1aFixed.CountryCode;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_CODEPAGE ) ) {

                    All->CodePage = V1aFixed.CodePage;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_NTPASSWORDPRESENT ) ) {

                    ASSERT( WhichFields & USER_ALL_LMPASSWORDPRESENT);

                    All->LmPasswordPresent = LmPasswordNonNull;
                    All->NtPasswordPresent = NtPasswordNonNull;

                    RtlInitUnicodeString(&All->LmPassword, NULL);
                    RtlInitUnicodeString(&All->NtPassword, NULL);

                    if ( LmPasswordNonNull ) {

                        All->LmPassword.Buffer =
                            MIDL_user_allocate( LM_OWF_PASSWORD_LENGTH );

                        if ( All->LmPassword.Buffer == NULL ) {

                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            RegisterBuffer(All->LmPassword.Buffer);

                            All->LmPassword.Length = LM_OWF_PASSWORD_LENGTH;
                            All->LmPassword.MaximumLength =
                                LM_OWF_PASSWORD_LENGTH;
                            RtlCopyMemory(
                                All->LmPassword.Buffer,
                                &LmOwfPassword,
                                LM_OWF_PASSWORD_LENGTH
                                );
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        if ( NtPasswordPresent ) {

                            All->NtPassword.Buffer =
                                MIDL_user_allocate( NT_OWF_PASSWORD_LENGTH );

                            if ( All->NtPassword.Buffer == NULL ) {

                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                            } else {

                                RegisterBuffer(All->NtPassword.Buffer);

                                All->NtPassword.Length = NT_OWF_PASSWORD_LENGTH;
                                All->NtPassword.MaximumLength =
                                    NT_OWF_PASSWORD_LENGTH;
                                RtlCopyMemory(
                                    All->NtPassword.Buffer,
                                    &NtOwfPassword,
                                    NT_OWF_PASSWORD_LENGTH
                                    );
                            }
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PRIVATEDATA ) ) {

                    All->PrivateDataSensitive = TRUE;

                    NtStatus = SampGetPrivateUserData(
                                   AccountContext,
                                   (PULONG)
                                   (&(All->PrivateData.Length)),
                                   (PVOID *)
                                   (&(All->PrivateData.Buffer))
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        All->PrivateData.MaximumLength =
                            All->PrivateData.Length;

                        RegisterBuffer(All->PrivateData.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_SECURITYDESCRIPTOR ) ) {

                    NtStatus = SampGetObjectSD(
                                   AccountContext,
                                   &(All->SecurityDescriptor.Length),
                                   (PSECURITY_DESCRIPTOR *)
                                   &(All->SecurityDescriptor.SecurityDescriptor)
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        if ((IsDsObject(AccountContext)) &&
                            (!( ( AccountContext->TrustedClient ) &&
                                ( UserAllInformation == UserInformationClass ||
                                  UserInternal6Information == UserInformationClass ))))
                        {
                            //
                            // For a DS object downgrade the security descrriptor
                            // to NT4. Do not do so for the Logon Case ( Trusted
                            // Client Asking for UserAllInformation). NT4 Replication
                            // uses UserInternal3Information, so we are OK in throwing
                            // in this performance hack. This is an important
                            // performance optimization, because security descriptor
                            // conversion is a slow process.
                            //

                            PSID                    SelfSid;
                            PSECURITY_DESCRIPTOR    Nt5SD =
                                All->SecurityDescriptor.SecurityDescriptor;


                            All->SecurityDescriptor.SecurityDescriptor = NULL;

                            //
                            // Get the Self Sid
                            //

                            if (AccountContext->ObjectNameInDs->SidLen>0)
                                SelfSid = &(AccountContext->ObjectNameInDs->Sid);
                            else
                                SelfSid = SampDsGetObjectSid(
                                                AccountContext->ObjectNameInDs);

                            if (NULL!=SelfSid)
                            {


                                NtStatus = SampConvertNt5SdToNt4SD(
                                                Nt5SD,
                                                AccountContext,
                                                SelfSid,
                                                &All->SecurityDescriptor.SecurityDescriptor
                                                );

                                if (NT_SUCCESS(NtStatus))
                                {

                                    //
                                    // Free the original security descriptor
                                    //

                                    MIDL_user_free(Nt5SD);
                                    Nt5SD = NULL;

                                    //
                                    // Compute length of new NT4 Security Descriptor
                                    //

                                    All->SecurityDescriptor.Length =
                                        GetSecurityDescriptorLength(
                                            All->SecurityDescriptor.SecurityDescriptor
                                            );

                                    RegisterBuffer(All->SecurityDescriptor.SecurityDescriptor);
                

                                }
                            }
                            else
                            {
                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            }

                            if (Nt5SD) {
                                MIDL_user_free(Nt5SD);
                            }
                        }
                        else
                        {
                            RegisterBuffer(All->SecurityDescriptor.SecurityDescriptor);
                        }


                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    All->WhichFields = WhichFields;
                }

                break;

            case UserAccountInformation:

                NoErrorsYet = TRUE;


                (*Buffer)->Account.UserId           = V1aFixed.UserId;
                (*Buffer)->Account.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                (*Buffer)->Account.LastLogon =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                (*Buffer)->Account.LastLogoff =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);


                (*Buffer)->Account.BadPasswordCount = SampQueryBadPasswordCount( AccountContext, &V1aFixed );
                (*Buffer)->Account.LogonCount       = V1aFixed.LogonCount;

                (*Buffer)->Account.PasswordLastSet =
                    *((POLD_LARGE_INTEGER)&V1aFixed.PasswordLastSet);

                (*Buffer)->Account.AccountExpires =
                    *((POLD_LARGE_INTEGER)&V1aFixed.AccountExpires);

                (*Buffer)->Account.UserAccountControl = V1aFixed.UserAccountControl;


                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.UserName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.FullName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.ScriptPath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.ProfilePath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->Account.AdminComment) // Body
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->Account.AdminComment.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.WorkStations.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }




                //
                // Now get the logon hours
                //


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&((*Buffer)->Account.LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if ((*Buffer)->Account.LogonHours.LogonHours != NULL) {

                            RegisterBuffer((*Buffer)->Account.LogonHours.LogonHours);
                        }

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserGeneralInformation:


                (*Buffer)->General.PrimaryGroupId   = V1aFixed.PrimaryGroupId;



                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->General.UserName)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->General.UserName.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->General.FullName.Buffer);

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->General.AdminComment) // Body
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->General.AdminComment.Buffer);

                            NtStatus = SampGetUnicodeStringAttribute(
                                           AccountContext,
                                           SAMP_USER_USER_COMMENT,
                                           TRUE, // Make copy
                                           (PUNICODE_STRING)&((*Buffer)->General.UserComment) // Body
                                           );
                            if (NT_SUCCESS(NtStatus)) {

                                RegisterBuffer((*Buffer)->General.UserComment.Buffer);
                            }
                        }
                    }
                }


                break;


            case UserNameInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Name.UserName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Name.UserName.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Name.FullName) // Body
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Name.FullName.Buffer);
                    }
                }


                break;


            case UserAccountNameInformation:

                //
                // Get copy of the string we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AccountName.UserName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AccountName.UserName.Buffer);
                }


                break;


            case UserFullNameInformation:

                //
                // Get copy of the string we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_FULL_NAME,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->FullName.FullName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->FullName.FullName.Buffer);
                }


                break;


            case UserAdminCommentInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ADMIN_COMMENT,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
                }


                break;


            case UserPrimaryGroupInformation:


                (*Buffer)->PrimaryGroup.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                break;


            case UserPreferencesInformation:


                (*Buffer)->Preferences.CountryCode  = V1aFixed.CountryCode;
                (*Buffer)->Preferences.CodePage     = V1aFixed.CodePage;



                //
                // Read the UserComment field from the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_USER_COMMENT,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Preferences.UserComment) // Body
                               );
                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Preferences.UserComment.Buffer);

                    //
                    // This field isn't used, but make sure RPC doesn't
                    // choke on it.
                    //

                    (*Buffer)->Preferences.Reserved1.Length = 0;
                    (*Buffer)->Preferences.Reserved1.MaximumLength = 0;
                    (*Buffer)->Preferences.Reserved1.Buffer = NULL;
                }


                break;


            case UserParametersInformation:


                //
                // Read the Parameters field from the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PARAMETERS,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Parameters.Parameters)
                               );
                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Parameters.Parameters.Buffer);
                }


                break;


            case UserLogonInformation:

                NoErrorsYet = TRUE;

                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                (*Buffer)->Logon.UserId           = V1aFixed.UserId;
                (*Buffer)->Logon.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                (*Buffer)->Logon.LastLogon =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                (*Buffer)->Logon.LastLogoff =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);

                (*Buffer)->Logon.BadPasswordCount = V1aFixed.BadPasswordCount;

                (*Buffer)->Logon.PasswordLastSet =
                    *((POLD_LARGE_INTEGER)&V1aFixed.PasswordLastSet);

                TempTime = SampAddDeltaTime(
                                V1aFixed.PasswordLastSet,
                                Domain->UnmodifiedFixed.MinPasswordAge );

                (*Buffer)->Logon.PasswordCanChange =
                    *((POLD_LARGE_INTEGER)&TempTime);


                TempTime = SampGetPasswordMustChange(
                                V1aFixed.UserAccountControl,
                                V1aFixed.PasswordLastSet,
                                Domain->UnmodifiedFixed.MaxPasswordAge);

                (*Buffer)->Logon.PasswordMustChange =
                    *((POLD_LARGE_INTEGER)&TempTime);


                (*Buffer)->Logon.LogonCount       = V1aFixed.LogonCount;
                (*Buffer)->Logon.UserAccountControl = V1aFixed.UserAccountControl;


                //
                // If there is no password on the account then
                // modify the password can/must change times
                // so that the password never expires and can
                // be changed immediately.
                //

                NtStatus = SampRetrieveUserPasswords(
                                AccountContext,
                                &LmOwfPassword,
                                &LmPasswordNonNull,
                                &NtOwfPassword,
                                &NtPasswordPresent,
                                &NtPasswordNonNull
                                );

                if (NT_SUCCESS(NtStatus)) {

                    if ( !NtPasswordNonNull && !LmPasswordNonNull ) {

                        //
                        // The password is NULL.
                        // It can be changed immediately.
                        //

                        (*Buffer)->Logon.PasswordCanChange =
                            *((POLD_LARGE_INTEGER)&SampHasNeverTime);

                    }
                } else {
                    NoErrorsYet = FALSE;
                }


                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.UserName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.FullName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.ScriptPath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.ProfilePath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.WorkStations.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }




                //
                // Now get the logon hours
                //


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&((*Buffer)->Logon.LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if ((*Buffer)->Logon.LogonHours.LogonHours != NULL) {

                            RegisterBuffer((*Buffer)->Logon.LogonHours.LogonHours);
                        }

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserLogonHoursInformation:

                NtStatus = SampRetrieveUserLogonHours(
                               AccountContext,
                               (PLOGON_HOURS)&((*Buffer)->LogonHours.LogonHours)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    if ((*Buffer)->LogonHours.LogonHours.LogonHours != NULL) {

                        RegisterBuffer((*Buffer)->LogonHours.LogonHours.LogonHours);
                    }
                }

                break;


            case UserHomeInformation:

                NoErrorsYet = TRUE;

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {


                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Home.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Home.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Home.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Home.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserScriptInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_SCRIPT_PATH,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Script.ScriptPath)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Script.ScriptPath.Buffer);
                }

                break;


            case UserProfileInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PROFILE_PATH,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Profile.ProfilePath)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Profile.ProfilePath.Buffer);
                }

                break;


            case UserWorkStationsInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_WORKSTATIONS,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->WorkStations.WorkStations)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->WorkStations.WorkStations.Buffer);
                }

                break;


            case UserControlInformation:

                (*Buffer)->Control.UserAccountControl     = V1aFixed.UserAccountControl;
                break;


            case UserExpiresInformation:

                (*Buffer)->Expires.AccountExpires     = V1aFixed.AccountExpires;

                break;


            case UserInternal1Information:

                if ( AccountContext->TrustedClient ) {

                    //
                    // PasswordExpired is a 'write only' flag.
                    // We always return FALSE on read.
                    //

                    (*Buffer)->Internal1.PasswordExpired = FALSE;

                    //
                    // Retrieve the OWF passwords.
                    // Since this is a trusted client, we don't need to
                    // reencrypt the OWFpasswords we return - so we stuff
                    // the OWFs into the structure that holds encryptedOWFs.
                    //

                    ASSERT( ENCRYPTED_LM_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH );
                    ASSERT( ENCRYPTED_NT_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH );

                    NtStatus = SampRetrieveUserPasswords(
                                    AccountContext,
                                    (PLM_OWF_PASSWORD)&(*Buffer)->Internal1.
                                            EncryptedLmOwfPassword,
                                    &(*Buffer)->Internal1.
                                            LmPasswordPresent,
                                    (PNT_OWF_PASSWORD)&(*Buffer)->Internal1.
                                            EncryptedNtOwfPassword,
                                    &NtPasswordPresent,
                                    &(*Buffer)->Internal1.NtPasswordPresent // Return the Non-NULL flag here
                                    );

                } else {

                    //
                    // This information is only queryable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;


            case UserInternal2Information:

                if ( AccountContext->TrustedClient ) {

                    (*Buffer)->Internal2.LastLogon =
                        *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                    (*Buffer)->Internal2.LastLogoff =
                        *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);

                    (*Buffer)->Internal2.BadPasswordCount  = V1aFixed.BadPasswordCount;
                    (*Buffer)->Internal2.LogonCount        = V1aFixed.LogonCount;

                } else {

                    //
                    // This information is only queryable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;

            }

        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //


    if (!LockHeld)
    {
        SampMaybeReleaseReadLock(LockAcquired);
    }



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationUser
                   );

    return(NtStatus);

}


NTSTATUS
SampIsUserAccountControlValid(
    IN PSAMP_OBJECT Context,
    IN ULONG UserAccountControl
    )

/*++

Routine Description:

    This routine checks a UserAccountControl field to make sure that
    the bits set make sense.

    NOTE: if the set operation is also setting passwords, it must set the
    passwords BEFORE calling this routine!


Parameters:

    Context - the context of the account being changed.

    UserAccountControl - the field that is about to be set.


Return Values:

    STATUS_SUCCESS - The UserAccountControl field is valid.

    STATUS_SPECIAL_ACCOUNT - The administrator account can't be disabled.

    STATUS_INVALID_PARAMETER - an undefined bit is set, or more than one
        account type bit is set.

    STATUS_INVALID_PARAMETER_MIX - USER_PASSWORD_NOT_REQUIRED has been
        turned off, but there isn't a bonafide password on the account.

--*/

{
    NTSTATUS  NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampIsUserAccountControlValid");



    //
    // Make sure that undefined bits aren't set.
    //

    if ( ( UserAccountControl & ~(NEXT_FREE_ACCOUNT_CONTROL_BIT - 1) ) != 0 ) {

        DbgPrint("SAM: Setting undefined AccountControl flag(s): 0x%lx for user %d\n",
                 UserAccountControl, Context->TypeBody.User.Rid);

        return (STATUS_INVALID_PARAMETER);
    }


     //
     // Make sure that the krbtgt account is'nt enabled
     //

     if (!( UserAccountControl & USER_ACCOUNT_DISABLED )) {

         if ( Context->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT ) {

             return( STATUS_SPECIAL_ACCOUNT );
         }
     }

     //
     // Don't allow the restore mode administrator account to be
     // disabled
     //

     if ((UserAccountControl & USER_ACCOUNT_DISABLED ) &&
         (Context->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN) &&
         (LsaISafeMode()))
     {
         return( STATUS_SPECIAL_ACCOUNT);
     }



    //
    // Make sure that exactly one of the account type bits is set.
    //

    switch ( UserAccountControl & USER_ACCOUNT_TYPE_MASK ) {


        case USER_NORMAL_ACCOUNT:
        case USER_SERVER_TRUST_ACCOUNT:
        case USER_WORKSTATION_TRUST_ACCOUNT:
        case USER_INTERDOMAIN_TRUST_ACCOUNT:

            break;


        case USER_TEMP_DUPLICATE_ACCOUNT:

            //
            // Temp duplicate accounts were a concept in Lan Manager
            // that has outlived its usefulness, therefore banish them
            //

        default:

            return( STATUS_INVALID_PARAMETER );
    }

    //
    // If USER_PASSWORD_NOT_REQUIRED is turned off, make sure that there
    // already is a password.  Note that this requires that the password
    // be set before calling this routine, if both are being done at once.
    //
    // Do not enforce this check for Machine Accounts. The fear here is that
    // we may break net join from downlevel clients. Also this is not a real
    // issue as we expect machines to automatically set very strong passwords.
    //
    // Further enforce this policy only when password length policy is being
    // set, else this would break net user /add in the simple case.
    //
    // Finally, should not enforce it for Trusted Client (such as Inter Domain
    // move object, they may set UserAccountControl first, then set password
    // later)
    //


    if (( ( UserAccountControl & USER_PASSWORD_NOT_REQUIRED ) == 0 )
        && ((UserAccountControl & USER_MACHINE_ACCOUNT_MASK )==0)
        && (SampDefinedDomains[Context->DomainIndex].UnmodifiedFixed.MinPasswordLength>0)
        && ((UserAccountControl & USER_ACCOUNT_DISABLED)==0)
        && (!Context->TrustedClient) )
    {

        NT_OWF_PASSWORD NtOwfPassword;
        LM_OWF_PASSWORD LmOwfPassword;
        BOOLEAN LmPasswordNonNull, NtPasswordPresent, NtPasswordNonNull;

        NtStatus = SampRetrieveUserPasswords(
                       Context,
                       &LmOwfPassword,
                       &LmPasswordNonNull,
                       &NtOwfPassword,
                       &NtPasswordPresent,
                       &NtPasswordNonNull
                       );

        if ( NT_SUCCESS( NtStatus ) &&
            ( (!LmPasswordNonNull) && (!NtPasswordNonNull) ) ) {
            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    //
    // Ensure that only trusted callers can set USER_INTERDOMAIN_TRUST_ACCOUNT. NT5 trust
    // management is always done through trusted domain objects
    //

    if ((NT_SUCCESS(NtStatus))
        && (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
        && (!Context->TrustedClient))
    {
        NtStatus = STATUS_ACCESS_DENIED;
    }


    return( NtStatus );
}




NTSTATUS
SampValidatePrivilegedAccountControlFlags(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
    )
/*++
Routine Description:

    This routine is called in SampSetUserAccountControl() aimed to resolve
    the following two problems:

    First - "Trusted for delegation" option on machine accounts have security
            impacts. In detail, some NT4 domains grant users the right to
            create machine accounts, thereby listing the end-user as the owner
            on these objects. NT5 (Windows 2000) machine object owners have the
            right by DEFAULT to enable the "trusted for delegation" option.
            This means that when these systems upgrades to NT5 their owners
            (end-users) can enable this option.

            Solution: use a new security privilege to set the trusted for
            delegation account flag. The security privilege plus the access
            control right to modify the account control flag will be required
            to enable the delegation option. Bug ID: 234784

    Second- There is a serious security flaw with delegation in NT5.0.
            Specifically an user who is granted the authority to join a
            workstation, or create a user can manipulate the user account
            control to be a server trust account. This is sufficient to install
            an NT4 BDC. We need to check that the rights required on the Domain
            NC head (account domain) to replicate is required to create
            a server trust account. Bug 238411

Parameters:

    AccountContext - Pointer to an object.

    UserAccountControl - New UserAccountControl

    V1aFixed - Pointer to the old data in object context.


Return Values:

    STATUS_SUCCESS - client passed all check

    STATUS_PRIVILEGE_NOT_HELD - donot have the privilege the enable
                                the trusted for delegation option.

    STATUS_ACCESS_DENIED - can not create a Domain Controller Account.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampValidatePrivilegedAccountControlFlags");

    //
    // check whether the client has privilege to set/unset the trusted for
    // delegation on this account or not.
    //

    if (((USER_TRUSTED_FOR_DELEGATION & UserAccountControl) !=
        (USER_TRUSTED_FOR_DELEGATION & V1aFixed->UserAccountControl)
       ) ||
       ((USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION & UserAccountControl) !=
        (USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION & V1aFixed->UserAccountControl)
       ))
    {

        //
        // If trusted_for_delegation is changed, check whether
        // the client holds the privilege.
        //

        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,                               // please impersonate this client
                                    SE_ENABLE_DELEGATION_PRIVILEGE,     // privilege to check
                                    NULL
                                    );
    }


    //
    // if success, check whether the client can UPDATE 
    // USER_PASSWORD_NOT_REQUIRED bit
    // User objects only (don't apply the restriction on computer objects).
    // 

    if (NT_SUCCESS(NtStatus) &&
        ((USER_PASSWORD_NOT_REQUIRED & UserAccountControl) !=  
         (USER_PASSWORD_NOT_REQUIRED & V1aFixed->UserAccountControl))
        )
    {
        NtStatus = SampValidatePwdSettingAttempt(
                            AccountContext,     // account context
                            NULL,               // client token
                            UserAccountControl,
                            (GUID *) &GUID_CONTROL_UpdatePasswordNotRequiredBit
                            );
    }




    //
    // if success, check whether the client can ENABLE
    // USER_DONT_EXPIRE_PASSWORD bit
    // User objects only (don't apply the restriction to computer objects).
    // 
    // not special access ck for DISABLE that bit
    // 

    if (NT_SUCCESS(NtStatus) &&
        (USER_DONT_EXPIRE_PASSWORD & UserAccountControl) && 
        !(USER_DONT_EXPIRE_PASSWORD & V1aFixed->UserAccountControl)
        )
    {
        NtStatus = SampValidatePwdSettingAttempt(
                            AccountContext,     // account context
                            NULL,               // client token
                            UserAccountControl,
                            (GUID *) &GUID_CONTROL_UnexpirePassword
                            );
    }


    //
    // if success, check whether the client can UPDATE
    // bit USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED 
    // 

    if (NT_SUCCESS(NtStatus) &&
        ((USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED & UserAccountControl) != 
         (USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED & V1aFixed->UserAccountControl))
        )
    {
        NtStatus = SampValidatePwdSettingAttempt(
                            AccountContext,     // account context
                            NULL,               // client token
                            UserAccountControl,
                            (GUID *) &GUID_CONTROL_EnablePerUserReversiblyEncryptedTextPassword
                            );
    }



    //
    // check whether the client has the right to create a Domain Controller
    // account.
    //

    //
    // the right required on the domain NC head to replicate is tested
    // at here
    //

    if (NT_SUCCESS(NtStatus) &&
        (!AccountContext->TrustedClient) &&
        (USER_SERVER_TRUST_ACCOUNT & UserAccountControl) &&
        !(USER_SERVER_TRUST_ACCOUNT & V1aFixed->UserAccountControl)
       )
    {
        NtStatus = SampValidateDomainControllerCreation(AccountContext);
    }

    return NtStatus;

}

NTSTATUS
SampEnforceComputerClassForDomainController(
    IN PSAMP_OBJECT AccountContext
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ATTRTYP  ObjectClassTyp[] = {SAMP_FIXED_USER_OBJECTCLASS};
    ATTRVAL  ObjectClassVal[] = {0,NULL};
    ATTRBLOCK ObjectClassResults;
    ULONG     i;
    BOOLEAN   IsComputer = FALSE;
    UNICODE_STRING UserName;
    DEFINE_ATTRBLOCK1(ObjectClassBlock,ObjectClassTyp,ObjectClassVal);

    NtStatus = SampDsRead(
                    AccountContext->ObjectNameInDs,
                    0,
                    SampUserObjectType,
                    &ObjectClassBlock,
                    &ObjectClassResults
                    );

    if (NT_SUCCESS(NtStatus))
    {
        for (i=0;i<ObjectClassResults.pAttr[0].AttrVal.valCount;i++)
        {
            if (CLASS_COMPUTER==
                (*((ULONG *)ObjectClassResults.pAttr[0].AttrVal.pAVal[i].pVal)))
            {
                IsComputer = TRUE;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {

        if (!IsComputer)
        {
            //
            // Event log the failure
            //
    
            NtStatus = SampGetUnicodeStringAttribute(
                            AccountContext,
                            SAMP_USER_ACCOUNT_NAME,
                            FALSE,    // Make copy
                            &UserName
                            );
    
            if (NT_SUCCESS(NtStatus))
            {
    
                PUNICODE_STRING StringPointers = &UserName;
    
                SampWriteEventLog(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SAMMSG_DC_NEEDS_TO_BE_COMPUTER,
                        NULL,
                        1,
                        0,
                        &StringPointers,
                        NULL
                        );
            }
    
            NtStatus = STATUS_PRENT4_MACHINE_ACCOUNT;
    
        }
    }

    return(NtStatus);
}



NTSTATUS
SampSetUserAccountControl(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed,
    IN BOOLEAN      ChangePrimaryGroupId,
    OUT BOOLEAN     *AccountUnlocked,
    OUT BOOLEAN     *AccountGettingMorphed,
    OUT BOOLEAN     *KeepOldPrimaryGroupMembership
    )
/*++

  Routine Description

    This routine performs all the steps in changing the user account control.
    It
        1. Checks for valid combination of user account control
        2. Checks if the machine account bits are being changed to user account
           or vice versa
        3. Checks to see if the account lockout flag is being cleared
        4. Changes Primary group id to new defaults if caller indicates so

    Parameters:

        AccountContext --- Open context to the account at hand
        UserAccountControl -- The new user account control
        V1aFixed       --- The V1aFixed that has just been retrieved from the account control
        ChangePrimaryGroupId -- Changes primary group id to new defaults if caller indicates so
        AccountGettingMorphed -- TRUE returned here if machine/user translations are taking place
        KeepOldPrimaryGroupMembership - TRUE returned here if 1) Domain Controller's PrimaryGroupId
                                        is changed and 2) the previous primary group id is not the
                                        default one. In this case, we should add the old primary
                                        group id to its (this account) reverse membership list.

    Return Values:

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CurrentlyLocked = FALSE;
    BOOLEAN  Unlocking = FALSE;
    ULONG OldUserAccountControl = V1aFixed->UserAccountControl;


    *AccountGettingMorphed = FALSE;
    *AccountUnlocked = FALSE;

    //
    // Password expired bit, is computed, cannot be set
    // However, applications read and simply or in additional
    // user account control flags. Therefore silently mask out
    // that bit

    UserAccountControl &= ~((ULONG) USER_PASSWORD_EXPIRED );

    NtStatus = SampIsUserAccountControlValid(
                        AccountContext,
                        UserAccountControl
                        );

    //
    // Apply additional checks for untrusted client,
    // only in DS case.
    //

    if (NT_SUCCESS(NtStatus) &&
        !(AccountContext->TrustedClient) &&
        IsDsObject(AccountContext)
       )
    {
        NtStatus = SampValidatePrivilegedAccountControlFlags(
                                        AccountContext,
                                        UserAccountControl,
                                        V1aFixed
                                        );
    }


    //
    // If a domain controller is being created verify that the
    // object class is class computer ( ie going from non server
    // trust account to server trust account
    //

    if ((NT_SUCCESS(NtStatus)) &&
        (IsDsObject(AccountContext)) &&
        (!AccountContext->TrustedClient) &&
        (( UserAccountControl & USER_SERVER_TRUST_ACCOUNT)!=0) &&
        ((V1aFixed->UserAccountControl & USER_SERVER_TRUST_ACCOUNT)==0))
    {
        NtStatus = SampEnforceComputerClassForDomainController(AccountContext);
    }



    if ( NT_SUCCESS( NtStatus ) ) {

        if ( ( V1aFixed->UserAccountControl &
            USER_MACHINE_ACCOUNT_MASK ) !=
            ( UserAccountControl &
            USER_MACHINE_ACCOUNT_MASK ) ) {

           *AccountGettingMorphed = TRUE;

           //
           // Urgently changes from WORKSTATION to SERVER Trust and vis
           // versa
           //
           if (  (V1aFixed->UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
              && (UserAccountControl & USER_SERVER_TRUST_ACCOUNT)  )
           {
               AccountContext->ReplicateUrgently = TRUE;
           }
           if (  (V1aFixed->UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
              && (UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)  )
           {
               AccountContext->ReplicateUrgently = TRUE;
           }
        }

        //
        // Untrusted clients can:
        //
        //   1) leave the the ACCOUNT_AUTO_LOCK flag set.
        //   2) Clear the ACCOUNT_AUTO_LOCK flag.
        //
        // They can't set it.  So, we must AND the user's
        // flag value with the current value and set that
        // in the UserAccountControl field.
        //

        if (!(AccountContext->TrustedClient)) {

            //
            // Minimize the passed in AccountControl
            // with the currently set value.
            //

            UserAccountControl =
                (V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)?
                UserAccountControl:
                ((~((ULONG) USER_ACCOUNT_AUTO_LOCKED)) & UserAccountControl);

            //
            // If an untrusted client is unlocking the account,
            // then we also need to re-set the BadPasswordCount.
            // Trusted clients are expected to explicitly set
            // the BadPasswordCount.
            //

            CurrentlyLocked = (V1aFixed->UserAccountControl &
                               USER_ACCOUNT_AUTO_LOCKED) != 0;
            Unlocking = (UserAccountControl &
                         USER_ACCOUNT_AUTO_LOCKED) == 0;

            if (CurrentlyLocked && Unlocking) {

                *AccountUnlocked = TRUE;

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                               "UserId: 0x%x  Manually unlocked\n", V1aFixed->UserId));

                V1aFixed->BadPasswordCount = 0;

                if (IsDsObject(AccountContext))
                {

                    //
                    // Set the lockout time to 0
                    //

                    RtlSecureZeroMemory(&AccountContext->TypeBody.User.LockoutTime,
                                   sizeof(LARGE_INTEGER) );

                    NtStatus = SampDsUpdateLockoutTime(AccountContext);

                }

                //
                // Event Log Account Unlock
                //
                if ( NT_SUCCESS(NtStatus) &&
                     SampDoAccountAuditing(AccountContext->DomainIndex) )
                {
                    NTSTATUS        TmpNtStatus = STATUS_SUCCESS;
                    UNICODE_STRING  AccountName;
                    PSAMP_DEFINED_DOMAINS   Domain = NULL;

                    TmpNtStatus = SampGetUnicodeStringAttribute(
                                        AccountContext,
                                        SAMP_USER_ACCOUNT_NAME,
                                        FALSE,      // Don't make copy
                                        &AccountName
                                        );

                    if (NT_SUCCESS(TmpNtStatus))
                    {
                        Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                        SampAuditAnyEvent(
                            AccountContext,
                            STATUS_SUCCESS,
                            SE_AUDITID_ACCOUNT_UNLOCKED,        // Audit ID
                            Domain->Sid,                        // Domain SID
                            NULL,                               // Additional Info
                            NULL,                               // Member Rid (unused)
                            NULL,                               // Member Sid (unused)
                            &AccountName,                       // Account Name
                            &Domain->ExternalName,              // Domain Name
                            &AccountContext->TypeBody.User.Rid, // Account Rid
                            NULL,                               // Privilege
                            NULL                                // New State Data
                            );

                    } // TmpNtStatus

                } // if DoAudit
            }

        }

        //
        // If the account is getting morphed, and it is DS mode, then check to see if
        // we have to change the primary group of the object.
        //

        if (  (NT_SUCCESS(NtStatus))
           && (*AccountGettingMorphed)
           && (IsDsObject(AccountContext))
           )
        {
            //
            // The algorithm to use is:
            //
            // if the account is morphed and is a Domain Controller right now,
            // then enforce the PrimaryGroupID to be DOMAIN_GROUP_RID_CONTROLLERS
            // no matter what.
            //
            // otherwise if the old Primary Group is the default one then the new
            // primarygroup will be changed to the defaults.
            //

            if (USER_SERVER_TRUST_ACCOUNT & UserAccountControl)
            {
                if (V1aFixed->PrimaryGroupId
                    != SampDefaultPrimaryGroup(AccountContext, V1aFixed->UserAccountControl))
                {
                    *KeepOldPrimaryGroupMembership = TRUE;
                }

                V1aFixed->PrimaryGroupId = SampDefaultPrimaryGroup(
                                                    AccountContext,
                                                    UserAccountControl
                                                    );

                ASSERT(V1aFixed->PrimaryGroupId = DOMAIN_GROUP_RID_CONTROLLERS);
            }
            else if(ChangePrimaryGroupId &&
                    (V1aFixed->PrimaryGroupId == SampDefaultPrimaryGroup(
                                                    AccountContext,
                                                    V1aFixed->UserAccountControl)))
            {
                V1aFixed->PrimaryGroupId = SampDefaultPrimaryGroup(
                                                AccountContext,
                                                UserAccountControl
                                                );
            }

        }




    }


    //
    // If the USER_SMARTCARD_REQUIRED flag is being set, then randomize the
    // password
    //

    if ((NT_SUCCESS(NtStatus)) &&
        (( UserAccountControl & USER_SMARTCARD_REQUIRED)!=0) &&
        ((V1aFixed->UserAccountControl & USER_SMARTCARD_REQUIRED)==0))
    {
        LM_OWF_PASSWORD LmOwfPassword;
        NT_OWF_PASSWORD NtOwfPassword;

        if (!CDGenerateRandomBits((PUCHAR) &LmOwfPassword, sizeof(LmOwfPassword)))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if ((NT_SUCCESS(NtStatus))
           && (!CDGenerateRandomBits((PUCHAR) &NtOwfPassword, sizeof(NtOwfPassword))))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(NtStatus))
        {

            NtStatus = SampStoreUserPasswords(
                            AccountContext,
                            &LmOwfPassword,
                            TRUE,
                            &NtOwfPassword,
                            TRUE,
                            FALSE, // Don't check Password Restrictions.
                            PasswordSet,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            );
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Now set the account control flags
        //     
        V1aFixed->UserAccountControl = UserAccountControl;
        
        //
        // Store the old UAC if auditing is enabled so we can report the delta.
        //
        if (SampDoAccountAuditing(AccountContext->DomainIndex)) {
            
            ULONG NewUserAccountControl = UserAccountControl;
            
            //
            // Mask out any computed bits as we don't audit them.
            //
            OldUserAccountControl &= 
                ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);
            
            NewUserAccountControl &= 
                ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);

            //
            // If there has been a change to audited bits queue the old UAC.
            //
            if (OldUserAccountControl != NewUserAccountControl) {
                
                PSID UserSid = NULL;
            
                NtStatus = SampCreateAccountSid(AccountContext, &UserSid);
        
                if (NT_SUCCESS(NtStatus)) {
                    
                    NtStatus = SampAuditUpdateAuditNotificationDs(
                               SampAuditUpdateTypeUserAccountControl,
                               UserSid,
                               (PVOID)&OldUserAccountControl
                               );
                    
                    MIDL_user_free(UserSid);
                }   
            }
        } 
    }


    return NtStatus;
}



NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    SAMTRACE("SampCalculateLMPassword");

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    LmPassword.Buffer = MIDL_user_allocate(LM_BUFFER_LENGTH);
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlSecureZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlSecureZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

        MIDL_user_free(LmPassword.Buffer);
    }

    return(NtStatus);
}



NTSTATUS
SampCalculateLmAndNtOwfPasswords(
    IN PUNICODE_STRING ClearNtPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    This routine calculates the LM and NT OWF passwordw from the cleartext
    password.

Arguments:

    ClearNtPassword - A Cleartext unicode password

    LmPasswordPresent - indicates whether an LM OWF password could be
        calculated

    LmOwfPassword - Gets the LM OWF hash of the cleartext password.

    NtOwfPassword - Gets the NT OWF hash of the cleartext password.


Return Value:

--*/
{
    PCHAR LmPassword = NULL;
    NTSTATUS NtStatus;

    SAMTRACE("SampCalculateLmAndNtOwfPassword");

    //
    // First compute the LM password.  If the password is too complex
    // this may not be possible.
    //


    NtStatus = SampCalculateLmPassword(
                ClearNtPassword,
                &LmPassword
                );

    //
    // If it faield because the LM password could not be calculated, that
    // is o.k.
    //

    if (NtStatus != STATUS_SUCCESS) {

        if (NtStatus == STATUS_NULL_LM_PASSWORD) {
            *LmPasswordPresent = FALSE;
            NtStatus = STATUS_SUCCESS;

        }

    } else {

        //
        // Now compute the OWF passwords
        //

        *LmPasswordPresent = TRUE;

        NtStatus = RtlCalculateLmOwfPassword(
                        LmPassword,
                        LmOwfPassword
                        );

    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlCalculateNtOwfPassword(
                        ClearNtPassword,
                        NtOwfPassword
                   );
    }

    if (LmPassword != NULL) {
        MIDL_user_free(LmPassword);
    }

    return(NtStatus);

}



NTSTATUS
SampDecryptPasswordWithKey(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PBYTE Key,
    IN ULONG KeySize,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    OEM_STRING OemPassword;
    PSAMPR_USER_PASSWORD Password = (PSAMPR_USER_PASSWORD) EncryptedPassword;

    SAMTRACE("SampDecryptPasswordWithKey");

    //
    // Decrypt the key.
    //

    rc4_key(
        &Rc4Key,
        KeySize,
        Key
        );

    rc4(&Rc4Key,
        sizeof(SAMPR_ENCRYPTED_USER_PASSWORD),
        (PUCHAR) Password
        );

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (Password->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_WRONG_PASSWORD);
    }


    //
    // Convert the password into a unicode string.
    //

    if (UnicodePasswords) {
        NtStatus = SampInitUnicodeString(
                        ClearNtPassword,
                        (USHORT) (Password->Length + sizeof(WCHAR))
                   );
        if (NT_SUCCESS(NtStatus)) {

            ClearNtPassword->Length = (USHORT) Password->Length;

            RtlCopyMemory(
                ClearNtPassword->Buffer,
                ((PCHAR) Password->Buffer) +
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                    Password->Length,
                Password->Length
                );
            NtStatus = STATUS_SUCCESS;
        }
    } else {

        //
        // The password is in the OEM character set.  Convert it to Unicode
        // and then copy it into the ClearNtPassword structure.
        //

        OemPassword.Buffer = ((PCHAR)Password->Buffer) +
                                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                                Password->Length;

        OemPassword.Length = (USHORT) Password->Length;


        NtStatus = RtlOemStringToUnicodeString(
                        ClearNtPassword,
                        &OemPassword,
                        TRUE            // allocate destination
                    );
    }

    return(NtStatus);
}


NTSTATUS
SampDecryptPasswordWithSessionKeyNew(
    IN SAMPR_HANDLE UserHandle,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD_NEW EncryptedPassword,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:

    This routine decrypts encrypted password using new algorithm.

    the old encryption method exposes plain text password.
    See WinSE Bug 9254 for more details.

    The fix (this routine) was introduced in Win 2000 SP2, and NT4 SP7.


Arguments:

    UserHandle - User Handle

    EncryptedPassword - Encrypted Password

    ClearNtPassword - return clear password

Return Value:

--*/
{
    NTSTATUS            NtStatus;
    USER_SESSION_KEY    UserSessionKey;
    MD5_CTX             Md5Context;
    OEM_STRING          OemPassword;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD_NEW    UserPassword = (PSAMPR_USER_PASSWORD_NEW) EncryptedPassword;


    SAMTRACE("SampDecryptPasswordWithSessionKeyNew");

    NtStatus = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)UserHandle,
                    &UserSessionKey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    MD5Init(&Md5Context);

    MD5Update(&Md5Context,
              (PUCHAR) UserPassword->ClearSalt,
              SAM_PASSWORD_ENCRYPTION_SALT_LEN
              );

    MD5Update(&Md5Context,
              (PUCHAR) &UserSessionKey,
              sizeof(UserSessionKey)
              );

    MD5Final(&Md5Context);

    rc4_key(&Rc4Key,
            MD5DIGESTLEN,
            Md5Context.digest
            );


    rc4(&Rc4Key,
        sizeof(SAMPR_ENCRYPTED_USER_PASSWORD_NEW) - SAM_PASSWORD_ENCRYPTION_SALT_LEN,
        (PUCHAR) UserPassword
        );

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (UserPassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_WRONG_PASSWORD);
    }

    NtStatus = SampInitUnicodeString(ClearNtPassword,
                                     (USHORT) (UserPassword->Length + sizeof(WCHAR))
                                     );

    if (NT_SUCCESS(NtStatus))
    {
        ClearNtPassword->Length = (USHORT) UserPassword->Length;

        RtlCopyMemory(ClearNtPassword->Buffer,
                      ((PUCHAR) UserPassword) +
                          (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                          UserPassword->Length,
                      UserPassword->Length
                      );
    }

    return( NtStatus );
}

NTSTATUS
SampDecryptPasswordWithSessionKeyOld(
    IN SAMPR_HANDLE UserHandle,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{

    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;

    SAMTRACE("SampDecryptPasswordWithSessionKeyOld");

    NtStatus = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)UserHandle,
                    &UserSessionKey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    return(SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) &UserSessionKey,
                sizeof(USER_SESSION_KEY),
                TRUE,
                ClearNtPassword
                ) );

}


NTSTATUS
SampDecryptPasswordWithSessionKey(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;

    SAMTRACE("SampDecryptPasswordWithSessionKey");


    switch( UserInformationClass )
    {
    case UserInternal4InformationNew:

        NtStatus = SampDecryptPasswordWithSessionKeyNew(
                        UserHandle,
                        &Buffer->Internal4New.UserPassword,
                        ClearNtPassword
                        );
        break;

    case UserInternal5InformationNew:

        NtStatus = SampDecryptPasswordWithSessionKeyNew(
                        UserHandle,
                        &Buffer->Internal5New.UserPassword,
                        ClearNtPassword
                        );

        break;

    case UserInternal4Information:

        NtStatus = SampDecryptPasswordWithSessionKeyOld(
                        UserHandle,
                        &Buffer->Internal4.UserPassword,
                        ClearNtPassword
                        );

        break;

    case UserInternal5Information:

        NtStatus = SampDecryptPasswordWithSessionKeyOld(
                        UserHandle,
                        &Buffer->Internal5.UserPassword,
                        ClearNtPassword
                        );

        break;

    default:

        NtStatus = STATUS_INTERNAL_ERROR;
        break;
    }

    return( NtStatus );
}




NTSTATUS
SampCheckPasswordRestrictions(
    IN PSAMP_OBJECT AccountContext,
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    IN PUNICODE_STRING NewNtPassword,
    IN BOOLEAN  MachineOrTrustAccount,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    )

/*++

Routine Description:

    This service is called to make sure that the password presented meets
    our quality requirements.


Arguments:

    UserHandle - Handle to a user.

    DomainPasswordInfo -- Indicates the password policy to enforce

    NewNtPassword - Pointer to the UNICODE_STRING containing the new
        password.

    PasswordChangeFailureInfo -- Indicates error information regarding
                                 the password change operation


Return Value:

    STATUS_SUCCESS - The password is acceptable.

    STATUS_PASSWORD_RESTRICTION - The password is too short, or is not
        complex enough, etc.

    STATUS_INVALID_RESOURCES - There was not enough memory to do the
        password checking.

    STATUS_NO_MEMORY - Return by SampGetUnicodeStringAttribute, or
        by SampCheckStrongPasswordRestrictions. no enough memory.


--*/
{
    USER_DOMAIN_PASSWORD_INFORMATION  PasswordInformation = {0, 0};
    NTSTATUS                          NtStatus = STATUS_SUCCESS;
    ULONG                             i;
    PSAMP_DEFINED_DOMAINS             Domain;

    SAMTRACE("SampCheckPasswordRestrictions");





    //
    // NT 4.0 and w2k versions of SAM used to enforce a check in some code paths
    // but not others, that the user' had rights to access the password policy
    // in order for password policies to be enforced on password change/set.
    // When password policy enforcement was consolidated this broke net re-join,
    // as the domain handle was'nt being opened with DOMAIN_READ_PASSWORD_PARAMETERS
    // access by the client side. This break was a result of password resets enforcing
    // this policy now -- previously did'nt
    //
    // We believe enforcing this policy only results in woes -- while w2k and NT 4.0
    // enforced it, they only got away because read access to the password policy was granted
    // by default to anonymous and removing this reliance on ACL's causes anonymous
    // password change ( ie change password when password expired  ) to break. By the
    // time we get to enforcing this policy here on a password reset we have already
    // access ck'd for "reset password" rights and for a password change we have already
    // authenticated the old password provided and access ck'd for "change password" rights.
    //

    //if ( !( AccountContext->TypeBody.User.DomainPasswordInformationAccessible ) ) {
    //
    //    NtStatus = STATUS_ACCESS_DENIED;
    //    goto Cleanup;
    //}

    //
    // If the user account is a machine account or
    // service accounts such as the krbtgt account,
    // then restrictions are generally not enforced.
    // This is so that simple initial passwords can be
    // established.  IT IS EXPECTED THAT COMPLEX PASSWORDS,
    // WHICH MEET THE MOST STRINGENT RESTRICTIONS, WILL BE
    // AUTOMATICALLY ESTABLISHED AND MAINTAINED ONCE THE MACHINE
    // JOINS THE DOMAIN.  It is the UI's responsibility to
    // maintain this level of complexity.
    //



    if ((MachineOrTrustAccount) ||
        (DOMAIN_USER_RID_KRBTGT==AccountContext->TypeBody.User.Rid)){

        PasswordInformation.MinPasswordLength = 0;
        PasswordInformation.PasswordProperties = 0;
    } else {

        PasswordInformation.MinPasswordLength = DomainPasswordInfo->MinPasswordLength;
        PasswordInformation.PasswordProperties = DomainPasswordInfo->PasswordProperties;
    }


    //
    // For Machine accounts if the special Domain flag for refuse password change is set,
    // then disallow any account creation except the default
    //

    if (MachineOrTrustAccount)
    {
        NtStatus = SampEnforceDefaultMachinePassword(
                        AccountContext,
                        NewNtPassword,
                        DomainPasswordInfo
                        );

        //
        // If this failed with password restriction it means that refuse password change
        // is set for machine acounts
        //

        if (!NT_SUCCESS(NtStatus)) {

            if ((STATUS_PASSWORD_RESTRICTION==NtStatus)
                    && (ARGUMENT_PRESENT(PasswordChangeFailureInfo))) {
                PasswordChangeFailureInfo->ExtendedFailureReason =
                        SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT;
            }

            goto Cleanup;
        }

    }

    //
    // Enforce Minimum password length restriction
    //


    if ( (USHORT)( NewNtPassword->Length / sizeof(WCHAR) ) < PasswordInformation.MinPasswordLength ) {

        NtStatus = STATUS_PASSWORD_RESTRICTION;
        if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
        {
            PasswordChangeFailureInfo->ExtendedFailureReason
                = SAM_PWD_CHANGE_PASSWORD_TOO_SHORT;
        }

        goto Cleanup;

    }

    //
    // Enforce Maximum password length restriction
    //

    if ( (USHORT) ( NewNtPassword->Length / sizeof(WCHAR) ) > PWLEN) {

        //
        // The password should be less than PWLEN -- 256
        //

        NtStatus = STATUS_PASSWORD_RESTRICTION;
        if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
        {
            PasswordChangeFailureInfo->ExtendedFailureReason
                = SAM_PWD_CHANGE_PASSWORD_TOO_LONG;
        }

        goto Cleanup;

    }

    //
    // Check strong password complexity.
    //

    if ( PasswordInformation.PasswordProperties & DOMAIN_PASSWORD_COMPLEX ) {

        // Make sure that the password meets our requirements for
        // complexity.  If it's got an odd byte count, it's
        // obviously not a hand-entered UNICODE string so we'll
        // consider it complex by default.
        //

        if ( !( NewNtPassword->Length & 1 ) ) {

            UNICODE_STRING  AccountName;
            UNICODE_STRING  FullName;

            RtlInitUnicodeString(&AccountName, NULL);

            RtlInitUnicodeString(&FullName, NULL);

            NtStatus = SampGetUnicodeStringAttribute(
                                AccountContext,
                                SAMP_USER_ACCOUNT_NAME,
                                TRUE,    // Make copy
                                &AccountName
                                );

            if ( NT_SUCCESS(NtStatus) ) {

                NtStatus = SampGetUnicodeStringAttribute(
                                    AccountContext,
                                    SAMP_USER_FULL_NAME,
                                    TRUE, // Make copy
                                    &FullName
                                    );

                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = SampCheckStrongPasswordRestrictions(
                                            &AccountName,
                                            &FullName,
                                            NewNtPassword,
                                            PasswordChangeFailureInfo
                                            );

                }
            }

            if ( AccountName.Buffer != NULL ) {
                MIDL_user_free ( AccountName.Buffer );
                AccountName.Buffer = NULL;
            }

            if ( FullName.Buffer != NULL ) {
                MIDL_user_free ( FullName.Buffer );
                FullName.Buffer = NULL;
            }
        }
    }

Cleanup:

    return( NtStatus );
}

////////////////////////////////////////////////////////////////////////

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    )

/*++

Routine Description:

    This routine is notified of a password change. It will check the
    password's complexity. The new Strong Password must meet the
    following criteria:
    1. Password must contain characters from at least 3 of the
       following 5 classes:

       Description                             Examples:
       1       English Upper Case Letters      A, B, C,   Z
       2       English Lower Case Letters      a, b, c,  z
       3       Westernized Arabic Numerals     0, 1, 2,  9
       4       Non-alphanumeric             ("Special characters")
                                            (`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)
       5       Any linguistic character: alphabetic, syllabary, or ideographic
               (localization issue)

    2. Password can not contain your account name or any part of
       user's full name.


    Note: This routine does NOT check password's length, since password
          length restriction has already been enforced by NT4 SAM if you
          set it correctly.

Arguments:

    AccountName - Name of user whose password changed

    FullName - Full name of the user whose password changed

    Password - Cleartext new password for the user

Return Value:

    STATUS_SUCCESS if the specified Password is suitable (complex, long, etc).
        The system will continue to evaluate the password update request
        through any other installed password change packages.

    STATUS_PASSWORD_RESTRICTION
        if the specified Password is unsuitable. The password change
         on the specified account will fail.

    STATUS_NO_MEMORY

--*/
{

                    // assume the password in not complex enough
    NTSTATUS NtStatus = STATUS_PASSWORD_RESTRICTION;
    USHORT     cchPassword = 0;
    USHORT     i = 0;
    USHORT     NumInPassword = 0;
    USHORT     UpperInPassword = 0;
    USHORT     LowerInPassword = 0;
    USHORT     AlphaInPassword = 0;
    USHORT     SpecialCharInPassword = 0;
    PWSTR     token = NULL;
    PWSTR     _password = NULL;
    PWSTR    _accountname = NULL;
    PWSTR    _fullname = NULL;
    PWSTR    TempString = NULL;
    PWORD    CharType = NULL;


    SAMTRACE("SampCheckStrongPasswordRestrictions");


    // check if the password contains at least 3 of 4 classes.


    CharType = MIDL_user_allocate( Password->Length );

    if ( CharType == NULL ) {

        NtStatus = STATUS_NO_MEMORY;
        goto SampCheckStrongPasswordFinish;
    }

    cchPassword = Password->Length / sizeof(WCHAR);
    if(GetStringTypeW(
           CT_CTYPE1,
           Password->Buffer,
           cchPassword,
           CharType)) {

        for(i = 0 ; i < cchPassword ; i++) {

            //
            // keep track of what type of characters we have encountered
            //

            if(CharType[i] & C1_DIGIT) {
                NumInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_UPPER) {
                UpperInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_LOWER) {
                LowerInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_ALPHA) {
                AlphaInPassword = 1;
                continue;
            }

        } // end of track character type.

        _password = MIDL_user_allocate(Password->Length + sizeof(WCHAR));

        if ( _password == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto SampCheckStrongPasswordFinish;
        }
        else {

            RtlSecureZeroMemory( _password, Password->Length + sizeof(WCHAR));
        }

        wcsncpy(_password,
                Password->Buffer,
                Password->Length/sizeof(WCHAR)
                );

        if (wcspbrk (_password, L"(`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)/") != NULL) {

                SpecialCharInPassword = 1 ;
        }

        //
        // Indicate whether we encountered enough password complexity
        //

        if( (NumInPassword + LowerInPassword + UpperInPassword + AlphaInPassword +
                SpecialCharInPassword) < 3) {

            NtStatus = STATUS_PASSWORD_RESTRICTION;
            if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason = SAM_PWD_CHANGE_NOT_COMPLEX;
            }
            goto SampCheckStrongPasswordFinish;

        } else {

            //
            // now we resort to more complex checking
            //
            _accountname = MIDL_user_allocate(AccountName->Length + sizeof(WCHAR));

            if ( _accountname == NULL ) {

                NtStatus = STATUS_NO_MEMORY;
                goto SampCheckStrongPasswordFinish;
            }
            else {

                RtlSecureZeroMemory( _accountname, AccountName->Length + sizeof(WCHAR));
            }

            wcsncpy(_accountname,
                    AccountName->Buffer,
                    AccountName->Length/sizeof(WCHAR)
                    );

            _fullname = MIDL_user_allocate(FullName->Length + sizeof(WCHAR));

            if ( _fullname == NULL ) {

                NtStatus = STATUS_NO_MEMORY;
                goto SampCheckStrongPasswordFinish;
            }
            else {

                RtlSecureZeroMemory( _fullname, FullName->Length + sizeof(WCHAR));
            }

            wcsncpy(_fullname,
                    FullName->Buffer,
                    FullName->Length/sizeof(WCHAR)
                    );

            _wcsupr(_password);
            _wcsupr(_accountname);
            _wcsupr(_fullname);

            if ( (AccountName->Length >= 3 * sizeof(WCHAR)) &&
                    wcsstr(_password, _accountname) ) {

                    NtStatus = STATUS_PASSWORD_RESTRICTION;
                    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                    {
                        PasswordChangeFailureInfo->ExtendedFailureReason
                            = SAM_PWD_CHANGE_USERNAME_IN_PASSWORD;
                    }
                    goto SampCheckStrongPasswordFinish;

            }

            token = SampLocalStringToken(_fullname, L" ,.\t-_#",&TempString);

            while ( token != NULL ) {

                if ( wcslen(token) >= 3 && wcsstr(_password, token) ) {

                    NtStatus = STATUS_PASSWORD_RESTRICTION;
                    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                    {
                        PasswordChangeFailureInfo->ExtendedFailureReason
                            = SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD;
                    }
                    goto SampCheckStrongPasswordFinish;

                }

                token = SampLocalStringToken(NULL, L" ,.\t-_#",&TempString);
            }


            NtStatus = STATUS_SUCCESS ;

        }

    } // if GetStringTypeW failed, NtStatus will by default equal to
      // STATUS_PASSWORD_RESTRICTION


SampCheckStrongPasswordFinish:

    if ( CharType != NULL ) {
        RtlSecureZeroMemory( CharType, Password->Length );
        MIDL_user_free( CharType );
    }

    if ( _password != NULL ) {
        RtlSecureZeroMemory( _password, Password->Length + sizeof(WCHAR) );
        MIDL_user_free( _password );
    }

    if ( _accountname != NULL ) {
        RtlSecureZeroMemory( _accountname, AccountName->Length + sizeof(WCHAR) );
        MIDL_user_free( _accountname );
    }

    if ( _fullname != NULL ) {
        RtlSecureZeroMemory( _fullname, FullName->Length + sizeof(WCHAR) );
        MIDL_user_free( _fullname );
    }

    return ( NtStatus );
}

/////////////////////////////////////////////////////////////////////

PWSTR
SampLocalStringToken(
    PWSTR    String,
    PWSTR    Token,
    PWSTR    * NextStringStart
    )
/*++

Routine Description:

    This routine will find next token in the first parameter "String".

Arguments:

    String - Pointer to a string, which contains (a) token(s).

    Token  - Delimiter Set. They could be " ,.\t-_#"

    NextStringStart - Used to keep the start point to search next token.

Return Value:

    A pointer to the token.

--*/

{
    USHORT    Index;
    USHORT    Tokens;
    PWSTR    StartString;
    PWSTR    EndString;
    BOOLEAN    Found;

    //
    // let StartString points to the start point of the string.
    //

    if (String != NULL) {

        StartString = String;
    }
    else {

        if (*NextStringStart == NULL) {
            return(NULL);
        }
        else {
            StartString = *NextStringStart;
        }
    }

    Tokens = (USHORT)wcslen(Token);

    //
    // Find the beginning of the string. pass all beginning delimiters.
    //

    while (*StartString != L'\0') {

        Found = FALSE;
        for (Index = 0; Index < Tokens; Index ++) {

            if (*StartString == Token[Index]) {

                StartString ++;
                Found = TRUE;
                break;
            }
        }
        if ( !Found ) {

            break;
        }
    }


    //
    // If there are no more tokens in this string
    //

    if (*StartString == L'\0') {

        *NextStringStart = NULL;
        return ( NULL );
    }

    EndString = StartString + 1;

    while ( *EndString != L'\0' ) {

        for (Index = 0; Index < Tokens; Index ++) {

            if (*EndString == Token[Index]) {

                *EndString = L'\0';
                *NextStringStart = EndString + 1;
                return ( StartString );
            }
        }
        EndString ++;
    }

    *NextStringStart = NULL;

    return ( StartString );

}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

LARGE_INTEGER
SampCalcEndOfLastLogonTimeStamp(
    LARGE_INTEGER   LastLogonTimeStamp,
    ULONG           SyncInterval
    )
/*++
Routine Description:

    This routine calculates the last logon time stamp update schedule

Parameters:

    LastLogonTimeStamp - last logon time

    SyncInterval - discrepency in days between the replicated
                   LastLogonTimeStamp attribute and non-replicated lastLognTime
                   attribute

Return Value:

    when should SAM update last logon time stamp

--*/
{
    LARGE_INTEGER       UpdateInterval;
    USHORT              RandomValue = 0x7FFF;

    //
    // if update interval is 0, this attribute is disabled.
    // no update will be scheduled.
    //

    if (0 == SyncInterval)
    {
        return(SampWillNeverTime);
    }


    //
    // calculate update interval (by 100 nanosecond)
    //
    //
    // SyncInterval contains the interval by days.
    // so need to convert days to filetime, which is number of 100-nanosecond
    // since 01/01/1601.  time (-1) to make it a delta time.
    // Be careful about Large integer multiply, put a limit of any variable to
    // make sure no overflow.
    // SyncInterval is in range of 1 ~ 100,000. RandomValue is 0 ~ 7FFFF
    //

    if (SyncInterval > SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW)
    {
        //
        // generate a random number. To simplifiy calculation, always use positive.
        // if failed, pick up the max (signed)
        //

        if (!CDGenerateRandomBits((PBYTE)&RandomValue, sizeof(USHORT)))
        {
            RandomValue = 0x7FFF;
        }
        RandomValue &= 0x7FFF;

        UpdateInterval.QuadPart = SyncInterval - ((SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW * RandomValue) / 0x7FFF);
    }
    else
    {
        UpdateInterval.QuadPart = SyncInterval;
    }

    UpdateInterval.QuadPart *= 24 * 60 * 60;
    UpdateInterval.QuadPart *= 1000 * 10000;
    UpdateInterval.QuadPart *= -1;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
//

#if DBG
    if (SampLastLogonTimeStampSyncByMinute)
    {
        UpdateInterval.QuadPart /= (24 * 60);
    }
#endif

    return(SampAddDeltaTime(LastLogonTimeStamp, UpdateInterval));
}


NTSTATUS
SampDsSuccessfulLogonSet(
   IN PSAMP_OBJECT AccountContext,
   IN ULONG        Flags,
   IN ULONG        LastLogonTimeStampSyncInterval,
   IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
   )
/*++

    Routine Description

        This routine, sets just the attributes corresponding to logon statistics,
        as opposed to writing out the user fixed attributes, which results in a
        large number of attributes being written out during every logon. This is called
        on successful logons.

    Parameters

        AccountContext -- Sam context for the user account.
        Flags          -- the client flags indicating the nature of the logon
        LastLogonTimeStampSyncInterval -- Update Interval for LastLogonTimeStamp attr
        V1aFixed       -- Pointer to a structure containing the modified properties

    Return Values

        STATUS_SUCCESS
        Other Error codes from the flushing
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER LastLogon = V1aFixed->LastLogon;
    LARGE_INTEGER LastLogoff = V1aFixed->LastLogoff;
    LARGE_INTEGER NewLastLogonTimeStamp = V1aFixed->LastLogon;
    LARGE_INTEGER EndOfLastLogonTimeStamp;
    ULONG         BadPasswordCount = (ULONG) V1aFixed->BadPasswordCount;
    SAMP_V1_0A_FIXED_LENGTH_USER OldV1aFixed;
    ULONG         LogonCount = (ULONG) V1aFixed->LogonCount;
    SAMP_SITE_AFFINITY  OldSA = AccountContext->TypeBody.User.SiteAffinity;
    SAMP_SITE_AFFINITY  NewSA;
    BOOLEAN fDeleteOld = FALSE;

#define MAX_SUCCESS_LOGON_ATTS  6

    ATTR          Attrs[MAX_SUCCESS_LOGON_ATTS];
    ULONG         Operations[MAX_SUCCESS_LOGON_ATTS];

    ATTRVAL LastLogonAttrVal = {sizeof(LastLogon),(UCHAR *)&LastLogon};
    ATTRVAL LogonCountAttrVal = {sizeof(LogonCount),(UCHAR *)&LogonCount};
    ATTRVAL BadPasswordAttrVal = {sizeof(BadPasswordCount),(UCHAR *)&BadPasswordCount};
    ATTRVAL OldSAAttrVal = {sizeof(OldSA),(UCHAR *)&OldSA};
    ATTRVAL NewSAAttrVal = {sizeof(NewSA),(UCHAR *)&NewSA};
    ATTRVAL LastLogonTimeStampAttrVal = {sizeof(NewLastLogonTimeStamp), (UCHAR *)&NewLastLogonTimeStamp};

    ATTRBLOCK LogonStatAttrblock;
    ULONG attrCount = 0;

    RtlSecureZeroMemory(&LogonStatAttrblock, sizeof(LogonStatAttrblock));
    LogonStatAttrblock.pAttr = Attrs;
    LogonStatAttrblock.attrCount = 0;

    if ((Flags & USER_LOGON_NO_WRITE) == 0) {

        // Always update the last logon
        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LAST_LOGON;
        Attrs[attrCount].AttrVal.valCount = 1;
        Attrs[attrCount].AttrVal.pAVal = &LastLogonAttrVal;
        Operations[attrCount] = REPLACE_ATT;
        attrCount++;

        // update the last logon time stamp based upon whether the
        // TimeStamp is too old or not.

        EndOfLastLogonTimeStamp = SampCalcEndOfLastLogonTimeStamp(
                                        AccountContext->TypeBody.User.LastLogonTimeStamp,
                                        LastLogonTimeStampSyncInterval
                                        );

        if ((NewLastLogonTimeStamp.QuadPart > EndOfLastLogonTimeStamp.QuadPart) &&
           (SampDefinedDomains[AccountContext->DomainIndex].BehaviorVersion
                    >= DS_BEHAVIOR_WIN_DOT_NET ))
        {
            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &LastLogonTimeStampAttrVal;
            Operations[attrCount] = REPLACE_ATT;
            attrCount++;

            // update the in memory copy
            AccountContext->TypeBody.User.LastLogonTimeStamp = NewLastLogonTimeStamp;
        }

        // Always update the logon count
        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LOGON_COUNT;
        Attrs[attrCount].AttrVal.valCount = 1;
        Attrs[attrCount].AttrVal.pAVal = &LogonCountAttrVal;
        Operations[attrCount] = REPLACE_ATT;
        attrCount++;

        //
        // If the bad password count was already a 0 then no need to update it
        // once again
        //
        NtStatus = SampRetrieveUserV1aFixed(
                        AccountContext,
                        &OldV1aFixed
                        );

        if (!NT_SUCCESS(NtStatus) ||
                (OldV1aFixed.BadPasswordCount!=BadPasswordCount))
        {
            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_BAD_PWD_COUNT;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &BadPasswordAttrVal;
            Operations[attrCount] = REPLACE_ATT;
            attrCount++;
        }
    }

    //
    // Determine if the site affinity needs updating
    //
    if (SampCheckForSiteAffinityUpdate(AccountContext,
                                      Flags,
                                      &OldSA,
                                      &NewSA,
                                      &fDeleteOld)) {


        NTSTATUS Status2;

        //
        // N.B. In this case the site affinity on the AccountContext is
        // cached, so refresh the site affinity and reevaluate
        //
        Status2 = SampRefreshSiteAffinity(AccountContext);
        if (NT_SUCCESS(Status2)) {

            OldSA = AccountContext->TypeBody.User.SiteAffinity;
            if (SampCheckForSiteAffinityUpdate(AccountContext,
                                              Flags,
                                              &OldSA,
                                              &NewSA,
                                              &fDeleteOld)) {

            if (fDeleteOld) {
                Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                Attrs[attrCount].AttrVal.valCount = 1;
                Attrs[attrCount].AttrVal.pAVal = &OldSAAttrVal;
                Operations[attrCount] = REMOVE_VALUE;
                attrCount++;
            }

            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &NewSAAttrVal;
            Operations[attrCount] = ADD_VALUE;
            attrCount++;
            }
        }
    }
    LogonStatAttrblock.attrCount = attrCount;


    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context. If the previous call to
    // Retrieve V1a Fixed failed, then still go an try to update the
    // logon statics anyway. The useful performance optimizations of reducing
    // updates to Bad password count does not come into play though
    //

    if (attrCount > 0) {

        NtStatus = SampDsSetAttributesEx(
                        AccountContext->ObjectNameInDs,
                        SAM_LAZY_COMMIT,
                        Operations,
                        SampUserObjectType,
                        &LogonStatAttrblock
                        );
    }

    return NtStatus;
}

NTSTATUS
SampDsFailedLogonSet(
   IN PSAMP_OBJECT AccountContext,
   IN ULONG        Flags,
   IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
   )
/*++

    Routine Description

        This routine, sets just the attributes corresponding to logon statistics,
        as opposed to writing out the user fixed attributes, which results in a
        large number of attributes being written out during every logon. This is
        called on failed logons.

    Parameters

        AccountContext -- Sam context for the user account.

        Flags -- the client flags indicating the nature of the failed logon

        V1aFixed       -- Pointer to a structure containing the modified properties

    Return Values

        STATUS_SUCCESS
        Other Error codes from the flushing
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (Flags & USER_LOGON_NO_LOGON_SERVERS) {

        //
        // Simply check if the site affinity needs updating
        //
        SAMP_SITE_AFFINITY  OldSA = AccountContext->TypeBody.User.SiteAffinity;
        SAMP_SITE_AFFINITY  NewSA;
        BOOLEAN fDeleteOld;
        ATTR Attrs[2];
        ULONG Operations[2];
        ATTRVAL OldSAAttrVal = {sizeof(OldSA),(UCHAR *)&OldSA};
        ATTRVAL NewSAAttrVal = {sizeof(NewSA),(UCHAR *)&NewSA};
        ATTRBLOCK AttrBlock;
        ULONG attrCount = 0;

        RtlSecureZeroMemory(&AttrBlock, sizeof(AttrBlock));

        if (SampCheckForSiteAffinityUpdate(AccountContext,
                                           Flags,
                                          &OldSA,
                                          &NewSA,
                                          &fDeleteOld)) {

            NTSTATUS Status2;

            //
            // N.B. In this case the site affinity on the AccountContext is
            // cached, so refresh the site affinity and reevaluate
            //
            Status2 = SampRefreshSiteAffinity(AccountContext);
            if (NT_SUCCESS(Status2)) {

                OldSA = AccountContext->TypeBody.User.SiteAffinity;
                if (SampCheckForSiteAffinityUpdate(AccountContext,
                                                   Flags,
                                                  &OldSA,
                                                  &NewSA,
                                                  &fDeleteOld)) {

                    if (fDeleteOld) {
                        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                        Attrs[attrCount].AttrVal.valCount = 1;
                        Attrs[attrCount].AttrVal.pAVal = &OldSAAttrVal;
                        Operations[attrCount] = REMOVE_VALUE;
                        attrCount++;
                    }

                    Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                    Attrs[attrCount].AttrVal.valCount = 1;
                    Attrs[attrCount].AttrVal.pAVal = &NewSAAttrVal;
                    Operations[attrCount] = ADD_VALUE;
                    attrCount++;

                    AttrBlock.pAttr = Attrs;
                    AttrBlock.attrCount = attrCount;

                    NtStatus = SampDsSetAttributesEx(
                                    AccountContext->ObjectNameInDs,
                                    AccountContext->LazyCommit?SAM_LAZY_COMMIT:0,
                                    Operations,
                                    SampUserObjectType,
                                    &AttrBlock
                                    );
                }
            }
        }

    } else {

        LARGE_INTEGER LastBadPasswordTime = V1aFixed->LastBadPasswordTime;
        ULONG         BadPasswordCount = (ULONG) V1aFixed->BadPasswordCount;

        ATTRTYP       LogonStatAttrs[]={
                                            SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME,
                                            SAMP_FIXED_USER_BAD_PWD_COUNT
                                       };
        ATTRVAL       LogonStatValues[]={
                                            {sizeof(LastBadPasswordTime),(UCHAR *) &LastBadPasswordTime},
                                            {sizeof(BadPasswordCount),(UCHAR *) &BadPasswordCount}
                                        };

        DEFINE_ATTRBLOCK2(LogonStatAttrblock,LogonStatAttrs,LogonStatValues);


        //
        // On failure, we always would want to update the user object
        //
        ASSERT( (Flags & USER_LOGON_NO_WRITE) == 0 );

        //
        // Make the Ds call to directly set the attribute. Take into account,
        // lazy commit settings in the context. If the previous call to
        // Retrieve V1a Fixed failed, then still go an try to update the
        // logon statics anyway. The useful performance optimizations of reducing
        // updates to Bad password count does not come into play though
        //
        NtStatus = SampDsSetAttributes(
                        AccountContext->ObjectNameInDs,
                        0, // No lazy commit for failed logons.
                        REPLACE_ATT,
                        SampUserObjectType,
                        &LogonStatAttrblock
                        );
    }



    return NtStatus;
}



NTSTATUS
SamrSetInformationUser2(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer
    )
{
    //
    // This is a thin veil to SamrSetInformationUser().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //


    return( SamrSetInformationUser(
                UserHandle,
                UserInformationClass,
                Buffer
                ) );
}

NTSTATUS
SamrSetInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer
    )


/*++

Routine Description:


    This API modifies information in a user record.  The data modified
    is determined by the UserInformationClass parameter.
    In general, a user may call GetInformation with class
    UserLogonInformation, but may only call SetInformation with class
    UserPreferencesInformation.  Access type USER_WRITE_ACCOUNT allows
    changes to be made to all fields.

    NOTE: If the password is set to a new password then the password-
    set timestamp is reset as well.



Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information provided.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ------------------------
        UserGeneralInformation          USER_WRITE_ACCOUNT and
                                        USER_WRITE_PREFERENCES

        UserPreferencesInformation      USER_WRITE_PREFERENCES

        UserParametersInformation       USER_WRITE_ACCOUNT

        UserLogonInformation            (Can't set)

        UserLogonHoursInformation       USER_WRITE_ACCOUNT

        UserAccountInformation          (Can't set)

        UserNameInformation             USER_WRITE_ACCOUNT
        UserAccountNameInformation      USER_WRITE_ACCOUNT
        UserFullNameInformation         USER_WRITE_ACCOUNT
        UserPrimaryGroupInformation     USER_WRITE_ACCOUNT
        UserHomeInformation             USER_WRITE_ACCOUNT
        UserScriptInformation           USER_WRITE_ACCOUNT
        UserProfileInformation          USER_WRITE_ACCOUNT
        UserAdminCommentInformation     USER_WRITE_ACCOUNT
        UserWorkStationsInformation     USER_WRITE_ACCOUNT
        UserSetPasswordInformation      USER_FORCE_PASSWORD_CHANGE
        UserControlInformation          USER_WRITE_ACCOUNT
        UserExpiresInformation          USER_WRITE_ACCOUNT

        UserInternal1Information        USER_FORCE_PASSWORD_CHANGE
        UserInternal2Information        (Trusted client only)
        UserInternal3Information        (Trusted client only) -
        UserInternal4Information        Similar to All Information
        UserInternal5Information        Similar to SetPassword
        UserAllInformation              Will set fields that are
                                        requested by caller.  Access
                                        to fields to be set must be
                                        held as defined above.


    Buffer - Buffer containing a user info struct.



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS,
                            IgnoreStatus;

    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT) UserHandle;

    PUSER_ALL_INFORMATION   All = NULL;

    SAMP_OBJECT_TYPE        FoundType;

    PSAMP_DEFINED_DOMAINS   Domain;

    ACCESS_MASK             DesiredAccess;

    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    UNICODE_STRING          OldAccountName,
                            ApiList,
                            NewAdminComment,
                            NewAccountName,
                            NewFullName,
                            *NewAccountNameToRemove = NULL;

    NT_OWF_PASSWORD         NtOwfPassword;

    LM_OWF_PASSWORD         LmOwfPassword;

    USER_SESSION_KEY        UserSessionKey;

    BOOLEAN                 LmPresent;
    BOOLEAN                 NtPresent;
    BOOLEAN                 PasswordExpired = FALSE;

    ULONG                   ObjectRid,
                            OldUserAccountControl = 0,
                            OldPrimaryGroupId = 0,
                            DomainIndex,
                            LocalLastLogonTimeStampSyncInterval;
                      
    BOOLEAN                 UserAccountControlChanged = FALSE,
                            MustUpdateAccountDisplay = FALSE,
                            MustQueryV1aFixed = TRUE,
                            ReplicateImmediately = FALSE,
                            TellNetlogon = TRUE,
                            AccountGettingMorphed = FALSE,
                            SystemChangesPrimaryGroupId = FALSE,
                            KeepOldPrimaryGroupMembership = FALSE,
                            AccountLockedOut,
                            fLockAcquired = FALSE,
                            RemoveAccountNameFromTable = FALSE,
                            AccountUnlocked = FALSE,
                            fSetUserPassword = FALSE,
                            fCanUnexpirePassword = FALSE;

    SECURITY_DB_DELTA_TYPE  DeltaType = SecurityDbChange;
    UNICODE_STRING          ClearTextPassword;
    BOOLEAN                 ClearTextPasswordPresent = FALSE;
    UNICODE_STRING          AccountName;
    ULONG                   UserRid = 0;
    BOOLEAN                 PrivilegedMachineAccountCreate=FALSE;
    BOOLEAN                 FlushOnlyLogonProperties = FALSE;

    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    UNICODE_STRING          PasswordToNotify;
    GUID                    UserGuidToReplicateLocally = {0};
    GUID                    NullGuid = {0};


    SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(RequestedAttributes)



    TIME_FIELDS
        T1;

    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrSetInformationUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationUser
                   );

    //
    // Initialization.
    //

    ClearTextPassword.Buffer = NULL;
    ClearTextPassword.Length = 0;
    AccountName.Buffer = NULL;
    SAMP_INIT_SAM_ATTRIBUTE_BITMASK(RequestedAttributes)

    //
    // Reset any strings that we'll be freeing in clean-up code
    //

    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);
    RtlInitUnicodeString(&NewFullName, NULL);
    RtlInitUnicodeString(&NewAdminComment, NULL);

    RtlSecureZeroMemory(&PasswordToNotify,sizeof(UNICODE_STRING));

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    if (Buffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Set the desired access based upon the Info class
    //

    switch (UserInformationClass) {

    case UserPreferencesInformation:
        DesiredAccess = USER_WRITE_PREFERENCES;
        break;

    case UserParametersInformation:
    case UserLogonHoursInformation:
    case UserNameInformation:
    case UserAccountNameInformation:
    case UserFullNameInformation:
    case UserPrimaryGroupInformation:
    case UserHomeInformation:
    case UserScriptInformation:
    case UserProfileInformation:
    case UserAdminCommentInformation:
    case UserWorkStationsInformation:
    case UserControlInformation:
    case UserExpiresInformation:

        DesiredAccess = USER_WRITE_ACCOUNT;
        break;

    case UserSetPasswordInformation:
    case UserInternal1Information:
    case UserInternal5Information:
    case UserInternal5InformationNew:

        DeltaType = SecurityDbChangePassword;
        DesiredAccess = USER_FORCE_PASSWORD_CHANGE;
        break;



    case UserAllInformation:
    case UserInternal3Information:
    case UserInternal4Information:
    case UserInternal4InformationNew:

        //////////////////////////////////////////////////////////////
        //                                                          //
        //  !!!! WARNING !!!!                                       //
        //                                                          //
        //  Be warned that the buffer structure for                 //
        //  UserInternal3/4Information MUST begin with the same     //
        //  structure as UserAllInformation.                        //
        //                                                          //
        //////////////////////////////////////////////////////////////

        DesiredAccess = 0;

        All = (PUSER_ALL_INFORMATION)Buffer;

        if ( ( All->WhichFields == 0 ) ||
            ( All->WhichFields & USER_ALL_WRITE_CANT_MASK ) ) {

            //
            // Passed in something (no fields to set), or is
            // trying to set fields that can't be set.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }

        //
        // If the user is the special account Administrator, return an
        // error if trying to set the expiry information, except to the value
        // that means that the account never expires.
        //

        if ( (All->WhichFields & USER_ALL_ACCOUNTEXPIRES) &&
             (!(AccountContext->TrustedClient)) &&
             ( AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN )) {

            LARGE_INTEGER AccountNeverExpires, Temp;

            AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                      SAMP_ACCOUNT_NEVER_EXPIRES
                                      );

            OLD_TO_NEW_LARGE_INTEGER(All->AccountExpires, Temp);

            if (!( Temp.QuadPart == AccountNeverExpires.QuadPart)) {

                NtStatus = STATUS_SPECIAL_ACCOUNT;
                goto Error;
            }
        }

        //
        // If the caller is trying to set trusted values, assume the
        // caller is trusted, leave DesiredAccess = 0, and proceed.
        // We'll check to make sure caller is trusted later.
        //

        if ( !(All->WhichFields & USER_ALL_WRITE_TRUSTED_MASK) ) {

            //
            // Set desired access based on which fields the caller is
            // trying to change.
            //
            if ( All->WhichFields & USER_ALL_WRITE_ACCOUNT_MASK ) {

                DesiredAccess |= USER_WRITE_ACCOUNT;
            }

            if ( All->WhichFields & USER_ALL_WRITE_PREFERENCES_MASK ) {

                DesiredAccess |= USER_WRITE_PREFERENCES;
            }


            if ( All->WhichFields & USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK ) {

                DesiredAccess |= USER_FORCE_PASSWORD_CHANGE;
            }

            ASSERT( DesiredAccess != 0 );
        }


        break;

    case UserInternal2Information:

        //
        // These levels are only setable by trusted clients.  The code
        // below will check AccountContext->TrustedClient after calling
        // SampLookupContext, and only set the data if it is TRUE.
        //

        DesiredAccess = (ACCESS_MASK)0;    // trusted client; no need to verify
        break;

    case UserGeneralInformation:
    case UserAccountInformation:
    case UserLogonInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;
    PrivilegedMachineAccountCreate =
            AccountContext->TypeBody.User.PrivilegedMachineAccountCreate;

    //
    // Compensating logic for NET API.
    // If privilege was used to create machine accounts, then mask the
    // which fields bit to just the password
    //

    if ((UserAllInformation==UserInformationClass)
            && (PrivilegedMachineAccountCreate))
    {
         All->WhichFields &= USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK;
         DesiredAccess = USER_FORCE_PASSWORD_CHANGE;
    }


    //
    // Only Proceed without grabbing the write lock, if
    // UserInternal2Information is being set on a thread
    // safe context
    //

    if ((!AccountContext->NotSharedByMultiThreads || !IsDsObject(AccountContext)) ||
        (UserInternal2Information!=UserInformationClass))
    {
        //
        // Grab the lock, if required
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus))
        {
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }

        fLockAcquired = TRUE;

        //
        // Determine what attributes will be referenced
        //
        SampGetRequestedAttributesForUser(UserInformationClass,
                                          All ? All->WhichFields : 0,
                                         &RequestedAttributes);


        //
        // Perform a lookup context, for non thread safe context's.
        //

        NtStatus = SampLookupContextEx(
                        AccountContext,
                        DesiredAccess,
                        SampUseDsData ? (&RequestedAttributes) : NULL,
                        SampUserObjectType,           // ExpectedType
                        &FoundType
                        );

    }
    else
    {

        //
        // For a thread safe context, writing just logon
        // statistics , just reference the context
        //

        //ASSERT(AccountContext->TrustedClient);
        SampReferenceContext(AccountContext);
    }

    if( NT_SUCCESS( NtStatus ) ) {
        //
        // Check input parameters
        //
        NtStatus = SampValidateUserInfoBuffer(
                        Buffer,
                        UserInformationClass,
                        AccountContext->TrustedClient
                        );
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // get a local copy of LastLogonTimeStampSyncInterval
        //

        LocalLastLogonTimeStampSyncInterval =
            SampDefinedDomains[DomainIndex].LastLogonTimeStampSyncInterval;

        //
        // Get the user's rid. This is used for notifying other
        // packages of a password change.
        //

        UserRid = AccountContext->TypeBody.User.Rid;


        //
        // If this information level contains reversibly encrypted passwords
        // it is not allowed if the DOMAIN_PASSWORD_NO_CLEAR_CHANGE bit is
        // set.  If that happens, return an error indicating that
        // the older information level should be used.
        //

        if ((UserInformationClass == UserInternal4Information) ||
            (UserInformationClass == UserInternal4InformationNew) ||
            (UserInformationClass == UserInternal5Information) ||
            (UserInformationClass == UserInternal5InformationNew) ) {

            if (Domain->UnmodifiedFixed.PasswordProperties &
                DOMAIN_PASSWORD_NO_CLEAR_CHANGE) {

                NtStatus = RPC_NT_INVALID_TAG;
            }

        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If the information level requires, retrieve the V1_FIXED
            // record from the registry.  We need to fetch V1_FIXED if we
            // are going to change it or if we need the AccountControl
            // flags for display cache updating.
            //
            // The following information levels change data that is in the cached
            // display list.
            //

            switch (UserInformationClass) {

            case UserAllInformation:
            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                if ( ( All->WhichFields &
                    ( USER_ALL_USERNAME | USER_ALL_FULLNAME |
                    USER_ALL_ADMINCOMMENT | USER_ALL_USERACCOUNTCONTROL ) )
                    == 0 ) {

                    //
                    // We're not changing any of the fields in the display
                    // info, we don't update the account display.
                    //

                    break;
                }

            case UserControlInformation:
            case UserNameInformation:
            case UserAccountNameInformation:
            case UserFullNameInformation:
            case UserAdminCommentInformation:

                MustUpdateAccountDisplay = TRUE;
            }

            //
            // These levels involve updating the V1aFixed structure
            //

            switch (UserInformationClass) {

            case UserAllInformation:

                 MustQueryV1aFixed = TRUE;

            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                //
                // Earlier, we might have just trusted that the caller
                // was a trusted client.  Check it out here.
                //

                if (  ( DesiredAccess == 0 ) &&
                    ( !AccountContext->TrustedClient ) ) {

                    NtStatus = STATUS_ACCESS_DENIED;
                    break;
                }

                //
                // Otherwise fall through
                //

            case UserPreferencesInformation:
            case UserPrimaryGroupInformation:
            case UserControlInformation:
            case UserExpiresInformation:
            case UserSetPasswordInformation:
            case UserInternal1Information:
            case UserInternal2Information:
            case UserInternal5Information:
            case UserInternal5InformationNew:

                MustQueryV1aFixed = TRUE;

                break;

            default:

                NtStatus = STATUS_SUCCESS;

            } // end_switch


        }

        if ( NT_SUCCESS( NtStatus ) &&
            ( MustQueryV1aFixed || MustUpdateAccountDisplay ) ) {

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // Store away the old account control flags for cache update
                //

                OldUserAccountControl = V1aFixed.UserAccountControl;

                //
                // Store away the old Primary Group Id for detecting wether we need
                // to modify the user's membership
                //

                OldPrimaryGroupId = V1aFixed.PrimaryGroupId;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (UserInformationClass) {

            case UserAllInformation:
            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                //
                // Set the string data
                //

                if ( All->WhichFields & USER_ALL_WORKSTATIONS ) {

                    if ( (All->WorkStations.Length > 0) &&
                         (All->WorkStations.Buffer == NULL) ) {

                         NtStatus = STATUS_INVALID_PARAMETER;
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        if ( !AccountContext->TrustedClient ) {

                            //
                            // Convert the workstation list, which is given
                            // to us in UI/Service format, to API list format
                            // before storing it.  Note that we don't do this
                            // for trusted clients, since they're just
                            // propogating data that has already been
                            // converted.
                            //

                            NtStatus = SampConvertUiListToApiList(
                                           &(All->WorkStations),
                                           &ApiList,
                                           FALSE );
                        } else {
                            ApiList = All->WorkStations;
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        NtStatus = SampSetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_WORKSTATIONS,
                                       &ApiList
                                       );
                    }
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERNAME ) ) {

                    NtStatus = SampChangeUserAccountName(
                                    AccountContext,
                                    &(All->UserName),
                                    V1aFixed.UserAccountControl,
                                    &OldAccountName
                                    );

                    if (!NT_SUCCESS(NtStatus)) {

                        OldAccountName.Buffer = NULL;
                    }

                    //
                    // Get the Address of New Account Name
                    //
                    NewAccountNameToRemove = &(All->UserName);

                    //
                    // RemoveAccountNameFromTable tells us whether
                    // the caller (this routine) is responsable
                    // to remove the name from the table.
                    //
                    RemoveAccountNameFromTable =
                        AccountContext->RemoveAccountNameFromTable;

                    //
                    // reset to FALSE
                    //
                    AccountContext->RemoveAccountNameFromTable = FALSE;
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_FULLNAME ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   &(All->FullName)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_HOMEDIRECTORY ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   &(All->HomeDirectory)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_HOMEDIRECTORYDRIVE ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   &(All->HomeDirectoryDrive)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_SCRIPTPATH ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   &(All->ScriptPath)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PROFILEPATH ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   &(All->ProfilePath)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_ADMINCOMMENT ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   &(All->AdminComment)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERCOMMENT ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   &(All->UserComment)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PARAMETERS ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PARAMETERS,
                                   &(All->Parameters)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_LOGONHOURS ) ) {

                    //
                    // Set the LogonHours
                    //

                    NtStatus = SampReplaceUserLogonHours(
                                   AccountContext,
                                   &(All->LogonHours)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) && (
                    ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) ||
                    ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) ) ) {

                    NT_OWF_PASSWORD     NtOwfBuffer;
                    LM_OWF_PASSWORD     LmOwfBuffer;
                    PLM_OWF_PASSWORD    TmpLmBuffer;
                    PNT_OWF_PASSWORD    TmpNtBuffer;
                    BOOLEAN             TmpLmPresent;
                    BOOLEAN             TmpNtPresent;
                    BOOLEAN             AccountControlChange = FALSE;


                    //
                    // This is a password set operation
                    //
                    fSetUserPassword = TRUE;

                    //
                    // Get the effective domain policy
                    //


                    NtStatus = SampObtainEffectivePasswordPolicy(
                                    &DomainPasswordInfo,
                                    AccountContext,
                                    TRUE
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    //
                    // Get copy of the account name to pass to
                    // notification packages.
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                    AccountContext,
                                    SAMP_USER_ACCOUNT_NAME,
                                    TRUE,    // Make copy
                                    &AccountName
                                    );

                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }


                    if ((UserInformationClass == UserInternal3Information) ||
                        ((UserInformationClass == UserAllInformation) &&
                         (!AccountContext->TrustedClient) &&
                         (!AccountContext->LoopbackClient))
                        ){


                        //
                        // Hashed passwords were sent.
                        //

                        if ( AccountContext->TrustedClient ) {

                            //
                            // Set password buffers as trusted client has
                            // indicated.
                            //

                            if ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)All->LmPassword.Buffer;
                                TmpLmPresent = All->LmPasswordPresent;

                            } else {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)NULL;
                                TmpLmPresent = FALSE;
                            }

                            if ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)All->NtPassword.Buffer;
                                TmpNtPresent = All->NtPasswordPresent;

                            } else {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)NULL;
                                TmpNtPresent = FALSE;
                            }

                        } else {

                            //
                            // This call came from the client-side.
                            // The OWFs will have been encrypted with the session
                            // key across the RPC link.
                            //
                            // Get the session key and decrypt both OWFs
                            //

                            NtStatus = RtlGetUserSessionKeyServer(
                                           (RPC_BINDING_HANDLE)UserHandle,
                                           &UserSessionKey
                                           );

                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }

                            //
                            // Decrypt the LM OWF Password with the session key
                            //

                            if ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) {

                                NtStatus = RtlDecryptLmOwfPwdWithUserKey(
                                               (PENCRYPTED_LM_OWF_PASSWORD)
                                                   All->LmPassword.Buffer,
                                               &UserSessionKey,
                                               &LmOwfBuffer
                                               );
                                if ( !NT_SUCCESS( NtStatus ) ) {
                                    break; // out of switch
                                }

                                TmpLmBuffer = &LmOwfBuffer;
                                TmpLmPresent = All->LmPasswordPresent;

                            } else {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)NULL;
                                TmpLmPresent = FALSE;
                            }

                            //
                            // Decrypt the NT OWF Password with the session key
                            //

                            if ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                NtStatus = RtlDecryptNtOwfPwdWithUserKey(
                                               (PENCRYPTED_NT_OWF_PASSWORD)
                                               All->NtPassword.Buffer,
                                               &UserSessionKey,
                                               &NtOwfBuffer
                                               );

                                if ( !NT_SUCCESS( NtStatus ) ) {
                                    break; // out of switch
                                }

                                TmpNtBuffer = &NtOwfBuffer;
                                TmpNtPresent = All->NtPasswordPresent;

                            } else {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)NULL;
                                TmpNtPresent = FALSE;
                            }

                        }

                    } else {


                        AccountControlChange = ((All->WhichFields & USER_ALL_USERACCOUNTCONTROL)!=0);

                        if ((UserInformationClass == UserInternal4Information) ||
                            (UserInformationClass == UserInternal4InformationNew)) {

                            //
                            // The clear text password was sent, so use that.
                            //

                            NtStatus = SampDecryptPasswordWithSessionKey(
                                            UserHandle,
                                            UserInformationClass,
                                            Buffer,
                                            &ClearTextPassword
                                            );
                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                        } else {

                            //
                            // Only trusted callers should be able to do this.
                            // DaveStr - 7/15/97 - Also add this capability for
                            // the loopback client who has the password in
                            // clear text and is passing it to SAM within the
                            // the process boundary - i.e. clear text is not
                            // going on the wire.  DS mandated that *it* got
                            // the password on a secure/encrypted connection.
                            //
                            //

                            if (    !AccountContext->TrustedClient
                                 && !AccountContext->LoopbackClient ) {
                                NtStatus = STATUS_ACCESS_DENIED;
                                break;
                            }
                            ASSERT(UserInformationClass == UserAllInformation);

                            //
                            // In this case the password is in the NtPassword
                            // field
                            //

                            NtStatus = SampDuplicateUnicodeString(
                                            &ClearTextPassword,
                                            &All->NtPassword
                                            );
                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                        }

                        //
                        // Compute the hashed passwords.
                        //

                        NtStatus = SampCalculateLmAndNtOwfPasswords(
                                        &ClearTextPassword,
                                        &TmpLmPresent,
                                        &LmOwfBuffer,
                                        &NtOwfBuffer
                                        );
                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }


                        TmpNtPresent = TRUE;
                        TmpLmBuffer = &LmOwfBuffer;
                        TmpNtBuffer = &NtOwfBuffer;

                        ClearTextPasswordPresent = TRUE;
                    }

                    //
                    // Set the password data
                    //


                    NtStatus=SampStoreUserPasswords(
                                AccountContext,
                                TmpLmBuffer,
                                TmpLmPresent,
                                TmpNtBuffer,
                                TmpNtPresent,
                                TRUE, // Check Password Restrictions
                                PasswordSet,
                                &DomainPasswordInfo,
                                ClearTextPasswordPresent?&ClearTextPassword:NULL,
                                AccountControlChange?&All->UserAccountControl:NULL,
                                &PasswordToNotify,
                                NULL
                                );

                    //
                    // Once we set the password,
                    // if client can unexpire user password, 
                    //    set PwdLastSet to current time - don't expire pwd now
                    // otherwise
                    //    set PwdLastSet to 0 - expire the password immediatedly
                    // 
                    //

                    if ( NT_SUCCESS( NtStatus ) ) 
                    {

                        NtStatus = SampIsPwdSettingAttemptGranted(
                                        AccountContext, 
                                        NULL,   // client token
                                        V1aFixed.UserAccountControl,
                                        (GUID *) &GUID_CONTROL_UnexpirePassword,
                                        &fCanUnexpirePassword
                                        );

                        if ( NT_SUCCESS(NtStatus) )
                        {
                            NtStatus = SampComputePasswordExpired(
                                        fCanUnexpirePassword ? FALSE : TRUE,
                                        &V1aFixed.PasswordLastSet
                                        );
                        }
                    }


                    //
                    // Replicate immediately if this is a machine account
                    //

                    if ( (V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) ||
                         ((All->WhichFields & USER_ALL_USERACCOUNTCONTROL ) &&
                          (All->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) )) {
                        ReplicateImmediately = TRUE;
                    }
                    DeltaType = SecurityDbChangePassword;

                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PASSWORDEXPIRED ) ) {

                    if ( !(All->PasswordExpired) )
                    {
                        //
                        // check whether the client can UnExpire Password.
                        // 1) no special access check for ExpirePassword operation
                        // 2) computer accounts are not subject to this access check
                        // 

                        NtStatus = SampValidatePwdSettingAttempt(
                                            AccountContext,     // account context
                                            NULL,               // client token
                                            V1aFixed.UserAccountControl,
                                            (GUID *) &GUID_CONTROL_UnexpirePassword
                                            );
                    }

                    if (NT_SUCCESS(NtStatus))
                    {

                        //
                        // If the PasswordExpired field is passed in,
                        //  Only update PasswordLastSet if the password is being
                        //  forced to expire or if the password is currently forced
                        //  to expire.
                        //
                        // Avoid setting the PasswordLastSet field to the current
                        // time if it is already non-zero.  Otherwise, the field
                        // will slowly creep forward each time this function is
                        // called and the password will never expire.
                        //
                        if ( All->PasswordExpired ||
                             (SampHasNeverTime.QuadPart == V1aFixed.PasswordLastSet.QuadPart) ) {

                            NtStatus = SampComputePasswordExpired(
                                            All->PasswordExpired,
                                            &V1aFixed.PasswordLastSet
                                            );
                        }

                        PasswordExpired = All->PasswordExpired;

                    }

                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PRIVATEDATA ) ) {

                    //
                    // Set the private data
                    //

                    NtStatus = SampSetPrivateUserData(
                                   AccountContext,
                                   All->PrivateData.Length,
                                   All->PrivateData.Buffer
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_SECURITYDESCRIPTOR ) ) {

                    //
                    // Should validate SD first, for both
                    // DS and Registry cases
                    //

                    NtStatus = SampValidatePassedSD(
                                    All->SecurityDescriptor.Length,
                                    (PISECURITY_DESCRIPTOR_RELATIVE) (All->SecurityDescriptor.SecurityDescriptor)
                                    );


                    if ( NT_SUCCESS(NtStatus) )
                    {
                        if (IsDsObject(AccountContext))
                        {
                            PSECURITY_DESCRIPTOR Nt4SD =
                               All->SecurityDescriptor.SecurityDescriptor;

                            PSECURITY_DESCRIPTOR Nt5SD = NULL;
                            ULONG                Nt5SDLength = 0;


                            //
                            // Upgrade the security descriptor to NT5 and set it
                            // on the object for trusted clients. For non trusted
                            // clients. Fail the call for non trusted clients. They
                            // should come in through SamrSetSecurityObject
                            //

                            if (AccountContext->TrustedClient)
                            {
                                NtStatus = SampConvertNt4SdToNt5Sd(
                                            Nt4SD,
                                            AccountContext->ObjectType,
                                            AccountContext,
                                            &(Nt5SD)
                                            );
                            }
                            else
                            {
                                NtStatus = STATUS_ACCESS_DENIED;
                            }


                            if (NT_SUCCESS(NtStatus))
                            {

                               ASSERT(Nt5SD!=NULL);

                               //
                               // Get the length
                               //

                               Nt5SDLength = GetSecurityDescriptorLength(Nt5SD);

                               //
                               // Set the security descriptor
                               //

                               NtStatus = SampSetAccessAttribute(
                                           AccountContext,
                                           SAMP_USER_SECURITY_DESCRIPTOR,
                                           Nt5SD,
                                           Nt5SDLength
                                           );

                               //
                               // Free the NT5 Security descriptor
                               //

                               MIDL_user_free(Nt5SD);


                            }
                        }
                        else
                        {
                            //
                            // Set the security descriptor
                            //

                            NtStatus = SampSetAccessAttribute(
                                           AccountContext,
                                           SAMP_USER_SECURITY_DESCRIPTOR,
                                           All->SecurityDescriptor.SecurityDescriptor,
                                           All->SecurityDescriptor.Length
                                           );
                        }
                    }
                }

                //
                // Set the fixed data
                //
                // Note that PasswordCanChange and PasswordMustChange
                // aren't stored; they're calculated when needed.
                //

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERACCOUNTCONTROL ) ) {


                    if (!(All->WhichFields & USER_ALL_PRIMARYGROUPID))
                    {
                        //
                        // If caller is not specifying primary group id also, then
                        // change the primary group to the new defaults if necessary
                        //

                        SystemChangesPrimaryGroupId = TRUE;
                    }

                    NtStatus = SampSetUserAccountControl(
                                    AccountContext,
                                    All->UserAccountControl,
                                    &V1aFixed,
                                    SystemChangesPrimaryGroupId,
                                    &AccountUnlocked,
                                    &AccountGettingMorphed,
                                    &KeepOldPrimaryGroupMembership
                                    );
                                             
                    if (AccountGettingMorphed &&
                        (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                       )
                    {
                        //
                        // in this case, system automatically changes the primary
                        // group id. Patch this case.
                        //
                        SystemChangesPrimaryGroupId = TRUE;
                    }

                    if (( NT_SUCCESS( NtStatus ) ) && AccountGettingMorphed) {

                            //
                            // One or more of the machine account bits has
                            // changed; we'll notify netlogon below.
                            //

                            UserAccountControlChanged = TRUE;

                            IgnoreStatus = SampGetUnicodeStringAttribute(
                                               AccountContext,
                                               SAMP_USER_ACCOUNT_NAME,
                                               TRUE, // Make copy
                                               &OldAccountName
                                               );

                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    if ( All->WhichFields & USER_ALL_LASTLOGON ) {

                        //
                        // Only trusted client can modify this field
                        //
                        if (AccountContext->TrustedClient)
                        {
                            V1aFixed.LastLogon = All->LastLogon;

                            //
                            // update Last Logon TimeStamp (Only in DS Mode)
                            //

                            NtStatus = SampDsUpdateLastLogonTimeStamp(
                                                AccountContext,
                                                V1aFixed.LastLogon,
                                                LocalLastLogonTimeStampSyncInterval
                                                );

                            if (!NT_SUCCESS(NtStatus))
                            {
                                break;
                            }
                        }
                        else
                        {
                            NtStatus = STATUS_ACCESS_DENIED;
                            break;
                        }
                    }

                    if ( All->WhichFields & USER_ALL_LASTLOGOFF ) {

                        if (AccountContext->TrustedClient)
                        {
                            V1aFixed.LastLogoff = All->LastLogoff;
                        }
                        else
                        {
                            NtStatus = STATUS_ACCESS_DENIED;
                            break;
                        }
                    }

                    if ( All->WhichFields & USER_ALL_PASSWORDLASTSET ) {

                        //
                        // PasswordLastSet == 0 ===> Password Expired
                        // PasswordLastSet != 0 ===> Password Unexpired
                        //
                        // 1) if client tried to Unexpire password, check 
                        //    whether DS Control Access right is granted or not
                        // 
                        // 2) computer accounts are not subject to this access check
                        // 

                        if (All->PasswordLastSet.QuadPart != 0i64)
                        {
                            NtStatus = SampValidatePwdSettingAttempt(
                                            AccountContext, // account context
                                            NULL,           // client token
                                            V1aFixed.UserAccountControl,
                                            (GUID *) &GUID_CONTROL_UnexpirePassword
                                            );

                            if ( !NT_SUCCESS(NtStatus) )
                            {
                                break;
                            }
                        }

                        V1aFixed.PasswordLastSet = All->PasswordLastSet;
                    }

                    if ( All->WhichFields & USER_ALL_ACCOUNTEXPIRES ) {

                        V1aFixed.AccountExpires = All->AccountExpires;
                    }

                    if ( All->WhichFields & USER_ALL_PRIMARYGROUPID ) {

                        if (IsDsObject(AccountContext) &&
                            (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                            (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
                           )
                        {
                            //
                            // Domain Controller's Primary Group should ALWAYS be
                            // DOMAIN_GROUP_RID_CONTROLLERS
                            //
                            // For NT4 and earlier release, we do not enforce the above rule,
                            // therefore compensate here is change the error code to success.
                            //
                            // For all interim NT5 releases (until beta2), since their DC's
                            // primary group Id might have been changed, so by checking
                            // V1aFixed.PrimaryGroupId, we still allow them to change their
                            // DC's primary group id. But once it has been set back to
                            // RID_CONTROLLERS, we do not let them go any further.
                            //

                            if (!AccountContext->LoopbackClient &&
                                (DOMAIN_GROUP_RID_USERS==All->PrimaryGroupId))
                            {
                                // Come throught NT4
                                NtStatus = STATUS_SUCCESS;
                            }
                            else if (DOMAIN_GROUP_RID_CONTROLLERS == All->PrimaryGroupId)
                            {
                                NtStatus = STATUS_SUCCESS;
                            }
                            else
                            {
                                NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
                                break;
                            }
                        }
                        else
                        {
                            //
                            // Make sure the primary group is legitimate
                            // (it must be one the user is a member of)
                            //
                            NtStatus = SampAssignPrimaryGroup(
                                           AccountContext,
                                           All->PrimaryGroupId
                                           );
                            if (NT_SUCCESS(NtStatus)) {

                                KeepOldPrimaryGroupMembership = TRUE;
                                V1aFixed.PrimaryGroupId = All->PrimaryGroupId;

                            } else if ((DOMAIN_GROUP_RID_USERS==All->PrimaryGroupId)
                                      && (V1aFixed.UserAccountControl
                                            & USER_MACHINE_ACCOUNT_MASK)) {
                               //
                               // NT4 and earlier releases during machine join
                               // set the primary group id to domain users.
                               // however the account need not necessarily be part
                               // of domain users. Therefore compensate here
                               // by changing the error code to status success

                               NtStatus = STATUS_SUCCESS;

                            } else {
                                break;
                            }
                        }
                    }

                    if ( All->WhichFields & USER_ALL_COUNTRYCODE ) {

                        V1aFixed.CountryCode = All->CountryCode;
                    }

                    if ( All->WhichFields & USER_ALL_CODEPAGE ) {

                        V1aFixed.CodePage = All->CodePage;
                    }

                    if ( All->WhichFields & USER_ALL_BADPASSWORDCOUNT ) {

                        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                                       "UserId: 0x%x BadPasswordCount set to %d\n",
                                        V1aFixed.UserId,
                                        All->BadPasswordCount));

                        V1aFixed.BadPasswordCount = All->BadPasswordCount;

                        if (UserInformationClass == UserInternal3Information) {
                            //
                            // Also set LastBadPasswordTime;
                            //
                            V1aFixed.LastBadPasswordTime =
                                Buffer->Internal3.LastBadPasswordTime;

                            RtlTimeToTimeFields(
                                           &Buffer->Internal3.LastBadPasswordTime,
                                           &T1);

                            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                                           "UserId: 0x%x LastBadPasswordTime set to: [0x%lx, 0x%lx]  %d:%d:%d\n",
                                           V1aFixed.UserId,
                                           Buffer->Internal3.LastBadPasswordTime.HighPart,
                                           Buffer->Internal3.LastBadPasswordTime.LowPart,
                                           T1.Hour, T1.Minute, T1.Second ));
                        }
                    }

                    if ( All->WhichFields & USER_ALL_LOGONCOUNT ) {

                        V1aFixed.LogonCount = All->LogonCount;
                    }

                    NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );
                }

                break;

            case UserPreferencesInformation:

                V1aFixed.CountryCode = Buffer->Preferences.CountryCode;
                V1aFixed.CodePage    = Buffer->Preferences.CodePage;

                NtStatus = SampReplaceUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );


                //
                // replace the user comment
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   (PUNICODE_STRING)&(Buffer->Preferences.UserComment)
                                   );
                }


                break;


            case UserParametersInformation:


                //
                // replace the parameters
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PARAMETERS,
                               (PUNICODE_STRING)&(Buffer->Parameters.Parameters)
                               );

                break;


            case UserLogonHoursInformation:

                NtStatus = SampReplaceUserLogonHours(
                               AccountContext,
                               (PLOGON_HOURS)&(Buffer->LogonHours.LogonHours)
                               );
                break;


            case UserNameInformation:

                //
                // first change the Full Name, then change the account name...
                //

                //
                // replace the full name - no value restrictions
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   (PUNICODE_STRING)&(Buffer->Name.FullName)
                                   );

                    //
                    // Change the account name
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampChangeUserAccountName(
                                        AccountContext,
                                        (PUNICODE_STRING)&(Buffer->Name.UserName),
                                        V1aFixed.UserAccountControl,
                                        &OldAccountName
                                        );

                        //
                        // Get the Address of New Account Name
                        //
                        NewAccountNameToRemove =
                                (UNICODE_STRING *)&(Buffer->Name.UserName);

                        //
                        // RemoveAccountNameFromTable tells us whether
                        // the caller (this routine) is responsable
                        // to remove the name from the table.
                        //
                        RemoveAccountNameFromTable =
                            AccountContext->RemoveAccountNameFromTable;

                        //
                        // reset to FALSE
                        //
                        AccountContext->RemoveAccountNameFromTable = FALSE;
                    }
                }


                //
                // Don't free the OldAccountName yet; we'll need it at the
                // very end.
                //

                break;


            case UserAccountNameInformation:

                NtStatus = SampChangeUserAccountName(
                                AccountContext,
                                (PUNICODE_STRING)&(Buffer->AccountName.UserName),
                                V1aFixed.UserAccountControl,
                                &OldAccountName
                                );

                //
                // Get the Address of New Account Name
                //
                NewAccountNameToRemove =
                            (UNICODE_STRING *)&(Buffer->AccountName.UserName);

                //
                // RemoveAccountNameFromTable tells us whether
                // the caller (this routine) is responsable
                // to remove the name from the table.
                //
                RemoveAccountNameFromTable =
                        AccountContext->RemoveAccountNameFromTable;

                //
                // reset to FALSE
                //
                AccountContext->RemoveAccountNameFromTable = FALSE;

                //
                // Don't free the OldAccountName; we'll need it at the
                // very end.
                //

                break;


            case UserFullNameInformation:

                //
                // replace the full name - no value restrictions
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_FULL_NAME,
                               (PUNICODE_STRING)&(Buffer->FullName.FullName)
                               );
                break;



 
            case UserPrimaryGroupInformation:

                if (IsDsObject(AccountContext) &&
                    (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                    (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
                   )
                {
                    //
                    // Domain Controller's Primary Group should ALWAYS be
                    // DOMAIN_GROUP_RID_CONTROLLERS
                    //
                    // For NT4 and earlier release, we do not enforce the above rule,
                    // therefore compensate here is change the error code to success.
                    //
                    // For all interim NT5 releases (until beta2), since their DC's
                    // primary group Id might have been changed, so by checking
                    // V1aFixed.PrimaryGroupId, we still allow them to change their
                    // DC's primary group id. But once it has been set back to
                    // RID_CONTROLLERS, we do not let them go any further.
                    //

                    if (!AccountContext->LoopbackClient &&
                        (DOMAIN_GROUP_RID_USERS==Buffer->PrimaryGroup.PrimaryGroupId))
                    {
                        // Come throught NT4
                        NtStatus = STATUS_SUCCESS;
                    }
                    else if (DOMAIN_GROUP_RID_CONTROLLERS == Buffer->PrimaryGroup.PrimaryGroupId)
                    {
                        NtStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
                    }
                }
                else
                {
                    //
                    // Make sure the primary group is legitimate
                    // (it must be one the user is a member of)
                    //
                    NtStatus = SampAssignPrimaryGroup(
                                   AccountContext,
                                   Buffer->PrimaryGroup.PrimaryGroupId
                                   );

                    //
                    // Update the V1_FIXED info.
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        V1aFixed.PrimaryGroupId = Buffer->PrimaryGroup.PrimaryGroupId;
                        KeepOldPrimaryGroupMembership = TRUE;

                        NtStatus = SampReplaceUserV1aFixed(
                                   AccountContext,
                                   &V1aFixed
                                   );
                     } else if ((DOMAIN_GROUP_RID_USERS==Buffer->PrimaryGroup.PrimaryGroupId)
                                      && (V1aFixed.UserAccountControl
                                            & USER_MACHINE_ACCOUNT_MASK)) {
                           //
                           // NT4 and earlier releases during machine join
                           // set the primary group id to domain users.
                           // however the account need not necessarily be part
                           // of domain users. Therefore compensate here
                           // by changing the error code to status success

                        NtStatus = STATUS_SUCCESS;
                    }
                }

                break;

 
            case UserHomeInformation:

                //
                // replace the home directory
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_HOME_DIRECTORY,
                               (PUNICODE_STRING)&(Buffer->Home.HomeDirectory)
                               );

                //
                // replace the home directory drive
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   (PUNICODE_STRING)&(Buffer->Home.HomeDirectoryDrive)
                                   );
                }

                break;
 
            case UserScriptInformation:

                //
                // replace the script
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_SCRIPT_PATH,
                               (PUNICODE_STRING)&(Buffer->Script.ScriptPath)
                               );

                break;

 
            case UserProfileInformation:

                //
                // replace the Profile
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   (PUNICODE_STRING)&(Buffer->Profile.ProfilePath)
                                   );
                }

                break;

 
            case UserAdminCommentInformation:

                //
                // replace the admin  comment
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                                   );
                }

                break;

 
            case UserWorkStationsInformation:

                //
                // Convert the workstation list, which is given to us in
                // UI/Service format, to API list format before storing
                // it.
                //
                if ( (Buffer->WorkStations.WorkStations.Length > 0)
                  && (Buffer->WorkStations.WorkStations.Buffer == NULL) ) {

                    NtStatus = STATUS_INVALID_PARAMETER;

                } else {

                    NtStatus = SampConvertUiListToApiList(
                                   (PUNICODE_STRING)&(Buffer->WorkStations.WorkStations),
                                   &ApiList,
                                   FALSE );
                }


                //
                // replace the admin workstations
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   &ApiList
                                   );

                    RtlFreeHeap( RtlProcessHeap(), 0, ApiList.Buffer );
                }

                break;

 
            case UserControlInformation:

                 SystemChangesPrimaryGroupId = TRUE;

                 NtStatus = SampSetUserAccountControl(
                                    AccountContext,
                                    Buffer->Control.UserAccountControl,
                                    &V1aFixed,
                                    TRUE,
                                    &AccountUnlocked,
                                    &AccountGettingMorphed,
                                    &KeepOldPrimaryGroupMembership
                                    );




                if ( NT_SUCCESS( NtStatus ) ) {

                    if ( AccountGettingMorphed ) {

                        //
                        // One or more of the machine account bits has
                        // changed; we'll notify netlogon below.
                        //

                        UserAccountControlChanged = TRUE;

                        IgnoreStatus = SampGetUnicodeStringAttribute(
                                           AccountContext,
                                           SAMP_USER_ACCOUNT_NAME,
                                           TRUE, // Make copy
                                           &OldAccountName
                                           );
                    }

                    NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );

                }



                break;

 
            case UserExpiresInformation:

                //
                // If the user is the special account Administrator, return an
                // error if trying to set the expiry information, except to the
                // value that means that the account never expires.
                //

                if ((!AccountContext->TrustedClient) &&
                    ( AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN )) {

                    LARGE_INTEGER AccountNeverExpires, Temp;

                    AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                              SAMP_ACCOUNT_NEVER_EXPIRES
                                              );

                    OLD_TO_NEW_LARGE_INTEGER(All->AccountExpires, Temp);

                    if (!( Temp.QuadPart == AccountNeverExpires.QuadPart)) {

                        NtStatus = STATUS_SPECIAL_ACCOUNT;
                        break;
                    }
                }

                V1aFixed.AccountExpires = Buffer->Expires.AccountExpires;

                NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );

                break;

 
            case UserSetPasswordInformation:

                ASSERT(FALSE); // Should have been mapped to INTERNAL1 on client side
                NtStatus = STATUS_INVALID_INFO_CLASS;
                break;

 
            case UserInternal1Information:
            case UserInternal5Information:
            case UserInternal5InformationNew:

                //
                // This is a password set operation
                //
                fSetUserPassword = TRUE;

                //
                // Get the effective domain policy
                //

                NtStatus = SampObtainEffectivePasswordPolicy(
                                &DomainPasswordInfo,
                                AccountContext,
                                TRUE
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    break;
                }
                //
                // Get copy of the account name to pass to
                // notification packages.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                                AccountContext,
                                SAMP_USER_ACCOUNT_NAME,
                                TRUE,    // Make copy
                                &AccountName
                                );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }



                if (UserInformationClass == UserInternal1Information) {

                    LmPresent = Buffer->Internal1.LmPasswordPresent;
                    NtPresent = Buffer->Internal1.NtPasswordPresent;
                    PasswordExpired = Buffer->Internal1.PasswordExpired;

                    //
                    // If our client is trusted, they are on the server side
                    // and data from them will not have been encrypted with the
                    // user session key - so don't decrypt them
                    //

                    if ( AccountContext->TrustedClient ) {

                        //
                        // Copy the (not) encrypted owfs into the owf buffers
                        //

                        ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);
                        ASSERT(ENCRYPTED_NT_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                        RtlCopyMemory(&LmOwfPassword,
                                      &Buffer->Internal1.EncryptedLmOwfPassword,
                                      LM_OWF_PASSWORD_LENGTH
                                      );

                        RtlCopyMemory(&NtOwfPassword,
                                      &Buffer->Internal1.EncryptedNtOwfPassword,
                                      NT_OWF_PASSWORD_LENGTH
                                      );

                    } else {


                        //
                        // This call came from the client-side. The
                        // The OWFs will have been encrypted with the session
                        // key across the RPC link.
                        //
                        // Get the session key and decrypt both OWFs
                        //

                        NtStatus = RtlGetUserSessionKeyServer(
                                       (RPC_BINDING_HANDLE)UserHandle,
                                       &UserSessionKey
                                       );

                        if ( !NT_SUCCESS( NtStatus ) ) {
                            break; // out of switch
                        }


                        //
                        // Decrypt the LM OWF Password with the session key
                        //

                        if ( Buffer->Internal1.LmPasswordPresent) {

                            NtStatus = RtlDecryptLmOwfPwdWithUserKey(
                                           &Buffer->Internal1.EncryptedLmOwfPassword,
                                           &UserSessionKey,
                                           &LmOwfPassword
                                           );
                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }
                        }


                        //
                        // Decrypt the NT OWF Password with the session key
                        //

                        if ( Buffer->Internal1.NtPasswordPresent) {

                            NtStatus = RtlDecryptNtOwfPwdWithUserKey(
                                           &Buffer->Internal1.EncryptedNtOwfPassword,
                                           &UserSessionKey,
                                           &NtOwfPassword
                                           );

                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }
                        }
                    }
                } else {

                     UNICODE_STRING FullName;

                    //
                    // Password was sent cleartext.
                    //

                    NtStatus = SampDecryptPasswordWithSessionKey(
                                    UserHandle,
                                    UserInformationClass,
                                    Buffer,
                                    &ClearTextPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }


                    //
                    // Compute the hashed passwords.
                    //

                    NtStatus = SampCalculateLmAndNtOwfPasswords(
                                    &ClearTextPassword,
                                    &LmPresent,
                                    &LmOwfPassword,
                                    &NtOwfPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }

                    NtStatus = SampObtainEffectivePasswordPolicy(
                                   &DomainPasswordInfo,
                                   AccountContext,
                                   TRUE
                                   );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    NtPresent = TRUE;
                    if (UserInternal5Information == UserInformationClass)
                    {
                        PasswordExpired = Buffer->Internal5.PasswordExpired;
                    }
                    else
                    {
                        ASSERT(UserInternal5InformationNew == UserInformationClass);

                        PasswordExpired = Buffer->Internal5New.PasswordExpired;
                    }

                    ClearTextPasswordPresent = TRUE;

                }

                

                //
                // check whether the client can UnExpire Password.
                // 1) no special access check for ExpirePassword operation
                // 2) computer accounts are not subject to this access check
                // 

                if ( !PasswordExpired )
                {
                    NtStatus = SampValidatePwdSettingAttempt(
                                        AccountContext,     // account context
                                        NULL,               // client token
                                        V1aFixed.UserAccountControl,
                                        (GUID *) &GUID_CONTROL_UnexpirePassword
                                        );
                }

                if (!NT_SUCCESS(NtStatus))
                {
                    break;
                }



                //
                // Store away the new OWF passwords
                //

                NtStatus = SampStoreUserPasswords(
                                AccountContext,
                                &LmOwfPassword,
                                LmPresent,
                                &NtOwfPassword,
                                NtPresent,
                                TRUE, // Check Password restrictions
                                PasswordSet,
                                &DomainPasswordInfo,
                                ClearTextPasswordPresent?&ClearTextPassword:NULL,
                                NULL,
                                &PasswordToNotify,
                                NULL
                                );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SampStorePasswordExpired(
                                   AccountContext,
                                   PasswordExpired
                                   );
                }

                //
                // Replicate immediately if this is a trust account
                //

                if ( V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
                    ReplicateImmediately = TRUE;
                }


                break;



 
            case UserInternal2Information:

                if ( AccountContext->TrustedClient ) {

                    TellNetlogon = FALSE;

                    //
                    // There are two ways to set logon/logoff statistics:
                    //
                    //      1) Directly, specifying each one being set,
                    //      2) Implicitly, specifying the action to
                    //         represent
                    //
                    // These two forms are mutually exclusive.  That is,
                    // you can't specify both a direct action and an
                    // implicit action.  In fact, you can't specify two
                    // implicit actions either.
                    //

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_INTER_SUCCESS_LOGON) {


                        //
                        // Set BadPasswordCount = 0
                        // Increment LogonCount
                        // Set LastLogon = NOW
                        // Reset the locked out time
                        //
                        //

                        if (V1aFixed.BadPasswordCount != 0) {

                            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                                            "UserId: 0x%x Successful interactive logon, clearing badPwdCount\n",
                                            V1aFixed.UserId));
                        }

                        V1aFixed.BadPasswordCount = 0;
                        if (V1aFixed.LogonCount != 0xFFFF) {
                            V1aFixed.LogonCount += 1;
                        }
                        NtQuerySystemTime( &V1aFixed.LastLogon );

                        if ( IsDsObject( AccountContext ) )
                        {
                            if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                            {
                                RtlSecureZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );

                                NtStatus = SampDsUpdateLockoutTime( AccountContext );
                                if ( !NT_SUCCESS( NtStatus ) )
                                {
                                    break;
                                }

                                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                                               "UserId: 0x%x Successful interactive logon, unlocking account\n",
                                                V1aFixed.UserId));

                            }
                        }

                        FlushOnlyLogonProperties=TRUE;

                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_INTER_SUCCESS_LOGOFF) {
                        if ( (Buffer->Internal2.StatisticsToApply
                                 & ~USER_LOGON_INTER_SUCCESS_LOGOFF)  != 0 ) {

                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        } else {

                            //
                            // Set LastLogoff time
                            // Decrement LogonCount (don't let it become negative)
                            //

                            if (V1aFixed.LogonCount != 0) {
                                V1aFixed.LogonCount -= 1;
                            }
                            NtQuerySystemTime( &V1aFixed.LastLogoff );
                            FlushOnlyLogonProperties=TRUE;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_NET_SUCCESS_LOGON) {

                        //
                        // Set BadPasswordCount = 0
                        // Set LastLogon = NOW
                        // Clear the locked time
                        //
                        //
                        //

                        if (V1aFixed.BadPasswordCount != 0) {

                            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                                           "UserId: 0x%x Successful network logon, clearing badPwdCount\n",
                                            V1aFixed.UserId));
                        }

                        V1aFixed.BadPasswordCount = 0;
                        NtQuerySystemTime( &V1aFixed.LastLogon );

                        if ( IsDsObject( AccountContext ) )
                        {
                            if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                            {
                                RtlSecureZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );
                                NtStatus = SampDsUpdateLockoutTime( AccountContext );
                                if ( !NT_SUCCESS( NtStatus ) )
                                {
                                    break;
                                }

                                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                                               "UserId: 0x%x Successful network logon, unlocking account\n",
                                                V1aFixed.UserId));
                            }
                        }

                        FlushOnlyLogonProperties=TRUE;
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_NET_SUCCESS_LOGOFF) {
                        if ( (Buffer->Internal2.StatisticsToApply
                                 & ~USER_LOGON_NET_SUCCESS_LOGOFF)  != 0 ) {

                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        } else {

                            //
                            // Set LastLogoff time
                            //

                            NtQuerySystemTime( &V1aFixed.LastLogoff );
                            FlushOnlyLogonProperties=TRUE;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_BAD_PASSWORD) {

                        PUNICODE_STRING TempMachineName = NULL;

                        //
                        // Increment BadPasswordCount
                        // (might lockout account)
                        //

                        //
                        // Get the wksta name if provided
                        //
                        if ((Buffer->Internal2.StatisticsToApply & USER_LOGON_BAD_PASSWORD_WKSTA) != 0) {
                            TempMachineName = &(((PUSER_INTERNAL2A_INFORMATION) &Buffer->Internal2)->Workstation);
                        }

                        AccountLockedOut =
                            SampIncrementBadPasswordCount(
                                AccountContext,
                                &V1aFixed,
                                TempMachineName
                                );

                        //
                        // If the account has been locked out,
                        //  ensure the BDCs in the domain are told.
                        //

                        if ( AccountLockedOut ) {
                            TellNetlogon = TRUE;
                            ReplicateImmediately = TRUE;
                        }
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LAST_LOGON ) {

                        OLD_TO_NEW_LARGE_INTEGER(
                            Buffer->Internal2.LastLogon,
                            V1aFixed.LastLogon );
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LAST_LOGOFF ) {

                        OLD_TO_NEW_LARGE_INTEGER(
                            Buffer->Internal2.LastLogoff,
                            V1aFixed.LastLogoff );
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_BAD_PWD_COUNT ) {


                        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                                       "UserId: 0x%x Setting BadPasswordCount to %d\n",
                                        V1aFixed.UserId, Buffer->Internal2.BadPasswordCount));

                        V1aFixed.BadPasswordCount =
                            Buffer->Internal2.BadPasswordCount;
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LOGON_COUNT ) {

                        V1aFixed.LogonCount = Buffer->Internal2.LogonCount;
                    }

                    //
                    // Determine if the user account should be replicated down
                    //
                    if ( IsDsObject(AccountContext)
                     && (Buffer->Internal2.StatisticsToApply & USER_LOGON_PDC_RETRY_SUCCESS)) {
                
                        //
                        // Replicate the object down locally from the PDC. Delay
                        // the queueing of the request until this write operation
                        // is done to avoid write conflicts.
                        //
                        ASSERT(AccountContext->ObjectNameInDs);

                        RtlCopyMemory(&UserGuidToReplicateLocally, 
                                   &AccountContext->ObjectNameInDs->Guid,
                                   sizeof(GUID));
                
                    }

                    if ((FlushOnlyLogonProperties)
                            && (IsDsObject(AccountContext)))
                    {
                        //
                        // If it is the DS case and we are only doing a successful
                        // logon or logoff, just flush the last logon, last logoff,
                        // logon count and bad password count properties. Note the
                        // value in the on disk structure in AccountContext will now
                        // be stale, but SetInformationUser is the last operation
                        // during a logon. Therefore it should not matter.
                        //
                        NtStatus = SampDsSuccessfulLogonSet(
                                        AccountContext,
                                        Buffer->Internal2.StatisticsToApply,
                                        LocalLastLogonTimeStampSyncInterval,
                                        &V1aFixed
                                        );
                    }
                    else if (IsDsObject(AccountContext))
                    {
                        //
                        // Set the bad password count and bad password time. Note the
                        // value in the on disk structure in AccountContext will now
                        // be stale, but SetInformationUser is the last operation
                        // during a logon. Therefore it should not matter.
                        //

                        //
                        // This path also updates the site affinity if no GC
                        // is present.
                        //
                        NtStatus = SampDsFailedLogonSet(
                                        AccountContext,
                                        Buffer->Internal2.StatisticsToApply,
                                        &V1aFixed
                                        );
                    }
                    else
                    {
                        //
                        // Registry Mode, set the entire V1aFixed Structure
                        //

                        NtStatus = SampReplaceUserV1aFixed(
                                        AccountContext,
                                        &V1aFixed
                                        );
                    }

                } else {

                    //
                    // This information is only settable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;


            } // end_switch



        } // end_if




        //
        // Go fetch any data we'll need to update the display cache
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Account Name if always retrieved
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE,    // Make copy
                           &NewAccountName
                           );
            //
            // If the account name has changed, then OldAccountName
            // is already filled in. If the account name hasn't changed
            // then the OldAccountName is the same as the new!
            //

            if (NT_SUCCESS(NtStatus) && (OldAccountName.Buffer == NULL)) {

                NtStatus = SampDuplicateUnicodeString(
                               &OldAccountName,
                               &NewAccountName);
            }

            if ( MustUpdateAccountDisplay ) {

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   &NewFullName
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       &NewAdminComment
                                       );
                    }
                }
            }
        }

        //
        //                ONLY IN DS CASE:
        //
        // If the primary group Id has been changed then explicitly modify the
        // user's membership to include the old primary group as a member. This
        // is because in the DS case the membership in the primary group is not
        // stored explicitly, but is rather implicit in the primary group-id property.
        //
        if ((NT_SUCCESS(NtStatus))
            && (V1aFixed.PrimaryGroupId!=OldPrimaryGroupId)
            && (IsDsObject(AccountContext)))
        {

            NtStatus = SampMaintainPrimaryGroupIdChange(AccountContext,
                                                        V1aFixed.PrimaryGroupId,
                                                        OldPrimaryGroupId,
                                                        KeepOldPrimaryGroupMembership);

        }

        //
        // Generate an audit if necessary. We don't account statistic
        // updates, which we also don't notify Netlogon of.
        //

        if (NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(DomainIndex) &&
            TellNetlogon) {

            ULONG   UserAccountControlOld;
            BOOLEAN AccountNameChanged;

            if (MustQueryV1aFixed || MustUpdateAccountDisplay)
            {
                UserAccountControlOld = OldUserAccountControl;
            }
            else
            {
                //
                // if OldUserAccountControl is not available,
                // then there is not change
                //
                UserAccountControlOld = V1aFixed.UserAccountControl;
            }
            
            AccountNameChanged = (RtlCompareUnicodeString(&OldAccountName,
                                                          &NewAccountName,
                                                          TRUE )  == 1) ? TRUE:FALSE;

            // audit account name change
            if (AccountNameChanged)
            {
                SampAuditAccountNameChange(AccountContext,
                                           &NewAccountName,
                                           &OldAccountName
                                           );
            }

            // account been disabled or enabled
            if ((UserAccountControlOld & USER_ACCOUNT_DISABLED) !=
                (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED))
            {
                SampAuditAccountEnableDisableChange(
                    AccountContext,
                    V1aFixed.UserAccountControl,
                    UserAccountControlOld,
                    &NewAccountName
                    );
            }

            //
            // Audit all changed attributes and their values.  In Ds mode,
            // the audit is managed by SampAuditUserChangeDs.
            //
            SampAuditUserChange(AccountContext,
                                UserInformationClass,
                                &NewAccountName,
                                &(AccountContext->TypeBody.User.Rid),
                                UserAccountControlOld,
                                V1aFixed.UserAccountControl,
                                NULL,
                                FALSE
                               );
        }

        if ((fSetUserPassword) && SampDoSuccessOrFailureAccountAuditing(DomainIndex, NtStatus))
        {
            SampAuditAnyEvent(
                AccountContext,
                NtStatus,
                SE_AUDITID_USER_PWD_SET, // AuditId
                SampDefinedDomains[AccountContext->DomainIndex].Sid, // Domain SID
                NULL,                        // Additional Info
                NULL,                        // Member Rid (not used)
                NULL,                        // Member Sid (not used)
                &NewAccountName,             // Account Name
                &(SampDefinedDomains[AccountContext->DomainIndex].ExternalName), // Domain
                &(AccountContext->TypeBody.User.Rid),   // Account Rid
                NULL,                        // Privileges used
                NULL                         // New State Data
                );
        }


        //
        // Finally, if the following changes have occurred, replicate them
        // urgently.
        //
        if (NT_SUCCESS(NtStatus)
        &&  IsDsObject(AccountContext)
        && (!(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK))
        &&  (PasswordExpired
          || AccountUnlocked)  ) {

            //
            // N.B. The context's ReplicateUrgently refers to DS replication
            // The stack based ReplicateUrgently refers to NT4 BDC replication
            // which we don't want here.
            //
            AccountContext->ReplicateUrgently = TRUE;
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //


            NtStatus = SampDeReferenceContext( AccountContext, TRUE );


        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

    } // end_if





    //
    // Commit the transaction and, if successful,
    // notify netlogon of the changes.  Also generate any necessary audits.
    // Note that the code path for commits is significantly different for the
    // case of the thread safe context and the non thread safe context
    //


    if (fLockAcquired)
    {
        if (NT_SUCCESS(NtStatus)) {


            if (( !TellNetlogon ) && (!IsDsObject(AccountContext))) {

                 //
                 // For logon statistics, we don't notify netlogon about changes
                 // to the database.  Which means that we don't want the
                 // domain's modified count to increase.  The commit routine
                 // will increase it automatically if this isn't a BDC, so we'll
                 // decrement it here.
                 //

                 if (SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole != DomainServerRoleBackup) {

                     SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart-1;
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart-1;
                 }
            }


            NtStatus = SampCommitAndRetainWriteLock();


            if ( NT_SUCCESS(NtStatus) ) {



                //
                // Update the display information if the cache may be affected
                //

                if ( MustUpdateAccountDisplay && (!IsDsObject(AccountContext)) ) {

                    SAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo;
                    SAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo;

                    OldAccountInfo.Name = OldAccountName;
                    OldAccountInfo.Rid = ObjectRid;
                    OldAccountInfo.AccountControl = OldUserAccountControl;
                    RtlInitUnicodeString(&OldAccountInfo.Comment, NULL);
                    RtlInitUnicodeString(&OldAccountInfo.FullName, NULL);

                    NewAccountInfo.Name = NewAccountName;
                    NewAccountInfo.Rid = ObjectRid;
                    NewAccountInfo.AccountControl = V1aFixed.UserAccountControl;
                    NewAccountInfo.Comment = NewAdminComment;
                    NewAccountInfo.FullName = NewFullName;

                    IgnoreStatus = SampUpdateDisplayInformation(&OldAccountInfo,
                                                                &NewAccountInfo,
                                                                SampUserObjectType);
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }



                //
                // Notify netlogon of any user account changes
                //

                if ( ( UserInformationClass == UserNameInformation ) ||
                    ( UserInformationClass == UserAccountNameInformation ) ||
                    ( ( UserInformationClass == UserAllInformation ) &&
                    ( All->WhichFields & USER_ALL_USERNAME ) ) ) {

                    //
                    // The account was renamed; let Netlogon know.
                    //

                    SampNotifyNetlogonOfDelta(
                        SecurityDbRename,
                        SecurityDbObjectSamUser,
                        ObjectRid,
                        &OldAccountName,
                        (DWORD) ReplicateImmediately,
                        NULL            // Delta data
                        );

                } else {

                    //
                    // Something in the account was changed.  Notify netlogon about
                    // everything except logon statistics changes.
                    //

                    if ( TellNetlogon ) {

                        SAM_DELTA_DATA DeltaData;

                        DeltaData.AccountControl = V1aFixed.UserAccountControl;

                        SampNotifyNetlogonOfDelta(
                            DeltaType,
                            SecurityDbObjectSamUser,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) ReplicateImmediately,
                            &DeltaData // Delta data
                            );
                    }
                }
            }
        }

        //
        // Remove the New Account Name from the Global
        // SAM Account Name Table
        //
        if (RemoveAccountNameFromTable)
        {
            IgnoreStatus = SampDeleteElementFromAccountNameTable(
                                (PUNICODE_STRING)NewAccountNameToRemove,
                                SampUserObjectType
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

         //
         // Release the lock
         //

         IgnoreStatus = SampReleaseWriteLock( FALSE );
         ASSERT(NT_SUCCESS(IgnoreStatus));
         fLockAcquired=FALSE;
     }
     else
     {
         //
         // Commit for the thread safe context case
         //

         ASSERT(IsDsObject(AccountContext));
         if (NT_SUCCESS(NtStatus))
         {
            SampMaybeEndDsTransaction(TransactionCommit);
         }
         else
         {
            SampMaybeEndDsTransaction(TransactionAbort);
         }
     }

    ASSERT(fLockAcquired == FALSE);

    //
    // Notify any packages that a password was changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG                   NotifyFlags = 0;

        if (PasswordExpired) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MANUAL_EXPIRE;
        }
        if (AccountUnlocked) {
            NotifyFlags |= SAMP_PWD_NOTIFY_UNLOCKED;
        }
        if ((DeltaType == SecurityDbChangePassword)
         && !(V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)) {
            NotifyFlags |= SAMP_PWD_NOTIFY_PWD_CHANGE;
        }
        if (NotifyFlags != 0) {

            if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
                NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
            }

            //
            // If the account name was changed, use the new account name.
            //
            if (NewAccountName.Buffer != NULL) {
                (void) SampPasswordChangeNotify(
                            NotifyFlags,
                            &NewAccountName,
                            UserRid,
                            &PasswordToNotify,
                            FALSE  // Not loopback
                            );
            } else {
                (void) SampPasswordChangeNotify(
                            NotifyFlags,
                            &AccountName,
                            UserRid,
                            &PasswordToNotify,
                            FALSE  // Not loopback
                            );

            }
        }
    }


    //
    // Clean up strings
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );
    SampFreeUnicodeString( &NewFullName );
    SampFreeUnicodeString( &NewAdminComment );
    SampFreeUnicodeString( &AccountName );

    if (ClearTextPassword.Buffer != NULL) {

        RtlSecureZeroMemory(
            ClearTextPassword.Buffer,
            ClearTextPassword.Length
            );

        RtlFreeUnicodeString( &ClearTextPassword );

    }

    if (PasswordToNotify.Buffer!=NULL) {

        RtlSecureZeroMemory(
            PasswordToNotify.Buffer,
            PasswordToNotify.Length
            );

        MIDL_user_free(PasswordToNotify.Buffer);
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // If we were notified of an account that needs to replicated locally
    // queue a request to do so
    //
    if (!IsEqualGUID(&UserGuidToReplicateLocally, &NullGuid)) {

        SampQueueReplicationRequest(&UserGuidToReplicateLocally);
    }

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationUser
                   );

    return(NtStatus);
}





NTSTATUS
SampCheckOwfPasswordChangeRestriction(
    OUT BOOLEAN *PasswordExpired
    )
/*++
Routine Description:

    This routine enforces OWF password change restrictions based on 
    the value of global variable - SampRestrictOwfPasswordChange 

    This global variable controls how SAM restricts OWF password change API.

    0 - old behavior, client can change password through OWF password change API,
        and the new password remains unexpired.

    1 - .NET Server default behavior, client can change password through 
        OWF password change API (SamrChangePasswordUser), but the password
        expires immediately.

    2 - more secure behavior, client cann't use OWF password change API.
        this API (SamrChangePasswordUser) will be totally shutted down.

    The value of this global variable will be based on REGISTRY KEY setting
    System\\CurrentControlSet\\Control\\Lsa\\SamRestrictOwfPasswordChange 

    NOTE: All restrictions are NOT applied to SYSTEM or members of Builtin 
          Administrators Alias Group.

Parameters:

    PasswordExpired - returned to caller to indicate what OWF password change 
                      API should do. 
    
Return Values;

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOL        fAdministrator = FALSE;
    PSID        pSid = NULL;


    ASSERT( SampRestrictOwfPasswordChange <= 2 );

    //
    // set init return value
    // 
    *PasswordExpired = TRUE;


    //
    // check global settings
    // 

    switch ( SampRestrictOwfPasswordChange )
    {
    case 0:

        // 
        // old behavior, anybody can do OWF password change and the password
        // remains unexpired.
        // 

        *PasswordExpired = FALSE;
        break;

    case 2: 

        //
        // more secure setting. Shut down OWF password change API.
        // 

        NtStatus = SampGetCurrentClientSid(NULL, &pSid, &fAdministrator);

        if ( NT_SUCCESS(NtStatus) )
        {
            if ( fAdministrator )
            {
                //
                // LocalSystem or Member of Builtin Administrators Group
                // can continue to use this OWF password change.
                // and password is unexpired.
                // 

                *PasswordExpired = FALSE;
            }
            else
            {
                // 
                // Non LocalSystem, nor member of Builtin Administrators group,
                // can't use this OWF password change API. 
                // Set return status code to ERROR - fail the request
                // 

                NtStatus = STATUS_ACCESS_DENIED;
            }
        }

        break;

    case 1: 
    default:

        //
        // .NET Server or default setting.
        // client can continue to use OWF password change API. but 
        // the new password will be expired. 
        // except for LocalSystem or member of Administrators Alias
        // 

        NtStatus = SampGetCurrentClientSid(NULL, &pSid, &fAdministrator);

        if ( NT_SUCCESS(NtStatus) )
        {
            if ( fAdministrator )
            {
                *PasswordExpired = FALSE;
            }
            else
            {
                *PasswordExpired = TRUE;
            }
        }

        break;
    }


    if (NULL != pSid)
    {
        MIDL_user_free( pSid );
    }
    
    return( NtStatus );
}



NTSTATUS
SamrChangePasswordUser(
    IN SAMPR_HANDLE UserHandle,
    IN BOOLEAN LmPresent,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmEncryptedWithNewLm,
    IN PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithOldLm,
    IN BOOLEAN NtPresent,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtEncryptedWithNewNt,
    IN PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithOldNt,
    IN BOOLEAN NtCrossEncryptionPresent,
    IN PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithNewLm,
    IN BOOLEAN LmCrossEncryptionPresent,
    IN PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithNewNt
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LMPresent - TRUE if the LM parameters (below) are valid.

    LmOldEncryptedWithLmNew - the old LM OWF encrypted with the new LM OWF

    LmNewEncryptedWithLmOld - the new LM OWF encrypted with the old LM OWF


    NtPresent - TRUE if the NT parameters (below) are valid

    NtOldEncryptedWithNtNew - the old NT OWF encrypted with the new NT OWF

    NtNewEncryptedWithNtOld - the new NT OWF encrypted with the old NT OWF


    NtCrossEncryptionPresent - TRUE if NtNewEncryptedWithLmNew is valid.

    NtNewEncryptedWithLmNew - the new NT OWF encrypted with the new LM OWF


    LmCrossEncryptionPresent - TRUE if LmNewEncryptedWithNtNew is valid.

    LmNewEncryptedWithNtNew - the new LM OWF encrypted with the new NT OWF


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    LARGE_INTEGER           TimeNow;
    LM_OWF_PASSWORD         StoredLmOwfPassword;
    NT_OWF_PASSWORD         StoredNtOwfPassword;
    NT_OWF_PASSWORD         NewNtOwfPassword, OldNtOwfPassword;
    LM_OWF_PASSWORD         NewLmOwfPassword, OldLmOwfPassword;
    BOOLEAN                 StoredLmPasswordNonNull;
    BOOLEAN                 StoredNtPasswordPresent;
    BOOLEAN                 StoredNtPasswordNonNull;
    BOOLEAN                 AccountLockedOut;
    BOOLEAN                 V1aFixedRetrieved = FALSE;
    BOOLEAN                 V1aFixedModified = FALSE;
    BOOLEAN                 MachineAccount = FALSE;
    BOOLEAN                 PasswordExpired = TRUE;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    DOMAIN_PASSWORD_INFORMATION  DomainPasswordInfo;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrChangePasswordUser");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );


    RtlInitUnicodeString(
        &AccountName,
        NULL
        );

    //
    // Parameter check
    //
    if (LmPresent) {
        if (  (NewLmEncryptedWithOldLm == NULL)
           || (OldLmEncryptedWithNewLm == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (NtPresent) {
        if (  (OldNtEncryptedWithNewNt == NULL)
           || (NewNtEncryptedWithOldNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (NtCrossEncryptionPresent) {
        if (NewNtEncryptedWithNewLm == NULL) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (LmCrossEncryptionPresent) {
        if (NewLmEncryptedWithNewNt == NULL) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (!NtPresent
     && !LmPresent   ) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }


    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime( &TimeNow );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }



    //
    // Extract the client's IP address if any
    //
    (VOID) SampExtractClientIpAddr(AccountContext);


    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];



    //
    // Get the account name for Auditing information
    //
    memset(&AccountName, 0, sizeof(UNICODE_STRING));
    NtStatus = SampGetUnicodeStringAttribute(
                        AccountContext,
                        SAMP_USER_ACCOUNT_NAME,
                        TRUE,           // make a copy
                        &AccountName
                        );


    //
    // check OWF password change restriction 
    //

    if ( NT_SUCCESS(NtStatus) )
    {
        NtStatus = SampCheckOwfPasswordChangeRestriction( &PasswordExpired );
    }


    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get the fixed attributes and check for account lockout
        //

        NtStatus = SampCheckForAccountLockout(
                            AccountContext,
                            &V1aFixed,
                            FALSE       // V1aFixed is not retrieved yet
                            );

        if (NT_SUCCESS(NtStatus))
        {
            MachineAccount = ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!=0);

            V1aFixedRetrieved = TRUE;
        }

    }

    //
    // Block password Change for KRBTGT account
    //

    if ((NT_SUCCESS(NtStatus)) &&
       (DOMAIN_USER_RID_KRBTGT==AccountContext->TypeBody.User.Rid))
    {
        NtStatus = STATUS_ACCESS_DENIED;
    }

    if (NT_SUCCESS(NtStatus))
    {

        //
        // Get the effective domain policy
        //

        NtStatus = SampObtainEffectivePasswordPolicy(
                        &DomainPasswordInfo,
                        AccountContext,
                        TRUE
                        );
    }

    if (NT_SUCCESS(NtStatus)) {


        //
        // Read the old OWF passwords from disk
        //

        NtStatus = SampRetrieveUserPasswords(
                        AccountContext,
                        &StoredLmOwfPassword,
                        &StoredLmPasswordNonNull,
                        &StoredNtOwfPassword,
                        &StoredNtPasswordPresent,
                        &StoredNtPasswordNonNull
                        );

        //
        // Check the password can be changed at this time
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Only do the check if one of the passwords is non-null.
            // A Null password can always be changed.
            //

            if (StoredNtPasswordNonNull || StoredLmPasswordNonNull) {




                if (NT_SUCCESS(NtStatus) && (!MachineAccount)) {
                    //
                    // If the min password age is non zero, check it here
                    //
                    if (DomainPasswordInfo.MinPasswordAge.QuadPart != SampHasNeverTime.QuadPart) {

                        LARGE_INTEGER PasswordCanChange = SampAddDeltaTime(
                                         V1aFixed.PasswordLastSet,
                                         DomainPasswordInfo.MinPasswordAge);

                        if (TimeNow.QuadPart < PasswordCanChange.QuadPart) {
                            NtStatus = STATUS_PASSWORD_RESTRICTION;
                        }
                    }

                }
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Check to make sure the old passwords passed in are sufficient
            // to validate what is stored.  There are reasons why an LM password
            // would not be stored: SampNoLMHash, too complex, etc.
            //
            NtStatus = SampValidatePresentAndStoredCombination(NtPresent,
                                                               LmPresent,
                                                               StoredNtPasswordPresent,
                                                               StoredNtPasswordNonNull,
                                                               StoredLmPasswordNonNull);

        }

        if (NT_SUCCESS(NtStatus)) {

            if (LmPresent) {

                //
                // Decrypt the doubly-encrypted LM passwords sent to us
                //

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                NewLmEncryptedWithOldLm,
                                &StoredLmOwfPassword,
                                &NewLmOwfPassword
                           );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                    OldLmEncryptedWithNewLm,
                                    &NewLmOwfPassword,
                                    &OldLmOwfPassword
                               );
                }
            }
        }

        //
        // Decrypt the doubly-encrypted NT passwords sent to us
        //

        if (NT_SUCCESS(NtStatus)) {

            if (NtPresent) {

                NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                NewNtEncryptedWithOldNt,
                                &StoredNtOwfPassword,
                                &NewNtOwfPassword
                           );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                    OldNtEncryptedWithNewNt,
                                    &NewNtOwfPassword,
                                    &OldNtOwfPassword
                               );
                }
            }
        }

        //
        // Authenticate the password change operation based on what
        // we have stored and what was passed.
        //

        if (NT_SUCCESS(NtStatus)) {

            if (!NtPresent) {

                //
                // Called from a down-level machine (no NT password passed)
                //
                ASSERT(LmPresent);

                //
                // LM data only passed. Use LM data for authentication
                //

                if (!RtlEqualLmOwfPassword(&OldLmOwfPassword, &StoredLmOwfPassword)) {

                    //
                    // Old LM passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                } else {

                    //
                    // The operation was authenticated based on the LM data
                    //
                    // We have NtPresent = FALSE, LM Present = TRUE
                    //
                    // NewLmOwfPassword will be stored.
                    // No NT password will be stored.
                    //
                }

            } else {

                //
                // NtPresent = TRUE, we were passed an NT password
                // The client is an NT-level machine (or higher !)
                //

                if (!LmPresent) {

                    //
                    // No LM version of old password - the old password is complex
                    //
                    // Use NT data for authentication
                    //

                    if (!RtlEqualNtOwfPassword(&OldNtOwfPassword, &StoredNtOwfPassword)) {

                        //
                        // Old NT passwords didn't match
                        //

                        NtStatus = STATUS_WRONG_PASSWORD;

                    } else {

                        //
                        // Authentication was successful.
                        // We need cross encrypted version of the new LM password
                        //

                        if (!LmCrossEncryptionPresent) {

                            NtStatus = STATUS_LM_CROSS_ENCRYPTION_REQUIRED;

                        } else {

                            //
                            // Calculate the new LM Owf Password
                            //

                            ASSERT(NT_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);

                            NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                            NewLmEncryptedWithNewNt,
                                            (PLM_OWF_PASSWORD)&NewNtOwfPassword,
                                            &NewLmOwfPassword
                                       );
                        }

                        if (NT_SUCCESS(NtStatus)) {

                            LmPresent = TRUE;

                            //
                            // The operation was authenticated based on NT data
                            // The new LM Password was requested and
                            // successfully obtained using cross-encryption.
                            //
                            // We have NtPresent = TRUE, LM Present = TRUE
                            //
                            // NewLmOwfPassword will be stored.
                            // NewNtOwfPassword will be stored.
                            //
                        }

                    }

                } else {

                    //
                    // NtPresent == TRUE, LmPresent == TRUE
                    //
                    // The old password passed is simple (both LM and NT versions)
                    //
                    // Authenticate using both LM and NT data
                    //

                    //
                    // N.B. Only check the LM OWF if non-null. We have the NT
                    // OWF so we will perform the authentication in the else
                    // clause.
                    //
                    if ( StoredLmPasswordNonNull
                      && !RtlEqualLmOwfPassword(&OldLmOwfPassword, &StoredLmOwfPassword)) {

                        //
                        // Old LM passwords didn't match
                        //

                        NtStatus = STATUS_WRONG_PASSWORD;

                    } else {

                        //
                        // Old LM passwords matched, in the non NULL case
                        //
                        // Do NT authentication if we have a stored NT password
                        // or the stored LM password is NULL.
                        //
                        // (NO stored NT and Stored LM = NULL -> stored pwd=NULL
                        // We must compare passed old NT Owf against
                        // NULL NT Owf to ensure user didn't specify complex
                        // old NT password instead of NULL password)
                        //
                        // (StoredNtOwfPassword is already initialized to
                        // the NullNtOwf if no NT password stored)
                        //

                        if (StoredNtPasswordPresent || !StoredLmPasswordNonNull) {

                            if (!RtlEqualNtOwfPassword(&OldNtOwfPassword,
                                                       &StoredNtOwfPassword)) {
                                //
                                // Old NT passwords didn't match
                                //

                                NtStatus = STATUS_WRONG_PASSWORD;

                            } else {

                                //
                                // The operation was authenticated based on
                                // both LM and NT data.
                                //
                                // We have NtPresent = TRUE, LM Present = TRUE
                                //
                                // NewLmOwfPassword will be stored.
                                // NewNtOwfPassword will be stored.
                                //

                            }

                        } else {

                            //
                            // The LM authentication was sufficient since
                            // we have no stored NT password
                            //
                            // Go get the new NT password using cross encryption
                            //

                            if (!NtCrossEncryptionPresent) {

                                NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;

                            } else {

                                //
                                // Calculate the new NT Owf Password
                                //

                                ASSERT(NT_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);

                                NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                                NewNtEncryptedWithNewLm,
                                                (PNT_OWF_PASSWORD)&NewLmOwfPassword,
                                                &NewNtOwfPassword
                                           );
                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // The operation was authenticated based on LM data
                                // The new NT Password was requested and
                                // successfully obtained using cross-encryption.
                                //
                                // We have NtPresent = TRUE, LM Present = TRUE
                                //
                                // NewLmOwfPassword will be stored.
                                // NewNtOwfPassword will be stored.
                                //
                            }
                        }
                    }
                }
            }
        }


        //
        // We now have a NewLmOwfPassword.
        // If NtPresent = TRUE, we also have a NewNtOwfPassword
        //

        //
        // Write the new passwords to disk
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // We should always have a LM password to store.
            //

            ASSERT(LmPresent);

            NtStatus = SampStoreUserPasswords(
                           AccountContext,
                           &NewLmOwfPassword,
                           TRUE,
                           &NewNtOwfPassword,
                           NtPresent,
                           TRUE, // Check Password Restrictions
                           PasswordChange,
                           &DomainPasswordInfo,
                           NULL, // No clear text password available
                           NULL,
                           NULL,
                           NULL
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We know the password is not expired.
                //

                NtStatus = SampStorePasswordExpired(
                               AccountContext,
                               PasswordExpired
                               );
            }
        }



        //
        // if we have a bad password, then increment the bad password
        // count and check to see if the account should be locked.
        //

        if (NtStatus == STATUS_WRONG_PASSWORD) {

            //
            // Get the V1aFixed so we can update the bad password count
            //


            TmpStatus = STATUS_SUCCESS;
            if (!V1aFixedRetrieved) {
                TmpStatus = SampRetrieveUserV1aFixed(
                                AccountContext,
                                &V1aFixed
                                );
            }

            if (!NT_SUCCESS(TmpStatus)) {

                //
                // If we can't update the V1aFixed, then return this
                // error so that the user doesn't find out the password
                // was not correct.
                //

                NtStatus = TmpStatus;

            } else {


                //
                // Increment BadPasswordCount (might lockout account)
                //


                AccountLockedOut = SampIncrementBadPasswordCount(
                                       AccountContext,
                                       &V1aFixed,
                                       NULL
                                       );

                V1aFixedModified = TRUE;


            }
        }

        if (V1aFixedModified) {
            TmpStatus = SampReplaceUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {



            //
            // De-reference the object, write out any change to current xaction.
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

    }
    else
    {
        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
                AccountContext,
                NtStatus,
                SE_AUDITID_USER_PWD_CHANGED, // AuditId
                Domain->Sid,                 // Domain SID
                NULL,                        // Additional Info
                NULL,                        // Member Rid (not used)
                NULL,                        // Member Sid (not used)
                &AccountName,                // Account Name
                &Domain->ExternalName,       // Domain
                &ObjectRid,                  // Account Rid
                NULL,                        // Privileges used
                NULL                         // New State Data
                );

    }


    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (MachineAccount) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
        }

        (void) SampPasswordChangeNotify(
                    NotifyFlags,
                    &AccountName,
                    ObjectRid,
                    NULL,
                    FALSE           // not loopback
                    );

    }

    SampFreeUnicodeString( &AccountName );
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}





NTSTATUS
SampDecryptPasswordWithLmOwfPassword(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PLM_OWF_PASSWORD StoredPassword,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    return( SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) StoredPassword,
                LM_OWF_PASSWORD_LENGTH,
                UnicodePasswords,
                ClearNtPassword
                ) );
}


NTSTATUS
SampDecryptPasswordWithNtOwfPassword(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PNT_OWF_PASSWORD StoredPassword,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    //
    // The code is the same as for LM owf password.
    //

    return(SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) StoredPassword,
                NT_OWF_PASSWORD_LENGTH,
                UnicodePasswords,
                ClearNtPassword
                ) );
}

NTSTATUS
SampOpenUserInServer(
    PUNICODE_STRING UserName,
    BOOLEAN Unicode,
    IN BOOLEAN TrustedClient,
    SAMPR_HANDLE * UserHandle
    )
/*++

Routine Description:

    Opens a user in the account domain.

Arguments:

    UserName - an OEM or Unicode string of the user's name

    Unicode - Indicates whether UserName is OEM or Unicode

    UserHandle - Receives handle to the user, opened with SamOpenUser for
        USER_CHANGE_PASSWORD access


Return Value:

--*/

{
    NTSTATUS NtStatus;
    SAM_HANDLE ServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAMPR_ULONG_ARRAY UserId;
    SAMPR_ULONG_ARRAY SidUse;
    UNICODE_STRING UnicodeUserName;
    ULONG DomainIndex;

    SAMTRACE("SampOpenUserInServer");


    UserId.Element = NULL;
    SidUse.Element = NULL;

    //
    // Get the unicode user name.
    //

    if (Unicode) {
        UnicodeUserName = *UserName;
    } else {
        NtStatus = RtlOemStringToUnicodeString(
                        &UnicodeUserName,
                        (POEM_STRING) UserName,
                        TRUE                    // allocate destination.
                        );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }



    //
    // Connect as a trusted client. This will bypass all the checks
    // related to the SAM server and Domain Objects. After all the
    // user is just interested in changing the Password and he does
    // not need access to the domain or SAM server objects in order
    // to change his own password. Detect the loopback case and use
    // the Loopback connect paradigm.
    //


    if ((SampUseDsData) && (SampIsWriteLockHeldByDs()))
    {
        //
        // Loopback case
        //

        NtStatus = SamILoopbackConnect(
                        NULL,
                        &ServerHandle,
                        SAM_SERVER_LOOKUP_DOMAIN,
                        TRUE
                        );
    }
    else
    {
        NtStatus = SamIConnect(
                    NULL,
                    &ServerHandle,
                    SAM_SERVER_LOOKUP_DOMAIN,
                    TRUE
                    );
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamrOpenDomain(
                ServerHandle,
                DOMAIN_LOOKUP |
                    DOMAIN_LIST_ACCOUNTS |
                    DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[1].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // If cleartext password change is not allowed, we return the error code
    // indicating that the rpc client should try using the old interfaces.
    //

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;
    if (SampDefinedDomains[DomainIndex].UnmodifiedFixed.PasswordProperties &
        DOMAIN_PASSWORD_NO_CLEAR_CHANGE) {

       NtStatus = RPC_NT_UNKNOWN_IF;
       goto Cleanup;
    }


    NtStatus = SamrLookupNamesInDomain(
                DomainHandle,
                1,
                (PRPC_UNICODE_STRING) &UnicodeUserName,
                &UserId,
                &SidUse
                );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_NONE_MAPPED) {
            NtStatus = STATUS_WRONG_PASSWORD;
        }
        goto Cleanup;
    }

    //
    // We need to access ck, whether the user has change password rights.
    // Therefore reset the trusted client bit in the handle and do the Open
    // user. This will verify wether the user does have change password rights
    //

    ((PSAMP_OBJECT)(DomainHandle))->TrustedClient = TrustedClient;

    //
    // Make it such that the new context is marked "opened by system"
    //

    ((PSAMP_OBJECT)(DomainHandle))->OpenedBySystem = TRUE;

    //
    // Now open the user object, performing the access ck.
    //

    NtStatus = SamrOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                UserId.Element[0],
                UserHandle
                );


    //
    // Reset the Trusted Client on the domain object. This is needed so, that
    // we will correctly decrement the SampActiveContextCount Variable when
    // we perform a close handle
    //

    ((PSAMP_OBJECT)(DomainHandle))->TrustedClient = TRUE;

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }



    //
    // Also reset the buffer writes bit on the user handle. This is set to
    // true in the loopback case, but loopback does not posess this handle,
    // so does not force a flush on this handle. This causes the data written
    // to be not written to disk.
    //

    ((PSAMP_OBJECT)((*UserHandle)))->BufferWrites = FALSE;



Cleanup:
    if (DomainHandle != NULL) {
        SamrCloseHandle(&DomainHandle);
    }
    if (ServerHandle != NULL) {
        SamrCloseHandle(&ServerHandle);
    }
    if (UserId.Element != NULL) {
        MIDL_user_free(UserId.Element);
    }
    if (SidUse.Element != NULL) {
        MIDL_user_free(SidUse.Element);
    }
    if (!Unicode && UnicodeUserName.Buffer != NULL) {
        RtlFreeUnicodeString( &UnicodeUserName );
    }

    return(NtStatus);
}

NTSTATUS
SampObtainEffectivePasswordPolicyWithDomainIndex(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   )
{
    PSAMP_DEFINED_DOMAINS   Domain;

    if (!WriteLockAcquired)
    {
        SampAcquireSamLockExclusive();
    }

    Domain = &SampDefinedDomains[ DomainIndex ];

    DomainPasswordInfo->MinPasswordLength = Domain->CurrentFixed.MinPasswordLength;
    DomainPasswordInfo->PasswordHistoryLength = Domain->CurrentFixed.PasswordHistoryLength;
    DomainPasswordInfo->PasswordProperties = Domain->CurrentFixed.PasswordProperties;
    DomainPasswordInfo->MaxPasswordAge = Domain->CurrentFixed.MaxPasswordAge;
    DomainPasswordInfo->MinPasswordAge = Domain->CurrentFixed.MinPasswordAge;

    if (!WriteLockAcquired)
    {
        SampReleaseSamLockExclusive();
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
SampObtainEffectivePasswordPolicy(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN  PSAMP_OBJECT AccountContext,
   IN  BOOLEAN      WriteLockAcquired
   )
{

    return SampObtainEffectivePasswordPolicyWithDomainIndex(
               DomainPasswordInfo,
               AccountContext->DomainIndex,
               WriteLockAcquired
               );
}


NTSTATUS
SampDecryptForPasswordChange(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN Unicode,
    IN BOOLEAN NtPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN BOOLEAN NtKeyUsed,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLmOrNt,
    OUT PUNICODE_STRING  NewClearPassword,
    OUT NT_OWF_PASSWORD *OldNtOwfPassword,
    OUT BOOLEAN         *OldNtPresent,
    OUT LM_OWF_PASSWORD *OldLmOwfPassword,
    OUT BOOLEAN         *OldLmPresent
    )

/*++

  Routine Description

  This routine does the decryption for a password change.


  Parameters

  Unicode                       -- Specifies strings passed in are unicode or OEM
                                   strings. Applies when the encrypted passwords
                                   are used.

  NtPresent                       -- Indicates that the NT OWF is present

  LmPresent                       -- Indicates that the LM OWF is present

  NewEncryptedWithOldNt,          -- Encrypted OWF passwords
  OldNtOwfEncryptedWithNewNt,
  NewEncryptedWithOldLm,
  OldLmOwfEncryptedWithNewLmOrNt


  NewClearPassword                -- The decrypted clear password

  OldNtOwfPassword                -- Old passwords in OWF form
  OldLmOwfPassword

  OldNtPresent                    -- tells if the old LM or  old NT password in OWF
  OldLmPresent                       form could be obtained.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, TmpStatus = STATUS_SUCCESS;
    NT_OWF_PASSWORD StoredNtOwfPassword, NewNtOwfPassword;
    LM_OWF_PASSWORD StoredLmOwfPassword, NewLmOwfPassword;
    BOOLEAN         StoredNtPasswordPresent;
    BOOLEAN         StoredLmPasswordNonNull;
    BOOLEAN         StoredNtPasswordNonNull;
    BOOLEAN         LmPasswordPresent;
    BOOLEAN         AccountLockedOut;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;

    //
    // Should ONLY be called by Non-Loopback Client
    //
    ASSERT(!AccountContext->LoopbackClient);


    *OldNtPresent = FALSE;
    *OldLmPresent = FALSE;

    //
    // Read the old OWF passwords from disk
    //

    NtStatus = SampRetrieveUserPasswords(
                    AccountContext,
                    &StoredLmOwfPassword,
                    &StoredLmPasswordNonNull,
                    &StoredNtOwfPassword,
                    &StoredNtPasswordPresent,
                    &StoredNtPasswordNonNull
                    );

    //
    // If we have old NtOwf passwords, use them
    // Decrypt the doubly-encrypted NT passwords sent to us
    //

    if (NT_SUCCESS(NtStatus)) {

        if (StoredNtPasswordPresent && NtPresent) {

            NtStatus = SampDecryptPasswordWithNtOwfPassword(
                            NewEncryptedWithOldNt,
                            &StoredNtOwfPassword,
                            Unicode,
                            NewClearPassword
                       );

        } else if (LmPresent) {

            //
            // There was no stored NT password and NT passed, so our only
            // hope now is that the stored LM password works.
            //

            //
            // Decrypt the new password encrypted with the old LM password
            //

            NtStatus = SampDecryptPasswordWithLmOwfPassword(
                            NewEncryptedWithOldLm,
                            &StoredLmOwfPassword,
                            Unicode,
                            NewClearPassword
                       );


        } else {

            NtStatus = STATUS_WRONG_PASSWORD;

        }
    }


    //
    // We now have the cleartext new password.
    // Compute the new LmOwf and NtOwf password
    //



    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCalculateLmAndNtOwfPasswords(
                        NewClearPassword,
                        &LmPasswordPresent,
                        &NewLmOwfPassword,
                        &NewNtOwfPassword
                   );

    }

    //
    // If we have both NT passwords, compute the old NT password,
    // otherwise compute the old LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        if (StoredNtPasswordPresent && NtPresent) {
            NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                            OldNtOwfEncryptedWithNewNt,
                            &NewNtOwfPassword,
                            OldNtOwfPassword
                       );

            *OldNtPresent = TRUE;
        }

        if (LmPresent) {


            //
            // If the NT key was used to encrypt this, use the NT key
            // to decrypt it.
            //


            if (NtKeyUsed) {

                ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                OldLmOwfEncryptedWithNewLmOrNt,
                                (PLM_OWF_PASSWORD) &NewNtOwfPassword,
                                OldLmOwfPassword
                           );

                *OldLmPresent = TRUE;


            } else if (LmPasswordPresent) {

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                OldLmOwfEncryptedWithNewLmOrNt,
                                &NewLmOwfPassword,
                                OldLmOwfPassword
                           );
                *OldLmPresent = TRUE;


            } else {
                NtStatus = STATUS_WRONG_PASSWORD;
            }

        }

    }

    //
    // if we have a bad password, then increment the bad password
    // count and check to see if the account should be locked.
    //

    if (STATUS_WRONG_PASSWORD == NtStatus)
    {
        //
        // Get the V1aFixed so we can update the bad password count
        //

        TmpStatus = SampRetrieveUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );

        if (!NT_SUCCESS(TmpStatus))
        {
            //
            // If we can't update the V1aFixed, then return this
            // error so that the user doesn't find out the password
            // was not correct.
            //

            NtStatus = TmpStatus;
        }
        else
        {

            //
            // Increment BadPasswordCount (might lockout account)
            //

            AccountLockedOut = SampIncrementBadPasswordCount(
                                    AccountContext,
                                    &V1aFixed,
                                    NULL
                                    );

            TmpStatus = SampReplaceUserV1aFixed(
                                    AccountContext,
                                    &V1aFixed
                                    );

            if (!NT_SUCCESS(TmpStatus))
                NtStatus = TmpStatus;
        }
    }

    return(NtStatus);

}


NTSTATUS
SampValidateAndChangePassword(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      WriteLockAcquired,
    IN BOOLEAN      ValidatePassword,
    IN NT_OWF_PASSWORD * OldNtOwfPassword,
    IN BOOLEAN         NtPresent,
    IN LM_OWF_PASSWORD * OldLmOwfPassword,
    IN BOOLEAN         LmPresent,
    IN PUNICODE_STRING  NewClearPassword,
    OUT PUNICODE_STRING  PasswordToNotify,
    OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo
    )
/*++

  Routine Description

  This routine authenticates a password change, enforces policy and
  stores the new password, updating history. This is the primary password
  change routine called by various windows clients using RPC interfaces.

  Parameters

        User Handle -- Handle to the user object

        WriteLockAcquired -- Indicates that the write lock has already been
                             acquired

        ValidatePassword  -- Indicates that actualvalidation of the password
                             is required


        OldNtOwfPassword  -- OWF forms of the old password
        OldLmOwfPassword

        NtPresent         -- Indicates which of the 2 OWF forms of the old
        LmPresent            password is present. Nt is used if both are
                             present.

        DomainPasswordInfo -- Indicates the effective password policy
                              that was applied.

--*/

{
    LM_OWF_PASSWORD         StoredLmOwfPassword;
    NT_OWF_PASSWORD         StoredNtOwfPassword;
    NT_OWF_PASSWORD         NewNtOwfPassword;
    LM_OWF_PASSWORD         NewLmOwfPassword;
    BOOLEAN                 LmPasswordPresent;
    BOOLEAN                 StoredLmPasswordNonNull;
    BOOLEAN                 StoredNtPasswordPresent;
    BOOLEAN                 StoredNtPasswordNonNull;
    BOOLEAN                 AccountLockedOut;
    BOOLEAN                 V1aFixedRetrieved = FALSE;
    BOOLEAN                 V1aFixedModified = FALSE;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 LoopbackClient = FALSE;
    LARGE_INTEGER           TimeNow;
    NTSTATUS                NtStatus = STATUS_SUCCESS,
                            IgnoreStatus = STATUS_SUCCESS,
                            TmpStatus = STATUS_SUCCESS;
    UNICODE_STRING          NewPassword;
    BOOLEAN                 MachineAccount = FALSE;
    BOOLEAN                 FreeRandomizedPasswordIgnored = FALSE;


    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    AccountName.Buffer = NULL;
    RtlSecureZeroMemory(&AccountName, sizeof(UNICODE_STRING));

    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime( &TimeNow );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    //  Get some state information.
    //

    LoopbackClient = AccountContext->LoopbackClient;

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Get the effective domain policy
    //

    NtStatus = SampObtainEffectivePasswordPolicy(
                    DomainPasswordInfo,
                    AccountContext,
                    WriteLockAcquired
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    //
    // Get Account Name
    //

    NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext,
                    SAMP_USER_ACCOUNT_NAME,
                    TRUE,           // make a copy
                    &AccountName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get fixed attributes and check for account lockout
        //

        NtStatus = SampCheckForAccountLockout(
                        AccountContext,
                        &V1aFixed,
                        FALSE   // V1aFixed is not retrieved yet
                        );

        if (NT_SUCCESS(NtStatus))
        {

            MachineAccount = ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!=0);

            V1aFixedRetrieved = TRUE;

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Read the old OWF passwords from disk
        //

        NtStatus = SampRetrieveUserPasswords(
                        AccountContext,
                        &StoredLmOwfPassword,
                        &StoredLmPasswordNonNull,
                        &StoredNtOwfPassword,
                        &StoredNtPasswordPresent,
                        &StoredNtPasswordNonNull
                        );

        //
        // Check the password can be changed at this time
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Only do the check if one of the passwords is non-null.
            // A Null password can always be changed.
            //

            if (StoredNtPasswordNonNull || StoredLmPasswordNonNull) {

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // If the min password age is non zero, check it here
                    //

                    if ((DomainPasswordInfo->MinPasswordAge.QuadPart != SampHasNeverTime.QuadPart) &&
                        (!MachineAccount))
                    {

                        LARGE_INTEGER PasswordCanChange = SampAddDeltaTime(
                                         V1aFixed.PasswordLastSet,
                                         DomainPasswordInfo->MinPasswordAge);


                        if (TimeNow.QuadPart < PasswordCanChange.QuadPart) {
                            NtStatus = STATUS_PASSWORD_RESTRICTION;
                        }
                    }
                }
            }
        }

        //
        // Verify the passed in passwords with respect to what is stored
        // locally.
        //
        if (NT_SUCCESS(NtStatus) && (ValidatePassword)) {

            NtStatus = SampValidatePresentAndStoredCombination(
                           NtPresent,
                           LmPresent,
                           StoredNtPasswordPresent,
                           StoredNtPasswordNonNull,
                           StoredLmPasswordNonNull);
        }

        //
        // We now have the cleartext new password.
        // Compute the new LmOwf and NtOwf password
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampCalculateLmAndNtOwfPasswords(
                            NewClearPassword,
                            &LmPasswordPresent,
                            &NewLmOwfPassword,
                            &NewNtOwfPassword
                       );

        }

        //
        // Authenticate the password change operation based on what
        // we have stored and what was passed.  We authenticate whatever
        // passwords were sent .
        //

        if ((NT_SUCCESS(NtStatus)) && (ValidatePassword)) {

            if (NtPresent && StoredNtPasswordPresent) {

                //
                // NtPresent = TRUE, we were passed an NT password
                //

                if (!RtlEqualNtOwfPassword(OldNtOwfPassword, &StoredNtOwfPassword)) {

                    //
                    // Old NT passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                }
            } else if (LmPresent) {

                //
                // LM data passed. Use LM data for authentication
                //

                if (!RtlEqualLmOwfPassword(OldLmOwfPassword, &StoredLmOwfPassword)) {

                    //
                    // Old LM passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                }

            } else {
                NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;
            }

        }

        //
        // We now have a NewLmOwfPassword and a NewNtOwfPassword.
        //

        //
        // Write the new passwords to disk; Note SampStoreUserPasswords
        // enforces password policy checks.
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // We should ahave an LM and an NT password to store.
            //

            NtStatus = SampStoreUserPasswords(
                           AccountContext,
                           &NewLmOwfPassword,
                           LmPasswordPresent,
                           &NewNtOwfPassword,
                           TRUE,
                           TRUE, // Check Password Restrictions
                           PasswordChange,
                           DomainPasswordInfo,
                           NewClearPassword,
                           NULL,
                           PasswordToNotify,
                           PasswordChangeFailureInfo
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We know the password is not expired.
                //

                NtStatus = SampStorePasswordExpired(
                               AccountContext,
                               FALSE
                               );
            }
        }



        //
        // if we have a bad password, then increment the bad password
        // count and check to see if the account should be locked.
        //

        if (NtStatus == STATUS_WRONG_PASSWORD) {

            //
            // Get the V1aFixed so we can update the bad password count
            //


            TmpStatus = STATUS_SUCCESS;
            if (!V1aFixedRetrieved) {
                TmpStatus = SampRetrieveUserV1aFixed(
                                AccountContext,
                                &V1aFixed
                                );
            }

            if (!NT_SUCCESS(TmpStatus)) {

                //
                // If we can't update the V1aFixed, then return this
                // error so that the user doesn't find out the password
                // was not correct.
                //

                NtStatus = TmpStatus;

            } else  if (!LoopbackClient) {


                //
                // Increment BadPasswordCount (might lockout account)
                //


                AccountLockedOut = SampIncrementBadPasswordCount(
                                       AccountContext,
                                       &V1aFixed,
                                       NULL
                                       );

                V1aFixedModified = TRUE;


            }
            else
            {
                //
                // Called from loopback, increment bad password count,
                // after current transaction is rolled back by the DS
                // This transaction needs to be rolled back because
                // there could be other things that the client is modifying
                // at the same time
                //

                SampAddLoopbackTaskForBadPasswordCount(&AccountName);
            }

        }
        else if (STATUS_NO_SUCH_USER==NtStatus) 
        {
            //
            // Don't allow information disclosure bugs
            //

            NtStatus = STATUS_WRONG_PASSWORD;
        }

        if (V1aFixedModified) {
            TmpStatus = SampReplaceUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Password change was successful; check if site affinity
            // needs updating when the context is dereferenced
            //
            ASSERT(AccountContext->ObjectType == SampUserObjectType);
            AccountContext->TypeBody.User.fCheckForSiteAffinityUpdate = TRUE;
        }
    }

    SampFreeUnicodeString( &AccountName );

    return(NtStatus);

}


NTSTATUS
SampChangePasswordUser2(
    IN handle_t        BindingHandle,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN BOOLEAN Unicode,
    IN BOOLEAN NtPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN BOOLEAN NtKeyUsed,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLmOrNt,
    OUT PDOMAIN_PASSWORD_INFORMATION    DomainPasswordInfo,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    BindingHandle -- the RPC binding handle that generated the call

    ServerName - Name of the machine this SAM resides on. Ignored by this
        routine, may be UNICODE or OEM string depending on Unicode parameter.

    UserName - User Name of account to change password on, may be UNICODE or
        OEM depending on Unicode parameter.

    Unicode - Indicated whether the strings passed in are Unicode or OEM
        strings.

    NtPresent - Are the Nt encrypted passwords present.

    NewEncryptedWithOldNt - The new cleartext password encrypted with the old
        NT OWF password. Dependinf on the Unicode parameter, the clear text
        password may be Unicode or OEM.

    OldNtOwfEncryptedWithNewNt - Old NT OWF password encrypted with the new
        NT OWF password.

    LmPresent - are the Lm encrypted passwords present.

    NewEncryptedWithOldLm - Contains new cleartext password (OEM or Unicode)
        encrypted with the old LM OWF password

    NtKeyUsed - Indicates whether the LM or NT OWF key was used to encrypt
        the OldLmOwfEncryptedWithNewlmOrNt parameter.

    OldLmOwfEncryptedWithNewlmOrNt - The old LM OWF password encrypted
        with either the new LM OWF password or NT OWF password, depending
        on the NtKeyUsed parameter.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    SAMPR_HANDLE            UserHandle=NULL;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    UNICODE_STRING          NewClearPassword;
    UNICODE_STRING          PasswordToNotify;
    UNICODE_STRING          UnicodeUserName;
    SAMP_OBJECT_TYPE        FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed;



    SAMTRACE("SampChangePasswordUser2");

    //
    // Firewall against NULL pointers
    //
    if (NtPresent) {
        if ((NewEncryptedWithOldNt == NULL)
         || (OldNtOwfEncryptedWithNewNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (LmPresent) {
        if ((NewEncryptedWithOldLm == NULL)
         || (OldLmOwfEncryptedWithNewLmOrNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Note: UserName is not [unique] so can't be NULL
    //
    if (NULL==UserName->Buffer)
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Validate some parameters.  We require that one of the two passwords
    // be present.
    //

    if (!NtPresent && !LmPresent) {

        return(STATUS_INVALID_PARAMETER_MIX);
    }
    
    
    //
    // Drop calls over invalid / uninstalled protocol sequences
    //
    
    NtStatus = SampValidateRpcProtSeq((RPC_BINDING_HANDLE)BindingHandle);
    
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }
    

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Init some variables
    //

    RtlSecureZeroMemory(&UnicodeUserName,sizeof(UNICODE_STRING));
    RtlSecureZeroMemory(&NewClearPassword,sizeof(UNICODE_STRING));
    RtlSecureZeroMemory(&PasswordToNotify,sizeof(UNICODE_STRING));

    //
    // Open the user (UserName may or may not be unicode string)
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    Unicode,
                    FALSE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }


    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Lookup the context, perform an access check
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NT_OWF_PASSWORD OldNtOwfPassword;
        BOOLEAN         OldNtPresent = FALSE;
        LM_OWF_PASSWORD OldLmOwfPassword;
        BOOLEAN         OldLmPresent = FALSE;

        //
        // Retrieve Unicode SAM User Account Name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        AccountContext,
                        SAMP_USER_ACCOUNT_NAME,
                        TRUE,      // make a copy
                        &UnicodeUserName
                        );


        if (NT_SUCCESS(NtStatus))
        {

            //
            // Extract the IP Address, if any
            //
            (VOID) SampExtractClientIpAddr(AccountContext);


            NtStatus = SampRetrieveUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );

            if (NT_SUCCESS(NtStatus))
            {

                //
                // Decrypt the cross encrypted hashes.
                //

                NtStatus = SampDecryptForPasswordChange(
                                AccountContext,
                                Unicode,
                                NtPresent,
                                NewEncryptedWithOldNt,
                                OldNtOwfEncryptedWithNewNt,
                                LmPresent,
                                NewEncryptedWithOldLm,
                                NtKeyUsed,
                                OldLmOwfEncryptedWithNewLmOrNt,
                                &NewClearPassword,
                                &OldNtOwfPassword,
                                &OldNtPresent,
                                &OldLmOwfPassword,
                                &OldLmPresent
                                );

                if (NT_SUCCESS(NtStatus))
                {

                    //
                    // Authenticate the password change operation
                    // and change the password.
                    //

                    NtStatus = SampValidateAndChangePassword(
                                    UserHandle,
                                    TRUE,
                                    TRUE,
                                    &OldNtOwfPassword,
                                    OldNtPresent,
                                    &OldLmOwfPassword,
                                    OldLmPresent,
                                    &NewClearPassword,
                                    &PasswordToNotify,
                                    DomainPasswordInfo,
                                    PasswordChangeFailureInfo
                                    );
                }
                //
                // Dereference the account context
                //

                if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {

                    //
                    // De-reference the object, write out any change to current xaction.
                    //

                    TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

                    //
                    // retain previous error/success value unless we have
                    // an over-riding error from our dereference.
                    //

                    if (!NT_SUCCESS(TmpStatus)) {
                        NtStatus = TmpStatus;
                    }

                } else {

                    //
                    // De-reference the object, ignore changes
                    //

                    IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }
            }
        }
    }

    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            DomainSidFromAccountContext(AccountContext),// Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &UnicodeUserName,            // Account Name
            &SampDefinedDomains[AccountContext->DomainIndex].ExternalName,// Domain
            &ObjectRid,                  // Account Rid
            NULL,                        // Privileges used
            NULL                         // New State Data
            );

    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
        }

        IgnoreStatus = SampPasswordChangeNotify(
                            NotifyFlags,
                            &UnicodeUserName,
                            ObjectRid,
                            &PasswordToNotify,
                            FALSE    // not loopback
                            );
    }

    SamrCloseHandle(&UserHandle);

    if (NewClearPassword.Buffer != NULL) {

        RtlSecureZeroMemory(
            NewClearPassword.Buffer,
            NewClearPassword.Length
            );

    }

    if (PasswordToNotify.Buffer != NULL) {

        RtlSecureZeroMemory(
            NewClearPassword.Buffer,
            NewClearPassword.Length
            );

        MIDL_user_free(PasswordToNotify.Buffer);

    }

     if ( Unicode ) {

        SampFreeUnicodeString( &NewClearPassword );
    } else {

        RtlFreeUnicodeString( &NewClearPassword );
    }

    if (UnicodeUserName.Buffer)
    {
        MIDL_user_free(UnicodeUserName.Buffer);
    }

    return(NtStatus);
}

NTSTATUS
SampDsSetPasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING PassedInPassword
    )


/*++

Routine Description:

   This is a set password routine, intended to be called
   by the DS.


Parameters:

    UserHandle -- Handle to the user object

    OldClearPassword  -- The old password in the clear

    NewClearPassword  -- The new password in the clear


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.



    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          AccountName;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 fContextReferenced = FALSE;
    NT_OWF_PASSWORD         NtOwfBuffer;
    LM_OWF_PASSWORD         LmOwfBuffer;
    BOOLEAN                 LmPresent;
    BOOLEAN                 fCanUnexpirePassword = FALSE;
    UNICODE_STRING          PasswordToNotify;


    SAMTRACE("SampDsSetPasswordUser");

    //
    // Init some variables
    //

    
    RtlSecureZeroMemory(&AccountName,sizeof(AccountName));
    RtlSecureZeroMemory(&PasswordToNotify,sizeof(PasswordToNotify));


    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;


    //
    // Validate the passed in context and see if the user handle
    // was opened with password set access
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_FORCE_PASSWORD_CHANGE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    fContextReferenced = TRUE;

    //
    // Retrieve the account name for Auditing
    //

    NtStatus = SampGetUnicodeStringAttribute(
                AccountContext,
                SAMP_USER_ACCOUNT_NAME,
                TRUE,           // make a copy
                &AccountName
                );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Get the effective domain policy
    //

    NtStatus = SampObtainEffectivePasswordPolicy(
                &DomainPasswordInfo,
                AccountContext,
                FALSE
                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Get the user fixed attributes
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   AccountContext,
                   &V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Calculate OWF passwords
    //

    NtStatus = SampCalculateLmAndNtOwfPasswords(
                    PassedInPassword,
                    &LmPresent,
                    &LmOwfBuffer,
                    &NtOwfBuffer
                    );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Set the password data; after enforcing
    // password policies
    //

    NtStatus = SampStoreUserPasswords(
                    AccountContext,
                    &LmOwfBuffer,
                    LmPresent,
                    &NtOwfBuffer,
                    TRUE,
                    TRUE, // Check Restrictions
                    PasswordSet,
                    &DomainPasswordInfo,
                    PassedInPassword,
                    NULL,
                    &PasswordToNotify,
                    NULL
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Once the password is set,
    // 
    // if client can unexpire user password, 
    //    set PwdLastSet to current time - don't expire pwd now
    // 
    // otherwise
    //    set PwdLastSet to 0 - expire the password immediatedly
    // 
    //

    NtStatus = SampIsPwdSettingAttemptGranted(
                    AccountContext, 
                    NULL,   // client token
                    V1aFixed.UserAccountControl,
                    (GUID *) &GUID_CONTROL_UnexpirePassword,
                    &fCanUnexpirePassword
                    );

    if ( NT_SUCCESS(NtStatus) )
    {

        //
        // Set the password last set time
        //

        NtStatus = SampComputePasswordExpired(
                    fCanUnexpirePassword ? FALSE : TRUE,
                    &V1aFixed.PasswordLastSet
                    );

    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    NtStatus = SampReplaceUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Note the caller in loopback is responsible for notifying the packages
    // that the password changed.
    //

Cleanup:


      if (fContextReferenced)
      {

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus))
    {

        PSAMP_DEFINED_DOMAINS   Domain = NULL;

        Domain = &SampDefinedDomains[AccountContext->DomainIndex];

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_SET,    // AuditID
            Domain->Sid,    // Domain Sid
            NULL,           // Additional Info
            NULL,           // Member Rid
            NULL,           // Member Sid
            &AccountName,   // AccountName
            &Domain->ExternalName,  // Domain Name
            &ObjectRid,     // Account Rid
            NULL,           // Privileges used
            NULL            // New State Data
            );
    }

    if (NULL!=AccountName.Buffer)
    {
        MIDL_user_free(AccountName.Buffer);
    }

    if (NULL!=PasswordToNotify.Buffer)
    {
        RtlSecureZeroMemory(PasswordToNotify.Buffer,PasswordToNotify.Length);
        MIDL_user_free(PasswordToNotify.Buffer);
    }


    return(NtStatus);

}

NTSTATUS
SampDsChangePasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING OldClearPassword,
    IN PUNICODE_STRING NewClearPassword
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD. Password update restrictions
    apply. This is the change password entry point when password change
    is called by the DS ( to satisfy an ldap request )


Parameters:

    UserHandle -- Handle to the user object

    OldClearPassword  -- The old password in the clear

    NewClearPassword  -- The new password in the clear


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    UNICODE_STRING          PasswordToNotify;



    SAMTRACE("SampDsChangePasswordUser");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    
    RtlSecureZeroMemory(&AccountName,sizeof(AccountName));
    RtlSecureZeroMemory(&PasswordToNotify,sizeof(PasswordToNotify));
       


    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Retrieve the account name for Auditing
        //

        NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext,
                    SAMP_USER_ACCOUNT_NAME,
                    TRUE,           // make a copy
                    &AccountName
                    );

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Get the user fixed attributes
            //

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );



            if (NT_SUCCESS(NtStatus))
            {
                NT_OWF_PASSWORD OldNtOwfPassword;
                LM_OWF_PASSWORD OldLmOwfPassword;
                BOOLEAN         LmPresent;

                //
                // Calculate the OWF passwords of the old
                // old password
                //

                NtStatus = SampCalculateLmAndNtOwfPasswords(
                                OldClearPassword,
                                &LmPresent,
                                &OldLmOwfPassword,
                                &OldNtOwfPassword
                                );

                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampValidateAndChangePassword(
                                    UserHandle,
                                    FALSE, // write lock is acquired
                                    TRUE, //validate old password
                                    &OldNtOwfPassword,
                                    TRUE, //NtPresent,
                                    &OldLmOwfPassword,
                                    LmPresent,
                                    NewClearPassword,
                                    &PasswordToNotify,
                                    &DomainPasswordInfo,
                                    NULL
                                    );
                }
            }
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current
            // transaction
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            DomainSidFromAccountContext(AccountContext),// Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                    // Account Name
            &SampDefinedDomains[AccountContext->DomainIndex].ExternalName,// Domain
            &ObjectRid,                  // Account Rid
            NULL,                        // Privileges used
            NULL                         // New State Data
            );

    }

    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
        }
        IgnoreStatus = SampPasswordChangeNotify(
                            NotifyFlags,
                            &AccountName,
                            ObjectRid,
                            &PasswordToNotify,
                            TRUE            // loopback
                            );
    }

    //
    // Zero out old and new clear passwords
    //

    if (NewClearPassword->Buffer != NULL) {

        RtlSecureZeroMemory(
            NewClearPassword->Buffer,
            NewClearPassword->Length
            );

    }

    if (OldClearPassword->Buffer != NULL) {

        RtlSecureZeroMemory(
            OldClearPassword->Buffer,
            OldClearPassword->Length
            );

    }

    if (PasswordToNotify.Buffer != NULL) {

        RtlSecureZeroMemory(
            PasswordToNotify.Buffer,
            PasswordToNotify.Length
            );

        MIDL_user_free(PasswordToNotify.Buffer);

    }

    return(NtStatus);
}

NTSTATUS
SamrOemChangePasswordUser2(
    IN handle_t BindingHandle,
    IN PRPC_STRING ServerName,
    IN PRPC_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/
{
    NTSTATUS    NtStatus = STATUS_INVALID_PARAMETER;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;


    SAMTRACE_EX("SamrOemChangePasswordUser2");

    if( ARGUMENT_PRESENT( ServerName ) ) {
        if( !SampValidateRpcString( ServerName ) ) {
            goto Error;
        }
    }
    if( !SampValidateRpcString( UserName ) ) {
        goto Error;
    }

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                FALSE,                          // not unicode
                FALSE,                          // NT not present
                NULL,                           // new NT password
                NULL,                           // old NT password
                TRUE,                           // LM present
                NewEncryptedWithOldLm,
                FALSE,                          // NT key not used
                OldLmOwfEncryptedWithNewLm,
                &DomainPasswordInfo,
                NULL
                );

    if (NtStatus == STATUS_ILL_FORMED_PASSWORD) {

        //
        // Downlevel clients don't understand
        // this error code
        //
        NtStatus = STATUS_WRONG_PASSWORD;
    }

Error:
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);

}





NTSTATUS
SamrUnicodeChangePasswordUser2(
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN PRPC_UNICODE_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/

{
    NTSTATUS    NtStatus = STATUS_INVALID_PARAMETER;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;

    SAMTRACE_EX("SamrUnicodeChangePasswordUser2");

    if( ARGUMENT_PRESENT( ServerName ) ) {
        if( !SampValidateRpcUnicodeString( ServerName ) ) {
            goto Error;
        }
    }
    if( !SampValidateRpcUnicodeString( UserName ) ) {
        goto Error;
    }

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                TRUE,                           // unicode
                TRUE,                           // NT present
                NewEncryptedWithOldNt,
                OldNtOwfEncryptedWithNewNt,
                LmPresent,
                NewEncryptedWithOldLm,
                TRUE,                           // NT key used
                OldLmOwfEncryptedWithNewNt,
                &DomainPasswordInfo,
                NULL
                );

Error:
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamrUnicodeChangePasswordUser3(
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN PRPC_UNICODE_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewNt,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD  AdditionalData,
    OUT PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/

{
    NTSTATUS    NtStatus;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfoLocal;

    SAMTRACE_EX("SamrUnicodeChangePasswordUser3");


    if ((NULL==EffectivePasswordPolicy) || (NULL!=*EffectivePasswordPolicy))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if ((NULL==PasswordChangeFailureInfo) || (NULL!=*PasswordChangeFailureInfo))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if ( ARGUMENT_PRESENT( ServerName ) ) {
        if( !SampValidateRpcUnicodeString( ServerName ) ) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if( !SampValidateRpcUnicodeString( UserName ) ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Pre-allocate memory for holding the effective policy and failure
    // information
    //

    *EffectivePasswordPolicy = MIDL_user_allocate(
                                            sizeof(DOMAIN_PASSWORD_INFORMATION));
    if (NULL==*EffectivePasswordPolicy)
    {
        return(STATUS_NO_MEMORY);
    }

    *PasswordChangeFailureInfo = MIDL_user_allocate(
                                            sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

    if (NULL==*PasswordChangeFailureInfo)
    {
        MIDL_user_free(*EffectivePasswordPolicy);
        *EffectivePasswordPolicy = NULL;
        return(STATUS_NO_MEMORY);
    }

    //
    // Zero out  out parameters
    //


    RtlSecureZeroMemory(*EffectivePasswordPolicy, sizeof(DOMAIN_PASSWORD_INFORMATION));
    RtlSecureZeroMemory(*PasswordChangeFailureInfo, 
                           sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

    RtlSecureZeroMemory(&DomainPasswordInfo,sizeof(DOMAIN_PASSWORD_INFORMATION));
    RtlSecureZeroMemory(&PasswordChangeFailureInfoLocal,
                           sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                TRUE,                           // unicode
                TRUE,                           // NT present
                NewEncryptedWithOldNt,
                OldNtOwfEncryptedWithNewNt,
                LmPresent,
                NewEncryptedWithOldLm,
                TRUE,                           // NT key used
                OldLmOwfEncryptedWithNewNt,
                &DomainPasswordInfo,
                &PasswordChangeFailureInfoLocal
                );



        if (STATUS_PASSWORD_RESTRICTION==NtStatus)
        {
            //
            // If the password change was failed with a password restriction
            // return additional info regarding the failure
            //

            RtlCopyMemory(*EffectivePasswordPolicy,
                          &DomainPasswordInfo,
                          sizeof(DOMAIN_PASSWORD_INFORMATION));


            RtlCopyMemory(*PasswordChangeFailureInfo,
                          &PasswordChangeFailureInfoLocal,
                          sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

        }
        else
        {
            MIDL_user_free(*EffectivePasswordPolicy);
            *EffectivePasswordPolicy = NULL;

            MIDL_user_free(*PasswordChangeFailureInfo);
            *PasswordChangeFailureInfo = NULL;
        }




    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamIChangePasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    )
//
// See SamIChangePasswordForeignUser2
//
{
    return SamIChangePasswordForeignUser2(NULL,
                                          UserName,
                                          NewPassword,
                                          ClientToken,
                                          DesiredAccess);
}

NTSTATUS
SamIChangePasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This service sets the password for user UserName to NewPassword only
    if NewPassword matches policy constraints and the calling user has
    USER_CHANGE_PASSWORD access to the account.


Parameters:

    ClientInfo - Information about the client's location (eg IP address)

    UserName - User Name of account to change password on

    NewPassword - The new cleartext password.

    ClientToken - Token of client to impersonate, optional.

    DesiredAccess - Access to verify for this request.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMPR_HANDLE            UserHandle = NULL;
    BOOLEAN                 MachineAccount = FALSE;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo;
    UNICODE_STRING          PasswordToNotify

    SAMTRACE("SamIChangePasswordForeignUser");


    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    RtlInitUnicodeString(&AccountName,
                         NULL
                         );

    RtlSecureZeroMemory(&PasswordToNotify,sizeof(UNICODE_STRING));
    //
    // Open the user
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    TRUE,
                    TRUE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   0,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Set the client info, if any
    //
    if (ClientInfo) {
        AccountContext->TypeBody.User.ClientInfo = *ClientInfo;
    }

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    if (ARGUMENT_PRESENT(ClientToken))
    {
        //
        // If a client token was passed in then access ck
        // for change password access.
        //

        ASSERT(USER_CHANGE_PASSWORD == DesiredAccess);
        AccountContext->TrustedClient = FALSE;

        NtStatus = SampValidateObjectAccess2(
                        AccountContext,
                        USER_CHANGE_PASSWORD,
                        ClientToken,
                        FALSE,
                        TRUE, // Change Password
                        FALSE // Set Password
                        );
    }

    //
    // Auditing information
    //

    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampGetUnicodeStringAttribute(
                      AccountContext,
                      SAMP_USER_ACCOUNT_NAME,
                      TRUE,           // make a copy
                      &AccountName
                      );
    }

    //
    // Perform the actual change password operation
    //

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampValidateAndChangePassword(
                            UserHandle,
                            TRUE,
                            FALSE,
                            NULL,
                            FALSE,
                            NULL,
                            FALSE,
                            NewPassword,
                            &PasswordToNotify,
                            &DomainPasswordInfo,
                            &PasswordChangeFailureInfo
                            );
    }

    //
    // Dereference the account context
    //

    if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

    } else {

        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (  SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)
       && ARGUMENT_PRESENT(ClientToken) ) {

        BOOL fImpersonate;

        //
        // Only audit if a token is passed in. NETLOGON uses this
        // function to reset machine account passwords over the
        // secure channel hence there is no token present.  Without
        // a token, we could audit the event as SYSTEM or ANONYMOUS
        // but that is misleading. Also, it is confusing for admin's
        // to password changes by "ANONYMOUS" -- it looks like
        // the system is being hacked.
        //

        //
        // We impersonate here so the audit correctly log the user
        // that is changing the password.
        //
        fImpersonate = ImpersonateLoggedOnUser( ClientToken );

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            Domain->Sid,                 // Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                // Account Name
            &Domain->ExternalName,       // Domain
            &ObjectRid,                  // Account Rid
            NULL,                        // Privileges used
            NULL                         // New State Data
            );

        if ( fImpersonate ) {

            RevertToSelf();

        }

    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (MachineAccount) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
        }

        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,
                        &AccountName,
                        ObjectRid,
                        &PasswordToNotify,
                        FALSE  // not loopback
                        );
    }

    //
    // Reset the trusted client bit
    //

    AccountContext->TrustedClient = TRUE;
    SamrCloseHandle(&UserHandle);


    SampFreeUnicodeString( &AccountName );

    if (NULL!=PasswordToNotify.Buffer)
    {
        RtlSecureZeroMemory(
            PasswordToNotify.Buffer,
            PasswordToNotify.Length
            );

        MIDL_user_free(PasswordToNotify.Buffer);
    }

    return(NtStatus);
}

NTSTATUS
SamISetPasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    )
//
// See SamISetPasswordForeignUser2
//
{
    return SamISetPasswordForeignUser2(NULL,
                                       UserName,
                                       NewPassword,
                                       ClientToken);
}

NTSTATUS
SamISetPasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PassedInPassword,
    IN HANDLE ClientToken
    )
/*++

Routine Description:

    This service sets the password for user UserName to NewPassword,
    w/ access based on "Set Password" permissions

Parameters:

    ClientInfo - information about the client's location (eg. IP address)

    UserName - User Name of account to change password on

    NewPassword - The new cleartext password.

    ClientToken - Token of client to impersonate, optional.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName, FullName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    SAMPR_HANDLE            UserHandle = NULL;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo;
    SAMPR_USER_INFO_BUFFER UserInfo = {0};

    NT_OWF_PASSWORD     NtOwfBuffer;
    LM_OWF_PASSWORD     LmOwfBuffer;
    BOOLEAN             LmPresent;
    BOOLEAN             FreeRandomizedPassword = FALSE;
    BOOLEAN             fCanUnexpirePassword = FALSE;
    UNICODE_STRING      PasswordToNotify;


    SAMTRACE("SamISetPasswordForeignUser");

    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    RtlInitUnicodeString(&AccountName,
                         NULL
                         );

    RtlSecureZeroMemory(&PasswordToNotify,sizeof(UNICODE_STRING));

    //
    // Open the user
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    TRUE,
                    TRUE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //
    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_FORCE_PASSWORD_CHANGE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Set the client info, if any
    //
    if (ClientInfo) {
        AccountContext->TypeBody.User.ClientInfo = *ClientInfo;
    }

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    //
    // If a client token was passed in then access ck
    // for change password access.
    //

    AccountContext->TrustedClient = FALSE;

    NtStatus = SampValidateObjectAccess2(
                              AccountContext,
                              USER_FORCE_PASSWORD_CHANGE,
                              ClientToken,
                              FALSE,
                              FALSE, // Change password
                              TRUE // Set Password
                              );
    //
    // Auditing information
    //
    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampGetUnicodeStringAttribute(
                             AccountContext,
                             SAMP_USER_ACCOUNT_NAME,
                             TRUE,           // make a copy
                             &AccountName
                             );
    }

    //
    //   GetV1a info
    //
    if (NT_SUCCESS(NtStatus))
    {

       NtStatus = SampRetrieveUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
    }

    //
    // Get the effective domain policy
    //
    if (NT_SUCCESS(NtStatus))
    {

       NtStatus = SampObtainEffectivePasswordPolicy(
                            &DomainPasswordInfo,
                            AccountContext,
                            TRUE
                            );
    }

    //
    // Perform the actual change password operation
    //
    if (NT_SUCCESS(NtStatus))
    {

       NtStatus = SampCalculateLmAndNtOwfPasswords(
                            PassedInPassword,
                            &LmPresent,
                            &LmOwfBuffer,
                            &NtOwfBuffer
                            );
    }

    //
    // Store the passwords after applying any password
    // policies.
    //

    if (NT_SUCCESS(NtStatus))
    {
       NtStatus = SampStoreUserPasswords(
                            AccountContext,
                            &LmOwfBuffer,
                            LmPresent,
                            &NtOwfBuffer,
                            TRUE, // NTOWF always there
                            TRUE, // check password restrictions
                            PasswordSet,
                            &DomainPasswordInfo,
                            PassedInPassword,
                            NULL,
                            &PasswordToNotify,
                            NULL
                            );
    }



    //
    //   Update the password expired field
    // 
    //   if client can unexpire user password, 
    //      set PwdLastSet to current time - don't expire pwd now
    // 
    //   otherwise
    //      set PwdLastSet to 0 - expire the password immediatedly
    // 


    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampIsPwdSettingAttemptGranted(
                            AccountContext, 
                            ClientToken,   // client token
                            V1aFixed.UserAccountControl,
                            (GUID *) &GUID_CONTROL_UnexpirePassword,
                            &fCanUnexpirePassword
                            );


        if ( NT_SUCCESS(NtStatus) )
        {

            NtStatus = SampStorePasswordExpired(
                            AccountContext,
                            fCanUnexpirePassword ? FALSE : TRUE
                            );
        }

    }




    AccountContext->TrustedClient = TRUE;

    //
    // Dereference the account context
    //

    if (NT_SUCCESS(NtStatus)) {


        //
        // De-reference the object, write out any change to current xaction.
        //

        TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

    } else {

        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus)) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (  SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus) )
    {
        BOOL fImpersonate;

        //
        // Only audit if a token is passed in. NETLOGON uses this
        // function to reset machine account passwords over the
        // secure channel hence there is no token present.  Without
        // a token, we could audit the event as SYSTEM or ANONYMOUS
        // but that is misleading. Also, it is confusing for admin's
        // to password changes by "ANONYMOUS" -- it looks like
        // the system is being hacked.
        //

        //
        // We impersonate here so the audit correctly log the user
        // that is changing the password.
        //
        fImpersonate = ImpersonateLoggedOnUser( ClientToken );

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_SET, // AuditId
            Domain->Sid,                 // Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                // Account Name
            &Domain->ExternalName,       // Domain
            &ObjectRid,                  // Account Rid
            NULL,                        // Privileges used
            NULL                         // New State Data
            );

        if ( fImpersonate ) {

            RevertToSelf();

        }

    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    //
    // Notify any notification packages that a password has changed.
    //
    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
        }

        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,
                        &AccountName,
                        ObjectRid,
                        &PasswordToNotify,
                        FALSE  // not loopback
                        );
    }

    SamrCloseHandle(&UserHandle);

    SampFreeUnicodeString( &AccountName );

    if (NULL!=PasswordToNotify.Buffer)
    {
        RtlSecureZeroMemory(PasswordToNotify.Buffer,PasswordToNotify.Length);
        MIDL_user_free(PasswordToNotify.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
SamrGetGroupsForUser(
    IN SAMPR_HANDLE UserHandle,
    OUT PSAMPR_GET_GROUPS_BUFFER *Groups
    )


/*++

Routine Description:

    This service returns the list of groups that a user is a member of.
    It returns a structure for each group that includes the relative ID
    of the group, and the attributes of the group that are assigned to
    the user.

    This service requires USER_LIST_GROUPS access to the user account
    object.




Parameters:

    UserHandle - The handle of an opened user to operate on.

    Groups - Receives a pointer to a buffer containing a count of members
        and a pointer to a second buffer containing an array of
        GROUP_MEMBERSHIPs data structures.  When this information is
        no longer needed, these buffers must be freed using
        SamFreeMemory().


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.



--*/
{

    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    SAMP_OBJECT_TYPE            FoundType;
    BOOLEAN                     fReadLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrGetGroupsForUser");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetGroupsForUser
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Groups != NULL);

    if ((*Groups) != NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrGetGroupsForUserError;
    }



    //
    // Allocate the first of the return buffers
    //

    (*Groups) = MIDL_user_allocate( sizeof(SAMPR_GET_GROUPS_BUFFER) );

    if ( (*Groups) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrGetGroupsForUserError;
    }




    SampMaybeAcquireReadLock((PSAMP_OBJECT) UserHandle,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fReadLockAcquired);


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;
    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_LIST_GROUPS,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveUserMembership(
                       AccountContext,
                       TRUE, // Make copy
                       &(*Groups)->MembershipCount,
                       &(*Groups)->Groups
                       );

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fReadLockAcquired);


    if (!NT_SUCCESS(NtStatus)) {

        (*Groups)->MembershipCount = 0;

        MIDL_user_free( (*Groups) );
        (*Groups) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

SamrGetGroupsForUserError:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetGroupsForUser
                   );

    return( NtStatus );
}



NTSTATUS
SamrGetUserDomainPasswordInformation(
    IN SAMPR_HANDLE UserHandle,
    OUT PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation
    )


/*++

Routine Description:

    Takes a user handle, finds the domain for that user, and returns
    password information for the domain.  This is so the client\wrappers.c
    can get the information to verify the user's password before it is
    OWF'd.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    PasswordInformation - Receives information about password restrictions
        for the user's domain.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    Other errors may be returned from SampLookupContext() if the handle
    is invalid or does not indicate proper access to the domain's password
    inforamtion.

--*/
{
    SAMP_OBJECT_TYPE            FoundType;
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrGetUserDomainPasswordInformation");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetUserDomainPasswordInformation
                   );

    SampAcquireReadLock();

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   0,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // When the user was opened, we checked to see if the domain handle
        // allowed access to the domain password information.  Check that here.
        //

        if ( !( AccountContext->TypeBody.User.DomainPasswordInformationAccessible ) ) {

            NtStatus = STATUS_ACCESS_DENIED;

        } else {

            Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

            //
            // If the user account is a machine account,
            // or a service account such as krbtgt
            // then restrictions are generally not enforced.
            // This is so that simple initial passwords can be
            // established.  IT IS EXPECTED THAT COMPLEX PASSWORDS,
            // WHICH MEET THE MOST STRINGENT RESTRICTIONS, WILL BE
            // AUTOMATICALLY ESTABLISHED AND MAINTAINED ONCE THE MACHINE
            // JOINS THE DOMAIN.  It is the UI's responsibility to
            // maintain this level of complexity.
            //


            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );

            if (NT_SUCCESS(NtStatus)) {
                if ( ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!= 0 )
                    || (DOMAIN_USER_RID_KRBTGT==V1aFixed.UserId)){

                    PasswordInformation->MinPasswordLength = 0;
                    PasswordInformation->PasswordProperties = 0;
                } else {

                    PasswordInformation->MinPasswordLength = Domain->UnmodifiedFixed.MinPasswordLength;
                    PasswordInformation->PasswordProperties = Domain->UnmodifiedFixed.PasswordProperties;
                }
            }
        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetUserDomainPasswordInformation
                   );

    return( NtStatus );
}



NTSTATUS
SamrGetDomainPasswordInformation(
    IN handle_t BindingHandle,
    IN OPTIONAL PRPC_UNICODE_STRING ServerName,
    OUT PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation
    )


/*++

Routine Description:

    Takes a user handle, finds the domain for that user, and returns
    password information for the domain.  This is so the client\wrappers.c
    can get the information to verify the user's password before it is
    OWF'd.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    PasswordInformation - Receives information about password restrictions
        for the user's domain.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    Other errors may be returned from SampLookupContext() if the handle
    is invalid or does not indicate proper access to the domain's password
    inforamtion.

--*/
{
    SAMP_OBJECT_TYPE            FoundType;
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    SAMPR_HANDLE                ServerHandle = NULL;
    SAMPR_HANDLE                DomainHandle = NULL;
    ULONG                       DomainIndex = SAMP_DEFAULT_ACCOUNT_DOMAIN_INDEX;

    SAMTRACE_EX("SamrGetDomainPasswordInformation");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetDomainPasswordInformation
                   );

    //
    // This check is loosened since there can be existing callers which use this
    //  parameter but doesn't meet the check criteria. Actually our client side
    //  has the problem of converting an ANSI string to UNICODE_STRING and passing it in
    //  as ServerName too...
    //

    //
    // Input parameter check
    //
    if( ARGUMENT_PRESENT( ServerName ) ) {
        if( !SampValidateRpcString( ( PRPC_STRING ) ServerName ) ) {
            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }
    }


    //
    // Connect to the server and open the account domain for
    // DOMAIN_READ_PASSWORD_PARAMETERS access. Connect as a
    // trusted client. We really do not wish to enforce access
    // checks on SamrGetDomainPasswordInformation.
    //

    NtStatus = SamrConnect4(
                NULL,
                &ServerHandle,
                SAM_CLIENT_LATEST,
                0  // Ask for No accesses, as this way we will
                   // access check for any access on the Sam server
                   // object
                );

    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // If we opened the Sam Server object. Grant the LOOKUP_DOMAIN
    // access, so that we may have rights to open the domain and
    // provided we have READ access on the domain object can read the
    // properties
    //

    ((PSAMP_OBJECT)ServerHandle)->GrantedAccess = SAM_SERVER_LOOKUP_DOMAIN;

    NtStatus = SamrOpenDomain(
                ServerHandle,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[DomainIndex].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&ServerHandle);
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    SampAcquireReadLock();


    //
    // We want to look at the account domain
    //

    Domain = &SampDefinedDomains[DomainIndex];

    //
    // Copy the password properites into the returned structure.
    //

    PasswordInformation->MinPasswordLength = Domain->UnmodifiedFixed.MinPasswordLength;
    PasswordInformation->PasswordProperties = Domain->UnmodifiedFixed.PasswordProperties;


    SampReleaseReadLock();

    SamrCloseHandle(&DomainHandle);
    SamrCloseHandle(&ServerHandle);

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetDomainPasswordInformation
                   );

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this process                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )

/*++

Routine Description:

    Validate a user's ability to logon at this time and at the workstation
    being logged onto.


Arguments:

    UserHandle - The handle of an opened user to operate on.

    LogonWorkStation - The name of the workstation the logon is being
        attempted at.

    WorkStations - The list of workstations the user may logon to.  This
        information comes from the user's account information.  It must
        be in API list format.

    LogonHours - The times the user may logon.  This information comes
        from the user's account information.

    LogoffTime - Receives the time at which the user should logoff the
        system.

    KickoffTime - Receives the time at which the user should be kicked
        off the system.


Return Value:


    STATUS_SUCCESS - Logon is permitted.

    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.

    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.


--*/
{

#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000

    TIME_FIELDS             CurrentTimeFields;
    LARGE_INTEGER           CurrentTime, CurrentUTCTime;
    LARGE_INTEGER           MillisecondsIntoWeekXUnitsPerWeek;
    LARGE_INTEGER           LargeUnitsIntoWeek;
    LARGE_INTEGER           Delta100Ns;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    NTSTATUS                IgnoreStatus;
    ULONG                   CurrentMsIntoWeek;
    ULONG                   LogoffMsIntoWeek;
    ULONG                   DeltaMs;
    ULONG                   MillisecondsPerUnit;
    ULONG                   CurrentUnitsIntoWeek;
    ULONG                   LogoffUnitsIntoWeek;
    USHORT                  i;
    TIME_ZONE_INFORMATION   TimeZoneInformation;
    DWORD TimeZoneId;
    LARGE_INTEGER           BiasIn100NsUnits = {0, 0};
    LONG                    BiasInMinutes = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 fLockAcquired = FALSE;

    SAMTRACE_EX("SamIAccountRestrictions");


    AccountContext = (PSAMP_OBJECT)UserHandle;


    //
    // Acquire the Read lock if necessary
    //

    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //



    NtStatus = SampLookupContext(
                   AccountContext,
                   0L,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );


    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampRetrieveUserV1aFixed(
                       AccountContext,
                       &V1aFixed
                       );
        if (NT_SUCCESS(NtStatus)) {

            //
            // Only check for users other than the builtin ADMIN
            //

            if (V1aFixed.UserId != DOMAIN_USER_RID_ADMIN) {

                //
                // Check to see if no GC was available during group expansion
                //
                if (AccountContext->TypeBody.User.fNoGcAvailable) {

                    NtStatus = STATUS_NO_LOGON_SERVERS;

                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Scan to make sure the workstation being logged into is in the
                    // list of valid workstations - or if the list of valid workstations
                    // is null, which means that all are valid.
                    //

                    NtStatus = SampMatchworkstation( LogonWorkStation, WorkStations );

                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Check to make sure that the current time is a valid time to logon
                    // in the LogonHours.
                    //
                    // We need to validate the time taking into account whether we are
                    // in daylight savings time or standard time.  Thus, if the logon
                    // hours specify that we are able to logon between 9am and 5pm,
                    // this means 9am to 5pm standard time during the standard time
                    // period, and 9am to 5pm daylight savings time when in the
                    // daylight savings time.  Since the logon hours stored by SAM are
                    // independent of daylight savings time, we need to add in the
                    // difference between standard time and daylight savings time to
                    // the current time before checking whether this time is a valid
                    // time to logon.  Since this difference (or bias as it is called)
                    // is actually held in the form
                    //
                    // Standard time = Daylight savings time + Bias
                    //
                    // the Bias is a negative number.  Thus we actually subtract the
                    // signed Bias from the Current Time.

                    //
                    // First, get the Time Zone Information.
                    //

                    TimeZoneId = GetTimeZoneInformation(
                                     (LPTIME_ZONE_INFORMATION) &TimeZoneInformation
                                     );

                    //
                    // Next, get the appropriate bias (signed integer in minutes) to subtract from
                    // the Universal Time Convention (UTC) time returned by NtQuerySystemTime
                    // to get the local time.  The bias to be used depends whether we're
                    // in Daylight Savings time or Standard Time as indicated by the
                    // TimeZoneId parameter.
                    //
                    // local time  = UTC time - bias in 100Ns units
                    //

                    switch (TimeZoneId) {

                    case TIME_ZONE_ID_UNKNOWN:

                        //
                        // There is no differentiation between standard and
                        // daylight savings time.  Proceed as for Standard Time
                        //

                        BiasInMinutes = TimeZoneInformation.StandardBias;
                        break;

                    case TIME_ZONE_ID_STANDARD:

                        BiasInMinutes = TimeZoneInformation.StandardBias;
                        break;

                    case TIME_ZONE_ID_DAYLIGHT:

                        BiasInMinutes = TimeZoneInformation.DaylightBias;
                        break;

                    default:

                        //
                        // Something is wrong with the time zone information.  Fail
                        // the logon request.
                        //

                        NtStatus = STATUS_INVALID_LOGON_HOURS;
                        break;
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Convert the Bias from minutes to 100ns units
                        //

                        BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes)
                                                    * 60 * 10000000;

                        //
                        // Get the UTC time in 100Ns units used by Windows Nt.  This
                        // time is GMT.
                        //

                        NtStatus = NtQuerySystemTime( &CurrentUTCTime );
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        CurrentTime.QuadPart = CurrentUTCTime.QuadPart -
                                      BiasIn100NsUnits.QuadPart;

                        RtlTimeToTimeFields( &CurrentTime, &CurrentTimeFields );

                        CurrentMsIntoWeek = (((( CurrentTimeFields.Weekday * 24 ) +
                                               CurrentTimeFields.Hour ) * 60 +
                                               CurrentTimeFields.Minute ) * 60 +
                                               CurrentTimeFields.Second ) * 1000 +
                                               CurrentTimeFields.Milliseconds;

                        MillisecondsIntoWeekXUnitsPerWeek.QuadPart =
                            ((LONGLONG)CurrentMsIntoWeek) *
                            ((LONGLONG)LogonHours->UnitsPerWeek);

                        LargeUnitsIntoWeek = RtlExtendedLargeIntegerDivide(
                                                 MillisecondsIntoWeekXUnitsPerWeek,
                                                 MILLISECONDS_PER_WEEK,
                                                 (PULONG)NULL );

                        CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart;

                        if ( !( LogonHours->LogonHours[ CurrentUnitsIntoWeek / 8] &
                            ( 0x01 << ( CurrentUnitsIntoWeek % 8 ) ) ) ) {

                            NtStatus = STATUS_INVALID_LOGON_HOURS;

                        } else {

                            //
                            // Determine the next time that the user is NOT supposed to be logged
                            // in, and return that as LogoffTime.
                            //

                            i = 0;
                            LogoffUnitsIntoWeek = CurrentUnitsIntoWeek;

                            do {

                                i++;

                                LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 ) % LogonHours->UnitsPerWeek;

                            } while ( ( i <= LogonHours->UnitsPerWeek ) &&
                                ( LogonHours->LogonHours[ LogoffUnitsIntoWeek / 8 ] &
                                ( 0x01 << ( LogoffUnitsIntoWeek % 8 ) ) ) );

                            if ( i > LogonHours->UnitsPerWeek ) {

                                //
                                // All times are allowed, so there's no logoff
                                // time.  Return forever for both logofftime and
                                // kickofftime.
                                //

                                LogoffTime->HighPart = 0x7FFFFFFF;
                                LogoffTime->LowPart = 0xFFFFFFFF;

                                KickoffTime->HighPart = 0x7FFFFFFF;
                                KickoffTime->LowPart = 0xFFFFFFFF;

                            } else {

                                //
                                // LogoffUnitsIntoWeek points at which time unit the
                                // user is to log off.  Calculate actual time from
                                // the unit, and return it.
                                //
                                // CurrentTimeFields already holds the current
                                // time for some time during this week; just adjust
                                // to the logoff time during this week and convert
                                // to time format.
                                //

                                MillisecondsPerUnit = MILLISECONDS_PER_WEEK / LogonHours->UnitsPerWeek;

                                LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

                                if ( LogoffMsIntoWeek < CurrentMsIntoWeek ) {

                                    DeltaMs = MILLISECONDS_PER_WEEK - ( CurrentMsIntoWeek - LogoffMsIntoWeek );

                                } else {

                                    DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek;
                                }

                                Delta100Ns = RtlExtendedIntegerMultiply(
                                                 RtlConvertUlongToLargeInteger( DeltaMs ),
                                                 10000
                                                 );

                                LogoffTime->QuadPart = CurrentUTCTime.QuadPart +
                                              Delta100Ns.QuadPart;

                                //
                                // If the account expires sooner than the logoff time,
                                // set the logoff time to account expiry time
                                //

                                if ((LogoffTime->QuadPart > V1aFixed.AccountExpires.QuadPart)
                                    && (V1aFixed.AccountExpires.QuadPart !=0))
                                {
                                    LogoffTime->QuadPart = V1aFixed.AccountExpires.QuadPart;
                                }

                                //
                                // Subtract Domain->ForceLogoff from LogoffTime, and return
                                // that as KickoffTime.  Note that Domain->ForceLogoff is a
                                // negative delta.  If its magnitude is sufficiently large
                                // (in fact, larger than the difference between LogoffTime
                                // and the largest positive large integer), we'll get overflow
                                // resulting in a KickOffTime that is negative.  In this
                                // case, reset the KickOffTime to this largest positive
                                // large integer (i.e. "never") value.
                                //

                                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                                KickoffTime->QuadPart = LogoffTime->QuadPart -
                                               Domain->UnmodifiedFixed.ForceLogoff.QuadPart;

                                if (KickoffTime->QuadPart < 0) {

                                    KickoffTime->HighPart = 0x7FFFFFFF;
                                    KickoffTime->LowPart = 0xFFFFFFFF;
                                }
                            }
                        }
                    }
                }

            } else {

                //
                // Never kick administrators off
                //

                LogoffTime->HighPart  = 0x7FFFFFFF;
                LogoffTime->LowPart   = 0xFFFFFFFF;
                KickoffTime->HighPart = 0x7FFFFFFF;
                KickoffTime->LowPart  = 0xFFFFFFFF;
            }

        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // If the read lock was acquired release it.
    //


    SampMaybeReleaseReadLock(fLockAcquired);


    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampReplaceUserV1aFixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    )

/*++

Routine Description:

    This service replaces the current V1 fixed length information related to
    a specified User.

    The change is made to the in-memory object data only.


Arguments:

    Context - Points to the account context whose V1_FIXED information is
        to be replaced.

    V1aFixed - Is a buffer containing the new V1_FIXED information.



Return Value:


    STATUS_SUCCESS - The information has been replaced.

    Other status values that may be returned are those returned
    by:

            SampSetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    SAMP_V1_0A_FIXED_LENGTH_USER LocalV1aFixed;

    SAMTRACE("SampReplaceUserV1aFixed");

    //
    // Minimize the passed in structure to not include computed user
    // account control flags
    //

    RtlCopyMemory(&LocalV1aFixed,V1aFixed,sizeof(SAMP_V1_0A_FIXED_LENGTH_USER));

    LocalV1aFixed.UserAccountControl &= ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);

    NtStatus = SampSetFixedAttributes(
                   Context,
                   (PVOID)&LocalV1aFixed
                   );

    return( NtStatus );
}



LARGE_INTEGER
SampGetPasswordMustChange(
    IN ULONG UserAccountControl,
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns the correct value to set the PasswordMustChange time
    to depending on the time the password was last set, whether the password
    expires on the account, and the maximum password age on the domain.

Arguments:

    UserAccountControl - The UserAccountControl for the user.  The
        USER_DONT_EXPIRE_PASSWORD bit is set if the password doesn't expire
        for this user.

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.


Return Value:

    Returns the time when the password for this user must change.

--*/
{
    LARGE_INTEGER PasswordMustChange;

    SAMTRACE("SampGetPasswordMustChange");

    //
    // Here is the rules:
    // 1. password never expires for this user (flags explicitly)
    // 2. password does not expire for smartcard
    // 3. password don't expire for machine. reliability issues,
    //    otherwise machines are programmed to change pwd periodically
    //
    //  return an infinitely large time.
    //


    if (( UserAccountControl & USER_DONT_EXPIRE_PASSWORD ) ||
       ( UserAccountControl & USER_SMARTCARD_REQUIRED) ||
       ( UserAccountControl & USER_MACHINE_ACCOUNT_MASK ) )
    {

        PasswordMustChange = SampWillNeverTime;

    //
    // If the password for this account is flagged to expire immediately,
    // return a zero time time.
    //
    // Don't return the current time here.  The callers clock might be a
    // little off from ours.
    //

    } else if ( PasswordLastSet.QuadPart == SampHasNeverTime.QuadPart ) {

        PasswordMustChange = SampHasNeverTime;

    //
    // If the no password aging according to domain password policy,
    // return an infinitely large time, so that password won't expire
    //

    } else if (MaxPasswordAge.QuadPart == SampHasNeverTime.QuadPart) {

        PasswordMustChange = SampWillNeverTime;

    //
    // Otherwise compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    } else {

        PasswordMustChange = SampAddDeltaTime(
                                  PasswordLastSet,
                                  MaxPasswordAge);
    }

    return PasswordMustChange;
}



NTSTATUS
SampComputePasswordExpired(
    IN BOOLEAN PasswordExpired,
    OUT PLARGE_INTEGER PasswordLastSet
    )

/*++

Routine Description:

    This routine returns the correct value to set the PasswordLastSet time
    to depending on whether the caller has requested the password to expire.
    It does this by setting the PasswordLastSet time to be now (if it's
    not expired) or to SampHasNeverTime (if it is expired).

Arguments:

    PasswordExpired - TRUE if the password should be marked as expired.



Return Value:

    STATUS_SUCCESS - the PasswordLastSet time has been set to indicate
        whether or not the password is expired.

    Errors as returned by NtQuerySystemTime.

--*/
{
    NTSTATUS                  NtStatus;

    SAMTRACE("SampComputePasswordExpired");

    //
    // If immediate expiry is required - set this timestamp to the
    // beginning of time. This will work if the domain enforces a
    // maximum password age. We may have to add a separate flag to
    // the database later if immediate expiry is required on a domain
    // that doesn't enforce a maximum password age.
    //

    if (PasswordExpired) {

        //
        // Set password last changed at dawn of time
        //

        *PasswordLastSet = SampHasNeverTime;
        NtStatus = STATUS_SUCCESS;

    } else {

        //
        // Set password last changed 'now'
        //

        NtStatus = NtQuerySystemTime( PasswordLastSet );
    }

    return( NtStatus );
}



NTSTATUS
SampStorePasswordExpired(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN PasswordExpired
    )

/*++

Routine Description:

    This routine marks the current password as expired, or not expired.
    It does this by setting the PasswordLastSet time to be now (if it's
    not expired) or to SampHasNeverTime (if it is expired).

Arguments:

    Context - Points to the user account context.

    PasswordExpired - TRUE if the password should be marked as expired.

Return Value:

    STATUS_SUCCESS - the PasswordLastSet time has been set to indicate
        whether or not the password is expired.

    Errors as returned by Samp{Retrieve|Replace}V1Fixed()

--*/
{
    NTSTATUS                  NtStatus;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    SAMTRACE("SampStorePasswordExpired");

    //
    // Get the V1aFixed info for the user
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   Context,
                   &V1aFixed
                   );

    //
    // Update the password-last-changed timestamp for the account
    //

    if (NT_SUCCESS(NtStatus ) ) {

        NtStatus = SampComputePasswordExpired(
                        PasswordExpired,
                        &V1aFixed.PasswordLastSet );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampReplaceUserV1aFixed(
                       Context,
                       &V1aFixed
                       );
        }
    }

    return( NtStatus );
}

VOID
SampPasswordChangeCPTrace(
    SAMP_STORE_PASSWORD_CALLER_TYPE CallerType,
    ULONG  UserAccountControl,
    ULONG  EventType
    )
{

    switch (CallerType) {

    case PasswordChange:

        if (UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EventType,
                           SampGuidChangePasswordComputer
                           );
        }
        else
        {
            SampTraceEvent(EventType,
                           SampGuidChangePasswordUser
                           );
        }
        break;

    case PasswordSet:

        if (UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EventType,
                           SampGuidSetPasswordComputer
                           );

        }
        else
        {
            SampTraceEvent(EventType,
                           SampGuidSetPasswordUser
                           );
        }

        break;

    case PasswordPushPdc:

        SampTraceEvent(EventType,
                       SampGuidPasswordPushPdc
                       );
        break;

    default:

        ASSERT(FALSE && "Invalid caller type");

    }
}



NTSTATUS
SampStoreUserPasswords(
    IN PSAMP_OBJECT Context,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN NtPasswordPresent,
    IN BOOLEAN CheckRestrictions,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType,
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo OPTIONAL,
    IN PUNICODE_STRING ClearPassword OPTIONAL,
    IN PULONG ChangedUserAccountControl,
    OUT PUNICODE_STRING PasswordToNotify OPTIONAL,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    )

/*++

Routine Description:

    This service updates the password for the specified user.

    This involves encrypting the one-way-functions of both LM and NT
    passwords with a suitable index and writing them into the registry.

    This service checks the new password for legality including history
    and UAS compatibilty checks - returns STATUS_PASSWORD_RESTRICTION if
    any of these checks fail.

    The password-last-changed time is updated.

        THE CHANGE WILL BE ADDED TO THE CURRENT RXACT TRANSACTION.


Arguments:

    Context - Points to the user account context.

    LmOwfPassword - The one-way-function of the LM password.

    LmPasswordPresent - TRUE if the LmOwfPassword contains valid information.

    NtOwfPassword - The one-way-function of the NT password.

    NtPasswordPresent - TRUE if the NtOwfPassword contains valid information.

    CallerType - Indicate why this API is been called.
                 Valid values are:
                    PasswordChange
                    PasswordSet
                    PasswordPushPdc

    Domain Password Information: This is the password policy to enforce

    Clear Password : This is the clear text password

    ChangedUserAccountControl - optional parameter, passed in to indicate if the
                     user account control field is changing at the same time

    PasswordToNotify Clear password value to be used for notitification packages
                     Note this is could be different from the passed in password

    PasswordChangeFailureInfo -- Info regarding the actual password change failure

Return Value:


    STATUS_SUCCESS - The passwords have been updated.

    STATUS_PASSWORD_RESTRICTION - The new password is not valid for
                                  for this account at this time.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ObjectRid = Context->TypeBody.User.Rid;
    CRYPT_INDEX             CryptIndex;
    UNICODE_STRING          StringBuffer;
    UNICODE_STRING          NtOwfHistoryBuffer;
    UNICODE_STRING          LmOwfHistoryBuffer;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 NtPasswordNull = FALSE, LmPasswordNull = FALSE;
    UNICODE_STRING          StoredBuffer;
    UNICODE_STRING          UpdatedClearPassword;
    USHORT                  PasswordHistoryLength=0;
    USHORT                  MinPasswordLength=0;
    BOOLEAN                 CheckHistory = TRUE,
                            SkipFurtherRestrictions = FALSE,
                            MachineOrTrustAccount = FALSE,
                            NoPasswordRequiredForAccount = FALSE;

    SAMTRACE("SampStoreUserPasswords");


    RtlSecureZeroMemory(&UpdatedClearPassword,sizeof(UNICODE_STRING));


    //
    // Get the V1aFixed info for the user
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   Context,
                   &V1aFixed
                   );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // do a start type WMI event trace
    // use CallerType to distinguish different events
    //

    SampPasswordChangeCPTrace(
        CallerType,
        V1aFixed.UserAccountControl,
        EVENT_TRACE_TYPE_START
        );



    //
    // Initialize some booleans for handling special cases
    //

    // The caller might be simultaneously setting
    // the password and changing the account to be
    // a machine or trust account.  In this case,
    // we don't validate the password (e.g., length).
    //
    // Same logic also applies if PASSWORD_NOT_REQUIRED is set,
    // or is being set
    //

    if (ARGUMENT_PRESENT(ChangedUserAccountControl))
    {
          MachineOrTrustAccount =
              ((*ChangedUserAccountControl) & USER_MACHINE_ACCOUNT_MASK)!=0;
          NoPasswordRequiredForAccount =
              ((*ChangedUserAccountControl) & USER_PASSWORD_NOT_REQUIRED)!=0;
    }
    else
    {
         MachineOrTrustAccount= (V1aFixed.UserAccountControl
                                        & USER_MACHINE_ACCOUNT_MASK)!=0;
         NoPasswordRequiredForAccount = (V1aFixed.UserAccountControl
                                        & USER_PASSWORD_NOT_REQUIRED)!=0;
    }

    //
    // Get the domain policies to enforce
    //

    if (ARGUMENT_PRESENT(DomainPasswordInfo))
    {
        PasswordHistoryLength = DomainPasswordInfo->PasswordHistoryLength;
        MinPasswordLength = DomainPasswordInfo->MinPasswordLength;
    }

    //
    // Untrusted callers cannot set passwords on interdomain trust accounts
    //

    if ((0!=(V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)) &&
       (!Context->TrustedClient))
    {
       NtStatus = STATUS_ACCESS_DENIED;
       goto Cleanup;
    }

    //
    // If the registry key for No LM passwords is set then change
    // the LmPasswordPresent bit to False. This ensures that  the
    // LM password is not saved. Do so if NtPassword is present
    //

    if ((NtPasswordPresent) && (SampNoLmHash)) {
         LmPasswordPresent = FALSE;
    }

    //
    // If the No LM password setting is enabled and the NtPassword
    // is not present then fail the call with STATUS_PASSWORD_RESTRICTION
    //

    if ((!NtPasswordPresent) && (SampNoLmHash)) {
         NtStatus  = STATUS_PASSWORD_RESTRICTION;
         goto Cleanup;
    }

    //
    // For krbtgt accounts
    // 1. don't allow a password change
    // 2. don't allow a password set with OWF passwords
    // 3. Randomize the krbtgt password
    //
    // SampRandomizeKrbtgtPassword enforces all 3 checks -- in a sense it
    // is aptly named :)
    //

    NtStatus = SampRestrictAndRandomizeKrbtgtPassword(
                    Context,
                    ClearPassword,
                    NtOwfPassword,
                    LmOwfPassword,
                    &LmPasswordPresent,
                    &UpdatedClearPassword,
                    CallerType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Check for a LM Owf of a NULL password.
    //

    if (LmPasswordPresent) {
        LmPasswordNull = RtlEqualNtOwfPassword(LmOwfPassword, &SampNullLmOwfPassword);
    }

    //
    // Check for a NT Owf of a NULL password
    //

    if (NtPasswordPresent) {
        NtPasswordNull = RtlEqualNtOwfPassword(NtOwfPassword, &SampNullNtOwfPassword);
    }


    //
    // Check password against restrictions if this isn't a trusted client
    //

    if (CheckRestrictions && !Context->TrustedClient ) {

        //
        // Enforce Domain Password No Clear Change
        //

        if ((DomainPasswordInfo->PasswordProperties & DOMAIN_PASSWORD_NO_CLEAR_CHANGE) &&
             (PasswordChange==CallerType) &&
             (ARGUMENT_PRESENT(ClearPassword)))

        {
            NtStatus = STATUS_PASSWORD_RESTRICTION;
            goto Cleanup;
        }

        //
        // Check if the password is a blank password
        //   1. If a password length policy is in effect then do not permit blank passwords
        //   2. If the per user override USER_PASSWORD_NOT_REQUIRED is set then skip
        //      further restrictions if this is a password reset operation.
        //

        if ( ((!LmPasswordPresent) || LmPasswordNull) &&
            ((!NtPasswordPresent) || NtPasswordNull) ) {

            //
            // In general don't allow empty passwords if MinPasswordLength > 0
            //

            if (MinPasswordLength > 0) {

                NtStatus = STATUS_PASSWORD_RESTRICTION;

                //
                // However if (an admin ) is resetting the password and password
                // not required flag is set, then allow the operation, and skip
                // further restrictions to be checked.
                //

                if ((PasswordSet==CallerType ) && (NoPasswordRequiredForAccount)){
                    NtStatus = STATUS_SUCCESS;
                    SkipFurtherRestrictions = TRUE;
                }
                else {
                    goto Cleanup;
                }
            }
        }

        //
        // Enforce password policy if clear password is provided
        //

        if ((!SkipFurtherRestrictions ) && (ARGUMENT_PRESENT(ClearPassword))) {


            //
            // Enforce Lenght, age and complexity policies
            // SampCheckPasswordRestrictions knows to appropriately
            // special case Machine and Krbtgt accounts.
            //

            NtStatus = SampCheckPasswordRestrictions(
                            Context,
                            DomainPasswordInfo,
                            &UpdatedClearPassword,
                            MachineOrTrustAccount,
                            PasswordChangeFailureInfo
                            );

            if (!NT_SUCCESS(NtStatus)) {
                goto Cleanup;
            }

            //
            // For user accounts ( ie not machine and trust accounts )
            // invoke the password filter routine to get password filtering
            // through any admin specified filters.
            //

            if (!MachineOrTrustAccount ) {

                NtStatus = SampPasswordChangeFilter(
                                Context,
                                &UpdatedClearPassword,
                                PasswordChangeFailureInfo,
                                CallerType==PasswordSet?TRUE:FALSE //set/change
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    goto Cleanup;
                }

            }
        }
    }

    //
    // Reencrypt both OWFs with the key for this user
    // so they can be stored on disk
    //
    // Note we encrypt the NULL OWF if we do not have a
    // a particular OWF. This is so we always have something
    // to add to the password history.
    //

    //
    // We'll use the account rid as the encryption index
    //

    ASSERT(sizeof(ObjectRid) == sizeof(CryptIndex));
    CryptIndex = ObjectRid;

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlEncryptLmOwfPwdWithIndex(
                       LmPasswordPresent ? LmOwfPassword :
                                           &SampNullLmOwfPassword,
                       &CryptIndex,
                       &EncryptedLmOwfPassword
                       );
    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlEncryptNtOwfPwdWithIndex(
                       NtPasswordPresent ? NtOwfPassword :
                                           &SampNullNtOwfPassword,
                       &CryptIndex,
                       &EncryptedNtOwfPassword
                       );
    }

    //
    // Check password against password history if and only if
    //
    //  1. Client is not trusted
    //  2. Object is not a machine account or trust account
    //  3. Operation is a password change ( by an user )
    //  4. SkipFurtherRestrictions is not set
    //
    // Note we don't check NULL passwords against history
    //

    if ((!Context->TrustedClient) &&
       (!MachineOrTrustAccount ) &&
       (PasswordChange==CallerType ) &&
       (!SkipFurtherRestrictions )) {

        CheckHistory = TRUE;
    } else {

        CheckHistory = FALSE;
    }


    NtOwfHistoryBuffer.Buffer = NULL;
    NtOwfHistoryBuffer.MaximumLength = NtOwfHistoryBuffer.Length = 0;

    LmOwfHistoryBuffer.Buffer = NULL;
    LmOwfHistoryBuffer.MaximumLength = LmOwfHistoryBuffer.Length = 0;


    if (NT_SUCCESS(NtStatus) ) {

        //
        // Always go get the existing password history.
        // We'll use these history buffers when we save the new history
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_USER_LM_PWD_HISTORY,
                       FALSE, // Don't make copy
                       &StringBuffer
                       );

        //
        // Decrypt the data if necessary
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDecryptSecretData(
                            &LmOwfHistoryBuffer,
                            LmPasswordHistory,
                            &StringBuffer,
                            ObjectRid
                            );

        }

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_NT_PWD_HISTORY,
                           FALSE, // Don't make copy
                           &StringBuffer
                           );

            //
            // Decrypt the data if necessary
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampDecryptSecretData(
                                &NtOwfHistoryBuffer,
                                NtPasswordHistory,
                                &StringBuffer,
                                ObjectRid
                                );

            }

            if (NT_SUCCESS(NtStatus) && LmPasswordPresent && !LmPasswordNull) {

                NtStatus = SampCheckPasswordHistory(
                               &EncryptedLmOwfPassword,
                               ENCRYPTED_LM_OWF_PASSWORD_LENGTH,
                               PasswordHistoryLength,
                               SAMP_USER_LM_PWD_HISTORY,
                               Context,
                               CheckHistory,
                               &LmOwfHistoryBuffer
                               );
            }

            if (NT_SUCCESS(NtStatus) && NtPasswordPresent && !NtPasswordNull) {

                NtStatus = SampCheckPasswordHistory(
                                &EncryptedNtOwfPassword,
                                ENCRYPTED_NT_OWF_PASSWORD_LENGTH,
                                PasswordHistoryLength,
                                SAMP_USER_NT_PWD_HISTORY,
                                Context,
                                CheckHistory,
                                &NtOwfHistoryBuffer
                                );
            }

            //
            // Update the failure code in extended error information
            // if we failed the history check
            //

            if ((STATUS_PASSWORD_RESTRICTION == NtStatus)
                && (ARGUMENT_PRESENT(PasswordChangeFailureInfo)))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason
                            = SAM_PWD_CHANGE_PWD_IN_HISTORY;
            }


        }

    }

    if (NT_SUCCESS(NtStatus ) ) {

        //
        // Write the encrypted LM OWF password into the database
        //

        if (!LmPasswordPresent || LmPasswordNull) {
            StringBuffer.Buffer = NULL;
            StringBuffer.Length = 0;
        } else {
            StringBuffer.Buffer = (PWCHAR)&EncryptedLmOwfPassword;
            StringBuffer.Length = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        }
        StringBuffer.MaximumLength = StringBuffer.Length;


        //
        // Write the encrypted LM OWF password into the registry
        //

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        LmPassword,
                        &StringBuffer,
                        ObjectRid
                        );

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                            Context,
                            SAMP_USER_DBCS_PWD,
                            &StoredBuffer
                            );
            SampFreeUnicodeString(&StoredBuffer);
        }

    }




    if (NT_SUCCESS(NtStatus ) ) {
        //
        // Write the encrypted NT OWF password into the database
        //

        if (!NtPasswordPresent) {
            StringBuffer.Buffer = NULL;
            StringBuffer.Length = 0;
        } else {
            StringBuffer.Buffer = (PWCHAR)&EncryptedNtOwfPassword;
            StringBuffer.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        }
        StringBuffer.MaximumLength = StringBuffer.Length;


        //
        // Write the encrypted NT OWF password into the registry
        //

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        NtPassword,
                        &StringBuffer,
                        ObjectRid
                        );

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_UNICODE_PWD,
                           &StoredBuffer
                           );
            SampFreeUnicodeString(&StoredBuffer);
        }

    }

    //
    // Update the password history for this account.
    //
    // If both passwords are NULL then don't bother adding
    // them to the history. Note that if either is non-NULL
    // we add both. This is to avoid the weird case where a user
    // changes password many times from a LM machine, then tries
    // to change password from an NT machine and is told they
    // cannot use the password they last set from NT (possibly
    // many years ago.)
    //
    // Also, don't bother with the password history if the client is
    // trusted.  Trusted clients will set the history via SetPrivateData().
    // Besides, we didn't get the old history buffer in the trusted
    // client case above.
    //


    if ( NT_SUCCESS(NtStatus) )  {

        USHORT PasswordHistoryLengthToUse=PasswordHistoryLength;

        //
        // We always want to store the password history for the krbtgt
        // account
        //

        if ((ObjectRid == DOMAIN_USER_RID_KRBTGT) &&
            (PasswordHistoryLength < SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH))
        {
            PasswordHistoryLengthToUse = SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH;
        }
        if ((LmPasswordPresent && !LmPasswordNull) ||
            (NtPasswordPresent && !NtPasswordNull)) {

            NtStatus = SampAddPasswordHistory(
                               Context,
                               SAMP_USER_LM_PWD_HISTORY,
                               &LmOwfHistoryBuffer,
                               &EncryptedLmOwfPassword,
                               ENCRYPTED_LM_OWF_PASSWORD_LENGTH,
                               PasswordHistoryLengthToUse
                               );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampAddPasswordHistory(
                               Context,
                               SAMP_USER_NT_PWD_HISTORY,
                               &NtOwfHistoryBuffer,
                               &EncryptedNtOwfPassword,
                               ENCRYPTED_NT_OWF_PASSWORD_LENGTH,
                               PasswordHistoryLengthToUse
                               );
            }
        }
    }

    //
    // Update supplemental credentials field and any other derived supplemental
    // credentials such as kerberos credential types
    //

    if ((NT_SUCCESS(NtStatus)) && (PasswordPushPdc!=CallerType))
    {
        //
        // Here we attach the clear text password (reversibly encoded) on the
        // context so that when the object is written to the DS, the
        // password is passed down as the USER_PASSWORD attribute.  The core
        // DS will call back into SAM after all attributes are written
        // on the object so that SAM can correctly calculate the
        // supplemental credentials.
        //
        NtStatus = SampSetPasswordUpdateOnContext(
                        DomainPasswordInfo,
                        Context,
                        ARGUMENT_PRESENT(ClearPassword)?
                                &UpdatedClearPassword:NULL
                        );
    }

    //
    // If the password was successfully stored, quickly replicate the change
    // if configured to do so.
    //
    if ((SampReplicatePasswordsUrgently || (CallerType == PasswordSet))
      && !(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
      && NT_SUCCESS(NtStatus)) {

       Context->ReplicateUrgently = TRUE;
    }

    //
    // Clean up our history buffers
    //

    if (NtOwfHistoryBuffer.Buffer != NULL ) {
        MIDL_user_free(NtOwfHistoryBuffer.Buffer );
    }
    if (LmOwfHistoryBuffer.Buffer != NULL ) {
        MIDL_user_free(LmOwfHistoryBuffer.Buffer );
    }

Cleanup:

    if ((NT_SUCCESS(NtStatus)) && (ARGUMENT_PRESENT(PasswordToNotify)))
    {
        *PasswordToNotify = UpdatedClearPassword;
    }
    else if (UpdatedClearPassword.Buffer!=NULL)
    {
        RtlSecureZeroMemory(
            UpdatedClearPassword.Buffer,
            UpdatedClearPassword.Length
            );

        MIDL_user_free(UpdatedClearPassword.Buffer);
    }


    SampPasswordChangeCPTrace(
        CallerType,
        V1aFixed.UserAccountControl,
        EVENT_TRACE_TYPE_END
        );

    return(NtStatus );
}



NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    )

/*++

Routine Description:

    This service retrieves the stored OWF passwords for a user.


Arguments:

    Context - Points to the user account context.

    LmOwfPassword - The one-way-function of the LM password is returned here.

    LmPasswordNonNull - TRUE if the LmOwfPassword is not the well-known
                        OWF of a NULL password

    NtOwfPassword - The one-way-function of the NT password is returned here.

    NtPasswordPresent - TRUE if the NtOwfPassword contains valid information.


Return Value:


    STATUS_SUCCESS - The passwords were retrieved successfully.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus;
    ULONG                   ObjectRid = Context->TypeBody.User.Rid;
    UNICODE_STRING          StringBuffer;
    UNICODE_STRING          StoredBuffer;
    CRYPT_INDEX             CryptIndex;

    SAMTRACE("SampRetrieveUserPasswords");

    //
    // The OWF passwords are encrypted with the account index in the registry
    // Setup the key we'll use for decryption.
    //

    ASSERT(sizeof(ObjectRid) == sizeof(CryptIndex));
    CryptIndex = ObjectRid;


    //
    // Read the encrypted LM OWF password from the database
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_DBCS_PWD,
                   FALSE, // Don't make copy
                   &StoredBuffer
                   );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // If the data was encrypted, decrypt it now. Otherwise just duplicate
    // it so we have an alloated copy.
    //

    NtStatus = SampDecryptSecretData(
                &StringBuffer,
                LmPassword,
                &StoredBuffer,
                ObjectRid
                );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // Check it is in the expected form
    //

    ASSERT( (StringBuffer.Length == 0) ||
            (StringBuffer.Length == ENCRYPTED_LM_OWF_PASSWORD_LENGTH));

    //
    // Determine if there is an LM password.
    //

    *LmPasswordNonNull = (BOOLEAN)(StringBuffer.Length != 0);

    //
    // Decrypt the encrypted LM Owf Password
    //

    if (*LmPasswordNonNull) {

        SampDiagPrint(LOGON,("[SAMSS] Decrypting Lm Owf Password\n"));

        NtStatus = RtlDecryptLmOwfPwdWithIndex(
                       (PENCRYPTED_LM_OWF_PASSWORD)StringBuffer.Buffer,
                       &CryptIndex,
                       LmOwfPassword
                       );
    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        SampDiagPrint(LOGON,("[SAMSS] Null LM OWF Password\n"));
        *LmOwfPassword = SampNullLmOwfPassword;
    }


    //
    // Free up the returned string buffer
    //

    SampFreeUnicodeString(&StringBuffer);


    //
    // Check if the decryption failed
    //

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }




    //
    // Read the encrypted NT OWF password from the database
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_UNICODE_PWD,
                   FALSE, // Don't make copy
                   &StoredBuffer
                   );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }


    //
    // If the data was encrypted, decrypt it now. Otherwise just duplicate
    // it so we have an alloated copy.
    //

    NtStatus = SampDecryptSecretData(
                    &StringBuffer,
                    NtPassword,
                    &StoredBuffer,
                    ObjectRid
                    );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // Check it is in the expected form
    //

    ASSERT( (StringBuffer.Length == 0) ||
            (StringBuffer.Length == ENCRYPTED_NT_OWF_PASSWORD_LENGTH));

    //
    // Determine if there is an Nt password.
    //

    *NtPasswordPresent = (BOOLEAN)(StringBuffer.Length != 0);

    //
    // Decrypt the encrypted NT Owf Password
    //

    if (*NtPasswordPresent) {

        SampDiagPrint(LOGON,("[SAMSS] Decrypting Nt Owf Password\n"));

        NtStatus = RtlDecryptNtOwfPwdWithIndex(
                       (PENCRYPTED_NT_OWF_PASSWORD)StringBuffer.Buffer,
                       &CryptIndex,
                       NtOwfPassword
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            *NtPasswordNonNull = (BOOLEAN)!RtlEqualNtOwfPassword(
                                     NtOwfPassword,
                                     &SampNullNtOwfPassword
                                     );
        }

    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        SampDiagPrint(LOGON,("[SAMSS] NULL NT Owf Password\n"));

        *NtOwfPassword = SampNullNtOwfPassword;
        *NtPasswordNonNull = FALSE;
    }

    //
    // Free up the returned string buffer
    //

    SampFreeUnicodeString(&StringBuffer);


    return( NtStatus );
}



NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of groups a user is a member of.
    If desired, it will also retrieve an array of RIDs and attributes
    of the groups the user is a member of.


Arguments:

    UserContext - User context block

    MakeCopy - If FALSE, the Membership pointer returned refers to the
        in-memory data for the user. This is only valid as long
        as the user context is valid.
        If TRUE, memory is allocated and the membership list copied
         into it. This buffer should be freed using MIDL_user_free.

    MembershipCount - Receives the number of groups the user is a member of.

    Membership - (Otional) Receives a pointer to a buffer containing an array
        of group Relative IDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

        If MakeCopy = TRUE, the membership buffer returned has extra space
        allocated at the end of it for one more membership entry.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        information to be returned in.

    Other status values that may be returned are those returned
    by:

            SampGetLargeIntArrayAttribute()



--*/
{

    NTSTATUS           NtStatus;
    PGROUP_MEMBERSHIP  MemberArray;
    ULONG              MemberCount;

    SAMTRACE("SampRetrieveUserMembership");


    if (IsDsObject(UserContext))
    {

        //
        // DS Case
        //
         SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

        //
        // We should always ask for copy, as this path will only be called
        // in from SamrGetGroupsForUser.
        //

        ASSERT(MakeCopy == TRUE);

        //
        // Get the V1aFixed info for the user in order to retrieve the primary
        // group Id property of the user
        //

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &V1aFixed
                       );

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Retrieve the membership from the DS
            //

            NtStatus = SampDsGetGroupMembershipOfAccount(
                        DomainObjectFromAccountContext(UserContext),
                        UserContext->ObjectNameInDs,
                        MembershipCount,
                        Membership
                        );
        }


    }
    else
    {

        NtStatus = SampGetLargeIntArrayAttribute(
                            UserContext,
                            SAMP_USER_GROUPS,
                            FALSE, //Reference data directly.
                            (PLARGE_INTEGER *)&MemberArray,
                            &MemberCount
                            );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fill in return info
            //

            *MembershipCount = MemberCount;

            if (Membership != NULL) {

                if (MakeCopy) {

                    //
                    // Allocate a buffer large enough to hold the existing
                    // membership data and one more and copy data into it.
                    //

                    ULONG BytesNow = (*MembershipCount) * sizeof(GROUP_MEMBERSHIP);
                    ULONG BytesRequired = BytesNow + sizeof(GROUP_MEMBERSHIP);

                    *Membership = MIDL_user_allocate(BytesRequired);

                    if (*Membership == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {
                        RtlCopyMemory(*Membership, MemberArray, BytesNow);
                    }

                } else {

                    //
                    // Reference the data directly
                    //

                    *Membership = (PGROUP_MEMBERSHIP)MemberArray;
                }
            }
        }
    }


    return( NtStatus );

}



NTSTATUS
SampReplaceUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN ULONG MembershipCount,
    IN PGROUP_MEMBERSHIP Membership
    )

/*++
Routine Description:

    This service sets the groups a user is a member of.

    The information is updated in the in-memory copy of the user's data only.
    The data is not written out by this routine.


Arguments:

    UserContext - User context block

    MembershipCount - The number of groups the user is a member of.

    Membership - A pointer to a buffer containing an array of group
        membership structures. May be NULL if membership count is zero.

Return Value:


    STATUS_SUCCESS - The information has been set.

    Other status values that may be returned are those returned
    by:

            SampSetUlongArrayAttribute()



--*/
{

    NTSTATUS    NtStatus;

    SAMTRACE("SampReplaceUserMembership");

    NtStatus = SampSetLargeIntArrayAttribute(
                        UserContext,
                        SAMP_USER_GROUPS,
                        (PLARGE_INTEGER)Membership,
                        MembershipCount
                        );

    return( NtStatus );
}



NTSTATUS
SampRetrieveUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    )

/*++
Routine Description:

    This service retrieves a user's logon hours from the registry.


Arguments:

    Context - Points to the user account context whose logon hours are
        to be retrieved.

    LogonHours - Receives the logon hours information.  If necessary, a buffer
        containing the logon time restriction bitmap will be allocated using
        MIDL_user_allocate().

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        information to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{

    NTSTATUS    NtStatus;

    SAMTRACE("SampRetrieveUserLogonHours");

    NtStatus = SampGetLogonHoursAttribute(
                   Context,
                   SAMP_USER_LOGON_HOURS,
                   TRUE, // Make copy
                   LogonHours
                   );

    if (NT_SUCCESS(NtStatus)) {

        //////////////////////////////// TEMPORARY MIDL WORKAROUND ///////////
                                                                   ///////////
        if (LogonHours->LogonHours == NULL) {                      ///////////
                                                                   ///////////
            LogonHours->UnitsPerWeek = SAM_HOURS_PER_WEEK;         ///////////
            LogonHours->LogonHours = MIDL_user_allocate( 21 );     ///////////
            if (NULL!=LogonHours->LogonHours)                      ///////////
            {                                                      ///////////
                ULONG ijk;                                         ///////////
                for ( ijk=0; ijk<21; ijk++ ) {                     ///////////
                    LogonHours->LogonHours[ijk] = 0xff;            ///////////
                }                                                  ///////////
            }                                                      ///////////
            else                                                   ///////////
            {                                                      ///////////
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;          ///////////
            }                                                      ///////////
        }                                                          ///////////
                                                                   ///////////
        //////////////////////////////// TEMPORARY MIDL WORKAROUND ///////////
    }

    return( NtStatus );

}




NTSTATUS
SampReplaceUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    )

/*++
Routine Description:

    This service replaces  a user's logon hours in the registry.

    THIS IS DONE BY ADDING AN ACTION TO THE CURRENT RXACT TRANSACTION.


Arguments:

    Context - Points to the user account context whose logon hours are
        to be replaced.

    LogonHours - Provides the new logon hours.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned are those returned
    by:

            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus;

    SAMTRACE("SampReplaceUserLogonHours");

    if ( LogonHours->UnitsPerWeek > SAM_MINUTES_PER_WEEK ) {
        return(STATUS_INVALID_PARAMETER);
    }


    NtStatus = SampSetLogonHoursAttribute(
                   Context,
                   SAMP_USER_LOGON_HOURS,
                   LogonHours
                   );

    return( NtStatus );


}




NTSTATUS
SampAssignPrimaryGroup(
    IN PSAMP_OBJECT Context,
    IN ULONG GroupRid
    )


/*++
Routine Description:

    This service ensures a user is a member of the specified group.


Arguments:

    Context - Points to the user account context whose primary group is
        being changed.

    GroupRid - The RID of the group being assigned as primary group.
        The user must be a member of this group.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to perform
        the operation.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not a member of the specified
        group.

    Other status values that may be returned are those returned
    by:

            SampRetrieveUserMembership()



--*/
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    ULONG                       MembershipCount, i;
    PGROUP_MEMBERSHIP           Membership = NULL;
    BOOLEAN                     Member = FALSE;

    SAMTRACE("SampAssignPrimaryGroup");


    //
    // Don't allow primary group id changes in Extended Sid mode. Note
    // that for compatitiblity reasons, it is allowed to "set" the primary
    // group id if it is equal to the existing value.
    //
    if (SampIsContextFromExtendedSidDomain(Context)) {

        SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;

        NtStatus = SampRetrieveUserV1aFixed(
                       Context,
                       &V1aFixed
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (V1aFixed.PrimaryGroupId != GroupRid) {
                NtStatus = STATUS_NOT_SUPPORTED;
            }
        }
    }

    if ( NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveUserMembership(
                       Context,
                       TRUE, // Make copy
                       &MembershipCount,
                       &Membership
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for ( i=0; i<MembershipCount; i++) {
                if (GroupRid == Membership[i].RelativeId) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            MIDL_user_free(Membership);
        }
    }

    return( NtStatus );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Provided for use by other SAM modules                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampSafeBoot(
    VOID
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HKEY Key ;
    int err ;
    BOOLEAN     fIsSafeBoot = FALSE;
    DWORD       dwType, dwSize = sizeof(DWORD), dwValue = 0;

    //
    // For Safe mode boot (minimal, no networking)
    // return TRUE, otherwise return FALSE
    //

    err = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",
                0,
                KEY_READ,
                &Key );

    if ( err == ERROR_SUCCESS )
    {
        err = RegQueryValueExW(
                    Key,
                    L"OptionValue",
                    0,
                    &dwType,
                    (PUCHAR) &dwValue,
                    &dwSize );

        if ((err == ERROR_SUCCESS) && (REG_DWORD == dwType))
        {
            fIsSafeBoot = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey( Key );
    }

    return( fIsSafeBoot );
}


NTSTATUS
SampUpdateAccountDisabledFlag(
    PSAMP_OBJECT Context,
    PULONG  pUserAccountControl
    )
/*++
Routine Description:

    This routine updates the USER_ACCOUNT_DISABLED flag in UserAccountControl for
    administrator only.
    The following rules applied:

    1) admin account can be disabled irrespective of anything

    2) admin account is considered enabled irrespective of anything if machine is booted to safe mode

Parameters:

    Context - User Account Context

    pUserAccountControl - Pointer to UserAccountControl flag

Return Value:

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       TmpUserAccountControl = (*pUserAccountControl);

    //
    // no update for non-administrator account or account not disabled
    //

    if ((DOMAIN_USER_RID_ADMIN != Context->TypeBody.User.Rid) ||
        ((TmpUserAccountControl & USER_ACCOUNT_DISABLED) == 0)
        )
    {
        return( STATUS_SUCCESS );
    }


    if (SampSafeBoot())
    {
        //
        // Administrator in Safe Mode is enabled.
        //
        TmpUserAccountControl &= ~(USER_ACCOUNT_DISABLED);

    }

    *pUserAccountControl = TmpUserAccountControl;

    return( NtStatus );
}



NTSTATUS
SampRetrieveUserV1aFixed(
    IN PSAMP_OBJECT UserContext,
    OUT PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    )

/*++

Routine Description:

    This service retrieves the V1 fixed length information related to
    a specified User.

    It updates the ACCOUNT_AUTO_LOCKED flag in the AccountControl field
    as appropriate while retrieving the data.


Arguments:

    UserContext - User context handle

    V1aFixed - Points to a buffer into which V1_FIXED information is to be
        retrieved.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    V1aFixed - Is a buffer into which the information is to be returned.

    Other status values that may be returned are those returned
    by:

            SampGetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    PVOID       FixedData;
    BOOLEAN     WasLocked;

    SAMTRACE("SampRetrieveUserV1aFixed");


    NtStatus = SampGetFixedAttributes(
                   UserContext,
                   FALSE, // Don't copy
                   &FixedData
                   );

    if (NT_SUCCESS(NtStatus)) {


        //
        // Copy data into return buffer
        //

         RtlMoveMemory(
             V1aFixed,
             FixedData,
             sizeof(SAMP_V1_0A_FIXED_LENGTH_USER)
             );

        //
        // Update the account lockout flag (might need to be turned off)
        //

        SampUpdateAccountLockedOutFlag(
            UserContext,
            V1aFixed,
            &WasLocked );

    }



    return( NtStatus );

}


NTSTATUS
SampRetrieveUserGroupAttribute(
    IN ULONG UserRid,
    IN ULONG GroupRid,
    OUT PULONG Attribute
    )

/*++

Routine Description:

    This service retrieves the Attribute of the specified group as assigned
    to the specified user account. This routine is used by group apis that
    don't have a user context available.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    UserRid - The relative ID of the user the group is assigned to.

    GroupRid - The relative ID of the assigned group.

    Attribute - Receives the Attributes of the group as they are assigned
        to the user.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The user does not exist or the group
        was not in the user's list of memberships.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;
    BOOLEAN                 AttributeFound = FALSE;

    SAMTRACE("SampRetrieveUserGroupAttribute");


    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    UserRid,
                    TRUE, // We're trusted
                    FALSE,// Loopback client
                    TRUE, // Account exists
                    &UserContext
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Now we have a user context, get the user's group/alias membership
        //

        if (IsDsObject(UserContext))
        {
            //
            // User is DS Object, then hardwire the attribute
            //

            *Attribute = SE_GROUP_MANDATORY| SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
            AttributeFound = TRUE;
        }
        else
        {
            NtStatus = SampRetrieveUserMembership(
                            UserContext,
                            FALSE, // Make copy
                            &MembershipCount,
                            &Membership
                            );

            //
            // Search the list of groups for a match and return
            // the corresponding attribute.
            //

            if (NT_SUCCESS(NtStatus)) {

                AttributeFound = FALSE;
                for ( i=0; (i<MembershipCount && !AttributeFound); i++) {
                    if (GroupRid == Membership[i].RelativeId) {
                        (*Attribute) = Membership[i].Attributes;
                        AttributeFound = TRUE;
                    }
                }
            }
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }


    if (NT_SUCCESS(NtStatus) && !AttributeFound) {
        NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
    }


    return( NtStatus );

}


NTSTATUS
SampAddGroupToUserMembership(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive,
    OUT PBOOLEAN PrimaryGroup
    )

/*++

Routine Description:

    This service adds the specified group to the user's membership
    list.  It is not assumed that the caller knows anything about
    the target user.  In particular, the caller doesn't know whether
    the user exists or not, nor whether the user is already a member
    of the group.

    If the GroupRid is DOMAIN_GROUP_RID_ADMINS, then this service
    will also indicate whether the user account is currently active.

Arguments:

    GroupRid - The relative ID of the group.

    Attributes - The group attributes as the group is assigned to the
        user.

    UserRid - The relative ID of the user.

    AdminGroup - Indicates whether the group the user is being
        added to is an administrator group (that is, directly
        or indirectly a member of the Administrators alias).

    OperatorGroup - Indicates whether the group the user is being
        added to is an operator group (that is, directly
        or indirectly a member of the Account Operators, Print
        Operators, Backup Operators, or Server Operators aliases)

    UserActive - is the address of a BOOLEAN to be set to indicate
        whether the user account is currently active.  TRUE indicates
        the account is active.  This value will only be set if the
        GroupRid is DOMAIN_GROUP_RID_ADMINS.

    PrimaryGroup - This is set to true if the Primary Group Id property
        of the user indicates the group specified by GroupRid as the the
        primary group.



Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_IN_GROUP - The user is already a member of the
        specified group.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;

    SAMTRACE("SampAddGroupToUserMembership");


    *PrimaryGroup = FALSE;

    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext2(
                    GroupContext,       // Group Context
                    SampUserObjectType, // Object Type
                    UserRid,            // Account ID
                    NULL,               // UserAccountControl
                    (PUNICODE_STRING)NULL,  // AccountName
                    GroupContext->ClientRevision,   // Client Revision
                    TRUE,               // We're trusted
                    GroupContext->LoopbackClient,   // Loopback client
                    FALSE,              // Create by Privilege
                    TRUE,               // Account Exists
                    FALSE,              // OverrideLocalGroupCheck
                    NULL,               // Group Type
                    &UserContext
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the V1aFixed Data
        //

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &V1aFixed
                       );


        //
        // If necessary, return an indication as to whether this account
        // is enabled or not.
        //

        if (NT_SUCCESS(NtStatus)) {

            if ((GroupRid == DOMAIN_GROUP_RID_ADMINS)
                 && (!(IsDsObject(UserContext))))
            {

                ASSERT(AdminGroup == AddToAdmin);  // Make sure we retrieved the V1aFixed

                if ((V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED) == 0) {
                    (*UserActive) = TRUE;
                } else {
                    (*UserActive) = FALSE;
                }
            }

            if (GroupRid == V1aFixed.PrimaryGroupId)
            {
                *PrimaryGroup = TRUE;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If the user is being added to an ADMIN group, modify
            // the user's ACLs so that account operators can once again
            // alter the account.  This will only occur if the user
            // is no longer a member of any admin groups.
            //

            if ( ((AdminGroup == AddToAdmin) || (OperatorGroup == AddToAdmin))
                 && (!IsDsObject(UserContext)))
            {
                NtStatus = SampChangeOperatorAccessToUser2(
                               UserContext,
                               &V1aFixed,
                               AdminGroup,
                               OperatorGroup
                               );
            }
        }


        if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext)))
        {

            //
            // Get the user membership
            // Note the returned buffer already includes space for
            // an extra member. For DS case we do not maintain reverse
            // membership
            //

            NtStatus = SampRetrieveUserMembership(
                            UserContext,
                            TRUE, // Make copy
                            &MembershipCount,
                            &Membership
                            );

            if (NT_SUCCESS(NtStatus)) {

                //
                // See if the user is already a member ...
                //

                for (i = 0; i<MembershipCount ; i++ ) {
                    if ( Membership[i].RelativeId == GroupRid )
                    {
                        NtStatus = STATUS_MEMBER_IN_GROUP;
                    }
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Add the groups's RID to the end.
                    //

                    Membership[MembershipCount].RelativeId = GroupRid;
                    Membership[MembershipCount].Attributes = Attributes;
                    MembershipCount += 1;

                    //
                    // Set the user's new membership
                    //

                    NtStatus = SampReplaceUserMembership(
                                    UserContext,
                                    MembershipCount,
                                    Membership
                                    );
                }

                //
                // Free up the membership array
                //

                MIDL_user_free( Membership );
            }
        }

        //
        // Write out any changes to the user account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveMembershipUser(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive
    )

/*++

Routine Description:

    This service removes the specified group from the user's membership
    list.  It is not assumed that the caller knows anything about
    the target user.  In particular, the caller doesn't know whether
    the user exists or not, nor whether the user is really a member
    of the group.

    If the GroupRid is DOMAIN_GROUP_RID_ADMINS, then this service
    will also indicate whether the user account is currently active.

Arguments:

    GroupRid - The relative ID of the group.

    UserRid - The relative ID of the user.

    AdminGroup - Indicates whether the group the user is being
        removed from is an administrator group (that is, directly
        or indirectly a member of the Administrators alias).

    OperatorGroup - Indicates whether the group the user is being
        added to is an operator group (that is, directly
        or indirectly a member of the Account Operators, Print
        Operators, Backup Operators, or Server Operators aliases)

    UserActive - is the address of a BOOLEAN to be set to indicate
        whether the user account is currently active.  TRUE indicates
        the account is active.  This value will only be set if the
        GroupRid is DOMAIN_GROUP_RID_ADMINS.




Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not a member of the
        specified group.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   MembershipCount, i;
    PGROUP_MEMBERSHIP       MembershipArray;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    PSAMP_OBJECT            UserContext;

    SAMTRACE("SampRemoveMembershipUser");

    //
    // Create a context for the user
    //

    NtStatus = SampCreateAccountContext2(
                    GroupContext,           // GroupContext
                    SampUserObjectType,     // Object Type
                    UserRid,                // Object ID
                    NULL,                   // User Account Control
                    (PUNICODE_STRING)NULL,  // Account Name
                    GroupContext->ClientRevision,   // Client Revision
                    TRUE,                   // We're trusted (Trusted client)
                    GroupContext->LoopbackClient,   // Loopback client
                    FALSE,                  // Created by Privilege
                    TRUE,                   // Account Exists
                    FALSE,                  // OverrideLocalGroupCheck
                    NULL,                   // Group Type
                    &UserContext            // Account Context
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Get the v1 fixed information
    // (contains primary group value and control flags)
    //

    NtStatus = SampRetrieveUserV1aFixed( UserContext, &V1aFixed );



    if (NT_SUCCESS(NtStatus)) {

        //
        // If the user is being removed from an ADMIN group, modify
        // the user's ACLs so that account operators can once again
        // alter the account.  This will only occur if the user
        // is no longer a member of any admin groups.
        //

        if (((AdminGroup == RemoveFromAdmin) ||
            (OperatorGroup == RemoveFromAdmin))
            && (!IsDsObject(UserContext)))
        {
            NtStatus = SampChangeOperatorAccessToUser2(
                           UserContext,
                           &V1aFixed,
                           AdminGroup,
                           OperatorGroup
                           );
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If necessary, return an indication as to whether this account
            // is enabled or not.
            //

            if (GroupRid == DOMAIN_GROUP_RID_ADMINS) {

                if ((V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED) == 0) {
                    (*UserActive) = TRUE;
                } else {
                    (*UserActive) = FALSE;
                }
            }


            //
            // See if this is the user's primary group...
            //

            if (GroupRid == V1aFixed.PrimaryGroupId) {
                NtStatus = STATUS_MEMBERS_PRIMARY_GROUP;
            }



            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext)))
            {

                //
                // Get the user membership, No reverse membership is stored for
                // DS Objects
                //

                NtStatus = SampRetrieveUserMembership(
                               UserContext,
                               TRUE, // Make copy
                               &MembershipCount,
                               &MembershipArray
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // See if the user is a member ...
                    //

                    NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
                    for (i = 0; i<MembershipCount ; i++ ) {
                        if ( MembershipArray[i].RelativeId == GroupRid )
                        {
                            NtStatus = STATUS_SUCCESS;
                            break;
                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Replace the removed group information
                        // with the last entry's information.
                        //

                        MembershipCount -= 1;
                        if (MembershipCount > 0) {
                            MembershipArray[i].RelativeId =
                                MembershipArray[MembershipCount].RelativeId;
                            MembershipArray[i].Attributes =
                            MembershipArray[MembershipCount].Attributes;
                        }

                        //
                        // Update the object with the new information
                        //

                        NtStatus = SampReplaceUserMembership(
                                        UserContext,
                                        MembershipCount,
                                        MembershipArray
                                        );
                    }

                    //
                    // Free up the membership array
                    //

                    MIDL_user_free( MembershipArray );
                }
            }
        }
    }


    //
    // Write out any changes to the user account
    // Don't use the open key handle since we'll be deleting the context.
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
    }


    //
    // Clean up the user context
    //

    SampDeleteContext(UserContext);


    return( NtStatus );

}



NTSTATUS
SampSetGroupAttributesOfUser(
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This service replaces the attributes of a group assigned to a
    user.

    The caller does not have to know whether the group is currently
    assigned to the user.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    GroupRid - The relative ID of the group.

    Attributes - The group attributes as the group is assigned to the
        user.

    UserRid - The relative ID of the user.



Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not in the specified group.


    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;

    SAMTRACE("SampSetGroupAttributesOfUser");


    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    UserRid,
                    TRUE, // We're trusted
                    FALSE,// Loopback Client
                    TRUE, // Account exists
                    &UserContext
                    );

    if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext))) {

        //
        // Now we have a user context, get the user's group/alias membership
        // For DS case this is a No Op
        //

        NtStatus = SampRetrieveUserMembership(
                        UserContext,
                        TRUE, // Make copy
                        &MembershipCount,
                        &Membership
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // See if the user is a member ...
            //

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for (i = 0; i<MembershipCount; i++ ) {
                if ( Membership[i].RelativeId == GroupRid )
                {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Change the groups's attributes.
                //

                Membership[i].Attributes = Attributes;

                //
                // Update the user's membership
                //

                NtStatus = SampReplaceUserMembership(
                                UserContext,
                                MembershipCount,
                                Membership
                                );
            }

            //
            // Free up the membership array
            //

            MIDL_user_free(Membership);
        }

        //
        // Write out any changes to the user account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }


    return( NtStatus );
}




NTSTATUS
SampDeleteUserKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a User object.


Arguments:

    Context - Points to the User context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;

    SAMTRACE("SampDeleteUserKeys");


    Rid = Context->TypeBody.User.Rid;




    //
    // Decrement the User count
    //

    NtStatus = SampAdjustAccountCount(SampUserObjectType, FALSE );




    //
    // Delete the registry key that has the User's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_USER_ACCOUNT_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampUserObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );
                SampFreeUnicodeString( &KeyName );
            }
        }
    }



    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }




    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}



NTSTATUS
SampAddPasswordHistory(
    IN PSAMP_OBJECT Context,
    IN ULONG HistoryAttributeIndex,
    IN PUNICODE_STRING NtOwfHistoryBuffer,
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength
    )

/*++

Routine Description:

    This service adds a password to the given user's password history.
    It will work for either NT or Lanman password histories.

    This routine should only be called if the password is actually present.


Arguments:

    Context - a pointer to the user context to which changes will be made.

    HistoryAttributeIndex - the attribue index in the user context which
             contains the password history.

    NtOwfHistoryBuffer - A pointer to the current password history, as
        it was retrieved from the disk - it's encrypted, and pretending
        to be in the UNICODE_STRING format.

    EncryptedPasswordLength - ENCRYPTED_NT_OWF_LENGTH or
        ENCRYPTED_LM_OWF_LENGTH, depending on which type of password
        history is being worked on.

    PasswordHistoryLength - The PasswordHistoryLength for the user's
        domain.


Return Value:


    STATUS_SUCCESS - The given password was added to the password history.

    STATUS_INSUFFICIENT_RESOURCES - The user's password history needs to
        be expanded, but there isn't enough memory to do so.

    Other errors from building the account subkey name or writing the
    password history out to the registry.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCHAR OldBuffer;
    UNICODE_STRING StoredBuffer;


    SAMTRACE("SampAddPasswordHistory");

    if ( ( NtOwfHistoryBuffer->Length / EncryptedPasswordLength ) <
        ( (ULONG)PasswordHistoryLength ) ) {

        //
        // Password history buffer can be expanded.
        // Allocate a larger buffer, copy the old buffer to the new one
        // while leaving room for the new password, and free the old
        // buffer.
        //

        OldBuffer = (PCHAR)(NtOwfHistoryBuffer->Buffer);

        NtOwfHistoryBuffer->Buffer = MIDL_user_allocate(
            NtOwfHistoryBuffer->Length + EncryptedPasswordLength );

        if ( NtOwfHistoryBuffer->Buffer == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            NtOwfHistoryBuffer->Buffer = (PWSTR)OldBuffer;

        } else {

            RtlCopyMemory(
                (PVOID)( (PCHAR)(NtOwfHistoryBuffer->Buffer) + EncryptedPasswordLength ),
                (PVOID)OldBuffer,
                NtOwfHistoryBuffer->Length );

            MIDL_user_free( OldBuffer );

            NtOwfHistoryBuffer->Length = (USHORT)(NtOwfHistoryBuffer->Length +
                EncryptedPasswordLength);
        }

    } else {

        //
        // Password history buffer is at its maximum size, or larger (for
        // this domain).  If it's larger, cut it down to the current maximum.
        //

        if ( ( NtOwfHistoryBuffer->Length / EncryptedPasswordLength ) >
            ( (ULONG)PasswordHistoryLength ) ) {

            //
            // Password history is too large (the password history length must
            // have been shortened recently).
            // Set length to the proper value,
            //

            NtOwfHistoryBuffer->Length = (USHORT)(EncryptedPasswordLength *
                PasswordHistoryLength);
        }

        //
        // Password history buffer is full, at its maximum size.
        // Move buffer contents right 16 bytes, which will lose the oldest
        // password and make room for the new password at the beginning
        // (left).
        // Note that we CAN'T move anything if the password history size
        // is 0.  If it's 1, we could but no need since we'll overwrite
        // it below.
        //

        if ( PasswordHistoryLength > 1 ) {

            RtlMoveMemory(
                (PVOID)( (PCHAR)(NtOwfHistoryBuffer->Buffer) + EncryptedPasswordLength ),
                (PVOID)NtOwfHistoryBuffer->Buffer,
                NtOwfHistoryBuffer->Length - EncryptedPasswordLength );
        }
    }


    //
    // Put the new encrypted OWF at the beginning of the password history
    // buffer (unless, of course, the buffer size is 0), and write the password
    // history to disk.
    //

    if ( NT_SUCCESS( NtStatus ) ) {


        if ( PasswordHistoryLength > 0 ) {

            RtlCopyMemory(
                (PVOID)NtOwfHistoryBuffer->Buffer,
                (PVOID)EncryptedPassword,
                EncryptedPasswordLength );
        }


        //
        // If the no LM hash setting is enabled and if the LM password history is being
        // written then set the password history to be random noise so as to flush
        // out any lingering LM Hash's.

        if ((HistoryAttributeIndex == SAMP_USER_LM_PWD_HISTORY) && SampNoLmHash) {

            RtlGenRandom((PUCHAR)NtOwfHistoryBuffer->Buffer, NtOwfHistoryBuffer->Length);

        }

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        (SAMP_USER_NT_PWD_HISTORY==HistoryAttributeIndex)?
                            NtPasswordHistory:LmPasswordHistory,
                        NtOwfHistoryBuffer,
                        Context->TypeBody.User.Rid
                        );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           HistoryAttributeIndex,
                           &StoredBuffer
                           );
            SampFreeUnicodeString(&StoredBuffer);
        }
    }

    return( NtStatus );
}



NTSTATUS
SampCheckPasswordHistory(
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength,
    IN ULONG HistoryAttributeIndex,
    IN PSAMP_OBJECT Context,
    IN BOOLEAN CheckHistory,
    IN OUT PUNICODE_STRING OwfHistoryBuffer
    )

/*++

Routine Description:

    This service takes the given password, and optionally checks it against the
    password history on the disk.  It returns a pointer to the password
    history, which will later be passed to SampAddPasswordHistory().

    This routine should only be called if the password is actually present.


Arguments:

    EncryptedPassword - A pointer to the encrypted password that we're
        looking for.

    EncryptedPasswordLength - ENCRYPTED_NT_OWF_PASSWORD or
        ENCRYPTED_LM_OWF_PASSWORD, depending on the type of password
        history to be searched.

    PasswordHistoryLength - the length of the password history for this
        domain.

    SubKeyName -  a pointer to a unicode string that describes the name
        of the password history to be read from the disk.

    Context - a pointer to the user's context.

    CheckHistory - If TRUE, the password is to be checked against
        the history to see if it is already present and an error returned
        if it is found.  If FALSE, the password will not be checked, but a
        pointer to the appropriate history buffer will still be returned
        because the specified password will be added to the history via
        SampAddPasswordHistory.

        NOTE:  The purpose of this flag is to allow Administrator to change
        a user's password regardless of whether it is already in the history.

    OwfHistoryBuffer - a pointer to a UNICODE_STRING which will be
        used to point to the password history.

        NOTE:  The caller must free OwfHistoryBuffer.Buffer with
        MIDL_user_free().


Return Value:


    STATUS_SUCCESS - The given password was not found in the password
        history.

    STATUS_PASSWORD_RESTRICTION - The given password was found in the
        password history.

    Other errors from reading the password history from disk.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID PasswordHistoryEntry;
    ULONG i = 0;
    BOOLEAN OldPasswordFound = FALSE;

    SAMTRACE("SampCheckPasswordHistory");


    if ( ( PasswordHistoryLength > 0 ) && ( OwfHistoryBuffer->Length == 0 ) ) {

        //
        // Perhaps the domain's PasswordHistoryLength was raised from 0
        // since the last time this user's password was changed.  Try to
        // put the current password (if non-null) in the password history.
        //

        UNICODE_STRING CurrentPassword;
        UNICODE_STRING TmpString;
        USHORT PasswordAttributeIndex;

        //
        // Initialize the CurrentPassword buffer pointer to NULL (and the
        // rest of the structure for consistency.  The called routine
        // SampGetUnicodeStringAttribute may perform a MIDL_user_allocate
        // on a zero buffer length and cannot safely be changed as there are
        // many callers.  The semantics of a zero-length allocate call are
        // not clear.  Currently a pointer to a heap block is returned,
        // but this might be changed to a NULL being returned.
        //

        CurrentPassword.Length = CurrentPassword.MaximumLength = 0;
        CurrentPassword.Buffer = NULL;


        if ( HistoryAttributeIndex == SAMP_USER_LM_PWD_HISTORY ) {

            PasswordAttributeIndex = SAMP_USER_DBCS_PWD;

        } else {

            ASSERT( HistoryAttributeIndex == SAMP_USER_NT_PWD_HISTORY );
            PasswordAttributeIndex = SAMP_USER_UNICODE_PWD;
        }

        //
        // Get the current password
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       PasswordAttributeIndex,
                       FALSE, // Make copy
                       &TmpString
                       );
        //
        // Decrypt the Current Password
        //

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampDecryptSecretData(
                        &CurrentPassword,
                        (SAMP_USER_UNICODE_PWD==PasswordAttributeIndex)?
                           NtPassword:LmPassword,
                        &TmpString,
                        Context->TypeBody.User.Rid
                        );
        }

        if ( ( NT_SUCCESS( NtStatus ) ) && ( CurrentPassword.Length != 0 ) ) {

            ASSERT( (CurrentPassword.Length == ENCRYPTED_NT_OWF_PASSWORD_LENGTH) ||
                    (CurrentPassword.Length == ENCRYPTED_LM_OWF_PASSWORD_LENGTH) );

            NtStatus = SampAddPasswordHistory(
                           Context,
                           HistoryAttributeIndex,
                           OwfHistoryBuffer,
                           CurrentPassword.Buffer,
                           CurrentPassword.Length,
                           PasswordHistoryLength
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Free the old password history, and re-read the
                // altered password history from the disk.
                //

                MIDL_user_free( OwfHistoryBuffer->Buffer );
                RtlSecureZeroMemory(OwfHistoryBuffer, sizeof(UNICODE_STRING));

                NtStatus = SampGetUnicodeStringAttribute(
                               Context,
                               HistoryAttributeIndex,
                               FALSE, // Make copy
                               &TmpString
                               );
                if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampDecryptSecretData(
                                        OwfHistoryBuffer,
                                        (HistoryAttributeIndex == SAMP_USER_NT_PWD_HISTORY)?
                                          NtPasswordHistory:LmPasswordHistory,
                                        &TmpString,
                                        Context->TypeBody.User.Rid
                                        );
                }
            }
        }

        //
        // If memory was allocated, free it.
        //

        if (CurrentPassword.Buffer != NULL) {

            RtlSecureZeroMemory(CurrentPassword.Buffer, CurrentPassword.Length);
            SampFreeUnicodeString( &CurrentPassword );
        }
    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    //
    // If requested, check the Password History to see if we can use this
    // password.  Compare the passed-in password to each of the entries in
    // the password history.
    //

    if ((CheckHistory) && (!Context->TrustedClient)) {

        PasswordHistoryEntry = (PVOID)(OwfHistoryBuffer->Buffer);

        while ( ( i < (ULONG)PasswordHistoryLength ) &&
            ( i < ( OwfHistoryBuffer->Length / EncryptedPasswordLength ) ) &&
            ( OldPasswordFound == FALSE ) ) {

            if ( RtlCompareMemory(
                     EncryptedPassword,
                     PasswordHistoryEntry,
                     EncryptedPasswordLength ) == EncryptedPasswordLength ) {

                OldPasswordFound = TRUE;

            } else {

                i++;

                PasswordHistoryEntry = (PVOID)((PCHAR)(PasswordHistoryEntry) +
                    EncryptedPasswordLength );
            }
        }

        if ( OldPasswordFound ) {

            //
            // We did find it in the password history, so return an appropriate
            // error.
            //

            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    return( NtStatus );
}



NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    )

/*++

Routine Description:

    Check if the given workstation is a member of the list of workstations
    given.


Arguments:

    LogonWorkStations - UNICODE name of the workstation that the user is
        trying to log into.

    WorkStations - API list of workstations that the user is allowed to
        log into.


Return Value:


    STATUS_SUCCESS - The user is allowed to log into the workstation.



--*/
{
    PWCHAR          WorkStationName;
    UNICODE_STRING  Unicode;
    NTSTATUS        NtStatus;
    WCHAR           Buffer[256];
    USHORT          LocalBufferLength = sizeof(Buffer);
    UNICODE_STRING  WorkStationsListCopy;
    UNICODE_STRING  NetBiosOfStored;
    UNICODE_STRING  NetBiosOfPassedIn;
    BOOLEAN         BufferAllocated = FALSE;
    PWCHAR          TmpBuffer;

    SAMTRACE("SampMatchWorkstation");

    //
    // Local workstation is always allowed
    // If WorkStations field is 0 everybody is allowed
    //

    if ( ( LogonWorkStation == NULL ) ||
        ( LogonWorkStation->Length == 0 ) ||
        ( WorkStations->Length == 0 ) ) {

        return( STATUS_SUCCESS );
    }

    RtlSecureZeroMemory(&NetBiosOfPassedIn, sizeof(UNICODE_STRING));
    RtlSecureZeroMemory(&NetBiosOfStored, sizeof(UNICODE_STRING));

    //
    // Get the Netbiosname of Passed in logon workstation, assuming it
    // is a DNS name
    //

    NtStatus = RtlDnsHostNameToComputerName(
                    &NetBiosOfPassedIn,
                    LogonWorkStation,
                    TRUE
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Assume failure; change status only if we find the string.
    //

    NtStatus = STATUS_INVALID_WORKSTATION;

    //
    // WorkStationApiList points to our current location in the list of
    // WorkStations.
    //

    if ( WorkStations->Length >= LocalBufferLength ) {

        WorkStationsListCopy.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, WorkStations->Length + sizeof(WCHAR));

        if ( WorkStationsListCopy.Buffer == NULL ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        BufferAllocated = TRUE;

        WorkStationsListCopy.MaximumLength = WorkStations->Length + sizeof(WCHAR);

    } else {

        WorkStationsListCopy.Buffer = Buffer;
        WorkStationsListCopy.MaximumLength = LocalBufferLength;
    }

    //
    // RtlCopyUnicodeString will NULL terminate the string
    //
    RtlCopyUnicodeString( &WorkStationsListCopy, WorkStations );
    ASSERT( WorkStationsListCopy.Length == WorkStations->Length );

    //
    // wcstok requires a string the first time it's called, and NULL
    // for all subsequent calls.  Use a temporary variable so we
    // can do this.
    //

    TmpBuffer = WorkStationsListCopy.Buffer;

    while( WorkStationName = wcstok(TmpBuffer, L",") ) {
        NTSTATUS TmpStatus;

        TmpBuffer = NULL;
        RtlInitUnicodeString( &Unicode, WorkStationName );

        TmpStatus = RtlDnsHostNameToComputerName(
                    &NetBiosOfStored,
                    &Unicode,
                    TRUE
                    );

        if (!NT_SUCCESS(TmpStatus))
        {
            NtStatus = TmpStatus;
            goto Cleanup;
        }

        if (RtlEqualComputerName( &Unicode, LogonWorkStation )) {
            NtStatus = STATUS_SUCCESS;
            break;
        }
        else if (RtlEqualComputerName(&Unicode, &NetBiosOfPassedIn))
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }
        else if (RtlEqualComputerName(&NetBiosOfStored, LogonWorkStation))
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        RtlFreeHeap(RtlProcessHeap(),0,NetBiosOfStored.Buffer);
        NetBiosOfStored.Buffer = NULL;
    }

Cleanup:

    if ( BufferAllocated ) {
        RtlFreeHeap( RtlProcessHeap(), 0,  WorkStationsListCopy.Buffer );
    }


    if (NULL!=NetBiosOfPassedIn.Buffer)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NetBiosOfPassedIn.Buffer);
    }

    if (NULL!=NetBiosOfStored.Buffer)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NetBiosOfStored.Buffer);
    }

    return( NtStatus );
}


LARGE_INTEGER
SampAddDeltaTime(
    IN LARGE_INTEGER Time,
    IN LARGE_INTEGER DeltaTime
    )

/*++
Routine Description:

    This service adds a delta time to a time and limits the result to
    the maximum legal absolute time value

Arguments:

    Time - An absolute time

    DeltaTime - A delta time

Return Value:

    The time modified by delta time.

--*/
{
    //
    // Check the time and delta time aren't switched
    //

    SAMTRACE("SampAddDeleteTime");

    ASSERT(!(Time.QuadPart < 0));
    ASSERT(!(DeltaTime.QuadPart > 0));

    try {

        Time.QuadPart = (Time.QuadPart - DeltaTime.QuadPart);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return( SampWillNeverTime );
    }

    //
    // Limit the resultant time to the maximum valid absolute time
    //

    if (Time.QuadPart < 0) {
        Time = SampWillNeverTime;
    }

    return(Time);
}




NTSTATUS
SampDsSyncServerObjectRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine changes the RDN of server object specified by
    the serverReferenceBL attribute of the computer account.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned by:
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ENTINFSEL   EntInfSel;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    ATTR        ReadAttr;
    ATTRBLOCK   ReadAttrBlock;
    COMMARG     *pCommArg = NULL;
    MODIFYDNARG ModDnArg;
    MODIFYDNRES *pModDnRes = NULL;
    ATTR        RDNAttr;
    ATTRVAL     RDNAttrVal;
    DSNAME      *pServerObjectDsName = NULL;
    ULONG       RetCode = 0;

    SAMTRACE("SampDsSyncServerObjectRDN");

    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);


    //
    // Read the serverReferenceBL attribute of the machine account
    //

    memset( &ReadArg, 0, sizeof(READARG) );
    memset( &EntInfSel, 0, sizeof(EntInfSel) );
    memset( &ReadAttr, 0, sizeof(ReadAttr) );

    ReadAttr.attrTyp = ATT_SERVER_REFERENCE_BL;
    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &ReadAttr;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock = ReadAttrBlock;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = Context->ObjectNameInDs;

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    RetCode = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode, &pReadRes->CommRes);
    }

    //
    // if no such attribute, fail silently
    //

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
        goto CleanupAndReturn;
    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto CleanupAndReturn;
    }

    pServerObjectDsName = (PDSNAME) pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;



    //
    // modify the ServerObject RDN
    //

    RDNAttr.attrTyp = ATT_COMMON_NAME;
    RDNAttr.AttrVal.valCount = 1;
    RDNAttr.AttrVal.pAVal = &RDNAttrVal;

    // Trim the dollar at the end of machine account name.
    if (L'$'==NewAccountName->Buffer[NewAccountName->Length/2-1])
    {
        RDNAttrVal.valLen = NewAccountName->Length - sizeof(WCHAR);
    }
    else
    {
        RDNAttrVal.valLen = NewAccountName->Length;
    }
    RDNAttrVal.pVal = (PUCHAR)NewAccountName->Buffer;

    memset( &ModDnArg, 0, sizeof(ModDnArg) );
    ModDnArg.pObject = pServerObjectDsName;
    ModDnArg.pNewRDN = &RDNAttr;
    pCommArg = &(ModDnArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyDN( &ModDnArg, &pModDnRes );

    if (NULL == pModDnRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus( RetCode, &pModDnRes->CommRes);
    }


CleanupAndReturn:

    SampClearErrors();


    return( NtStatus );
}


NTSTATUS
SampChangeUserAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    IN ULONG UserAccountControl,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of a user account.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

    UserAccountControl - The UserAccountControl for the user, used to exam
                         whether this account is a machine account or not.

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeUserAccountName");


    //
    // The Krbtgt account is special. Cannot rename this account
    // as otherwise this is special
    //

    if (DOMAIN_USER_RID_KRBTGT==Context->TypeBody.User.Rid)
    {
        return (STATUS_SPECIAL_ACCOUNT);
    }

    /////////////////////////////////////////////////////////////
    // There are two copies of the name of each account.       //
    // one is under the DOMAIN\(domainName)\USER\NAMES key,    //
    // one is the value of the                                 //
    // DOMAIN\(DomainName)\USER\(rid)\NAME key                 //
    /////////////////////////////////////////////////////////////


    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_ACCOUNT_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampUserObjectType
                       );

        if (!IsDsObject(Context))
        {

            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampUserObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampUserObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG ObjectRid = Context->TypeBody.User.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   ObjectRid,
                                   (PVOID)NULL,
                                   0
                                   );

                    SampFreeUnicodeString( &KeyName );
                }
            }
        }
        else  // DS mode
        {
            //
            // If the user account is actually a machine account,
            // try to rename the RDN in DS
            //
            if (  (NT_SUCCESS(NtStatus)) &&
                  ((UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT) ||
                   (UserAccountControl & USER_SERVER_TRUST_ACCOUNT))  &&
                 !Context->LoopbackClient)
            {
                NtStatus = SampDsChangeAccountRDN(
                                                Context,
                                                NewAccountName
                                                );

                //
                // if the account is a Domain Controller,
                // try to rename the RDN of the server object specified by
                // the serverReferenceBL attribute of the machine account
                //

                if (NT_SUCCESS(NtStatus) &&
                    (UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                    !Context->LoopbackClient)
                {
                    NtStatus = SampDsSyncServerObjectRDN(
                                                Context,
                                                NewAccountName
                                                );
                }
            }
        }

        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_ACCOUNT_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {

            SampFreeUnicodeString( OldAccountName );
            OldAccountName->Buffer = NULL;
        }

    }


    return(NtStatus);
}



USHORT
SampQueryBadPasswordCount(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    )

/*++

Routine Description:

    This routine is used to retrieve the effective BadPasswordCount
    value of a user.

    When querying BadPasswordCount, some quick
    analysis has to be done.  If the last bad password
    was set more than LockoutObservationWindow time ago,
    then we re-set the BadPasswordCount.  Otherwise, we
    return the current value.


    NOTE: The V1aFixed data for the user object MUST be valid.
          This routine does not retrieve the data from disk.

Arguments:

    UserContext - Points to the object context block of the user whose
        bad password count is to be returned.

    V1aFixed - Points to a local copy of the user's V1aFixed data.


Return Value:


    The effective bad password count.


--*/
{

    SAMTRACE("SampQueryBadPasswordCount");

    if (SampStillInLockoutObservationWindow( UserContext, V1aFixed ) ) {
        return(V1aFixed->BadPasswordCount);
    }

    return(0);

}


BOOLEAN
SampStillInLockoutObservationWindow(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    )
/*++

Routine Description:

    This routine returns a boolean indicating whether the provided user
    account context is within an account lockout window or not.

    An account lockout window is the time window starting at the
    last time a bad password was provided in a logon attempt
    (since the last valid logon) and extending for the duration of
    time specified in the LockoutObservationWindow field of the
    corresponding domain object.

    BY DEFINITION, a user account that has zero bad passwords, is
    NOT in an observation window.

    NOTE: The V1aFixed data for the both the user and corresponding
          domain objects MUST be valid.  This routine does NOT retrieve
          data from disk.

Arguments:

    UserContext - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.


Return Value:


    TRUE - the user is in a lockout observation window.

    FALSE - the user is not in a lockout observation window.


--*/
{
    NTSTATUS
        NtStatus;

    LARGE_INTEGER
        WindowLength,
        LastBadPassword,
        CurrentTime,
        EndOfWindow;

    SAMTRACE("SampStillInLockoutObservationWindow");


    if (V1aFixed->BadPasswordCount == 0) {
        return(FALSE);
    }

    //
    // At least one bad password.
    // See if we are still in its observation window.
    //

    LastBadPassword = V1aFixed->LastBadPasswordTime;

    ASSERT( LastBadPassword.HighPart >= 0 );

    WindowLength =
        SampDefinedDomains[UserContext->DomainIndex].CurrentFixed.LockoutObservationWindow;
    ASSERT( WindowLength.HighPart <= 0 );  // Must be a delta time


    NtStatus = NtQuerySystemTime( &CurrentTime );
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // See if current time is outside the observation window.
    // * you must subtract a delta time from an absolute time*
    // * to end up with a time in the future.                *
    //

    EndOfWindow = SampAddDeltaTime( LastBadPassword, WindowLength );

    return(CurrentTime.QuadPart <= EndOfWindow.QuadPart);

}


BOOLEAN
SampIncrementBadPasswordCount(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN PUNICODE_STRING  MachineName  OPTIONAL
    )

/*++

Routine Description:

    This routine increments a user's bad password count.
    This may result in the account becoming locked out.
    It may also result in the BadPasswordCount being
    reduced (because we left one LockoutObservationWindow
    and had to start another).

    If (and only if) this call results in the user account
    transitioning from not locked out to locked out, a value
    of TRUE will be returned.  Otherwise, a value of FALSE is
    returned.


    NOTE: The V1aFixed data for the both the user and corresponding
          domain objects MUST be valid.  This routine does NOT retrieve
          data from disk.

Arguments:

    Context - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.

    MachineName - a pointer to the client workstation making the call,
                  if available

Return Value:


    TRUE - the user became locked-out due to this call.

    FALSE - the user was either already locked-out, or did
        not become locked out due to this call.


--*/
{
    NTSTATUS
        NtStatus;


    BOOLEAN
        IsLocked,
        WasLocked;

    TIME_FIELDS
        T1;

    SAMTRACE("SampIncrementBadPasswordCount");


    //
    // Reset the locked out flag if necessary.
    // We might turn right around and set it again below,
    // but we need to know when we transition into a locked-out
    // state.  This is necessary to give us information we
    // need to do lockout auditing at some time.  Note that
    // the lockout flag itself is updated in a very lazy fashion,
    // and so its state may or may not be accurate at any point
    // in time.  You must call SampUpdateAccountLockoutFlag to
    // ensure it is up to date.
    //

    SampUpdateAccountLockedOutFlag( UserContext,
                                    V1aFixed,
                                    &WasLocked );

    //
    // If we are not in a lockout observation window, then
    // reset the bad password count.
    //

    if (!SampStillInLockoutObservationWindow( UserContext, V1aFixed )) {

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: 0x%x IncrementBadPasswordCount: starting new observation window.\n",
                       V1aFixed->UserId));
        V1aFixed->BadPasswordCount = 0; // Dirty flag will be set later
    }

    V1aFixed->BadPasswordCount++;

    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x Incrementing bad password count to %d\n",
                   V1aFixed->UserId, V1aFixed->BadPasswordCount));

    NtStatus = NtQuerySystemTime( &V1aFixed->LastBadPasswordTime );
    ASSERT(NT_SUCCESS(NtStatus));

    RtlTimeToTimeFields(
                   &V1aFixed->LastBadPasswordTime,
                   &T1);

    if ( IsDsObject( UserContext ) )
    {
        BOOLEAN BeyondLockoutDuration;
        USHORT Threshold;

        //
        // When we are a dc, we need to set the global LockoutTime when enough
        // bad passwords have been provided.
        //
        Threshold =
         SampDefinedDomains[UserContext->DomainIndex].CurrentFixed.LockoutThreshold;

        if (SampAccountLockoutTestMode) {

            LARGE_INTEGER EndOfLockout;

    
            //
            // SAM shouldn't be called to increment the bad password count when an 
            // account is locked out.  The only exception is 
            // SampAccountLockoutTestMode where accounts are locked out in the 
            // database, but we don't update the user account control attribute 
            // indicating that the account is locked out.
            // Therefore don't update the LockoutTime (which is a replicated 
            // attribute) unless the account needs to be locked again.
            //
            EndOfLockout =
                 SampAddDeltaTime( UserContext->TypeBody.User.LockoutTime, 
                                   SampDefinedDomains[UserContext->DomainIndex].CurrentFixed.LockoutDuration );
     
            BeyondLockoutDuration = V1aFixed->LastBadPasswordTime.QuadPart > EndOfLockout.QuadPart;
    
        } else {

            //
            // During normal account lockout, always write the new 
            // lockout time
            //
            BeyondLockoutDuration = TRUE;

        }

                  
        //
        // Don't lockout machine accounts -- see Windows NT bug 434468
        //


        if (   (V1aFixed->BadPasswordCount >= Threshold)
            && BeyondLockoutDuration
            && (Threshold != 0)      // Zero is a special case threshold
            && !(V1aFixed->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) )
        {
            //
            // account must be locked.
            //

            UserContext->TypeBody.User.LockoutTime = V1aFixed->LastBadPasswordTime;


            NtStatus = SampDsUpdateLockoutTime( UserContext );

            if ( !NT_SUCCESS( NtStatus ) )
            {
                NTSTATUS Status2;
                UNICODE_STRING  StringDN = {0, 0, NULL};
                PUNICODE_STRING StringPointers = &StringDN;
                PSID            Sid = NULL;

                //
                // Tell the admin we didn't lockout the account when we should
                // have
                //
                Status2 = SampGetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_ACCOUNT_NAME,
                                    FALSE,    // Don't make copy
                                    &StringDN
                                    );

                if ( !NT_SUCCESS( Status2 ) )
                {
                    RtlInitUnicodeString( &StringDN, L"" );
                }

                if ( UserContext->ObjectNameInDs->SidLen > 0 )
                {
                    Sid = &UserContext->ObjectNameInDs->Sid;
                }

                SampWriteEventLog(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SAMMSG_LOCKOUT_NOT_UPDATED,
                        Sid,
                        1,
                        sizeof( ULONG ),
                        &StringPointers,
                        &NtStatus
                        );

                NtStatus = STATUS_SUCCESS;

            }
        }
    }

    //
    // Update the state of the flag to reflect its new situation
    //


    SampUpdateAccountLockedOutFlag( UserContext,
                                    V1aFixed,
                                    &IsLocked );


    //
    // Now to return our completion value.
    // If the user was originally not locked, but now is locked
    // then we need to return TRUE to indicate a transition into
    // LOCKED occured.  Otherwise, return false to indicate we
    // did not transition into LOCKED (although we might have
    // transitioned out of LOCKED).
    //

    if (!WasLocked) {
        if (IsLocked) {
            //
            // Audit the event if necessary
            //
            {
                NTSTATUS       TempNtStatus;
                UNICODE_STRING TempMachineName, TempAccountName;

                if ( !SampDoAccountAuditing( UserContext->DomainIndex ) )
                {
                    goto AuditEnd;
                }

                TempNtStatus = SampGetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_ACCOUNT_NAME,
                                    FALSE,    // Don't make copy
                                    &TempAccountName
                                    );

                if ( !NT_SUCCESS( TempNtStatus ) )
                {
                    goto AuditEnd;
                }


                if ( !MachineName )
                {
                    RtlInitUnicodeString( &TempMachineName, L"" );
                }
                else
                {
                    RtlCopyMemory( &TempMachineName,
                                   MachineName,
                                   sizeof(UNICODE_STRING) );
                }

                //
                // Finally, audit the event
                //
                SampAuditAnyEvent(
                    UserContext,
                    STATUS_SUCCESS,
                    SE_AUDITID_ACCOUNT_AUTO_LOCKED,     // AuditId
                    SampDefinedDomains[UserContext->DomainIndex].Sid,   // Domain SID
                    NULL,                               // Additional Info
                    NULL,                               // Member Rid (not used)
                    NULL,                               // Member Sid (not used)
                    &TempAccountName,                   // Account Name
                    &TempMachineName,                   // Machine name
                    &UserContext->TypeBody.User.Rid,    // Account Rid
                    NULL,                        // Privileges used
                    NULL                         // New State Data
                    );


            AuditEnd:

                NOTHING;

            }

            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                           "UserId: 0x%x Account locked out\n",
                            V1aFixed->UserId));

            return(TRUE);
        }
    }

    return(FALSE);
}




NTSTATUS
SampDsUpdateLockoutTime(
    IN PSAMP_OBJECT AccountContext
    )
{
    return SampDsUpdateLockoutTimeEx(AccountContext,
                                     TRUE
                                     );
}

NTSTATUS
SampDsUpdateLockoutTimeEx(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      ReplicateUrgently
    )
/*++

Routine Description:

    This routine write the lockout time persistently.  If this dc is
    a primary, then the account control field is updated, too.

Arguments:

    Context - Points to the user object context block.

Return Value:

    A system service error

--*/
{
    NTSTATUS      NtStatus = STATUS_SUCCESS;
    ULONG         SamFlags = 0;
    LARGE_INTEGER LockoutTime = AccountContext->TypeBody.User.LockoutTime;

    ATTRTYP       LockoutAttrs[]={
                                    SAMP_FIXED_USER_LOCKOUT_TIME
                                 };

    ATTRVAL       LockoutValues[]={
                                    {sizeof(LockoutTime),(UCHAR *)&LockoutTime}
                                  };

    DEFINE_ATTRBLOCK1(LockoutAttrblock,LockoutAttrs,LockoutValues);

    SAMTRACE("SampDsUpdateLockoutTime");

    if (ReplicateUrgently) {
        SamFlags |= SAM_URGENT_REPLICATION;
    }


    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context
    //

    NtStatus = SampDsSetAttributes(
                    AccountContext->ObjectNameInDs,
                    SamFlags,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &LockoutAttrblock
                    );

    return(NtStatus);
}


VOID
SampUpdateAccountLockedOutFlag(
    PSAMP_OBJECT Context,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    PBOOLEAN IsLocked
    )

/*++

Routine Description:

    This routine checks to see if a user's account should
    currently be locked out.  If it should, it turns on
    the AccountLockedOut flag.  If not, it turns the flag
    off.


Arguments:

    Context - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.

    V1aFixedDirty - If any changes are made to V1aFixed, then
        V1aFixedDirty will be set to TRUE, otherwise V1aFixedDirty
        WILL NOT BE MODIFIED.

    IsState - Indicates whether the account is currently locked
        or unlocked.  A value of TRUE indicates the account is
        locked.  A value of false indicates the account is not
        locked.

Return Value:


    TRUE - the user's lockout status changed.

    FALSE - the user's lockout status did not change.


--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    USHORT
        Threshold;

    LARGE_INTEGER
        CurrentTime,
        LastBadPassword,
        LockoutDuration,
        EndOfLockout,
        TimeZero,
        LockoutTime,
        PasswordMustChange,
        MaxPasswordAge;

    BOOLEAN
        BeyondLockoutDuration;

#if DBG

    LARGE_INTEGER
        TmpTime;

    TIME_FIELDS
        AT1, AT2, AT3, DT1;
#endif //DBG



    SAMTRACE("SampUpdateAccountLockedOutFlag");

    SampDiagPrint( DISPLAY_LOCKOUT,
                   ("SAM:  UpdateAccountLockedOutFlag:  \n"
                    "\tUser account 0x%lx\n",
                   V1aFixed->UserId));

    //
    // Init some well known quantities
    //
    GetSystemTimeAsFileTime( (FILETIME *)&CurrentTime );
    RtlSecureZeroMemory( &TimeZero, sizeof( LARGE_INTEGER ) );

    Threshold =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutThreshold;

    LockoutDuration =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

    MaxPasswordAge =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.MaxPasswordAge;

    if ( IsDsObject(Context) )
    {
        //
        // In nt5, three situations can exist.
        //
        // 1) the LockoutTime is zero. To the best of our knowledge no
        //    other dc has determined that the account is locked.
        //
        // 2) the LockoutTime is non-zero and the delta between the current
        //    time and the LockoutTime is enough the user is not locked
        //    out any longer
        //
        // 3) else the LockoutTime is non-zero and the delta between the
        //    current time and the Lockout in NOT enough for the user
        //    to be free and the account remains locked.
        //

        //
        // Get some information
        //
        LockoutTime = Context->TypeBody.User.LockoutTime;

        EndOfLockout =
            SampAddDeltaTime( LockoutTime, LockoutDuration );

        BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;


        //
        // Now for some logic
        //

        if ( !SAMP_LOCKOUT_TIME_SET( Context ) )
        {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is not locked out\n") );
            //
            // There is no lockout time
            //
            V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tLeaving account unlocked\n") );
        }
        else if ( BeyondLockoutDuration )
        {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is locked out\n") );

            //
            // The user is now free
            //
            V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;

            //
            // Don't reset the BadPasswordCount, LastBadPasswordTime
            // and Account LockedOutTime. Leave them as it is right now.
            // Let us change the value of BadPasswordCount (and so on)
            // whenever client picks another BadPassword (either through
            // change password or logon).
            //

        }
        else
        {
            //
            // Ok, we have a lockout time and we have not passed the duration
            // of the window
            //
            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is locked out\n") );
            //
            // The account remains to be locked
            //
            V1aFixed->UserAccountControl |= USER_ACCOUNT_AUTO_LOCKED;

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount still locked out\n") );

        }

    }
    else
    {
        //
        // Perform old style determination
        //
        if ((V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) !=0) {

            //
            // Left locked out - do we need to unlock it?
            //

            LastBadPassword = V1aFixed->LastBadPasswordTime;
            LockoutDuration =
                SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

            EndOfLockout =
                SampAddDeltaTime( LastBadPassword, LockoutDuration );

            BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;

    #if DBG

            RtlTimeToTimeFields( &LastBadPassword,  &AT1);
            RtlTimeToTimeFields( &CurrentTime,      &AT2);
            RtlTimeToTimeFields( &EndOfLockout,     &AT3 );

            TmpTime.QuadPart = -LockoutDuration.QuadPart;
            RtlTimeToElapsedTimeFields( &TmpTime, &DT1 );

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("              Account previously locked.\n"
                            "              Current Time       : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              End of Lockout     : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              Lockout Duration   : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              LastBadPasswordTime: [0x%lx, 0x%lx] %d:%d:%d\n",
                            CurrentTime.HighPart, CurrentTime.LowPart, AT2.Hour, AT2.Minute, AT2.Second,
                            EndOfLockout.HighPart, EndOfLockout.LowPart, AT3.Hour, AT3.Minute, AT3.Second,
                            LockoutDuration.HighPart, LockoutDuration.LowPart, DT1.Hour, DT1.Minute, DT1.Second,
                            V1aFixed->LastBadPasswordTime.HighPart, V1aFixed->LastBadPasswordTime.LowPart,
                            AT1.Hour, AT1.Minute, AT1.Second)
                          );
    #endif //DBG

            if (BeyondLockoutDuration) {

                //
                // Unlock account
                //

                V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
                V1aFixed->BadPasswordCount = 0;


                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              ** unlocking account **\n") );
            } else {
                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              leaving account locked\n") );
            }

        } else {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("              Account previously not locked.\n"
                            "              BadPasswordCount:  %ld\n",
                            V1aFixed->BadPasswordCount) );

            //
            // Left in a not locked state.  Do we need to lock it?
            //

            Threshold =
                SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutThreshold;

            if (V1aFixed->BadPasswordCount >= Threshold &&
                Threshold != 0) {               // Zero is a special case threshold

                //
                // Left locked out - do we need to unlock it?
                //

                LastBadPassword = V1aFixed->LastBadPasswordTime;
                LockoutDuration =
                    SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

                EndOfLockout =
                    SampAddDeltaTime( LastBadPassword, LockoutDuration );

                BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;

                if (BeyondLockoutDuration) {

                    //
                    // account should not be locked out
                    //

                    V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
                    V1aFixed->BadPasswordCount = 0;

                    SampDiagPrint( DISPLAY_LOCKOUT,
                                   ("              ** leaving account unlocked **\n") );
                } else {

                    //
                    // account must be locked.
                    //

                    V1aFixed->UserAccountControl |= USER_ACCOUNT_AUTO_LOCKED;

                    SampDiagPrint( DISPLAY_LOCKOUT,
                                   ("              ** locking account **\n") );
                }


            } else {
                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              leaving account unlocked\n") );
            }
        }

    }

    //
    // Now return the state of the flag.
    //

    if ((V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) !=0) {

        (*IsLocked) = TRUE;
    } else {
        (*IsLocked) = FALSE;
    }

    //
    // Password expired bit, is computed, cannot be set
    // However, applications read and simply or in additional
    // user account control flags. Therefore silently mask out
    // that bit

    V1aFixed->UserAccountControl &= ~((ULONG) USER_PASSWORD_EXPIRED );

    //
    // Compute the Password expired bit
    //

    PasswordMustChange = SampGetPasswordMustChange(V1aFixed->UserAccountControl,
                                                   V1aFixed->PasswordLastSet,
                                                   MaxPasswordAge);

    if (CurrentTime.QuadPart > PasswordMustChange.QuadPart)
    {
        V1aFixed->UserAccountControl |= USER_PASSWORD_EXPIRED;
    }

    //
    // Finally, in SampAccountLockoutTestMode never actually return that
    // the account is locked out in the context.
    //
    if (SampAccountLockoutTestMode) {

        V1aFixed->UserAccountControl &= ~((ULONG) USER_ACCOUNT_AUTO_LOCKED );

    }


    return;
}


NTSTATUS
SampCheckForAccountLockout(
    IN PSAMP_OBJECT AccountContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN BOOLEAN  V1aFixedRetrieved
    )
/*++
Routine Description:

    This routine checks whether this account is currently locked out or not.

Paramenters:

    AccountContext - pointer to the object context

    V1aFixed - pointer to the Fixed Length attributes structure.

    V1aFixedRetrieved - indicate whether V1aFixed is valid or not, if not
                        This routine should fill in the fixed attributes into
                        the passed in structure

Return Values:

    STATUS_ACCOUNT_LOCKED_OUT or STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // Get fixed attributes if we are told to do so
    //

    if (!V1aFixedRetrieved)
    {
        NtStatus = SampRetrieveUserV1aFixed(
                        AccountContext,
                        V1aFixed
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            return( NtStatus );
        }
    }

    //
    // Check for account lockout
    //

    if (V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        //
        // Account has been locked
        //

        NtStatus = STATUS_ACCOUNT_LOCKED_OUT;
    }

    return( NtStatus );
}



NTSTATUS
SampDsUpdateLastLogonTimeStamp(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER LastLogon,
    IN ULONG SyncInterval
    )
/*++

Routine Description:

    This routine write the last logon time stamp persistently if necessary.

Arguments:

    Context - Points to the user object context block.

    LastLogon - New Last Logon Value

    SyncInterval - Update Interval (by days) for LastLogonTimeStamp attr

Return Value:

    A system service error

--*/
{
    NTSTATUS      NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER LastLogonTimeStamp = LastLogon;
    LARGE_INTEGER EndOfLastLogonTimeStamp;
    ATTRTYP       LastLogonTimeStampAttrs[]={ SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP };
    ATTRVAL       LastLogonTimeStampValues[]={ {sizeof(LastLogonTimeStamp),
                                                (UCHAR *)&LastLogonTimeStamp} };

    DEFINE_ATTRBLOCK1(LastLogonTimeStampAttrblock,LastLogonTimeStampAttrs,LastLogonTimeStampValues);

    SAMTRACE("SampDsUpdateLastLogonTimeStamp");


    //
    // no-op in registry mode
    //

    if (!IsDsObject(AccountContext))
    {
        return( STATUS_SUCCESS );
    }

    //
    // Check whether LastLogonTimeStamp should be updated or not.
    //

    EndOfLastLogonTimeStamp = SampCalcEndOfLastLogonTimeStamp(
                                    AccountContext->TypeBody.User.LastLogonTimeStamp,
                                    SyncInterval
                                    );

    if (EndOfLastLogonTimeStamp.QuadPart > LastLogon.QuadPart)
    {
        return( STATUS_SUCCESS );
    }

    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context
    //

    NtStatus = SampDsSetAttributes(
                    AccountContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &LastLogonTimeStampAttrblock
                    );

    //
    // Update the in-memory copy
    //
    if (NT_SUCCESS(NtStatus))
    {
        AccountContext->TypeBody.User.LastLogonTimeStamp = LastLogon;
    }

    return(NtStatus);
}


NTSTATUS
SampDsLookupObjectByAlternateId(
    IN PDSNAME DomainRoot,
    IN ULONG AttributeId,
    IN PUNICODE_STRING AlternateId,
    OUT PDSNAME *Object
    )

/*++

Routine Description:

    This routine assembles a DS attribute block based on the AlternateId
    value and searches the DS for a unique instance of the record, which
    is returned in the Object parameter.

    // BUG: Move this routine to dslayer.c after the technology preview.

Arguments:

    DomainRoot - Pointer, starting point (container) in the name space for
        the search.

    AlternateId - Pointer, unicode string containing the alternative user
        identifier.

    Object - Pointer, returned DS object matching the ID.

Return Value:

    STATUS_SUCCESS - Object was found, otherwise not found.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ATTR Attr;

    SAMTRACE("SampDsLookupObjectByAlternateId");

    RtlSecureZeroMemory(&Attr, sizeof(ATTR));


    // Attr.attrTyp = SampDsAttrFromSamAttr(SampUnknownObjectType,
    //                                      ???);

    Attr.attrTyp = AttributeId;
    Attr.AttrVal.valCount = 1;

    // Perform lazy thread and transaction initialization.

    NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);

    SampSetDsa(TRUE);

    Attr.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

    if (NULL != Attr.AttrVal.pAVal)
    {

        //
        // Build a unicode string search attribute
        //

        Attr.AttrVal.pAVal->valLen = AlternateId->Length;
        Attr.AttrVal.pAVal->pVal = (PUCHAR)(AlternateId->Buffer);


        NtStatus = SampDsDoUniqueSearch(0, DomainRoot, &Attr, Object);

    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    // Turn the fDSA flag back on, as in loopback cases this can get reset
    // to FALSE.

    SampSetDsa(TRUE);

    return(NtStatus);
}

NTSTATUS
SamIOpenUserByAlternateId(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE *UserHandle
    )

/*++

Routine Description:

    This routine returns a SAM handle to a user object based on its alter-
    nate security identifier.

Arguments:

    DomainHandle - Handle, open SAM domain context.

    DesiredAccess - Access level requested.

    AlternateId - Pointer, unicode string containing the alternative user
        identifier.

    UserHandle - Pointer, returned handle to an open SAM user object.

Return Value:

    STATUS_SUCCESS - Object was found and opened, otherwise it could not
        be found or opened. If failed, the UserHandle returned will have
        value zero (or what SamrOpenUser sets it to for failure).

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PDSNAME DomainRoot = NULL;
    PDSNAME Object = NULL;
    ULONG UserRid = 0;

    SAMTRACE("SamIOpenUserByAlternateId");

    // Finds an account with AlternateId in the ALTERNATE_SECURITY_IDENTITIES,
    // returning a SAM handle good for calling SamrGetGroupsForUser()

    if ((NULL != DomainHandle) &&
        (NULL != AlternateId) &&
        (NULL != UserHandle))
    {
        PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;

        ASSERT(IsDsObject(DomainContext));

        DomainRoot = DomainContext->ObjectNameInDs;

        SampAcquireReadLock();

        if (NULL != DomainRoot)
        {
            NtStatus = SampDsLookupObjectByAlternateId(DomainRoot,
                                                       ATT_ALT_SECURITY_IDENTITIES,
                                                       AlternateId,
                                                       &Object);

            if (NT_SUCCESS(NtStatus))
            {
                ASSERT(NULL != Object);

                // Extract the user's Rid from the Sid.

                NtStatus = SampSplitSid(&(Object->Sid), NULL, &UserRid);

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SamrOpenUser(DomainHandle,
                                            DesiredAccess,
                                            UserRid,
                                            UserHandle);
                }

                MIDL_user_free(Object);
            }
        }

        SampReleaseReadLock();
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}

NTSTATUS
SampFlagsToAccountControl(
    IN ULONG Flags,
    OUT PULONG UserAccountControl
    )
/*++

    Routine Description:

        Transalates from UF Values to User Account Control

    Parameters:

        Flags Specifies the UF Flags Value

        UserAccountControl - Specifies the User account control value

   Return Values:

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    *UserAccountControl=0;


    if (Flags & UF_ACCOUNTDISABLE) {
        (*UserAccountControl) |= USER_ACCOUNT_DISABLED;
    }

    if (Flags & UF_HOMEDIR_REQUIRED) {
        (*UserAccountControl) |= USER_HOME_DIRECTORY_REQUIRED;
    }

    if (Flags & UF_PASSWD_NOTREQD) {
        (*UserAccountControl) |= USER_PASSWORD_NOT_REQUIRED;
    }

    if (Flags & UF_DONT_EXPIRE_PASSWD) {
        (*UserAccountControl) |= USER_DONT_EXPIRE_PASSWORD;
    }

    if (Flags & UF_LOCKOUT) {
        (*UserAccountControl) |= USER_ACCOUNT_AUTO_LOCKED;
    }

    if (Flags & UF_MNS_LOGON_ACCOUNT) {
        (*UserAccountControl) |= USER_MNS_LOGON_ACCOUNT;
    }

     if (Flags & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED) {
        (*UserAccountControl) |= USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }

    if (Flags & UF_SMARTCARD_REQUIRED) {
        (*UserAccountControl) |= USER_SMARTCARD_REQUIRED;
    }

    if (Flags & UF_TRUSTED_FOR_DELEGATION) {
        (*UserAccountControl) |= USER_TRUSTED_FOR_DELEGATION;
    }

    if (Flags & UF_NOT_DELEGATED) {
        (*UserAccountControl) |= USER_NOT_DELEGATED;
    }

    if (Flags & UF_USE_DES_KEY_ONLY) {
        (*UserAccountControl) |= USER_USE_DES_KEY_ONLY;
    }

    if (Flags & UF_DONT_REQUIRE_PREAUTH) {
        (*UserAccountControl) |= USER_DONT_REQUIRE_PREAUTH;
    }

    if (Flags & UF_PASSWORD_EXPIRED) {
        (*UserAccountControl) |= USER_PASSWORD_EXPIRED;
    }
    if (Flags & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
        (*UserAccountControl) |= USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
    }

    //
    // Set the account type bit.
    //
    // If no account type bit is set in user specified flag,
    //  then leave this bit as it is.
    //

    if( Flags & UF_ACCOUNT_TYPE_MASK )
    {
        ULONG NewSamAccountType;
        ULONG AccountMask;

        //
        // Check that exactly one bit is set
        //

        AccountMask = Flags & UF_ACCOUNT_TYPE_MASK;
        // Right Shift Till Account Mask's LSB is set
        while (0==(AccountMask & 0x1))
            AccountMask = AccountMask >>1;

        // If Exactly one bit is set then the value of
        // account mask is exactly one

        if (0x1!=AccountMask)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Determine what the new account type should be.
        //

        if ( Flags & UF_TEMP_DUPLICATE_ACCOUNT ) {
            NewSamAccountType = USER_TEMP_DUPLICATE_ACCOUNT;

        } else if ( Flags & UF_NORMAL_ACCOUNT ) {
            NewSamAccountType = USER_NORMAL_ACCOUNT;

        } else if ( Flags & UF_INTERDOMAIN_TRUST_ACCOUNT){
            NewSamAccountType = USER_INTERDOMAIN_TRUST_ACCOUNT;

        } else if ( Flags & UF_WORKSTATION_TRUST_ACCOUNT){
            NewSamAccountType = USER_WORKSTATION_TRUST_ACCOUNT;

        } else if ( Flags & UF_SERVER_TRUST_ACCOUNT ) {
            NewSamAccountType = USER_SERVER_TRUST_ACCOUNT;

        } else {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Use the new Account Type.
        //

        (*UserAccountControl) |= NewSamAccountType;

    //
    //  If none of the bits are set,
    //      set USER_NORMAL_ACCOUNT.
    //
    }
    else
    {
        (*UserAccountControl) |= USER_NORMAL_ACCOUNT;
    }

Error:

    return NtStatus;

}

ULONG
SampAccountControlToFlags(
    IN ULONG UserAccountControl
    )
/*++

    Routine Description:

        Transalates from User Account control to UF Values

    Parameters:

        UserAccountControl Specifies the User account control value

   Return Values:

        UF Flags
--*/
{
    ULONG Flags=0;

    //
    // Set all other bits as a function of the SAM UserAccountControl
    //

    if ( UserAccountControl & USER_ACCOUNT_DISABLED ) {
        Flags |= UF_ACCOUNTDISABLE;
    }
    if ( UserAccountControl & USER_HOME_DIRECTORY_REQUIRED ){
        Flags |= UF_HOMEDIR_REQUIRED;
    }
    if ( UserAccountControl & USER_PASSWORD_NOT_REQUIRED ){
        Flags |= UF_PASSWD_NOTREQD;
    }
    if ( UserAccountControl & USER_DONT_EXPIRE_PASSWORD ){
        Flags |= UF_DONT_EXPIRE_PASSWD;
    }
    if ( UserAccountControl & USER_ACCOUNT_AUTO_LOCKED ){
        Flags |= UF_LOCKOUT;
    }
    if ( UserAccountControl & USER_MNS_LOGON_ACCOUNT ){
        Flags |= UF_MNS_LOGON_ACCOUNT;
    }
    if ( UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED ){
        Flags |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }
    if ( UserAccountControl & USER_SMARTCARD_REQUIRED ){
        Flags |= UF_SMARTCARD_REQUIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_FOR_DELEGATION ){
        Flags |= UF_TRUSTED_FOR_DELEGATION;
    }
    if ( UserAccountControl & USER_NOT_DELEGATED ){
        Flags |= UF_NOT_DELEGATED;
    }
    if ( UserAccountControl & USER_USE_DES_KEY_ONLY ){
        Flags |= UF_USE_DES_KEY_ONLY;
    }
    if ( UserAccountControl & USER_DONT_REQUIRE_PREAUTH) {
        Flags |= UF_DONT_REQUIRE_PREAUTH;
    }
    if ( UserAccountControl & USER_PASSWORD_EXPIRED) {
        Flags |= UF_PASSWORD_EXPIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
        Flags |= UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
    }

    //
    // set account type bit.
    //

    //
    // account type bit are exculsive and precisely only one
    // account type bit is set. So, as soon as an account type bit is set
    // in the following if sequence we can return.
    //


    if( UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT ) {
        Flags |= UF_TEMP_DUPLICATE_ACCOUNT;

    } else if( UserAccountControl & USER_NORMAL_ACCOUNT ) {
        Flags |= UF_NORMAL_ACCOUNT;

    } else if( UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
        Flags |= UF_INTERDOMAIN_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT ) {
        Flags |= UF_WORKSTATION_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_SERVER_TRUST_ACCOUNT ) {
        Flags |= UF_SERVER_TRUST_ACCOUNT;

    } else {
        //
        // There is no known account type bit set in UserAccountControl.
        // ?? Flags |= UF_NORMAL_ACCOUNT;

        ASSERT(FALSE && "No Account Type Flag set in User Account Control");
    }

    return Flags;
}

NTSTATUS
SampEnforceDefaultMachinePassword(
    PSAMP_OBJECT AccountContext,
    PUNICODE_STRING NewPassword,
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo
    )
/*++

    This routine checks to see if the machine account's password
    is the same as the default machine account password. This routine
    references the current transaction domain.

    Parameters

        AccountContext -- Pointer to the SAM context
        NewPassword    -- points to the clear text password

    Return Values

        STATUS_SUCCESS
        STATUS_PASSWORD_RESTRICTION
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING AccountName;

    NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext,
                    SAMP_USER_ACCOUNT_NAME,
                    FALSE, // Make Copy
                    &AccountName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // The default machine password is same as the machine name minus the $ sign
        //

        AccountName.Length-=sizeof(WCHAR); // assume last char is the dollar sign

        if ((DomainPasswordInfo->PasswordProperties
                & DOMAIN_REFUSE_PASSWORD_CHANGE)
                && (!RtlEqualUnicodeString(&AccountName,NewPassword,TRUE)))
        {
            //
            // If refuse password change is set then disallow any machine
            // passwords other than default.
            //

            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    return NtStatus;
}




NTSTATUS
SamIGetInterdomainTrustAccountPasswordsForUpgrade(
   IN ULONG AccountRid,
   OUT PUCHAR NtOwfPassword,
   OUT BOOLEAN *NtPasswordPresent,
   OUT PUCHAR LmOwfPassword,
   OUT BOOLEAN *LmPasswordPresent
   )
/*++

    Routine Description

    This routine gets the NT and LM OWF passwords from the account
    with the specified RID during an NT4 upgrade. This routine can
    be called by inprocess clients only

    Parameters

    AccountRid  -- Specifies the RID of the account
    NtOwfPassword -- Buffer in which the NT owf password is returned
    NtPasswordPresent -- Boolean indicates that the NT password is present
    LmOwfPassword    -- Buffer in which the LM owf password is returned
    LmPasswordPresetn -- Indicates that the LM password is present

    Return Values

    STATUS_SUCCESS
    Other Error Codes

--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PDSNAME      DomainDn=NULL;
    ULONG        Length = 0;
    PDSNAME      AccountDn= NULL;
    ATTRBLOCK    ResultAttrs;
    ATTRTYP      PasswdAttrs[]={
                                        SAMP_USER_UNICODE_PWD,
                                        SAMP_USER_DBCS_PWD
                                   };
    ATTRVAL      PasswdValues[]={ {0,NULL}, {0,NULL}};

    DEFINE_ATTRBLOCK2(PasswdAttrblock,PasswdAttrs,PasswdValues);
    ULONG        i;
    ULONG        CryptIndex = AccountRid;

    *NtPasswordPresent = FALSE;
    *LmPasswordPresent = FALSE;

    //
    // Get the root domain
    //

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                            &Length,
                            NULL
                            );


    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(DomainDn,Length );
        if (NULL!=DomainDn)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &Length,
                                            DomainDn
                                            );

            ASSERT(NT_SUCCESS(NtStatus));
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Begin a transaction if required
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Lookup the account by RID
    //

    NtStatus = SampDsLookupObjectByRid(
                    DomainDn,
                    AccountRid,
                    &AccountDn
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Now read the account
    //

    NtStatus = SampDsRead(
                    AccountDn,
                    0,
                    SampUserObjectType,
                    &PasswdAttrblock,
                    &ResultAttrs
                    );

    if ( STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus ) {

        //
        // Neither passwords are present? Return, saying neither are
        // present
        //
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    for (i=0;i<ResultAttrs.attrCount;i++)
    {
        if ((ResultAttrs.pAttr[i].attrTyp == SAMP_USER_UNICODE_PWD)
            && (1==ResultAttrs.pAttr[i].AttrVal.valCount)
            && (NT_OWF_PASSWORD_LENGTH==ResultAttrs.pAttr[i].AttrVal.pAVal[0].valLen))

        {
            *NtPasswordPresent = TRUE;
            NtStatus = RtlDecryptNtOwfPwdWithIndex(
                            (PENCRYPTED_NT_OWF_PASSWORD)ResultAttrs.pAttr[i].AttrVal.pAVal[0].pVal,
                             &CryptIndex,
                            (PNT_OWF_PASSWORD) NtOwfPassword
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }
        else  if ((ResultAttrs.pAttr[i].attrTyp == SAMP_USER_DBCS_PWD)
            && (1==ResultAttrs.pAttr[i].AttrVal.valCount)
            && (LM_OWF_PASSWORD_LENGTH==ResultAttrs.pAttr[i].AttrVal.pAVal[0].valLen))
        {
            *LmPasswordPresent = TRUE;
            NtStatus = RtlDecryptLmOwfPwdWithIndex(
                            (PENCRYPTED_LM_OWF_PASSWORD)ResultAttrs.pAttr[i].AttrVal.pAVal[0].pVal,
                             &CryptIndex,
                            (PLM_OWF_PASSWORD) LmOwfPassword
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;


        }
    }


Error:

    //
    // Cleanup any existing transaction
    //

    if (NULL!=AccountDn)
        MIDL_user_free(AccountDn);

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);

}

NTSTATUS
SampSetPasswordUpdateOnContext(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING ClearPassword
    )
/*++

Routine Description

    Given a pointer to the domain, the user context and the clear password,
    this routine saves the clear password in the context so that
    when the DS updates this value, SAM will be notified of the change
    and construct the supplemental credentials configured packages
    require.

Parameters

        Domain  -- Pointer to the domain to check policy etc
        UserContext -- Pointer to the user context
        ClearPassword -- Unicode string specifying the clear password

Return Values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    USHORT Length;
    PSAMP_PASSWORD_UPDATE_INFO PasswordUpdateInfo;

    //
    // If we are in registry mode, simply return success
    //
    if (!IsDsObject(UserContext)) {

        return STATUS_SUCCESS;
    }

    //
    // Free any existing value
    //
    if (UserContext->TypeBody.User.PasswordInfo.Buffer != NULL) {
        
        RtlSecureZeroMemory(UserContext->TypeBody.User.PasswordInfo.Buffer, 
                      UserContext->TypeBody.User.PasswordInfo.Length);
        
        MIDL_user_free(UserContext->TypeBody.User.PasswordInfo.Buffer);

        RtlSecureZeroMemory(&UserContext->TypeBody.User.PasswordInfo, 
                      sizeof(UNICODE_STRING));
    }

    //
    // Construct the new value
    //
    Length = sizeof(SAMP_PASSWORD_UPDATE_INFO);
    if (ARGUMENT_PRESENT(ClearPassword)) {
        Length += ClearPassword->Length + RTL_ENCRYPT_MEMORY_SIZE;
    }
    PasswordUpdateInfo = MIDL_user_allocate(Length);
    if (NULL == PasswordUpdateInfo) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlSecureZeroMemory(PasswordUpdateInfo, Length);

    if (ARGUMENT_PRESENT(ClearPassword)) {
        PasswordUpdateInfo->ClearPresent = TRUE;
        PasswordUpdateInfo->DataLength = ClearPassword->Length;
        PasswordUpdateInfo->DataMaximumLength = ClearPassword->Length +
                                                (RTL_ENCRYPT_MEMORY_SIZE -
                                                (ClearPassword->Length % RTL_ENCRYPT_MEMORY_SIZE));

        RtlCopyMemory(&(PasswordUpdateInfo->Data[0]),
                      ClearPassword->Buffer,
                      ClearPassword->Length);

        NtStatus = RtlEncryptMemory(&(PasswordUpdateInfo->Data[0]),
                                    PasswordUpdateInfo->DataMaximumLength,
                                    0);

        if (!NT_SUCCESS(NtStatus)) {
            goto Exit;
        }
    }

    //
    // Put the value on the context
    //
    UserContext->TypeBody.User.PasswordInfo.Length =
        UserContext->TypeBody.User.PasswordInfo.MaximumLength =
            Length;
    UserContext->TypeBody.User.PasswordInfo.Buffer = (WCHAR*)PasswordUpdateInfo;
    PasswordUpdateInfo = NULL;

Exit:

    if (PasswordUpdateInfo) {
        MIDL_user_free(PasswordUpdateInfo);
    }

    return NtStatus;
}

NTSTATUS
SamIUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    )
/*++

Routine Description:

    This routine updates the logon statistics for a user after a logon request.
    The logon request could have either failed or succeeded.

Parameters:

    UserHandle - the handle of an opened user to operate on.

    LogonStats - the result of the logon attempt

Return Values:

    STATUS_SUCCESS, resource error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT AccountContext = (PSAMP_OBJECT) UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed;
    ULONG ObjectRid;
    BOOLEAN AccountLockedOut = FALSE;
    BOOLEAN ReplicateImmediately = FALSE;

    BOOLEAN fReferencedContext = FALSE;
    BOOLEAN fLockAcquired      = FALSE;
    BOOLEAN TellNetlogon       = FALSE;
    BOOLEAN FlushOnlyLogonProperties = FALSE;
    GUID                    UserGuidToReplicateLocally = {0};
    GUID                    NullGuid = {0};

#if DBG

    TIME_FIELDS
        T1;

#endif //DBG

    RtlSecureZeroMemory(&V1aFixed, sizeof(V1aFixed));

    //
    // Parameter check
    //
    if ( (AccountContext == NULL) ||
         (LogonStats == NULL) ) {

        return STATUS_INVALID_PARAMETER;
    }
    ASSERT(AccountContext->TrustedClient);

    //
    // Acquire the lock, if necessary
    //
    if (   !AccountContext->NotSharedByMultiThreads
        || !IsDsObject(AccountContext) ) {

        NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        //
        // Perform a lookup context, for non thread safe context's
        //
        NtStatus = SampLookupContext(
                        AccountContext,
                        0,                      // No access necessary
                        SampUserObjectType,     // ExpectedType
                        &FoundType
                        );
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        ASSERT(FoundType == SampUserObjectType);
        fReferencedContext = TRUE;

    } else {

        //
        // For a thread safe context, writing just logon
        // statistics , just reference the context
        //
        SampReferenceContext(AccountContext);
        fReferencedContext = TRUE;
    }
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Extract the fixed attributes for analysis
    //
    NtStatus = SampRetrieveUserV1aFixed(
                   AccountContext,
                   &V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Attach the client info, to the context
    //
    AccountContext->TypeBody.User.ClientInfo = LogonStats->ClientInfo;


    //
    // Extract the RID
    //
    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // There are two ways to set logon/logoff statistics:
    //
    //      1) Directly, specifying each one being set,
    //      2) Implicitly, specifying the action to
    //         represent
    //
    // These two forms are mutually exclusive.  That is,
    // you can't specify both a direct action and an
    // implicit action.  In fact, you can't specify two
    // implicit actions either.
    //

    if (LogonStats->StatisticsToApply
        & USER_LOGON_INTER_SUCCESS_LOGON) {

        //
        // Set BadPasswordCount = 0
        // Increment LogonCount
        // Set LastLogon = NOW
        // Reset the locked out time
        //
        //

        if (V1aFixed.BadPasswordCount != 0) {

            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                           "UserId: 0x%x Successful interactive logon, clearing badPwdCount\n",
                            V1aFixed.UserId));
        }

        V1aFixed.BadPasswordCount = 0;
        if (V1aFixed.LogonCount != 0xFFFF) {
            V1aFixed.LogonCount += 1;
        }

        GetSystemTimeAsFileTime( (FILETIME *) &V1aFixed.LastLogon );

        if ( IsDsObject( AccountContext ) )
        {
            if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
            {
                RtlSecureZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );

                NtStatus = SampDsUpdateLockoutTime( AccountContext );
                if ( !NT_SUCCESS( NtStatus ) )
                {
                    goto Cleanup;
                }

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                               "UserId: 0x%x Successful interactive logon, unlocking account\n",
                                V1aFixed.UserId));
            }
        }

        FlushOnlyLogonProperties=TRUE;
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_INTER_SUCCESS_LOGOFF) {
        if ( (LogonStats->StatisticsToApply
                 & ~USER_LOGON_INTER_SUCCESS_LOGOFF)  != 0 ) {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        } else {

            //
            // Set LastLogoff time
            // Decrement LogonCount (don't let it become negative)
            //

            if (V1aFixed.LogonCount != 0) {
                V1aFixed.LogonCount -= 1;
            }
            GetSystemTimeAsFileTime( (FILETIME *) &V1aFixed.LastLogoff );
            FlushOnlyLogonProperties=TRUE;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_NET_SUCCESS_LOGON) {

        //
        // Set BadPasswordCount = 0
        // Set LastLogon = NOW
        // Clear the locked time
        //
        //
        //
        if (V1aFixed.BadPasswordCount != 0) {

            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                           "UserId: 0x%x Successful network logon, clearing badPwdCount\n",
                            V1aFixed.UserId));
        }

        V1aFixed.BadPasswordCount = 0;
        GetSystemTimeAsFileTime( (FILETIME *) &V1aFixed.LastLogon );

        if ( IsDsObject( AccountContext ) )
        {
            if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
            {
                RtlSecureZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );
                NtStatus = SampDsUpdateLockoutTime( AccountContext );
                if ( !NT_SUCCESS( NtStatus ) )
                {
                    goto Cleanup;
                }

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                                "UserId: 0x%x Successful network logon, unlocking account\n",
                                V1aFixed.UserId));
            }
        }

        FlushOnlyLogonProperties=TRUE;
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_NET_SUCCESS_LOGOFF) {
        if ( (LogonStats->StatisticsToApply
                 & ~USER_LOGON_NET_SUCCESS_LOGOFF)  != 0 ) {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        } else {

            //
            // Set LastLogoff time
            //

            GetSystemTimeAsFileTime( (FILETIME *) &V1aFixed.LastLogoff );
            FlushOnlyLogonProperties=TRUE;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_BAD_PASSWORD) {

        PUNICODE_STRING TempMachineName = NULL;

        //
        // Increment BadPasswordCount
        // (might lockout account)
        //

        //
        // Get the wksta name if provided
        //
        if ((LogonStats->StatisticsToApply & USER_LOGON_BAD_PASSWORD_WKSTA) != 0) {
            TempMachineName = &LogonStats->Workstation;
        }

        AccountLockedOut =
            SampIncrementBadPasswordCount(
                AccountContext,
                &V1aFixed,
                TempMachineName
                );

        //
        // If the account has been locked out,
        //  ensure the BDCs in the domain are told.
        //

        if ( AccountLockedOut ) {
            TellNetlogon = TRUE;
            ReplicateImmediately = TRUE;
        }
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LAST_LOGON ) {

        V1aFixed.LastLogon = LogonStats->LastLogon;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LAST_LOGOFF ) {

        V1aFixed.LastLogoff = LogonStats->LastLogoff;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_BAD_PWD_COUNT ) {

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: 0x%x Setting BadPasswordCount %d\n",
                        V1aFixed.UserId,
                        LogonStats->BadPasswordCount));

        V1aFixed.BadPasswordCount =
            LogonStats->BadPasswordCount;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LOGON_COUNT ) {

        V1aFixed.LogonCount = LogonStats->LogonCount;
    }

    if ( IsDsObject(AccountContext)
     && (LogonStats->StatisticsToApply & USER_LOGON_PDC_RETRY_SUCCESS)) {


        //
        // Replicate the object down locally from the PDC. Delay
        // the queueing of the request until this write operation
        // is done to avoid write conflicts.
        //
        ASSERT(AccountContext->ObjectNameInDs);
        RtlCopyMemory(&UserGuidToReplicateLocally,
                      &AccountContext->ObjectNameInDs->Guid,
                      sizeof(GUID));
    }


    //
    // Write the changes
    //

    if ((FlushOnlyLogonProperties)
            && (IsDsObject(AccountContext)))
    {
        //
        // If it is the DS case and we are only doing a successful
        // logon or logoff, just flush the last logon, last logoff,
        // logon count and bad password count properties. Note the
        // value in the on disk structure in AccountContext will now
        // be stale, but SetInformationUser is the last operation
        // during a logon. Therefore it should not matter.
        //
        NtStatus = SampDsSuccessfulLogonSet(
                        AccountContext,
                        LogonStats->StatisticsToApply,
                        SampDefinedDomains[AccountContext->DomainIndex].LastLogonTimeStampSyncInterval,
                        &V1aFixed
                        );
    }
    else if (IsDsObject(AccountContext))
    {
        //
        // Set the bad password count and bad password time. Note the
        // value in the on disk structure in AccountContext will now
        // be stale, but SetInformationUser is the last operation
        // during a logon. Therefore it should not matter.
        //

        //
        // This path also updates the site affinity if no GC
        // is present.
        //
        NtStatus = SampDsFailedLogonSet(
                        AccountContext,
                        LogonStats->StatisticsToApply,
                        &V1aFixed
                        );
    }
    else
    {
        //
        // Registry Mode, set the entire V1aFixed Structure
        //

        NtStatus = SampReplaceUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );
    }

    //
    // That's it -- fall through the Cleanup
    //

Cleanup:

    //
    // Release the context
    //
    if (fReferencedContext) {

        NTSTATUS Status2;
        Status2 = SampDeReferenceContext( AccountContext, NT_SUCCESS(NtStatus) );
        if (!NT_SUCCESS(Status2) && NT_SUCCESS(NtStatus)) {
            NtStatus = Status2;
        }

    } else {

        ASSERT(!NT_SUCCESS(NtStatus) && "No context referenced");
    }

    //
    // Commit the changes
    //
    if (fLockAcquired) {

        if (NT_SUCCESS(NtStatus)) {

            if (( !TellNetlogon ) && (!IsDsObject(AccountContext))) {

                 //
                 // For logon statistics, we don't notify netlogon about changes
                 // to the database.  Which means that we don't want the
                 // domain's modified count to increase.  The commit routine
                 // will increase it automatically if this isn't a BDC, so we'll
                 // decrement it here.
                 //

                 if (SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole != DomainServerRoleBackup) {

                     SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart-1;
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart-1;
                 }
            }

            NtStatus = SampCommitAndRetainWriteLock();

            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Something in the account was changed.  Notify netlogon about
                // everything except logon statistics changes.
                //

                if ( TellNetlogon ) {

                    SAM_DELTA_DATA DeltaData;
                    SECURITY_DB_DELTA_TYPE  DeltaType = SecurityDbChange;

                    DeltaData.AccountControl = V1aFixed.UserAccountControl;

                    SampNotifyNetlogonOfDelta(
                        DeltaType,
                        SecurityDbObjectSamUser,
                        ObjectRid,
                        (PUNICODE_STRING) NULL,
                        (DWORD) ReplicateImmediately,
                        &DeltaData // Delta data
                        );
                }
            }
        }

         //
         // Release the lock
         //

         IgnoreStatus = SampReleaseWriteLock( FALSE );
         ASSERT(NT_SUCCESS(IgnoreStatus));

     } else {

         //
         // Commit for the thread safe context case
         //
         ASSERT(IsDsObject(AccountContext));
         if (NT_SUCCESS(NtStatus)) {

            SampMaybeEndDsTransaction(TransactionCommit);
         } else {

            SampMaybeEndDsTransaction(TransactionAbort);
         }
     }


    //
    // If we were notified of an account that needs to replicated locally
    // queue a request to do so
    //
    if (!IsEqualGUID(&UserGuidToReplicateLocally, &NullGuid)) {
    
        SampQueueReplicationRequest(&UserGuidToReplicateLocally);

    }

    return NtStatus;
}

VOID
SampGetRequestedAttributesForUser(
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN ULONG WhichFields,
    OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine Description:

    This routine sets in AttributeAccessTable the requested attributes
    determined by both the UserInformationClass or the WhichFields, if any.

Parameters:

    UserInformationClass -- the information level

    WhichFields -- which fields of the UserAllInformation are requested

    AttributeAccessTable -- a bitmask of attributes

Return Values:

    None.

--*/
{
    ULONG LocalWhichFields = 0;

    switch (UserInformationClass) {

    case UserPreferencesInformation:

        LocalWhichFields |= USER_ALL_USERCOMMENT |
                            USER_ALL_COUNTRYCODE |
                            USER_ALL_CODEPAGE;
        break;

    case UserParametersInformation:

        LocalWhichFields |= USER_ALL_PARAMETERS;
        break;

    case UserLogonHoursInformation:

        LocalWhichFields |= USER_ALL_LOGONHOURS;
        break;

    case UserNameInformation:

        LocalWhichFields |= USER_ALL_USERNAME | USER_ALL_FULLNAME;
        break;

    case UserAccountNameInformation:

        LocalWhichFields |= USER_ALL_USERNAME;
        break;

    case UserFullNameInformation:

        LocalWhichFields |= USER_ALL_FULLNAME;
        break;

    case UserPrimaryGroupInformation:

        LocalWhichFields |= USER_ALL_PRIMARYGROUPID;
        break;

    case UserHomeInformation:

        LocalWhichFields |=  USER_ALL_HOMEDIRECTORY | USER_ALL_HOMEDIRECTORYDRIVE;
        break;

    case UserScriptInformation:

        LocalWhichFields |= USER_ALL_SCRIPTPATH;
        break;

    case UserProfileInformation:

        LocalWhichFields |= USER_ALL_PROFILEPATH;
        break;

    case UserAdminCommentInformation:

        LocalWhichFields |= USER_ALL_ADMINCOMMENT;
        break;

    case UserWorkStationsInformation:

        LocalWhichFields |= USER_ALL_WORKSTATIONS;
        break;
    case UserControlInformation:

        LocalWhichFields |= USER_ALL_USERACCOUNTCONTROL;
        break;

    case UserExpiresInformation:
        LocalWhichFields |= USER_ALL_ACCOUNTEXPIRES;
        break;

    default:
        //
        // Extract whatever fields were passed in
        //
        LocalWhichFields |= (WhichFields & USER_ALL_WRITE_ACCOUNT_MASK) |
                            (WhichFields & USER_ALL_WRITE_PREFERENCES_MASK);
    }

    SampSetAttributeAccessWithWhichFields(LocalWhichFields,
                                          AttributeAccessTable);

    return;
}


NTSTATUS
SampValidatePresentAndStoredCombination(
    IN BOOLEAN NtPresent,
    IN BOOLEAN LmPresent,
    IN BOOLEAN StoredNtPasswordPresent,
    IN BOOLEAN StoredNtPasswordNonNull,
    IN BOOLEAN StoredLmPasswordNonNull
    )
/*++

Routine Description:

    This routine determines if the combination of passed in values
    and stored values are allowed.

    Thoery:  There are 32 different combinations of the above variables.  The
    following aren't interesting:

        if (!NtPresent
         && !LmPresent  )
         // invalid parameters from client

        if (!StoredNtPasswordPresent
         && StoredNtPasswordNonNull  )
         // can't have a non-NULL password and not be present

        if ( StoredNtPasswordPresent
         && !StoredNtPasswordNonNull
         &&  StoredLmPasswordNonNull   )
         // can't have a non-NULL LM password, but a present NT NULL password

This leaves 15 remaining cases -- see implementation for details.

Parameters:

    NtPresent -- the caller presented an NT OWF of the password

    LmPresent -- the caller presented an LM OWF of the password

    StoredNtPasswordPresent -- the NT OWF of the password is stored

    StoredNtPasswordNonNull -- the account's password is non NULL

    StoredLmPasswordNonNull -- the account's password is non NULL or
                               the LM OWF is not stored.

Return Values:

    STATUS_SUCCESS

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED -- the password necessary to validate
                                           the change is not sufficient.

--*/
{

    //
    // Assert for the uninteresting cases first
    //
    ASSERT(  NtPresent
          || LmPresent);

    ASSERT(StoredNtPasswordPresent
       || !StoredNtPasswordNonNull);

    ASSERT( !StoredNtPasswordPresent
         ||  StoredNtPasswordNonNull
         || !StoredLmPasswordNonNull);

    //
    // Now for the interesting cases
    //

    if (!NtPresent
     &&  LmPresent
     &&  StoredNtPasswordPresent
     && StoredNtPasswordNonNull
     && !StoredLmPasswordNonNull  ) {

        // We have a non-NULL password, the LM password is NULL, and
        // only the LM is given.  This is not enough information.
        // set the return code to STATUS_WRONG_PASSWORD, so that client
        // won't get a chance to know a non-null NT hash exists.
        return STATUS_WRONG_PASSWORD;
    }

    if ( NtPresent
     && !LmPresent
     && !StoredNtPasswordPresent
     && StoredLmPasswordNonNull ) {

        // We have a non-NULL LM password, but only the NT is provided.
        // This is not enough information.
        // set the return code to STATUS_WRONG_PASSWORD, so that client
        // won't get a chance to know a non-null LM hash exists.
        return STATUS_WRONG_PASSWORD;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SampCopyA2D2Attribute(
    IN PUSER_ALLOWED_TO_DELEGATE_TO_LIST Src,
    OUT PUSER_ALLOWED_TO_DELEGATE_TO_LIST *Dest
    )
{
    ULONG i;

    *Dest = MIDL_user_allocate(Src->Size);
    if (NULL==*Dest)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Copy the data
    //

    RtlCopyMemory(*Dest,Src,Src->Size);


    //
    // Fixup the pointers
    //

    for (i=0;i<(*Dest)->NumSPNs;i++)
    {
       ULONG_PTR Offset = (ULONG_PTR) Src->SPNList[i].Buffer - (ULONG_PTR)Src;

       (ULONG_PTR) (*Dest)->SPNList[i].Buffer = (ULONG_PTR) (*Dest)+Offset;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
SampRestrictAndRandomizeKrbtgtPassword(
    IN PSAMP_OBJECT        AccountContext,
    IN OUT PUNICODE_STRING ClearTextPassword,
    IN OUT PNT_OWF_PASSWORD NtOwf,
    IN OUT PLM_OWF_PASSWORD LmOwf,
    IN OUT BOOLEAN * LmPresent,
    OUT PUNICODE_STRING     UpdatedClearPassword,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType
    )
/*++

   This routine checks if the account context describes
   a user context for the krbtgt account and if so then
   computes a new random clear password

   Parameters:

    AccountContext -- Context to the account
    ClearTextPassword -- If it is the krbtgt account then
                         the password is altered in here
    FreeOldPassword -- boolean out parameter .. indicates that
                       the old password needs to be freed.
    FreeRandomizedPassword -- Indicates that memory was alloc'd
                       for the randomized password that needs
                       to be freed.

    CallerType  -- Indicates if this is a change/reset/ or push
                   password to PDC
*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    if ((AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT) &&
       (!AccountContext->TrustedClient ))
    {
        //
        // This is the krbtgt account and not this is not a trusted client
        // modifying the krbtgt account. We may need to randomize the password
        // in which case we will need to compute a new NT,and LM OWF, return
        // if LM were present and return an updated clear text password.
        //

        //1. PasswordPushPdc is execused. Simply bail without altering anything

        if (CallerType==PasswordPushPdc)
        {
            return(STATUS_SUCCESS);
        }

        //2. Password change is never allowed

        if (CallerType==PasswordChange)
        {
            return(STATUS_PASSWORD_RESTRICTION);
        }

        //3. Clear text password needs to be supplied by client for password set

        ASSERT(CallerType == PasswordSet);

        if (!ARGUMENT_PRESENT(ClearTextPassword))
        {
            return(STATUS_PASSWORD_RESTRICTION);
        }

        UpdatedClearPassword->Buffer = MIDL_user_allocate(
                    (SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1 )*sizeof(WCHAR));
        if (NULL==UpdatedClearPassword->Buffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        Status = SampGenerateRandomPassword(UpdatedClearPassword->Buffer,
                                            SAMP_RANDOM_GENERATED_PASSWORD_LENGTH+1
                                            );
        if (!NT_SUCCESS(Status)) {
            MIDL_user_free(UpdatedClearPassword->Buffer);
            UpdatedClearPassword->Buffer = NULL;
            return Status;
        }
        UpdatedClearPassword->Length = SAMP_RANDOM_GENERATED_PASSWORD_LENGTH*sizeof(WCHAR);
        UpdatedClearPassword->MaximumLength = UpdatedClearPassword->Length;
        
        Status = SampCalculateLmAndNtOwfPasswords(
                    UpdatedClearPassword,
                    LmPresent,
                    LmOwf,
                    NtOwf
                    );

    }
    else if (ARGUMENT_PRESENT(ClearTextPassword))
    {
        //
        // This is the case where the account is not the krbtgt
        // account and the caller passed in the clear password,
        // in this case duplicate the clear text password in the
        // updated clear text password field.
        //

        Status = SampDuplicateUnicodeString(
                        UpdatedClearPassword,
                        ClearTextPassword
                        );
    }
    else
    {
        //
        // Same as above except that caller did not pass in the clear password
        // Leave all fields as is
        //
    }

    return(Status);
}

NTSTATUS
SampCreateSupplementalCredentialsHelper(
    IN ULONG                        DomainIndex,
    IN PUNICODE_STRING              AccountName,
    IN DWORD                        UserAccountControl,
    IN PUNICODE_STRING              UPN,
    IN PUNICODE_STRING              OldSupplementalCreds,
    IN PUNICODE_STRING              ClearPassword OPTIONAL,
    OUT PSAMP_SUPPLEMENTAL_CRED     *NewSupplementalCreds
    )
/*++

Routine Description:

    This routine returns the supplemental credentials for a user, given
    various pieces of information about the user.  This is called during
    the modify path of a user when its password is updated.

Parameters:

    DomainIndex -- the domain the user belongs to

    AccountName -- the SAM account name of the user

    UserAccountControl -- bit field describing account

    UPN -- UPN of the account

    OldSupplelmentalCreds -- previous supplemental credentials, if any

    ClearPassword -- the new clear text password, if any

    NewSupplementalCreds -- the new supplemental credentials


Return Values:

    STATUS_SUCCESS, resource error otherwise.

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    UNICODE_STRING          ClearTextPackageName;

    PSAMP_SUPPLEMENTAL_CRED LocalSupplementalCreds = NULL;

    PSAMP_NOTIFICATION_PACKAGE Package;
    UNICODE_STRING             CredentialName;

    RtlInitUnicodeString(&CredentialName, NULL);

    //
    // Initialize package names for clear passwords and kerberos
    //
    RtlInitUnicodeString( &ClearTextPackageName,L"CLEARTEXT");

    //
    // If a clear password was passed in then add the clear password ( if required )
    // call out to packages so supplemental credentials can be updated.
    //

    if (ARGUMENT_PRESENT(ClearPassword)) {

        //
        // Store the cleartext password, if required
        //

        if (((SampDefinedDomains[ DomainIndex ].CurrentFixed.PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT) != 0)
            || (UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED)){


            NtStatus = SampAddSupplementalCredentialsToList(
                            &LocalSupplementalCreds,
                            &ClearTextPackageName,
                            ClearPassword->Buffer,
                            ClearPassword->Length,
                            FALSE, // scan for conflict
                            FALSE // remove
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

        }

        //
        // Update packages external to SAM for supplemental credential updates
        //
        for (Package = SampNotificationPackages;
                Package != NULL;
                    Package = Package->Next )
        {

            PVOID NewCredentials = NULL;
            PVOID OldCredentials = NULL;
            ULONG NewCredentialSize = 0;
            ULONG OldCredentialSize = 0;

            //
            // If this package doesn't support credential update notifications,
            // goto the next package
            //
            if (NULL == Package->CredentialUpdateNotifyRoutine)
            {
                continue;
            }

            //
            // Prepare the credentials this package wants
            //
            CredentialName = Package->Parameters.CredentialUpdateNotify.CredentialName;

            ASSERT(CredentialName.Length > 0);
            ASSERT(CredentialName.Buffer != NULL);

            //
            // Get the credential value
            //
            NtStatus = SampRetrieveCredentialsFromList(
                            OldSupplementalCreds,
                            &CredentialName, // name of the package
                            TRUE, // Primary
                            &OldCredentials,
                            &OldCredentialSize
                            );

            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
            {
                //
                // If the value were not present then simply ignore
                //
                NtStatus = STATUS_SUCCESS;
                OldCredentials = NULL;
                OldCredentialSize = 0;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

            //
            // Call the package
            //
            try
            {
                NtStatus = Package->CredentialUpdateNotifyRoutine(
                                    ClearPassword,
                                    OldCredentials,
                                    OldCredentialSize,
                                    UserAccountControl,
                                    UPN,
                                    AccountName,
                                    &(SampDefinedDomains[DomainIndex].ExternalName ),
                                    &(SampDefinedDomains[DomainIndex].DnsDomainName),
                                    &NewCredentials,
                                    &NewCredentialSize);

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Credential UpdateRoutine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode()));

                NtStatus = STATUS_ACCESS_VIOLATION;
            }

            //
            // Free the old credentials
            //
            if (OldCredentials) {
                RtlSecureZeroMemory(OldCredentials, OldCredentialSize);
                MIDL_user_free(OldCredentials);
                OldCredentials = NULL;
            }

            //
            // Add the new values
            //
            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampAddSupplementalCredentialsToList(
                                &LocalSupplementalCreds,
                                &CredentialName,
                                NewCredentials,
                                NewCredentialSize,
                                FALSE, // scan for conflict
                                FALSE // remove
                                );

                //
                // Free the memory from the package, if necessary
                //
                if (NewCredentials) {
                    try {
                        Package->CredentialUpdateFreeRoutine(NewCredentials);
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "Exception thrown in Credential Free Routine: 0x%x (%d)\n",
                                   GetExceptionCode(),
                                   GetExceptionCode()));
                        ;
                    }
                    NewCredentials = NULL;
                }

                if (!NT_SUCCESS(NtStatus))
                {
                    goto Error;
                }

            }
            else
            {
                PUNICODE_STRING StringPointers[2];
                //
                // Package should not have allocated anything
                //
                ASSERT(NULL == NewCredentials);

                StringPointers[0] = &Package->PackageName;
                StringPointers[1] = AccountName;

                //
                // The package failed the update. Log a message and continue
                //
                // N.B. The old value will still be removed from the user
                //
                SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                                  0, // no category
                                  SAMMSG_CREDENTIAL_UPDATE_PKG_FAILED,
                                  NULL,  // no user id necessary
                                  sizeof(StringPointers)/sizeof(StringPointers[0]),
                                  sizeof(NTSTATUS),
                                  StringPointers,
                                  &NtStatus);

                NtStatus = STATUS_SUCCESS;
            }


        } // for all packages

    } // if clear text password

    //
    // Remove the existing clear text password, no op if password did not exist.
    // Note AddSupplementalCredential always adds to the front of the list. Therefore
    // the order of the add and remove are reversed.
    //
    NtStatus = SampAddSupplementalCredentialsToList(
                        &LocalSupplementalCreds,
                        &ClearTextPackageName,
                        NULL,
                        0,
                        FALSE,
                        TRUE
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Remove the old values of all other supplemental credentials
    //
    for (Package = SampNotificationPackages;
            Package != NULL;
                Package = Package->Next )
    {
        //
        // If this package doesn't support credential update notifications,
        // goto the next package
        //
        if (NULL == Package->CredentialUpdateNotifyRoutine)
        {
            continue;
        }

        CredentialName = Package->Parameters.CredentialUpdateNotify.CredentialName;
        ASSERT(CredentialName.Length > 0);
        ASSERT(CredentialName.Buffer != NULL);
        NtStatus = SampAddSupplementalCredentialsToList(
                        &LocalSupplementalCreds,
                        &CredentialName,
                        NULL,
                        0,
                        FALSE, // scan for conflict
                        TRUE // remove
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

Error:

    if (NT_SUCCESS(NtStatus)) {

        *NewSupplementalCreds = LocalSupplementalCreds;

    }

    return NtStatus;
}


NTSTATUS
SampCreateSupplementalCredentials(
    IN PVOID            UpdateInfo,
    IN ATTRBLOCK        *AttrBlockIn,
    OUT ATTRBLOCK       *AttrBlockOut
    )
/*++

Routine Description:

    This routine generates the Supplemental credentials for a user account
    given its clear text password.  This routine is called during the modify
    path when a user has its password updated.

Parameters:

    UpdateInfo -- a pointer to SAMP_OBJECT_UPDATE_INFO

    AttrBlockIn -- extra attributes on the object that have been applied
                   to the object

    AttrBlockOut -- attribute SAM wants to apply to the object


Return Values:

    STATUS_SUCCESS, resource error otherwise.

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;

    PSAMP_SUPPLEMENTAL_CRED NewSuppCreds = NULL;

    UNICODE_STRING AccountName = {0, 0, NULL};
    UNICODE_STRING UPN = {0, 0, NULL};
    BOOLEAN UpnAllocated = FALSE;
    UNICODE_STRING OldSuppCreds = {0, 0, NULL};
    UNICODE_STRING EncryptedOldSuppCreds = {0, 0, NULL};
    ULONG          UserAccountControl = 0;
    ULONG          DomainIndex;
    ULONG          ObjectRid;
    PUNICODE_STRING         ClearPassword = NULL;
    UNICODE_STRING          ClearPasswordBuffer;
    PSAMP_PASSWORD_UPDATE_INFO PasswordUpdateInfo = (PSAMP_PASSWORD_UPDATE_INFO)UpdateInfo;

    ATTR Attr = {0};
    ULONG i;
    PSID UserSid = NULL;
    PSID DomainSid = NULL;

    //
    // Extract the parameters from the AttrBlock we have been given
    //
    for (i = 0; i < AttrBlockIn->attrCount; i++) {

        switch (AttrBlockIn->pAttr[i].attrTyp) {
        case ATT_SAM_ACCOUNT_NAME:

            if (AttrBlockIn->pAttr[i].AttrVal.valCount > 0) {
                AccountName.Length = (USHORT) AttrBlockIn->pAttr[i].AttrVal.pAVal[0].valLen;
                AccountName.MaximumLength = AccountName.Length;
                AccountName.Buffer = (WCHAR*) AttrBlockIn->pAttr[i].AttrVal.pAVal[0].pVal;
            }
            break;

        case ATT_USER_PRINCIPAL_NAME:

            if (AttrBlockIn->pAttr[i].AttrVal.valCount > 0) {
                if (AttrBlockIn->pAttr[i].AttrVal.pAVal[0].valLen > MAXUSHORT) {
                    // UPN is not controlled by SAM and can be arbitrary length
                    NtStatus = STATUS_INVALID_PARAMETER;
                    goto Error;
                }
                UPN.Length = (USHORT) AttrBlockIn->pAttr[i].AttrVal.pAVal[0].valLen;
                UPN.MaximumLength = UPN.Length;
                UPN.Buffer = (WCHAR*) AttrBlockIn->pAttr[i].AttrVal.pAVal[0].pVal;
            }
            break;

        case ATT_SUPPLEMENTAL_CREDENTIALS:

            if (AttrBlockIn->pAttr[i].AttrVal.valCount > 0) {
                EncryptedOldSuppCreds.Length = (USHORT) AttrBlockIn->pAttr[i].AttrVal.pAVal[0].valLen;
                EncryptedOldSuppCreds.MaximumLength = EncryptedOldSuppCreds.Length;
                EncryptedOldSuppCreds.Buffer = (WCHAR*)AttrBlockIn->pAttr[i].AttrVal.pAVal[0].pVal;
            }
            break;

        case ATT_USER_ACCOUNT_CONTROL:
            if (AttrBlockIn->pAttr[i].AttrVal.valCount > 0) {

                NtStatus = SampFlagsToAccountControl(*((ULONG*)(AttrBlockIn->pAttr[i].AttrVal.pAVal[0].pVal)),
                                                     &UserAccountControl);
                if (!NT_SUCCESS(NtStatus)) {
                    goto Error;
                }

            }
            break;

        case ATT_OBJECT_SID:

            if (AttrBlockIn->pAttr[i].AttrVal.valCount > 0) {
                UserSid = (PSID)AttrBlockIn->pAttr[i].AttrVal.pAVal[0].pVal;
                ASSERT(RtlValidSid(UserSid));
            }
            break;
        default:
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }
    }

    if ( (AccountName.Length == 0)
     ||  (UserSid == NULL)) {

         //
         // This condition means that passwords are being set on
         // non SAM objects or SAM objects that aren't SAM users
         //
         ASSERT(AccountName.Length != 0);
         ASSERT(NULL != UserSid);
         NtStatus = STATUS_INVALID_PARAMETER;
         goto Error;
    }


    //
    // Handle the password
    //
    if (PasswordUpdateInfo->ClearPresent) {

        ClearPassword = &ClearPasswordBuffer;
        ClearPassword->Length = (USHORT)PasswordUpdateInfo->DataLength;
        ClearPassword->MaximumLength = (USHORT)PasswordUpdateInfo->DataMaximumLength;
        ClearPassword->Buffer = (WCHAR*) &PasswordUpdateInfo->Data[0];

        NtStatus = RtlDecryptMemory(ClearPassword->Buffer,
                                    ClearPassword->MaximumLength,
                                    0);

        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }

    }


    //
    // Get the domain attributes
    //
    NtStatus = SampSplitSid(UserSid,
                            &DomainSid,
                            &ObjectRid);
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // DomainIndex
    //
    for (DomainIndex = SampDsGetPrimaryDomainStart();
            DomainIndex < SampDefinedDomainsCount;
                DomainIndex++) {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid)) {
            break;
        }
    }
    ASSERT(DomainIndex < SampDefinedDomainsCount);
    if (DomainIndex >= SampDefinedDomainsCount) {
        // This is an error condition
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Default the UPN if necessary
    //
    if (UPN.Length == 0) {

        NtStatus = SampCreateDefaultUPN(&AccountName,
                                        DomainIndex,
                                        &UPN);
        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }
        UpnAllocated = TRUE;

    }

    //
    // Decrypt old supplemental credentials
    //
    if (EncryptedOldSuppCreds.Length > 0) {

        NtStatus = SampDecryptSupplementalCredentials(&EncryptedOldSuppCreds,
                                                      ObjectRid,
                                                      &OldSuppCreds);
        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }
    }


    //
    // Get the new credentials
    //
    NtStatus = SampCreateSupplementalCredentialsHelper(DomainIndex,
                                                       &AccountName,
                                                       UserAccountControl,
                                                       &UPN,
                                                       &OldSuppCreds,
                                                       ClearPassword,
                                                       &NewSuppCreds
                                                       );
    if (!NT_SUCCESS(NtStatus)) {

        goto Error;

    }


    //
    // Convert the credentials to an ATTR
    //
    NtStatus = SampConvertCredentialsFromListToAttr(&OldSuppCreds,
                                                    0, // no flags
                                                    ObjectRid,
                                                    NewSuppCreds,
                                                    &Attr
                                                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // Prepare the return value to write to the DS
    //
    RtlSecureZeroMemory(AttrBlockOut, sizeof(*AttrBlockOut));
    AttrBlockOut->attrCount = 1;
    AttrBlockOut->pAttr = DSAlloc(sizeof(ATTR));
    if (NULL == AttrBlockOut->pAttr) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    AttrBlockOut->pAttr->attrTyp = Attr.attrTyp;
    AttrBlockOut->pAttr->AttrVal.valCount = Attr.AttrVal.valCount;
    AttrBlockOut->pAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
    if (NULL == AttrBlockOut->pAttr->AttrVal.pAVal) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    AttrBlockOut->pAttr->AttrVal.pAVal->valLen = Attr.AttrVal.pAVal->valLen;
    AttrBlockOut->pAttr->AttrVal.pAVal->pVal = DSAlloc(Attr.AttrVal.pAVal->valLen);
    if (NULL == AttrBlockOut->pAttr->AttrVal.pAVal->pVal) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    RtlCopyMemory(AttrBlockOut->pAttr->AttrVal.pAVal->pVal,
                  Attr.AttrVal.pAVal->pVal,
                  Attr.AttrVal.pAVal->valLen);

Error:

    if (UpnAllocated) {
        MIDL_user_free(UPN.Buffer);
    }

    if (OldSuppCreds.Buffer) {
        MIDL_user_free(OldSuppCreds.Buffer);
    }

    for (i = 0; i < Attr.AttrVal.valCount; i++) {
        if (Attr.AttrVal.pAVal[i].pVal) {
            MIDL_user_free(Attr.AttrVal.pAVal[i].pVal);
        }
    }
    if (Attr.AttrVal.pAVal) {
        MIDL_user_free(Attr.AttrVal.pAVal);
    }

    if (NewSuppCreds) {
        SampFreeSupplementalCredentialList(NewSuppCreds);
    }

    if (DomainSid) {
        MIDL_user_free(DomainSid);
    }

    // Finally, zero out the password
    if (ClearPassword) {
        RtlSecureZeroMemory(ClearPassword->Buffer, ClearPassword->MaximumLength);
    }

    return (NtStatus);
}

NTSTATUS
SampObtainLockoutInfoWithDomainIndex(
   OUT PDOMAIN_LOCKOUT_INFORMATION LockoutInformation,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   )
{
    PSAMP_DEFINED_DOMAINS   Domain;

    if (!WriteLockAcquired) {
        SampAcquireSamLockExclusive();
    }

    Domain = &SampDefinedDomains[ DomainIndex ];

    LockoutInformation->LockoutDuration = Domain->CurrentFixed.LockoutDuration;
    LockoutInformation->LockoutObservationWindow = Domain->CurrentFixed.LockoutObservationWindow;
    LockoutInformation->LockoutThreshold = Domain->CurrentFixed.LockoutThreshold;

    if (!WriteLockAcquired) {
        SampReleaseSamLockExclusive();
    }

    return(STATUS_SUCCESS);
}


//
// Replicate Single during PDC retry 
//

//
// Theory of Operation
//

//
// The two popular authentication packages for Windows, NTLM and Kerberos,
// both will retry an authentication at the PDC when the authentication 
// failed with "bad password" locally at a BDC.  This is to handle the scenario
// of a password set or change.  Since replication in Windows is not 
// immediate, there will be windows where after a user changes his password or
// an admin resets their password that all DC's don't have the new information.
// Because SAM forwards password changes to the PDC, the PDC will always have
// the newest information.  Therefore, when the authentication packages tell
// SAM (via SamrSetInformation(Internal2), or SamIUpdateLogonStatistics), that
// an authentication failed locally, but succeeded at the PDC, SAM queues
// the user object and replicates that one object down.  In the case of password
// reset, the user will then be able to change thier password on the BDC 
// successfully.
//
// This mechanism is accomplished by queue'ing the replication request on 
// a linked list (SampReplicationQueue) and starting a work item in the 
// process's thread queue.  When the task is started, it drains the replication
// queue by replicating each individual object.
//
// The mechanism is designed such that there is only one instance of the worker
// task (SampProcessReplicationRequest) running at one time -- 
// SampReplicationRequestPending maintains this condition.
//
// To avoid stress situations the replication queue is limited to 32 elements.
//

//
// This element represents a request of one object to be replicated
// to the local DC.  It is part of a linked list.
//
typedef struct _SAMP_REPLICATE_SINGLE_OBJECT {

    //
    // Linked list data
    //
    struct _SAMP_REPLICATE_SINGLE_OBJECT *Next;

    //
    // The GUID of the object to be replicated
    //
    GUID   Guid;

} SAMP_REPLICATE_SINGLE_OBJECT, *PSAMP_REPLICATE_SINGLE_OBJECT;   

//
// The head of the linked list of requests
//
PSAMP_REPLICATE_SINGLE_OBJECT SampReplicationQueue = NULL;

//
// The count of requests.  This is used to limit the number of 
// pending requests.
//
ULONG SampReplicationQueueSize = 0;

//
// Boolean that indicates when a work item has been placed in the task
// queue.  The work item will process all requests in SampReplicationQueue
// before exiting.
//
ULONG SampReplicationRequestPending = FALSE;

//
// Lock that gaurds SampReplicationQueue, SampReplicationQueueSize,
// SampReplicationRequestPending
//
CRITICAL_SECTION SampReplicateQueueLock;
#define LockReplicationQueue()    EnterCriticalSection(&SampReplicateQueueLock)
#define UnLockReplicationQueue()  LeaveCriticalSection(&SampReplicateQueueLock)


//
// 32 is chosen as a value that 1) we don't expect to exceed in deployment
// and 2) works well for the algorithms below.  Should the number be
// raised, a different search on the linked list should be investigated.
//
#define SAMP_MAX_REPLICATION_QUEUE 32


//
// This value maintains the last time that the BDC attempted to contact
// the PDC to replicate down a single object.  This value is only set
// when the PDC doesn't support the extended operation of replicating
// a single object (this was added in the .NET release and may be back
// ported to win2k).  The idea is that if the PDC doesn't support the 
// operation only retry periodically.
//
LARGE_INTEGER  SampNextSingleObjectReplicationRetry = {0};

#if DBG
// 1 minute
#define SAMP_PDC_REPLICATE_SINGLE_OBJECT_RETRY 60
#else
// 1 hour
#define SAMP_PDC_REPLICATE_SINGLE_OBJECT_RETRY (60*60) 
#endif


VOID
SampCleanupReplicationQueue(
    BOOLEAN fPDCSupportsOperation
    )
//
// This routine frees SampReplicationQueue and resets all state
//
// fPDCSupportsOperation indicates whether the TimeStamp controlling when
// the PDC is contacted should be updated.
// 
{
    PSAMP_REPLICATE_SINGLE_OBJECT Current;
    LARGE_INTEGER TempTime;

    LockReplicationQueue();

    Current = SampReplicationQueue;
    while (Current) {
        PVOID p = Current;
        Current = Current->Next;
        MIDL_user_free(p);
    }
    SampReplicationQueue = NULL;
    SampReplicationQueueSize = 0;
    SampReplicationRequestPending = FALSE;

    if (!fPDCSupportsOperation) {
        //
        // The PDC doesn't support the replicate single object primitive.
        // Update the timestamp so we don't contact the PDC needlessly.
        //
        GetSystemTimeAsFileTime((FILETIME*)&SampNextSingleObjectReplicationRetry);
        TempTime.QuadPart = Int32x32To64(SAMP_PDC_REPLICATE_SINGLE_OBJECT_RETRY, 
                                         SAMP_ONE_SECOND_IN_FILETIME);
        SampNextSingleObjectReplicationRetry.QuadPart += TempTime.QuadPart;
    }

    UnLockReplicationQueue();
}





VOID
SampQueueReplicationRequest(
    IN GUID *Guid
    )
/*++

Routine Description:

    This routine is called during an authentication in which a user failed
    to logon locally because of a bad password, but the authentication 
    attempt succeeded at the PDC.  This routine adds the user to a list
    of users to be replicated locally so that the BDC will be kept
    up to date more quickly than just relying on normal replication

Parameters:

    Guid -- the security principal to replicate locally

Return Values:

    None.

--*/
{
    BOOLEAN fLogSuccess = FALSE;
    PSAMP_REPLICATE_SINGLE_OBJECT New, Current, Previous = NULL;
    LARGE_INTEGER CurrentTime;

    //
    // Do nothing when disabled
    //

    if (SampDisableSingleObjectRepl) {
        return;
    }

    //
    // Prepare the time after which we will attempt to replicate from the
    // PDC
    //
    GetSystemTimeAsFileTime((FILETIME*)&CurrentTime);

    //
    // Allocate the new entry outside of the lock
    //

    New = MIDL_user_allocate(sizeof(*New));
    if (!New) {

        return;
    }

    //
    // Copy in the information about the user, only zero out the
    // structure portion
    //
    ZeroMemory(New, sizeof(SAMP_REPLICATE_SINGLE_OBJECT));
    RtlCopyMemory(&New->Guid, Guid, sizeof(GUID));

    //
    // Serialize access to the queue
    //

    LockReplicationQueue();

    //
    // Queue the request, if possible
    //        

    if ((CurrentTime.QuadPart > SampNextSingleObjectReplicationRetry.QuadPart)
     && (SampReplicationQueueSize < SAMP_MAX_REPLICATION_QUEUE)) {


        //
        // Search the list for the entry if it exists
        //

        Current = SampReplicationQueue;
        while (Current) {
            if (IsEqualGUID(&Current->Guid, Guid)) {
                //
                // Object is in the queue
                //
                break;
            }
            Previous = Current;
            Current = Current->Next;
        }


        if (NULL == Current) {

            //
            // Object not in the queue so add it at the end
            //

            if (NULL == Previous) {
                ASSERT(SampReplicationQueue == NULL);
                SampReplicationQueue = New;
            } else {
                ASSERT(Previous->Next == NULL);
                Previous->Next = New;
            }
            New = NULL;
            SampReplicationQueueSize++;
            fLogSuccess = TRUE;


            //
            // Trigger a work item, if necessary. SampReplicationRequestPending
            // is set to FALSE when SampProcessReplicationRequest has 
            // finished processing all current request in SampReplicationQueue
            //

            if (!SampReplicationRequestPending) {

                BOOL fSuccess;

                fSuccess = QueueUserWorkItem(SampProcessReplicationRequest,
                                             NULL,
                                             WT_EXECUTEINIOTHREAD);
                if (fSuccess) {

                    //
                    // The task has been submitted.  If this fails then
                    // the next replication request will attempt to 
                    // queue the task to run again.
                    //

                    SampReplicationRequestPending = TRUE;
                }
            }
        }

    }
    UnLockReplicationQueue();

    if (fLogSuccess) {

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "Adding %x-%x-%x-%x to SAM replication queue\n", 
                        ((ULONG *) Guid)[0],
                        ((ULONG *) Guid)[1],
                        ((ULONG *) Guid)[2],
                        ((ULONG *) Guid)[3]));
    } else {

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "%x-%x-%x-%x replication request dropped\n", 
                        ((ULONG *) Guid)[0],
                        ((ULONG *) Guid)[1],
                        ((ULONG *) Guid)[2],
                        ((ULONG *) Guid)[3]));

    }

    //
    // Free the element if it wasn't put in the list
    //
    if (New) {
        MIDL_user_free(New);
    }

    return;

}    



DWORD
SampProcessReplicationRequest(
    PVOID p // unused
    )
/*++

Routine Description:

    This is an async task that executes in the context of the process's
    thread pool.  It walks through SAM's replication queue, issuing a 
    request to replicate each user down individually.
    
    This routine will always end such that the queue is empty.
    
    Only once instance of this routine should be running at a time --
    SampReplicationRequestPending gaurds this fact.

Parameters:

    p -- unused

Return Values:

    ERROR_SUCCESS, though the error is ignored since this is a thread pool task               

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_REPLICATE_SINGLE_OBJECT Current, LastItem = NULL;
    BOOLEAN fPDCSupportsOperation = TRUE;
    BOOL fTHStateFailed = TRUE;

    OPARG OpArg = {0};
    OPRES *OpRes;

    // UTF8 representation of the server to replicate the object from
    LPSTR TargetServerDN = NULL;

    // UTF8 representation of DN
    LPSTR UserDN = NULL;

    //
    // This boolean indicates whether to empty the queue
    // of all requests.  This can happen on error conditions
    // or if the PDC doesn't support the replicate single
    // object operations
    //
    BOOLEAN fFlushQueue = FALSE;

    fTHStateFailed = THCreate( CALLERTYPE_SAM );
    if (fTHStateFailed) {
        // Nothing we can do
        fFlushQueue = TRUE;
        goto Exit;
    }
    SampSetDsa(TRUE);

    //
    // Get the target server
    //
    TargetServerDN = SampGetPDCString();
    if (NULL == TargetServerDN) {

        // Nothing we can do
        fFlushQueue = TRUE;
        goto Exit;
    }

    //
    // Get the first element of requests
    //
    LockReplicationQueue();
    Current = SampReplicationQueue;
    if (NULL == Current) {

        //
        // There is nothing in the queue, this task is going to
        // finish now
        //

        SampReplicationRequestPending = FALSE;
    } else {

        //
        // Remove the element from the head of the list
        //

        SampReplicationQueue = Current->Next;
        SampReplicationQueueSize--;
    }
    UnLockReplicationQueue();

    //
    // Process each replication request
    //
    while (Current) {

        DWORD err;
        DSNAME DsName = {0};

        //
        // Remeber this item so that it can be freed
        //

        LastItem = Current;

        //
        // Package up parameter
        //
        memset(&OpArg, 0, sizeof(OpArg));
        OpArg.eOp = OP_CTRL_REPLICATE_OBJECT;

        //
        // Get the User DN in UTB8 format
        //
        DsName.structLen = DSNameSizeFromLen(0);
        RtlCopyMemory(&DsName.Guid, &Current->Guid, sizeof(GUID));

        UserDN = SampGetUserString(&DsName);
        if (UserDN) {

            //
            // The user was found -- replicate locally
            //

            OpArg.cbBuf = strlen(UserDN) 
                        + strlen(TargetServerDN) 
                        + 1   // for :
                        + 1;   // NULL
    
            OpArg.pBuf = MIDL_user_allocate(OpArg.cbBuf);
            if (NULL == OpArg.pBuf) {
                fFlushQueue = TRUE;
                goto Exit;
            }
            strcpy(OpArg.pBuf, TargetServerDN);
            strcat(OpArg.pBuf, ":");
            strcat(OpArg.pBuf, UserDN);
    
            //
            // Issue request
            //
            err = DirOperationControl(&OpArg, &OpRes);
    
            if (OpRes == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {                                          
                if (EXOP_ERR_UNKNOWN_OP == OpRes->ulExtendedRet) {
        
                    //
                    // PDC doesn't handle request clear up queue and leave
                    //
                    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "PDC doesn't handle replicate single object\n"));
                    fPDCSupportsOperation = FALSE;
                    fFlushQueue = TRUE;
                    goto Exit;
        
                }
                Status = SampMapDsErrorToNTStatus(err,&OpRes->CommRes);
            }
            THClearErrors();
    
    
            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
               (SAMP_LOG_ACCOUNT_LOCKOUT,
               "%x-%x-%x-%x (%s) replication attempt: 0x%x\n",
                ((ULONG *) &Current->Guid)[0],
                ((ULONG *) &Current->Guid)[1],
                ((ULONG *) &Current->Guid)[2],
                ((ULONG *) &Current->Guid)[3],
                 UserDN,
                 Status));
        }


        //
        // Free the request element
        //
        MIDL_user_free(LastItem);
        LastItem = NULL;

        if (UserDN) {
            MIDL_user_free(UserDN);
            UserDN = NULL;
        }

        if (OpArg.pBuf) {
            MIDL_user_free(OpArg.pBuf);
            OpArg.pBuf = NULL;
        }

        //
        // Get the next element
        //
        LockReplicationQueue();
        Current = SampReplicationQueue;
        if (NULL == Current) {

            //
            // There is nothing in the queue, this task is going to
            // finish now
            //

            SampReplicationRequestPending = FALSE;
        } else {

            //
            // Remove the element from the head of the list
            //

            SampReplicationQueue = Current->Next;
            SampReplicationQueueSize--;
        }
        UnLockReplicationQueue();

    }

Exit:

    //
    // Remove all entries from the queue, if necessary
    //
    if (fFlushQueue) {

        SampCleanupReplicationQueue(fPDCSupportsOperation);
    }

    if (LastItem) {
        MIDL_user_free(LastItem);
    }

    if (UserDN) {
        MIDL_user_free(UserDN);
    }

    if (OpArg.pBuf) {
        MIDL_user_free(OpArg.pBuf);
    }

    if (TargetServerDN) {
        MIDL_user_free(TargetServerDN);
    }

    if (!fTHStateFailed) {
        THDestroy();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\usrlogon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    user.c

Abstract:

    This file contains services related fast logon API's


Author:

    Murli Satagopan - Murlis (4/8/97 ) Created

Environment:

    User Mode - Win32

Revision History:

    4/8/96 Created

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <lmcons.h>
#include <nturtl.h>
#include <ntlsa.h>              // need for nlrepl.h
#include <nlrepl.h>             // I_NetNotifyMachineAccount prototype
#include <msaudite.h>
#include <rc4.h>                // rc4_key(), rc4()
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>             // ATT_*
#include <dslayer.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <dnsapi.h>
#include <validate.h>

NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    SAMP_OBJECT_TYPE    ObjectType,
    PSAMP_OBJECT        NewContext,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    IN  BOOLEAN  OverrideLocalGroupCheck
    );

NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );

NTSTATUS
SampParseName(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING DnsDomainName,
    PUNICODE_STRING ParsedSamAccountName,
    BOOLEAN         *LookupByParsedName
    )
{
    ULONG    NumChars = AccountName->Length/sizeof(WCHAR);
    ULONG    Current = 0;
    UNICODE_STRING    ParsedDomainName;

    *LookupByParsedName = FALSE;

    //
    // Look for the @ sign
    //
    for (Current=0;Current<NumChars; Current++)
    {
        if (L'@'==AccountName->Buffer[Current])
        {
            WCHAR *DnsDomainNameString = NULL;
            //
            // AccountName contains @ Char.
            //


            *ParsedSamAccountName = *AccountName;
            ParsedSamAccountName->Length = (USHORT) Current * sizeof(WCHAR);
            ParsedDomainName.Length = ParsedDomainName.MaximumLength = (USHORT)
                    (AccountName->Length - (Current + 1) * sizeof(WCHAR));

            // 1 for the NULL terminator.

            ParsedDomainName.Buffer = MIDL_user_allocate(ParsedDomainName.Length + sizeof(WCHAR));
            if (NULL==ParsedDomainName.Buffer)
            {
                return(STATUS_NO_MEMORY);
            }

            ParsedDomainName.Buffer[ParsedDomainName.Length/sizeof(WCHAR)] = 0;
            RtlCopyMemory(
                ParsedDomainName.Buffer,
                AccountName->Buffer+Current+1,
                ParsedDomainName.Length
                );

            DnsDomainNameString = MIDL_user_allocate(DnsDomainName->Length + sizeof(WCHAR));
            if (NULL==DnsDomainNameString)
            {
                MIDL_user_free(ParsedDomainName.Buffer);
                return(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(DnsDomainNameString, DnsDomainName->Buffer, DnsDomainName->Length);
            DnsDomainNameString[DnsDomainName->Length/sizeof(WCHAR)] = L'\0';

            if ((ParsedDomainName.Length > 0 ) &&
               (DnsNameCompare_W(DnsDomainNameString,ParsedDomainName.Buffer)))
            {
                *LookupByParsedName = TRUE;          
            }

            MIDL_user_free(ParsedDomainName.Buffer);
            MIDL_user_free(DnsDomainNameString);

            return(STATUS_SUCCESS);
        }
    }

    return (STATUS_SUCCESS);
}


NTSTATUS
SampLookupUserByUPNOrAccountName(
    DSNAME * DomainObject,
    PUNICODE_STRING DnsDomainName,
    PUNICODE_STRING AccountName,
    DSNAME  ** UserObject
    )

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Check to see if an object by the UPN exists
    //

    NtStatus = SampDsLookupObjectByAlternateId(
                    DomainObject,
                    ATT_USER_PRINCIPAL_NAME,
                    AccountName,
                    UserObject
                    );

    if (!NT_SUCCESS(NtStatus))
    {

        //
        // Try the SAM account name -- lookup by UPN failed
        //

         NtStatus = SampDsLookupObjectByName(
                        DomainObject,
                        SampUserObjectType,
                        AccountName,
                        UserObject
                        );

         if (!NT_SUCCESS(NtStatus))
         {
             UNICODE_STRING ParsedSamAccountName;
             BOOLEAN        LookupByParsedName = FALSE;

             //
             // Scan for an @ sign and try to parse the name
             // into account name and UPN
             //

             NtStatus = SampParseName(
                            AccountName,
                            DnsDomainName,
                            &ParsedSamAccountName,
                            &LookupByParsedName
                            );

             if (NT_SUCCESS(NtStatus))
             {
                 if (LookupByParsedName)
                 {
                     NtStatus = SampDsLookupObjectByName(
                                    DomainObject,
                                    SampUserObjectType,
                                    &ParsedSamAccountName,
                                    UserObject
                                    );
                 }
                 else
                 {
                     NtStatus = STATUS_NO_SUCH_USER;
                 }
             }
         }
    }

    return(NtStatus);
}

                            




NTSTATUS
SampGetReverseMembershipTransitive(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Flags,
    OUT PSID_AND_ATTRIBUTES_LIST   List
    )
/*++

  Routine Description

    Gets the  transitive reverse membership of a user


  Arguments:

    User Handle -- handle of the User object, whose reverse membership is desired
    Flags       -- Flags for controlling the operation. Currently no flags
    cSids       -- Count of Sids
    rpSids      -- Array of Sids

--*/
{

    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    DSNAME          *UserObjectName = NULL;
    PSID            *DsSids=NULL;
    SAMP_OBJECT_TYPE FoundType;


    //
    // Parameter Validation
    //

    ASSERT(List);
    List->Count = 0;

    NtStatus = SampDsGetReverseMemberships(
                    AccountContext->ObjectNameInDs,
                    Flags,
                    &(List->Count),
                    &DsSids
                    );

    if (NT_SUCCESS(NtStatus))
    {
         //
         // Copy in the Sids, using MIDL_user_allocate
         //

         List->SidAndAttributes = MIDL_user_allocate(List->Count * sizeof(SID_AND_ATTRIBUTES));

         if (NULL!=List->SidAndAttributes)
         {
             ULONG  Index;
             ULONG  SidLen;

             //
             // Zero out the returned Memory
             //

             RtlZeroMemory(List->SidAndAttributes, (List->Count)* sizeof(SID_AND_ATTRIBUTES));

             //
             // Copy the Sids
             //

             for (Index=0;Index<List->Count;Index++)
             {
                 SidLen = RtlLengthSid(DsSids[Index]);

                 (List->SidAndAttributes)[Index].Sid= MIDL_user_allocate(SidLen);

                 if (NULL!=(List->SidAndAttributes)[Index].Sid)
                 {
                     RtlCopyMemory((List->SidAndAttributes[Index]).Sid,DsSids[Index],SidLen);
                     (List->SidAndAttributes)[Index].Attributes = SE_GROUP_ENABLED|SE_GROUP_MANDATORY|
                                                        SE_GROUP_ENABLED_BY_DEFAULT;
                 }
                 else
                 {
                     NtStatus = STATUS_NO_MEMORY;
                     break;
                 }
             }

         }
         else
         {
             NtStatus = STATUS_NO_MEMORY;
         }
     }


    if (!NT_SUCCESS(NtStatus)) {

        ULONG Index;

        if (List->SidAndAttributes)
        {
            for (Index=0;Index < List->Count;Index++)
            {
                if ((List->SidAndAttributes)[Index].Sid)
                    MIDL_user_free((List->SidAndAttributes)[Index].Sid);
            }

            MIDL_user_free(List->SidAndAttributes);
            List->SidAndAttributes = NULL;
        }

        List->Count = 0;


    }

    if (NULL!=DsSids)
        THFree(DsSids);

    return( NtStatus );

}

NTSTATUS
SampGetUserLogonInformationRegistryMode(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
/*++

    This is the Registry Mode SAM Logon Information Routine.
    This is used by ( or will eventually be used ) during logon's
    on Workstations and member server's when logging on to an account
    in the local database.

    Paramerters:

        Same as SamIGetUserLogonInformation

    Return Values:

        STATUS_SUCCESS:
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_OBJECT_TYPE FoundType;
    PSAMP_OBJECT     DomainContext;
    SID_NAME_USE     Use;
    ULONG            Rid;
    PSAMP_OBJECT     AccountContext=NULL;
    ULONG            MembershipCount;
    PGROUP_MEMBERSHIP Membership=NULL;
    BOOLEAN          fLockAcquired = FALSE;
    PVOID            DomainSid = NULL;
    ULONG            WhichFields = 0;


    //
    // In Registry mode, we always fetch all fields
    //

    WhichFields = USER_ALL_READ_GENERAL_MASK         |
                              USER_ALL_READ_LOGON_MASK           |
                              USER_ALL_READ_ACCOUNT_MASK         |
                              USER_ALL_READ_PREFERENCES_MASK     |
                              USER_ALL_READ_TRUSTED_MASK;

    //
    // Acquire the Read Lock
    //

    SampAcquireReadLock();
    fLockAcquired = TRUE;


    *Buffer = NULL;
    RtlZeroMemory(ReverseMembership, sizeof(SID_AND_ATTRIBUTES_LIST));


    //
    // Validate type of, and access to the object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP|DOMAIN_READ,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );
    if (NT_SUCCESS(NtStatus))
    {

        if (Flags & SAM_OPEN_BY_SID)
        {

            NtStatus = SampSplitSid(
                          AccountName->Buffer,
                          &DomainSid,
                          &Rid
                          );

            if ((NT_SUCCESS(NtStatus))
                && (!RtlEqualSid(DomainSid,SampDefinedDomains[DomainContext->DomainIndex].Sid)))
            {
                NtStatus = STATUS_NO_SUCH_USER;
            }
        }
        else
        {
           //
           // Get the Rid of the Account
           //

           NtStatus = SampLookupAccountRid(
                        DomainContext,
                        SampUserObjectType,
                        AccountName,
                        STATUS_NO_SUCH_USER,
                        &Rid,
                        &Use
                        );
        }

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Create an Account Context
            //

            NtStatus = SampCreateAccountContext(
                            SampUserObjectType,
                            Rid,
                            TRUE, // Trusted Client
                            FALSE,// Loopback Client
                            TRUE, // Object Exisits
                            &AccountContext
                            );
            if (NT_SUCCESS(NtStatus))
            {
                //
                // Query Information
                //

                //
                // Clear the transaction in domain flag first, as
                // as SampQueryInformationUserInternal will call
                // LookupContext, which will set the TransactionDomain
                // flag
                //

                SampSetTransactionWithinDomain(FALSE);

                NtStatus = SampQueryInformationUserInternal(
                                AccountContext,
                                UserInformationClass,
                                TRUE, // Lock is already held
                                WhichFields,
                                0,
                                Buffer
                                );
                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampUpdateAccountDisabledFlag(
                                    AccountContext,
                                    &((*Buffer)->All.UserAccountControl)
                                    );

                    if (NT_SUCCESS(NtStatus))
                    {
                        //
                        // Get the User's Reverse Membership in Groups
                        //

                        NtStatus =  SampRetrieveUserMembership(
                                        AccountContext,
                                        FALSE, // Make copy
                                        &MembershipCount,
                                        &Membership
                                        );
                        if ((NT_SUCCESS(NtStatus))&& (MembershipCount>0))
                        {
                            ULONG i;

                            //
                            // Create the Sid and Attributes form of ReverseMembership
                            //

                            ReverseMembership->Count = MembershipCount;
                            ReverseMembership->SidAndAttributes = MIDL_user_allocate(
                                                        ReverseMembership->Count
                                                        * sizeof(SID_AND_ATTRIBUTES));

                            if (NULL!=ReverseMembership->SidAndAttributes)
                            {
                                ULONG  Index;
                                ULONG  SidLen;

                                //
                                // Zero out the returned Memory
                                //

                                RtlZeroMemory(ReverseMembership->SidAndAttributes,
                                        (ReverseMembership->Count)* sizeof(SID_AND_ATTRIBUTES));

                                //
                                // Convert the Rids to Sids and Then Copy Them
                                //

                                for (Index=0;
                                        (Index<ReverseMembership->Count)&&(NT_SUCCESS(NtStatus));
                                                Index++)
                                {
                                    (ReverseMembership->SidAndAttributes)[Index].Attributes
                                            = Membership[Index].Attributes;
                                    NtStatus = SampCreateFullSid(
                                                SampDefinedDomains[SampTransactionDomainIndex].Sid,
                                                Membership[Index].RelativeId,
                                                &((ReverseMembership->SidAndAttributes)[Index].Sid)
                                                );
                                }

                                if ((ARGUMENT_PRESENT(UserHandle))&&(NT_SUCCESS(NtStatus)))
                                {
                                    *UserHandle = AccountContext;
                                }
                            }
                            else
                            {
                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
            }
        }

        SampDeReferenceContext2(DomainContext,FALSE);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Free the reverse membership information
        //

        if (ReverseMembership->SidAndAttributes)
        {
            SamIFreeSidAndAttributesList(ReverseMembership);
        }

        ReverseMembership->Count = 0;

        //
        // Free the User All Information
        //

        if (NULL!=*Buffer)
        {
            SamIFree_SAMPR_USER_INFO_BUFFER(*Buffer,UserAllInformation);
            *Buffer=NULL;
        }

        if (NULL!=AccountContext)
        {
            SampDeleteContext(AccountContext);
        }
    }

    if (NULL!=DomainSid)
       MIDL_user_free(DomainSid);

    if (fLockAcquired)
        SampReleaseReadLock();

    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//         SAM I calls to be used by NT5 in process clients                 //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    IN  USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
/*++

    Routine Description

        This Routine  Gets all the information for logging on a
        a user, including the full transitive reverse membership.
        The transitive reverse membership, if necessary is obtained
        by going to a G.C. A user handle is also returned, in case
        the caller requested it for sub-authentication. This function
        is efficient in its usage of the Sam Lock, except for the
        sub-authentication case


    Parameters

        Flags -- Controls the operation of the routine. The Following Flags
                 are defined Currently

                    SAM_GET_MEMBERSHIPS_NO_GC

                            Go to GC to get reverse memberships

                    SAM_GET_MEMBERSHIPS_TWO_PHASE

                            Get the reverse memberships in the
                            2 phase fashion for logon's. Can be
                            used to save additional positioning
                            cycles while logging on to a domain
                            controller

                    SAM_GET_MEMBERSHIPS_MIXED_DOMAIN

                            Forces Reverse membership evaluation
                            to be identical to that of an NT4 Domain

                    SAM_NO_MEMBERSHIPS

                            Does Not Retreive Any reverse memberships.
                            Useful while evaluating special accounts
                            that are known to not have any group memberships

                    SAM_OPEN_BY_ALTERNATE_ID

                            The Account Parameter specifies an Alternate
                            Id that is used to locate the account. Instead
                            of the SAM account name.

                    SAM_OPEN_BY_GUID

                            The AccountName->Buffer is a pointer to
                            the GUID of the account object

                    SAM_OPEN_BY_SID

                            The AccountName->Buffer is a pointer to the
                            SID of the account object.




        DomainSid -- Indicates the Users Domain

        AccountName -- Indicates the Users Account Name

        Buffer -- Builds the User All formation structure,
                        specifying passwords, account lockout and such

        ReverseMembership  -- The full transtive reverse membership of the
                        user, does not contain the local group membership
                        in the builtin domain

        UserHandle  -- Optional User Handle for Sub- Authentication packages.

    Return Values:

        STATUS_SUCCESS
        Other Error codes depending upon error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    PSAMP_OBJECT    NewContext=NULL, DomainContext = (PSAMP_OBJECT) DomainHandle;
    PSAMP_OBJECT    SubAuthenticationContext=NULL;
    UNICODE_STRING  KdcAccount;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    ULONG StartTick, EndTick;

    SAMTRACE_EX("SamIGetUserLogonInformation");

    if (FALSE==SampUseDsData)
    {
        //
        // Registry Mode Sam, call the Equivalent Registry mode
        // routine
        //

        NtStatus = SampGetUserLogonInformationRegistryMode(
                        DomainHandle,
                        Flags,
                        AccountName,
                        UserInformationClass,
                        Buffer,
                        ReverseMembership,
                        UserHandle
                        );
        SAMTRACE_RETURN_CODE_EX(NtStatus);

        return NtStatus;

    }
    else
    {
        PDSNAME     DomainObject = NULL;
        PDSNAME     UserObject = NULL;
        BOOLEAN     fMixedDomain = FALSE;
        ULONG       DomainIndex=0;
        PUNICODE_STRING DnsDomainName = NULL;


        *Buffer = NULL;
        RtlZeroMemory(ReverseMembership,sizeof(SID_AND_ATTRIBUTES_LIST));

        //
        // This routine executes without any locks held and therefore
        // is vulnerable for the database to be shut down while executng
        // database queries. Therefore update state saying that we are
        // executing so that the shutdown code waits for us.
        //

        NtStatus = SampIncrementActiveThreads();
        if (!NT_SUCCESS(NtStatus))
            return NtStatus;

        //
        // Obtain the Domain Object corresponding to the domain
        // Sid
        //


        //
        // We are not Validating the Domain Handle passed in by
        // our clients and using it straight away. This is because
        // the validation code is single threaded and we do not want
        // to incur the performance penalty. This call is made only
        // by trusted callers and to that extent we trust them
        //

        DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;
        DomainObject = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs;
        fMixedDomain = SampDefinedDomains[DomainIndex].IsMixedDomain;
        DnsDomainName = &SampDefinedDomains[DomainIndex].DnsDomainName;

        //
        // Begin a Ds Transaction.
        //

        NtStatus = SampMaybeBeginDsTransaction(TransactionRead);

        if (!NT_SUCCESS(NtStatus))
            goto Error;



        //
        // Create a Context for the User Object
        //

        NewContext = SampCreateContextEx(
                        SampUserObjectType,
                        TRUE, // Trusted Client
                        TRUE, // DS mode
                        TRUE, // Thread Safe
                        DomainContext->LoopbackClient, // Loopback Client
                        TRUE, // Lazy Commit
                        TRUE, // PersisAcrossCalls
                        FALSE,// BufferWrites
                        FALSE,// Opened By DCPromo
                        DomainIndex
                        );

        if (NULL==NewContext)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // For the passed in Account name, obtain the FQDN of the
        // user object. The caller has several ways of specifying the
        // name
        //  1. As an account name -- This is a default. A DS search is done
        //     to convert this to a FQDN
        //
        //  2. An alternate id -- This is typically done when the user wishes
        //     to authenticate using a certificate
        //
        //  3. The caller has specified a UPN or an SPN
        //
        //  4. A GUID specifying the user object.
        //
        //  5. A SID specifying the user object.
        //
        //  6. A DN specifying the user object
        //

        if (Flags & SAM_OPEN_BY_ALTERNATE_ID)
        {
            //
            // Caller Wants to Open the account by Alternate Id
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_ALT_SECURITY_IDENTITIES,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_UPN)
        {
            //
            // Caller Wants to Open the account by User Principal Name
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_USER_PRINCIPAL_NAME,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_SPN)
        {
            //
            // Caller Wants to Open the account by User Principal Name
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_SERVICE_PRINCIPAL_NAME,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_GUID)
        {
            //
            // The passed in name is the GUID of the user object. There is no need to
            // lookup the database.
            //


            UserObject = MIDL_user_allocate(sizeof(DSNAME));
            if (NULL!=UserObject)
            {
                RtlZeroMemory(UserObject,sizeof(DSNAME));
                RtlCopyMemory(&UserObject->Guid,AccountName->Buffer,sizeof(GUID));
                UserObject->structLen = DSNameSizeFromLen(0);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (Flags & SAM_OPEN_BY_SID)
        {
            //
            // The passed in name is the SID of the user object. Construct a SID only
            // DS name after validating the SID. There is no need to lookup the database
            //

            if ((RtlValidSid(AccountName->Buffer))
                    && (AccountName->Length<=sizeof(NT4SID))
                    && (AccountName->Length==RtlLengthSid(AccountName->Buffer)))
            {
                UserObject = MIDL_user_allocate(sizeof(DSNAME));
                if (NULL!=UserObject)
                {
                    RtlZeroMemory(UserObject,sizeof(DSNAME));
                    RtlCopyMemory(&UserObject->Sid,AccountName->Buffer,AccountName->Length);
                    UserObject->SidLen = AccountName->Length;
                    UserObject->structLen = DSNameSizeFromLen(0);
                }
                else
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
        }
        else if (Flags & SAM_OPEN_BY_DN) {

            ULONG Length = AccountName->Length/sizeof(WCHAR);
            ULONG Size = DSNameSizeFromLen(Length);

            UserObject = MIDL_user_allocate(Size);
            if (NULL != UserObject) {

                RtlZeroMemory(UserObject, Size);
                UserObject->structLen = Size;
                UserObject->NameLen = Length;
                RtlCopyMemory(&(UserObject->StringName[0]), AccountName->Buffer, AccountName->Length);

            } else {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (Flags & SAM_OPEN_BY_UPN_OR_ACCOUNTNAME)
        {
            NtStatus = SampLookupUserByUPNOrAccountName(
                            DomainObject,
                            DnsDomainName,
                            AccountName,
                            &UserObject
                            );

        }
        else
        {
            //
            // Lookup the object by Name
            //

            NtStatus = SampDsLookupObjectByName(
                        DomainObject,
                        SampUserObjectType,
                        AccountName,
                        &UserObject
                        );
        }

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // Initialize the DS object portion on the new context.
        //

        NewContext->ObjectNameInDs = UserObject;
        NewContext->DomainIndex = DomainIndex;
        NewContext->GrantedAccess = USER_ALL_ACCESS;
        SetDsObject(NewContext);

        //
        // Read all the properties in one stroke. This results in
        // in a single DirRead call. All "interesting" properties
        // are prefetched by this routine. This eliminates any
        // further DS calls to read additional properties.
        //


        NtStatus = SampDsCheckObjectTypeAndFillContext(
                            SampUserObjectType,
                            NewContext,
                            WhichFields,
                            ExtendedFields,
                            FALSE // override local group check
                            );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // After the successful completion of SampDsCheckObjectTypeAndFillContext
        // the DSName pointed to by UserObject, should have the SID in it. This
        // is because the DS, annotates the name with any missing components.
        //

        ASSERT(UserObject->SidLen>0);


        //
        // Obtain the Rid from Sid. Note SampSplitSid should never
        // fail, with a NULL domainSid parameter.
        //

        IgnoreStatus = SampSplitSid(
                                &(UserObject->Sid),
                                NULL ,
                                &(NewContext->TypeBody.User.Rid)
                                );

        ASSERT(NT_SUCCESS(IgnoreStatus));


       


        //
        // Query Information Regarding the User Object. This is a
        // completely in memory operation.
        //

        NtStatus = SampQueryInformationUserInternal(
                        NewContext,
                        UserInformationClass,
                        TRUE, // Lock is not held, but we do not
                              // want to end the transaction in
                              // inside of SampQueryInformationUserInteral
                              // There fore pass a TRUE.
                        WhichFields,
                        ExtendedFields,
                        Buffer
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;


        //
        // Update the account disabled flag in the user information requested
        // This routine enables the admin account for purposes of logon, if
        // the machine is booted in to Safe mode
        //

        if ((0==WhichFields) // 0 is special case, means get all fields
           || (WhichFields & USER_ALL_USERACCOUNTCONTROL ))
        {
            PULONG pUserAccountControl = NULL;

            switch(UserInformationClass)
            {
                case UserAllInformation:
                    pUserAccountControl = &((*Buffer)->All.UserAccountControl);
                    break;
                case UserInternal6Information:
                    pUserAccountControl = &(((PUSER_INTERNAL6_INFORMATION)(*Buffer))->I1.UserAccountControl);
                    break;
                default:
                    ASSERT(FALSE && "UnsupportedInformationLevel");
                    NtStatus = STATUS_INVALID_PARAMETER;
                    goto Error;
            }

            NtStatus = SampUpdateAccountDisabledFlag(
                                    NewContext,
                                    pUserAccountControl
                                    );
        }

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // If caller did not prohibit us from getting memberships then
        // retrieve reverse memberships
        //

        if (!(Flags & SAM_NO_MEMBERSHIPS))
        {
            //
            // Obtain the Transitive Reverse Membership, if necessary goto G.C
            //


            //
            // Do not go to the G.C for the krbtgt account. The krbtgt
            // is not renamable and in a win2k domain it is enforced that
            // only the account with the RID DOMAIN_USER_RID_KRBTGT can
            // and will have this name. The name is never localized.
            //

            RtlInitUnicodeString(&KdcAccount,L"krbtgt");
            if (0==RtlCompareUnicodeString(AccountName,&KdcAccount,TRUE))
            {
                Flags |= SAM_GET_MEMBERSHIPS_NO_GC;
            }

            // Do not go to the G.C for DC's and interdomain trust accounts 
            if (((*Buffer)->All.UserAccountControl) & 
                  (USER_SERVER_TRUST_ACCOUNT|USER_INTERDOMAIN_TRUST_ACCOUNT))
            {
                Flags |= SAM_GET_MEMBERSHIPS_NO_GC;
            }

            if (fMixedDomain)
            {
                Flags|= SAM_GET_MEMBERSHIPS_MIXED_DOMAIN;
            }

            //
            // Sp case this DC's computer account
            //

            if ((NULL!=SampComputerObjectDsName) &&
               (0==memcmp(&SampComputerObjectDsName->Guid,
                        &NewContext->ObjectNameInDs->Guid,sizeof(GUID))))
            {
                Flags|= SAM_GET_MEMBERSHIPS_NO_GC;
            }

        
            StartTick = GetTickCount();

            NtStatus = SampGetReverseMembershipTransitive(
                            NewContext,
                            Flags,
                            ReverseMembership
                            );

            EndTick = GetTickCount();

            //
            // We we tried going to the GC and could not reach a GC
            // the above routine returns a special success code 
            // (STATUS_DS_MEMBERSHIP_EVAULATED_LOCALLY ). If the
            // registry flag for allowing logons is not set and if
            // it is not the administrator account then fail the
            // logon with STATUS_NO_LOGON_SERVERS.
            //

            if ((STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY==NtStatus)
                && (!SampIgnoreGCFailures)
                && (DOMAIN_USER_RID_ADMIN!=NewContext->TypeBody.User.Rid))
            {
                if (SampIsGroupCachingEnabled(NewContext)) {
                    NewContext->TypeBody.User.fNoGcAvailable = TRUE;
                    NtStatus = STATUS_SUCCESS;
                } else {
                    NtStatus = STATUS_NO_LOGON_SERVERS;
                }
            }

            if (!NT_SUCCESS(NtStatus))
                goto Error;

            // 
            // Only update on success
            //
            SampUpdateLatencyCounter(&SampAccountGroupsLatencyInfo, EndTick - StartTick);
        }

        //
        // If the caller asked for a user handle, then add one reference to it
        // and pass back the new context
        //

        if (ARGUMENT_PRESENT(UserHandle))
        {
            *UserHandle = NewContext;
            SampReferenceContext(NewContext);

            if (!(Flags & SAM_NO_MEMBERSHIPS)) {
                NewContext->TypeBody.User.fCheckForSiteAffinityUpdate = TRUE;
            }
        }

    }

Error:

    //
    // End Any Open Transactions
    //

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Free the context, if necessary
    //

    if (NewContext)
    {
        // Free the context, ignore any changes.
        if ((ARGUMENT_PRESENT(UserHandle)) && (NT_SUCCESS(NtStatus)))
        {
            IgnoreStatus = SampDeReferenceContext(NewContext,FALSE);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
        else
        {
             SampDeleteContext(NewContext);
             if (ARGUMENT_PRESENT(UserHandle))
             {
                 *UserHandle = NULL;
             }
        }

    }


    if (!NT_SUCCESS(NtStatus))
    {


        //
        // Free the reverse membership information
        //

        if (ReverseMembership->SidAndAttributes)
        {
            SamIFreeSidAndAttributesList(ReverseMembership);
        }

        ReverseMembership->Count = 0;
        ReverseMembership->SidAndAttributes = NULL;

        //
        // Free the User All Information
        //

        if ((NULL!=Buffer)&& (NULL!=*Buffer))
        {
            SamIFree_SAMPR_USER_INFO_BUFFER(*Buffer,UserAllInformation);
            *Buffer=NULL;
        }

    }




    //
    // Decrement the Active Thread Count
    //

    SampDecrementActiveThreads();

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    return NtStatus;

}

NTSTATUS
SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{

    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                0, // which fields
                0, // extended fields
                UserAllInformation, // information class
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}

NTSTATUS
SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields, // which fields
                0, // extended fields
                UserAllInformation, // information class
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}

NTSTATUS
SamIGetUserLogonInformation2(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    OUT PUSER_INTERNAL6_INFORMATION * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields, // which fields
                ExtendedFields, // extended fields
                UserInternal6Information, // information class
                (PSAMPR_USER_INFO_BUFFER *)Buffer,
                ReverseMembership,
                UserHandle
                ));
}

NTSTATUS
SampGetAliasMembershipAsSids(
    IN SAMPR_HANDLE         DomainHandle,
    IN PSAMPR_PSID_ARRAY    SidArray,
    OUT PSAMPR_PSID_ARRAY * Membership
    )
//
// Wrapper for SamrGetAliasMemberships that returns the memberships in
// terms of SID's not RID's
//
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;
    SAMPR_ULONG_ARRAY RidMembership = {0};
    ULONG i;

    *Membership = NULL;


    //
    // Get the memberships
    //
    Status = SamrGetAliasMembership(DomainHandle,
                                    SidArray,
                                    &RidMembership);

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Allocate the return structure
    //
    *Membership = MIDL_user_allocate(sizeof(SAMPR_PSID_ARRAY));
    if (!(*Membership)) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    RtlZeroMemory(*Membership,sizeof(SAMPR_PSID_ARRAY));

    if (RidMembership.Count > 0) {

        (*Membership)->Sids = (PSAMPR_SID_INFORMATION)
                MIDL_user_allocate((RidMembership.Count) * sizeof(SAMPR_SID_INFORMATION));
    
        if (!((*Membership)->Sids)) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    
        //
        // Translate the RID's to sid
        //
        for (i = 0; i < RidMembership.Count; i++) {
    
            Status = SampCreateFullSid(SampDefinedDomains[DomainIndex].Sid,
                                       RidMembership.Element[i],
                                       (PSID*)&((*Membership)->Sids[i].SidPointer));
            if (!NT_SUCCESS(Status)) {
                goto Exit;
            }
            (*Membership)->Count++;
        }
    }

Exit:
    
    if (RidMembership.Element) {
        MIDL_user_free(RidMembership.Element);
    }

    if (!NT_SUCCESS(Status)) {
       SamIFreeSidArray(*Membership);
       *Membership = NULL;
    }

    return Status;
}




NTSTATUS
SamIGetResourceGroupMembershipsTransitive(
    IN SAMPR_HANDLE         DomainHandle,
    IN PSAMPR_PSID_ARRAY    SidArray,
    ULONG                   Flags,
    OUT PSAMPR_PSID_ARRAY * Membership
    )
/*++

   Routine Description

   This routine retrieves the transitive reverse membership of the
   given set of sids in resource groups

   Parameters

        DomainHandle -- Handle to Domain object

        SidArray   -- Set of Sids whose reverse membership needs to
                     be evaluated

        Flags     -- Flags to control operation of the routine.
                     
        SAM_SERVICE_TARGET_IS_DC
        
            Caller is indicating that a service ticket for DC is being 
            created.  In this case during mixed mode, the non-transitive
            domain localgroups are retrieved.  These groups are retrieved
            at this time because if the resulting token is created on a 
            DC with the native mode bit set then the local groups won't 
            be evaluated during SamIGetAliasMembership
            
            
        Membership -- Returned reverse membership set


   Return Values

        STATUS_SUCCESS
        Other error codes to indicate resource failures

--*/
{
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT) DomainHandle;
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    PDSNAME         *ResolvedNames=NULL;
    PDSNAME         *pMemberships=NULL;
    PSID            *pSidHistory=NULL;
    ULONG           cMemberships=0;
    ULONG           cSidHistory=0;
    BOOLEAN         fMixedDomain = FALSE;
    ULONG           i=0;
    ULONG           StartTick, EndTick;

    //
    // Not necessary to grab the lock for referring to IsMixedDomain in  
    // the defined domains array. 
    //

    fMixedDomain = SampDefinedDomains[DomainContext->DomainIndex].IsMixedDomain;

    if (SampUseDsData &&
        fMixedDomain  && 
       (Flags & SAM_SERVICE_TARGET_IS_DC)) {

        //
        // For mixed domains, place the one level domain local groups
        // in the service ticket for DC's since if the ticket is recieved
        // on a DC with the native mode bit set (due to replication latency)
        // local group evaluation won't take place and thus the resulting
        // token will be missing groups.
        //

        return (SampGetAliasMembershipAsSids(DomainHandle,SidArray,Membership));

    }
   
    //
    // This routine executes without any locks held and therefore
    // is vulnerable for the database to be shut down while executng
    // database queries. Therefore update state saying that we are
    // executing so that the shutdown code waits for us.
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;


    //
    // Reference the context while we are using it.
    //

    SampReferenceContext(DomainContext);




    *Membership = MIDL_user_allocate(sizeof(SAMPR_PSID_ARRAY));
    if (NULL==*Membership)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Initialize Return Values
    //

    RtlZeroMemory(*Membership,sizeof(SAMPR_PSID_ARRAY));

    //
    // If we are not in DS mode then return right away. Do not
    // merge in any memberships we are still O.K without it
    // Note we are returning a STATUS_SUCCESS , with no memberhships

    if (!SampUseDsData)
    {
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (fMixedDomain)
    {
        //
        // Nothing to Do, just bail
        //
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    //
    // Convert the SIDS to SID only DS Names
    //

    NtStatus = SampDsResolveSids(
                    (PSID) SidArray->Sids,
                    SidArray->Count,
                    RESOLVE_SIDS_SID_ONLY_NAMES_OK,
                    &ResolvedNames
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // begin a read only transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Get the resource group memberships
    //

    StartTick = GetTickCount();

    NtStatus = SampGetMemberships(
                    ResolvedNames,
                    SidArray->Count,
                    DomainContext->ObjectNameInDs,
                    RevMembGetResourceGroups,
                    &cMemberships,
                    &pMemberships,
                    NULL,
                    &cSidHistory,
                    &pSidHistory
                    );

    EndTick = GetTickCount();

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Only update on success
    //
    SampUpdateLatencyCounter(&SampResourceGroupsLatencyInfo, EndTick - StartTick);


    //
    // Merge in the SIDs and Sid Histories into the
    // SAMPR_PSID_ARRAY
    //

    (*Membership)->Sids = (PSAMPR_SID_INFORMATION)
            MIDL_user_allocate((cMemberships+cSidHistory) * sizeof(PRPC_SID));
    if (NULL==(*Membership)->Sids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // First the  Sids
    //

    for (i=0;i<cMemberships;i++)
    {
        (*Membership)->Sids[(*Membership)->Count].SidPointer
            = (PSID)MIDL_user_allocate(pMemberships[i]->SidLen);
        if (NULL==((*Membership)->Sids[i].SidPointer))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory((*Membership)->Sids[i].SidPointer,
                      &pMemberships[i]->Sid,
                      pMemberships[i]->SidLen
                      );
        (*Membership)->Count++;
    }


    //
    // Then the SID History
    //

    for (i=0;i<cSidHistory;i++)
    {
        (*Membership)->Sids[(*Membership)->Count].SidPointer
            = (PSID) MIDL_user_allocate(RtlLengthSid(pSidHistory[i]));
        if (NULL==((*Membership)->Sids[(*Membership)->Count].SidPointer))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory((*Membership)->Sids[(*Membership)->Count].SidPointer,
                      pSidHistory[i],
                      RtlLengthSid(pSidHistory[i])
                      );
        (*Membership)->Count++;
    }






Error:

    //
    // End Any Open Transactions in DS mode.
    //

    if (SampUseDsData)
    {
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Perform any necessary cleanup
    //

    if (NULL!=ResolvedNames)
    {
        for (i=0; i<SidArray->Count;i++)
        {
            if (NULL!=ResolvedNames[i])
            {
                MIDL_user_free(ResolvedNames[i]);
            }

        }

        MIDL_user_free(ResolvedNames);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        SamIFreeSidArray(*Membership);
        *Membership = NULL;
    }

    SampDeReferenceContext2(DomainContext,FALSE);

    //
    // Decrement the Active Thread Count
    //

    SampDecrementActiveThreads();

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return NtStatus;

}


NTSTATUS
SamIOpenAccount(
    IN SAMPR_HANDLE         DomainHandle,
    IN ULONG                AccountRid,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    OUT SAMPR_HANDLE        *AccountHandle
    )
/*++

    Given a Domain Handle and the Rid of the Account, this routine opens
    an account handle for that account. All the properties of the account are prefetched
    into the handle, to make subsequent SAM queries faster . The Handle is marked with
    all access.


    Parameters:

        DomainHandle --- Handle to the Domain in which the account is to be opened.
        AccountRid   --- The Rid of the account
        ObjectType   --- The type of the object. Must be a SAM account object type, else status
                         invalid parameter would be retunred
        AccountHandle -- Handle to the account

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
        Other Error codes to indicate Various error conditions

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_OBJECT_TYPE    SamObjectType;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT)DomainHandle;
    PSAMP_OBJECT        NewContext = NULL;
    ACCESS_MASK         AllAccess;
    DSNAME              *AccountObject = NULL;
    PSID                AccountSid = NULL;
    PSID                DomainSid = NULL;
    NTSTATUS            NotFoundStatus = STATUS_INTERNAL_ERROR;
   
    //
    // Translate Security DB object Types to SAM object Types
    //
    switch (ObjectType)
    {
    case SecurityDbObjectSamUser:
            SamObjectType = SampUserObjectType;
            AllAccess     = USER_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_USER;
            break;

    case SecurityDbObjectSamGroup:
            SamObjectType = SampGroupObjectType;
            AllAccess     = GROUP_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_GROUP;
            break;

    case SecurityDbObjectSamAlias:
            SamObjectType = SampAliasObjectType;
            AllAccess     = ALIAS_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_ALIAS;
            break;

    default:

            return(STATUS_INVALID_PARAMETER);
    }

    //
    // This routine executes without any locks held and therefore
    // is vulnerable for the database to be shut down while executng
    // database queries. Therefore update state saying that we are
    // executing so that the shutdown code waits for us.
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    //
    // If we are in Registry Mode then call Sam Open Account.
    // Do the Same for the Builtin Domain
    //

    SampReferenceContext(DomainContext);
    DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;

    if ((IsBuiltinDomain(DomainContext->DomainIndex)) || (!IsDsObject(DomainContext)))
    {
        
        SampDeReferenceContext2(DomainContext,FALSE);

        SampDecrementActiveThreads();

        return(SampOpenAccount(
                    SamObjectType,
                    DomainHandle,
                    AllAccess,
                    AccountRid,
                    FALSE,
                    AccountHandle
                    ));
    }


    //
    // We are in DS mode and are not the builtin domain. Perform a fast open and 
    // mark the context as thread safe
    //

    NtStatus = SampCreateFullSid(DomainSid,AccountRid,&AccountSid);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Create a Context for the account Object
    //


    NewContext = SampCreateContextEx(
                    SamObjectType,
                    TRUE, // Trusted Client
                    TRUE, // DS mode
                    TRUE, // Thread Safe
                    DomainContext->LoopbackClient, // Loopback Client
                    TRUE, // Lazy Commit
                    TRUE, // PersisAcrossCalls
                    FALSE,// BufferWrites
                    FALSE,// Opened By DCPromo
                    DomainContext->DomainIndex
                    );

    if (NULL==NewContext)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

   
   
    //
    // Construct a SID only DS Name based on the passed in Account Rid
    //

     AccountObject = MIDL_user_allocate(sizeof(DSNAME));
     if (NULL==AccountObject)
     {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto Error;
     }


    
    RtlZeroMemory(AccountObject,sizeof(DSNAME));
    RtlCopyMemory(&AccountObject->Sid,AccountSid,RtlLengthSid(AccountSid));
    AccountObject->SidLen = RtlLengthSid(AccountSid);
    AccountObject->structLen = DSNameSizeFromLen(0);


    //
    // Initialize the DS object portion on the new context.
    //

    NewContext->ObjectNameInDs = AccountObject;
    NewContext->DomainIndex = DomainContext->DomainIndex;
    NewContext->GrantedAccess = AllAccess;
    SetDsObject(NewContext);


    //
    // Prefetch all properties after checking Object type
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampDsCheckObjectTypeAndFillContext(
                        SamObjectType,
                        NewContext,
                        0,
                        0,
                        FALSE // override local group check
                        );
    //
    // If We got a name error then reset the failure
    // status to object not found
    //
 
    if ((STATUS_OBJECT_NAME_INVALID==NtStatus)
         || (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus))
    {
        NtStatus = NotFoundStatus;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;
    
    //
    // Set the Rid
    //

    switch (ObjectType)
    {
    case SecurityDbObjectSamUser:
            
            NewContext->TypeBody.User.Rid = AccountRid;
            break;

    case SecurityDbObjectSamGroup:
         
            NewContext->TypeBody.Group.Rid = AccountRid;
            break;

    case SecurityDbObjectSamAlias:
           
            NewContext->TypeBody.Alias.Rid = AccountRid;
            break;

    default:

            ASSERT(FALSE && "Should Never Hit Here");
            break;
     }


     *AccountHandle = NewContext;
     

Error:

     if ((!NT_SUCCESS(NtStatus)) && (NULL!=NewContext))
     {
         SampDeleteContext(NewContext);
     }

     SampDeReferenceContext2(DomainContext,FALSE);

     //
     // End all Open Transactions
     //

     SampMaybeEndDsTransaction(TransactionCommit);

     if (NULL!=AccountSid)
     {
         MIDL_user_free(AccountSid);
     }

     SampDecrementActiveThreads();

     return NtStatus;
     
}





NTSTATUS
SamIGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )
/*++

  Routine Description.

  In process version of SamrGetAliasMembership. Does different things
  for mixed mode, registry mode vs native mode.

  Parameters

    Same As SamrGetAliasMembership

  Return Values

    Same As SamrGetAliasMembership

--*/
{

    ULONG DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;

    if ( (!SampUseDsData)
        || (SampDefinedDomains[DomainIndex].IsMixedDomain )
        || (SampDefinedDomains[DomainIndex].IsBuiltinDomain))

    {
        //
        // Do exactly what SamrGetAliasMembership did
        //

        return (SamrGetAliasMembership(DomainHandle,SidArray,Membership));
    }
    else
    {
        //
        // return a 0 length membership
        //

        Membership->Count = 0;
        Membership->Element = NULL;

    }


    return(STATUS_SUCCESS);
}


NTSTATUS
SamINetLogonPing(
    IN  SAMPR_HANDLE    DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT BOOLEAN *       AccountExists,
    OUT PULONG          UserAccountControl
    )
/*++
Routine Description:

    This routine will based on a Domain Handle and on the account name will
    tell if the account exists and return the user account control.
    
Parameters:

    DomainHandle - The domain where the account name can be found
    
    AccountName - The account name for which to find the useraccountcontrol
    
    AccountExists - This will tell the call if the account exists or not
    
    UserAccountControl - This will have the return of the useraccountcontrol

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    
--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    DWORD    DsErr  = 1;
    BOOL     IncrementedThreads = FALSE;
    ULONG    UserFlags = 0;

    //make sure that we are not in sam registry mode
    if (!SampUseDsData)
    {
        status = STATUS_NOT_SUPPORTED;    
        goto cleanup;
    }

    if (!SampValidateRpcUnicodeString((PRPC_UNICODE_STRING)AccountName)) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    status = SampIncrementActiveThreads();
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    } else {
        IncrementedThreads = TRUE;
    }

    if ( !THQuery() ) {
        DsErr = THCreate(CALLERTYPE_SAM);
        if (0!=DsErr)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    }

    status = SampNetlogonPing(SampDefinedDomains[((PSAMP_OBJECT)DomainHandle)->DomainIndex].DsDomainHandle,
                              AccountName,
                              AccountExists,
                              &UserFlags
                              );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = SampFlagsToAccountControl(UserFlags,
                                       UserAccountControl);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    cleanup:

    if (0==DsErr) {
        THDestroy();
    }

    if ( TRUE == IncrementedThreads ) {
        SampDecrementActiveThreads();
    }

    return status;


}

NTSTATUS
SamIUPNFromUserHandle(
    IN  SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    )

/*++

    This is a simple helper routine to efficiently return the UPN given a user handle

    Parameters are as follows

    UserHandle -- Handle to the user object
    UPNDefaulted -- Boolean indicates that the UPN has been defaulted
    UPN          -- Unicode string returning the UPN

--*/
{
    PSAMP_OBJECT UserContext = (PSAMP_OBJECT) UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             ContextReferenced = FALSE;
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    BOOLEAN             fLockAcquired = FALSE;


    SampMaybeAcquireReadLock(UserHandle, DEFAULT_LOCKING_RULES,&fLockAcquired);

    NtStatus = SampLookupContext(
                    UserContext,
                    0,
                    SampUserObjectType,
                    &FoundType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ContextReferenced = TRUE;

    UPN->Length = UserContext->TypeBody.User.UPN.Length;
    UPN->MaximumLength = UserContext->TypeBody.User.UPN.Length;

    UPN->Buffer = MIDL_user_allocate(UPN->Length);
    if (NULL==UPN->Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlCopyMemory(
            UPN->Buffer,
            UserContext->TypeBody.User.UPN.Buffer,
            UPN->Length
            );

    *UPNDefaulted =  UserContext->TypeBody.User.UpnDefaulted;

Error:

    if (ContextReferenced)
    {
        SampDeReferenceContext(UserContext, FALSE);
    }

    SampMaybeReleaseReadLock(fLockAcquired);

    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\usrparms.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    usrparms.c

Abstract:

    This file contains services which convert SAM user object's UserParameters 
    Attribute to a DSATTRBLOCK structure. 
    The steps involved: 
        1. call each notification package to get client-specified SAM_USERPARMS_ATTRBLOCK,
        2. convert SAM_USERPARMS_ATTRBLOCK to DSATTRBLOCK

Author:

    Shaohua Yin      (ShaoYin)    15-August-1998

Environment:

    User Mode - Win32

Revision History:


--*/



#include <samsrvp.h>
#include <attids.h>
#include <nlrepl.h>
#include <dbgutilp.h>
#include <dsutilp.h>
#include <mappings.h>
#include "notify.h"



ULONG   InvalidDsAttributeTable[] =
{
    DS_ATTRIBUTE_UNKNOWN,
    ATT_SAM_ACCOUNT_NAME
};


// extern from credman.cxx
NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN ULONG ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    );
    
    
    
    
//////////////////////////////////////////////////////////////
//                                                          //
// Private service routines                                 // 
//                                                          //
//////////////////////////////////////////////////////////////

NTSTATUS 
SampUserParmsAttrBlockHealthCheck(
    IN PSAM_USERPARMS_ATTRBLOCK  AttrBlock
    )
    
/*++

Routine Dsscription:

    This routine will do the health check on AttrBlock, including: all Attribute is valid, 
    EncryptedAttribute's AttributeIdentifier is valid. 
    
Arguments:

    AttrBlock - pointer to SAM_USERPARMS_ATTRBLOCK structure
    
Return Values:

    STATUS_SUCCESS - AttrBlock is valid.
    
    STATUS_INVALID_PARAMETER - invalid AttrBlock.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index, i;
    ULONG       DsAttrId;
    
    
    SAMTRACE("SampUserParmsAttrBlockHealthCheck");
    
    ASSERT(AttrBlock);
    
    if (NULL == AttrBlock)
    {
        return NtStatus;
    }
    
    if (AttrBlock->attCount)
    {
        if (NULL == AttrBlock->UserParmsAttr)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto HealthCheckError;
        }
    }
    
    for (Index = 0; Index < AttrBlock->attCount; Index++ )
    {
        if (Syntax_Attribute == AttrBlock->UserParmsAttr[Index].Syntax)
        {
            DsAttrId = SampGetDsAttrIdByName(AttrBlock->UserParmsAttr[Index].AttributeIdentifier);
        
            for (i = 0; i < ARRAY_COUNT(InvalidDsAttributeTable); i++)
            {
                if (DsAttrId == InvalidDsAttributeTable[i])
                {
                    NtStatus = STATUS_INVALID_PARAMETER;
                    goto HealthCheckError;
                }
            }
        }
        else 
        {
            ASSERT(Syntax_EncryptedAttribute == AttrBlock->UserParmsAttr[Index].Syntax);
            
            if (0 == AttrBlock->UserParmsAttr[Index].AttributeIdentifier.Length ||
                NULL == AttrBlock->UserParmsAttr[Index].AttributeIdentifier.Buffer ||
                1 < AttrBlock->UserParmsAttr[Index].CountOfValues)
            {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto HealthCheckError;
            }
        }
    }
        
HealthCheckError:

    return NtStatus;
        
}



NTSTATUS
SampScanAttrBlockForConflict(
    IN PDSATTRBLOCK DsAttrBlock,
    IN PDSATTRBLOCK UserParmsAttrBlock
    )
    
/*++
    
Routine Description:

    This routine checks two DSATTRBLOCK structures, search for any conflict - duplicate set operation 

Arguments:
    
    DsAttrBlock - Pointer, to DSATTRBLOCK 
    
    UserParmsAttrBlock - Pointer, to DSATTRBLOCK

Return Values:

    NtStatus
    
--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG UserParmsIndex, DsIndex;
    
    
    SAMTRACE("SampScanAttrBlockForConflict");
    
    if ((NULL == DsAttrBlock) || (NULL == UserParmsAttrBlock))
    {
        return NtStatus;
    }

    for (UserParmsIndex = 0; UserParmsIndex < UserParmsAttrBlock->attrCount; UserParmsIndex++)
    {
        for (DsIndex = 0; DsIndex < DsAttrBlock->attrCount; DsIndex++)
        {
            if (UserParmsAttrBlock->pAttr[UserParmsIndex].attrTyp == DsAttrBlock->pAttr[DsIndex].attrTyp)
            {
                // conflict
                NtStatus = STATUS_INVALID_PARAMETER;
                return NtStatus;
            }
        }
    }
    
    return NtStatus;
}




VOID
SampFreeSupplementalCredentialList(
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialList
    )
    
/*++

Routine Description:
    
    This routine releases the link-list which contains all supplemental credentials.

Arguments: 

    SupplementalCredentialsList - Pointer, to the link-list

Return Values: 

    None.

--*/

{
    ULONG     Index;   
    PSAMP_SUPPLEMENTAL_CRED TmpCredential = NULL;
    PSAMP_SUPPLEMENTAL_CRED NextCredential = NULL;
    
    SAMTRACE("SampFreeSupplementalCredentialList");
   
    TmpCredential = SupplementalCredentialList;
    
    while (TmpCredential)
    {
        NextCredential = TmpCredential->Next;    

        RtlFreeUnicodeString(&(TmpCredential->SupplementalCred.PackageName));
        
        if (TmpCredential->SupplementalCred.Credentials)
        {
            MIDL_user_free(TmpCredential->SupplementalCred.Credentials);
        }
        
        MIDL_user_free(TmpCredential);
        
        TmpCredential = NextCredential;
    }
    
    return;
}


NTSTATUS
SampAddSupplementalCredentialsToList(
    IN OUT PSAMP_SUPPLEMENTAL_CRED *SupplementalCredentialList,
    IN PUNICODE_STRING PackageName,
    IN PVOID           CredentialData,
    IN ULONG           CredentialLength,
    IN BOOLEAN         ScanForConflicts,
    IN BOOLEAN         Remove
    )
/*++

    Routine Description

    This routine adds a supplemental credential specified by package name and data
    to the list of supplemental credentials

    Arguments

    SupplementalCredentialList -- doubly linked list of supplemental credentials
    PackageName                -- Name of the package
    CredentialData             -- Pointer to the data in the supplemental credential
    CredentialLength           -- Length of the credential Data

    Return Values

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SUPPLEMENTAL_CRED TmpList = *SupplementalCredentialList;
    PSAMP_SUPPLEMENTAL_CRED NewItem=NULL;

    //
    // First scan the list for conflicts
    //

    while ((NULL != TmpList) && (ScanForConflicts))
    {
        if ( RtlEqualUnicodeString(&(TmpList->SupplementalCred.PackageName),
                                   PackageName,
                                   TRUE   // Case Insensitive
                                   ))
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        TmpList = TmpList->Next;
    }
        

    //
    // Allocate space for a new item in the list
    //

    NewItem = MIDL_user_allocate( sizeof(SAMP_SUPPLEMENTAL_CRED) );
    if ( NULL == NewItem )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    RtlZeroMemory(NewItem, sizeof(SAMP_SUPPLEMENTAL_CRED));


    //
    // Copy the package name
    //
     
    if (!RtlCreateUnicodeString(&(NewItem->SupplementalCred.PackageName),
                           PackageName->Buffer)
       )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    if (Remove)
    {
        NewItem->Remove = Remove;
    }
    else
    {

        //
        // Set the length
        //

        NewItem->SupplementalCred.CredentialSize = CredentialLength;
    

        //
        // Allocate space and copy over the credentials if the length is non zero.
        //

        if (CredentialLength)
        {
            NewItem->SupplementalCred.Credentials = MIDL_user_allocate( CredentialLength ); 
   
            if (NULL == NewItem->SupplementalCred.Credentials)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
            RtlZeroMemory(NewItem->SupplementalCred.Credentials, CredentialLength);
                     
            RtlCopyMemory(NewItem->SupplementalCred.Credentials, 
                          CredentialData,
                          CredentialLength
                          );
        }
    }
                        
    //
    // Insert in front of the list
    //

    NewItem->Next = *SupplementalCredentialList;
    (*SupplementalCredentialList) = NewItem;

Error:

    if ((!NT_SUCCESS(NtStatus)) && (NULL!=NewItem))
    {
        //
        // Error'd out in the middle, ensure that new item is completely freed
        //

        SampFreeSupplementalCredentialList(NewItem);
    }

    return(NtStatus);
}

NTSTATUS
SampMergeDsAttrBlocks(
    IN PDSATTRBLOCK FirstAttrBlock,
    IN PDSATTRBLOCK SecondAttrBlock,
    OUT PDSATTRBLOCK * AttrBlock
    )
    
/*++

Routine Description:
    
    This routine will concatenate FirstAttrBlock and SecondAttrBlock.  
    return AttrBlock as concatenated result.

Arguments: 

    FirstAttrBlock - Pointer, the DSATTRBLOCK containing partial attributes.
    
    SecondAttrBlock - Pointer, the DSATTRBLOCK containing partial attributes.
    
    AttrBlock - Pointer, the DSATTRBLOCK containing all attributes from FirstAttrBlock and 
                SecondAttrBlock, 
                if routine success, AttrBlock will hold the concatenated attributes block.
                and release memory which is occupied by FirstAttrBlock and SecondAttrBlock.
                if routine Failure, nothing changed.
                  
Return Values: 

    STATUS_SUCCESS - AttrBlock hold the concatenated result, FirstAttrBlock and SecondAttrBlock
                     have been freed. 
                     
    STATUS_NO_MEMORY - the only error case, AttrBlock = NULL, nothing changed.

--*/

{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    ULONG        firstIndex, secIndex, Index;
    ULONG        AttrCount;
    
    
    SAMTRACE("SampMergeDsAttrBlocks");
    
    // 
    // caller must pass us at least one attribute block
    // 
    ASSERT(NULL != FirstAttrBlock || NULL != SecondAttrBlock);
    
    if (NULL == FirstAttrBlock)
    {
        *AttrBlock = SecondAttrBlock;
        return NtStatus;
    }
    
    if (NULL == SecondAttrBlock)
    {
        *AttrBlock = FirstAttrBlock;
        return NtStatus;
    }
    
    *AttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) );
                                   
    if (NULL == *AttrBlock)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto MergeAttrBlockError;
    }
    
    RtlZeroMemory(*AttrBlock, sizeof(DSATTRBLOCK));
    
    AttrCount = FirstAttrBlock->attrCount + SecondAttrBlock->attrCount;    
    
    (*AttrBlock)->attrCount = AttrCount;
    (*AttrBlock)->pAttr = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
                                          
    if (NULL == (*AttrBlock)->pAttr)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto MergeAttrBlockError;
    }
                 
    RtlZeroMemory((*AttrBlock)->pAttr, (AttrCount * sizeof(DSATTR)));                 
    
    Index = 0;
     
    for (firstIndex = 0; firstIndex < FirstAttrBlock->attrCount; firstIndex++)
    {
        (*AttrBlock)->pAttr[Index].attrTyp = 
                        FirstAttrBlock->pAttr[firstIndex].attrTyp;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.valCount =
                        FirstAttrBlock->pAttr[firstIndex].AttrVal.valCount;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.pAVal = 
                        FirstAttrBlock->pAttr[firstIndex].AttrVal.pAVal;
                        
        Index++;
    }
    
    for (secIndex = 0; secIndex < SecondAttrBlock->attrCount; secIndex++)
    {
        (*AttrBlock)->pAttr[Index].attrTyp = 
                        SecondAttrBlock->pAttr[secIndex].attrTyp;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.valCount =
                        SecondAttrBlock->pAttr[secIndex].AttrVal.valCount;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.pAVal = 
                        SecondAttrBlock->pAttr[secIndex].AttrVal.pAVal;
                        
        Index++;
    }
    
    ASSERT(Index == AttrCount);
    
    if (FirstAttrBlock->pAttr)
    {
        MIDL_user_free(FirstAttrBlock->pAttr);
    }
    if (SecondAttrBlock->pAttr)
    {
        MIDL_user_free(SecondAttrBlock->pAttr);
    }
    MIDL_user_free(FirstAttrBlock);
    MIDL_user_free(SecondAttrBlock);
    
    
    return NtStatus;
    
    
MergeAttrBlockError:

    
    if (*AttrBlock)
    {
        if ((*AttrBlock)->pAttr)
        {
            MIDL_user_free((*AttrBlock)->pAttr);
            (*AttrBlock)->pAttr = NULL;
        }
        
        MIDL_user_free(*AttrBlock);
        *AttrBlock = NULL;
    }
    
    return NtStatus;
    
}




NTSTATUS
SampAppendAttrToAttrBlock(
    IN ATTR CredentialAttr,
    IN OUT PDSATTRBLOCK * DsAttrBlock
    )

/*++

Routine Description:

    This routine will append the CredentialAttr at the end of DsAttrBlock. 
    Actually, what we do is: create a new DsAttrBlock, copy the old attribute block and 
    add the CredentialAttr.

Arguments:

    CredentialAttr - hold the credential attribute to set.
    
    DsAttrBlock - pointer to the old DS attribute block which need to be appended. 
                  also used to return the new DS attribute block.
                  
                  it could point to NULL when passed in.

Return Values:

    STATUS_SUCCESS
    
    STATUS_NO_MEMORY

--*/

{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PDSATTRBLOCK TmpAttrBlock = NULL;
    ULONG        AttrCount;
    
    SAMTRACE("SampAppendAttrToAttrBlock");
    
    TmpAttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) );
                                   
    if (NULL == TmpAttrBlock)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto AppendError;
    }
    
    RtlZeroMemory(TmpAttrBlock, sizeof(DSATTRBLOCK));
    
    AttrCount = 1;          // for the append attribute
    
    if (*DsAttrBlock)
    {
        AttrCount += (*DsAttrBlock)->attrCount;
    }
    
    TmpAttrBlock->attrCount = AttrCount;
    TmpAttrBlock->pAttr = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
                                          
    if (NULL == TmpAttrBlock->pAttr)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto AppendError;
    }
    
    RtlZeroMemory(TmpAttrBlock->pAttr, AttrCount * sizeof(DSATTR));
    
    if (*DsAttrBlock)
    {
        RtlCopyMemory(TmpAttrBlock->pAttr, 
                      (*DsAttrBlock)->pAttr, 
                      (*DsAttrBlock)->attrCount * sizeof(DSATTR)
                      );
    }
                  
    TmpAttrBlock->pAttr[AttrCount - 1].attrTyp = CredentialAttr.attrTyp;
    TmpAttrBlock->pAttr[AttrCount - 1].AttrVal.valCount = CredentialAttr.AttrVal.valCount;
    TmpAttrBlock->pAttr[AttrCount - 1].AttrVal.pAVal = CredentialAttr.AttrVal.pAVal;
    
    if (*DsAttrBlock)
    {
        if ((*DsAttrBlock)->pAttr)
        {
            MIDL_user_free((*DsAttrBlock)->pAttr);
            (*DsAttrBlock)->pAttr = NULL;
        }
        
        MIDL_user_free(*DsAttrBlock);
    }
    
    *DsAttrBlock = TmpAttrBlock;
    
    
AppendFinish:

    return NtStatus;    


AppendError:

    if (TmpAttrBlock)
    {
        if (TmpAttrBlock->pAttr)
        {
            MIDL_user_free(TmpAttrBlock->pAttr);
        }
        
        MIDL_user_free(TmpAttrBlock);
    }
    
    goto AppendFinish;
}





NTSTATUS
SampConvertUserParmsAttrBlockToDsAttrBlock(
    IN PSAM_USERPARMS_ATTRBLOCK UserParmsAttrBlock,
    OUT PDSATTRBLOCK * DsAttrBlock,
    IN OUT PSAMP_SUPPLEMENTAL_CRED * SupplementalCredentials
    )

/*++

Routine Description:
    
    This routine will scan a SAM_USERPARMS_ATTRBLOCK, converts that structure to 
    DSATTRBLOCK structure, and put and EncrypedAttribute in SAM_USERPARMS_ATTRBLOCK
    into the SupplementalCredentials link-list

Arguments:
    
    UserParmsAttrBlock - pointer to a PSAM_USERPARMS_ATTRBLOCK structure.
    
    DsAttrBlock - return a DSATTRBLOCK, which is converted from UserParmsAttrBlock
    
    SupplementalCredentials - link list, hold all EncrypedAttributes

Return Values:

    STATUS_SUCCESS - this routine finished successfully, 
    
    STATUS_NO_MEMROY - no resoures.
    
    STATUS_INVALID_PARAMETERS - duplicate credential identifier, means duplicate
                                supplemental credential tag (package name) 

--*/

{
    
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSATTR  Attributes = NULL;
    ULONG    AttrCount;
    ULONG    Index, valIndex, dsAttrIndex;
    ULONG    size; 
    ULONG    CredSize;
    
    
    SAMTRACE("SampConvertUserParmsAttrBlockToDsAttrBlock");
    
    
    ASSERT(UserParmsAttrBlock);
    
     
    //
    // calculate the Attribute Count exclude Encrypted Attributes;
    //
    AttrCount = UserParmsAttrBlock->attCount;
    
    for (Index = 0; Index < UserParmsAttrBlock->attCount; Index++)
    {
        if (Syntax_EncryptedAttribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax)
        {
            AttrCount--;
        }
    }
    
    //
    // Allocate Memory for DSATTRBLOCK structure; if AttrCount > 0
    //    
    if (0 < AttrCount)
    {
        *DsAttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) ); 
    
        if (NULL == *DsAttrBlock)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto ConvertUserParmsAttrBlockError;
        }
    
        RtlZeroMemory(*DsAttrBlock, sizeof(DSATTRBLOCK));
    
        Attributes = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
    
        if (NULL == Attributes)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto ConvertUserParmsAttrBlockError;
        }
        
        RtlZeroMemory(Attributes, AttrCount * sizeof(DSATTR));
    
        (*DsAttrBlock)->attrCount = AttrCount;
        (*DsAttrBlock)->pAttr = Attributes; 
    }
    
    // 
    // Fill the DSATTRBLOCK structure or add an Encrypted Attribute to the beginning of 
    // the Supplemental Credential List.
    //
    dsAttrIndex = 0;
    
    for ( Index = 0; Index < UserParmsAttrBlock->attCount; Index++)
    {
        ULONG   valCount = UserParmsAttrBlock->UserParmsAttr[Index].CountOfValues;

        if (Syntax_Attribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax)
        {
            // 
            // fill a new attribute to DsAttrBlock
            //
            
            // get the DS Attribute type (ID)
            Attributes[dsAttrIndex].attrTyp = 
                        SampGetDsAttrIdByName(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier);
                                                   
            if ((1 == valCount) &&
                (0 == UserParmsAttrBlock->UserParmsAttr[Index].Values[0].length) &&
                (NULL == UserParmsAttrBlock->UserParmsAttr[Index].Values[0].value))
            {
                valCount = 0;
            }
                                                   
            Attributes[dsAttrIndex].AttrVal.valCount = valCount;

            if (0 == valCount)
            {
                Attributes[dsAttrIndex].AttrVal.pAVal = NULL;
            }
            else
            {
                Attributes[dsAttrIndex].AttrVal.pAVal = MIDL_user_allocate(
                                                            valCount * sizeof (DSATTRVAL)
                                                            );

                if (NULL == Attributes[dsAttrIndex].AttrVal.pAVal)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    goto ConvertUserParmsAttrBlockError;
                }
            
                RtlZeroMemory(Attributes[dsAttrIndex].AttrVal.pAVal, 
                              valCount * sizeof(DSATTRVAL)
                              );
            }
            
            for (valIndex = 0; valIndex < valCount; valIndex++)
            {
                Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen =
                        UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].length;
                        
                if (Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen) 
                {
                    Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal = MIDL_user_allocate( 
                                                                                 Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen
                                                                                 );
                                                                     
                    if (NULL == Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal)
                    {
                        NtStatus = STATUS_NO_MEMORY;
                        goto ConvertUserParmsAttrBlockError;
                    }
                
                    RtlZeroMemory(Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal,
                                  Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen
                                  );
                              
                    RtlCopyMemory(Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal,
                                  UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].value,
                                  UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].length
                                  );
                }
            }
            dsAttrIndex++;
        }
        else 
        {
            ASSERT(Syntax_EncryptedAttribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax);
            
            //
            // Create a linked list of supplemental credentials
            //
            
            if (1 == valCount)
            {
                NtStatus = SampAddSupplementalCredentialsToList(
                                SupplementalCredentials,
                                &(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier),
                                UserParmsAttrBlock->UserParmsAttr[Index].Values[0].value,
                                UserParmsAttrBlock->UserParmsAttr[Index].Values[0].length,
                                TRUE, // scan for conflicts
                                FALSE // remove
                                );
            }
            else if (0 == valCount)
            {
                // this is a deletion

                NtStatus = SampAddSupplementalCredentialsToList(
                                SupplementalCredentials,
                                &(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier),
                                NULL,       // value
                                0,          // value length
                                TRUE,       // scan for conflicts
                                FALSE       // remove
                                );
            }
            else
            {
                ASSERT(FALSE && "invalid parameter");
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                 goto ConvertUserParmsAttrBlockError;
            }            
        }
             
    }
    
    ASSERT(dsAttrIndex == AttrCount);
    
ConvertUserParmsAttrBlockFinish:
    
    return NtStatus;
        
    
ConvertUserParmsAttrBlockError:

    if (*DsAttrBlock)
    {
        SampFreeAttributeBlock(*DsAttrBlock);
        *DsAttrBlock = NULL;
    }
    
    goto ConvertUserParmsAttrBlockFinish;

}



NTSTATUS
SampConvertUserParmsToDsAttrBlock(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN PSID  DomainSid,
    IN ULONG ObjectRid,
    IN ULONG UserParmsLengthOrig,
    IN PVOID UserParmsOrig,
    IN ULONG UserParmsLengthNew, 
    IN PVOID UserParmsNew, 
    IN PDSATTRBLOCK InAttrBlock,
    OUT PDSATTRBLOCK * OutAttrBlock
    )

/*++

Routine Description:

    This routine passes the User Parameters to Notification Package, convert the 
    User Parms to Attributes Block.
    
Arguments: 
    
    Context   - Pointer to SAM user object's context block.
    
    Flags     - Indicate we are in Upgrade process or down-lever SAM API.
                by setting SAM_USERPARMS_DURING_UPGRADE bit.
                
    DomainSid - Pointer, the user object's parent Domain SID
    
    ObjectRid - this user object's RID
    
    UserParmsLengthOrig - Length of the original User Parameters, 
    
    UserParmsOrig - Pointer to the original User Parmameters, 
    
    UserParmsLengthNew - Lenghth of the new User Parameters, 
    
    UserParmsNew - Pointer to the new User Parameters,
    
    AttrBlock - Pointer, the returned DS attribute structure.
    
Return Value:

    STATUS_SUCCESS - complete successfully.
    
    STATUS_NO_MEMORY - no resources
    
    STATUS_INVALID_PARAMETER - Notification Package trying to set invalid attribute 
    
--*/
 
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_NOTIFICATION_PACKAGE Package = NULL;
    PDSATTRBLOCK DsAttrBlock = NULL;
    PDSATTRBLOCK PartialDsAttrBlock = NULL;
    PDSATTRBLOCK TmpDsAttrBlock = NULL;
    PSAM_USERPARMS_ATTRBLOCK UserParmsAttrBlock = NULL;
    PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials = NULL;
    ATTR         CredentialAttr;
    
    
    SAMTRACE("SampConvertUserParmsToDsAttrBlock");
    
    // 
    // initialize
    //
    memset((PVOID) &CredentialAttr, 0, sizeof(ATTR));
    
    Package = SampNotificationPackages;

    if (ARGUMENT_PRESENT(Context))
    {
        SupplementalCredentials = Context->TypeBody.User.SupplementalCredentialsToWrite;
    }

    while (Package != NULL) 
    {
        if ( Package->UserParmsConvertNotificationRoutine != NULL &&
             Package->UserParmsAttrBlockFreeRoutine != NULL) 
        {
            __try 
            {
                NtStatus = Package->UserParmsConvertNotificationRoutine(
                                                                Flags,
                                                                DomainSid,
                                                                ObjectRid,
                                                                UserParmsLengthOrig,
                                                                UserParmsOrig,
                                                                UserParmsLengthNew,
                                                                UserParmsNew,
                                                                &UserParmsAttrBlock 
                                                                );
            
                if (NT_SUCCESS(NtStatus) && NULL != UserParmsAttrBlock) 
                {
                    //
                    // Validate the passed-in UserParmsAttrBlock is well-constructed.
                    //
                    NtStatus = SampUserParmsAttrBlockHealthCheck(UserParmsAttrBlock);
                    
                    if (NT_SUCCESS(NtStatus))
                    {
                        // 
                        // Convert SAM_USERPARMS_ATTRBLOCK to DSATTRBLOCK and get 
                        // Supplemental Credential Data if any.
                        // 
                        NtStatus = SampConvertUserParmsAttrBlockToDsAttrBlock(
                                                                        UserParmsAttrBlock,
                                                                        &PartialDsAttrBlock,
                                                                        &SupplementalCredentials
                                                                        );                                       
                                                                    
                        if (NT_SUCCESS(NtStatus) && NULL != PartialDsAttrBlock)
                        {
                            // if (!SampDsAttrBlockIsValid(PartialDsAttrBlock))
                            // {
                            //     NtStatus = STATUS_INVALID_PARAMETER;
                            //     __leave;
                            //  }
                            // 
                            // Check for any conflict between the converted UserParmsAttrBlock and 
                            // user's attributes block
                            //  
                            NtStatus = SampScanAttrBlockForConflict(DsAttrBlock, PartialDsAttrBlock);
                        
                            if (NT_SUCCESS(NtStatus))
                            {
                                NtStatus = SampScanAttrBlockForConflict(InAttrBlock, PartialDsAttrBlock);
                                    
                                if (NT_SUCCESS(NtStatus))
                                {
                                    NtStatus = SampMergeDsAttrBlocks(DsAttrBlock,
                                                                     PartialDsAttrBlock,
                                                                     &TmpDsAttrBlock
                                                                     );               
                                    if (NT_SUCCESS(NtStatus))
                                    {
                                        DsAttrBlock = TmpDsAttrBlock;
                                        TmpDsAttrBlock = NULL;
                                        PartialDsAttrBlock = NULL;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (UserParmsAttrBlock != NULL) 
                {
                    Package->UserParmsAttrBlockFreeRoutine( UserParmsAttrBlock );
                    UserParmsAttrBlock = NULL;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            
        }
        
        if (!NT_SUCCESS(NtStatus))
        {
            goto ConvertUserParmsError;
        }

        Package = Package->Next;
    }
    
    
    if ((NULL != SupplementalCredentials) && (!ARGUMENT_PRESENT(Context)))
    {
        NtStatus = SampConvertCredentialsToAttr(Context,
                                            Flags,
                                            ObjectRid,
                                            SupplementalCredentials,
                                            &CredentialAttr
                                            );
        
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampAppendAttrToAttrBlock(CredentialAttr,
                                             &DsAttrBlock
                                             );
        }
    }
        
   
    
    if (!NT_SUCCESS(NtStatus))
    {
        goto ConvertUserParmsError;
    }
    
    *OutAttrBlock = DsAttrBlock;
    

ConvertUserParmsFinish:

    if ((SupplementalCredentials) && (!ARGUMENT_PRESENT(Context)))
    {
        SampFreeSupplementalCredentialList(SupplementalCredentials);
    }

    return NtStatus;



ConvertUserParmsError:


    if (NULL != Package)
    {
        PUNICODE_STRING EventString[1];
        
        EventString[0] = &Package->PackageName;
    
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_ERROR_UPGRADE_USERPARMS,
                          NULL,  // Object SID 
                          1,
                          sizeof(NTSTATUS),
                          EventString,
                          (PVOID) &NtStatus 
                          );
    }                          

    
    if (PartialDsAttrBlock)
    {
        SampFreeAttributeBlock(PartialDsAttrBlock);
    }
       
    if (DsAttrBlock)
    {
        SampFreeAttributeBlock(DsAttrBlock);
    }

    if (CredentialAttr.AttrVal.pAVal)
    {
        if (CredentialAttr.AttrVal.pAVal[0].pVal)
        {
            MIDL_user_free(CredentialAttr.AttrVal.pAVal[0].pVal);
        }
        MIDL_user_free(CredentialAttr.AttrVal.pAVal); 
    }

        
    *OutAttrBlock = NULL;
        
    goto ConvertUserParmsFinish;        
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\usrprop.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef notdef
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"
#endif // notdef

#include <usrprop.h>

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );

NTSTATUS
SetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN PUNICODE_STRING PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
    It is the Callers Responsibility to initialize the Update Field prior
    to calling this routine
*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    USHORT  oldUserParmsLength = 0;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if ((Property == NULL) || (PropertyFlag == 0))
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.


    *pNewUserParms = NULL;

    try {

        oldUserParmsLength = (USHORT)((lstrlenW(UserParms) + 1) * sizeof(WCHAR));

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't get the length of the current UserParameters, we loose
        //  the whole thing.
        //

        UserParms = NULL;
    }

    // Convert UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms ? oldUserParmsLength : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue->Length;

    if (ValueLength != 0)
    {
        // Convert property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));
        if (!PropertyValueString)
        {
            return(STATUS_NO_MEMORY) ;
        }

        pchValue = (UCHAR *) PropertyValue->Buffer;

        // N.B:  Since wsprint converts 0x00 to 20 30 (20 is
        // space and 30 is 0), sscanf converts 20 30 to 0. If the
        // value is uncode string, this convertsion would not
        // convert back to original value. So if we want to store
        // some value in the UserParms, we have to pass in ansi
        // string.

        for (i = 0; i < ValueLength; i++)
        {
            wsprintfA ((PCHAR)(PropertyValueString+i), "%02x", *(pchValue+i));
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = oldUserParmsLength;
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        status = STATUS_BUFFER_OVERFLOW;
        goto Error;
    }

    try {

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't copy the current UserParameters, we loose the whole thing.
        //

        UserParms = NULL;
        uniUserParms.Buffer = UserParms;
        uniUserParms.Length = 0;
        uniUserParms.MaximumLength = uniUserParms.Length;

        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
        if (ValueLength > 0) {
            Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
        }

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    }

    if ( !NT_SUCCESS(status) ) {
        goto Error;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    try {

        if (FindUserProperty (UserProperties,
                              Property,
                              &UserProperty,
                              &Count))
        {
            RemoveUserProperty ( &uniNewUserParms,
                                 UserProperty,
                                 Count,
                                 Update);
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... get rid of them.
        //

        *Update = TRUE;

        if (*pNewUserParms != NULL) {
            LocalFree( *pNewUserParms );
        }
        *pNewUserParms = NULL;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS(status) ) {
        goto Error;
    }

    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0) {

        try {

            // find the end of the parameters list

            UserProperty = &(UserProperties->FirstProperty);

            for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
            {
                UserProperty = (PUSER_PROPERTY)
                                   ((LPSTR)((LPSTR) UserProperty +
                                         sizeof(USER_PROPERTY) + // length of entry
                                         UserProperty->PropertyLength +
                                         UserProperty->ValueLength -
                                         sizeof(WCHAR)));  // for Property[0]
            }

            //
            // append it to the end and update length of string
            //

            UserProperty->PropertyFlag   = PropertyFlag;

            UserProperty->PropertyLength = PropertyLength;
            UserProperty->ValueLength    = ValueLength;

            RtlCopyMemory(  &(UserProperty->Property[0]),
                            Property,
                            PropertyLength );

            RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                            PropertyValueString,
                            ValueLength );

            uniNewUserParms.Length +=
                            sizeof(USER_PROPERTY) + // length of entry
                            PropertyLength +    // length of property name string
                            ValueLength -       // length of value string
                            sizeof(WCHAR);      // account for WCHAR Property[1]

            UserProperties->Header.PropertyCount++;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  we have corrupted user parms here... get rid of them.
            //

            if (*pNewUserParms != NULL) {
                LocalFree( *pNewUserParms );
            }
            *pNewUserParms = NULL;
            status = STATUS_INVALID_PARAMETER;
        }
        *Update = TRUE;
    }
    
Error:

    if (NULL != PropertyValueString)
    {
        LocalFree(PropertyValueString);
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    return( status );
}

NTSTATUS
SetUserPropertyWithLength (
    IN PUNICODE_STRING UserParms,
    IN LPWSTR          Property,
    IN PUNICODE_STRING PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //
        
        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) ( length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = SetUserProperty(   newUserParms.Buffer,
                                Property,
                                PropertyValue,
                                PropertyFlag,
                                pNewUserParms,
                                Update );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString = NULL;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    try {

        PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

        // Check if UserParms have the right structure.

        if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                              PropertyName,
                              &UserProperty,
                              &Count) ) {

            Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                              PropertyNameLength);

            //
            //  Found the requested property
            //

            //
            //  Copy the property flag.
            //

            if (PropertyFlag) {
                *PropertyFlag = UserProperty->PropertyFlag;
            }

            // Allocate memory for PropertyValue->Buffer

            PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);
            PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

            //
            //  Make sure the property value length is valid.
            //
            if ((PropertyValue->Buffer == NULL) || (PropertyValueString == NULL)) {

                status = STATUS_INSUFFICIENT_RESOURCES;

                if (PropertyValue->Buffer != NULL) {
                    LocalFree( PropertyValue->Buffer );
                    PropertyValue->Buffer = NULL;
                }

            } else {

                //
                //  Copy the property value to the buffer.
                //

                RtlCopyMemory( PropertyValueString,
                               Value,
                               UserProperty->ValueLength );

                pchValue = (CHAR *) PropertyValue->Buffer;

                // Convert from value unicode string to value.
                for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
                {
                     // sscanf will trash memory.
                     // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

                     pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                                   MAPHEXTODIGIT( PropertyValueString[2*i+1]);
                }

                PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
                PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);
            }
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... can't return a decent value
        //

        if (PropertyValue->Buffer != NULL) {
            LocalFree( PropertyValue->Buffer );
            PropertyValue->Buffer = NULL;
        }

        PropertyValue->Length = 0;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( PropertyValueString != NULL ) {
        LocalFree( PropertyValueString);
    }

    return status;
}

NTSTATUS
QueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) (length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = QueryUserProperty( newUserParms.Buffer,
                                PropertyName,
                                PropertyFlag,
                                PropertyValue );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
}


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;
    USHORT              LengthToMove = 0;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount) {


        LengthToMove = puniUserParms->Length - 
                       (USHORT) ((LPSTR)NextProperty - (LPSTR)puniUserParms->Buffer);

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        LengthToMove );
    }

    //
    // Zero the space occurpaied by the removed property. 
    // Otherwise, we will always carry these memory and save them into permenent 
    // storage.
    // 
    ASSERT(((LPSTR)UserProperty + LengthToMove + OldParmLength) == ((LPSTR)puniUserParms->Buffer + puniUserParms->Length)); 
    RtlZeroMemory((LPSTR)UserProperty + LengthToMove,  OldParmLength);

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
}


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
}

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\convobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    convobj.cxx

Abstract:

    These class definitions encapsulate the data and actions to move SAM objects
    located in the registry to the Directory Service.  The function definitions
    assume a running DS.

Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    4-Sept-96  ColinBr  Added security change to regsitry keys so no
                        manual change would have to be done.
    15-Sept-96 ColinBr  Added code so the members of groups and aliases
                        would be extracted before the object was written
                        to the DS, since those fields are now zeroed out

++*/

#include <ntdspchx.h>
#pragma hdrstop


#include "event.hxx"

extern "C"{

#include <samsrvp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <dsutilp.h>
#include <attids.h>
#include <filtypes.h>
#include <lmaccess.h>

//
// Forward declarations
//

NTSTATUS
SampRegObjToDsObj(
     IN  PSAMP_OBJECT     pObject,
     OUT ATTRBLOCK**      ppAttrBlock
     );

NTSTATUS
SampDsCreateObject(
    IN   DSNAME         *Object,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    );

void
SampInitializeDsName(
                     IN DSNAME * pDsName,
                     IN WCHAR * NamePrefix,
                     IN ULONG NamePrefixLen,
                     IN WCHAR * ObjectName,
                     IN ULONG NameLen
                     );
NTSTATUS
SampGetAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG        AttributeIndex,
    IN BOOLEAN      MakeCopy,
    OUT PSID       *SidArray
    );

NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampGetArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID  *SidArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    );

NTSTATUS
SampDsLookupObjectBySid(
    IN DSNAME *DomainObject,
    PSID       ObjectSid,
    DSNAME   **Object
    );

NTSTATUS
GetGroupRid(
    IN DSNAME * GroupObject,
    OUT PULONG GroupRid
    );

NTSTATUS
LookupObjectByRidAndGetPrimaryGroup(
    DSNAME      *BaseObject,
    IN  PSID     DomainSid,
    IN  ULONG    UserRid,
    OUT DSNAME **UserObject,
    OUT PULONG   UserPrimaryGroupId,
    OUT PULONG   UserAccountControl
    );

NTSTATUS
SampValidateRegAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    );


NTSTATUS
SampUpgradeUserParmsActual(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG        Flags, 
    IN PSID         DomainSid, 
    IN ULONG        ObjectRid, 
    IN OUT PDSATTRBLOCK * AttributesBlock
    );
    

NTSTATUS
SampSetMachineAccountOwnerDuringDCPromo(
    IN PDSNAME pDsName,
    IN PSID    NewOwner 
    );

#include "util.h"

}

#include <convobj.hxx>
#include <trace.hxx>

extern CDomainObject  *pRootDomainObject;
#define RootDomainObject (*pRootDomainObject)

//
// Useful macros
//
#define CheckAndReturn(s)                                           \
if (!NT_SUCCESS(s)) {                                               \
     DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, s)); \
     return(s);                                                     \
}

#if DBG
#define MEMBER_BUFFER_SIZE 5
#else
#define MEMBER_BUFFER_SIZE 500
#endif

//
// Local utility functions
//

NTSTATUS
GetPartialRegValue (
    IN     HANDLE hRegistryHandle,
    IN     PUNICODE_STRING pUName,
    OUT    PVOID           *ppvData,
    IN OUT PULONG          pulLength
    );


//
// Static variable for CRegistryObject Class
//
ULONG CRegistryObject::_ulKeysWithPermChange = 0;

BOOL  KeyRestoreProblems(void) {

    // This function should be called at the very end of processing
    // all registry data.  Since the permission may be reset during
    // object destuction, we want to note any failures
    return(CRegistryObject::_ulKeysWithPermChange != 0);

}

//
// Class method definitions
//

NTSTATUS
CRegistryObject::Open(
    WCHAR *wcszRegName
    )
/*++

Routine Description:
    This function opens the registry specified by wcszRegName.  It also
    changes the DACL so an administrator can enumerate the keys. The change
    is undone once in the destructor.


Parameters:

    wcszRegName : the full path of a key in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::Open");

    NTSTATUS          NtStatus;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    RegNameU;


    DebugInfo(("DSUPGRAD: Opening Registry key %ws\n", wcszRegName));

    //
    // Create the object that we will be opening in the registry
    //
    RtlInitUnicodeString( &RegNameU, wcszRegName);

    InitializeObjectAttributes(
        &Attributes,
        &RegNameU,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    //
    // Try to open for read control
    //
    NtStatus = NtOpenKey(
                  &_hRegistryKey,
                  KEY_READ,
                  &Attributes
                   );

    if ( NtStatus != STATUS_SUCCESS
      && NtStatus != STATUS_ACCESS_DENIED ) {

        CheckAndReturn(NtStatus);

    }

    if ( STATUS_ACCESS_DENIED == NtStatus ) {
        //
        // This is the default setting, we should have
        // write DACL control, though
        //
        NtStatus = NtOpenKey(
              &_hRegistryKey,
              WRITE_DAC | READ_CONTROL,
              &Attributes
               );
        if ( STATUS_ACCESS_DENIED == NtStatus ) {
            //
            // Can't do anything from here
            //
            DebugError((
            "DSUPGRAD does not have permission to KEY_READ or WRITE_DAC on registry keys\n"));
        }
        CheckAndReturn(NtStatus);

        //
        // We can write the DACL - give administrators permissions
        // to KEY_READ, and save our original permissions so they can be
        // reset
        //
        NtStatus = AddAdministratorsToPerms();
        CheckAndReturn(NtStatus);

        // Close the handle so we can reopen with WRITE_DAC
        NtClose(_hRegistryKey);

        NtStatus = NtOpenKey(
                      &_hRegistryKey,
                      KEY_READ | WRITE_DAC,
                      &Attributes
                       );
        CheckAndReturn(NtStatus);


    }

    return STATUS_SUCCESS;

}

NTSTATUS
CRegistryObject::Close(
    void
    )
/*++

Routine Description:

    This function resets the permissions on the key, if necessary,
    and then closes it.

Parameters:


Return Values:

--*/
{
    FTRACE(L"CRegistryObject::Close");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    if ( _fRestorePerms ) {
        ASSERT(INVALID_HANDLE_VALUE != _hRegistryKey);
        NtStatus = RestorePerms();
        if ( !NT_SUCCESS(NtStatus) ) {
            DebugWarning(("DSUPGRAD: Unable to revert key to previous permissions\n"));
        }
        _fRestorePerms = FALSE;
    }

    if (INVALID_HANDLE_VALUE != _hRegistryKey)  {
        NtStatus = NtClose(_hRegistryKey);
        if ( !NT_SUCCESS(NtStatus) ) {
            DebugWarning(("DSUPGRAD: Unable to close key\n"));
        }
        _hRegistryKey = INVALID_HANDLE_VALUE;
    }

    if (_pSd) {
        RtlFreeHeap(RtlProcessHeap(), 0, _pSd);
        _pSd = NULL;
    }

    return NtStatus;
}

NTSTATUS
CRegistryObject::AddAdministratorsToPerms(
    void
    )
/*++

Routine Description:

    This routines querys the registry object's security info
    and adds the administrators alias to its list of SID's that
    can read and enumerate the keys.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::AddAdministratorsFromPerms");

    NTSTATUS                 NtStatus;
    BOOL                     fAdminsFound = FALSE;
    ULONG                    i;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    // Resources to be cleaned up
    PSID                     AdminsAliasSid = NULL;
    PSECURITY_DESCRIPTOR     pNewSd = NULL;

    //
    // Get the current security descriptor
    //
    NtStatus = NtQuerySecurityObject(_hRegistryKey,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     0,
                                     &_ulSdLength);
    if ( NtStatus != STATUS_BUFFER_TOO_SMALL ) {
        CheckAndReturn(NtStatus);
    }

    _pSd = (PSECURITY_DESCRIPTOR) RtlAllocateHeap(RtlProcessHeap(), 0, _ulSdLength);
    if ( !_pSd ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_pSd, _ulSdLength);

    NtStatus = NtQuerySecurityObject(_hRegistryKey,
                                     DACL_SECURITY_INFORMATION,
                                     _pSd,
                                     _ulSdLength,
                                     &_ulSdLength);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }

    //
    // Make a copy to work with
    //
    pNewSd = (PSECURITY_DESCRIPTOR) RtlAllocateHeap(RtlProcessHeap(), 0, _ulSdLength);
    if ( !pNewSd ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlCopyMemory(pNewSd, _pSd, _ulSdLength);

    BOOL bDaclPresent, bDaclDefaulted;
    PACL pDacl;
    if (!GetSecurityDescriptorDacl(pNewSd,
                                   &bDaclPresent,
                                   &pDacl,
                                   &bDaclDefaulted)) {
        NtStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Create the well-known administrators SID
    //

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid(2 ));
    if ( !AdminsAliasSid ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    //
    // Go through the ACE's looking for the Administrators'
    // entry
    //
    for (i = 0; i < pDacl->AceCount; i++ ) {
        PACCESS_ALLOWED_ACE pAce;

        NtStatus = RtlGetAce(pDacl, i, (void**)&pAce);
        if ( !NT_SUCCESS(NtStatus) ) {
            goto Cleanup;
        }

        if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

            // Check the sid

            if (RtlEqualSid((PSID)&(pAce->SidStart), AdminsAliasSid)) {
                //
                // this is it!
                //
                pAce->Mask = (KEY_READ | WRITE_DAC);
                fAdminsFound = TRUE;
            }
        }
    }

    if ( !fAdminsFound ) {
        //
        // This is impossible since the key was opened up with
        // WRITE_DACL perms!
        //
        ASSERT(FALSE);
    }

    NtStatus = NtSetSecurityObject(_hRegistryKey,
                                   DACL_SECURITY_INFORMATION,
                                   pNewSd);

    if ( !NT_SUCCESS(NtStatus) ) {
        DebugError(("DSUPGRAD: Cannot set perms to read registry keys\n"));
    }

    _fRestorePerms = TRUE;
    _ulKeysWithPermChange++;

    //
    // That's it -  fall through to Cleanup
    //

Cleanup:

    if ( NULL != AdminsAliasSid ) {
        RtlFreeHeap(RtlProcessHeap(), 0, AdminsAliasSid);
    }

    if ( NULL != pNewSd ) {
        RtlFreeHeap(RtlProcessHeap(), 0, pNewSd);
    }

    CheckAndReturn(NtStatus);

    return STATUS_SUCCESS;

}

NTSTATUS
CRegistryObject::RestorePerms(
    void
    )
/*++

Routine Description:

    This routine sets the permission information of the key to
    its original state, before it was opened by this object

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::RestorePerms");

    NTSTATUS NtStatus;

    NtStatus = NtSetSecurityObject(_hRegistryKey,
                                   DACL_SECURITY_INFORMATION,
                                   _pSd);
    if ( !NT_SUCCESS(NtStatus)) {
        DebugWarning(("DSUPGRAD: Permissions not restored on key\n"));
    }
    _ulKeysWithPermChange--;

    return NtStatus;
}

CRegistrySamObject::~CRegistrySamObject()
{
    FTRACE(L"CRegistrySamObject::~CRegistrySamObject()");

    if ( _pSampObject ) {
        if ( _pSampObject->OnDisk ) {
            RtlFreeHeap(RtlProcessHeap(), 0, _pSampObject->OnDisk);
        }
        RtlFreeHeap(RtlProcessHeap(), 0, _pSampObject);
    }
}

NTSTATUS
CSeparateRegistrySamObject::Fill(void)
/*++

Routine Description:
    This routine queries the key embedding in the object for both
    the "V" and "F" values.  In addition is creates a SAMP_OBJECT
    context for the object calling this method. Memory is allocated
    is released in the destuctor.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CSeparateRegistrySamObject::Fill");

    NTSTATUS NtStatus;
    PVOID    pvFixed, pvVariable;
    ULONG    ulFixed, ulVariable;
    ULONG    ulTotalLength;

    //
    // CRegistryObject::Open should have succeeded
    //

    ASSERT(INVALID_HANDLE_VALUE != GetHandle());

    //
    // Allocate some space for the SAM definition of the object
    //
    _pSampObject = SampCreateContextEx(
                    _SampObjectType,
                    TRUE,  // Trusted client
                    FALSE,  // Ds Mode
                    TRUE,  // NotSharedByMultiThread
                    FALSE, // Loopback Client
                    TRUE,  // lazy commit
                    FALSE, // persist across across calls
                    FALSE, // Buffer Writes
                    TRUE,  // Opened By DCPromo
                    1 // the domain index is that of reg mode account domain
                    );

    if (NULL == _pSampObject) {
        CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Set the object type
    _pSampObject->ObjectType = _SampObjectType;
    _pSampObject->RootKey    = GetHandle();
    _pSampObject->OnDiskAllocated = 0;
    _pSampObject->OnDiskFree      = 0;
    _pSampObject->OnDiskUsed      = 0;

    //
    // Inititialize the IsDSObject to Registry Object and
    // Object Name in DS to NULL. Later we will find out where
    // the Object should actually exist in the DS
    //
    SetRegistryObject(_pSampObject);
    _pSampObject->ObjectNameInDs = NULL;


    //
    // Read the attributes
    //
    ASSERT( !_pSampObject->FixedValid );
    ASSERT( !_pSampObject->VariableValid );

    NtStatus = SampValidateRegAttributes( _pSampObject,
                                          SAMP_FIXED_ATTRIBUTES );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampValidateRegAttributes( _pSampObject,
                                              SAMP_VARIABLE_ATTRIBUTES );
    }

    CheckAndReturn(NtStatus);


    // This is important as we never want Samp routines to
    // attempt to "validate" us!
    ASSERT( _pSampObject->FixedValid );
    ASSERT( _pSampObject->VariableValid );

    return STATUS_SUCCESS;

}

NTSTATUS
CTogetherRegistrySamObject::Fill(void)
/*++

Routine Description:
    This routine querys the key embedding in the object for just
    the "C".  In addition is creates a SAMP_OBJECT
    context for the object calling this method. Memory is allocated
    is released in the destuctor.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CTogetherRegistrySamObject::Fill");

    NTSTATUS NtStatus;
    PVOID    pvCombined;
    ULONG    ulCombinedLength;

    //
    // CRegistryObject::Open should have succeeded
    //
    ASSERT(INVALID_HANDLE_VALUE != GetHandle());

    //
    // Allocate some space for the SAM definition of the object
    //
    _pSampObject = SampCreateContextEx(
                    _SampObjectType,
                    TRUE,  // trusted client
                    FALSE, // ds mode
                    TRUE,  // NotSharedByMultiThread
                    FALSE, // Loopback Client
                    TRUE,  // lazy commit
                    FALSE, // persist across across calls
                    FALSE, // Buffer Writes
                    TRUE,  // Opened By DCPromo
                    1 // the domain index is that of reg mode account domain
                    );
    if (NULL == _pSampObject) {
        CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Set the object type
    _pSampObject->ObjectType = _SampObjectType;
    _pSampObject->RootKey    = GetHandle();
    _pSampObject->OnDiskAllocated = 0;
    _pSampObject->OnDiskFree      = 0;
    _pSampObject->OnDiskUsed      = 0;

    //
    // Inititialize the IsDSObject to Registry Object and
    // Object Name in DS to NULL. Later we will find out where
    // the Object should actually exist
    //

    SetRegistryObject(_pSampObject);
    _pSampObject->ObjectNameInDs = NULL;


    ASSERT( !_pSampObject->FixedValid );
    ASSERT( !_pSampObject->VariableValid );

    //
    // Read the attributes
    //
    NtStatus = SampValidateRegAttributes( _pSampObject,
                                          SAMP_FIXED_ATTRIBUTES );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampValidateRegAttributes( _pSampObject,
                                              SAMP_VARIABLE_ATTRIBUTES );
    }

    CheckAndReturn(NtStatus);

    // This is important as we never want Samp routines to
    // attempt to "validate" us!
    ASSERT( _pSampObject->FixedValid );
    ASSERT( _pSampObject->VariableValid );


    return STATUS_SUCCESS;

}

NTSTATUS
CDsSamObject::Flush(PDSNAME pDsName)
/*++

Routine Description:

    This routine takes data in the CDsObject that should have been
    filled and converted, and writes it to the DS. _pDsName is
    assigned to pDsName, which is then freed in the destructor.

Parameters:

    pDsName : the DsName of the object

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDsSamObject::Flush");

    NTSTATUS NtStatus, NtStatusCreate;

    //
    // the Attribute block should be filled by now
    //
    ASSERT(_pAttributeBlock);

    ASSERT(pDsName);

    //
    // Set up the object's DS name.
    //
    _pDsName = pDsName;

    //
    // Create the object
    //
    DebugInfo(("DSUPGRAD: Creating DsObject %ws as type %d\n", _pDsName->StringName, _SampObjectType));

    //
    // Start a transaction
    //
    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus)) {
        DebugError(("DSUPGRAD: SampMaybeBeginDsTransaction error = 0x%lx\n", NtStatus));
        CheckAndReturn(NtStatus);
    }

    if ( (_ulObjectQuantifier & ulDsSamObjBuiltinDomain) == ulDsSamObjBuiltinDomain ) {
        //
        // Use a separate call
        //
        NtStatusCreate = SampDsCreateBuiltinDomainObject(_pDsName,
                                                         _pAttributeBlock);

    } else if ( (_ulObjectQuantifier & ulDsSamObjRootDomain) == ulDsSamObjRootDomain ) {
        //
        // The object is already created - just set the attributes
        //
        NtStatusCreate = SampDsSetAttributes(_pDsName,
                                             SAM_LAZY_COMMIT,
                                             ADD_ATT,
                                             _SampObjectType,
                                             _pAttributeBlock);

    } else {
        //
        // Create the object normally
        //
        if (SampUserObjectType == _SampObjectType)
        {
            ULONG Flags = SAM_LAZY_COMMIT | ALREADY_MAPPED_ATTRIBUTE_TYPES;
           
            if (RtlEqualSid(_rParentDomain.GetSid(), SampBuiltinDomainSid))
            {
                Flags |= DOMAIN_TYPE_BUILTIN;
            }
           
            NtStatusCreate = SampDsCreateObjectActual(_pDsName, 
                                                      Flags, 
                                                      _SampObjectType, 
                                                      _pAttributeBlock,
                                                      _rParentDomain.GetSid()
                                                      );

            if (NT_SUCCESS(NtStatusCreate) &&
                _PrivilegedMachineAccountCreate)
            {
                PSID    DomainAdmins = NULL;

                //
                // Construct the Domain Administrators Group SID
                // 
                NtStatusCreate = SampCreateFullSid(
                                _rParentDomain.GetSid(), 
                                DOMAIN_GROUP_RID_ADMINS,
                                &DomainAdmins
                                );


                if (NT_SUCCESS(NtStatusCreate))
                {
                    //
                    // Reset the owner of the Machine Account and 
                    // Add ms-ds-CreatorSid attribute
                    // 
                    NtStatusCreate = SampSetMachineAccountOwnerDuringDCPromo(
                                                      _pDsName,
                                                      DomainAdmins 
                                                      );

                    MIDL_user_free(DomainAdmins);
                }
            }
        }
        else 
        {
            NtStatusCreate = SampDsCreateObject(_pDsName,
                                                _SampObjectType,
                                                _pAttributeBlock,
                                                _rParentDomain.GetSid()
                                                );
        }
    }

    if ( !NT_SUCCESS(NtStatusCreate) ) {
        DebugError(("DSUPGRAD: SampDsCreateObject failed 0x%x\n", NtStatusCreate));
        // Don't bail out - we need to complete the transaction

        KdPrint(("[DsUpgrade], Failed Creation of object;DN is %S\n",_pDsName->StringName));
    }

    //
    // Commmit the transaction
    //
    NtStatus = SampMaybeEndDsTransaction(TransactionCommit);
    if (!NT_SUCCESS(NtStatus)) {
        DebugError(("DSUPGRAD: SampMaybeEndDsTransaction error = 0x%lx\n", NtStatus));
    }

    if (!NT_SUCCESS(NtStatusCreate)) {
        NtStatus = NtStatusCreate;
    }

    return NtStatus;

}

CDsObject::~CDsObject(void)
{
    FTRACE(L"CDsObject::~CDsObject");
    ULONG cAttr, cVal;

    if ( _pAttributeBlock ) {

        for ( cAttr = 0;
                  cAttr < _pAttributeBlock->attrCount;
                      cAttr++ ) {

            ASSERT(_pAttributeBlock->pAttr);

            for ( cVal = 0;
                      cVal < _pAttributeBlock->pAttr[cAttr].AttrVal.valCount;
                          cVal++ ) {

                ASSERT(_pAttributeBlock->pAttr[cAttr].AttrVal.pAVal);

                if ( _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal[cVal].pVal ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,
                                _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal[cVal].pVal);
                }
            }

            if ( _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal ) {
                RtlFreeHeap(RtlProcessHeap(), 0,
                            _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal);
            }
        }

        if ( _pAttributeBlock->pAttr ) {
            RtlFreeHeap(RtlProcessHeap(), 0, _pAttributeBlock->pAttr);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, _pAttributeBlock);
    }

    if ( _pDsName ) {
        //
        // This was allocated from the dslayer, which uses the MIDL* allocator.
        //
        MIDL_user_free(_pDsName);
    }
}

NTSTATUS
CGroupObject::ConvertMembers(
    VOID
    )
/*++

Routine Description:

    This method extracts the list of rids from the calling groups
    SAMP_OBJECT context and for each rid, finds the DS name and then
    adds that dsname to the membvership list.

Parameters:

    None.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CGroupObject::ConvertMembers");

    //
    // This is the number of members we will hand off to the ds at a time.
    //

    NTSTATUS NtStatus, IgnoreStatus;

    ULONG    GroupRid;
    PSID     DomainSid, DomainSidTmp;
    DSNAME   *DomainObject, *DomainObjectTmp;

    DSNAME   *MemberNameArray[ MEMBER_BUFFER_SIZE ];
    ULONG     MemberNameCount;

    PUNICODE_STRING StringArray[2];
    UNICODE_STRING  MemberName, GroupName;
    PVOID     pTmp = NULL;

    NtStatus = STATUS_SUCCESS;

    //
    // Get the Group Rid
    //
    NtStatus = GetGroupRid( GetDsName(),&GroupRid );
    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugError(("DSUPGRAD: GetGroupRid error = 0x%lx\n", NtStatus));
        CheckAndReturn(NtStatus);
    }

    //
    // Get the Domain DsName - make assure the memory stays valid for the
    // during of this function, which can span many sam/ds transactions.
    //
    DomainObjectTmp = GetRootDomain().GetDsName();

    if ( NULL == DomainObjectTmp )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        DebugError(("DSUPGRAD: GetRootDomain().GetDsName() failure"));
        CheckAndReturn(NtStatus);
    }

    SAMP_ALLOCA(pTmp,DomainObjectTmp->structLen);
    DomainObject = (DSNAME *) pTmp;
    if ( NULL == DomainObject )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DebugError(("DSUPGRAD: alloca failure"));
        CheckAndReturn(NtStatus);
    }
  
    RtlCopyMemory(DomainObject, DomainObjectTmp, DomainObjectTmp->structLen);

    DomainSidTmp = SampDsGetObjectSid(DomainObject);

    if ( NULL == DomainSidTmp )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        DebugError(("DSUPGRAD: SampDsGetObjectSid() failure"));
        CheckAndReturn(NtStatus);
    }

    SAMP_ALLOCA(DomainSid,RtlLengthSid(DomainSidTmp));
    if ( NULL == DomainSid )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DebugError(("DSUPGRAD: alloca failure"));
        CheckAndReturn(NtStatus);
    }
    RtlCopyMemory(DomainSid, DomainSidTmp, RtlLengthSid(DomainSidTmp));

    //
    // Clear the member array
    //
    RtlZeroMemory( MemberNameArray, sizeof( MemberNameArray ) );
    MemberNameCount = 0;

    //
    //  Iterate through the rids, shipping them off to the ds in batches
    //
    DebugInfo(("DSUPGRAD: Converting members of %ws\n", GetAccountName()));

    for ( ULONG i = 0;
            i < _cRids && NT_SUCCESS(NtStatus);
                i++ ) {

        PDSNAME  pUserDsName = 0;
        ULONG    UserPrimaryGroup;
        ULONG    UserAccountControl;
        BOOLEAN  fLastIteration = FALSE;

        if ( i == (_cRids - 1) )
        {
            fLastIteration = TRUE;
        }

        //
        // Get the DS name of the rid in this iteration
        //
        NtStatus = LookupObjectByRidAndGetPrimaryGroup(
                                           DomainObject,
                                           DomainSid,
                                           _aRids[i],
                                           &pUserDsName,
                                           &UserPrimaryGroup,
                                           &UserAccountControl
                                           );

        if ( NT_SUCCESS(NtStatus) )
        {
            //
            // We were able to resolve this name; now we want to consider this
            // member only if this group is not the primary group
            //
            if (  (GroupRid != UserPrimaryGroup )
                    && (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
            {
                MemberNameArray[ MemberNameCount++ ] = pUserDsName;
            }
        }
        else
        {
            //
            // The name could not be resolved - log an event
            //
            WCHAR ridString[12]; // 2 for 0x + 8 for hex representation of
                                 // a 32 bit number

            StringArray[0] = &MemberName;
            StringArray[1] = &GroupName;

            swprintf(ridString, L"0x%x\0", _aRids[i]);
            RtlInitUnicodeString(&MemberName, ridString);
            RtlInitUnicodeString( &GroupName, GetAccountName() );

            SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                              0,                  // Category
                              SAMMSG_ERROR_GROUP_MEMBER_UNKNOWN,
                              NULL,               // Sid
                              2,                  // Num strings
                              sizeof(NTSTATUS),   // Data size
                              StringArray,        // String array
                              (PVOID)&NtStatus    // Data
                              );

            DebugInfo(("DSUPGRAD: Rid 0x%x NOT found when trying to add"
                       "to group %ws \n", _aRids[i], GetAccountName()));


            //
            // This scenario is handled successfully
            //
            NtStatus = STATUS_SUCCESS;

        }


        //
        // Is it time to flush MemberNameArray to the ds?
        //
        if (   (fLastIteration && MemberNameCount > 0 )
            || (MemberNameCount == (MEMBER_BUFFER_SIZE - 1))  )
        {

            //
            // Send these guys to the ds
            //

            //
            // Start a transaction
            //
            NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

            if ( NT_SUCCESS(NtStatus) )
            {

                NtStatus = SampDsAddMultipleMembershipAttribute( GetDsName(),  // dsname of group
                                                                 SampGroupObjectType,
                                                                 SAM_LAZY_COMMIT | SAM_ALLOW_INTRAFOREST_FPO,
                                                                 MemberNameCount,
                                                                 MemberNameArray );

                if ( NT_SUCCESS( NtStatus ) )
                {
                    //
                    // Ok, now try to commit the changes
                    //
                    NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                }
                else
                {
                    //
                    // Abort any changes
                    //
                    IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                }


                if ( !NT_SUCCESS( NtStatus ) )
                {

                    //
                    // This is an unexpected case - slowly go through each member
                    // adding one at time, logging any errors that occur
                    //
                    NtStatus = STATUS_SUCCESS;

                    for ( ULONG j = 0;
                            j < MemberNameCount && NT_SUCCESS( NtStatus );
                                j++ )
                    {

                        //
                        // Start a transaction
                        //
                        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

                        if ( NT_SUCCESS( NtStatus ) )
                        {

                            //
                            // Add the member
                            //
                            NtStatus = SampDsAddMembershipAttribute( GetDsName(),
                                                                     SAMP_GROUP_MEMBERS,
                                                                     0,
                                                                     SampGroupObjectType,
                                                                     MemberNameArray[j] );


                            if ( NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Ok, now try to commit the changes
                                //
                                NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                            }
                            else
                            {
                                //
                                // Abort any changes
                                //
                                IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                            }

                            if ( !NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Oh well, we tried - this member really can't be
                                // transferred
                                //
                                StringArray[0] = &MemberName;
                                StringArray[1] = &GroupName;

                                RtlInitUnicodeString( &GroupName, GetAccountName() );
                                RtlInitUnicodeString( &MemberName, MemberNameArray[j]->StringName );

                                SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                                  0,                  // Category
                                                  SAMMSG_ERROR_GROUP_MEMBER,
                                                  NULL,               // Sid
                                                  2,                  // Num strings
                                                  sizeof(NTSTATUS),   // Data size
                                                  StringArray,        // String array
                                                  (PVOID)&NtStatus    // Data
                                                  );

                                DebugInfo(("DSUPGRAD: User %ws not added to group %ws\n",
                                          MemberName.Buffer, GetAccountName()));

                                //
                                // This scenario is handled successfully
                                //
                                NtStatus = STATUS_SUCCESS;

                            }
                        }
                        else
                        {
                            // Couldn't get a transaction? Bail
                            NtStatus = STATUS_NO_MEMORY;
                        }
                    }
                }
            }
            else
            {
                // Couldn't get a transaction? Bail
                NtStatus = STATUS_NO_MEMORY;
            }

            //
            // Reset the state of the MemberNameArray
            //
            for ( ULONG j = 0 ; j < MemberNameCount; j++ )
            {
                MIDL_user_free( MemberNameArray[j] );
                MemberNameArray[j] = NULL;
            }
            MemberNameCount = 0;

        }

    }

    return NtStatus;

}



NTSTATUS
CAliasObject::ConvertMembers(
    VOID
    )
/*++

Routine Description:

    This routine extracs the list of Sids for the calling aliases
    SAMP_OBJECT context data, and for each Sid, gets the dsname, and
    adds that dsname to the membership list of the alias.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CAliasObject::ConvertMembers");

    NTSTATUS NtStatus, IgnoreStatus;

    PSID     pCurrentSid = NULL;
    PSID     pDomainSid  = NULL, pDomainSidTmp = NULL;

    //
    // Locals to keep track of sids in the nt4 alias
    //
    ULONG    AliasSidIndex, AliasSidCount;

    //
    // Buffer of sids to send of to  ds
    //
    PSID     SidArray[ MEMBER_BUFFER_SIZE ];
    ULONG    SidCount, SidIndex;

    //
    // Array of dsname's resolved from sids in SidArray - allocated
    // from SAM code using MIDL
    //
    PDSNAME *NameArray = NULL;
    ULONG    NameCount = 0;

    //
    // Array of dsname's from NameArray that were actually resolved
    //
    PDSNAME  ResolvedNameArray[ MEMBER_BUFFER_SIZE ];
    ULONG    ResolvedNameCount;

    //
    // Used for event log messaging
    //
    PUNICODE_STRING StringArray[2];
    UNICODE_STRING  MemberName, AliasName;

    BOOLEAN        fLastIteration;
    ULONG          Index;

    //
    // Only a resource failure can cause this routine to fail
    //
    NtStatus = STATUS_SUCCESS;

    //
    //  Init the event log messaging
    //
    RtlInitUnicodeString( &AliasName, GetAccountName() );
    StringArray[0] = &MemberName;
    StringArray[1] = &AliasName;

    //
    // Get the domain sid
    //
    pDomainSidTmp  = SampDsGetObjectSid(GetRootDomain().GetDsName());
    if ( pDomainSidTmp )
    {
        SAMP_ALLOCA(pDomainSid,RtlLengthSid(pDomainSidTmp));
        if (NULL==pDomainSid)
        {
           CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
        }
        RtlCopySid( RtlLengthSid(pDomainSidTmp), pDomainSid, pDomainSidTmp );
    }
    else
    {
        // No domain sid?
        CheckAndReturn( STATUS_INTERNAL_ERROR );
    }

    DebugInfo(("DSUPGRAD: Converting members of %ws\n", GetAccountName()));

    //
    // Clear the member sid array
    //
    RtlZeroMemory( SidArray, sizeof( SidArray ) );
    SidCount = 0;

    //
    // In batches of MEMBER_BUFFER_SIZE, resolve the sids into dsnames and
    // add dsnames to the alias'es membership list in the ds
    //
    for ( AliasSidIndex = 0, AliasSidCount = _cSids, pCurrentSid = _aSids;
            AliasSidIndex < AliasSidCount && NT_SUCCESS( NtStatus );
                AliasSidIndex++, pCurrentSid = (PSID) ((PBYTE)pCurrentSid
                                               + RtlLengthSid(pCurrentSid)) )

    {
        //
        // fLastIteration is set so we flush the last group of sids to ds
        // even if the buffer size is not met - hence don't increment
        // AliasSidIndex during this block!
        //
        if ( AliasSidIndex == ( AliasSidCount - 1 ) ) {
            fLastIteration = TRUE;
        } else {
            fLastIteration = FALSE;
        }

        //
        // Add the sid to current batch
        //
        SidArray[ SidCount++ ]  = pCurrentSid;


        //
        // Is it time to flush SidArray to the ds?
        //
        if (   fLastIteration
            || ( SidCount == MEMBER_BUFFER_SIZE ) )
        {

            //
            // Send the current batch to the ds
            //

            //
            // Start a transaction
            //
            NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

            if ( NT_SUCCESS(NtStatus) )
            {
                //
                // Translate sids into dsnames
                //

                //
                // During this resolve Sids process we will
                // 1. Treat every Sid not belonging to the domain to be upgraded to be a foriegn
                //    domain security principal ( even if that Sid really belongs to some domain
                //    in the enterprise. The reason for this is that that we do not want to contact
                //    the G.C under any circumstance ( because of the sheer availability problem )
                //    Upgrades may run for a long time and the G.C may go down during this time. A
                //    further reason is that even if we implement the logic to contact the G.C and
                //    ignore any errors due to unavailability of G.C's we would still face cleanup
                //    problems.
                //

                NtStatus = SampDsResolveSidsForDsUpgrade(
                                pDomainSid,
                                SidArray,
                                SidCount,
                                (RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL),
                                &NameArray
                                );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    //
                    // We couldn't do them all at once, let's try one at a time
                    //
                    for (  Index = 0; Index < SidCount; Index++ )
                    {

                        PDSNAME *ppDsName;

                        NtStatus = SampDsResolveSidsForDsUpgrade(
                                        pDomainSid,
                                        &SidArray[Index],
                                        1,
                                        (RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL),
                                        &ppDsName
                                        );


                        if ( NT_SUCCESS(NtStatus) )
                        {
                            //
                            // N.B. SampDsResolveSidsForDsUpgrade can return
                            // STATUS_SUCCESS and set *pDsName to NULL.  This
                            // means the function successfully determined that
                            // the sid could not be resolved
                            //
                            NameArray[Index] = *ppDsName;
                        }
                        else
                        {
                            //
                            // The fact that this sid did not get resolved
                            // will be address in new loop
                            //
                            NameArray[Index] = NULL;
                        }
                    }

                    //
                    // This scenario is handled correctly
                    //
                    NtStatus = STATUS_SUCCESS;
                }

                //
                // These two arrays have the same cardinality
                //
                NameCount = SidCount;

                //
                // Package all the resolved sids into array
                //
                RtlZeroMemory( ResolvedNameArray, sizeof( ResolvedNameArray ) );
                ResolvedNameCount = 0;
                for ( Index = 0; Index < NameCount; Index++ )
                {

                    if ( NameArray[Index] )
                    {
                        ResolvedNameArray[ResolvedNameCount++] = NameArray[Index];
                    }
                    else
                    {
                        //
                        // This particular sid could not be resolved
                        //
                        IgnoreStatus = RtlConvertSidToUnicodeString(&MemberName,
                                                                    SidArray[Index],
                                                                    TRUE  // Allocate the memory
                                                                    );
                        ASSERT(NT_SUCCESS(IgnoreStatus));

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_ERROR_ALIAS_MEMBER_UNKNOWN,
                                          NULL,               // Sid
                                          2,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          StringArray,        // String array
                                          (PVOID)&NtStatus    // Data
                                          );

                        DebugInfo(("DSUPGRAD: Sid %ws NOT found when trying to add"
                                   "to alias %ws \n", MemberName.Buffer, GetAccountName()));

                        RtlFreeHeap( RtlProcessHeap(), 0, MemberName.Buffer );
                    }

                }

                //
                // Ship the resolved sids off to the ds
                //
                NtStatus = SampDsAddMultipleMembershipAttribute( GetDsName(),  // dsname of group
                                                                 SampAliasObjectType,
                                                                 SAM_LAZY_COMMIT | SAM_ALLOW_INTRAFOREST_FPO,
                                                                 ResolvedNameCount,
                                                                 ResolvedNameArray );

                if ( NT_SUCCESS( NtStatus ) )
                {
                    //
                    // Ok, now try to commit the changes
                    //
                    NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                }
                else
                {
                    //
                    // Abort any changes
                    //
                    IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {

                    //
                    // This is an unexpected case - slowly go through each member
                    // adding one at time, logging any errors that occur
                    //

                    NtStatus = STATUS_SUCCESS;

                    for ( Index = 0;
                            Index < ResolvedNameCount && NT_SUCCESS( NtStatus );
                                Index++ )
                    {

                        //
                        // Start a transaction
                        //
                        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

                        if ( NT_SUCCESS( NtStatus ) )
                        {

                            //
                            // Add the member
                            //
                            NtStatus = SampDsAddMembershipAttribute( GetDsName(),
                                                                     0,
                                                                     SAMP_ALIAS_MEMBERS,
                                                                     SampAliasObjectType,
                                                                     ResolvedNameArray[Index] );


                            if ( NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Ok, now try to commit the changes
                                //
                                NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                            }
                            else
                            {
                                //
                                // Abort any changes
                                //
                                IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                            }

                            if ( !NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Oh well, we tried - this member really can't be
                                // transferred
                                //
                                RtlInitUnicodeString( &MemberName, ResolvedNameArray[Index]->StringName );

                                SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                                  0,                  // Category
                                                  SAMMSG_ERROR_ALIAS_MEMBER,
                                                  NULL,               // Sid
                                                  2,                  // Num strings
                                                  sizeof(NTSTATUS),   // Data size
                                                  StringArray,        // String array
                                                  (PVOID)&NtStatus    // Data
                                                  );

                                DebugInfo(("DSUPGRAD: User %ws not added to group %ws\n",
                                          MemberName.Buffer, GetAccountName()));

                                //
                                // This scenario is handled successfully
                                //
                                NtStatus = STATUS_SUCCESS;

                            }
                        }
                        else
                        {
                            // Couldn't get a transaction? Bail
                            NtStatus = STATUS_NO_MEMORY;
                        }
                    }
                }
            }
            else
            {
                // Couldn't get a transaction? Bail
                NtStatus = STATUS_NO_MEMORY;
            }

            //
            // Release NameArray
            //
            if ( NameArray )
            {
                for ( Index = 0; Index < NameCount; Index++ )
                {
                    if ( NameArray[Index] )
                    {
                        MIDL_user_free( NameArray[Index] );
                        NameArray[Index] = NULL;
                    }
                }
                MIDL_user_free( NameArray );
                NameArray = NULL;
            }
            NameCount = 0;

            //
            // Reset the SidArray
            //
            RtlZeroMemory( SidArray, sizeof( SidArray ) );
            SidCount = 0;

        } // if buffer flush

    } // for

    //
    // Return to the caller, printing out any error message
    //
    CheckAndReturn( NtStatus );

    return STATUS_SUCCESS;

}

NTSTATUS
CConversionObject::Convert(void)
/*++

Routine Description:
    This routine transforms the SAMP_OBJECT data to be an in memory
    DS Sam object (ie, .OnDisk structure is changed, SetDsObject() is
    called, etc). and an AttributeBlock containing the same information
    is generated.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CConversionObject::Convert");

    NTSTATUS    NtStatus;

    NtStatus = SampRegObjToDsObj(_rRegObj._pSampObject, &(_rDsObj._pAttributeBlock));

    if (NT_SUCCESS(NtStatus) && 
        (SampUserObjectType == _rRegObj._SampObjectType))
    {
        _rDsObj._PrivilegedMachineAccountCreate = 
            (_rRegObj._pSampObject)->TypeBody.User.PrivilegedMachineAccountCreate;
    }

    return NtStatus;
}

NTSTATUS
CConversionObject::UpgradeUserParms(void)
/*++

Routine Description:
    This Routine upgrade SAMP_USER_OBJECT's UserParameters attribute.

Parameters:
    
    None
    
Return Values:
    
    STATUS_SUCCESS - The service completed successfully.
    
    STATUS_NO_MEMORY / STATUS_INVALID_PARAMETER  - Error return from SampUpgradeUserParmsActual.
    
--*/
{
    FTRACE(L"CConversionOject::UpgradeUserParms");
    
    ASSERT(SampUserObjectType == _rDsObj._SampObjectType);
    
    // 
    // Map SAM attribute ID to DS attribute ID, should always successful.
    // _rDsObj._pAttributeBlock has been updated.
    // 
    SampMapSamAttrIdToDsAttrId(_rDsObj._SampObjectType,
                               _rDsObj._pAttributeBlock
                               );
   
    // 
    // Upgrade UserParms Attribute, if succeed, _rDsObj._pAttributeBlock has been updated.
    // if failure, _pAttributeBlock remains unchanged.
    // 
    return SampUpgradeUserParmsActual(NULL,           // Context, OPTIONAL, 
                                      SAM_USERPARMS_DURING_UPGRADE,               // during upgrade
                                      _rDsObj._rParentDomain.GetSid(),            // Domain Sid
                                      (_rRegObj._pSampObject)->TypeBody.User.Rid,    // Object Rid
                                      &(_rDsObj._pAttributeBlock)                 // Attribute Block
                                      );
}


NTSTATUS
CDomainObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the SID of the domain, since it is used by other objects
    during creation.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDomainObject::Fill");

    NTSTATUS NtStatus;

    NtStatus = CSeparateRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the SID
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetSidAttribute(_pSampObject,
                                   SAMP_DOMAIN_SID,
                                   TRUE,
                                   &_pSid);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != _pSid);

    return STATUS_SUCCESS;

}

NTSTATUS
CDomainObject::SetAccountCounts(void)
/*++

Routine Description:

   This routine sets the account counts on the ds domain
   object.  The domain object should have been set at this point.
   An attrblock is allocated,  filled to set ATT_USER_COUNT,
   ATT_GROUP_COUNT, and ATT_ALIAS_COUNT attributes.

Parameters:


Return Values:

   STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDomainObject::SetAccountsCounts");


    //
    // The DS is a multi Master System. Therefore it is no longer
    // feasible to maintain account counts. Therefore just return
    // status of Success in here
    //
    return STATUS_SUCCESS;

}

NTSTATUS
CUserObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable, and the account control field

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CUserObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;


    NtStatus = CSeparateRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Set the Domain Sid for NT4 Security Descriptor Conversion
    // 
    _pSampObject->TypeBody.User.DomainSidForNt4SdConversion = 
                                _rParentDomain.GetSid();



    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_USER_ACCOUNT_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';

    MIDL_user_free(usTemp.Buffer);

    //
    // Now get the account control field
    //
    PSAMP_V1_0A_FIXED_LENGTH_USER pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _ulAccountControl = pFixedData->UserAccountControl;
    
    //
    // Now set the TypeBody.User.Rid to the account Relative ID (UserID) 
    //
    
    _pSampObject->TypeBody.User.Rid = pFixedData->UserId;


    return STATUS_SUCCESS;

}

NTSTATUS
CGroupObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable.  Also the list of rids of users
    the belong in this group is extracted, as it will not be written
    to the DS, and hence it zeroed out before we can convert the
    members. The conversion of members happens after the the object is
    written to the DS, so the members must be preserved.


Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CGroupObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;

    NtStatus = CTogetherRegistrySamObject::Fill();

    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_GROUP_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';
    MIDL_user_free(usTemp.Buffer);


    //
    // Get the rid
    //
    PSAMP_V1_0A_FIXED_LENGTH_GROUP pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _GroupRid = pFixedData->RelativeId;

    //
    // Extract and copy the list of RID's
    //
    ASSERT(GetObject()->FixedValid);
    ASSERT(GetObject()->VariableValid);

    ULONG ulLength = 0;
    ULONG *aRids = NULL;

    NtStatus = SampGetUlongArrayAttribute(GetObject(),
                                          SAMP_GROUP_MEMBERS,
                                          FALSE,   // don't make a copy
                                          &aRids,
                                          &_cRids,
                                          &ulLength);
    // ulLength is the number of elements in the array; _cRids is the number
    // of "used" elements

    CheckAndReturn(NtStatus);


    if ( ulLength > 0 ) {

        ASSERT(_cRids > 0);
        ASSERT(aRids);

        _aRids = (ULONG*) RtlAllocateHeap(RtlProcessHeap(), 0, ulLength*sizeof(ULONG));
        if ( !_aRids ) {
            CheckAndReturn(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(_aRids, aRids, ulLength*sizeof(ULONG));
    }

    return STATUS_SUCCESS;

}

NTSTATUS
CAliasObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable. Also the list of sids of members
    who belong to this group is extracted and copied, since that field
    will be zeroed before the DS write.  The conversion of members happens
    after the the object is written to the DS, so the members must be
    preserved.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CAliasObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;

    NtStatus = CTogetherRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_ALIAS_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';
    MIDL_user_free(usTemp.Buffer);

    //
    //  Get this alias's Rid
    //
    PSAMP_V1_FIXED_LENGTH_ALIAS pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _AliasRid = pFixedData->RelativeId;

    //
    //  We must obtain the list of SID's from the aliases
    //  OnDisk structure
    //
    ULONG ulLength = 0;
    PSID  aSids = NULL;

    ASSERT(GetObject()->FixedValid);
    ASSERT(GetObject()->VariableValid);
    NtStatus = SampGetSidArrayAttribute(GetObject(),
                                        SAMP_ALIAS_MEMBERS,
                                        FALSE,  // don't make a copy
                                        &aSids,
                                        &ulLength,
                                        &_cSids);
    CheckAndReturn(NtStatus);

    if ( ulLength > 0 ) {

        ASSERT(_cSids > 0);
        ASSERT(aSids);

        _aSids = (PSID) RtlAllocateHeap(RtlProcessHeap(), 0, ulLength);
        if ( !_aSids ) {
            CheckAndReturn(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(_aSids, aSids, ulLength);
    }


    return STATUS_SUCCESS;

}


NTSTATUS
GetGroupRid(
    IN DSNAME * GroupObject,
    OUT PULONG GroupRid
    )
/*++
    Gets the Rid of a group Object

    Parameters:

        GroupObject -- DS Name of the group object
        GroupRid     -- Rid of the group object is returned
                       in here

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRTYP RidTyp[] = { SAMP_FIXED_GROUP_RID };
    ATTRVAL RidVal[] = { 0,NULL};
    DEFINE_ATTRBLOCK1(AttrBlockToRead,RidTyp,RidVal);
    ATTRBLOCK OutAttrBlock;

    NtStatus = SampDsRead(
                GroupObject,
                0,
                SampGroupObjectType,
                &AttrBlockToRead,
                &OutAttrBlock
                );
    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(OutAttrBlock.attrCount==1);

        *GroupRid =  *((ULONG *)(OutAttrBlock.pAttr->AttrVal.pAVal->pVal));
    }
    return NtStatus;
}





NTSTATUS
LookupObjectByRidAndGetPrimaryGroup(
    IN  DSNAME  *BaseObject,
    IN  PSID     DomainSid,
    IN  ULONG    UserRid,
    OUT DSNAME **UserObject,
    OUT PULONG   UserPrimaryGroupId,
    OUT PULONG   UserAccountControl
    )
/*++

    Searches for a user object by the specified Rid and retrieves
    the primary group Id of the user

    Parameters:

        BaseObject  DS Name of the base object under which to search
        DomainSid   The Sid of the domain under which we want the user
        User Rid    The Rid of the User
        UserObject  Out parameter specifying the DS Name of the User object
        UserPrmaryGroupId Out parameter specifying the Primary group of the user

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSID     AccountSid = NULL;
    FILTER   DsFilter;
    ULONG    AccountSubAuthorityCount;
    ULONG    AccountSidLength;
    ATTRTYP  AttrTyp[] = { SAMP_FIXED_USER_PRIMARY_GROUP_ID,
                           SAMP_FIXED_USER_ACCOUNT_CONTROL
                         };
    ATTRVAL  AttrVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(AttrsToRead,AttrTyp,AttrVal);
    SEARCHRES * SearchRes;


    //
    // Create a full Sid as follows
    //

    //
    // Calculate the size of the new Sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);


    //
    // Allocate enough memory for the new Sid
    //

    AccountSid = RtlAllocateHeap(RtlProcessHeap(),0,AccountSidLength);
    if (NULL!=AccountSid)
    {
        NTSTATUS    IgnoreStatus;
        PULONG      RidLocation;

        IgnoreStatus = RtlCopySid(AccountSidLength, AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(AccountSid) = (UCHAR) AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = UserRid;
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Compose a Filter to search on the Sid
    //

    memset (&DsFilter, 0, sizeof (DsFilter));
    DsFilter.pNextFilter = NULL;
    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                       SampUnknownObjectType,
                                                       SAMP_UNKNOWN_OBJECTSID
                                                       );

    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = AccountSidLength;
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) AccountSid;

    NtStatus = SampDsDoSearch(
                    NULL,
                    BaseObject,
                    &DsFilter,
                    0,
                    SampUserObjectType,
                    &AttrsToRead,
                    1,
                    &SearchRes
                    );
    if ((NT_SUCCESS(NtStatus)) && SearchRes->count)
    {
        ASSERT(SearchRes->FirstEntInf.Entinf.AttrBlock.attrCount==2);
        *UserPrimaryGroupId =  *((ULONG *)
            (SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal));
        *UserAccountControl =  *((ULONG *)
            (SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal));

        *UserObject = (DSNAME *)
                        MIDL_user_allocate(SearchRes->FirstEntInf.Entinf.pName->structLen);
        if (NULL==*UserObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(*UserObject,
                  SearchRes->FirstEntInf.Entinf.pName,
                  SearchRes->FirstEntInf.Entinf.pName->structLen
                  );


    }
    else if  ((NT_SUCCESS(NtStatus)) && (0==SearchRes->count))
    {
        //
        // We are supposed to fail if no entries were returned
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    if (NULL!=AccountSid)
    {
        RtlFreeHeap(RtlProcessHeap(),0,AccountSid);
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\convert.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    convert.cxx

Abstract:

    Routines to transfer SAM information in Registry to DS.

    The main routine, TransferSamObjects, will only fail if the underlying
    SAM database is corrupt.  Otherwise, given a coherent SAM registry
    base, the routine will success logging all ds addition failures in the
    event log.

Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    Colin Brace (ColinBr) May 21, 1997

        Improved error handling code.

--*/

#include <ntdspchx.h>
#pragma hdrstop

//
// Bring the SAM structure definitions
//

#define MAX_DOWN_LEVEL_NAME_LENGTH 20

extern "C" {

#include <samsrvp.h>

// Ignore debug stuff for GetConfigParam
#include <dsconfig.h>
#include <dslayer.h>            // SampDsLookupObjectByName
#include <attids.h>
#include "util.h"

NTSTATUS
SampDsLookupObjectByNameEx(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object,
    ULONG SearchFlags
    );

}

#include <convobj.hxx>
#include <trace.hxx>

//
// This macro returns if a non-success occurred
//
#define CheckAndReturn(s)                                           \
if (!NT_SUCCESS(s)) {                                               \
     DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, s)); \
     return(s);                                                     \
}

BOOLEAN
SampIsNtStatusResourceError(
    NTSTATUS NtStatus
    )
{

    switch ( NtStatus )
    {
        case STATUS_NO_MEMORY:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_DISK_FULL:

            return TRUE;

        default:

            return FALSE;
    }
}

    
//
// Global variables and contants
//
PWCHAR          wcszRootDomainDN = NULL;
PDSNAME        gRootDomainDsName = NULL;
CDomainObject  *pRootDomainObject;

HMODULE         SampStringNameResource = NULL;
WCHAR           SampDefaultConflictString[] = L"$AccountNameConflict";
ULONG           SampNameConflictCount;

#define RootDomainObject (*pRootDomainObject)

//
// Local Utility functions
//
NTSTATUS
ConvertDomains(
    CServerObject &ServerObject,
    WCHAR*        wcszServerRegName
    );

NTSTATUS
ConvertUsers(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

NTSTATUS
ConvertGroups(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

NTSTATUS
ConvertAliases(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

extern "C"
NTSTATUS
GetRdnForSamObject(IN WCHAR* SamAccountName,
                   IN SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* RdnBuffer,
                   IN OUT ULONG* Size
                   );

NTSTATUS
CheckForNonExistence(
    WCHAR* AccountName,
    SAMP_OBJECT_TYPE SampObjectType
    );

//
// Function Definitions
//
NTSTATUS
GetRootDomainDN(void)
{
    DWORD    cbRootDomainDN = 0;
    ULONG    dwErr=0;

    dwErr = GetConfigParamAllocW(MAKE_WIDE(ROOTDOMAINDNNAME),
                                    (PVOID *) &wcszRootDomainDN,
                                    &cbRootDomainDN);
    if ( 0!=dwErr ) {
        DebugError(("GetConfigAllocParam failed: 0x%x\n", dwErr));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // The root container for the SAM objects in the DS should have
    // set
    ASSERT(wcslen(wcszRootDomainDN) > 0);

    return STATUS_SUCCESS;

}

extern "C" {


NTSTATUS
TransferSamObjects(
    IN WCHAR *wcszSamRegistryPath
)
/*++

Routine Description:

    This routine opens the top level registry container, aka the
    Server Object, converts all the domains and their subkey and
    then finally writes out the server object.

    The critical operations in the transfer are:

    1) reading the dn of the root domain
    2) reading and writing the SAM server object
    3) reading and writing the builtin domain object
    4) reading and writing the account domain object
    5) traversing a non-corrupt SAM database

    If any of these fail, then TransferSamObjects will fail, resulting
    in an unsuccessful upgrade.

    5) implies that during the transfer sanity checks are performed on the
    SAM registry database; if any of these fail, the operation is aborted.

    Any other non-success, will be considered non-fatal; an event will be
    logged indicating the nature of the event and a debug printout will
    also be made.

Parameters:

    wcszSamRegistryPath : this is the full path to the server object


Return Values:

    STATUS_SUCCESS - The service completed successfully.
    STATUS_NO_MEMORY
    any other that might occur when dealing with DS

--*/
{
    FTRACE(L"TransferSamObjects");

    NTSTATUS               NtStatus;

    UNICODE_STRING         uServerDN;
    UNICODE_STRING         uSystemContainerDN;
    PDSNAME                SystemContainerDsName = NULL;
    PDSNAME                ServerDsName = NULL;
    PDSNAME                TempDomainDsName = NULL;
    ULONG                  Size = 0;

    CServerObject          ServerObject(RootDomainObject);

    //
    // Init some globals
    //
    SampNameConflictCount = 0;


    //
    // Get the DN of the root domain object
    //
    NtStatus = GetRootDomainDN();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: GetRootDomainDN failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }
    
    //
    // Construct the Domain's DSNAME from wcszRootDomainDN
    // 
    Size = (ULONG)DSNameSizeFromLen(wcslen(wcszRootDomainDN));
    
    TempDomainDsName = (PDSNAME) MIDL_user_allocate(Size);
    
    if (NULL == TempDomainDsName)
    {
        // This is fatal
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    memset(TempDomainDsName, 0, Size);
    
    TempDomainDsName->structLen = Size;
    TempDomainDsName->NameLen = wcslen(wcszRootDomainDN);
    wcscpy(TempDomainDsName->StringName, wcszRootDomainDN);
    
    //
    // call dslayer routine to initialize SAM global varibles which
    // pointe to well known container's ds name
    // 
    NtStatus = SampInitWellKnownContainersDsName(TempDomainDsName);
    
    // 
    // release the memory we just allocated.
    //  
    MIDL_user_free(TempDomainDsName);
    
    if (!NT_SUCCESS(NtStatus))
    {
        // This is fatal
        goto Cleanup;
    }

    //
    // Open the server object
    //
    NtStatus = ServerObject.Open(wcszSamRegistryPath);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: GetRootDomainDN failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }


    NtStatus = ConvertDomains(ServerObject, wcszSamRegistryPath);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: ConvertDomains failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Now we write out the server object
    //
    NtStatus = ServerObject.Fill();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not read server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    NtStatus = ServerObject.Convert();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not convert server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Create a ds name for the server object
    //

    RtlInitUnicodeString(&uSystemContainerDN,L"System");

    NtStatus = SampDsCreateDsName(gRootDomainDsName,
                                  &uSystemContainerDN,
                                  &SystemContainerDsName);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create a name for the server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    RtlInitUnicodeString(&uServerDN,L"Server");

    NtStatus = SampDsCreateDsName(SystemContainerDsName,
                                  &uServerDN,
                                  &ServerDsName);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create a name for the server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }


    //
    //  The server object takes ownership of the ds name
    //
    NtStatus = ServerObject.Flush(ServerDsName);
    ServerDsName = NULL;

    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Explicity close remaining keys
    //
    NtStatus = ServerObject.Close();
    if (!NT_SUCCESS(NtStatus)) {
        DebugWarning(("Dsupgrad: Could not close handle, error: 0x%x\n", NtStatus));
    }

    NtStatus = RootDomainObject.Close();
    if (!NT_SUCCESS(NtStatus)) {
        DebugWarning(("Dsupgrad: Could not close handle, error: 0x%x\n", NtStatus));
    }

    //
    // Make sure that if any permissions on registry keys were modified
    // that they are undone.
    //
    if ( KeyRestoreProblems() ) {
        DebugWarning((
        "DSUPGRAD *** Warning! Some registry keys not restored to original configuration\n"));
    }

    NtStatus = STATUS_SUCCESS;

    //
    //  That's it fall through to cleanup
    //

Cleanup:

    if (wcszRootDomainDN)
    {
        free(wcszRootDomainDN);
    }

    if (gRootDomainDsName) {
        MIDL_user_free(gRootDomainDsName);
    }

    if (SystemContainerDsName){
        MIDL_user_free(SystemContainerDsName);
    }

    if (SampStringNameResource) {
        FreeLibrary(SampStringNameResource);
        SampStringNameResource = NULL;
    }

    if (!NT_SUCCESS(NtStatus)) {
        //
        // A fatal error occurred
        //

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,                // Category
                          SAMMSG_FATAL_UPGRADE_ERROR,
                          NULL,             //  Sid
                          0,                // Num strings
                          sizeof(NTSTATUS), // Data size
                          NULL,             // String array
                          (PVOID)&NtStatus  // Data
                          );
    }

    return NtStatus;

}

} // extern "C"

NTSTATUS
ConvertDomains(
    IN CServerObject &ServerObject,
    IN WCHAR*        wcszServerRegName
    )
/*++

Routine Description:

    This routine finds the "Domains" key under the server object
    registry handle and then for each domain, converts it and its
    users, groups, and aliases.

    If the domain objects (either account or builtin) cannot be successfully
    created, a fatal error is returned, which will cause the upgrade to
    fail.

Parameters:

    ServerObject      : a server object that has already been opened
    wcszServerRegName : the path in the reg of this open

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertDomain");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    // Misc counters
    ULONG i;

    // This is server query data
    BYTE   ServerInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulServerInfoLength = 0;

    // This is data for enumerating the keys on the server object
    BYTE   EnumServerInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumServerInfoLength = 0;

    // This is domains key data
    CRegistryObject DomainsKey;
    BYTE            DomainsKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulDomainsKeyInfoLength = 0;
    WCHAR           wcszDomainsKeyRegName[MAX_REGISTRY_NAME_LENGTH];

    // This is the Builtin Domain object - the other domain, the "Accounts"
    // will use the global RootDomainObject
    CBuiltinDomainObject BuiltinDomain(RootDomainObject);

    // Parameter checking
    ASSERT(wcszServerRegName);

    // Stack clearing
    RtlZeroMemory(ServerInfo, sizeof(ServerInfo));
    RtlZeroMemory(EnumServerInfo, sizeof(EnumServerInfo));
    RtlZeroMemory(DomainsKeyInfo, sizeof(DomainsKeyInfo));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //

    NtStatus = NtQueryKey(
                   ServerObject.GetHandle(),
                   KeyFullInformation,
                   &ServerInfo,
                   sizeof(ServerInfo),
                   &ulServerInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulServerInfoLength <= sizeof(ServerInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Domains" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)ServerInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       ServerObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumServerInfo,
                       sizeof(EnumServerInfo),
                       &ulEnumServerInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumServerInfoLength <= sizeof(EnumServerInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumServerInfo)->Name, L"Domains", 7)) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //
            wcszDomainsKeyRegName[0] = L'\0';
            wcscat(wcszDomainsKeyRegName, wcszServerRegName);
            wcscat(wcszDomainsKeyRegName, L"\\Domains");

            NtStatus = DomainsKey.Open(wcszDomainsKeyRegName);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           DomainsKey.GetHandle(),
                           KeyFullInformation,
                           &DomainsKeyInfo,
                           sizeof(DomainsKeyInfo),
                           &ulDomainsKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulDomainsKeyInfoLength <= sizeof(DomainsKeyInfo));

            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we have found the Domains key
    //
    if (0 == ulDomainsKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Domains\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_ERROR);
    }

    //
    // Now, iterate on the "Domains" key - there should only
    // be two domains
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainsKeyInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //
        BYTE  DomainNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
        ULONG ulDomainNameInfoLength;

        WCHAR  wcszDomainRegName[MAX_REGISTRY_NAME_LENGTH];
        WCHAR* temp;
        PDSNAME        DomainDsName = NULL;
        UNICODE_STRING uDomainName;
        ULONG          Size;

        CDomainObject *pDomainObject = NULL;

        // stack clearing
        RtlZeroMemory(DomainNameInfo, sizeof(DomainNameInfo));
        RtlZeroMemory(wcszDomainRegName, sizeof(wcszDomainRegName));


        NtStatus = NtEnumerateKey(
                       DomainsKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       DomainNameInfo,
                       sizeof(DomainNameInfo),
                       &ulDomainNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulDomainNameInfoLength <= sizeof(DomainNameInfo));

        //
        // Construct the name of this registry key
        //
        WCHAR wcszTempBuffer[MAX_REGISTRY_KEY_NAME_LENGTH];
        RtlZeroMemory(wcszTempBuffer, sizeof(wcszTempBuffer));

        wcsncpy(wcszTempBuffer, ((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name,
                ((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR));
        wcszTempBuffer[((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

        wcszDomainRegName[0] = L'\0';
        wcscat(wcszDomainRegName, wcszDomainsKeyRegName);
        wcscat(wcszDomainRegName, L"\\");
        wcscat(wcszDomainRegName, wcszTempBuffer);

        //
        // Which domain is this ?
        //
        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name, L"Account", 7 )) {

            // This is the "Accounts" object full name, which is the
            // container of all other SAM information in the DS

            ASSERT(wcslen(wcszRootDomainDN));

            //
            // There exists no dslayer calls to create a dsname for the domain
            // so we make it here outselves
            //
            Size = (ULONG)DSNameSizeFromLen(wcslen(wcszRootDomainDN));

            DomainDsName = (PDSNAME)MIDL_user_allocate(Size);
            if (!DomainDsName) {
                return STATUS_NO_MEMORY;
            }
            memset(DomainDsName, 0, Size);

            DomainDsName->structLen = Size;
            DomainDsName->NameLen = wcslen(wcszRootDomainDN);
            wcscpy(DomainDsName->StringName, wcszRootDomainDN);

            //
            // Store a global copy for the rest of conversions
            //
            gRootDomainDsName = (PDSNAME) MIDL_user_allocate(Size);
            if (!gRootDomainDsName) {
                return STATUS_NO_MEMORY;
            }
            memcpy(gRootDomainDsName, DomainDsName, Size);

            pDomainObject = &RootDomainObject;

        } else if ( !wcsncmp(((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name, L"Builtin", 7 ) ) {

            //
            // This is the builtin account
            //
            WCHAR wcszBuiltinName[MAX_REGISTRY_KEY_NAME_LENGTH];

            RtlZeroMemory(wcszBuiltinName, sizeof(wcszBuiltinName));

            wcsncpy(wcszBuiltinName,
                   ((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name,
                   ((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR));



            //
            // Create a dsname based on the dn
            //
            RtlInitUnicodeString(&uDomainName,wcszBuiltinName);

            NtStatus = SampDsCreateDsName(gRootDomainDsName,
                                          &uDomainName,
                                          &DomainDsName);
            CheckAndReturn(NtStatus);

            pDomainObject = &BuiltinDomain;



        } else {
            //
            // Bad news - there should not be anything here
            //
            DebugWarning(("DSUPGRAD: Unknown keys found under Domains key - ignoring\n"));
            continue;
        }

        //
        // Now open the subkey, fill and flush! These are all critical
        // operations; bail if necessary
        //


        NtStatus = pDomainObject->Open(wcszDomainRegName);
        CheckAndReturn(NtStatus);

        NtStatus = pDomainObject->Fill();
        CheckAndReturn(NtStatus);

        NtStatus = pDomainObject->Convert();
        CheckAndReturn(NtStatus);


        //
        //  The domain object takes ownership of the ds name
        //
        NtStatus = pDomainObject->Flush(DomainDsName);
        DomainDsName = NULL;
        CheckAndReturn(NtStatus);

        //
        // Transfer all the users; an error status will only be
        // returned if the SAM registry base is corrupt
        //
        NtStatus = ConvertUsers(*pDomainObject,
                                wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Transfer all the groups; an error status will only be
        // returned if the  SAM registry base is corrupt
        //
        NtStatus = ConvertGroups(*pDomainObject,
                                 wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Transfer all the aliases; an error status will only be
        // returned if the SAM registry base is corrupt
        //
        NtStatus = ConvertAliases(*pDomainObject,
                                  wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Now, all the account counts should have been set
        // set in memory, so let's set them on the DS object
        // This is critical since it affects the domain object
        //
        NtStatus = pDomainObject->SetAccountCounts();
        CheckAndReturn(NtStatus);
    }

    return NtStatus;
}


NTSTATUS
ConvertUsers(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Names"
    key, and then converts all users found under that key.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertUsers");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Users" key so we can enumerate it
    CRegistryObject UsersKey;
    BYTE            UsersKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulUsersKeyInfoLength = 0;
    WCHAR           wcszUsersKeyName[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseUserCount = -1;
    DWORD           ActualUserCount = 0;

    BOOLEAN         fReadSuccess = FALSE;

    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(wcszUsersKeyName, sizeof(wcszUsersKeyName));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Users" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength <= sizeof(EnumInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Users", 5 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszUsersKeyName[0] = L'\0';
            wcscat(wcszUsersKeyName, wcszDomainRegName);
            wcscat(wcszUsersKeyName, L"\\Users");

            NtStatus = UsersKey.Open(wcszUsersKeyName);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           UsersKey.GetHandle(),
                           KeyFullInformation,
                           &UsersKeyInfo,
                           sizeof(UsersKeyInfo),
                           &ulUsersKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulUsersKeyInfoLength <= sizeof(UsersKeyInfo));

            //
            // Now get the user count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //
            ULONG KeyValueLength = 0;
            LARGE_INTEGER IgnoreLastWriteTime;

            NtStatus = RtlpNtQueryValueKey(UsersKey.GetHandle(),
                                          &DatabaseUserCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);



            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we've found the "Users" key
    //
    if (0 == ulUsersKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Users\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Users" key - and copy over all users
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)UsersKeyInfo)->SubKeys; i++ ) {

        BYTE  UserNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
        ULONG ulUserNameInfoLength = 0;

        WCHAR   wcszUserRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME UserDsName = NULL;

        PDSNAME         DsObject = NULL;

        // Stack clearing
        RtlZeroMemory(UserNameInfo, sizeof(UserNameInfo));
        RtlZeroMemory(wcszUserRegName, sizeof(wcszUserRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       UsersKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       UserNameInfo,
                       sizeof(UserNameInfo),
                       &ulUserNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulUserNameInfoLength <= sizeof(UserNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)UserNameInfo)->Name, L"Names", 5 )) {

            //
            // This is not a user! Ignore
            //

            continue;
        }

        //
        // Start a new stack frame to make use of destructors
        //
        {

            CUserObject UserObject(RootDomainObject, DomainObject);
            // The name given by NtEnumerateKey is not NULL-terminating

            WCHAR wcszUserName[MAX_REGISTRY_KEY_NAME_LENGTH];
            RtlZeroMemory(wcszUserName, sizeof(wcszUserName));

            wcsncpy(wcszUserName, ((PKEY_BASIC_INFORMATION)UserNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)UserNameInfo)->NameLength/sizeof(WCHAR));
            wcszUserName[((PKEY_BASIC_INFORMATION)UserNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszUserRegName[0] = L'\0';
            wcscat(wcszUserRegName, wcszDomainRegName);
            wcscat(wcszUserRegName, L"\\Users\\");
            wcscat(wcszUserRegName, wcszUserName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next user.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = UserObject.Open(wcszUserRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = UserObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(UserObject.GetAccountName(),
                                              SampUserObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(UserObject.GetAccountName(),
                                                  SampUserObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               UserObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                DWORD   AccountControl = UserObject.GetAccountControl();
                UNICODE_STRING uAccountName;

                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           NULL,        // Domain SID
                                                           SampUserObjectType,
                                                           &uAccountName,
                                                           NULL,        // User RID
                                                           &AccountControl,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &UserDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer
                //

                NtStatus = UserObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
               
                // 
                // Upgrade UserObject's UserParameters Attribute 
                // the error is ignoreable, but we would like to log the error in System Event Log
                // 
                NtStatus = UserObject.UpgradeUserParms();
                
                if (!NT_SUCCESS(NtStatus)) {
                    
                    UNICODE_STRING Name;
                    PUNICODE_STRING NameArray[1];
                
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    
                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, UserObject.GetAccountName());
                    
                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                    // Category 
                                      SAMMSG_ACCEPTABLE_ERROR_UPGRADE_USER,
                                      NULL,                 // User Sid 
                                      1,                    // Num of String 
                                      sizeof(NTSTATUS),     // Data Size
                                      NameArray,            // String Array, contain User Name
                                      (PVOID) &NtStatus     // Data
                                      ); 
                }
                
                //
                //  The user object takes ownership of the ds name
                //
                NtStatus = UserObject.Flush(UserDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                UserDsName = NULL;

                //
                // That's it - fall through to the finally
                //

            }
            __finally
            {
                //
                //  If an error occured, log that this user was unsuccessfully
                //  added.
                //
                if (STATUS_USER_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, UserObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                   // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,                // User Sid
                                      1,                   // Num strings
                                      sizeof(NTSTATUS),    // Data size
                                      NameArray,           // String array
                                      (PVOID)&NtStatus     // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if ( !NT_SUCCESS( NtStatus ) 
                         && !SampIsNtStatusResourceError( NtStatus ) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the user's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, UserObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_USER_NOT_UPGRADED,
                                          NULL,               // User Sid
                                          1,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          NameArray,          // String array
                                          (PVOID)&NtStatus    // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_UNKNOWN_USER_NOT_UPGRADED,
                                          NULL,               // User Sid
                                          0,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          NULL,               // String array
                                          (PVOID)&NtStatus    // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The user was transferred correctly
                    ActualUserCount++;
                }

                fReadSuccess = FALSE;

                if ( RdnBuffer && RdnBuffer != StaticRdnBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            }  // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        if (ActualUserCount != DatabaseUserCount) {
            DebugInfo(("DSUPGRAD: User counts differ\n"));
        }
        DomainObject.SetUserCount(ActualUserCount);
    }

    return NtStatus;

}

NTSTATUS
ConvertGroups(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Groups"
    key, and then converts all groups found under that key. For
    each group, all accounts in that group are transferred too.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertGroups");

    NTSTATUS NtStatus;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Groups" key so we can enumerate it
    CRegistryObject GroupsKey;
    BYTE            GroupsKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulGroupsKeyInfoLength = 0;
    WCHAR           wcszGroupsKey[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseGroupCount = -1;
    DWORD           ActualGroupCount = 0;
    BOOLEAN         fReadSuccess = FALSE;


    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(GroupsKeyInfo, sizeof(GroupsKeyInfo));
    RtlZeroMemory(wcszGroupsKey, sizeof(wcszGroupsKey));


    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Groups" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength <= sizeof(EnumInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Groups", 6 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszGroupsKey[0] = L'\0';
            wcscat(wcszGroupsKey, wcszDomainRegName);
            wcscat(wcszGroupsKey, L"\\Groups");

            NtStatus = GroupsKey.Open(wcszGroupsKey);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           GroupsKey.GetHandle(),
                           KeyFullInformation,
                           &GroupsKeyInfo,
                           sizeof(GroupsKeyInfo),
                           &ulGroupsKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulGroupsKeyInfoLength <= sizeof(GroupsKeyInfo));

            //
            // Now get the group count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //

            //
            ULONG ulGroupCount = 0;
            LARGE_INTEGER IgnoreLastWriteTime;
            ULONG         KeyValueLength = 0;

            NtStatus = RtlpNtQueryValueKey(GroupsKey.GetHandle(),
                                          &DatabaseGroupCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);

            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we have found the Groups key
    //
    if (0 == ulGroupsKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Groups\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Groups" key - and copy over all groups
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)GroupsKeyInfo)->SubKeys; i++ ) {

        BYTE  GroupNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_NAME_LENGTH];
        ULONG ulGroupNameInfoLength = 0;

        WCHAR   wcszGroupRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME GroupDsName = NULL;


        // Stack clearing
        RtlZeroMemory(GroupNameInfo, sizeof(GroupNameInfo));
        RtlZeroMemory(wcszGroupRegName, sizeof(wcszGroupRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       GroupsKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       GroupNameInfo,
                       sizeof(GroupNameInfo),
                       &ulGroupNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulGroupNameInfoLength < sizeof(GroupNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)GroupNameInfo)->Name, L"Names", 5 )) {

            //
            // This is not a group! Ignore
            //

            continue;
        }


        //
        // Start a new stack frame to make use of destructors
        //
        {
            CGroupObject GroupObject(RootDomainObject, DomainObject);

            // The name given by NtEnumerateKey is not always NULL-terminating!

            WCHAR wcszGroupName[MAX_REGISTRY_NAME_LENGTH];
            RtlZeroMemory(wcszGroupName, sizeof(wcszGroupName));

            wcsncpy(wcszGroupName, ((PKEY_BASIC_INFORMATION)GroupNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)GroupNameInfo)->NameLength/sizeof(WCHAR));
            wcszGroupName[((PKEY_BASIC_INFORMATION)GroupNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszGroupRegName[0] = L'\0';
            wcscat(wcszGroupRegName, wcszDomainRegName);
            wcscat(wcszGroupRegName, L"\\Groups\\");
            wcscat(wcszGroupRegName, wcszGroupName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next group.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = GroupObject.Open(wcszGroupRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = GroupObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;


                if (  ( DOMAIN_GROUP_RID_USERS == GroupObject.GetRid() )
                   && ( !SampNT4UpgradeInProgress ) )
                {
                    //
                    // This is the "none" group - don't migrate it
                    //
                    NtStatus = STATUS_SUCCESS;
                    __leave;
                }

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(GroupObject.GetAccountName(),
                                              SampGroupObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(GroupObject.GetAccountName(),
                                                  SampGroupObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               GroupObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                UNICODE_STRING uAccountName;
                ULONG          AccountRid = GroupObject.GetRid();
                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           DomainObject.GetSid(),   // Domain Sid
                                                           SampGroupObjectType,
                                                           &uAccountName,
                                                           NULL,         // Account RID
                                                           NULL,  // Account Control field,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &GroupDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer!
                //

                NtStatus = GroupObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                //  The group object takes ownership of the ds name
                //
                NtStatus = GroupObject.Flush(GroupDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                GroupDsName = NULL;

                //
                // Now add the members
                //
                NtStatus = GroupObject.ConvertMembers();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                // That's it - fall through to the finally
                //
            }
            __finally
            {

                //
                //  If an error occured, log that this Group was unsuccessfully
                //  added.
                //
                if (STATUS_GROUP_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, GroupObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                 // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,              // Group Sid
                                      1,                 // Num strings
                                      sizeof(NTSTATUS),  // Data size
                                      NameArray,         // String array
                                      (PVOID)&NtStatus   // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if (  !NT_SUCCESS( NtStatus )
                          && !SampIsNtStatusResourceError( NtStatus ) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the Group's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, GroupObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                        // Category
                                          SAMMSG_GROUP_NOT_UPGRADED,
                                          NULL,                     // Group Sid
                                          1,                        // Num strings
                                          sizeof(NTSTATUS),         // Data size
                                          NameArray,                // String array
                                          (PVOID)&NtStatus          // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,  // Category
                                          SAMMSG_UNKNOWN_GROUP_NOT_UPGRADED,
                                          NULL, // Group Sid
                                          0, // Num strings
                                          sizeof(NTSTATUS), // Data size
                                          NULL, // String array
                                          (PVOID)&NtStatus // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The Group was transferred correctly
                    ActualGroupCount++;
                }

                fReadSuccess = FALSE;

                if (RdnBuffer && RdnBuffer != StaticRdnBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            } // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        //
        // The -1 on the Database group count accounts for the ommission
        // of the "None" group
        //
        if (ActualGroupCount != (DatabaseGroupCount-1)) {
            DebugInfo(("DSUPGRAD: Group counts differ\n"));
        }
        DomainObject.SetGroupCount(ActualGroupCount);
    }

    return NtStatus;

}

NTSTATUS
ConvertAliases(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Aliases"
    key, and then converts all aliases found under that key. For
    each alias, all accounts in that group are transferred too.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertAliases");

    NTSTATUS NtStatus;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Aliases" key so we can enumerate it
    CRegistryObject AliasesKey;
    BYTE            AliasesKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulAliasesKeyInfoLength = 0;
    WCHAR           wcszAliasesKey[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseAliasCount = -1;
    DWORD           ActualAliasCount = 0;
    BOOLEAN         fReadSuccess = TRUE;


    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(AliasesKeyInfo, sizeof(AliasesKeyInfo));
    RtlZeroMemory(wcszAliasesKey, sizeof(wcszAliasesKey));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Aliases" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength < sizeof(EnumInfo));


        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Aliases", 7 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszAliasesKey[0] = L'\0';
            wcscat(wcszAliasesKey, wcszDomainRegName);
            wcscat(wcszAliasesKey, L"\\Aliases");

            NtStatus = AliasesKey.Open(wcszAliasesKey);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           AliasesKey.GetHandle(),
                           KeyFullInformation,
                           &AliasesKeyInfo,
                           sizeof(AliasesKeyInfo),
                           &ulAliasesKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulAliasesKeyInfoLength <= sizeof(AliasesKeyInfo));

            //
            // Now get the alias count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //

            ULONG KeyValueLength = 0;
            LARGE_INTEGER IgnoreLastWriteTime;

            NtStatus = RtlpNtQueryValueKey(AliasesKey.GetHandle(),
                                          &DatabaseAliasCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);

            // Other keys are irrelevant right now
            break;

        }

    }
    //
    // Make sure we have found the Domains key
    //
    if (0 == ulAliasesKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Aliases\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Aliases" key - and copy over all groups
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)AliasesKeyInfo)->SubKeys; i++ ) {

        BYTE  AliasNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_NAME_LENGTH];
        ULONG ulAliasNameInfoLength;

        WCHAR   wcszAliasRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME AliasDsName = NULL;


        // Stack clearing
        RtlZeroMemory(AliasNameInfo, sizeof(AliasNameInfo));
        RtlZeroMemory(wcszAliasRegName, sizeof(wcszAliasRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       AliasesKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       AliasNameInfo,
                       sizeof(AliasNameInfo),
                       &ulAliasNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulAliasNameInfoLength <= sizeof(AliasNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name, L"Names", 5 )
          || !wcsncmp(((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name, L"Members", 7 )) {

            //
            // This is not a alias! Ignore
            //

            continue;
        }


        //
        // Start a new stack frame to make use of destructors
        //
        {

            CAliasObject AliasObject(RootDomainObject, DomainObject);

            // The name given by NtEnumerateKey is not NULL-terminating
            WCHAR wcszAliasName[MAX_REGISTRY_NAME_LENGTH];
            RtlZeroMemory(wcszAliasName, sizeof(wcszAliasName));

            wcsncpy(wcszAliasName, ((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)AliasNameInfo)->NameLength/sizeof(WCHAR));
            wcszAliasName[((PKEY_BASIC_INFORMATION)AliasNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszAliasRegName[0] = L'\0';
            wcscat(wcszAliasRegName, wcszDomainRegName);
            wcscat(wcszAliasRegName, L"\\Aliases\\");
            wcscat(wcszAliasRegName, wcszAliasName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next group.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = AliasObject.Open(wcszAliasRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = AliasObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;

                if ( DOMAIN_ALIAS_RID_POWER_USERS ==
                     AliasObject.GetRid() )
                {
                    //
                    // This group should not exist on a domain contoller
                    //
                    NtStatus = STATUS_SUCCESS;
                    __leave;
                }

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(AliasObject.GetAccountName(),
                                              SampAliasObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(AliasObject.GetAccountName(),
                                                  SampUserObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               AliasObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                UNICODE_STRING uAccountName;
                ULONG          AccountRid = AliasObject.GetRid();
                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           DomainObject.GetSid(),   // Domain Sid
                                                           SampAliasObjectType,
                                                           &uAccountName,
                                                           NULL,             // Account Rid
                                                           NULL,  // Account Control field,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &AliasDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer!
                //

                NtStatus = AliasObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                //  The alias object takes ownership of the ds name
                //
                NtStatus = AliasObject.Flush(AliasDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                AliasDsName = NULL;

                //
                // Now add the members
                //
                NtStatus = AliasObject.ConvertMembers();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                // That's it - fall through to the finally
                //
            }
            __finally
            {

                //
                //  If an error occured, log that this Alias was unsuccessfully
                //  added.
                //
                if (STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, AliasObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                 // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,              // Sid
                                      1,                 // Num strings
                                      sizeof(NTSTATUS),  // Data size
                                      NameArray,         // String array
                                      (PVOID)&NtStatus   // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if ( !NT_SUCCESS( NtStatus )
                         && !SampIsNtStatusResourceError(NtStatus) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the Alias's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, AliasObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                   // Category
                                          SAMMSG_ALIAS_NOT_UPGRADED,
                                          NULL,                //  Sid
                                          1,                   // Num strings
                                          sizeof(NTSTATUS),    // Data size
                                          NameArray,           // String array
                                          (PVOID)&NtStatus     // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                    // Category
                                          SAMMSG_UNKNOWN_ALIAS_NOT_UPGRADED,
                                          NULL,                 //  Sid
                                          0,                    // Num strings
                                          sizeof(NTSTATUS),     // Data size
                                          NULL,                 // String array
                                          (PVOID)&NtStatus      // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The Alias was transferred correctly
                    ActualAliasCount++;
                }

                fReadSuccess = FALSE;

                if (RdnBuffer && RdnBuffer != StaticRdnBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            } // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // The minus one is for the power users alias omission
        //
        if ( ActualAliasCount != (DatabaseAliasCount-1) ) {
            DebugInfo(("DSUPGRAD: Alias counts differ\n"));
        }
        DomainObject.SetAliasCount(ActualAliasCount);
    }

    return NtStatus;

}


NTSTATUS
CheckForNonExistence(
    WCHAR* AccountName,
    SAMP_OBJECT_TYPE SampObjectType
    )
/*++

Routine Description:

    Given an account name and type, this routine checks to see
    if an account with an equivalent name exists. It also checks
    to see if the account name passed in satisfies all DS constraints


    It is possible that two given SAM user account id's
    map to the same string in the DS/Jet internals.  Check
    to make sure that the account name does not already exist.

Parameters:

    AccountName    : the name of the account
    SampObjectType : the type of the account

Return Values:

    STATUS_SUCCESS if the name does not exist
    STATUS_USER_EXISTS, STATUS_GROUP_EXISTS, STATUS_ALIAS_EXISTS
    Otherwise, ds related error.

--*/
{
    NTSTATUS       NtStatus;
    UNICODE_STRING Name;
    PDSNAME        DsObject = NULL;
    ATTRVAL        AttValCN;
    BOOL           fConstraintCheckPassed = FALSE;

    ASSERT(AccountName);

    RtlInitUnicodeString(&Name, AccountName);


    //
    // The intent of the call to SampDsLookupObjectByNameEx is to determine
    // if we can use the samaccountname of the account as the RDN of the object
    // In most cases this is possible, however the DS uses a different
    // string comparison routine than registry SAM. So there are some cases
    // where two strings are unique for SAM, but not for the DS and since all
    // user objects are placed in the same container, the second object can't
    // use the samaccountname as the RDN since it will conflict.  A common
    // example of these types of names are names with the character 'o' and
    // o<umlate>.  So "foo" and "foo<umlate>", while different sam account names
    // are the same string to the DS.
    //
    
    // 
    // SampDsLookupObjectByNameEx can be controlled to handle this scenario.
    // The flag SAM_UNICODE_STRING_MANUAL_COMPARISON can be passed in to tell
    // the routine to walk through all return values (from a search based
    // on samaccountname) and "manually" compare (do a unicode string compare)
    // to see if the accounts returned have identical samaccountnames or simply
    // samaccountnames that the DS thinks are the same.  For the purposes of 
    // the current routine, we don't want this behavoir, so we don't pass in 
    // the flag.  We want to find all the accounts with samaccountnames that
    // the DS thinks are the same so this routine knows not to use it.
    //

    //
    // Next, SampDsLookupObjectByNameEx will also event log when duplicate
    // accounts are found; we don't want this behavoir either since the message
    // tells the admin to delete the duplicate accounts.  Hence we do pass in
    // in the SAM_UPGRADE_FROM_REGISTRY flag which tells 
    // SampDsLookupObjectByNameEx to not log events when duplicate accounts
    // are found.
    //

    //
    // If a name is found to exist, a unique RDN will be generated.  Its
    // uniqueness is gaureenteed by searching for it to make sure it doesn't
    // already exist and by adding a monotonically increased integer to the end.
    //
    // For example, consider the case where 3 names map to the same name for the
    // DS.  The first once will get its samaccountname as the RDN, the second
    // will get the $AccountNameConflict0, and the third will get
    // $AccountNameConflict1
    //

    NtStatus = SampDsLookupObjectByNameEx(RootDomainObject.GetDsName(),
                                          SampObjectType,
                                          &Name,
                                          &DsObject,
                                          SAM_UPGRADE_FROM_REGISTRY );

    //
    // Use DS constraint check to see if it can be used as a CN
    // SampDsLookupObjectByName would have created a thread state
    // the DsCheckConstraint can use.
    //
    
    AttValCN.valLen = Name.Length;
    AttValCN.pVal = (PUCHAR) Name.Buffer;

    fConstraintCheckPassed = DsCheckConstraint(
                                   ATT_COMMON_NAME,
                                   &AttValCN,
                                   TRUE      // also check RDN 
                                   );

    SampMaybeEndDsTransaction(TransactionCommit);

    if (( NT_SUCCESS(NtStatus) ) || (!fConstraintCheckPassed))
    {
        if (NULL!=DsObject)
        {
            MIDL_user_free(DsObject);
        }

        switch (SampObjectType)
        {

            case SampUserObjectType:
                NtStatus = STATUS_USER_EXISTS;
                break;

            case SampGroupObjectType:
                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SampAliasObjectType:
                NtStatus = STATUS_ALIAS_EXISTS;
                break;

            default:
                ASSERT(FALSE);
                NtStatus = STATUS_USER_EXISTS;
                break;

        }
        DebugWarning(("DSUPGRAD: skipping duplicate name \"%ws\"\n", AccountName));

    }
    else if ( STATUS_NOT_FOUND == NtStatus )
    {
        // Don't have this name yet
        NtStatus = STATUS_SUCCESS;
        NULL;
    }
    else
    {
        // Error case.
        DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
    }

    return NtStatus;

}


WCHAR*
GetNameConflictString(
    ULONG Count
    )

/*++

Routine Description:

    This routine loads the resource table from samsrv.dll to get the
    string used for name conflicts.  If any of these operations fail,
    a harded value is used instead.


Parameters:

   Count, a 32 bit integer

Return Values:

   A unique rdn or null if memory allocation fails

--*/
{

    WCHAR   ConflictCountString[10];  // holds a 32 bit number
    WCHAR   *CountArray[2];
    WCHAR   *UniqueRdn = NULL;
    ULONG   Size, Length;

    //
    // Prepare the unique number as a string
    //
    RtlZeroMemory(ConflictCountString, sizeof(ConflictCountString));
    _itow(Count, ConflictCountString, 10);
    CountArray[0] = (WCHAR*)&(ConflictCountString[0]);
    CountArray[1] = NULL; // this is the sentinel

    if (!SampStringNameResource) {

        SampStringNameResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    }

    if (SampStringNameResource) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        SampStringNameResource,
                                        SAMP_NAME_CONFLICT_RDN,
                                        0,       // Use caller's language
                                        (LPWSTR)&UniqueRdn,
                                        0,       // routine should allocate
                                        (va_list*)&(CountArray[0])
                                        );
        if (UniqueRdn) {
            // Messages from a message file have a cr and lf appended
            // to the end
            UniqueRdn[Length-2] = L'\0';
            Length -= 2;
        }

    }

    if (!UniqueRdn) {

        // Large enough to hold the default string an a 32 bit integer
        Size = (wcslen(SampDefaultConflictString)+1+10)*sizeof(WCHAR);
        UniqueRdn = (WCHAR*)LocalAlloc(0, Size);
        if (UniqueRdn) {

            RtlZeroMemory(UniqueRdn, Size);
            wcscpy(UniqueRdn, SampDefaultConflictString);
            wcscat(UniqueRdn, ConflictCountString);
        }

    }

    return UniqueRdn;
}

extern "C"
NTSTATUS
GetRdnForSamObject(IN  WCHAR* SamAccountName,
                   IN  SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* Rdn,
                   IN OUT ULONG* RdnSize
                   )
/*++

Routine Description:

    This routine finds an rdn for a SAM object. The algorithm is
    as follows:

    1) try to the sam account name - this will work 99.9% of the time
    2) if it does not, then try the string found in the resource table
    for such a case and appended an increasing integer at the end until the
    rdn is unique.

Parameters:

    AccountName    : the name of the account
    SampObjectType : the type of the account
    Rdn            : buffer to put the name into
    Size           : size in bytes of the buffer

Return Values:

    STATUS_SUCCESS

    STATUS_BUFFER_TOO_SMALL if the space provided was not large enough

--*/
{
    NTSTATUS NtStatus;

    ULONG    SamAccountNameSize;
    BOOLEAN  RdnIsUnique = FALSE;
    BOOLEAN  RdnIsNotSamAccountName = FALSE;
    ULONG    NextNumber = 0;

    // Most account names will be MAX_DOWN_LEVEL_NAME_LENGTH
    WCHAR    InitialBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR   *UniqueRdn = InitialBuffer;
    ULONG    UniqueRdnSize = sizeof(InitialBuffer);

    ASSERT(SamAccountName);
    ASSERT(RdnSize);

    RtlZeroMemory(InitialBuffer, sizeof(InitialBuffer));

    if (NULL!=SamAccountName)
    {

        //
        // If an account name is passed in then first try that
        //

        SamAccountNameSize = (wcslen(SamAccountName)+1) * sizeof(WCHAR);
        if (SamAccountNameSize > UniqueRdnSize) {

            UniqueRdn = (WCHAR*)LocalAlloc(0, SamAccountNameSize);
            if (!UniqueRdn) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            UniqueRdnSize = SamAccountNameSize;
        }
        RtlZeroMemory(UniqueRdn, UniqueRdnSize);
        wcscpy(UniqueRdn, SamAccountName);

        //
        // Is this unique?
        //
        NtStatus = CheckForNonExistence(UniqueRdn, SampObjectType);
        switch (NtStatus) {
            case STATUS_USER_EXISTS:
            case STATUS_GROUP_EXISTS:
            case STATUS_ALIAS_EXISTS:

                NtStatus = STATUS_SUCCESS;
                RdnIsUnique = FALSE;
                break;

            case STATUS_SUCCESS:

                RdnIsUnique = TRUE;
                break;

            default:
                // We want to trap these cases. Assume the rdn is not
                // unique
                ASSERT(FALSE);
                NtStatus = STATUS_SUCCESS;
                RdnIsUnique = FALSE;

        }
    }

    if (!RdnIsUnique) {

        RdnIsNotSamAccountName = TRUE;

        NextNumber = SampNameConflictCount;
        do {


            if (UniqueRdn != InitialBuffer) {
                LocalFree(UniqueRdn);
            }

            //
            // This function loads the string from the resource table in
            // samsrv.dll.  (If the loading of the resource table fails, then
            // a hard coded string is used).
            //
            UniqueRdn =  GetNameConflictString(NextNumber);

            if (UniqueRdn) {

                NtStatus = CheckForNonExistence(UniqueRdn, SampObjectType);
                switch (NtStatus) {
                    case STATUS_USER_EXISTS:
                    case STATUS_GROUP_EXISTS:
                    case STATUS_ALIAS_EXISTS:

                        NtStatus = STATUS_SUCCESS;
                        RdnIsUnique = FALSE;
                        break;

                    case STATUS_SUCCESS:

                        RdnIsUnique = TRUE;
                        break;

                    default:
                        // We want to trap these cases. To prevent the possibility
                        // of an endless loop, assume the rdn is unique
                        ASSERT(FALSE);
                        NtStatus = STATUS_SUCCESS;
                        RdnIsUnique = TRUE;
                }

            } else {

                return STATUS_INSUFFICIENT_RESOURCES;

            }

            NextNumber++;

        } while (!RdnIsUnique && NT_SUCCESS(NtStatus));


    }

    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }
    ASSERT(UniqueRdn);

    UniqueRdnSize = (wcslen(UniqueRdn)+1) * sizeof(WCHAR);

    //
    // Return the rdn if we can
    //
    if (Rdn && UniqueRdnSize <= *RdnSize) {
        if ( NextNumber > SampNameConflictCount ) {
            SampNameConflictCount = NextNumber;
        }
        RtlZeroMemory(Rdn, *RdnSize);
        wcscpy(Rdn, UniqueRdn);
        NtStatus = STATUS_SUCCESS;

    } else {

        NtStatus = STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Return the amount buffer space the rdn requires or was
    // used
    //
    *RdnSize = UniqueRdnSize;

    if (UniqueRdn != InitialBuffer) {
        LocalFree(UniqueRdn);
    }

    if ( NT_SUCCESS( NtStatus )
      && RdnIsNotSamAccountName  ) {

        UNICODE_STRING Name;
        PUNICODE_STRING  NameArray[1];
        
        NameArray[0] = &Name;
        RtlInitUnicodeString(&Name, SamAccountName);
        
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,                   // Category
                          SAMMSG_DUPLICATE_ACCOUNT,
                          NULL,                // User Sid
                          1,                   // Num strings
                          sizeof(NTSTATUS),    // Data size
                          NameArray,           // String array
                          (PVOID)&NtStatus     // Data
                          );
        
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\validate.h ===
#include <samrpc.h>

BOOLEAN
SampValidateRpcUnicodeString(
    IN PRPC_UNICODE_STRING UnicodeString
    );

BOOLEAN
SampValidateRpcString(
    IN PRPC_STRING String
    );

BOOLEAN
SampValidateRpcSID(
    IN PRPC_SID SID
    );

BOOLEAN
SampValidateRidEnumeration(
    IN PSAMPR_RID_ENUMERATION RidEnum
    );

BOOLEAN
SampValidateSidEnumeration(
    IN PSAMPR_SID_ENUMERATION SidEnum
    );

BOOLEAN
SampValidateEnumerationBuffer(
    IN PSAMPR_ENUMERATION_BUFFER EnumBuff
    );

BOOLEAN
SampValidateSD(
    IN PSAMPR_SR_SECURITY_DESCRIPTOR SD
    );

BOOLEAN
SampValidateGroupMembership(
    IN PGROUP_MEMBERSHIP GroupMembership
    );

BOOLEAN
SampValidateGroupsBuffer(
    IN PSAMPR_GET_GROUPS_BUFFER GroupsBuffer
    );

BOOLEAN
SampValidateMembersBuffer(
    IN PSAMPR_GET_MEMBERS_BUFFER MembersBuffer
    );

BOOLEAN
SampValidateLogonHours(
    IN PSAMPR_LOGON_HOURS LogonHours
    );

BOOLEAN
SampValidateULongArray(
    IN PSAMPR_ULONG_ARRAY UlongArray
    );

BOOLEAN
SampValidateSIDInformation(
    IN PSAMPR_SID_INFORMATION SIDInformation
    );

BOOLEAN
SampValidateSIDArray(
    IN PSAMPR_PSID_ARRAY SIDArray
    );

BOOLEAN
SampValidateUnicodeStringArray(
    IN PSAMPR_UNICODE_STRING_ARRAY UStringArray
    );

BOOLEAN
SampValidateReturnedString(
    IN PSAMPR_RETURNED_STRING String
    );

BOOLEAN
SampValidateReturnedNormalString(
    IN PSAMPR_RETURNED_NORMAL_STRING String
    );

BOOLEAN
SampValidateReturnedUStringArray(
    IN PSAMPR_RETURNED_USTRING_ARRAY UStringArray
    );

BOOLEAN
SampValidateRevisionInfoV1(
    IN PSAMPR_REVISION_INFO_V1 RevisionInfo
    );

NTSTATUS
SampValidateRevisionInfo(
    IN PSAMPR_REVISION_INFO RevisionInfo,
    IN ULONG RevisionVersion,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateDomainGeneralInformation(
    IN PSAMPR_DOMAIN_GENERAL_INFORMATION GeneralInfo
    );

BOOLEAN
SampValidateDomainGeneralInformation2(
    IN PSAMPR_DOMAIN_GENERAL_INFORMATION2 GeneralInfo
    );

BOOLEAN
SampValidateDomainOemInformation(
    IN PSAMPR_DOMAIN_OEM_INFORMATION OemInfo
    );

BOOLEAN
SampValidateDomainNameInformation(
    IN PSAMPR_DOMAIN_NAME_INFORMATION DomainNameInfo
    );

BOOLEAN
SampValidateDomainReplicationInformation(
    IN PSAMPR_DOMAIN_REPLICATION_INFORMATION DomainRepInfo
    );

BOOLEAN
SampValidateDomainLockoutInformation(
    IN PSAMPR_DOMAIN_LOCKOUT_INFORMATION DomainLockoutInfo
    );

BOOLEAN
SampValidateDomainPasswordInformation(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPassInfo
    );

BOOLEAN
SampValidateDomainLogoffInformation(
    IN PDOMAIN_LOGOFF_INFORMATION DomainLogoffInfo
    );

BOOLEAN
SampValidateDomainServerRoleInformation(
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRoleInfo
    );

BOOLEAN
SampValidateDomainModifiedInformation(
    IN PDOMAIN_MODIFIED_INFORMATION DomainModifiedInfo
    );

BOOLEAN
SampValidateDomainStateInformation(
    IN PDOMAIN_STATE_INFORMATION DomainStateInfo
    );

BOOLEAN
SampValidateDomainModifiedInformation2(
    IN PDOMAIN_MODIFIED_INFORMATION2 DomainModifiedInfo2
    );

NTSTATUS
SampValidateDomainInfoBuffer(
    IN PSAMPR_DOMAIN_INFO_BUFFER DomainInfoBuf,
    IN DOMAIN_INFORMATION_CLASS InfoClass,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateGroupGeneralInformation(
    IN PSAMPR_GROUP_GENERAL_INFORMATION GroupGeneralInfo
    );

BOOLEAN
SampValidateGroupNameInformation(
    IN PSAMPR_GROUP_NAME_INFORMATION GroupNameInfo
    );

BOOLEAN
SampValidateGroupAdmCommentInformation(
    IN PSAMPR_GROUP_ADM_COMMENT_INFORMATION AdmCommentInfo
    );

BOOLEAN
SampValidateGroupAttributeInformation(
    IN PGROUP_ATTRIBUTE_INFORMATION GroupAttrInfo
    );

NTSTATUS
SampValidateGroupInfoBuffer(
    IN PSAMPR_GROUP_INFO_BUFFER GroupInfoBuf,
    IN GROUP_INFORMATION_CLASS GroupInfoClass,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateAliasGeneralInformation(
    IN PSAMPR_ALIAS_GENERAL_INFORMATION AliasGeneralInfo
    );

BOOLEAN
SampValidateAliasNameInformation(
    IN PSAMPR_ALIAS_NAME_INFORMATION AliasNameInfo
    );

BOOLEAN
SampValidateAliasAdmCommentInformation(
    IN PSAMPR_ALIAS_ADM_COMMENT_INFORMATION AliasAdmCommentInfo
    );

NTSTATUS
SampValidateAliasInfoBuffer(
    IN PSAMPR_ALIAS_INFO_BUFFER AliasInfoBuf,
    IN ALIAS_INFORMATION_CLASS AliasInfoClass,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateUserAllInformation(
    IN PSAMPR_USER_ALL_INFORMATION UserAllInfo
    );

BOOLEAN
SampValidateUserInternal3Information(
    IN PSAMPR_USER_INTERNAL3_INFORMATION UserInternal3Info
    );

BOOLEAN
SampValidateUserGeneralInformation(
    IN PSAMPR_USER_GENERAL_INFORMATION UserGeneralInfo
    );

BOOLEAN
SampValidateUserPreferencesInformation(
    IN PSAMPR_USER_PREFERENCES_INFORMATION UserPrefInfo
    );

BOOLEAN
SampValidateUserParametersInformation(
    IN PSAMPR_USER_PARAMETERS_INFORMATION UserParametersInfo
    );

BOOLEAN
SampValidateUserLogonInformation(
    IN PSAMPR_USER_LOGON_INFORMATION UserLogonInfo
    );

BOOLEAN
SampValidateUserAccountInformation(
    IN PSAMPR_USER_ACCOUNT_INFORMATION UserAccountInfo
    );

BOOLEAN
SampValidateUserANameInformation(
    IN PSAMPR_USER_A_NAME_INFORMATION UserANameInfo
    );

BOOLEAN
SampValidateUserFNameInformation(
    IN PSAMPR_USER_F_NAME_INFORMATION UserFNameInfo
    );

BOOLEAN
SampValidateUserNameInformation(
    IN PSAMPR_USER_NAME_INFORMATION UserNameInfo
    );

BOOLEAN
SampValidateUserHomeInformation(
    IN PSAMPR_USER_HOME_INFORMATION UserHomeInfo
    );

BOOLEAN
SampValidateUserScriptInformation(
    IN PSAMPR_USER_SCRIPT_INFORMATION UserScriptInfo
    );

BOOLEAN
SampValidateUserProfileInformation(
    IN PSAMPR_USER_PROFILE_INFORMATION UserProfileInfo
    );

BOOLEAN
SampValidateUserAdminCommentInformation(
    IN PSAMPR_USER_ADMIN_COMMENT_INFORMATION UserAdmCommentInfo
    );

BOOLEAN
SampValidateUserWorkstationsInformation(
    IN PSAMPR_USER_WORKSTATIONS_INFORMATION UserWorkstationsInfo
    );

BOOLEAN
SampValidateUserLogonHoursInformation(
    IN PSAMPR_USER_LOGON_HOURS_INFORMATION UserLogonHoursInfo
    );

BOOLEAN
SampValidateUserInternal1Information(
    IN PSAMPR_USER_INTERNAL1_INFORMATION UserInternal1Info
    );

BOOLEAN
SampValidateUserInternal4Information(
    IN PSAMPR_USER_INTERNAL4_INFORMATION UserInternal4Info
    );

BOOLEAN
SampValidateUserInternal4InformationNew(
    IN PSAMPR_USER_INTERNAL4_INFORMATION_NEW UserInternal4InfoNew
    );

BOOLEAN
SampValidateUserInternal5Information(
    IN PSAMPR_USER_INTERNAL5_INFORMATION UserInternal5Info
    );

BOOLEAN
SampValidateUserInternal5InformationNew(
    IN PSAMPR_USER_INTERNAL5_INFORMATION_NEW UserInternal5InfoNew
    );

BOOLEAN
SampValidateUserPrimaryGroupInformation(
    IN PUSER_PRIMARY_GROUP_INFORMATION UserPrimaryGroupInfo
    );

BOOLEAN
SampValidateUserControlInformation(
    IN PUSER_CONTROL_INFORMATION UserControlInfo
    );

BOOLEAN
SampValidateUserExpiresInformation(
    IN PUSER_EXPIRES_INFORMATION UserExpiresInfo
    );

BOOLEAN
SampValidateUserInternal2Information(
    IN USER_INTERNAL2_INFORMATION *UserInternal2Info
    );

NTSTATUS
SampValidateUserInfoBuffer(
    IN PSAMPR_USER_INFO_BUFFER UserInfoBuf,
    IN USER_INFORMATION_CLASS UserInfoClass,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateDomainDisplayUser(
    IN PSAMPR_DOMAIN_DISPLAY_USER DomainDisplayUser
    );

BOOLEAN
SampValidateDomainDisplayMachine(
    IN PSAMPR_DOMAIN_DISPLAY_MACHINE DomainDisplayMachine
    );

BOOLEAN
SampValidateDomainDisplayGroup(
    IN PSAMPR_DOMAIN_DISPLAY_GROUP DomainDisplayGroup
    );

BOOLEAN
SampValidateDomainDisplayOemUser(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_USER DomainDisplayOemUser
    );

BOOLEAN
SampValidateDomainDisplayOemGroup(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_GROUP DomainDisplayOemGroup
    );

BOOLEAN
SampValidateDomainDisplayUserBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_USER_BUFFER DomainDisplayUserBuffer
    );

BOOLEAN
SampValidateDomainDisplayMachineBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER DomainDisplayMachineBuffer
    );

BOOLEAN
SampValidateDomainDisplayGroupBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_GROUP_BUFFER DomainDisplayGroupBuffer
    );

BOOLEAN
SampValidateDomainDisplayOemUserBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER DomainDisplayOemUserBuffer
    );

BOOLEAN
SampValidateDomainDisplayOemGroupBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER DomainDisplayOemGroupBuffer
    );

NTSTATUS
SampValidateDisplayInfoBuffer(
    IN PSAMPR_DISPLAY_INFO_BUFFER DisplayInfoBuff,
    IN DOMAIN_DISPLAY_INFORMATION DomainDisplayInfoClass,
    IN BOOLEAN Trusted
    );

BOOLEAN
SampValidateValidatePasswordHash(
    IN PSAM_VALIDATE_PASSWORD_HASH PassHash
    );

BOOLEAN
SampValidateValidatePersistedFields(
    IN PSAM_VALIDATE_PERSISTED_FIELDS PersistedFields
    );

BOOLEAN
SampValidateValidateAuthenticationInputArg(
    IN PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG AuthenticationInputArg
    );

BOOLEAN
SampValidateValidatePasswordChangeInputArg(
    IN PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG PassChangeInputArg
    );

BOOLEAN
SampValidateValidatePasswordResetInputArg(
    IN PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG PassResetInputArg
    );

NTSTATUS
SampValidateValidateInputArg(
    IN PSAM_VALIDATE_INPUT_ARG ValidateInputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN BOOLEAN Trusted
    );
BOOLEAN
SampValidateValidateStandartOutputArg(
    IN PSAM_VALIDATE_STANDARD_OUTPUT_ARG StOutputArg
    );

NTSTATUS
SampValidateValidateOutputArg(
    IN PSAM_VALIDATE_OUTPUT_ARG ValidateOutputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN BOOLEAN Trusted
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\dsupgrad.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main Routine to test dsupgrad.lib


Author:

    ColinBr  12-Aug-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#include <stdio.h>
#include <samsrvp.h>
#include <duapi.h>
#include <dslayer.h>
#include <mappings.h>
#include <process.h>


#include "util.h"
#include <sdconvrt.h>

VOID
SampInitDsObjectInfoAttributes(
    );

VOID
SampInitObjectInfoAttributes(
    );

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

NTSTATUS
SampRegistryToDsUpgrade (
    WCHAR* wcszRegPath
    );

VOID
Usage(
    char *pgmName
    )
{
    printf("Usage: %s [/?] [/t] [/i] [/e]\n", pgmName);
    printf("\nThis a tool to move registry based SAM data to a DS.  This should only\nbe run on a PDC and requires that the DS NOT be running.\n");
    printf("\nNote : All operational output is piped through to the kernel debugger\n\n");
    printf("\t/?                Display this usage message\n");
    printf("\t/t                Show function trace (through kd)\n");
    printf("\t/i                Show informational messages(through kd)\n");
    printf("\t/e                Prints status at end of execution\n");

    printf("\n");

    return;
}

void
InitSamGlobals()
{
    RtlInitUnicodeString( &SampCombinedAttributeName, L"C" );
    RtlInitUnicodeString( &SampFixedAttributeName, L"F" );
    RtlInitUnicodeString( &SampVariableAttributeName, L"V" );

    SampInitDsObjectInfoAttributes();
    SampInitObjectInfoAttributes();
}

VOID __cdecl
main(int argc, char *argv[])
/*++

Routine Description:


Parameters:

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    NTSTATUS  UnInitNtStatus = STATUS_SUCCESS;
    BOOL      PrintStatus = FALSE;
    int arg = 1;

    // Parse command-line arguments.
    while(arg < argc)
    {

        if (0 == _stricmp(argv[arg], "/?"))
        {
            Usage(argv[0]);
            exit(0);
        }
        else if (0 == _stricmp(argv[arg], "/t"))
        {
            DebugInfoLevel |= _DEB_TRACE;
        }
        else if (0 == _stricmp(argv[arg], "/i"))
        {
            DebugInfoLevel |= _DEB_INFO;
        }
        else if (0 == _stricmp(argv[arg], "/e"))
        {
            PrintStatus = TRUE;
        }
        else {
            Usage(argv[0]);
            exit(0);
        }

        arg++;
    }

    InitSamGlobals();


    //
    // Initialize the Directory Service.
    //

    NtStatus = SampDsInitialize(FALSE);     // SAM loopback disabled


    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "SampDsInitialize error = 0x%lx\n", NtStatus);
        goto Error;
    }

    //
    // This is a hack to ensure the delayed startup has completed. The real fix
    // is change the dit install so the DS can be running without the interfaces
    // being initialized.
    // 
    NtStatus = DsWaitUntilDelayedStartupIsDone();
    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "DsWaitUntilDelayedStartupIsDone error = 0x%lx\n", 
                NtStatus);
        goto Error;
    }

    //
    // Initialize the security descriptor conversion
    //
					 
    NtStatus = SampInitializeSdConversion();

    
    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "SampInitializeSdConversion = 0x%lx\n", NtStatus);
        goto Error;
    }

    //
    // Do the conversion!
    //
		            
    NtStatus = SampRegistryToDsUpgrade(L"\\Registry\\Machine\\Security\\SAM");
    if (!NT_SUCCESS(NtStatus))
    {
        fprintf(stderr, "SampRegistryToDsUpgrade error = 0x%lx\n", NtStatus);
    }

    //
    //  This fprintf is for processes who might have
    //  created this executable and want to see the return
    //  value.  We do this before SampDsUnitialize because
    //  we suspect it is causing an exception and want the
    //  upgrade to register as successful since all data has
    //  been committted by now.  (BUGBUG - TP workaround.)
    //

    if ( PrintStatus ) {
        fprintf(stderr, "\n$%s$%d$\n", argv[0],
                RtlNtStatusToDosError(NtStatus));
    }

Error:

    __try 
    {
        UnInitNtStatus = SampDsUninitialize();
    } 
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        UnInitNtStatus = STATUS_UNHANDLED_EXCEPTION;
    }

    if (!NT_SUCCESS(UnInitNtStatus))
    {
        fprintf(stderr, "SampDsUninitialize error = 0x%lx\n", UnInitNtStatus);
    }

    //
    // Propogate errors that happened above first
    // 
    if (NT_SUCCESS(NtStatus) && !NT_SUCCESS(UnInitNtStatus)) {
        NtStatus = UnInitNtStatus; 
    }

}

//
// Dummy functions to avoid nasty includes
//

NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )
{
    ASSERT(FALSE);
    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )
{
    ASSERT(FALSE);
    return STATUS_SUCCESS;
}


NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it.

Parameters:

    OutString - A pointer to a destination unicode string

    InString - A pointer to an unicode string to be copied

Return Values:

    None.

--*/

{
    SAMTRACE("SampDuplicateUnicodeString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OutString->Buffer = MIDL_user_allocate( InString->Length );

        if (OutString->Buffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        OutString->MaximumLength = InString->Length;

        RtlCopyUnicodeString(OutString, InString);

    } else {

        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}

VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with a unicode string
    (using MIDL_user_free()).


Arguments:

    Target - The address of a unicode string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeUnicodeString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
    }

    return;
}

NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid OPTIONAL,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller. If this
        paramter is NULL, only the account Rid is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    SAMTRACE("SampSplitSid");

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);


    //
    // Get Domain Sid if caller is intersted in it.
    //

    if (DomainSid)
    {

        //
        // If no buffer is required for the Domain Sid, we have to allocate one.
        //

        if (*DomainSid == NULL) {

            //
            // Allocate space for the domain sid (allocate the same size as the
            // account sid so we can use RtlCopySid)
            //

            *DomainSid = MIDL_user_allocate(AccountSidLength);


            if (*DomainSid == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto SplitSidError;
            }
        }

        //
        // Copy the Account sid into the Domain sid
        //

        RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

        //
        // Decrement the domain sid sub-authority count
        //

        (*RtlSubAuthorityCountSid(*DomainSid))--;
    }


    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}

NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store.




Arguments:

    Context - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;

    SAMTRACE("SampGetObjectSD");


    (*SecurityDescriptorLength) = 0;

    NtStatus = SampGetAccessAttribute(
                    Context,
                    SAMP_OBJECT_SECURITY_DESCRIPTOR,
                    TRUE, // Make copy
                    &Revision,
                    SecurityDescriptor
                    );

    if (NT_SUCCESS(NtStatus)) {

        if ( ((Revision && 0xFFFF0000) > SAMP_MAJOR_REVISION) ||
             (Revision > SAMP_REVISION) ) {

            NtStatus = STATUS_UNKNOWN_REVISION;
        }


        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free( (*SecurityDescriptor) );
        }
    }


    if (NT_SUCCESS(NtStatus)) {
        *SecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                        (*SecurityDescriptor) );
    }

    return(NtStatus);
}


VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    *** This function is added here for the unit test only. ***
    Routine that adds an entry to the event log

Arguments:

    EventType - Type of event.

    EventCategory - EventCategory

    EventID - event log ID.

    UserSid - SID of user involved.

    NumStrings - Number of strings in Strings array

    DataSize - Number of bytes in Data buffer

    Strings - Array of unicode strings

    Data - Pointer to data buffer

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    UNICODE_STRING Source;
    HANDLE LogHandle;

    SAMTRACE("SampWriteEventLog");

    RtlInitUnicodeString(&Source, L"SAM");

    //
    // Open the log
    //

    NtStatus = ElfRegisterEventSourceW (
                        NULL,   // Server
                        &Source,
                        &LogHandle
                        );
    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to registry event source with event log, status = 0x%lx\n", NtStatus));
        return;
    }



    //
    // Write out the event
    //

    NtStatus = ElfReportEventW (
                        LogHandle,
                        EventType,
                        EventCategory,
                        EventID,
                        UserSid,
                        NumStrings,
                        DataSize,
                        Strings,
                        Data,
                        0,       // Flags
                        NULL,    // Record Number
                        NULL     // Time written
                        );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to report event to event log, status = 0x%lx\n", NtStatus));
    }



    //
    // Close the event log
    //

    NtStatus = ElfDeregisterEventSource (LogHandle);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to de-register event source with event log, status = 0x%lx\n", NtStatus));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\usrprop.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_


NTSTATUS
SetUserProperty (
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN PUNICODE_STRING    PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
SetUserPropertyWithLength (
    IN PUNICODE_STRING    UserParms,
    IN LPWSTR             Property,
    IN PUNICODE_STRING    PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

NTSTATUS
QueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

#define USER_PROPERTY_SIGNATURE     L'P'
#define USER_PROPERTY_TYPE_ITEM     1
#define USER_PROPERTY_TYPE_SET      2

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\utility.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This file contains utility services used by several other SAM files.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

  6-11-96: MURLIS  Added logic to branch between registry/ DS cases
  6-16-96: MURLIS  Added  Logic to Open Account/ Adjust Account counts
    16-Aug-96   ChrisMay
        Changed SampShutdownNotify to shutdown the DS.
    08-Oct-1996 ChrisMay
        Added crash-recovery code.
    31-Jan-1997 ChrisMay
        Added RID manager termination code to SampShutdownNotification.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>
#include <dnsapi.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// SampShutdownNotification is called during system shutdown. If this is a DC
// and Shutdown has not been set, the DsUninitialize routine will be executed
// and resets Shutdown to TRUE to prevent multiple calls to SampShutdownNot-
// ification from calling DsUninitialize more than once.

BOOLEAN SampDatabaseHasAlreadyShutdown = FALSE;

//
// Table for Events which should not be written to setup log.
//

ULONG   EventsNotInSetupTable[] =
{
    SAMMSG_RID_MANAGER_INITIALIZATION,
    SAMMSG_RID_POOL_UPDATE_FAILED,
    SAMMSG_GET_NEXT_RID_ERROR,
    SAMMSG_NO_RIDS_ASSIGNED,
    SAMMSG_MAX_DOMAIN_RID,
    SAMMSG_MAX_DC_RID,
    SAMMSG_INVALID_RID,
    SAMMSG_REQUESTING_NEW_RID_POOL,
    SAMMSG_RID_REQUEST_STATUS_SUCCESS,
    SAMMSG_RID_REQUEST_STATUS_FAILURE,
    SAMMSG_RID_MANAGER_CREATION,
    SAMMSG_RID_INIT_FAILURE
};

//
// The list of Invalid Down Level Chars for SAM account Names
//

WCHAR InvalidDownLevelChars[] = TEXT("\"/\\[]:|<>+=;?,*")
                                TEXT("\001\002\003\004\005\006\007")
                                TEXT("\010\011\012\013\014\015\016\017")
                                TEXT("\020\021\022\023\024\025\026\027")
                                TEXT("\030\031\032\033\034\035\036\037");

//
// The maximum length of account names for NT4 Compatibility
//

const ULONG MAX_DOWN_LEVEL_NAME_LENGTH = SAMP_MAX_DOWN_LEVEL_NAME_LENGTH;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Imports                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampDsMakeAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN ULONG WhichFields,
    OUT PDSATTRBLOCK AttrBlock
    );

PVOID
DSAlloc(
    IN ULONG Length
    );

NTSTATUS
SampDsConvertReadAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN PDSATTRBLOCK AttrBlock,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    );

NTSTATUS
SampDsUpdateContextAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength
    );

NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT NewContext,
    IN ULONG        WhichFields,
    IN ULONG        ExtendedFields,
    IN  BOOLEAN  OverrideLocalGroupCheck
    );

//
// This function is defined in kdcexp.h. However including this requires
// a security header cleanup ( kdcexp.h is in security\kerberos\inc and
// also drags in a bunch of kerberos headers, so define the function in
// here
//

NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampRefreshRegistry(
    VOID
    );

NTSTATUS
SampRetrieveAccountCountsRegistry(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );


NTSTATUS
SampAdjustAccountCountRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    );



NTSTATUS
SampEnforceDownlevelNameRestrictions(
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );


VOID
SampFlushNetlogonChangeNumbers();

BOOLEAN
SampEventIsInSetup(
    IN  ULONG   EventID
    );

VOID
SampWriteToSetupLog(
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    );


NTSTATUS
SampSetMachineAccountOwner(
    IN PSAMP_OBJECT UserContext,
    IN PSID NewOwner
    );

NTSTATUS
SampCheckQuotaForPrivilegeMachineAccountCreation(
    VOID
    );

#define IS_DELIMITER(c,_BlankOk) \
    (((c) == L' ' && (_BlankOk)) || \
    ((c) == L'\t') || ((c) == L',') || ((c) == L';'))



ULONG
SampNextElementInUIList(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    );



///////////////////////////////////////////////////////////////////////
//                                                                   //
//          Comments on the useage of SampTransactionWithinDomain    // 
//                                                                   //
///////////////////////////////////////////////////////////////////////

/*++


    SampTransactionWithinDomain and SampTransactionDomainIndex are 
    used by clients to access SAM data structure and backing store.   
    It also sets the scope of the SAM transaction. SampSetTransactionDomain()
    must be called if any domain-specific information is to be modified
    during a transaction. Clients need to hold SAM lock to set 
    TransactionDomain and use SampTransactionDomainIndex. 
    

    For loopback clients, no domain-specific information will be 
    modified, so no need to set Transaction Domain and 
    SampTransactionDomainIndex, plus loopback client doesn't hold 
    SAM lock, so can't use SampTransactionDomainIndex either. 
    However loopback client can use AccountContext->DomainIndex 
    to access (read) domain related info.

    
    For all the other clients, they need to acquire SAM lock before 
    setting TransactionDomain. Once TransactionDomain is set, clients
    can free to modify domain-specific information. 

    There are two sets of APIs, one to set TransactionDomainIndex, the
    other is used to set TransactionWithinDomain Flag. 

    1. SampSetTransactionDomain() is used to set SampTransactionDomainIndex. 
       Also it will turn on SampTransactionWithinDomainGlobal flag. If any 
       thread sets a domain for a transaction and modifies the domain info
       during the transaction, the domain modification count will be updated
       upon commit. In memory copy of domain info will also be updated. 

       SampTransactionDomainIndexFn() is used to return the domain index 
       of the current transaction. 
       
    2. SampSetTransactionWithinDomain() and SampTransactionWithinDomainFn()
       are used to set and retrieve the value of 
       SampTransactionWithinDomainGlobal.

    
    Correct calling sequence
        
        SampAcquireReadLock()  or SampAcquireWriteLock()
        Begin a transaction
        ASSERT(SampTransactionWithinDomain == FALSE) or
                SampSetTransactionWithinDomain(FALSE) 
        SampSetTransactionDomain()
        Access SAM data structure and backing store
        Commit or Abort this transaction        
        SampReleaseReadLock() or SampReleaseWriteLock()
          
--*/

VOID
SampSetTransactionDomain(
    IN ULONG DomainIndex
    )

/*++

Routine Description:

    This routine sets a domain for a transaction.  This must be done
    if any domain-specific information is to be modified during a transaction.
    In this case, the domain modification count will be updated upon commit.

    This causes the UnmodifiedFixed information for the specified domain to
    be copied to the CurrentFixed field for the in-memory representation of
    that domain.


Arguments:

    DomainIndex - Index of the domain within which this transaction
        will occur.


Return Value:

    STATUS_SUCCESS - Indicates the write lock was acquired and the transaction
        was successfully started.

    Other values may be returned as a result of failure to initiate the
    transaction.  These include any values returned by RtlStartRXact().



--*/
{

    SAMTRACE("SampSetTransactionDomain");


    ASSERT((SampCurrentThreadOwnsLock())||(SampServiceState==SampServiceInitializing));
    ASSERT(SampTransactionWithinDomain == FALSE);

    SampSetTransactionWithinDomain(TRUE);
    SampTransactionDomainIndexGlobal =  DomainIndex;

    //
    //  The data in the defined domains structure better be valid at this time
    //

    ASSERT(SampDefinedDomains[SampTransactionDomainIndex].FixedValid == TRUE);

    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed =
    SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed;


    return;

}

ULONG
SampTransactionDomainIndexFn()
/*++

Routine Description:

    this routine returns the domain index of the current transaction.

    The caller must hold SAM lock to reference this global variable.

Return Value:

    domain index of current transcation.

--*/
{
    ASSERT((SampCurrentThreadOwnsLock())||(SampServiceState==SampServiceInitializing));
    return(SampTransactionDomainIndexGlobal);
}

BOOLEAN
SampTransactionWithinDomainFn()
/*++

Routine Description:

    This routine reports whehter TransactionDomain is set or not.

    Only threads holding SAM lock can check the exact state. Clients
    without lock will always get FALSE.   

--*/
{
    if (SampCurrentThreadOwnsLock())
        return(SampTransactionWithinDomainGlobal);
    else
        return(FALSE);
}

VOID
SampSetTransactionWithinDomain(
    IN BOOLEAN  WithinDomain
    )
/*++

Routine Description:

    This routine set/reset the global flag SampTransactionWithinDomainGlobal
    to indicate whether any domain-specific information can be retrieved 
    or modified during a transaction. 
    
    Only clients with SAM lock can set / reset this global.

--*/
{
    if (SampCurrentThreadOwnsLock())
    {
        SampTransactionWithinDomainGlobal = WithinDomain;
    }
#ifdef DBG
    else
    {
        if (WithinDomain)
        {
            ASSERT(FALSE && "SAM Lock is not held");
        }
        else
        {
            ASSERT(FALSE && "SAM Lock is not held");
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Should Not Set it to FALSE\n"));
        }
    }
#endif  // DBG
}



NTSTATUS
SampFlushThread(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This thread is created when SAM's registry tree is changed.
    It will sleep for a while, and if no other changes occur,
    flush the changes to disk.  If other changes keep occurring,
    it will wait for a certain amount of time and then flush
    anyway.

    After flushing, the thread will wait a while longer.  If no
    other changes occur, it will exit.

    Note that if any errors occur, this thread will simply exit
    without flushing.  The mainline code should create another thread,
    and hopefully it will be luckier.  Unfortunately, the error is lost
    since there's nobody to give it to that will be able to do anything
    about it.

Arguments:

    ThreadParameter - not used.

Return Value:

    None.

--*/

{
    TIME minDelayTime, maxDelayTime, exitDelayTime;
    LARGE_INTEGER startedWaitLoop;
    LARGE_INTEGER currentTime;
    NTSTATUS NtStatus;
    BOOLEAN Finished = FALSE;

    UNREFERENCED_PARAMETER( ThreadParameter );

    SAMTRACE("SampFlushThread");

    NtQuerySystemTime( &startedWaitLoop );

    //
    // It would be more efficient to use constants here, but for now
    // we'll recalculate the times each time we start the thread
    // so that somebody playing with us can change the global
    // time variables to affect performance.
    //

    minDelayTime.QuadPart = -1000 * 1000 * 10 *
                   ((LONGLONG)SampFlushThreadMinWaitSeconds);

    maxDelayTime.QuadPart = -1000 * 1000 * 10 *
                   ((LONGLONG)SampFlushThreadMaxWaitSeconds);

    exitDelayTime.QuadPart = -1000 * 1000 * 10 *
                    ((LONGLONG)SampFlushThreadExitDelaySeconds);

    do {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Flush thread sleeping\n"));

        NtDelayExecution( FALSE, &minDelayTime );

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Flush thread woke up\n"));

        NtStatus = SampAcquireWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

#ifdef SAMP_DBG_CONTEXT_TRACKING
            SampDumpContexts();
#endif

            NtQuerySystemTime( &currentTime );

            if ( LastUnflushedChange.QuadPart == SampHasNeverTime.QuadPart ) {

                LARGE_INTEGER exitBecauseNoWorkRecentlyTime;

                //
                // No changes to flush.  See if we should stick around.
                //

                exitBecauseNoWorkRecentlyTime = SampAddDeltaTime(
                                                    startedWaitLoop,
                                                    exitDelayTime
                                                    );

                if ( exitBecauseNoWorkRecentlyTime.QuadPart < currentTime.QuadPart ) {

                    //
                    // We've waited for changes long enough; note that
                    // the thread is exiting.
                    //

                    FlushThreadCreated = FALSE;
                    Finished = TRUE;
                }

            } else {

                LARGE_INTEGER noRecentChangesTime;
                LARGE_INTEGER tooLongSinceFlushTime;

                //
                // There are changes to flush.  See if it's time to do so.
                //

                noRecentChangesTime = SampAddDeltaTime(
                                          LastUnflushedChange,
                                          minDelayTime
                                          );

                tooLongSinceFlushTime = SampAddDeltaTime(
                                            startedWaitLoop,
                                            maxDelayTime
                                            );

                if ( (noRecentChangesTime.QuadPart < currentTime.QuadPart) ||
                     (tooLongSinceFlushTime.QuadPart < currentTime.QuadPart) ) {

                    //
                    // Min time has passed since last change, or Max time
                    // has passed since last flush.  Let's flush.
                    //

                    NtStatus = NtFlushKey( SampKey );


#if SAMP_DIAGNOSTICS
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDiagPrint( DISPLAY_STORAGE_FAIL,
                                       ("SAM: Failed to flush RXact (0x%lx)\n",
                                        NtStatus) );
                        IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                            ASSERT(NT_SUCCESS(NtStatus));  // See following comment
                        }
                    }
#endif //SAMP_DIAGNOSTICS

                    //
                    // Under normal conditions, we would have an
                    // ASSERT(NT_SUCCESS(NtStatus)) here.  However,
                    // Because system shutdown can occur while we
                    // are waiting to flush, we have a race condition.
                    // When shutdown is made, another thread will  be
                    // notified and perform a flush.  That leaves this
                    // flush to potentially occur after the registry
                    // has been notified of system shutdown - which
                    // causes and error to be returned.  Unfortunately,
                    // the error is REGISTRY_IO_FAILED - a great help.
                    //
                    // Despite this, we will only exit this loop only
                    // if we have success.  This may cause us to enter
                    // into another wait and attempt another hive flush
                    // during shutdown, but the wait should never finish
                    // (unless shutdown takes more than 30 seconds).  In
                    // other error situations though, we want to keep
                    // trying the flush until we succeed.   Jim Kelly
                    //


                    if ( NT_SUCCESS(NtStatus) ) {

                        LastUnflushedChange = SampHasNeverTime;
                        NtQuerySystemTime( &startedWaitLoop );

                        FlushThreadCreated = FALSE;
                        Finished = TRUE;
                    }
                }
            }

            SampReleaseWriteLock( FALSE );

        } else {

            DbgPrint("SAM: Thread failed to get write lock, status = 0x%lx\n", NtStatus);
            ASSERT( NT_SUCCESS(NtStatus) || (STATUS_NO_MEMORY == NtStatus) );

            FlushThreadCreated = FALSE;
            Finished = TRUE;
        }

    } while ( !Finished );

    return( STATUS_SUCCESS );
}

VOID
SampInvalidateDomainCache()
/*++

    Routine Description

        This Invalidates the Domain Cache


            WARNING:

            This routine must be called with the Lock held for
            exclusive access


 --*/
{
    ULONG DomainIndex;

    ASSERT(SampCurrentThreadOwnsLock());

    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (SampDefinedDomains[DomainIndex].Context->OnDisk!=NULL)
            SampFreeAttributeBuffer(SampDefinedDomains[DomainIndex].Context);
        SampDefinedDomains[DomainIndex].FixedValid = FALSE;
    }
}


NTSTATUS
SampValidateDomainCache()
/*++

    Routine Description

        This Validates the Domain Cache  for all the domains


            WARNING:

            This routine must be called with the Lock held for
            exclusive access


 --*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN FixedAttributes = NULL;
    ULONG DomainIndex;
    BOOLEAN MixedDomain = TRUE;
    ULONG   BehaviorVersion = 0;
    ULONG   LastLogonTimeStampSyncInterval;
    BOOLEAN fObtainedDomainSettings = FALSE;

    ASSERT(SampCurrentThreadOwnsLock());

    
    for (DomainIndex=0;DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (
            (IsDsObject(SampDefinedDomains[DomainIndex].Context))
            && (!(SampDefinedDomains[DomainIndex].FixedValid))
            )
        {
            //
            // In DS Mode read the mixed domain/behavior version information
            //

            if ((SampUseDsData) &&(!fObtainedDomainSettings))
            {
                NtStatus = SampGetDsDomainSettings(
                                    &MixedDomain,
                                    &BehaviorVersion, 
                                    &LastLogonTimeStampSyncInterval
                                    );
                if (!NT_SUCCESS(NtStatus))
                {
                    return(NtStatus);
                }

                fObtainedDomainSettings = TRUE;
            }

            //
            // For Ds case if Domain Cache is invalid then read the data back
            //
            //

            NtStatus = SampGetFixedAttributes(SampDefinedDomains[DomainIndex].Context,
                                FALSE,
                                (PVOID *)&FixedAttributes
                                );

            //
            // The validate call has to succeed, or if we cannot access the domain object
            // then we are in dire straights anyway. After TP this routine should be made
            // to return a return code and references to this will need to be patched up.
            //

            if (NT_SUCCESS(NtStatus))
            {

                //
                // Update the current fixed and unmodified fixed fields from
                // the data just read from disk
                //

                RtlCopyMemory(
                    &(SampDefinedDomains[DomainIndex].CurrentFixed),
                    FixedAttributes,
                    sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                    );

                RtlCopyMemory(
                    &(SampDefinedDomains[DomainIndex].UnmodifiedFixed),
                    FixedAttributes,
                    sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                    );

                SampDefinedDomains[DomainIndex].CurrentFixed.ServerRole =
                        SampDefinedDomains[DomainIndex].ServerRole;

                SampDefinedDomains[DomainIndex].UnmodifiedFixed.ServerRole =
                        SampDefinedDomains[DomainIndex].ServerRole;

                SampDefinedDomains[DomainIndex].FixedValid = TRUE;

                SampDefinedDomains[DomainIndex].IsMixedDomain = MixedDomain;

                SampDefinedDomains[DomainIndex].BehaviorVersion = BehaviorVersion;

                SampDefinedDomains[DomainIndex].LastLogonTimeStampSyncInterval =
                                                    LastLogonTimeStampSyncInterval;
            }
            else
            {
                break;
            }
        }
    }

    return NtStatus;

}

NTSTATUS
SampValidateDomainCacheCallback(PVOID UnReferencedParameter)
{
  NTSTATUS Status = STATUS_SUCCESS;


  SampAcquireSamLockExclusive();

  Status = SampMaybeBeginDsTransaction(TransactionRead);

  if (NT_SUCCESS(Status))
  {
      Status = SampValidateDomainCache();
  }

  SampMaybeEndDsTransaction(TransactionCommit);
  
  SampReleaseSamLockExclusive();

  if (!NT_SUCCESS(Status))
  {
      LsaIRegisterNotification(
                         SampValidateDomainCacheCallback,
                         NULL,
                         NOTIFIER_TYPE_INTERVAL,
                         0,            // no class
                         NOTIFIER_FLAG_ONE_SHOT,
                         600,        // wait for 10 mins
                         NULL        // no handle
                         );
  }

  return(Status);

}





NTSTATUS
SampCommitChangesToRegistry(
                            BOOLEAN * AbortDone
                            )
/*++
    Description:

      Commits the changes to the Registry.

    Parameters

          AbortDone -- Indicates that an error ocurred and in
                       the process of error handling aborted the
                       transaction
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;


    if ( ( !FlushImmediately ) && ( !FlushThreadCreated ) )
    {

        HANDLE Thread;
        DWORD Ignore;

        //
        // If we can't create the flush thread, ignore error and
        // just flush by hand below.
        //

        Thread = CreateThread(
                     NULL,
                     0L,
                     (LPTHREAD_START_ROUTINE)SampFlushThread,
                     NULL,
                     0L,
                     &Ignore
                     );

        if ( Thread != NULL )
        {

            FlushThreadCreated = TRUE;
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Flush thread created, handle = 0x%lx\n",
                       Thread));

            CloseHandle(Thread);
        }
    }

    NtStatus = RtlApplyRXactNoFlush( SampRXactContext );

#if SAMP_DIAGNOSTICS
    if (!NT_SUCCESS(NtStatus))
    {
        SampDiagPrint( DISPLAY_STORAGE_FAIL,
                       ("SAM: Failed to apply RXact without flush (0x%lx)\n",
                       NtStatus) );
        IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL )
        {
            ASSERT(NT_SUCCESS(NtStatus));

        }
    }
#endif //SAMP_DIAGNOSTICS


    if ( NT_SUCCESS(NtStatus) )
    {

        if ( ( FlushImmediately ) || ( !FlushThreadCreated ) )
        {

            NtStatus = NtFlushKey( SampKey );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus))
            {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to flush RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL )
                {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
             }
#endif //SAMP_DIAGNOSTICS

             if ( NT_SUCCESS( NtStatus ) )
             {
                FlushImmediately = FALSE;
                LastUnflushedChange = SampHasNeverTime;
             }

        }
        else
        {
            NtQuerySystemTime( &LastUnflushedChange );
        }


        //
        // Commit successful, set our unmodified to now be the current...
        //

        if (NT_SUCCESS(NtStatus))
        {
            if (SampTransactionWithinDomain == TRUE)
            {
                SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed =
                    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed;
            }
        }

    }
    else
    {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to commit changes to registry, status = 0x%lx\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Restoring database to earlier consistent state\n"));

            //
            // Add an entry to the event log
            //

        SampWriteEventLog(
                    EVENTLOG_ERROR_TYPE,
                    0,  // Category
                    SAMMSG_COMMIT_FAILED,
                    NULL, // User Sid
                    0, // Num strings
                    sizeof(NTSTATUS), // Data size
                    NULL, // String array
                    (PVOID)&NtStatus // Data
                    );

            //
            // The Rxact commital failed. We don't know how many registry
            // writes were done for this transaction. We can't guarantee
            // to successfully back them out anyway so all we can do is
            // back out all changes since the last flush. When this is done
            // we'll be back to a consistent database state although recent
            // apis that were reported as succeeding will be 'undone'.
            //

        IgnoreStatus = SampRefreshRegistry();

        if (!NT_SUCCESS(IgnoreStatus))
        {

            //
            // This is very serious. We failed to revert to a previous
            // database state and we can't proceed.
            // Shutdown SAM operations.
            //

            SampServiceState = SampServiceTerminating;

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to refresh registry, SAM has shutdown\n"));

            //
            // Add an entry to the event log
            //

            SampWriteEventLog(
                        EVENTLOG_ERROR_TYPE,
                        0,  // Category
                        SAMMSG_REFRESH_FAILED,
                        NULL, // User Sid
                        0, // Num strings
                        sizeof(NTSTATUS), // Data size
                        NULL, // String array
                        (PVOID)&IgnoreStatus // Data
                        );

        }


        //
        // Now all open contexts are invalid (contain invalid registry
        // handles). The in memory registry handles have been
        // re-opened so any new contexts should work ok.
        //


        //
        // All unflushed changes have just been erased.
        // There is nothing to flush
        //
        // If the refresh failed it is important to prevent any further
        // registry flushes until the system is rebooted
        //

        FlushImmediately = FALSE;
        LastUnflushedChange = SampHasNeverTime;

        //
        // The refresh effectively aborted the transaction
        //
        *AbortDone = TRUE;

    }


    return NtStatus;
}



NTSTATUS
SampRefreshRegistry(
    VOID
    )

/*++

Routine Description:

    This routine backs out all unflushed changes in the registry.
    This operation invalidates any open handles to the SAM hive.
    Global handles that we keep around are closed and re-opened by
    this routine. The net result of this call will be that the database
    is taken back to a previous consistent state. All open SAM contexts
    are invalidated since they have invalid registry handles in them.

Arguments:

    STATUS_SUCCESS : Operation completed successfully

    Failure returns: We are in deep trouble. Normal operations can
                     not be resumed. SAM should be shutdown.

Return Value:

    None

--*/
{
    NTSTATUS        NtStatus;
    NTSTATUS        IgnoreStatus;
    HANDLE          HiveKey;
    BOOLEAN         WasEnabled;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  String;
    ULONG           i;

    SAMTRACE("SampRefreshRegistry");

    //
    // Get a key handle to the root of the SAM hive
    //


    RtlInitUnicodeString( &String, L"\\Registry\\Machine\\SAM" );


    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_QUERY_VALUE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &HiveKey,
                   KEY_QUERY_VALUE,
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to open SAM hive root key for refresh, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }


    //
    // Enable restore privilege in preparation for the refresh
    //

    NtStatus = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to enable restore privilege to refresh registry, status = 0x%lx\n",
                   NtStatus));

        IgnoreStatus = NtClose(HiveKey);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(NtStatus);
    }


    //
    // Refresh the SAM hive
    // This should not fail unless there is volatile storage in the
    // hive or we don't have TCB privilege
    //


    NtStatus = NtRestoreKey(HiveKey, NULL, REG_REFRESH_HIVE);


    IgnoreStatus = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = NtClose(HiveKey);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to refresh registry, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }




    //
    // Now close the registry handles we keep in memory at all times
    // This effectively closes all server and domain context keys
    // since they are shared.
    //

    NtStatus = NtClose(SampKey);
    ASSERT(NT_SUCCESS(NtStatus));
    SampKey = INVALID_HANDLE_VALUE;

    for (i = 0; i<SampDefinedDomainsCount; i++ ) {
        NtStatus = NtClose(SampDefinedDomains[i].Context->RootKey);
        ASSERT(NT_SUCCESS(NtStatus));
        SampDefinedDomains[i].Context->RootKey = INVALID_HANDLE_VALUE;
    }

    //
    // Mark all domain and server context handles as invalid since they've
    // now been closed
    //

    SampInvalidateContextListKeysByObjectType(SampServerObjectType, FALSE);
    SampInvalidateContextListKeysByObjectType(SampDomainObjectType, FALSE);

    //
    // Close all account context registry handles for existing
    // open contexts
    //

    SampInvalidateContextListKeysByObjectType(SampUserObjectType, TRUE);
    SampInvalidateContextListKeysByObjectType(SampGroupObjectType, TRUE);
    SampInvalidateContextListKeysByObjectType(SampAliasObjectType, TRUE);


    //
    // Re-open the SAM root key
    //

    RtlInitUnicodeString( &String, L"\\Registry\\Machine\\Security\\SAM" );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SampKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to re-open SAM root key after registry refresh, status = 0x%lx\n",
                   NtStatus));

        ASSERT(FALSE);
        return(NtStatus);
    }

    //
    // Re-initialize the in-memory domain contexts
    // Each domain will re-initialize it's open user/group/alias contexts
    //

    for (i = 0; i<SampDefinedDomainsCount; i++ ) {

        NtStatus = SampReInitializeSingleDomain(i);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to re-initialize domain %d context after registry refresh, status = 0x%lx\n",
                       i,
                       NtStatus));

            return(NtStatus);
        }
    }

    //
    // Cleanup the current transcation context
    // (It would be nice if there were a RtlDeleteRXactContext())
    //
    // Note we don't have to close the rootregistrykey in the
    // xact context since it was SampKey which we've already closed.
    //

    NtStatus = RtlAbortRXact( SampRXactContext );
    ASSERT(NT_SUCCESS(NtStatus));

    NtStatus = NtClose(SampRXactContext->RXactKey);
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Re-initialize the transaction context.
    // We don't expect there to be a partially commited transaction
    // since we're reverting to a previously consistent and committed
    // database.
    //

    NtStatus = RtlInitializeRXact( SampKey, FALSE, &SampRXactContext );
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to re-initialize rxact context registry refresh, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    ASSERT(NtStatus != STATUS_UNKNOWN_REVISION);
    ASSERT(NtStatus != STATUS_RXACT_STATE_CREATED);
    ASSERT(NtStatus != STATUS_RXACT_COMMIT_NECESSARY);
    ASSERT(NtStatus != STATUS_RXACT_INVALID_STATE);

    return(STATUS_SUCCESS);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Unicode registry key manipulation services                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampRetrieveStringFromRegistry(
    IN HANDLE ParentKey,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Body
    )

/*++

Routine Description:

    This routine retrieves a unicode string buffer from the specified registry
    sub-key and sets the output parameter "Body" to be that unicode string.

    If the specified sub-key does not exist, then a null string will be
    returned.

    The string buffer is returned in a block of memory which the caller is
    responsible for deallocating (using MIDL_user_free).



Arguments:

    ParentKey - Key to the parent registry key of the registry key
        containing the unicode string.  For example, to retrieve
        the unicode string for a key called ALPHA\BETA\GAMMA, this
        is the key to ALPHA\BETA.

    SubKeyName - The name of the sub-key whose value contains
        a unicode string to retrieve.  This field should not begin with
        a back-slash (\).  For example, to retrieve the unicode string
        for a key called ALPHA\BETA\GAMMA, the name specified by this
        field would be "BETA".

    Body - The address of a UNICODE_STRING whose fields are to be filled
        in with the information retrieved from the sub-key.  The Buffer
        field of this argument will be set to point to an allocated buffer
        containing the unicode string characters.


Return Value:


    STATUS_SUCCESS - The string was retrieved successfully.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other errors as may be returned by:

            NtOpenKey()
            NtQueryInformationKey()



--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKeyHandle;
    ULONG IgnoreKeyType, KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;

    SAMTRACE("SampRetrieveStringFromRegistry");


    ASSERT(Body != NULL);

    //
    // Get a handle to the sub-key ...
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        SubKeyName,
        OBJ_CASE_INSENSITIVE,
        ParentKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SubKeyHandle,
                   (KEY_READ),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Couldn't open the sub-key
        // If it is OBJECT_NAME_NOT_FOUND, then build a null string
        // to return.  Otherwise, return nothing.
        //

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            Body->Buffer = MIDL_user_allocate( sizeof(UNICODE_NULL) );
            if (Body->Buffer == NULL) {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            Body->Length = 0;
            Body->MaximumLength = sizeof(UNICODE_NULL);
            Body->Buffer[0] = 0;

            return( STATUS_SUCCESS );

        } else {
            return(NtStatus);
        }

    }



    //
    // Get the length of the unicode string
    // We expect one of two things to come back here:
    //
    //      1) STATUS_BUFFER_OVERFLOW - In which case the KeyValueLength
    //         contains the length of the string.
    //
    //      2) STATUS_SUCCESS - In which case there is no string out there
    //         and we need to build an empty string for return.
    //

    KeyValueLength = 0;
    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyType,
                   NULL,
                   &KeyValueLength,
                   &IgnoreLastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyType,
                                NULL,
                                &KeyValueLength,
                                &IgnoreLastWriteTime);

    if (NT_SUCCESS(NtStatus)) {

        KeyValueLength = 0;
        Body->Buffer = MIDL_user_allocate( KeyValueLength + sizeof(WCHAR) ); // Length of null string
        if (Body->Buffer == NULL) {
            IgnoreStatus = NtClose( SubKeyHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Body->Buffer[0] = 0;

    } else {

        if (NtStatus == STATUS_BUFFER_OVERFLOW) {
            Body->Buffer = MIDL_user_allocate(  KeyValueLength + sizeof(WCHAR) );
            if (Body->Buffer == NULL) {
                IgnoreStatus = NtClose( SubKeyHandle );
                ASSERT(NT_SUCCESS(IgnoreStatus));
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            NtStatus = RtlpNtQueryValueKey(
                           SubKeyHandle,
                           &IgnoreKeyType,
                           Body->Buffer,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(&IgnoreKeyType,
                                        Body->Buffer,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

        } else {
            IgnoreStatus = NtClose( SubKeyHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
            return(NtStatus);
        }
    }

    if (!NT_SUCCESS(NtStatus)) {
        MIDL_user_free( Body->Buffer );
        IgnoreStatus = NtClose( SubKeyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        return(NtStatus);
    }

    Body->Length = (USHORT)(KeyValueLength);
    Body->MaximumLength = (USHORT)(KeyValueLength) + (USHORT)sizeof(WCHAR);
    UnicodeTerminate(Body);


    IgnoreStatus = NtClose( SubKeyHandle );
    ASSERT(NT_SUCCESS(IgnoreStatus));
    return( STATUS_SUCCESS );


}


NTSTATUS
SampPutStringToRegistry(
    IN BOOLEAN RelativeToDomain,
    IN PUNICODE_STRING SubKeyName,
    IN PUNICODE_STRING Body
    )

/*++

Routine Description:

    This routine puts a unicode string into the specified registry
    sub-key.

    If the specified sub-key does not exist, then it is created.

    NOTE: The string is assigned via the RXACT mechanism.  Therefore,
          it won't actually reside in the registry key until a commit
          is performed.




Arguments:

    RelativeToDomain - This boolean indicates whether or not the name
        of the sub-key provide via the SubKeyName parameter is relative
        to the current domain or to the top of the SAM registry tree.
        If the name is relative to the current domain, then this value
        is set to TRUE.  Otherwise this value is set to FALSE.

    SubKeyName - The name of the sub-key to be assigned the unicode string.
        This field should not begin with a back-slash (\).  For example,
        to put a unicode string into a key called ALPHA\BETA\GAMMA, the
        name specified by this field would be "BETA".

    Body - The address of a UNICODE_STRING to be placed in the registry.


Return Value:


    STATUS_SUCCESS - The string was added to the RXACT transaction
        successfully.

    STATUS_INSUFFICIENT_RESOURCES - There was not enough heap memory
        or other limited resource available to fullfil the request.

    Other errors as may be returned by:

            RtlAddActionToRXact()



--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;

    SAMTRACE("SampPutStringToRegsitry");


    //
    // Need to build up the name of the key from the root of the RXACT
    // registry key.  That is the root of the SAM registry database
    // in our case.  If RelativeToDomain is FALSE, then the name passed
    // is already relative to the SAM registry database root.
    //

    if (RelativeToDomain == TRUE) {


        NtStatus = SampBuildDomainSubKeyName(
                       &KeyName,
                       SubKeyName
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }


    } else {
        KeyName = (*SubKeyName);
    }


    NtStatus = RtlAddActionToRXact(
                   SampRXactContext,
                   RtlRXactOperationSetValue,
                   &KeyName,
                   0,                   // No KeyValueType
                   Body->Buffer,
                   Body->Length
                   );



    //
    // free the KeyName buffer if necessary
    //

    if (RelativeToDomain) {
        SampFreeUnicodeString( &KeyName );
    }


    return( STATUS_SUCCESS );


}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Unicode String related services - These use MIDL_user_allocate and        //
// MIDL_user_free so that the resultant strings can be given to the          //
// RPC runtime.                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInitUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT MaximumLength
    )

/*++

Routine Description:

    This routine initializes a unicode string to have zero length and
    no initial buffer.


    All allocation for this string will be done using MIDL_user_allocate.

Arguments:

    String - The address of a unicode string to initialize.

    MaximumLength - The maximum length (in bytes) the string will need
        to grow to. The buffer associated with the string is allocated
        to be this size.  Don't forget to allow 2 bytes for null termination.


Return Value:


    STATUS_SUCCESS - Successful completion.

--*/

{
    SAMTRACE("SampInitUnicodeString");

    String->Length = 0;
    String->MaximumLength = MaximumLength;

    String->Buffer = MIDL_user_allocate(MaximumLength);

    if (String->Buffer != NULL) {
        String->Buffer[0] = 0;

        return(STATUS_SUCCESS);
    } else {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}



NTSTATUS
SampAppendUnicodeString(
    IN OUT PUNICODE_STRING Target,
    IN PUNICODE_STRING StringToAdd
    )

/*++

Routine Description:

    This routine appends the string pointed to by StringToAdd to the
    string pointed to by Target.  The contents of Target are replaced
    by the result.


    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.

Arguments:

    Target - The address of a unicode string to initialize to be appended to.

    StringToAdd - The address of a unicode string to be added to the
        end of Target.


Return Value:


    STATUS_SUCCESS - Successful completion.

    STATUS_INSUFFICIENT_RESOURCES - There was not sufficient heap to fullfil
        the requested operation.


--*/
{

    ULONG TotalLength;
    PWSTR NewBuffer;

    SAMTRACE("SampAppendUnicodeString");


    TotalLength = Target->Length + StringToAdd->Length + (USHORT)(sizeof(UNICODE_NULL));

    //
    // Perform a quick overflow test
    //

    if (TotalLength>MAXUSHORT)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // If there isn't room in the target to append the new string,
    // allocate a buffer that is large enough and move the current
    // target into it.
    //

    if (TotalLength > Target->MaximumLength) {

        NewBuffer = MIDL_user_allocate( (ULONG)TotalLength );
        if (NewBuffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( NewBuffer, Target->Buffer, (ULONG)(Target->Length) );

        MIDL_user_free( Target->Buffer );
        Target->Buffer = NewBuffer;
        Target->MaximumLength = (USHORT) TotalLength;

    } else {
        NewBuffer = Target->Buffer;
    }


    //
    // There's now room in the target to append the string.
    //

    (PCHAR)NewBuffer += Target->Length;

    RtlCopyMemory( NewBuffer, StringToAdd->Buffer, (ULONG)(StringToAdd->Length) );


    Target->Length = (USHORT) (TotalLength - (sizeof(UNICODE_NULL)));


    //
    // Null terminate the resultant string
    //

    UnicodeTerminate(Target);

    return(STATUS_SUCCESS);

}



VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with a unicode string
    (using MIDL_user_free()).


Arguments:

    Target - The address of a unicode string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeUnicodeString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
        String->Buffer = NULL;
    }

    return;
}


VOID
SampFreeOemString(
    IN POEM_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with an OEM string
    (using MIDL_user_free()).



Arguments:

    Target - The address of an OEM string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeOemString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
    }

    return;
}


NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )

/*++

Routine Description:

    This routine builds a unicode string name of the string passed
    via the SubKeyName argument.  The resultant name is relative to
    the root of the SAM root registry key.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of three components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

      (optionally)

        4) A backslash

        5) The name of the domain's sub-key (specified by the SubKeyName
           argument).


    For example, if the current domain is called "MY_DOMAIN", then
    the relative name of the sub-key named "FRAMITZ" is :

                "DOMAINS\MY_DOMAIN\FRAMITZ"


    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    KeyName - The address of a unicode string whose buffer is to be filled
        in with the full name of the registry key.  If successfully created,
        this string must be released with SampFreeUnicodeString() when no
        longer needed.


    SubKeyName - (optional) The name of the domain sub-key.  If this parameter
        is not provided, then only the domain's name is produced.
        This string is not modified.




Return Value:





--*/
{
    NTSTATUS NtStatus;
    ULONG    TotalLength;
    USHORT   SubKeyNameLength;

    SAMTRACE("SampBuildDomainSubKeyName");


    ASSERT(SampTransactionWithinDomain == TRUE);


        //
        // Initialize a string large enough to hold the name
        //

        if (ARGUMENT_PRESENT(SubKeyName)) {
            SubKeyNameLength = SampBackSlash.Length + SubKeyName->Length;
        } else {
            SubKeyNameLength = 0;
        }

        TotalLength =   SampNameDomains.Length  +
                        SampBackSlash.Length    +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SubKeyNameLength        +
                        (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

        if (TotalLength>MAXUSHORT)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = SampInitUnicodeString( KeyName, (USHORT) TotalLength );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }


        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( KeyName, &SampNameDomains);
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }

        //
        // "DOMAINS\"
        //

        NtStatus = SampAppendUnicodeString( KeyName, &SampBackSlash );
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }


        //
        // "DOMAINS\(domain name)"
        //

        NtStatus = SampAppendUnicodeString(
                       KeyName,
                       &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                       );
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }


        if (ARGUMENT_PRESENT(SubKeyName)) {

            //
            // "DOMAINS\(domain name)\"
            //



            NtStatus = SampAppendUnicodeString( KeyName, &SampBackSlash );
            if (!NT_SUCCESS(NtStatus)) {
                SampFreeUnicodeString( KeyName );
                return(NtStatus);
            }


            //
            // "DOMAINS\(domain name)\(sub key name)"
            //

            NtStatus = SampAppendUnicodeString( KeyName, SubKeyName );
            if (!NT_SUCCESS(NtStatus)) {
                SampFreeUnicodeString( KeyName );
                return(NtStatus);
            }

        }
    return(NtStatus);

}


NTSTATUS
SampBuildAccountKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN PUNICODE_STRING AccountName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of either a group or user registry key.
    The name produced is relative to the SAM root and will be the name of
    key whose name is the name of the account.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the group or user registry key
           ("GROUPS" or "USERS").

        6) A backslash

        7) The constant name of the registry key containing the
           account names ("NAMES").

    and, if the AccountName is specified,

        8) A backslash

        9) The account name specified by the AccountName argument.


    For example, given a AccountName of "XYZ_GROUP" and the current domain
    is "ALPHA_DOMAIN", this would yield a resultant AccountKeyName of
    "DOMAINS\ALPHA_DOMAIN\GROUPS\NAMES\XYZ_GROUP".



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    AccountKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    AccountName - The name of the account.  This string is not
        modified.




Return Value:


    STATUS_SUCCESS - The name has been built.

    STATUS_INVALID_ACCOUNT_NAME - The name specified is not legitimate.




--*/
{
    NTSTATUS NtStatus;
    ULONG    TotalLength;
    USHORT   AccountNameLength;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    PUNICODE_STRING NamesSubKeyName = NULL;

    SAMTRACE("SampBuildAccountKeyName");


    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    RtlZeroMemory(AccountKeyName, sizeof(UNICODE_STRING));


    //
    // If an account name was provided, then it must meet certain
    // criteria.
    //

    if (ARGUMENT_PRESENT(AccountName)) {
        if (
            //
            // Length must be legitimate
            //

            (AccountName->Length == 0)                          ||
            (AccountName->Length > AccountName->MaximumLength)  ||

            //
            // Buffer pointer is available
            //

            (AccountName->Buffer == NULL)


            ) {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
    }




    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        NamesSubKeyName    = &SampNameDomainGroupsNames;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        NamesSubKeyName    = &SampNameDomainAliasesNames;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        NamesSubKeyName    = &SampNameDomainUsersNames;
        break;
    }




    //
    // Allocate a buffer large enough to hold the entire name.
    // Only count the account name if it is passed.
    //

    AccountNameLength = 0;
    if (ARGUMENT_PRESENT(AccountName)) {
        AccountNameLength = AccountName->Length + SampBackSlash.Length;
    }

    TotalLength =   SampNameDomains.Length          +
                    SampBackSlash.Length            +
                    SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                    SampBackSlash.Length            +
                    AccountTypeKeyName->Length      +
                    SampBackSlash.Length            +
                    NamesSubKeyName->Length         +
                    AccountNameLength               +
                    (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

    if (TotalLength>MAXUSHORT)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NtStatus = SampInitUnicodeString( AccountKeyName, (USHORT) TotalLength );
    if (NT_SUCCESS(NtStatus)) {

        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampNameDomains);
        if (NT_SUCCESS(NtStatus)) {

            //
            // "DOMAINS\"
            //

            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
            if (NT_SUCCESS(NtStatus)) {

                //
                // "DOMAINS\(domain name)"
                //


                NtStatus = SampAppendUnicodeString(
                               AccountKeyName,
                               &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                               );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)\"
                    //

                    NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // "DOMAINS\(domain name)\GROUPS"
                        //  or
                        // "DOMAINS\(domain name)\USERS"
                        //

                        NtStatus = SampAppendUnicodeString( AccountKeyName, AccountTypeKeyName );
                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // "DOMAINS\(domain name)\GROUPS\"
                            //  or
                            // "DOMAINS\(domain name)\USERS\"
                            //

                            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // "DOMAINS\(domain name)\GROUPS\NAMES"
                                //  or
                                // "DOMAINS\(domain name)\USERS\NAMES"
                                //

                                NtStatus = SampAppendUnicodeString( AccountKeyName, NamesSubKeyName );
                                if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(AccountName)) {
                                    //
                                    // "DOMAINS\(domain name)\GROUPS\NAMES\"
                                    //  or
                                    // "DOMAINS\(domain name)\USERS\NAMES\"
                                    //

                                    NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                    if (NT_SUCCESS(NtStatus)) {

                                        //
                                        // "DOMAINS\(domain name)\GROUPS\(account name)"
                                        //  or
                                        // "DOMAINS\(domain name)\USERS\(account name)"
                                        //

                                        NtStatus = SampAppendUnicodeString( AccountKeyName, AccountName );

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

    }


        //
    // Cleanup on error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if ((AccountKeyName)&&(AccountKeyName->Buffer))
        {
            MIDL_user_free(AccountKeyName->Buffer);
            AccountKeyName->Buffer = NULL;
            AccountKeyName->Length = 0;
        }
    }

    return(NtStatus);

}



NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of a key for one of the fields of either
    a user or a group.

    The name produced is relative to the SAM root.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the group or user registry key
           ("Groups" or "Users").

        6) A unicode representation of the reltive ID of the account

   and if the optional SubKeyName is provided:

        7) A backslash

        8) the sub key's name.
        4) The account name specified by the AccountName argument.


    For example, given a AccountRid of 3187, a SubKeyName of "AdminComment"
    and the current domain is "ALPHA_DOMAIN", this would yield a resultant
    AccountKeyName of:

            "DOMAINS\ALPHA_DOMAIN\GROUPS\00003187\AdminComment".



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    AccountKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    AccountName - The name of the account.  This string is not
        modified.

Return Value:

--*/

{
    NTSTATUS NtStatus;
    ULONG  TotalLength;
    USHORT SubKeyNameLength;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    UNICODE_STRING RidNameU;

    SAMTRACE("SampBuildAccountSubKeyName");

    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );


    RtlZeroMemory(AccountKeyName, sizeof(UNICODE_STRING));

    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        break;
    }

    //
    // Determine how much space will be needed in the resultant name
    // buffer to allow for the sub-key-name.
    //

    if (ARGUMENT_PRESENT(SubKeyName)) {
        SubKeyNameLength = SubKeyName->Length + SampBackSlash.Length;
    } else {
        SubKeyNameLength = 0;
    }

    //
    // Convert the account Rid to Unicode.
    //

    NtStatus = SampRtlConvertUlongToUnicodeString(
                   AccountRid,
                   16,
                   8,
                   TRUE,
                   &RidNameU
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // allocate a buffer large enough to hold the entire name
        //

        TotalLength =   SampNameDomains.Length          +
                        SampBackSlash.Length            +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SampBackSlash.Length            +
                        AccountTypeKeyName->Length      +
                        RidNameU.Length                  +
                        SubKeyNameLength                +
                        7*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above

        if (TotalLength>MAXUSHORT)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = SampInitUnicodeString( AccountKeyName, (USHORT)TotalLength );
        if (NT_SUCCESS(NtStatus)) {


            //
            // "DOMAINS"
            //

            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampNameDomains);
            if (NT_SUCCESS(NtStatus)) {

                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)"
                    //


                    NtStatus = SampAppendUnicodeString(
                                   AccountKeyName,
                                   &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // "DOMAINS\(domain name)\"
                        //

                        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // "DOMAINS\(domain name)\GROUPS"
                            //  or
                            // "DOMAINS\(domain name)\USERS"
                            //

                            NtStatus = SampAppendUnicodeString( AccountKeyName, AccountTypeKeyName );
                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // "DOMAINS\(domain name)\GROUPS\"
                                //  or
                                // "DOMAINS\(domain name)\USERS\"
                                //

                                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                if (NT_SUCCESS(NtStatus)) {

                                    //
                                    // "DOMAINS\(domain name)\GROUPS\(rid)"
                                    //  or
                                    // "DOMAINS\(domain name)\USERS\(rid)"
                                    //

                                    NtStatus = SampAppendUnicodeString( AccountKeyName, &RidNameU );

                                    if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(SubKeyName)) {

                                        //
                                        // "DOMAINS\(domain name)\GROUPS\(rid)\"
                                        //  or
                                        // "DOMAINS\(domain name)\USERS\(rid)\"
                                        //

                                        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                        if (NT_SUCCESS(NtStatus)) {

                                            //
                                            // "DOMAINS\(domain name)\GROUPS\(rid)\(sub-key-name)"
                                            //  or
                                            // "DOMAINS\(domain name)\USERS\(rid)\(sub-key-name)"
                                            //

                                            NtStatus = SampAppendUnicodeString( AccountKeyName, SubKeyName );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }

        MIDL_user_free(RidNameU.Buffer);
    }

    //
    // Cleanup on error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if ((AccountKeyName)&&(AccountKeyName->Buffer))
        {
            MIDL_user_free(AccountKeyName->Buffer);
            AccountKeyName->Buffer = NULL;
            AccountKeyName->Length = 0;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampBuildAliasMembersKeyName(
    IN PSID AccountSid,
    OUT PUNICODE_STRING DomainKeyName,
    OUT PUNICODE_STRING AccountKeyName
    )

/*++

Routine Description:

    This routine builds the name of a key for the alias membership for an
    arbitrary account sid. Also produced is the name of the key for the
    domain of the account. This is the account key name without the last
    account rid component.

    The names produced is relative to the SAM root.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The names built up are comprised of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the alias registry key ("Aliases").

        6) A backslash

        7) The constant name of the alias members registry key ("Members").

        8) A backslash

        9) A unicode representation of the SID of the account domain

    and for the AccountKeyName only

        10) A backslash

        11) A unicode representation of the RID of the account


    For example, given a Account Sid of 1-2-3-3187
    and the current domain is "ALPHA_DOMAIN",
    this would yield a resultant AcccountKeyName of:

            "DOMAINS\ALPHA_DOMAIN\ALIASES\MEMBERS\1-2-3\00003187".

    and a DomainKeyName of:

            "DOMAINS\ALPHA_DOMAIN\ALIASES\MEMBERS\1-2-3".



    All allocation for these strings will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    AccountSid - The account whose alias membership in the current domain
    is to be determined.

    DomainKeyName - The address of a unicode string whose
        buffer is to be filled in with the full name of the domain registry key.
        If successfully created, this string must be released with
        SampFreeUnicodeString() when no longer needed.

    AccountKeyName - The address of a unicode string whose
        buffer is to be filled in with the full name of the account registry key.
        If successfully created, this string must be released with
        SampFreeUnicodeString() when no longer needed.




Return Value:

    STATUS_SUCCESS - the domain and account key names are valid.

    STATUS_INVALID_SID - the AccountSid is not valid. AccountSids must have
                         a sub-authority count > 0

--*/

{
    NTSTATUS NtStatus;
    USHORT  DomainTotalLength;
    USHORT  AccountTotalLength;
    UNICODE_STRING DomainNameU, TempStringU;
    UNICODE_STRING RidNameU;
    PSID    DomainSid = NULL;
    ULONG   AccountRid;
    ULONG   AccountSubAuthorities;

    SAMTRACE("SampBuildAliasMembersKeyName");

    DomainNameU.Buffer = TempStringU.Buffer = RidNameU.Buffer = NULL;

    ASSERT(SampTransactionWithinDomain == TRUE);

    ASSERT(AccountSid != NULL);
    ASSERT(DomainKeyName != NULL);
    ASSERT(AccountKeyName != NULL);

    //
    // Initialize Return Values
    //

    RtlZeroMemory(DomainKeyName,sizeof(UNICODE_STRING));
    RtlZeroMemory(AccountKeyName,sizeof(UNICODE_STRING));

    //
    // Split the account sid into domain sid and account rid
    //

    AccountSubAuthorities = (ULONG)*RtlSubAuthorityCountSid(AccountSid);

    //
    // Check for at least one sub-authority
    //

    if (AccountSubAuthorities < 1) {

        return (STATUS_INVALID_SID);
    }

    //
    // Allocate space for the domain sid
    //

    DomainSid = MIDL_user_allocate(RtlLengthSid(AccountSid));

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    if (DomainSid == NULL) {

        return(NtStatus);
    }

    //
    // Initialize the domain sid
    //

    NtStatus = RtlCopySid(RtlLengthSid(AccountSid), DomainSid, AccountSid);
    ASSERT(NT_SUCCESS(NtStatus));

    *RtlSubAuthorityCountSid(DomainSid) = (UCHAR)(AccountSubAuthorities - 1);

    //
    // Initialize the account rid
    //

    AccountRid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorities - 1);

    //
    // Convert the domain sid into a registry key name string
    //

    NtStatus = RtlConvertSidToUnicodeString( &DomainNameU, DomainSid, TRUE);

    if (!NT_SUCCESS(NtStatus)) {
        DomainNameU.Buffer = NULL;
        goto BuildAliasMembersKeyNameError;
    }

    //
    // Convert the account rid into a registry key name string with
    // leading zeros.
    //

    NtStatus = SampRtlConvertUlongToUnicodeString(
                   AccountRid,
                   16,
                   8,
                   TRUE,
                   &RidNameU
                   );

    if (!NT_SUCCESS(NtStatus)) {

        goto BuildAliasMembersKeyNameError;
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // allocate a buffer large enough to hold the entire name
        //

        DomainTotalLength =
                        SampNameDomains.Length          +
                        SampBackSlash.Length            +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SampBackSlash.Length            +
                        SampNameDomainAliases.Length    +
                        SampBackSlash.Length            +
                        SampNameDomainAliasesMembers.Length +
                        SampBackSlash.Length            +
                        DomainNameU.Length               +
                        9*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above



        AccountTotalLength = DomainTotalLength +
                        SampBackSlash.Length            +
                        RidNameU.Length +
                                                3*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above;

        //
        // First build the domain key name
        //


        NtStatus = SampInitUnicodeString( DomainKeyName, DomainTotalLength );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampInitUnicodeString( AccountKeyName, AccountTotalLength );

            if (!NT_SUCCESS(NtStatus)) {

                SampFreeUnicodeString(DomainKeyName);

            } else {

                //
                // "DOMAINS"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomains);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)"
                //

                NtStatus = SampAppendUnicodeString(
                               DomainKeyName,
                               &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                               );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomainAliases);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomainAliasesMembers);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &DomainNameU );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // Now build the account name by copying the domain name
                // and suffixing the account Rid
                //

                RtlCopyUnicodeString(AccountKeyName, DomainKeyName);
                ASSERT(AccountKeyName->Length == DomainKeyName->Length);

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)\"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)\(AccountRid)"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &RidNameU );
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }

        MIDL_user_free(RidNameU.Buffer);
    }

BuildAliasMembersKeyNameFinish:

    //
    // If necessary, free memory allocated for the DomainSid.
    //

    if (DomainSid != NULL) {

        MIDL_user_free(DomainSid);
        DomainSid = NULL;
    }
    if ( DomainNameU.Buffer != NULL ) {
        RtlFreeUnicodeString( &DomainNameU );
    }

    return(NtStatus);

BuildAliasMembersKeyNameError:

    if (AccountKeyName->Buffer)
    {
        MIDL_user_free(AccountKeyName->Buffer);
        AccountKeyName->Buffer = NULL;
    }

    if (DomainKeyName->Buffer)
    {
        MIDL_user_free(DomainKeyName->Buffer);
        DomainKeyName->Buffer = NULL;
    }

    goto BuildAliasMembersKeyNameFinish;
}


NTSTATUS
SampValidateSamAccountName(
    PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine checks whether the NewAccountName has been used any
    exist account or not by searching the SamAccountName attr over DS.
    
    Note: it is used by DS code ONLY.

Parameter:

    NewAccountName - NewAccountName to use
    
Return Value:

    NtStatus - STATUS_SUCCESS: no conflict
               other: can't use this NewAccountName, either found conflict, or error
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRVAL     NameVal;
    ATTR        NameAttr;
    DSNAME      *ExistingObject=NULL;

    NameVal.valLen = (NewAccountName->Length);
    NameVal.pVal = (UCHAR *) NewAccountName->Buffer;
    NameAttr.AttrVal.valCount = 1;
    NameAttr.AttrVal.pAVal = & NameVal;
    NameAttr.attrTyp =
        SampDsAttrFromSamAttr(SampUnknownObjectType,SAMP_UNKNOWN_OBJECTNAME);


    NtStatus = SampDsDoUniqueSearch(
                    SAM_UNICODE_STRING_MANUAL_COMPARISON,
                    ROOT_OBJECT,
                    &NameAttr,
                    &ExistingObject
                    );

    if (STATUS_NOT_FOUND == NtStatus)
    {
        //
        // We did not find the object with the same SamAccountName. 
        // The given name is valid.
        //
        ASSERT(NULL==ExistingObject);
        NtStatus = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        NtStatus = STATUS_USER_EXISTS;
    }

    if (NULL!=ExistingObject)
    {
        MIDL_user_free(ExistingObject);
    }


    return( NtStatus );
}


NTSTATUS
SampValidateAdditionalSamAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine validates the NewAccountName by searching
    AdditionalSamAccountName attribute over DS. Make sure NewAccountName
    is not been used by any account in its AdditionalSamAccountName field.
    
Parameter:

    Context - pointer to object context
    
    NewAccountName - new account name
    
Return Value:

    STATUS_SUCCESS  - no conflict
    
    Other   - this account name has been used by others in AdditionalSamAccountName
              attribute, or error. 

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRVAL     AdditionalNameVal;
    ATTR        AdditionalNameAttr;
    DSNAME      *ExistingObject=NULL;

    // 
    // check ms-DS-Additional-SAM-Account-Name
    // 
    AdditionalNameVal.valLen = (NewAccountName->Length);
    AdditionalNameVal.pVal = (UCHAR *) NewAccountName->Buffer;
    AdditionalNameAttr.AttrVal.valCount = 1;
    AdditionalNameAttr.AttrVal.pAVal = & AdditionalNameVal;
    AdditionalNameAttr.attrTyp = ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;

    NtStatus = SampDsDoUniqueSearch(
                        SAM_UNICODE_STRING_MANUAL_COMPARISON,
                        ROOT_OBJECT,
                        &AdditionalNameAttr,
                        &ExistingObject
                        );

    if (STATUS_NOT_FOUND == NtStatus)
    {
        // 
        // we did not find the object with the same name in 
        // AdditionalSamAccountName attribute. The given name is valid.
        // 
        ASSERT(NULL == ExistingObject);
        NtStatus = STATUS_SUCCESS;
    }
    else if (STATUS_SUCCESS == NtStatus)
    {
        //
        // two functions will call this API. 1) Create new account 2) existing
        // account rename. For 1), SidLen is 0. For 2) Object Sid should be 
        // valid, also we allow client to rename the account to any
        // value in ms-DS-Additional-SAM-Account-Name attribute.
        // 
        NtStatus = STATUS_USER_EXISTS;

        if ((NULL != ExistingObject) && 
            Context->ObjectNameInDs->SidLen && 
            RtlEqualSid(&Context->ObjectNameInDs->Sid, &ExistingObject->Sid)
            )
        {        
            NtStatus = STATUS_SUCCESS;
        }
    }

    if (NULL != ExistingObject)
    {
        MIDL_user_free(ExistingObject);
    }


    return( NtStatus );
}


NTSTATUS
SampValidateNewAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine validates a new user, alias or group account name.
    This routine:

        1) Validates that the name is properly constructed.

        2) Is not already in use as a user, alias or group account name
           in any of the local SAM domains.


Arguments:

    Context - Domain Context (during account creation) or Account Context
              (during account name change).

    Name - The address of a unicode string containing the name to be
        looked for.

    TrustedClient -- Informs the Routine wether the caller is a trusted
    client. Names created through trusted clients are not restricted in the
    same fashion as non-trusted clients.

    ObjectType   -- Informs the routine of the type of Sam object that the
                    caller wants the name validated for. This is used to
                    enforce different restrictions on the name depending
                    upon different object types

Return Value:

    STATUS_SUCCESS - The new account name is valid, and not yet in use.

    STATUS_ALIAS_EXISTS - The account name is already in use as a
        alias account name.

    STATUS_GROUP_EXISTS - The account name is already in use as a
        group account name.

    STATUS_USER_EXISTS - The account name is already in use as a user
        account name.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SID_NAME_USE Use;
    ULONG Rid;
    ULONG DomainIndex, CurrentTransactionDomainIndex;
    ULONG DomainStart;

    SAMTRACE("SampValidateNewAccountName");


    if (!Context->TrustedClient)
    {
        ULONG   i;
        BOOLEAN BlankAccountName = TRUE;

        //
        // Account Name should not be all blank
        //

        for (i = 0; i < NewAccountName->Length/sizeof(WCHAR); i++)
        {
            if (NewAccountName->Buffer[i] != L' ')
            {
                BlankAccountName = FALSE;
            }
        }

        if (BlankAccountName)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }

        //
        // For Non Trusted Clients enforce the same restrictions
        // as user manager.
        //

        NtStatus = SampEnforceDownlevelNameRestrictions(NewAccountName, ObjectType);
        if (!NT_SUCCESS(NtStatus))
        {
            return NtStatus;
        }

       //
       // Enforce that the trailing character is not a '.'
       //

       if (L'.'==NewAccountName->Buffer[NewAccountName->Length/sizeof(WCHAR)-1])
       {
           return(STATUS_INVALID_ACCOUNT_NAME);
       }
    }

    //
    // check if the NewAccountName is a well known name.
    //
    if (LsaILookupWellKnownName(NewAccountName))
    {
        return STATUS_USER_EXISTS;
    }

    //
    // Comment this check out as even though this was a reasonable thing to do
    // NT4 allowed it and PM believes for now that we should not enforce it
    //
#if 0
    //
    // The new account name should not be the name of the domain
    //

    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualUnicodeString(NewAccountName,&SampDefinedDomains[DomainIndex].ExternalName,TRUE))
        {
            return(STATUS_DOMAIN_EXISTS);
        }
    }
#endif

    //
    // In DS mode make a pre-emptive pass on the name, validating
    // whether the object exists. If the object does indeed exist then
    // fall through the loop below to check for correct type of object
    // and get correct error code.
    //

    if (IsDsObject(Context))
    {
        NTSTATUS    SearchStatus;

        //
        // For DS object, we need to check SAM Account Name Table 
        // 
        SearchStatus = SampCheckAccountNameTable(
                            Context,
                            NewAccountName,
                            ObjectType
                            );

        if (!NT_SUCCESS(SearchStatus))
        {
            return( SearchStatus );
        }

        //
        // Validate NewAccountName is not used as SamAccountName by any account.
        // 
        SearchStatus = SampValidateSamAccountName(NewAccountName);

        if (NT_SUCCESS(SearchStatus))
        {

            //
            // Validate NewAccountName is not used in AdditionalSamAccountName
            // by any account
            // 
            SearchStatus = SampValidateAdditionalSamAccountName(
                                Context,
                                NewAccountName
                                );

            return( SearchStatus );

        }
    }


    //
    // Save the current transaction domain indicator
    //

    if (SampTransactionWithinDomain)
    {
        CurrentTransactionDomainIndex = SampTransactionDomainIndex;
    }

    // Initialize the starting index into SampDefinedDomains.

    DomainStart = SampDsGetPrimaryDomainStart();

    //
    // Lookup the account in each of the local SAM domains
    //

    for (DomainIndex = DomainStart;
         ((DomainIndex < (DomainStart + 2)) && NT_SUCCESS(NtStatus));
         DomainIndex++) {

        PSAMP_OBJECT    DomainContext = NULL;

        DomainContext = SampDefinedDomains[ DomainIndex ].Context;

        //
        // Set TransactionWithinDomain ONLY in registy mode
        // 

        if (!IsDsObject(DomainContext))
        {
            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain( DomainIndex );
        }

        NtStatus = SampLookupAccountRid(
                       DomainContext,
                       SampUnknownObjectType,
                       NewAccountName,
                       STATUS_NO_SUCH_USER,
                       &Rid,
                       &Use
                       );

        if (!NT_SUCCESS(NtStatus)) {

            //
            // The only error allowed is that the account was not found.
            // Convert this to success, and continue searching SAM domains.
            // Propagate any other error.
            //

            if (NtStatus != STATUS_NO_SUCH_USER) {

                break;
            }

            NtStatus = STATUS_SUCCESS;

        } else {

            //
            // An account with the given Rid already exists.  Return status
            // indicating the type of the conflicting account.
            //

            switch (Use) {

            case SidTypeUser:

                NtStatus = STATUS_USER_EXISTS;
                break;

            case SidTypeGroup:

                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SidTypeDomain:

                NtStatus = STATUS_DOMAIN_EXISTS;
                break;

            case SidTypeAlias:

                NtStatus = STATUS_ALIAS_EXISTS;
                break;

            case SidTypeWellKnownGroup:

                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SidTypeDeletedAccount:

                NtStatus = STATUS_INVALID_PARAMETER;
                break;

            case SidTypeInvalid:

                NtStatus = STATUS_INVALID_PARAMETER;
                break;

            default:

                NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
                break;
            }
        }
    }

    //
    // Restore the Current Transaction Domain
    //

    if (SampTransactionWithinDomain)
    {
        SampSetTransactionWithinDomain(FALSE);
        SampSetTransactionDomain( CurrentTransactionDomainIndex );
    }

    return(NtStatus);
}


NTSTATUS
SampValidateAccountNameChange(
    IN PSAMP_OBJECT    AccountContext,
    IN PUNICODE_STRING NewAccountName,
    IN PUNICODE_STRING OldAccountName,
    SAMP_OBJECT_TYPE   ObjectType
    )

/*++

Routine Description:

    This routine validates a user, group or alias account name that is
    to be set on an account.  This routine:

        1) Returns success if the name is the same as the existing name,
           except with a different case

        1) Otherwise calls SampValidateNewAccountName to verify that the
           name is properly constructed and is not already in use as a
           user, alias or group account name.

Arguments:

    NewAccountName - The address of a unicode string containing the new
        name.

    OldAccountName - The address of a unicode string containing the old
        name.

    TrustedClient  - Indicates that the caller is a trusted client


    ObjectType     - Indicates the type of object that we are changing the name of

Return Value:

    STATUS_SUCCESS - The account's name may be changed to the new
        account name

    STATUS_ALIAS_EXISTS - The account name is already in use as a
        alias account name.

    STATUS_GROUP_EXISTS - The account name is already in use as a
        group account name.

    STATUS_USER_EXISTS - The account name is already in use as a user
        account name.

    STATUS_INVALID_PARAMETER - If garbage was passed in as the new account
    Name



--*/

{

     SAMTRACE("SampValidateAccountNameChange");


    //
    // Verify that the new unicode string is valid
    //

    if (!((NULL!=NewAccountName->Buffer) && (NewAccountName->Length >0)))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Compare the old and new names without regard for case.  If they
    // are the same, return success because the name was checked when we
    // first added it; we don't care about case changes.
    //


    if ( 0 == RtlCompareUnicodeString(
                  NewAccountName,
                  OldAccountName,
                  TRUE ) ) {

        return( STATUS_SUCCESS );
    }

    //
    // Not just a case change; this is a different name.  Validate it as
    // any new name.
    //

    return( SampValidateNewAccountName( AccountContext,
                                        NewAccountName, 
                                        ObjectType ) 
          );
}



NTSTATUS
SampRetrieveAccountCounts(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    )


/*++

Routine Description:

    This routine retrieve the number of user and group accounts in a domain.



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Arguments:

    UserCount - Receives the number of user accounts in the domain.

    GroupCount - Receives the number of group accounts in the domain.

    AliasCount - Receives the number of alias accounts in the domain.


Return Value:

    STATUS_SUCCESS - The values have been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:
     SampRetrieveAccountsRegistry
     SampRetrieveAcountsDs



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampRetrieveAccountCount");


    ASSERT(SampTransactionWithinDomain == TRUE);

    // Check if a Ds Object
    if (IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context))
        NtStatus = SampRetrieveAccountCountsDs(
                        SampDefinedDomains[SampTransactionDomainIndex].Context,
                        FALSE,          // Get more accurate count
                        UserCount,
                        GroupCount,
                        AliasCount
                        );
     else
        NtStatus = SampRetrieveAccountCountsRegistry(
                        UserCount,
                        GroupCount,
                        AliasCount
                        );
     return NtStatus;

}



NTSTATUS
SampRetrieveAccountCountsDs(
                        IN PSAMP_OBJECT DomainContext,
                        IN BOOLEAN  GetApproximateCount, 
                        OUT PULONG UserCount,
                        OUT PULONG GroupCount,
                        OUT PULONG AliasCount
                        )
/*++

  Retrieve Account Counts from the DS. For the Account Domain we will get approximate numbers from
  the Jet indices. For the builtin domain we will special case to return constant fixed numbers.

  Account counts were originally incorporated in NT3.x and NT4, to support backward compatibilty
  with LanMan 2.0. Accordingly its use can be debated at this juncture. However the published and
  exported Net API return this, and we may be breaking applications by not supporting this feature.
  Hence we must atleast give back approximate account counts.

  It is possible to use Jet escrow columns instead to maintain the account counts. However, Jet has
  the requirement currently ( Jet 600) that every escrow column must be a fixed column. This means that
  either account counts be maintained in a seperate table in Jet or that we sacrifice 12 bytes for every
  object in the DS, neither of which are acceptable solutions at this point.

  Parameters:

    DomainContext Pointer to Open Domain Context
    GetApproximateCount -- Indicate we don't need the exact value, so don't
                           make the expensive DBGetIndexSize()
    UserCount       The count of users is returned in here
    GroupCount      The count of groups is returned in here
    AliasCount      The count of aliases is returned in here

  Return Values

        STATUS_SUCCESS
        Other Return Values from other


--*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (IsBuiltinDomain(DomainContext->DomainIndex))
    {
        *UserCount = 0;
        *GroupCount =0;
        *AliasCount = 8;
    }
    else
    {
        //
        // Account Domain, Query these values from the
        // DS, by looking at the Jet indices.
        //

        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampGetAccountCounts(
                                DomainContext->ObjectNameInDs,
                                GetApproximateCount, 
                                UserCount,
                                GroupCount,
                                AliasCount
                                );
        }
    }

    return NtStatus;
}




NTSTATUS
SampRetrieveAccountCountsRegistry(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    )
/*++

Routine Description:

    This routine retrieve the number of user and group accounts in a domain
    in the registry.Called in by SampRetrieveAccountCounts if its the Registry
    case



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Arguments:

    UserCount - Receives the number of user accounts in the domain.

    GroupCount - Receives the number of group accounts in the domain.

    AliasCount - Receives the number of alias accounts in the domain.


Return Value:

    STATUS_SUCCESS - The values have been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()


--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    UNICODE_STRING KeyName;
    PUNICODE_STRING AccountTypeKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE AccountHandle;
    ULONG KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;



    SAMTRACE("SampRetrieveAccountCountsRegistry");

    //
    // Get the user count first
    //

    AccountTypeKeyName = &SampNameDomainUsers;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         UserCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(UserCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    //
    // Now get the group count
    //

    AccountTypeKeyName = &SampNameDomainGroups;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         GroupCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(GroupCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    //
    // Now get the alias count
    //

    AccountTypeKeyName = &SampNameDomainAliases;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         AliasCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(AliasCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );
    }

    return( NtStatus);

}



NTSTATUS
SampAdjustAccountCount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    )

/*++

Routine Description:

    This is the main wrapper routine for Adjusting account counts
    This routine figures out wether the object is in the Ds or the
    registry and then calls one of the two routines

     Note: THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().
           Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    Increment - a BOOLEAN value indicating whether the user or group
        count is to be incremented or decremented.  A value of TRUE
        will cause the count to be incremented.  A value of FALSE will
        cause the value to be decremented.


Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    Other values are unexpected errors.  These may originate from
    internal calls to sampAdjustAccountCountInRegistry, SampAdjustAccountCount
    inDs

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampAdjustAccountCount");


    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    //
    // Should be called in registry case ONLY
    // 
    ASSERT( !SampUseDsData );

    NtStatus = SampAdjustAccountCountRegistry(
                        ObjectType,
                        Increment
                        );
     return NtStatus;

}






NTSTATUS
SampAdjustAccountCountRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    )

/*++

Routine Description:

    This routine increments or decrements the count of either
    users or groups in a domain.



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    Increment - a BOOLEAN value indicating whether the user or group
        count is to be incremented or decremented.  A value of TRUE
        will cause the count to be incremented.  A value of FALSE will
        cause the value to be decremented.


Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()
            RtlAddActionToRXact()


--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    UNICODE_STRING KeyName;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE AccountHandle;
    ULONG Count, KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;

    SAMTRACE("SampAdjustAccountCount");


    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );


    //
    // Build the name of the key whose count is to be incremented or
    // decremented.
    //

    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        break;
    }

    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         &Count,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(&Count,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            if (NT_SUCCESS(NtStatus)) {

                if (Increment == TRUE) {
                    Count += 1;
                } else {
                    ASSERT( Count != 0 );
                    Count -= 1;
                }

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationSetValue,
                               &KeyName,
                               Count,
                               NULL,
                               0
                               );
            }


            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );
    }


    return( STATUS_SUCCESS );


}




NTSTATUS
SampLookupAccountRid(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    )

/*++

Routine Description:


    This routine attempts to find the RID of the account with the SAM 
    account name Name.
    
    N.B.  The first attempt of resolving the name is to perform a lookup
    in a global cache.  When modifying the behavoir of this function, be sure
    to make sure the cache is modified, if necessary.

Arguments:

    DomainContext - Indicates the domain in which the account lookup is being done

    ObjectType - Indicates whether the name is a user, group or unknown
        type of object.

    Name - The name of the account being looked up.

    NotFoundStatus - Receives a status value to be returned if no name is
        found.

    Rid - Receives the relative ID of account with the specified name.

    Use - Receives an indication of the type of account.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    (NotFoundStatus) - No name by the specified name and type could be
        found.  This value is passed to this routine.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()
                    DsLayer

--*/
{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DSNAME * ObjectName = NULL;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;
    ULONG DomainIndex = DomainContext->DomainIndex;

    ASSERT(DomainContext);


    //
    // Check the cache first
    //
    AccountNameCache = SampDefinedDomains[DomainIndex].AccountNameCache;
    if (AccountNameCache) {

        ULONG i;
        ASSERT(IsBuiltinDomain(DomainIndex));
        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));

        // Assume there is no match
        NtStatus = NotFoundStatus;
        for ( i = 0; i < AccountNameCache->Count; i++ ) {

            PUNICODE_STRING CachedName = &AccountNameCache->Entries[i].Name;
            if (0==RtlCompareUnicodeString(Name,CachedName,TRUE)) {
                // Match!  Note the dependence here on the fact this
                // account is an alias.
                *Use = SidTypeAlias;
                *Rid = AccountNameCache->Entries[i].Rid;
                NtStatus = STATUS_SUCCESS;
                break;
            }
        }

        return NtStatus;
    }

    if (IsDsObject(DomainContext))
    {



        // Do the DS Thing
        NtStatus = SampDsLookupObjectByName(
                        DomainContext->ObjectNameInDs,
                        ObjectType,
                        Name,
                        &ObjectName
                        );
        if NT_SUCCESS(NtStatus)
        {
            ULONG ObjectClass;

            // We found the object, lookup its class and its Rid

            // Define an Attrblock structure to do so. Fill in values
            // field as NULL. DS will fill them out correctly for us upon
            // a Read

            ATTRVAL ValuesDesired[] =
            {
                { sizeof(ULONG), NULL },
                { sizeof(ULONG), NULL },
                { sizeof(ULONG), NULL }
            };

            ATTRTYP TypesDesired[]=
            {
                SAMP_UNKNOWN_OBJECTSID,
                SAMP_UNKNOWN_OBJECTCLASS,
                SAMP_UNKNOWN_GROUP_TYPE
            };
            ATTRBLOCK AttrsRead;
            DEFINE_ATTRBLOCK3(AttrsDesired,TypesDesired,ValuesDesired);

            NtStatus = SampDsRead(
                            ObjectName,
                            0,
                            SampUnknownObjectType,
                            &AttrsDesired,
                            &AttrsRead
                            );


            if NT_SUCCESS(NtStatus)
            {

                 PSID   Sid;
                 NTSTATUS   IgnoreStatus;
                 SAMP_OBJECT_TYPE FoundObjectType;


                 ASSERT(AttrsRead.attrCount>=2);

                 //
                 // Get the Sid
                 //

                 Sid  = AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal;
                 ASSERT(Sid!=NULL);

                 //
                 // Split the Sid
                 //

                 IgnoreStatus = SampSplitSid(Sid,NULL,Rid);
                 ASSERT(NT_SUCCESS(IgnoreStatus));

                 //
                 // Get the Object Class
                 //

                 ObjectClass = *((UNALIGNED ULONG *) AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal);

                 // Map derived class to more basic class which SAM
                 // understands.

                 ObjectClass = SampDeriveMostBasicDsClass(ObjectClass);

                 //
                 // Get the object type from the database
                 //

                 FoundObjectType = SampSamObjectTypeFromDsClass(ObjectClass);

                 if (SampGroupObjectType==FoundObjectType)
                 {
                    ULONG GroupType;

                    ASSERT(3==AttrsRead.attrCount);

                    GroupType = *((UNALIGNED ULONG *) AttrsRead.pAttr[2].AttrVal.pAVal[0].pVal);

                    //
                    // Check the group type for local group ness
                    //

                    if (GroupType & GROUP_TYPE_RESOURCE_BEHAVOIR)
                    {
                        FoundObjectType = SampAliasObjectType;
                    }
                 }

                 switch(FoundObjectType)
                 {
                 case SampDomainObjectType:
                     *Use=SidTypeDomain;
                     break;
                 case SampGroupObjectType:
                     *Use=SidTypeGroup;
                     break;
                 case SampAliasObjectType:
                     *Use=SidTypeAlias;
                     break;
                 case SampUserObjectType:
                     *Use=SidTypeUser;
                     break;
                 case SampUnknownObjectType:
                     *Use=SidTypeUnknown;
                     break;
                 default:
                     *Use=SidTypeInvalid;
                     break;
                 }
            }

            //
            // Free Memory
            //

            MIDL_user_free(ObjectName);
        }
        else
        {
            //
            // We count not find the object
            //

            NtStatus = NotFoundStatus;
        }

    }
    else
    {
        NtStatus = SampLookupAccountRidRegistry(
            ObjectType,
            Name,
            NotFoundStatus,
            Rid,
            Use
            );
    }

    return NtStatus;
}


NTSTATUS
SampLookupAccountRidRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    )

/*++

Routine Description:




Arguments:

    ObjectType - Indicates whether the name is a user, group or unknown
        type of object.

    Name - The name of the account being looked up.

    NotFoundStatus - Receives a status value to be returned if no name is
        found.

    Rid - Receives the relative ID of account with the specified name.

    Use - Receives an indication of the type of account.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    (NotFoundStatus) - No name by the specified name and type could be
        found.  This value is passed to this routine.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()

--*/


{
    NTSTATUS            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND, TmpStatus;
    UNICODE_STRING      KeyName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              TempHandle;
    ULONG               KeyValueLength;
    LARGE_INTEGER                IgnoreLastWriteTime;


    SAMTRACE("SampLookupAccountRidRegistry");


    if (  (ObjectType == SampGroupObjectType  )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the groups for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampGroupObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeGroup;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }

    //
    // No group (or not group type)
    // Try an alias if appropriate
    //

    if (  (ObjectType == SampAliasObjectType  )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the aliases for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampAliasObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeAlias;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }


    //
    // No group (or not group type) nor alias (or not alias type)
    // Try a user if appropriate
    //


    if (  (ObjectType == SampUserObjectType   )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the Users for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeUser;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);


            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        NtStatus = NotFoundStatus;
    }

    return(NtStatus);
}



NTSTATUS
SampLookupAccountNameDs(
    IN PSID                 DomainSid,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType,
    OUT PULONG              AccountType OPTIONAL
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSID     AccountSid = NULL;
    DSNAME   AccountDsName;
    ATTRTYP  SamAccountTypAttrTyp[] = {SAMP_UNKNOWN_ACCOUNT_TYPE,SAMP_UNKNOWN_OBJECTNAME};
    ATTRVAL  SamAccountTypAttrVal[] = {{0,NULL},{0,NULL}};
    ATTRBLOCK AttrsRead;
    DEFINE_ATTRBLOCK2(SamAccountTypAttrs,SamAccountTypAttrTyp,SamAccountTypAttrVal);

    //
    // Initialize Return Values
    //

    *ObjectType = SampUnknownObjectType;

    //
    // Build the Full SID
    //

    NtStatus = SampCreateFullSid(
                    DomainSid,
                    Rid,
                    &AccountSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Build the DS name from the SID
    //

    BuildDsNameFromSid(AccountSid,&AccountDsName);

    //
    // Read the SAM account type attribute
    //

    NtStatus = SampDsRead(
                    &AccountDsName,
                    0,
                    SampUnknownObjectType,
                    &SamAccountTypAttrs,
                    &AttrsRead
                    );

     if (  (NT_SUCCESS(NtStatus))
        && (2==AttrsRead.attrCount)
        && (SAMP_UNKNOWN_ACCOUNT_TYPE==AttrsRead.pAttr[0].attrTyp)
        && (SAMP_UNKNOWN_OBJECTNAME==AttrsRead.pAttr[1].attrTyp)
        && (1==AttrsRead.pAttr[0].AttrVal.valCount)
        && (1==AttrsRead.pAttr[1].AttrVal.valCount)
        && (NULL!=AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal)
        && (NULL!=AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal)
        && (0!=AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen)
        && (sizeof(ULONG)==AttrsRead.pAttr[0].AttrVal.pAVal[0].valLen))
    {
       ULONG SamAccountType =*((PULONG) (AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal));

        if (ARGUMENT_PRESENT(AccountType))
        {
            *AccountType = SamAccountType;
        }

        //
        // Successfully read the sam accounttype . Mask bottom bits and switch on it
        //

        SamAccountType &=0xF0000000;


        switch(SamAccountType)
        {
        case SAM_USER_OBJECT:
             *ObjectType = SampUserObjectType;
             break;

        case SAM_GROUP_OBJECT:
            *ObjectType = SampGroupObjectType;
            break;

        case SAM_APP_BASIC_GROUP:
        case SAM_APP_QUERY_GROUP:
        case SAM_ALIAS_OBJECT:
            *ObjectType = SampAliasObjectType;
            break;

        default:
            *ObjectType = SampUnknownObjectType;
        }

    }
    else if (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus)
    {
        //
        // Its OK if we did not seek to the object with the
        // given SID. The object type value of SampUnknownObjectype
        // is used to indicate this situation.
        //

        NtStatus = STATUS_SUCCESS;
    }

   if ((ARGUMENT_PRESENT(Name))
       && (*ObjectType!=SampUnknownObjectType))
   {
       //
       // We found the object and we want the name
       //

      Name->Buffer = MIDL_user_allocate(AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen);
      if (NULL==Name->Buffer)
      {
          NtStatus = STATUS_NO_MEMORY;
          goto Error;
      }

      RtlCopyMemory(
          Name->Buffer,
          AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal,
          AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen
          );

      Name->Length = (USHORT)AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen;
      Name->MaximumLength = (USHORT)AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen;

   }

Error:

   if (NULL!=AccountSid)
   {
       MIDL_user_free(AccountSid);
       AccountSid = NULL;
   }

   return(NtStatus);
}

NTSTATUS
SampLookupAccountName(
    IN ULONG                DomainIndex,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType
    )
/*++

Routine Description:

    Looks up the specified rid in the current transaction domain.
    Returns its name and account type.


    N.B.  The first attempt of resolving the RID is to perform a lookup
    in a global cache.  When modifying the behavoir of this function, be sure
    to make sure the cache is modified, if necessary.
    
Arguments:

    Rid - The relative ID of account

    Name - Receives the name of the account if ObjectType !=  UnknownObjectType
           The name buffer can be freed using MIDL_user_free

    ObjectType - Receives the type of account this rid represents

                        SampUnknownObjectType - the account doesn't exist
                        SampUserObjectType
                        SampGroupObjectType
                        SampAliasObjectType

Return Value:

    STATUS_SUCCESS - The Service completed successfully, object type contains
                     the type of object this rid represents.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()

--*/
{
    NTSTATUS            NtStatus;
    PSAMP_OBJECT        AccountContext;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;

    SAMTRACE("SampLookupAccountName");

    //
    // Check the cache first
    //
    AccountNameCache = SampDefinedDomains[DomainIndex].AccountNameCache;
    if (AccountNameCache) {

        ULONG i;

        ASSERT(IsBuiltinDomain(DomainIndex));
        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));

        // Assume there is no match
        NtStatus = STATUS_SUCCESS;
        *ObjectType = SampUnknownObjectType;
        for ( i = 0; i < AccountNameCache->Count; i++ ) {
            if (AccountNameCache->Entries[i].Rid == Rid) {
                // Match!  Note the dependence here on the fact this
                // account is an alias.
                *ObjectType = SampAliasObjectType;
                if (Name) {
                    PUNICODE_STRING CachedName = &AccountNameCache->Entries[i].Name;
                    Name->Length = 0;
                    Name->Buffer = MIDL_user_allocate(CachedName->MaximumLength);
                    if (Name->Buffer) {
                        Name->MaximumLength = CachedName->MaximumLength;
                        RtlCopyUnicodeString(Name, CachedName);
                    } else {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
                break;
            }
        }

        return NtStatus;
    }

    //
    // If we are in DS mode, use the faster and thread safe DS mode 
    // routine 
    //

    if (IsDsObject(SampDefinedDomains[DomainIndex].Context))
    {
        //
        // Ds Mode call the DS routine
        //

        return(SampLookupAccountNameDs(
                        SampDefinedDomains[DomainIndex].Sid,
                        Rid,
                        Name,
                        ObjectType,
                        NULL
                        ));
    }

    //
    // Lock should be held and transaction domain should be set
    // if we are in registry mode.
    //

    ASSERT(SampCurrentThreadOwnsLock());
    ASSERT(SampTransactionWithinDomain);

    //
    // Search the groups for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampGroupObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampGroupObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }

    //
    // Search the aliases for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampAliasObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampAliasObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }


    //
    // Search the users for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampUserObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }

    //
    // This account doesn't exist
    //

    *ObjectType = SampUnknownObjectType;

    return(STATUS_SUCCESS);
}



NTSTATUS
SampOpenAccount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AccountId,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *AccountHandle
    )

/*++

Routine Description:

    This API opens an existing user, group or alias account in the account database.
    The account is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened account that may be
    used for successive operations on the account.  This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the account.  These access types are reconciled
        with the Discretionary Access Control list of the account to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the user or group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        user or group.  This handle will be required in successive calls to
        operate on the account.

    WriteLockHeld - if TRUE, the caller holds SAM's SampLock for WRITE
        access, so this routine does not have to obtain it.

Return Values:

    STATUS_SUCCESS - The account was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_NO_SUCH_ALIAS - The specified alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    NTSTATUS            IgnoreStatus;
    PSAMP_OBJECT        NewContext, DomainContext = (PSAMP_OBJECT)DomainHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE;

    SAMTRACE("SampOpenAccount");


    //
    // Grab a read lock, if a lock isn't already held.
    //

    if ( !WriteLockHeld )
    {
        SampMaybeAcquireReadLock(DomainContext, 
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &fLockAcquired );
    }


    //
    // Validate type of, and access to domain object.
    //

    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {

        //
        // Try to create a context for the account.
        //

        NtStatus = SampCreateAccountContext2(
                        DomainContext,                  // Domain Context
                        ObjectType,                     // Object Type
                        AccountId,                      // Relative ID
                        NULL,                           // UserAccountCtrl
                        (PUNICODE_STRING) NULL,         // Account Name
                        DomainContext->ClientRevision,  // Client Revision
                        DomainContext->TrustedClient,   // Trusted Client
                        DomainContext->LoopbackClient,  // Loopback Client
                        FALSE,                          // CreatebByPrivilege
                        TRUE,                           // Account Exists 
                        FALSE,                          // OverrideLocalGroupCheck 
                        NULL,                           // Group Type
                        &NewContext                     // Acount Context (return)
                        );



        if (NT_SUCCESS(NtStatus)) {

            //
            // Reference the object for the validation
            //

            //
            // Do not reference and dereference the context for Ds case for trusted
            // trusted clients. This preserves the buffer that was cached in the context
            // Since we know that trusted clients immediately use the data for account
            // object, this strategy saves us some additional DS calls. For non trusted
            // clients security is a bigger issue and therefore we cannot ever let them
            // deal with possible stale data, so do not do this caching
            //

            if (!(IsDsObject(NewContext) && NewContext->TrustedClient))
                SampReferenceContext(NewContext);

            //
            // Validate the caller's access.
            //

            NtStatus = SampValidateObjectAccess(
                           NewContext,                   //Context
                           DesiredAccess,                //DesiredAccess
                           FALSE                         //ObjectCreation
                           );

            //
            // Dereference object, discarding any changes
            //

            if (!(IsDsObject(NewContext) && NewContext->TrustedClient))
            {
                IgnoreStatus = SampDeReferenceContext(NewContext, FALSE);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            //
            // Clean up the new context if we didn't succeed.
            //

            if (!NT_SUCCESS(NtStatus)) {
                SampDeleteContext( NewContext );
            }

        }


        //
        // De-reference the object, discarding changes
        // 

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Return the account handle
    //

    if (!NT_SUCCESS(NtStatus)) {
        (*AccountHandle) = 0;
    } else {
        (*AccountHandle) = NewContext;
    }


    //
    // Free the lock, if we obtained it.
    //

    if ( !WriteLockHeld ) {
        SampMaybeReleaseReadLock( fLockAcquired );
    }

    return(NtStatus);
}


NTSTATUS
SampCreateAccountContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN AccountExists,
    OUT PSAMP_OBJECT *AccountContext
    )

/*++

Routine Description:

    This is a wrapper for SampCreateAccountContext2.  This function is
    called by SAM code that doesn't not require that the AccountName of
    the object be passed in.

    For parameters and return values see SampCreateAccountContext2

--*/

{
    return SampCreateAccountContext2(NULL,                  // ObjectContext
                                     ObjectType,
                                     AccountId,
                                     NULL,                  // user account control
                                     (PUNICODE_STRING) NULL,// Account name
                                     SAM_CLIENT_PRE_NT5,
                                     TrustedClient,
                                     LoopbackClient,
                                     FALSE,                 // CreateByPrivilege
                                     AccountExists,
                                     FALSE,                 // Override LocalGroupCheck
                                     NULL,                  // Group Type parameter
                                     AccountContext
                                     );
}


NTSTATUS
SampCreateAccountContext2(
    IN PSAMP_OBJECT PassedInContext OPTIONAL,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN OPTIONAL PULONG  UserAccountControl,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN ULONG   ClientRevision,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN CreateByPrivilege,
    IN BOOLEAN AccountExists,
    IN BOOLEAN OverrideLocalGroupCheck,
    IN PULONG  GroupType OPTIONAL,
    OUT PSAMP_OBJECT *AccountContext
    )

/*++

Routine Description:

    This API creates a context for an account object. (User group or alias).
    If the account exists flag is specified, an attempt is made to open
    the object in the database and this api fails if it doesn't exist.
    If AccountExists = FALSE, this routine setups up the context such that
    data can be written into the context and the object will be created
    when they are committed.

    The account is specified by a ID value that is relative to the SID of the
    current transaction domain.

    This call returns a context handle for the newly opened account.
    This handle may be closed with the SampDeleteContext API.

    No access check is performed by this function.

    In Loopback Case, PassedInContext will be provided by caller, so 
    SamTransactionWithinDomain is not a requirment any more, so as long
    as PassedInContext is passed in by caller, SAM lock is NOT required.           

    For all the other case, if PassedInContext is NULL, the below statement
    is still true.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Parameters:

    ObjectType - the type of object to open

    AccountId - the id of the account in the current transaction domain

    UserAccountControl --- If this passed, in then this information is passed
                           down to lower layers, for determining correct objectclass
                           during user account creation.

        AccountName -- the SAM account name of the account

    TrustedClient - TRUE if client is trusted - i.e. server side process.

    LoopbackClient - TRUE if the Client is the DS itself as part of Loopback

    AccountExists - specifies whether the account already exists.

    CreateByPrivilege -  specifies that the account creation has been authorized,
                     because the client holds a privilege that can allows it to
                     create the specified account. Setting this disables all
                     security descriptor controlled access checks.

    OverrideLocalGroupCheck -- Normally only a group with a group type marked as local group
                     is allowed to be opened as an alias object. Setting this flag
                     overrides that option

    GroupType       -- For group creation the group type is specified in here

    AccountContext - Receives context pointer referencing the newly opened account.


Return Values:

    STATUS_SUCCESS - The account was successfully opened.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_NO_SUCH_ALIAS - The specified alias does not exist.

--*/
{

    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            NotFoundStatus = STATUS_NO_SUCH_USER;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PSAMP_OBJECT        NewContext;
    PSAMP_OBJECT        DomainContext;
    DSNAME              *LoopbackName = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG                SecurityDescriptorLength = 0;
    ULONG               DomainIndex;
    BOOLEAN             OpenedBySystem = FALSE;

    SAMTRACE("SampCreateAccountContext");

    //
    // Establish type-specific information
    //

    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    switch (ObjectType) {
    case SampGroupObjectType:
        NotFoundStatus = STATUS_NO_SUCH_GROUP;
        ASSERT(!SampUseDsData || AccountExists || ARGUMENT_PRESENT(GroupType));
        break;
    case SampAliasObjectType:
        NotFoundStatus = STATUS_NO_SUCH_ALIAS;
        ASSERT(!SampUseDsData || AccountExists || ARGUMENT_PRESENT(GroupType));
        break;
    case SampUserObjectType:
        NotFoundStatus = STATUS_NO_SUCH_USER;
        break;
    }

    //
    // Get the Domain Context through the domain index, either 
    // get it from SampTransactionDomainIndex or from passedin context
    //

    if (ARGUMENT_PRESENT(PassedInContext))
    {
        DomainIndex = PassedInContext->DomainIndex;
        OpenedBySystem = PassedInContext->OpenedBySystem;
    }
    else
    {
        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);
        DomainIndex = SampTransactionDomainIndex;
    }

    DomainContext = SampDefinedDomains[DomainIndex].Context;

    //
    // Try to create a context for the account.
    //

    if (LoopbackClient)
    {
        //
        // For DS loopback create a special context
        //

        NewContext = SampCreateContextEx(
                        ObjectType,
                        TrustedClient,
                        TRUE, // DsMode,
                        TRUE, // NotSharedByMultiThreads, - Loopback Client doesn't share context
                        TRUE, // Loopback Client
                        TRUE, // LazyCommit,
                        TRUE, // PersistAcrossCalls,
                        TRUE, // BufferWrites,
                        FALSE,// Opened By DCPromo
                        DomainIndex
                        );

    }
    else
    {

        NewContext = SampCreateContext(
                        ObjectType,
                        DomainIndex,
                        TrustedClient
                        );
    }



    if (NewContext != NULL) {

        //
        // Mark the context as a loopback client if necessary
        //

        NewContext->LoopbackClient = LoopbackClient;

        //
        // Set the client revision in the context
        //

        NewContext->ClientRevision = ClientRevision;

        //
        // Propagate the opened by system flag
        //
     
        NewContext->OpenedBySystem = OpenedBySystem;


        //
        // Set the account's rid
        //

        switch (ObjectType) {
        case SampGroupObjectType:
            NewContext->TypeBody.Group.Rid = AccountId;
            break;
        case SampAliasObjectType:
            NewContext->TypeBody.Alias.Rid = AccountId;
            break;
        case SampUserObjectType:
            NewContext->TypeBody.User.Rid = AccountId;
            break;
        }

        //
        // Also stash away information, if we used the privilege
        // to create accounts
        //
        if ((SampUserObjectType == ObjectType) &&
            (!AccountExists) )
        {
            NewContext->TypeBody.User.PrivilegedMachineAccountCreate = CreateByPrivilege;
        }


        // Check if registry or DS. We have  to do different things depending
        // upon Registry or Ds.

        if (IsDsObject(DomainContext))
        {
            //
            // Domain to which the object belongs ( supposedly) Exists in the DS
            //

            if (AccountExists)
            {
                //
                // If Fast Opens are specified then do not search based on Rid.
                // Contruct a DS Name with the appropriate Sid. This assumes support in the
                // DS to position by such DSNames. The DS then postions based on just the
                // Sid specified in the DS Name and will use the Nc DNT of the primary
                // domain. If Multiple domain support is desired then this logic will then
                // need to be revisited.
                //

                DSNAME * NewDsName=NULL;

                NewDsName = MIDL_user_allocate(sizeof(DSNAME));
                if (NULL!=NewDsName)
                {
                    PSID  AccountSid;
                    PSID    DomainSid;

                    //
                    // Create the Account Sid
                    //

                    DomainSid =  SampDefinedDomains[DomainIndex].Sid;
                    NtStatus = SampCreateFullSid(DomainSid, AccountId,&AccountSid);
                    if (NT_SUCCESS(NtStatus))
                    {
                        // Build the Sid only DSName and free the account sid
                        // generated by SampCreateFullSid
                        BuildDsNameFromSid(AccountSid,NewDsName);
                        MIDL_user_free(AccountSid);

                        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
                        if (NT_SUCCESS(NtStatus))
                        {
                            // Set the DSName in the Context
                            NewContext->ObjectNameInDs = NewDsName;

                            // Prefetch Sam Properties
                            NtStatus = SampDsCheckObjectTypeAndFillContext(
                                            ObjectType,
                                            NewContext,
                                            0,
                                            0,
                                            OverrideLocalGroupCheck
                                            );

                            // If We got a name error then reset the failure
                            // status to object not found
                            if ((STATUS_OBJECT_NAME_INVALID==NtStatus)
                                 || (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus))
                                NtStatus = NotFoundStatus;
                        }
                    }
                }
                else
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                #ifdef DBG

                //
                // On a Checked Build do an addtional validation for the Uniqueness
                // of the Sid within the Nc. The below code with a special SAMP
                // global flag will print out all instances of conflicts into the
                // kernel debugger.
                //

                if (NT_SUCCESS(NtStatus))
                {
                    DSNAME * ObjectName=NULL;
                    NTSTATUS IgnoreStatus;

                    IgnoreStatus = SampDsLookupObjectByRid(
                                    DomainContext->ObjectNameInDs,
                                    AccountId,
                                    &(ObjectName)
                                    );
                    // ASSERT(NT_SUCCESS(IgnoreStatus));

                    if (NT_SUCCESS(IgnoreStatus))
                    {
                        MIDL_user_free(ObjectName);
                    }
                }

               #endif
            }
            else
            {
                BOOLEAN fLoopBack = FALSE;
                BOOLEAN fDSA = FALSE;

                ASSERT(AccountName);

                if (SampExistsDsLoopback(&LoopbackName))
                {
                    //
                    // If it is the loop back case then get the actual Class Id by looking
                    // into the loopback structure. We will not set the security Descriptor
                    // because we are not running as fDSA and the DS will consider whichever
                    // security descriptor the LDAP client passed in.
                    //

                    SampGetLoopbackObjectClassId(&(NewContext->DsClassId));
                    fLoopBack = TRUE;
                }
                else
                {
                    //
                    // No this is not a loopback case. The client never passes in a security
                    // descriptor and since we will be running as fDSA we will have to pass
                    // in a security descriptor. For this we obtain the security descriptor from
                    // the schema. Note that we must obtain a security descriptor from the schema
                    // for the call to succeed. Further Pass in a trusted client Bit. For trusted
                    // clients no impersonation is done, but the owner and the group is set to the
                    // the Administrators Alias. For Non Trusted Clients the Client Token is
                    // queried to obtain the owner and the Group. Also if we are creating computer
                    // object's mark the context as such as because we need to put in the right
                    // default security descriptor and therefore need the correct class in DsClassId
                    //

                    if ((SampUserObjectType==ObjectType) && (ARGUMENT_PRESENT(UserAccountControl))
                            && ((*UserAccountControl)& USER_MACHINE_ACCOUNT_MASK))
                    {
                        NewContext->DsClassId = CLASS_COMPUTER;
                    }

                    NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
                    if (NT_SUCCESS(NtStatus))
                    {
                        NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                        NewContext->DsClassId,
                                        &SecurityDescriptorLength,
                                        TrustedClient,
                                        &SecurityDescriptor
                                        );
                    }

                    if (NT_SUCCESS(NtStatus))
                    {
                        ASSERT(SecurityDescriptorLength>0);
                        ASSERT(SecurityDescriptor!=NULL);
                    }
                }

                //
                // For group objects check the group type and then
                // set the flags in the context accordingly
                //

                if (((SampGroupObjectType==ObjectType) || (SampAliasObjectType==ObjectType))
                    && (NT_SUCCESS(NtStatus)))
                {
                    NT4_GROUP_TYPE NT4GroupType;
                    NT5_GROUP_TYPE NT5GroupType;
                    BOOLEAN        SecurityEnabled;

                    //
                    // Validate the group type bits
                    //

                    NtStatus = SampCheckGroupTypeBits(
                                    DomainIndex,
                                    *GroupType
                                    );
                    //
                    // If that succeeded proceed to get the group type in meaningful form
                    //

                    if (NT_SUCCESS(NtStatus))
                    {

                        NtStatus = SampComputeGroupType(
                                        SampDeriveMostBasicDsClass(NewContext->DsClassId),
                                        *GroupType,
                                        &NT4GroupType,
                                        &NT5GroupType,
                                        &SecurityEnabled
                                        );
                    }


                    if (NT_SUCCESS(NtStatus))
                    {
                        if (SampAliasObjectType==ObjectType)
                        {
                            NewContext->TypeBody.Alias.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Alias.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Alias.SecurityEnabled = SecurityEnabled;
                        }
                        else
                        {
                            NewContext->TypeBody.Group.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Group.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Group.SecurityEnabled = SecurityEnabled;
                        }
                    }
                }

                //
                // Construct the account's DSNAME
                //


                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampDsCreateAccountObjectDsName(
                                DomainContext->ObjectNameInDs,
                                SampDefinedDomains[DomainIndex].Sid, // Domain Sid
                                ObjectType,
                                AccountName,
                                &AccountId,     // Account Rid
                                UserAccountControl,
                                SampDefinedDomains[DomainIndex].IsBuiltinDomain,
                                &NewContext->ObjectNameInDs
                                );
                }
                //
                // Now Proceed on creating the account
                //

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Control the fDSA flag Appropriately. Setting the fDSA flag is tricky and
                    // is actually governed by the following rules
                    //
                    // 1, Trusted Clients get fDSA.
                    //
                    // 2. All others proceed with fDSA set to FALSE
                    //
                    // 2.1.  If (2) failed access check by core DS, but the Machine account is
                    //       getting created by privilege, we will set fDSA to true for a second
                    //       try --- this requires explanation
                    //
                    //    -- NT4 had a notion of a privilege to create machine accounts. Therefore if
                    //       the privilege check passed ( and this would only be that case for machine
                    //       accounts ) then we set fDSA. This is because even though the access check
                    //       may fail the privilege allows us to create the account. ( DS does not know
                    //       about specific checks for privelege for specific classes of accounts ).
                    //

                    ASSERT(SampExistsDsTransaction());

                    if (TrustedClient)
                    {
                        SampSetDsa(TRUE);
                        fDSA = TRUE;
                    }
                    else
                    {
                        SampSetDsa(FALSE);
                        fDSA = FALSE;
                    }

                    //
                    // Create the account object with fDSA turned off for
                    // any caller except TrustedClient.
                    //
                    if (NT_SUCCESS(NtStatus))
                    {
                        ASSERT( ARGUMENT_PRESENT(UserAccountControl) || (SampUserObjectType != ObjectType) ); 

                        NtStatus = SampDsCreateInitialAccountObject(
                                       NewContext,
                                       0,
                                       AccountId,
                                       AccountName,
                                       NULL,        // CreatorSid
                                       fDSA?SecurityDescriptor:NULL,
                                       UserAccountControl,
                                       GroupType
                                       );

                        if ( NT_SUCCESS(NtStatus)  )
                        {
                            //
                            // if the client can just create Machine Account
                            // without using the privilege he holds, then
                            // we need to mark it correctly, so that caller will
                            // know it throught the returned context.
                            //
                            if (CreateByPrivilege)
                            {
                                NewContext->TypeBody.User.PrivilegedMachineAccountCreate = FALSE;
                            }
                        }
                        else if (STATUS_ACCESS_DENIED == NtStatus)
                        {
                            //
                            // if access check failed, but the client has privilege
                            // to create machine account.
                            //
                            if ( CreateByPrivilege )
                            {
                                // Asssert this privilege is only for Machine Account
                                ASSERT(SampUserObjectType == ObjectType);
                                ASSERT(NewContext->DsClassId == CLASS_COMPUTER);

                                //
                                // Clear privous DS Error
                                //
                                SampClearErrors();

                                //
                                // Check whether the client still has quota or not
                                //
                                NtStatus = SampCheckQuotaForPrivilegeMachineAccountCreation();

                                //
                                // If the caller still has quota to create machine account
                                //
                                if (NT_SUCCESS(NtStatus))
                                {
                                    PTOKEN_OWNER Owner=NULL;
                                    PTOKEN_PRIMARY_GROUP PrimaryGroup=NULL;
                                    PSID         CreatorSid = NULL;

                                    //
                                    // Get Client's SID (actual creator) from token
                                    //
                                    NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                                                        &Owner,
                                                        &PrimaryGroup
                                                        );

                                    if (NT_SUCCESS(NtStatus))
                                    {
                                        CreatorSid = Owner->Owner;

                                        //
                                        // Set fDSA to TRUE, because client has
                                        // privilege to do the machine creation
                                        //
                                        SampSetDsa(TRUE);
                                        fDSA = TRUE;

                                        NtStatus = SampDsCreateInitialAccountObject(
                                                        NewContext,
                                                        0,
                                                        AccountId,
                                                        AccountName,
                                                        CreatorSid,
                                                        fDSA?SecurityDescriptor:NULL,
                                                        UserAccountControl,
                                                        GroupType
                                                        );

                                        //
                                        // if create the machine account with privilege successfully
                                        // Then turn around, reset the Owner of the machine object
                                        // to Domain Admins
                                        //
                                        if (NT_SUCCESS(NtStatus))
                                        {
                                            PSID    DomainAdmins = NULL;

                                            //
                                            // Construct Domain_Administrators Group SID
                                            //
                                            NtStatus = SampCreateFullSid(
                                                            SampDefinedDomains[DOMAIN_START_DS + 1].Sid,
                                                            DOMAIN_GROUP_RID_ADMINS,
                                                            &DomainAdmins
                                                            );

                                            //
                                            // reset Owner to Domain Administrators Group
                                            //
                                            if (NT_SUCCESS(NtStatus))
                                            {
                                                NtStatus = SampSetMachineAccountOwner(
                                                                NewContext,
                                                                DomainAdmins
                                                                );

                                                MIDL_user_free(DomainAdmins);
                                            }
                                        }
                                    }
                                    if (NULL != Owner)
                                    {
                                        MIDL_user_free(Owner);
                                    }
                                    if (NULL != PrimaryGroup)
                                    {
                                        MIDL_user_free(PrimaryGroup);
                                    }
                                }
                            }
                        }
                    }
               }
            } // End of DS mode Account Creation Case.
        }
        else
        {
            //
            // The Domain in which the account is supposed to exist/ or to
            // be created is in the registry
            //

            //
            // Create the specified acocunt's root key name
            // and store it in the context.
            // This name remains around until the context is deleted.
            //

            NtStatus = SampBuildAccountSubKeyName(
                           ObjectType,
                           &NewContext->RootName,
                           AccountId,
                           NULL             // Don't give a sub-key name
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // If the account should exist, try and open the root key
                // to the object - fail if it doesn't exist.
                //

                if (AccountExists) {

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &NewContext->RootName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &NewContext->RootKey,
                                   (KEY_READ | KEY_WRITE),
                                   &ObjectAttributes,
                                   0
                                   );

                    if ( !NT_SUCCESS(NtStatus) ) {
                        NewContext->RootKey = INVALID_HANDLE_VALUE;
                        NtStatus = NotFoundStatus;
                    }
                }

            } else {
                RtlInitUnicodeString(&NewContext->RootName, NULL);
            }
        } // End of Registry Mode.

        //
        // Clean up the account context if we failed
        //

        if (!NT_SUCCESS(NtStatus))
        {
            SampDeleteContext( NewContext );
            NewContext = NULL;
        }

    } // End of NewContext != NULL if Statement.
    else
    {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Return the context pointer
    //

    *AccountContext = NewContext;

    //
    // Do any necessary Cleanup
    //

    if (NULL!=SecurityDescriptor)
    {
        MIDL_user_free(SecurityDescriptor);
    }

    return(NtStatus);
}



NTSTATUS
SampIsAccountBuiltIn(
    IN ULONG Rid
    )

/*++

Routine Description:

    This routine checks to see if a specified account name is a well-known
    (built-in) account.  Some restrictions apply to such accounts, such as
    they can not be deleted or renamed.


Parameters:

    Rid - The RID of the account.


Return Values:

    STATUS_SUCCESS - The account is not a well-known (restricted) account.

    STATUS_SPECIAL_ACCOUNT - Indicates the account is a restricted
        account.  This is an error status, based upon the assumption that
        this service will primarily be utilized to determine if an
        operation may allowed on an account.


--*/
{
    SAMTRACE("SampIsAccountBuiltIn");

    if (Rid < SAMP_RESTRICTED_ACCOUNT_COUNT) {

        return(STATUS_SPECIAL_ACCOUNT);

    } else {

        return(STATUS_SUCCESS);
    }
}



NTSTATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

    The returned Sid may be freed with MIDL_user_free.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/
{

    NTSTATUS    NtStatus, IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    SAMTRACE("SampCreateFullSid");

    //
    // Calculate the size of the new sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //

    *AccountSid = MIDL_user_allocate(AccountSidLength);

    if (*AccountSid == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Copy the domain sid into the first part of the account sid
        //

        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        NtStatus = STATUS_SUCCESS;
    }

    return(NtStatus);
}



NTSTATUS
SampCreateAccountSid(
    IN PSAMP_OBJECT AccountContext,
    OUT PSID *AccountSid
    )

/*++

Routine Description:

    This function creates the sid for an account object.

    The returned Sid may be freed with MIDL_user_free.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus;
    PSID        DomainSid;
    ULONG       AccountRid = 0;

    SAMTRACE("SampCreateAccountSid");


    //
    // Get the Sid for the domain this object is in
    //


    DomainSid = SampDefinedDomains[AccountContext->DomainIndex].Sid;

    //
    // Get the account Rid
    //

    switch (AccountContext->ObjectType) {

    case SampGroupObjectType:
        AccountRid = AccountContext->TypeBody.Group.Rid;
        break;
    case SampAliasObjectType:
        AccountRid = AccountContext->TypeBody.Alias.Rid;
        break;
    case SampUserObjectType:
        AccountRid = AccountContext->TypeBody.User.Rid;
        break;
    default:
        ASSERT(FALSE);
    }


    //
    // Build a full sid from the domain sid and the account rid
    //
    ASSERT(AccountRid && "AccountRid not initialized\n");

    NtStatus = SampCreateFullSid(DomainSid, AccountRid, AccountSid);

    return(NtStatus);
}


VOID
SampNotifyNetlogonOfDelta(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )

/*++

Routine Description:

    This routine is called after any change is made to the SAM database
    on a PDC.  It will pass the parameters, along with the database type
    and ModifiedCount to I_NetNotifyDelta() so that Netlogon will know
    that the database has been changed.

    This routine MUST be called with SAM's write lock held; however, any
    changes must have already been committed to disk.  That is, call
    SampCommitAndRetainWriteLock() first, then this routine, then
    SampReleaseWriteLock().

Arguments:

    DeltaType - Type of modification that has been made on the object.

    ObjectType - Type of object that has been modified.

    ObjectRid - The relative ID of the object that has been modified.
        This parameter is valid only when the object type specified is
        either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias otherwise this parameter is set to
        zero.

    ObjectName - The old name of the object when the object type specified
        is either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias and the delta type is SecurityDbRename
        otherwise this parameter is set to zero.

    ReplicateImmediately - TRUE if the change should be immediately
        repl\noticated to all BDCs.  A password change should set the flag
        TRUE.

    DeltaData - pointer to delta-type specific structure to be passed
              - to netlogon.

Return Value:

    None.


--*/
{
    SAMTRACE("SampNotifyNetlogonOfDelta");

    //
    // Only make the call if this is not a backup domain controller.
    // In DS mode the Core DS will make this call. Therefore Nothing
    // to do
    //

    if ((!SampUseDsData) && (!SampDisableNetlogonNotification))
    {
        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);

        if ( SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
             != DomainServerRoleBackup )
        {
        I_NetNotifyDelta(
            SecurityDbSam,
            SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber,
            DeltaType,
            ObjectType,
            ObjectRid,
            SampDefinedDomains[SampTransactionDomainIndex].Sid,
            ObjectName,
            ReplicateImmediately,
            DeltaData
            );

        //
        // Let any notification packages know about the delta.
        //

        SampDeltaChangeNotify(
            SampDefinedDomains[SampTransactionDomainIndex].Sid,
            DeltaType,
            ObjectType,
            ObjectRid,
            ObjectName,
            &SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber,
            DeltaData
            );

        }
    }
}



NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid OPTIONAL,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller. If this
        parameter is NULL, only the account Rid is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    SAMTRACE("SampSplitSid");

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);


    //
    // Get Domain Sid if caller is intersted in it.
    //

    if (DomainSid)
    {

        //
        // If no buffer is required for the Domain Sid, we have to allocate one.
        //

        if (*DomainSid == NULL) {

            //
            // Allocate space for the domain sid (allocate the same size as the
            // account sid so we can use RtlCopySid)
            //

            *DomainSid = MIDL_user_allocate(AccountSidLength);


            if (*DomainSid == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto SplitSidError;
            }
        }

        //
        // Copy the Account sid into the Domain sid
        //

        RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

        //
        // Decrement the domain sid sub-authority count
        //

        (*RtlSubAuthorityCountSid(*DomainSid))--;
    }


    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}



NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it.

Parameters:

    OutString - A pointer to a destination unicode string

    InString - A pointer to an unicode string to be copied

Return Values:

    None.

--*/

{
    SAMTRACE("SampDuplicateUnicodeString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OutString->Buffer = MIDL_user_allocate( InString->Length );

        if (OutString->Buffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        OutString->MaximumLength = InString->Length;

        RtlCopyUnicodeString(OutString, InString);

    } else {

        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SampUnicodeToOemString(
    IN POEM_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it, converting to OEM string in the process.

Parameters:

    OutString - A pointer to a destination OEM string.

    InString - A pointer to a unicode string to be copied

Return Values:

    None.

--*/

{
    ULONG
        OemLength,
        Index;

    NTSTATUS
        NtStatus;

    SAMTRACE("SampUnicodeToOemString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OemLength = RtlUnicodeStringToOemSize(InString);
        if ( OemLength > MAXUSHORT ) {
            return STATUS_INVALID_PARAMETER_2;
        }

        OutString->Length = (USHORT)(OemLength - 1);
        OutString->MaximumLength = (USHORT)OemLength;
        OutString->Buffer = MIDL_user_allocate(OemLength);
        if ( !OutString->Buffer ) {
            return STATUS_NO_MEMORY;
        }

        NtStatus = RtlUnicodeToOemN(
                       OutString->Buffer,
                       OutString->Length,
                       &Index,
                       InString->Buffer,
                       InString->Length
                       );

        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free(OutString->Buffer);
            return NtStatus;
        }

        OutString->Buffer[Index] = '\0';


    } else {

        RtlInitString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampChangeAccountOperatorAccessToMember(
    IN PRPC_SID MemberSid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    )

/*++

Routine Description:

    This routine is called when a member is added to or removed from an
    ADMIN alias.  If the member is from the BUILTIN or ACCOUNT domain,
    it will change the ACL(s) of the member to allow or disallow access
    by account operators if necessary.

    This must be called BEFORE the member is actually added to the
    alias, and AFTER the member is actually removed from the alias to
    avoid security holes in the event that we are unable to complete the
    entire task.

    When this routine is called, the transaction domain is alredy set
    to that of the alias.  Note, however, that the member might be in a
    different domain, so the transaction domain may be adjusted in this
    routine.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

        THIS ROUTINE IS NOT CALLED IN THE DS CASE

Arguments:

    MemberSid - The full ID of the member being added to/ deleted from
        an ADMIN alias.

    ChangingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    ChangingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL(s) was modified, or it didn't need
        to be.

--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed;
    PSID                        MemberDomainSid = NULL;
    PULONG                      UsersInGroup = NULL;
    NTSTATUS                    NtStatus;
    ULONG                       MemberRid;
    ULONG                       OldTransactionDomainIndex = SampDefinedDomainsCount;
    ULONG                       NumberOfUsersInGroup;
    ULONG                       i;
    ULONG                       MemberDomainIndex;
    SAMP_OBJECT_TYPE            MemberType;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    PSECURITY_DESCRIPTOR        OldDescriptor;
    ULONG                       SecurityDescriptorLength;
    ULONG                       Revision;
    ULONG                       DomainStart;

    SAMTRACE("SampChangeAccountOperatorAccessToMember");

    ASSERT( SampTransactionWithinDomain );
        ASSERT( SampUseDsData == FALSE);


    //
    // See if the SID is from one of the local domains (BUILTIN or ACCOUNT).
    // If it's not, we don't have to worry about modifying ACLs.
    //

    NtStatus = SampSplitSid( MemberSid, &MemberDomainSid, &MemberRid );

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    DomainStart = SampDsGetPrimaryDomainStart();


    for ( MemberDomainIndex = DomainStart;
        MemberDomainIndex < SampDefinedDomainsCount;
        MemberDomainIndex++ ) {

        if ( RtlEqualSid(
            MemberDomainSid,
            SampDefinedDomains[MemberDomainIndex].Sid ) ) {

            break;
        }
    }

    if ( MemberDomainIndex < SampDefinedDomainsCount ) {

        //
        // The member is from one of the local domains.  MemberDomainIndex
        // indexes that domain.  First, check to see if the alias and member
        // are in the same domain.
        //

        if ( MemberDomainIndex != SampTransactionDomainIndex ) {

            //
            // The transaction domain is set to that of the alias, but
            // we need to set it to that of the member while we modify
            // the member.
            //

            SampSetTransactionWithinDomain(FALSE);

            OldTransactionDomainIndex = SampTransactionDomainIndex;

            SampSetTransactionDomain( MemberDomainIndex );
        }

        //
        // Now we need to change the member ACL(s), IF the member is being
        // added to an admin alias for the first time.  Find out whether
        // the member is a user or a group, and attack accordingly.
        //

        NtStatus = SampLookupAccountName(
                       SampTransactionDomainIndex,
                       MemberRid,
                       NULL,
                       &MemberType
                       );

        if (NT_SUCCESS(NtStatus)) {

            switch (MemberType) {

                case SampUserObjectType: {

                    NtStatus = SampChangeOperatorAccessToUser(
                                   MemberRid,
                                   ChangingToAdmin,
                                   ChangingToOperator
                                   );

                    break;
                }

                case SampGroupObjectType: {

                    PSAMP_OBJECT GroupContext;

                    //
                    // Change ACL for every user in this group.
                    // First get group member list.
                    //

                    //
                    // Try to create a context for the account.
                    //

                    NtStatus = SampCreateAccountContext(
                                     SampGroupObjectType,
                                     MemberRid,
                                     TRUE, // Trusted client
                                     FALSE,// Loopback client
                                     TRUE, // Account exists
                                     &GroupContext
                                     );
                    if (NT_SUCCESS(NtStatus)) {


                        //
                        // Now set a flag in the group itself,
                        // so that when users are added and removed
                        // in the future it is known whether this
                        // group is in an ADMIN alias or not.
                        //

                        NtStatus = SampRetrieveGroupV1Fixed(
                                       GroupContext,
                                       &GroupV1Fixed
                                       );

                        if ( NT_SUCCESS( NtStatus ) ) {

                            ULONG OldAdminStatus = 0;
                            ULONG NewAdminStatus;

                            // SAM BUG 42367 FIX - ChrisMay 7/1/96

                            SAMP_MEMBERSHIP_DELTA AdminChange = NoChange;
                            SAMP_MEMBERSHIP_DELTA OperatorChange = NoChange;

                            if (GroupV1Fixed.AdminCount != 0 ) {
                                OldAdminStatus++;
                            }
                            if (GroupV1Fixed.OperatorCount != 0) {
                                OldAdminStatus++;
                            }
                            NewAdminStatus = OldAdminStatus;

                            //
                            // Update the admin count.  If we added one and the
                            // count is now 1, then the group became administrative.
                            // If we subtracted one and the count is zero,
                            // then the group lost its administrive membership.
                            //

                            if (ChangingToAdmin == AddToAdmin) {
                                if (++GroupV1Fixed.AdminCount == 1) {
                                    NewAdminStatus++;

                                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                    AdminChange = AddToAdmin;
                                }
                            } else if (ChangingToAdmin == RemoveFromAdmin) {


                                //
                                // For removing an admin count, we need to make
                                // sure there is at least one.  In the upgrade
                                // case there may not be, since prior versions
                                // of NT only had a boolean.
                                //
                                if (GroupV1Fixed.AdminCount > 0) {
                                    if (--GroupV1Fixed.AdminCount == 0) {
                                        NewAdminStatus --;

                                        // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                        AdminChange = RemoveFromAdmin;
                                    }
                                }

                            }

                            //
                            // Update the operator count
                            //

                            if (ChangingToOperator == AddToAdmin) {
                                if (++GroupV1Fixed.OperatorCount == 1) {
                                    NewAdminStatus++;

                                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                    OperatorChange = AddToAdmin;
                                }
                            } else if (ChangingToOperator == RemoveFromAdmin) {


                                //
                                // For removing an Operator count, we need to make
                                // sure there is at least one.  In the upgrade
                                // case there may not be, since prior versions
                                // of NT only had a boolean.
                                //
                                if (GroupV1Fixed.OperatorCount > 0) {
                                    if (--GroupV1Fixed.OperatorCount == 0) {
                                        NewAdminStatus --;

                                        // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                        OperatorChange = RemoveFromAdmin;
                                    }
                                }

                            }


                            NtStatus = SampReplaceGroupV1Fixed(
                                            GroupContext,
                                            &GroupV1Fixed
                                            );
                            //
                            // If the status of the group changed,
                            // modify the security descriptor to
                            // prevent account operators from adding
                            // anybody to this group
                            //

                            if ( NT_SUCCESS( NtStatus ) &&
                                ((NewAdminStatus != 0) != (OldAdminStatus != 0)) ) {

                                //
                                // Get the old security descriptor so we can
                                // modify it.
                                //

                                NtStatus = SampGetAccessAttribute(
                                                GroupContext,
                                                SAMP_GROUP_SECURITY_DESCRIPTOR,
                                                FALSE, // don't make copy
                                                &Revision,
                                                &OldDescriptor
                                                );
                                if (NT_SUCCESS(NtStatus)) {

                                    NtStatus = SampModifyAccountSecurity(
                                                   GroupContext,
                                                   SampGroupObjectType,
                                                   (BOOLEAN) ((NewAdminStatus != 0) ? TRUE : FALSE),
                                                   OldDescriptor,
                                                   &SecurityDescriptor,
                                                   &SecurityDescriptorLength
                                                   );

                                    if ( NT_SUCCESS( NtStatus ) ) {

                                        //
                                        // Write the new security descriptor into the object
                                        //

                                        NtStatus = SampSetAccessAttribute(
                                                       GroupContext,
                                                       SAMP_GROUP_SECURITY_DESCRIPTOR,
                                                       SecurityDescriptor,
                                                       SecurityDescriptorLength
                                                       );

                                        RtlDeleteSecurityObject( &SecurityDescriptor );
                                    }
                                }
                            }

                            //
                            // Update all the members of this group so that
                            // their security descriptors are changed.
                            //

                            // SAM BUG 42367 FIX - ChrisMay 7/1/96

                            #if 0

                            if ( NT_SUCCESS( NtStatus ) ) {

                                NtStatus = SampRetrieveGroupMembers(
                                            GroupContext,
                                            &NumberOfUsersInGroup,
                                            &UsersInGroup
                                            );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    for ( i = 0; i < NumberOfUsersInGroup; i++ ) {

                                        NtStatus = SampChangeOperatorAccessToUser(
                                                       UsersInGroup[i],
                                                       ChangingToAdmin,
                                                       ChangingToOperator
                                                       );

                                        if ( !( NT_SUCCESS( NtStatus ) ) ) {

                                            break;
                                        }
                                    }

                                    MIDL_user_free( UsersInGroup );

                                }

                            }

                            #endif

                            if (NT_SUCCESS(NtStatus) &&
                                ((AdminChange != NoChange) ||
                                 (OperatorChange != NoChange))) {

                                NtStatus = SampRetrieveGroupMembers(
                                                GroupContext,
                                                &NumberOfUsersInGroup,
                                                &UsersInGroup
                                                );

                                if (NT_SUCCESS(NtStatus)) {

                                    for (i = 0; i < NumberOfUsersInGroup; i++) {

                                            NtStatus = SampChangeOperatorAccessToUser(
                                                           UsersInGroup[i],
                                                           AdminChange,
                                                           OperatorChange
                                                           );

                                            if (!(NT_SUCCESS(NtStatus))){

                                                break;
                                        }
                                    }

                                    MIDL_user_free(UsersInGroup);

                                }

                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Add the modified group to the current transaction
                                // Don't use the open key handle since we'll be deleting the context.
                                //

                                NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
                            }

                        }



                        //
                        // Clean up the group context
                        //

                        SampDeleteContext(GroupContext);
                    }

                    break;
                }

                default: {

                    //
                    // A bad RID from a domain other than the domain
                    // current at the time of the call could slip through
                    // to this point.  Return error.
                    //

                    //
                    // If the account is in a different domain than the alias,
                    //  don't report an error if we're removing the member and
                    //  the member no longer exists.
                    //
                    //  Possibly caused by deleting the object before deleting
                    //  the membership in the alias.
                    //

                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                    #if 0

                    if ( (ChangingToAdmin == AddToAdmin) ||
                         (ChangingToOperator == AddToAdmin) ||
                         OldTransactionDomainIndex == SampDefinedDomainsCount ){
                        NtStatus = STATUS_INVALID_MEMBER;
                    } else {
                        NtStatus = STATUS_SUCCESS;
                    }

                    #endif

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }

        if ( OldTransactionDomainIndex != SampDefinedDomainsCount ) {

            //
            // The transaction domain should be set to that of the alias, but
            // we switched it above to that of the member while we modified
            // the member.  Now we need to switch it back.
            //

            SampSetTransactionWithinDomain(FALSE);

            SampSetTransactionDomain( OldTransactionDomainIndex );
        }
    }

    MIDL_user_free( MemberDomainSid );

    return( NtStatus );
}


NTSTATUS
SampChangeOperatorAccessToUser(
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    )

/*++

Routine Description:

    This routine adjusts the user's AdminCount field as appropriate, and
    if the user is being removed from it's last ADMIN alias or added to
    its first ADMIN alias, the ACL is adjusted to allow/disallow access
    by account operators as appropriate.

    This routine will also increment or decrement the domain's admin count,
    if this operation changes that.

    NOTE:
    This routine is similar to SampChangeOperatorAccessToUser2().
    This routine should be used in cases where a user context does NOT
    already exist (and won't later on).  You must be careful not to
    create two contexts, since they will be independently applied back
    to the registry, and the last one there will win.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

Arguments:

    UserRid - The transaction-domain-relative ID of the user that is
        being added to or removed from an ADMIN alias.

    ChangingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    ChangingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL was modified, or it didn't need
        to be.

--*/
{
    SAMP_V1_0A_FIXED_LENGTH_USER   UserV1aFixed;
    NTSTATUS                    NtStatus;
    PSAMP_OBJECT                UserContext;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    ULONG                       SecurityDescriptorLength;

    SAMTRACE("SampChangeOperatorAccessToUser");

    //
    // None of this ACL modification business in DS Mode
    //

    ASSERT(FALSE==SampUseDsData);

    //
    // Get the user's fixed data, and adjust the AdminCount.
    //

    NtStatus = SampCreateAccountContext(
                   SampUserObjectType,
                   UserRid,
                   TRUE, // Trusted client
                   FALSE,// Trusted client
                   TRUE, // Account exists
                   &UserContext
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &UserV1aFixed
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampChangeOperatorAccessToUser2(
                            UserContext,
                            &UserV1aFixed,
                            ChangingToAdmin,
                            ChangingToOperator
                            );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // If we've succeeded (at changing the admin count, and
                // the ACL if necessary) then write out the new admin
                // count.
                //

                NtStatus = SampReplaceUserV1aFixed(
                                   UserContext,
                                   &UserV1aFixed
                                   );
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the modified user context to the current transaction
            // Don't use the open key handle since we'll be deleting the context.
            //

            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }


        //
        // Clean up account context
        //

        SampDeleteContext(UserContext);
    }

    if ( ( !NT_SUCCESS( NtStatus ) ) &&
        (( ChangingToAdmin == RemoveFromAdmin )  ||
         ( ChangingToOperator == RemoveFromAdmin )) &&
        ( NtStatus != STATUS_SPECIAL_ACCOUNT ) ) {

        //
        // When an account is *removed* from admin groups, we can
        // ignore errors from this routine.  This routine is just
        // making the account accessible to account operators, but
        // it's no big deal if that doesn't work.  The administrator
        // can still get at it, so we should proceed with the calling
        // operation.
        //
        // Obviously, we can't ignore errors if we're being added
        // to an admin group, because that could be a security hole.
        //
        // Also, we want to make sure that the Administrator is
        // never removed, so we DO propogate STATUS_SPECIAL_ACCOUNT.
        //

        NtStatus = STATUS_SUCCESS;
    }

    return( NtStatus );
}


NTSTATUS
SampChangeOperatorAccessToUser2(
    IN PSAMP_OBJECT                    UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed,
    IN SAMP_MEMBERSHIP_DELTA           AddingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA           AddingToOperator
    )

/*++

Routine Description:

    This routine adjusts the user's AdminCount field as appropriate, and
    if the user is being removed from it's last ADMIN alias or added to
    its first ADMIN alias, the ACL is adjusted to allow/disallow access
    by account operators as appropriate.

    This routine will also increment or decrement the domain's admin count,
    if this operation changes that.

    NOTE:
    This routine is similar to SampAccountOperatorAccessToUser().
    This routine should be used in cases where a user account context
    already exists.  You must be careful not to create two contexts,
    since they will be independently applied back to the registry, and
    the last one there will win.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

Arguments:

    UserContext - Context of user whose access is to be updated.

    V1aFixed - Pointer to the V1aFixed length data for the user.
        The caller of this routine must ensure that this value is
        stored back out to disk on successful completion of this
        routine.

    AddingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    AddingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL(s) was modified, or it didn't need
        to be.

--*/
{
    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR        OldDescriptor;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    ULONG                       SecurityDescriptorLength;
    ULONG                       OldAdminStatus = 0, NewAdminStatus = 0;
    ULONG                       Revision;

    SAMTRACE("SampChangeOperatorAccessToUser2");

    //
    // Compute whether we are an admin now. From that we will figure
    // out how many times we were may not an admin to tell if we need
    // to update the security descriptor.
    //

    if (V1aFixed->AdminCount != 0) {
        OldAdminStatus++;
    }
    if (V1aFixed->OperatorCount != 0) {
        OldAdminStatus++;
    }

    NewAdminStatus = OldAdminStatus;



    if ( AddingToAdmin == AddToAdmin ) {

        V1aFixed->AdminCount++;
        NewAdminStatus++;
        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Incrementing admin count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->AdminCount ) );
    } else if (AddingToAdmin == RemoveFromAdmin) {

        V1aFixed->AdminCount--;

        if (V1aFixed->AdminCount == 0) {
            NewAdminStatus--;
        }

        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Decrementing admin count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->AdminCount ) );

        if ( V1aFixed->AdminCount == 0 ) {

            //
            // Don't allow the Administrator account to lose
            // administrative power.
            //

            if ( V1aFixed->UserId == DOMAIN_USER_RID_ADMIN ) {

                NtStatus = STATUS_SPECIAL_ACCOUNT;
            }
        }
    }
    if ( AddingToOperator == AddToAdmin ) {

        V1aFixed->OperatorCount++;
        NewAdminStatus++;
        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Incrementing operator count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->OperatorCount ) );

    } else if (AddingToOperator == RemoveFromAdmin) {

        //
        // Only decrement if the count is > 0, since in the upgrade case
        // this field we start out zero.
        //

        if (V1aFixed->OperatorCount > 0) {
            V1aFixed->OperatorCount--;

            if (V1aFixed->OperatorCount == 0) {
                NewAdminStatus--;
            }
        }

        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Decrementing operator count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->OperatorCount ) );
    }


    if (NT_SUCCESS(NtStatus)) {

        if ( ( NewAdminStatus != 0 ) != ( OldAdminStatus != 0 ) ) {

            //
            // User's admin status is changing.  We must change the
            // ACL.
            //

#ifdef SAMP_DIAGNOSTICS
            if (AddingToAdmin) {
                SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                           ("SAM DIAG: Protecting user %d as ADMIN account\n",
                            V1aFixed->UserId ) );
            } else {
                SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                           ("SAM DIAG: Protecting user %d as non-admin account\n",
                            V1aFixed->UserId ) );
            }
#endif // SAMP_DIAGNOSTICS

            //
            // Get the old security descriptor so we can
            // modify it.
            //

            NtStatus = SampGetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            FALSE, // don't make copy
                            &Revision,
                            &OldDescriptor
                            );
            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampModifyAccountSecurity(
                                UserContext,
                                SampUserObjectType,
                                (BOOLEAN) ((NewAdminStatus != 0) ? TRUE : FALSE),
                                OldDescriptor,
                                &SecurityDescriptor,
                                &SecurityDescriptorLength
                                );
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Write the new security descriptor into the object
                //

                NtStatus = SampSetAccessAttribute(
                               UserContext,
                               SAMP_USER_SECURITY_DESCRIPTOR,
                               SecurityDescriptor,
                               SecurityDescriptorLength
                               );

                RtlDeleteSecurityObject( &SecurityDescriptor );
            }
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Save the fixed-length attributes
        //

        NtStatus = SampReplaceUserV1aFixed(
                        UserContext,
                        V1aFixed
                        );
    }


    if ( ( !NT_SUCCESS( NtStatus ) ) &&
        ( AddingToAdmin != AddToAdmin ) &&
        ( NtStatus != STATUS_SPECIAL_ACCOUNT ) ) {

        //
        // When an account is *removed* from admin groups, we can
        // ignore errors from this routine.  This routine is just
        // making the account accessible to account operators, but
        // it's no big deal if that doesn't work.  The administrator
        // can still get at it, so we should proceed with the calling
        // operation.
        //
        // Obviously, we can't ignore errors if we're being added
        // to an admin group, because that could be a security hole.
        //
        // Also, we want to make sure that the Administrator is
        // never removed, so we DO propogate STATUS_SPECIAL_ACCOUNT.
        //

        NtStatus = STATUS_SUCCESS;
    }

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this process                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamINotifyDelta (
    IN SAMPR_HANDLE DomainHandle,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )

/*++

Routine Description:

    Performs a change to some 'virtual' data in a domain. This is used by
    netlogon to get the domain modification count updated for cases where
    fields stored in the database replicated to a down-level machine have
    changed. These fields don't exist in the NT SAM database but netlogon
    needs to keep the SAM database and the down-level database modification
    counts in sync.

Arguments:

    DomainHandle - The handle of an opened domain to operate on.

    All other parameters match those in I_NetNotifyDelta.


Return Value:


    STATUS_SUCCESS - Domain modification count updated successfully.


--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;

    SAMTRACE("SamINotifyDelta");


    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_ALL_ACCESS,       // Trusted client should succeed
                   SampDomainObjectType,    // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Dump the context - don't save the non-existent changes
        //

        NtStatus = SampDeReferenceContext( DomainContext, FALSE );
    }





    //
    // Commit changes, if successful, and notify Netlogon of changes.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // This will increment domain count and write it out
        //

        NtStatus = SampCommitAndRetainWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                DeltaType,
                ObjectType,
                ObjectRid,
                ObjectName,
                ReplicateImmediately,
                DeltaData
                );
        }
    }

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(NtStatus);
}


NTSTATUS
SamISetAuditingInformation(
    IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    )

/*++

Routine Description:

    This function sets Policy Audit Event Info relevant to SAM Auditing

Arguments:

    PolicyAuditEventsInfo - Pointer to structure containing the
        current Audit Events Information.  SAM extracts values of
        relevance.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESSFUL - The call completed successfully.

        STATUS_UNSUCCESSFUL - The call was not successful because the
            SAM lock was not acquired.
--*/

{
    NTSTATUS NtStatus;

    SAMTRACE("SamISetAuditingInformation");

    //
    // Acquire the SAM Database Write Lock.
    //

    NtStatus = SampAcquireWriteLock();

    if (NT_SUCCESS(NtStatus)) {

        //
        // Set boolean if Auditing is on for Account Management
        //

        SampSetAuditingInformation( PolicyAuditEventsInfo );

        //
        // Release the SAM Database Write Lock.  No need to commit
        // the database transaction as there are no entries in the
        // transaction log.
        //

        NtStatus = SampReleaseWriteLock( FALSE );
    }

    return(NtStatus);
}


NTSTATUS
SampRtlConvertUlongToUnicodeString(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN ULONG DigitCount,
    IN BOOLEAN AllocateDestinationString,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function converts an unsigned long integer a Unicode String.
    The string contains leading zeros and is Unicode-NULL terminated.
    Memory for the output buffer can optionally be allocated by the routine.

    NOTE:  This routine may be eligible for inclusion in the Rtl library
           (possibly after modification).  It is modeled on
           RtlIntegerToUnicodeString

Arguments:

    Value - The unsigned long value to be converted.

    Base - Specifies the radix that the converted string is to be
        converted to.

    DigitCount - Specifies the number of digits, including leading zeros
        required for the result.

    AllocateDestinationString - Specifies whether memory of the string
        buffer is to be allocated by this routine.  If TRUE is specified,
        memory will be allocated via MIDL_user_allocate().  When this memory
        is no longer required, it must be freed via MIDL_user_free.  If
        FALSE is specified, the string will be appended to the output
        at the point marked by the Length field onwards.

    UnicodeString - Pointer to UNICODE_STRING structure which will receive
        the output string.  The Length field will be set equal to the
        number of bytes occupied by the string (excluding NULL terminator).
        If memory for the destination string is being allocated by
        the routine, the MaximumLength field will be set equal to the
        length of the string in bytes including the null terminator.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NO_MEMORY - Insufficient memory for the output string buffer.

        STATUS_BUFFER_OVERFLOW - Buffer supplied is too small to contain the
            output null-terminated string.

        STATUS_INVALID_PARAMETER_MIX - One or more parameters are
            invalid in combination.

            - The specified Relative Id is too large to fit when converted
              into an integer with DigitCount digits.

        STATUS_INVALID_PARAMETER - One or more parameters are invalid.

            - DigitCount specifies too large a number of digits.
--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING TempStringU, NumericStringU, OutputUnicodeStringU;
    USHORT OutputLengthAvailable, OutputLengthRequired, LeadingZerosLength;

    SAMTRACE("SamRtlConvertUlongToUnicodeString");

    OutputUnicodeStringU = *UnicodeString;
    RtlZeroMemory(&TempStringU,sizeof(UNICODE_STRING));
    RtlZeroMemory(&NumericStringU,sizeof(UNICODE_STRING));

    //
    // Verify that the maximum number of digits rquested has not been
    // exceeded.
    //

    if (DigitCount > SAMP_MAXIMUM_ACCOUNT_RID_DIGITS) {

        NtStatus = STATUS_INVALID_PARAMETER;
        goto ConvertUlongToUnicodeStringError;
    }

    OutputLengthRequired = (USHORT)((DigitCount + 1) * sizeof(WCHAR));

    //
    // Allocate the Destination String Buffer if requested
    //

    if (AllocateDestinationString) {

        NtStatus = STATUS_NO_MEMORY;
        OutputUnicodeStringU.MaximumLength = OutputLengthRequired;
        OutputUnicodeStringU.Length = (USHORT) 0;

        OutputUnicodeStringU.Buffer = MIDL_user_allocate(
                                          OutputUnicodeStringU.MaximumLength
                                          );

        if (OutputUnicodeStringU.Buffer == NULL) {

            goto ConvertUlongToUnicodeStringError;
        }
    }

    //
    // Compute the length available in the output string and compare it with
    // the length required.
    //

    OutputLengthAvailable = OutputUnicodeStringU.MaximumLength -
                            OutputUnicodeStringU.Length;


    NtStatus = STATUS_BUFFER_OVERFLOW;

    if (OutputLengthRequired > OutputLengthAvailable) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Create a Unicode String with capacity equal to the required
    // converted Rid Length
    //

    TempStringU.MaximumLength = OutputLengthRequired;

    TempStringU.Buffer = MIDL_user_allocate( TempStringU.MaximumLength );

    NtStatus = STATUS_NO_MEMORY;

    if (TempStringU.Buffer == NULL) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Convert the unsigned long value to a hexadecimal Unicode String.
    //

    NtStatus = RtlIntegerToUnicodeString( Value, Base, &TempStringU );

    if (!NT_SUCCESS(NtStatus)) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Prepend the requisite number of Unicode Zeros.
    //

    LeadingZerosLength = OutputLengthRequired - sizeof(WCHAR) - TempStringU.Length;

    if (LeadingZerosLength > 0) {

        RtlInitUnicodeString( &NumericStringU, L"00000000000000000000000000000000" );

        RtlCopyMemory(
            ((PUCHAR)OutputUnicodeStringU.Buffer) + OutputUnicodeStringU.Length,
            NumericStringU.Buffer,
            LeadingZerosLength
            );

        OutputUnicodeStringU.Length += LeadingZerosLength;
    }

    //
    // Append the converted string
    //

    RtlAppendUnicodeStringToString( &OutputUnicodeStringU, &TempStringU);

    *UnicodeString = OutputUnicodeStringU;
    NtStatus = STATUS_SUCCESS;

ConvertUlongToUnicodeStringFinish:

    if (TempStringU.Buffer != NULL) {

        MIDL_user_free( TempStringU.Buffer);
    }

    return(NtStatus);

ConvertUlongToUnicodeStringError:

    if (AllocateDestinationString) {

        if (OutputUnicodeStringU.Buffer != NULL) {

            MIDL_user_free( OutputUnicodeStringU.Buffer);
        }
    }

    goto ConvertUlongToUnicodeStringFinish;
}


NTSTATUS
SampRtlWellKnownPrivilegeCheck(
    BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function checks if the given well known privilege is enabled for an
    impersonated client or for the current process.

Arguments:

    ImpersonateClient - If TRUE, impersonate the client.  If FALSE, don't
        impersonate the client (we may already be doing so).

    PrivilegeId -  Specifies the well known Privilege Id

    ClientId - Specifies the client process/thread Id.  If already
        impersonating the client, or impersonation is requested, this
        parameter should be omitted.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    BOOLEAN PrivilegeHeld = FALSE;
    HANDLE ClientThread = NULL, ClientProcess = NULL, ClientToken = NULL;
    OBJECT_ATTRIBUTES NullAttributes;
    PRIVILEGE_SET Privilege;
    BOOLEAN ClientImpersonatedHere = FALSE;
    BOOLEAN ImpersonatingNullSession = FALSE;

    SAMTRACE("SampRtlWellKnownPrivilegeCheck");

    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );

    //
    // If requested, impersonate the client.
    //

    if (ImpersonateClient) {

        Status = SampImpersonateClient(&ImpersonatingNullSession);

        if ( !NT_SUCCESS(Status) ) {

            goto WellKnownPrivilegeCheckError;
        }

        ClientImpersonatedHere = TRUE;
    }

    //
    // If a client process other than ourself has been specified , open it
    // for query information access.
    //

    if (ARGUMENT_PRESENT(ClientId)) {

        if (ClientId->UniqueProcess != NtCurrentProcess()) {

            Status = NtOpenProcess(
                         &ClientProcess,
                         PROCESS_QUERY_INFORMATION,        // To open primary token
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientProcess = NtCurrentProcess();
        }
    }

    //
    // If a client thread other than ourself has been specified , open it
    // for query information access.
    //

    if (ARGUMENT_PRESENT(ClientId)) {

        if (ClientId->UniqueThread != NtCurrentThread()) {

            Status = NtOpenThread(
                         &ClientThread,
                         THREAD_QUERY_INFORMATION,
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientThread = NtCurrentThread();
        }

    } else {

        ClientThread = NtCurrentThread();
    }

    //
    // Open the specified or current thread's impersonation token (if any).
    //

    Status = NtOpenThreadToken(
                 ClientThread,
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );


    //
    // Make sure that we did not get any error in opening the impersonation
    // token other than that the token doesn't exist.
    //

    if ( !NT_SUCCESS(Status) ) {

        if ( Status != STATUS_NO_TOKEN ) {

            goto WellKnownPrivilegeCheckError;
        }

        //
        // The thread isn't impersonating...open the process's token.
        // A process Id must have been specified in the ClientId information
        // in this case.
        //

        if (ClientProcess == NULL) {

            Status = STATUS_INVALID_PARAMETER;
            goto WellKnownPrivilegeCheckError;
        }

        Status = NtOpenProcessToken(
                     ClientProcess,
                     TOKEN_QUERY,
                     &ClientToken
                     );

        //
        // Make sure we succeeded in opening the token
        //

        if ( !NT_SUCCESS(Status) ) {

            goto WellKnownPrivilegeCheckError;
        }
    }

    //
    // OK, we have a token open.  Now check for the privilege to execute this
    // service.
    //

    Privilege.PrivilegeCount = 1;
    Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
    Privilege.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck(
                 ClientToken,
                 &Privilege,
                 &PrivilegeHeld
                 );

    if (!NT_SUCCESS(Status)) {

        goto WellKnownPrivilegeCheckError;
    }

    //
    // Generate any necessary audits
    //

    SecondaryStatus = NtPrivilegedServiceAuditAlarm (
                        &SampSamSubsystem,
                        &SampSamSubsystem,
                        ClientToken,
                        &Privilege,
                        PrivilegeHeld
                        );
    // ASSERT( NT_SUCCESS(SecondaryStatus) );


    if ( !PrivilegeHeld ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto WellKnownPrivilegeCheckError;
    }

WellKnownPrivilegeCheckFinish:

    //
    // If we impersonated the client, revert to ourself.
    //

    if (ClientImpersonatedHere) {

        SampRevertToSelf(ImpersonatingNullSession);

    }

    //
    // If necessary, close the client Process.
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueProcess != NtCurrentProcess()) &&
        (ClientProcess != NULL)) {

        SecondaryStatus = NtClose( ClientProcess );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientProcess = NULL;
    }

    //
    // If necessary, close the client token.
    //

    if (ClientToken != NULL) {

        SecondaryStatus = NtClose( ClientToken );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientToken = NULL;
    }

    //
    // If necessary, close the client thread
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueThread != NtCurrentThread()) &&
        (ClientThread != NULL)) {

        SecondaryStatus = NtClose( ClientThread );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientThread = NULL;
    }

    return(Status);

WellKnownPrivilegeCheckError:

    goto WellKnownPrivilegeCheckFinish;
}



BOOLEAN
SampEventIsInSetup(
    IN  ULONG   EventID
    )

/*++

Routine Description:

    Routine that determines an Enent belongs to setup process or not

Arguments:

    EventID - event log ID.

Reture Value:

    TRUE: if this EventID belongs to setup process.

    FALSE: Event doesn't belong to setup.

--*/

{
    ULONG   i;

    for (i = 0; i < ARRAY_COUNT(EventsNotInSetupTable); i ++)
    {
        if ( EventsNotInSetupTable[i] == EventID )
        {
            return (FALSE);
        }
    }

    return(TRUE);
}


VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    Routine that adds an entry to the event log

Arguments:

    EventType - Type of event.

    EventCategory - EventCategory

    EventID - event log ID.

    UserSid - SID of user involved.

    NumStrings - Number of strings in Strings array

    DataSize - Number of bytes in Data buffer

    Strings - Array of unicode strings

    Data - Pointer to data buffer

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    UNICODE_STRING Source;
    HANDLE LogHandle;
    ULONG i;
    static struct {
        ULONG         EventId;
        LARGE_INTEGER LastLog;
        ULONG         Period;  //in seconds
    } EventLogTimingTable[] = 
    {
        {SAMMSG_PDC_TASK_FAILURE, {0,0}, (60*60*24*7)},  // once a week
    };

    SAMTRACE("SampWriteEventLog");

    for (i = 0; i < RTL_NUMBER_OF(EventLogTimingTable); i++) {
        if (EventID == EventLogTimingTable[i].EventId) {

            LARGE_INTEGER CurrentTime;
            LARGE_INTEGER Period;

            Period.QuadPart = Int32x32To64(EventLogTimingTable[i].Period, SAMP_ONE_SECOND_IN_FILETIME);
            GetSystemTimeAsFileTime((FILETIME*)&CurrentTime);
            if ( (EventLogTimingTable[i].LastLog.QuadPart != 0)  &&
                 (EventLogTimingTable[i].LastLog.QuadPart + Period.QuadPart)
                    > CurrentTime.QuadPart) {

                // No need to log again
                return;
            } else {

                // update the last log time
                EventLogTimingTable[i].LastLog = CurrentTime;
            }
        }
    }


    RtlInitUnicodeString(&Source, L"SAM");

    if (SampIsSetupInProgress(NULL) && SampEventIsInSetup(EventID) )
    {
        SampWriteToSetupLog(
            EventType,
            EventCategory,
            EventID,
            UserSid,
            NumStrings,
            DataSize,
            Strings,
            Data
            );
    }
    else
    {
        //
        // Open the log
        //

        NtStatus = ElfRegisterEventSourceW (
                            NULL,   // Server
                            &Source,
                            &LogHandle
                            );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                      "SAM: Failed to registry event source with event log, status = 0x%lx\n",
                      NtStatus));

            return;
        }



        //
        // Write out the event
        //

        NtStatus = ElfReportEventW (
                            LogHandle,
                            EventType,
                            EventCategory,
                            EventID,
                            UserSid,
                            NumStrings,
                            DataSize,
                            Strings,
                            Data,
                            0,       // Flags
                            NULL,    // Record Number
                            NULL     // Time written
                            );

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to report event to event log, status = 0x%lx\n",
                       NtStatus));
        }



        //
        // Close the event log
        //

        NtStatus = ElfDeregisterEventSource (LogHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to de-register event source with event log, status = 0x%lx\n",
                       NtStatus));
        }
    }
}




BOOL
SampShutdownNotification(
    DWORD   dwCtrlType
    )

/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

    It causes the SAM registry to be flushed if necessary.

Arguments:



Return Value:

    FALSE - to allow any other shutdown routines in this process to
        also be called.



--*/
{
    NTSTATUS
        NtStatus;

    DWORD StartTime = 0;
    DWORD StopTime = 1;

    SAMP_SERVICE_STATE  PreviousServiceState;

    SAMTRACE("SampShutdownNotification");

    // BUG: Still flushing the registry on an NT5 DC.

    // When the DC's SAM is hosted exclusively on the DS, there will not
    // be a need to flush the registy, so fix this routine.

    if (dwCtrlType == CTRL_SHUTDOWN_EVENT) {

        // Set the service state to "terminating" so that LSA doesn't attempt to
        // access SAM at this point. and wait for active threads to terminate.
        // the shudown global is updated inside of this routine

        SampWaitForAllActiveThreads( &PreviousServiceState );

        //
        // Don't wait for the flush thread to wake up.
        // Flush the registry now if necessary ...
        //

        NtStatus = SampAcquireWriteLock();
        ASSERT( NT_SUCCESS(NtStatus) ); //Nothing we can do if this fails

        if ( NT_SUCCESS( NtStatus ) ) {

            if ( PreviousServiceState != SampServiceDemoted )
            {

                //
                // This flush use to be done only if FlushThreadCreated
                // was true.  However, we seem to have a race condition
                // at setup that causes an initial replication to be
                // lost (resulting in an additional replication).
                // Until we resolve this problem, always flush on
                // shutdown.
                //

                NtStatus = NtFlushKey( SampKey );

                if (!NT_SUCCESS( NtStatus )) {
                    DbgPrint("NtFlushKey failed, Status = %X\n",NtStatus);
                    ASSERT( NT_SUCCESS(NtStatus) );
                }

                //
                // Flush the Netlogon Change numbers to Disk, for the account
                // domain.
                //

                if ((TRUE==SampUseDsData)&&(FALSE==SampDatabaseHasAlreadyShutdown))
                {
                    SampFlushNetlogonChangeNumbers();
                }
            }

            SampReleaseWriteLock( FALSE );
        }


        if ((TRUE == SampUseDsData)
                && (FALSE==SampDatabaseHasAlreadyShutdown))
        {
                    // Clean up the RID Manager, release resources, etc.


            if (TRUE==SampRidManagerInitialized)
            {
                NtStatus = SampDomainRidUninitialization();
                if (!NT_SUCCESS(NtStatus))
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampDomainRidUninitialize status = 0x%lx\n",
                               NtStatus));
                }
            }


            // Terminate and close the DS database if this is a DC. If this
            // call fails, or is skipped, Jet will incorrectly terminate and
            // corrupt the database tables. Rebooting the system will cause
            // Jet to repair the database, which may take a long time.

            StartTime = GetTickCount();
            NtStatus = SampDsUninitialize();
            StopTime = GetTickCount();

            SampDiagPrint(INFORM,
                          ("SAMSS: DsUninitialize took %lu second(s) to complete\n",
                           ((StopTime - StartTime) / 1000)));

            if (NT_SUCCESS(NtStatus))
            {
                SampDatabaseHasAlreadyShutdown = TRUE;
            }

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampDsUninitialize status = 0x%lx\n",
                       NtStatus));
        }

    }

    return(FALSE);
}


NTSTATUS
SampGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.



Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSAPR_HANDLE
        PolicyHandle;

    SAMTRACE("SampGetAccountDomainInfo");


    NtStatus = LsaIOpenPolicyTrusted( &PolicyHandle );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the account domain information
        //

        NtStatus = LsarQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       (PLSAPR_POLICY_INFORMATION *)PolicyAccountDomainInfo
                       );

        if (NT_SUCCESS(NtStatus)) {

            if ( (*PolicyAccountDomainInfo)->DomainSid == NULL ) {

                NtStatus = STATUS_INVALID_SID;
            }
        }

        IgnoreStatus = LsarClose( &PolicyHandle );


        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

#if DBG
    if ( NT_SUCCESS(NtStatus) ) {
        ASSERT( (*PolicyAccountDomainInfo) != NULL );
        ASSERT( (*PolicyAccountDomainInfo)->DomainName.Buffer != NULL );
    }
#endif //DBG

    return(NtStatus);
}


NTSTATUS
SampFindUserSPNAttribute(
    ATTRBLOCK *AttrsRead,
    IN ULONG DesiredAttribute,
    PUSER_SPN_LIST *SPNList
    )
{
    ULONG i,j;

    *SPNList = NULL;

    for (i=0;i<AttrsRead->attrCount;i++)
    {
        if (AttrsRead->pAttr[i].attrTyp == DesiredAttribute)
        {
           
            //
            // Compute the size
            //

            ULONG NumSPNs = AttrsRead->pAttr[i].AttrVal.valCount;
            ULONG Size= sizeof(USER_ALLOWED_TO_DELEGATE_TO_LIST) +
                          (NumSPNs-1)*sizeof(UNICODE_STRING);
            ULONG_PTR SPNOffset = (ULONG_PTR) Size;

            for (j=0;j<NumSPNs;j++)
            {
                Size+=AttrsRead->pAttr[i].AttrVal.pAVal[j].valLen;
            }

            //
            // Allocate memory
            //

            *SPNList = MIDL_user_allocate(Size);
            if (NULL==*SPNList)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            (*SPNList)->Size = Size;
            (*SPNList)->NumSPNs = NumSPNs;

            //
            // Fill in the pointers
            //

            for (j=0;j<NumSPNs;j++)
            {
                (*SPNList)->SPNList[j].Length =
                    (*SPNList)->SPNList[j].MaximumLength =
                       (USHORT) AttrsRead->pAttr[i].AttrVal.pAVal[j].valLen;
                (ULONG_PTR) (*SPNList)->SPNList[j].Buffer = SPNOffset +
                                     (ULONG_PTR) (*SPNList);
                RtlCopyMemory(
                    (*SPNList)->SPNList[j].Buffer,
                    AttrsRead->pAttr[i].AttrVal.pAVal[j].pVal,
                    (*SPNList)->SPNList[j].Length
                    );

                SPNOffset+=  (ULONG_PTR) (*SPNList)->SPNList[j].Length;
            }

            break;
        }
    }


    return(STATUS_SUCCESS);
}


                       

//
// Additional Attributes to be fetched and kept in SAM context
// blocks. These are attributes defined in addition to what NT4
// SAM kept in the OnDisk structure of SAM context's.
//

typedef struct {
    ATTRTYP Attrtyp;
    ULONG   ExtendedField;
} SAMP_ADDITIONAL_ATTR_INFO;


//
// Declare SAM reserved extended fields
//

#define SAMP_GROUP_CACHING_ENABLED 0x01000000

SAMP_ADDITIONAL_ATTR_INFO UserAdditionalAttrs[] =
{
    { SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS, 0 },
    { SAMP_FIXED_USER_LOCKOUT_TIME,             0 },
    { SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,     0 },
    { SAMP_FIXED_USER_UPN,                      0 },
    { SAMP_FIXED_USER_SITE_AFFINITY,            SAMP_GROUP_CACHING_ENABLED },
    { SAMP_USER_A2D2LIST,                       USER_EXTENDED_FIELD_A2D2 },
    { SAMP_USER_SPN,                            USER_EXTENDED_FIELD_SPN  },
    { SAMP_USER_KVNO,                           USER_EXTENDED_FIELD_KVNO }     
};

SAMP_ADDITIONAL_ATTR_INFO GroupAdditionalAttrs[] =
{
    { SAMP_FIXED_GROUP_TYPE,0}
};

SAMP_ADDITIONAL_ATTR_INFO AliasAdditionalAttrs[] =
{
    { SAMP_FIXED_ALIAS_TYPE, 0}
};


NTSTATUS
SampDsFillContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT     NewContext,
    IN ATTRBLOCK        AttrsRead,
    IN ATTRBLOCK        AttrsAsked,
    IN ULONG            TotalAttrsAsked,
    IN ULONG            FixedAttrsAsked,
    IN ULONG            VariableAttrsAsked,
    IN ULONG            ExtendedFields
    )
/*++

      Routine Description:

      Given a Context,  and object type specifying the object in the
      DS, and an attrblock that describes all the SAM relevant properties, this routine
      fills the context with all the information. Since the DS simply "drops the attr"
      if a value is not present without any error indication, the caller needs to
      have logic to keep track of what types of attrs were missed out etc. Therefore
      the total count of attributes, plus fixed and var length attributes asked are
      passed in. This is used to track the dividing line between the variable and fixed
      length attrs. The attr block that was asked is supposed to be in the following
      general format

                            ____________
                            |           |  Object Class
                            _____________
                            |           |
                            |           |
                            |           |   Fixed Attributes
                            |           |
                            -------------
                            |           |
                            |           |   Variable Attributes
                            |           |
                            _____________
                            |           |
                            |           |   Misc additional attributes
                            _____________

      Parameters:

            ObjectType --- Object Type
            NewContext --- The new context where the data needs to be stuffed in
            AttrsRead  --- The Set of attributes describing "SAM relevant data" read from
                           the database
            AttrsAsked --- The set of attributes that were asked from the database
            TotalAttrsAsked -- The total number of attributes that were asked
            FixedAttrsAsked -- The total number of fixed length SAM attributes asked
            VariableAttrsAsked -- The total number of variable length SAM attributes asked


      Return Values:

        STATUS_SUCCESS
        Other Error codes pertaining to resource failures
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID               SamFixedAttributes=NULL;
    PVOID               SamVariableAttributes=NULL;
    ATTRBLOCK           FixedAttrs;
    ATTRBLOCK           VariableAttrs;
    ULONG               FixedLength=0;
    ULONG               VariableLength=0;
    ULONG               i,j;


    // Due to missing attributes on the object, the result is not guaranteed
    // to be in the same order.  So make a new result set which is the same order
    // as the requested result set.

    SAMP_ALLOCA(FixedAttrs.pAttr,FixedAttrsAsked * sizeof(ATTR));
    if (NULL==FixedAttrs.pAttr)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Generate an Attrblock containing just the fixed attributes, in the order
    // they were allocatated
    //

    FixedAttrs.attrCount = 0;

    for ( i = 1; i < (1 + FixedAttrsAsked); i++ )
    {
        for ( j = 0; j < AttrsRead.attrCount; j++ )
        {
            if ( AttrsAsked.pAttr[i].attrTyp == AttrsRead.pAttr[j].attrTyp )
            {
                FixedAttrs.pAttr[FixedAttrs.attrCount++] = AttrsRead.pAttr[j];
                ASSERT(FixedAttrs.attrCount<=FixedAttrsAsked);
                break;
            }
        }
    }


    //
    // Convert that Attrblock into a SAM OnDisk, containing the fixed
    // length attributes
    //

    NtStatus = SampDsConvertReadAttrBlock(
                                    ObjectType,
                                    SAMP_FIXED_ATTRIBUTES,
                                    &FixedAttrs,
                                    &SamFixedAttributes,
                                    &FixedLength,
                                    &VariableLength);

    if ( !NT_SUCCESS(NtStatus) || (NULL == SamFixedAttributes) )
    {
        if (NULL==SamFixedAttributes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        goto Error;
    }

    //
    // Update this OnDisk onto the SAM context
    //

    NtStatus = SampDsUpdateContextAttributes(
                    NewContext,
                    SAMP_FIXED_ATTRIBUTES,
                    SamFixedAttributes,
                    FixedLength,
                    VariableLength
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Generate an Attrblock containing the variable attributes
    //

    SAMP_ALLOCA(VariableAttrs.pAttr,VariableAttrsAsked * sizeof(ATTR));
    if (NULL==VariableAttrs.pAttr)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    VariableAttrs.attrCount = 0;

    for ( i = (1 + FixedAttrsAsked); i < 1+FixedAttrsAsked+VariableAttrsAsked; i++ )
    {
        for ( j = 0; j < AttrsRead.attrCount; j++ )
        {
            if ( AttrsAsked.pAttr[i].attrTyp == AttrsRead.pAttr[j].attrTyp )
            {
                VariableAttrs.pAttr[VariableAttrs.attrCount++] = AttrsRead.pAttr[j];
                ASSERT(VariableAttrs.attrCount<=VariableAttrsAsked);
                break;
            }
        }
    }


    FixedLength = 0;
    VariableLength = 0;

    //
    // Convert this attrblock into a SAM variable length attribute on Disk
    //

    NtStatus = SampDsConvertReadAttrBlock(
                    ObjectType,
                    SAMP_VARIABLE_ATTRIBUTES,
                    &VariableAttrs,
                    &SamVariableAttributes,
                    &FixedLength,
                    &VariableLength
                    );

    if ( !NT_SUCCESS(NtStatus) || (NULL == SamVariableAttributes))
    {
        if (NULL==SamVariableAttributes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        goto Error;
    }


    //
    // Update this onto the Context
    //

    NtStatus = SampDsUpdateContextAttributes(
                    NewContext,
                    SAMP_VARIABLE_ATTRIBUTES,
                    SamVariableAttributes,
                    FixedLength,
                    VariableLength
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // For User object type, scan the attributes array to see if any
    // supplementary credentials was returned, if so cache it in the
    // context
    //

    if (SampUserObjectType==ObjectType)
    {
        ATTR * SupplementalCredentials = NULL;
        ATTR * LockoutTime = NULL, * LastLogonTimeStamp = NULL;
        ATTR * UPN = NULL;
        ATTR * AccountName = NULL;
        ATTR * SiteAffinity = NULL;
        ATTR * KVNO = NULL;

        NewContext->TypeBody.User.CachedSupplementalCredentialLength =0;
        NewContext->TypeBody.User.CachedSupplementalCredentials = NULL;

        SupplementalCredentials = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                                        &AttrsRead
                                        );

        if (NULL!=SupplementalCredentials)
        {
            NewContext->TypeBody.User.CachedSupplementalCredentials
                = MIDL_user_allocate(SupplementalCredentials->AttrVal.pAVal[0].valLen);
            if (NULL==NewContext->TypeBody.User.CachedSupplementalCredentials)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory(
                NewContext->TypeBody.User.CachedSupplementalCredentials,
                SupplementalCredentials->AttrVal.pAVal[0].pVal,
                SupplementalCredentials->AttrVal.pAVal[0].valLen);

            NewContext->TypeBody.User.CachedSupplementalCredentialLength =
                    SupplementalCredentials->AttrVal.pAVal[0].valLen;

        }

        //
        // Indicate we have valid, cached supplemental credentials. If we did
        // not manage to read it in the DS, it means that it is not set, and
        // this is equivalent to caching the fact that there are no credentials
        //

        NewContext->TypeBody.User.CachedSupplementalCredentialsValid = TRUE;

        //
        // Next, retrieve LockoutTime for the user's account, and cache it
        // in the user-body portion of the account context.
        //

        RtlZeroMemory(&(NewContext->TypeBody.User.LockoutTime),
                      sizeof(LARGE_INTEGER));


        LockoutTime = SampDsGetSingleValuedAttrFromAttrBlock(
                        SAMP_FIXED_USER_LOCKOUT_TIME,
                        &AttrsRead
                        );

        if (NULL != LockoutTime)
        {
            RtlCopyMemory(&(NewContext->TypeBody.User.LockoutTime),
                          LockoutTime->AttrVal.pAVal[0].pVal,
                          LockoutTime->AttrVal.pAVal[0].valLen);
        }

        //
        // Get LastLogonTimeStamp for the user account, and cache it 
        // in the user-body portion of the account context
        //

        RtlZeroMemory(&(NewContext->TypeBody.User.LastLogonTimeStamp),
                      sizeof(LARGE_INTEGER));


        LastLogonTimeStamp = SampDsGetSingleValuedAttrFromAttrBlock(
                                SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
                                &AttrsRead
                                );

        if (NULL != LastLogonTimeStamp)
        {
            RtlCopyMemory(&(NewContext->TypeBody.User.LastLogonTimeStamp),
                          LastLogonTimeStamp->AttrVal.pAVal[0].pVal,
                          LastLogonTimeStamp->AttrVal.pAVal[0].valLen);
        }


        //
        // Add the UPN into the context
        //


        UPN = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_FIXED_USER_UPN,
                                        &AttrsRead
                                        );

        if (NULL!=UPN)
        {
            NewContext->TypeBody.User.UPN.Buffer
                = MIDL_user_allocate(UPN->AttrVal.pAVal[0].valLen);
            if (NULL==NewContext->TypeBody.User.UPN.Buffer)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory(
                NewContext->TypeBody.User.UPN.Buffer,
                UPN->AttrVal.pAVal[0].pVal,
                UPN->AttrVal.pAVal[0].valLen);

            NewContext->TypeBody.User.UPN.Length =
                NewContext->TypeBody.User.UPN.MaximumLength =
                    (USHORT) UPN->AttrVal.pAVal[0].valLen;

            NewContext->TypeBody.User.UpnDefaulted = FALSE;

        }
        else
        {

            UNICODE_STRING AccountNameU;
            PUNICODE_STRING DefaultDomainName =
                &SampDefinedDomains[NewContext->DomainIndex].DnsDomainName;
            ULONG   DefaultUpnLength;

            //
            // Default the UPN in the context to accountname@dnsdomain domain name
            //

            AccountName = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_USER_ACCOUNT_NAME,
                                        &AttrsRead
                                        );

            if (NULL==AccountName)
            {
                ASSERT(FALSE && "AccountName must exist");
                NtStatus = STATUS_INTERNAL_ERROR;
                goto Error;
            }
            AccountNameU.Length = (USHORT) AccountName->AttrVal.pAVal[0].valLen;
            AccountNameU.MaximumLength = (USHORT) AccountName->AttrVal.pAVal[0].valLen;
            AccountNameU.Buffer = (WCHAR*)AccountName->AttrVal.pAVal[0].pVal;

            NtStatus = SampCreateDefaultUPN(&AccountNameU,
                                            NewContext->DomainIndex,
                                            &NewContext->TypeBody.User.UPN);
            if (!NT_SUCCESS(NtStatus)) {
                goto Error;
            }

            NewContext->TypeBody.User.UpnDefaulted = TRUE;

        }

        if (ExtendedFields & SAMP_GROUP_CACHING_ENABLED)
        {

            //
            // Find and our site affinity
            //
            {
                NTSTATUS NtStatus2;
                SAMP_SITE_AFFINITY SiteAffinityTmp;

                NtStatus2 = SampFindUserSiteAffinity( NewContext,
                                                      &AttrsRead, 
                                                      &SiteAffinityTmp );
    
                if ( NT_SUCCESS(NtStatus2) ) {
                    RtlCopyMemory(&NewContext->TypeBody.User.SiteAffinity,
                                  &SiteAffinityTmp,
                                  sizeof(SAMP_SITE_AFFINITY));
                }
            }

        }

        //
        // Find the A2D2 attribute
        //

        if (ExtendedFields & USER_EXTENDED_FIELD_A2D2)
        {

            NewContext->TypeBody.User.A2D2Present = TRUE;

            NtStatus = SampFindUserSPNAttribute(
                             &AttrsRead,
                             SAMP_USER_A2D2LIST,
                             &NewContext->TypeBody.User.A2D2List
                             );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

        //
        // Find the SPN attribute
        //

        if (ExtendedFields & USER_EXTENDED_FIELD_SPN )
        {

            NewContext->TypeBody.User.SPNPresent = TRUE;

            NtStatus = SampFindUserSPNAttribute(
                            &AttrsRead,
                            SAMP_USER_SPN,
                            &NewContext->TypeBody.User.SPNList
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

        
        //
        // Find the key version #
        //

       

         if (ExtendedFields & USER_EXTENDED_FIELD_KVNO )
        {

            NewContext->TypeBody.User.KVNOPresent = TRUE;

            KVNO = SampDsGetSingleValuedAttrFromAttrBlock(
                            SAMP_USER_KVNO,
                            &AttrsRead
                            );

            if (NULL!=KVNO)
            {
                NewContext->TypeBody.User.KVNO = 
                    *(ULONG *) KVNO->AttrVal.pAVal[0].pVal;
            }
        }
    }
    

Error:

    //
    // Free the SAM attributes
    //

    if (NULL!=SamFixedAttributes)
    {
        RtlFreeHeap(RtlProcessHeap(),0,SamFixedAttributes);
    }

    if (NULL!=SamVariableAttributes)
    {
        RtlFreeHeap(RtlProcessHeap(),0,SamVariableAttributes);
    }

    return NtStatus;
}
NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    IN  SAMP_OBJECT_TYPE    ObjectType,
    IN  PSAMP_OBJECT        NewContext,
    IN  ULONG               WhichFields,
    IN  ULONG               ExtendedFields,
    IN  BOOLEAN             OverrideLocalGroupCheck
    )
/*++

    This routine checks for the correct object type and reads both the fixed and variable
    attributes in a single DS read. This improves the performance of account opens.
    All "relevant" properties of the object are cached in the handle as part of the routine
    This strategy has been shown to improve performance as this eliminates subsequent
    calls to the core DS.

    Parameters:

        SampObjectType -- The type of the object
        NewContext     -- Pointer to a New context,
                          that in the process of creation for the object
        WhichFields    -- Indicates the fields of a UserAllInformationStructure
                          that is desired

        ExtendedFields -- Indicates the extended fields in a UserInternal6Information
                          structure that is desired.

        OverrideLocalGroupCheck -- Allows a local group to be opened as a SAM group object, vs
                          a SAM alias object

    Return Values

        STATUS_SUCCESS
        Other Error codes from DS

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            NotFoundStatus = STATUS_NO_SUCH_USER;
    ULONG               AccountType = 0;
    ATTR                *AccountTypeAttr;
    ATTRBLOCK           DesiredAttrs;
    ATTRBLOCK           AttrsRead;
    ATTRBLOCK           FixedAttrs;
    ATTRBLOCK           VariableAttrs;
    ATTRBLOCK           TempAttrs;
    ULONG               ObjectTypeStoredInDs;
    ULONG               i;
    ULONG               AdditionalAttrIndex=0;
    SAMP_ADDITIONAL_ATTR_INFO
                        *AdditionalAttrs = NULL;
    ULONG               AdditionalAttrCount = 0;
    SAMP_OBJECT_TYPE    ObjectTypeToRead = ObjectType;
    ATTR                *GroupTypeAttr = NULL;
    ULONG               GroupType;
    ATTRTYP             AttrTypForGroupType = 0;
    NT4_GROUP_TYPE      DesiredNT4GroupType = NT4LocalGroup,
                        NT4GroupType;
    NT5_GROUP_TYPE      NT5GroupType;
    BOOLEAN             SecurityEnabled;
    BOOLEAN             SidOnlyName = FALSE;
    ULONG               Rid;
    ULONG               MaxRequiredAttrCount=0;

    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType) );

    switch (ObjectType)
    {
    case SampGroupObjectType:
        NotFoundStatus = STATUS_NO_SUCH_GROUP;
        AccountType = SAMP_GROUP_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(GroupAdditionalAttrs);
        AdditionalAttrs = GroupAdditionalAttrs;
        AttrTypForGroupType = SAMP_FIXED_GROUP_TYPE;
        DesiredNT4GroupType = NT4GlobalGroup;
        break;
    case SampAliasObjectType:
        NotFoundStatus = STATUS_NO_SUCH_ALIAS;
        AccountType = SAMP_ALIAS_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(AliasAdditionalAttrs);
        AdditionalAttrs = AliasAdditionalAttrs;
        AttrTypForGroupType = SAMP_FIXED_ALIAS_TYPE;
        DesiredNT4GroupType = NT4LocalGroup;
        break;
    case SampUserObjectType:
        NotFoundStatus = STATUS_NO_SUCH_USER;
        AccountType = SAMP_USER_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(UserAdditionalAttrs);
        AdditionalAttrs = UserAdditionalAttrs;
        break;
    }

    //
    // OR in any sam specific fields into extended fields
    //

    if (SampIsGroupCachingEnabled(NewContext) )
    {
        ExtendedFields |= SAMP_GROUP_CACHING_ENABLED ;
    }

    
    //
    // Construct the fixed attr block def.
    //

    NtStatus = SampDsMakeAttrBlock(
                            ObjectType,
                            SAMP_FIXED_ATTRIBUTES,
                            WhichFields,
                            &FixedAttrs);

    if ( NT_SUCCESS(NtStatus) && (NULL == FixedAttrs.pAttr) )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else if ( NT_SUCCESS(NtStatus) && (NULL != FixedAttrs.pAttr) )
    {
        //
        // Construct the variable attr block def.
        //

        NtStatus = SampDsMakeAttrBlock(
                                ObjectType,
                                SAMP_VARIABLE_ATTRIBUTES,
                                WhichFields,
                                &VariableAttrs);

        if ( NT_SUCCESS(NtStatus) && (NULL == VariableAttrs.pAttr) )
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else if ( NT_SUCCESS(NtStatus) && (NULL != VariableAttrs.pAttr) )
        {
            //
            // Allocate one big DesiredAttrs block.
            //

            DesiredAttrs.attrCount = 1; // object class
            DesiredAttrs.attrCount += FixedAttrs.attrCount;
            DesiredAttrs.attrCount += VariableAttrs.attrCount;


            //
            // Additional Attrs may be required depending upon
            // the object Type. For example we cache supplemental
            // credentials for the user object, or get the group
            // type for groups into the context
            //

            AdditionalAttrIndex = DesiredAttrs.attrCount;
            MaxRequiredAttrCount = DesiredAttrs.attrCount + AdditionalAttrCount;

            SAMP_ALLOCA(DesiredAttrs.pAttr,MaxRequiredAttrCount*sizeof(ATTR)); 

            if ( NULL == DesiredAttrs.pAttr )
            {
                NtStatus = STATUS_NO_MEMORY;
            }
            else
            {
                // Fill in DesiredAttrs.

                ULONG CurrentAttrIndex = AdditionalAttrIndex;

                DesiredAttrs.pAttr[0].attrTyp = AccountType;
                DesiredAttrs.pAttr[0].AttrVal.valCount = 0;
                DesiredAttrs.pAttr[0].AttrVal.pAVal = NULL;

                RtlCopyMemory(
                        &DesiredAttrs.pAttr[1],
                        FixedAttrs.pAttr,
                        FixedAttrs.attrCount * sizeof(ATTR));

                RtlCopyMemory(
                        &DesiredAttrs.pAttr[1 + FixedAttrs.attrCount],
                        VariableAttrs.pAttr,
                        VariableAttrs.attrCount * sizeof(ATTR));

                // Fill in additional Attrs

                for(i=0;i<AdditionalAttrCount;i++)
                {
                    if ((AdditionalAttrs[i].ExtendedField == 0) ||
                       ((AdditionalAttrs[i].ExtendedField & ExtendedFields ) !=0))
                    {
                        ATTR * pAttr;

                        pAttr = &(DesiredAttrs.pAttr[CurrentAttrIndex]);
                        pAttr->attrTyp = AdditionalAttrs[i].Attrtyp;
                        pAttr->AttrVal.valCount = 0;
                        pAttr->AttrVal.pAVal = NULL;
                        DesiredAttrs.attrCount++;
                        CurrentAttrIndex++;
                    }
                }

            }

            RtlFreeHeap(RtlProcessHeap(), 0, VariableAttrs.pAttr);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, FixedAttrs.pAttr);
    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        return(NtStatus);
    }


    //
    // Grab the RID of the object , and also note if it was a SID only
    // name. This check needs to take place before the call into Dir Read
    //


    if ((NewContext->ObjectNameInDs->SidLen>0) &&
        (NewContext->ObjectNameInDs->NameLen==0) &&
        (fNullUuid(&NewContext->ObjectNameInDs->Guid)))
    {
        SidOnlyName = TRUE;
    }




    //
    // Do the read
    //

    NtStatus = SampDsRead(
                NewContext->ObjectNameInDs,
                SAM_ALLOW_REORDER,
                ObjectTypeToRead,
                &DesiredAttrs,
                &AttrsRead
                );

    if ((NtStatus == STATUS_DS_DUPLICATE_ID_FOUND) &&(SidOnlyName))
    {
        DSNAME * Object;
        NTSTATUS TmpStatus;

        ASSERT( (NewContext->DomainIndex >= SampDsGetPrimaryDomainStart()) &&
                (NewContext->DomainIndex < SampDefinedDomainsCount));


         SampSplitSid(
            &NewContext->ObjectNameInDs->Sid,
            NULL,
            &Rid
            );

        //
        // Search for the object, so that we may get all the Duplicates and walk through
        // them and handle them.
        //
        //
        // Search for the object, so that we may get all the Duplicates and walk through
        // them and handle them.
        //

        TmpStatus = SampDsRemoveDuplicateRids(
                         DomainObjectFromAccountContext(NewContext),
                         Rid
                         );
    }



    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Fish out the Account Type
        //

        AccountTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                                AccountType,
                                &AttrsRead
                                );

        if (NULL!= AccountTypeAttr)
        {
            ULONG AccountTypeVal;

            //
            // Account Type was Successfully Read
            //

            AccountTypeVal = *((UNALIGNED ULONG *) AccountTypeAttr->AttrVal.pAVal[0].pVal);

            //
            // Mask out insignificant account type bits
            //

            AccountTypeVal &=0xF0000000;

            //
            // Get the Object Type stored in the DS
            //

            switch(AccountTypeVal)
            {
                case SAM_GROUP_OBJECT:
                case SAM_ALIAS_OBJECT:
                case SAM_APP_BASIC_GROUP:
                case SAM_APP_QUERY_GROUP:
                    ObjectTypeStoredInDs = SampGroupObjectType;
                    break;
                case SAM_USER_OBJECT:
                    ObjectTypeStoredInDs = SampUserObjectType;
                    break;
                default:
                    ASSERT(FALSE && "Unknown Object Type");
                    ObjectTypeStoredInDs = SampUnknownObjectType;
                    break;

            }

            //
            // Depending upon Object Type, and enforce the object type
            // check
            //

            switch(ObjectType)
            {
            case SampAliasObjectType:
            case SampGroupObjectType:

                // Initialize default return
                NtStatus = NotFoundStatus;

                GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                                    AttrTypForGroupType,
                                    &AttrsRead
                                    );

                if ((NULL!=GroupTypeAttr) && (ObjectTypeStoredInDs==SampGroupObjectType))
                {
                    ULONG           GroupTypeTmp;
                    NTSTATUS        TmpStatus;

                    GroupTypeTmp = *((UNALIGNED ULONG *) GroupTypeAttr->AttrVal.pAVal[0].pVal);
                    TmpStatus = SampComputeGroupType(
                                    CLASS_GROUP,
                                    GroupTypeTmp,
                                    &NT4GroupType,
                                    &NT5GroupType,
                                    &SecurityEnabled
                                    );

                    if ((NT_SUCCESS(TmpStatus))
                       && (OverrideLocalGroupCheck ||
                          (NT4GroupType==DesiredNT4GroupType)))
                    {
                        NtStatus = STATUS_SUCCESS;
                        if (SampAliasObjectType==ObjectType)
                        {
                            NewContext->TypeBody.Alias.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Alias.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Alias.SecurityEnabled = SecurityEnabled;
                        }
                        else
                        {
                            NewContext->TypeBody.Group.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Group.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Group.SecurityEnabled = SecurityEnabled;
                        }

                    }
                }

                break;

            case SampUserObjectType:

                if ( (ULONG) ObjectType != ObjectTypeStoredInDs )
                {
                    NtStatus = NotFoundStatus;
                }
                break;
            }
        }
        else
        {
            NtStatus = NotFoundStatus;
        }

        if (NT_SUCCESS(NtStatus))
        {
            //
            //  Fill all the data in the context
            //

            NtStatus = SampDsFillContext(
                            ObjectType,
                            NewContext,
                            AttrsRead,
                            DesiredAttrs,
                            DesiredAttrs.attrCount,
                            FixedAttrs.attrCount,
                            VariableAttrs.attrCount,
                            ExtendedFields
                            );

            if (0!=WhichFields)
            {
                //
                // If we prefetched only some and not others then mark the
                // attributes being only partially valid in the context
                //

                NewContext->AttributesPartiallyValid = TRUE;

                //
                // Mark per attribute invalid bits from WhichFields
                //

                SampMarkPerAttributeInvalidFromWhichFields(NewContext,WhichFields);
            }
        }


    }

    return(NtStatus);
}


BOOLEAN
SampNetLogonNotificationRequired(
    PSID ObjectSid,
    SAMP_OBJECT_TYPE    SampObjectType
    )
/*++

  Routine Description:

    This Routine Checks the defined domains array for the Given Sid and based on the Sid,
    determines if net logon notification is required.

  Parameters:

    ObjectSid   -- The Sid of the object, that is about to be modified.
    SampObjectType -- The type of the SAM object that is about to be modified
    fNotificationRequired -- Out Parameter, finds out if notification is required.

  Return Values

    TRUE    Notification is required
    FALSE   Notification is not required

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;
    PSID        DomainSid = NULL;
    ULONG       Rid;
    PSID        SidToCheck;
    BOOLEAN     fNotificationRequired = FALSE;
    BOOLEAN     LockAcquired = FALSE;



    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        LockAcquired = TRUE;
    }

    //
    // The Ds better be calling us only when we are in DS Mode. The Exception to this is in
    // the Replicated Setup Case. Sam is booted in registry mode and the DS will enquire about
    // notifications to SAM while changes replicate in. Bail out saying no notifications are
    // needed.
    //

    if (FALSE==SampUseDsData)
    {
        fNotificationRequired = FALSE;
    }
    else
    {

        //
        // Copy the Passed in Sid into SidToCheck
        //

        SAMP_ALLOCA(SidToCheck,RtlLengthSid(ObjectSid));
        if (NULL==SidToCheck)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(SidToCheck,ObjectSid, RtlLengthSid(ObjectSid));

        //
        // For domain objects the passed in objectsid is checked in
        // the defined domains array. For other object's the domain Sid
        // is obtained and that checked in the defined domains array
        //

        if (SampDomainObjectType != SampObjectType)
        {
            //
            // The Sid is an account Sid. Obtain the Domain Sid by just decrementing
            // the sub-authority count. We do not want to call split Sid because that
            // routine will allocate memory and we should not fail in here
            //

            (*RtlSubAuthorityCountSid(SidToCheck))--;

        }
        else
        {
            //
            // Nothing to Do, SidToCheck is Domain Sid
            //
        }

        //
        // Walk through the list of defined domains arrays, for domain objects.
        //

        //
        // If we are the G.C and if the domain object is in the builtin domain, then we
        // will supply notifications to netlogon, for change in any of the builtin domains
        // in the G.C . Fortunately built domain objects do not change very often, and
        // therefore its not worthwile adding the extra check.
        //
        //


        for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
        {
            //
            // If the Domain Sid Matches, then we
            // need to supply the notification.
            //


            if (RtlEqualSid(SampDefinedDomains[i].Sid,SidToCheck))
            {
                //
                // The Sid Matches
                //

                fNotificationRequired = TRUE;
                break;
            }
        }
    }

Error:

    if (LockAcquired)
    {
        SampReleaseSamLockExclusive();
    }

    return fNotificationRequired;
}


NTSTATUS
SampNotifyKdcInBackground(
    IN PVOID Parameter
    )
/*++

    This routine is the background worker routine for informing the KDC of account
    changes. The KDC is called in the background because it tends to make SAM calls
    on the Same thread upon this notification. Later we may consider notifying all
    third party notification packages in a back ground thread to offset the danger
    that these packages may make other LSA/SAM calls that may call back into the DS.


    Parameters:

        Parameter : Pointer to a PSAMP_NOTIFCATION_INFORMATION structure used to get
                    information regarding the notification.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DELAYED_NOTIFICATION_INFORMATION NotifyInfo
                        = (PSAMP_DELAYED_NOTIFICATION_INFORMATION)Parameter;

    ASSERT(NULL!=Parameter);

    NtStatus = KdcAccountChangeNotification (
                    &NotifyInfo->DomainSid,
                    NotifyInfo->DeltaType,
                    NotifyInfo->DbObjectType,
                    NotifyInfo->Rid,
                    &NotifyInfo->AccountName,
                    &NotifyInfo->SerialNumber,
                    NULL
                    );

    SampFreeUnicodeString(&NotifyInfo->AccountName);

    MIDL_user_free(Parameter);

    return NtStatus;
}


VOID
SampNotifyAuditChange(
    IN PSID                         ObjectSid,
    IN SECURITY_DB_DELTA_TYPE       DeltaType,
    IN SAMP_OBJECT_TYPE             ObjectType,
    IN PUNICODE_STRING              AccountName,
    IN ULONG                        AccountControl,
    IN ULONG                        GroupType,
    IN ULONG                        CallerType,
    IN PPRIVILEGE_SET               Privileges,
    IN ULONG                        AuditType,
    IN PVOID                        AuditInfo
    )
/*++

    Routine Description

        This is the audit notification function for SAM, called by the DS 
        to process SAM audit notifications.

    Parameters:

        ObjectSid      -- Sid of the Object.  Note: The subauthority count of 
                          this Sid will be changed by this routine.
        DeltaType      -- The Type of Change.
        ObjectType     -- The Type of Sam Object.
        AccountName    -- The Name of the Account.
        AccountControl -- Account control if the object was a user/computer.
        GroupType      -- Type of group is this is a group object.
        CallerType     -- Component that initiated the change.
        AuditType      -- Type of audit.
        AuditInfo      -- Points to a audit type specific structure.
        
    Return Values:

        None 
        
++*/
{   
    NTSTATUS IgnoreStatus;
    ULONG DomainIndex = 0;
    ULONG Rid = 0;  
    PSID DomainSid = ObjectSid;   
    
    //
    // Valid only in ds mode
    //
    if ( !SampUseDsData ) {
        return;
    }
    
    //
    // Split the Sid if the Object Type is an account object Type
    //  
    switch(ObjectType)
    {
    case SampDomainObjectType:

        //
        // One of the SAM domain object's has changed. The object Sid is the
        // domain Sid
        //
        break;

        //
        // In the following cases the Object Sid is the Account Sid. Split Sid
        // can return the domain Sid, but that will make it allocate memory
        // which can potentially fail the call. Therefore we just ask split Sid
        // to return the Rid and in place reduce the sub authority count on the
        // Sid to get the domain Sid
        //
    case SampUserObjectType:
    case SampGroupObjectType:
    case SampAliasObjectType:

        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        (*RtlSubAuthorityCountSid(ObjectSid))--;
        ASSERT(NT_SUCCESS(IgnoreStatus));
        break;

    default:

        //
        // This should never happen
        // 
        ASSERT(FALSE && "Unknown Object Type");
    }  

    //
    // Lookup the domain index
    //     
    for (DomainIndex = SampDsGetPrimaryDomainStart();
         DomainIndex < SampDefinedDomainsCount;
         DomainIndex++)
    {   
        if (RtlEqualSid(DomainSid, SampDefinedDomains[DomainIndex].Sid))
        {   
            break;
        }
    }

    //
    // We should always be able to find a match in the defined domains structure
    //                                
    ASSERT(DomainIndex < SampDefinedDomainsCount);
    
    //
    // Audit object change
    //
    // All change and deletion audits for DS SAM objects are performed via 
    // this notify mechanism.  Replicated changes are not audited.  
    //
    // All other additions and modifications on SAM objects go though
    // the SAM code base where they can leverage existing audits calls that 
    // need to happen in the registry case or have their own notification
    // call since they need special information.
    //   
    if (SampDoAccountAuditing(DomainIndex))
    {
        switch (ObjectType)
        {
        case SampDomainObjectType:

            //
            // Addition for domain objects is not currently defined.
            //
            
            if (SecurityDbChange == DeltaType)
            {
                SampAuditDomainChangeDs(DomainIndex, AuditInfo); 
            }
                    
            //
            // Deletion for domain objects is not currently defined.
            //
            break;

        case SampUserObjectType:

            if (SecurityDbNew == DeltaType)
            {
                SampAuditUserChangeDs(DomainIndex,
                                      AccountName,
                                      AccountControl,
                                      &Rid,
                                      Privileges,
                                      AuditInfo,
                                      TRUE
                                      ); 
            }
            else if (SecurityDbChange == DeltaType)
            {
                SampAuditUserChangeDs(DomainIndex,
                                      AccountName,
                                      AccountControl,
                                      &Rid,
                                      Privileges,
                                      AuditInfo,
                                      FALSE
                                      ); 
            }
            else if (SecurityDbDelete == DeltaType) 
            {
                SampAuditUserDelete(DomainIndex, 
                                    AccountName,
                                    &Rid,
                                    AccountControl
                                    ); 
            }
            break;

        case SampGroupObjectType:
        case SampAliasObjectType:

            //
            // Current auditing model prevents us from unification.  
            // Some audits require information not directly associated with the
            // change which is only available at the time of the change.
            // The priviledges used to create a group are an example, the
            // old value for a modified attribute is another example.
            //
            // If we add the ability to collect such information and store
            // it on the thread state with in such a way we can associate it
            // with this transaction/audit and retrieve it now then we could 
            // unify the model for DS mode and have a clean call
            // to SampAuditGroupChangeDs with Add==TRUE like the user case
            // above.  And we could do before/after delta decisions to allow
            // the move of all loopback task based audits to the notification
            // audit mechanism.
            //
            if (SecurityDbNew == DeltaType)
            {
                SampAuditGroupChangeDs(DomainIndex,
                                       AccountName,
                                       &Rid,
                                       GroupType,
                                       Privileges,
                                       AuditInfo,
                                       TRUE              
                                       );      
            } 
            else if (SecurityDbChange == DeltaType)
            {   
                SampAuditGroupChangeDs(DomainIndex,
                                       AccountName,
                                       &Rid,
                                       GroupType,
                                       Privileges,
                                       AuditInfo,
                                       FALSE              
                                       );  
            }
            else if (SecurityDbDelete == DeltaType)
            {   
                SampAuditGroupDelete(DomainIndex, 
                                     AccountName,
                                     &Rid,
                                     GroupType
                                     );
            }
            
            break;

        default:
            //
            // This should never happen
            //   
            ASSERT(FALSE && "Unknown Object Type");
        }
    }
    
}

 
VOID
SampNotifyReplicatedInChange(
    IN PSID                       ObjectSid,
    IN BOOL                       WriteLockHeldByDs,
    IN SECURITY_DB_DELTA_TYPE     DeltaType,
    IN SAMP_OBJECT_TYPE           ObjectType,
    IN PUNICODE_STRING            AccountName,
    IN ULONG                      AccountControl,
    IN ULONG                      GroupType,
    IN ULONG                      CallerType,
    IN BOOL                       MixedModeChange,
    IN BOOL                       UserAccountControlChange
    )
/*++

    Routine Description

        This is the Notification Function for SAM, called by the DS when a SAM object is changed

    Parameters:

        ObjectSid      -- Sid of the Object
        WriteLockHeldByDs --
        DeltaType      -- The Type of Change
        SampObjectType -- The Type of Sam Object
        AccountName    -- The Name of the Account
        MixedModeChange -- Indicates that the mixed domain nature of the domain
                           is changing
        CallerType     -- component that initiated the change
        MixedModeChange -- Indicates if the domain mode has changed to native.

    Return Values:

        None -- Void Function
++*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;
    PSID        DomainSid = NULL;
    LARGE_INTEGER NetLogonChangeLogSerialNumber;
    ULONG       Rid=0;
    ULONG       i;
    SECURITY_DB_OBJECT_TYPE DbObjectType = SecurityDbObjectSamDomain;
    BOOLEAN     LockAcquired = FALSE;
    PSAMP_DELAYED_NOTIFICATION_INFORMATION NotifyInfo = NULL;
    SAM_DELTA_DATA DeltaData;
    
    // Valid only in ds mode
    if ( !SampUseDsData ) {
        return;
    }

    //
    // Do not grab the Lock Recursively
    //

    if ((!WriteLockHeldByDs) && (!SampCurrentThreadOwnsLock()))
    {
        SampAcquireSamLockExclusive();
        LockAcquired = TRUE;
    }

    //
    // Initialize the serial number
    //

    NetLogonChangeLogSerialNumber.QuadPart = 0;

    //
    // Make a working copy of the Sid
    //
    
    DomainSid = (PSID)MIDL_user_allocate(RtlLengthSid(ObjectSid));
    
    if (NULL == DomainSid) {
        // Fatal resource error
        goto Cleanup;
    }
    
    RtlCopySid(RtlLengthSid(ObjectSid), DomainSid, ObjectSid);
    
    //
    // Split the Sid if the Object Type is an account object Type
    //
    
    switch(ObjectType)
    {
    case SampDomainObjectType:

        //
        // One of the SAM domain object's has changed. The object Sid is the
        // domain Sid
        //
        DbObjectType = SecurityDbObjectSamDomain;
        break;

        //
        // In the following cases the Object Sid is the Account Sid. Split Sid
        // can return the domain Sid, but that will make it allocate memory
        // which can potentially fail the call. Therefore we just ask split Sid
        // to return the Rid and in place reduce the sub authority count on the
        // Sid to get the domain Sid
        //
    case SampUserObjectType:

        DbObjectType = SecurityDbObjectSamUser;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(DomainSid))--;
        DeltaData.AccountControl = AccountControl;
        break;

     case SampGroupObjectType:

        DbObjectType = SecurityDbObjectSamGroup;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(DomainSid))--;
        break;

     case SampAliasObjectType:

        DbObjectType = SecurityDbObjectSamAlias;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(DomainSid))--;
        break;

     default:

        //
        // This should never happen
        //

        ASSERT(FALSE && "Unknown Object Type");
    }  

    //
    // Now we need to obtain the correct netlogon change log serial number
    // Loop through the defined domains structure comparing the Domain Sid
    //

    for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
    {
        //
        // Currently we do not support multiple hosted domains.
        // So O.K to change the mixed state of all domains ( otherwise
        // only that of the builtin and account domain should be invalidated ).
        //

        if (MixedModeChange)
        {
            SampDefinedDomains[i].IsMixedDomain = FALSE;
        }

        if (RtlEqualSid(DomainSid, SampDefinedDomains[i].Sid))
        {

            break;
        }
    }

    //
    // We should always be able to find a match in the defined domains structure
    //

    ASSERT(i<SampDefinedDomainsCount);
    
   
    //
    // Process invalidattions to the group cache
    //

    SampProcessChangesToGroupCache(
        Rid,
        ObjectType,
        UserAccountControlChange,
        AccountControl,
        DeltaType
        );

   
    //
    // for non-security enabled group, nothing to notify, they are passed into 
    // this routine for auditing only. 
    // 

    if (((SampGroupObjectType == ObjectType) ||(SampAliasObjectType == ObjectType)) &&
        !(GROUP_TYPE_SECURITY_ENABLED & GroupType))
    {
        goto Cleanup;
    }


    //
    // if the Builtin Domain Alias information is changed, invalidate the
    // Alias Information Cache.
    //

    if (SampAliasObjectType==ObjectType && IsBuiltinDomain(i))
    {
        IgnoreStatus = SampAlInvalidateAliasInformation(i);
    }



    //
    // if the change was to the domain object, invalidate the domain cache
    //

    if (SampDomainObjectType==ObjectType)
    {
         SampInvalidateDomainCache();

         //
         // Register a notification to update the domain cache in the background
         //
         
         LsaIRegisterNotification(
             SampValidateDomainCacheCallback,
                 ( PVOID ) NULL,
                 NOTIFIER_TYPE_IMMEDIATE,
                 0,
                 NOTIFIER_FLAG_ONE_SHOT,
                 0,
                 0
                ); 
    }


    //
    // If We are in mixed mode then tell netlogon to add this change to the
    // change log
    //

    if (SampDefinedDomains[i].IsMixedDomain)
    {

           BOOLEAN NotifyUrgently = FALSE;

           //
           // Set urgent notification for interdomain trust accounts
           // Note account control is a 0 for non user accounts
           //

           if (AccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
           {
               NotifyUrgently = TRUE;
           }

           //
           // Issue a New Serial Number
           //

            SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart+=1;
            NetLogonChangeLogSerialNumber = SampDefinedDomains[i].NetLogonChangeLogSerialNumber;


            //
            // Notify Netlogon of the Change
            //

            I_NetNotifyDelta(
                            SecurityDbSam,
                            NetLogonChangeLogSerialNumber,
                            DeltaType,
                            DbObjectType,
                            Rid,
                            DomainSid,
                            AccountName,
                            NotifyUrgently,
                            NULL
                            );
    }


    //
    // if a machine account or a trust account has changed
    // then tell netlogon about the change
    //

    if (AccountControl & USER_MACHINE_ACCOUNT_MASK )
    {
            I_NetNotifyMachineAccount(
                    Rid,
                    SampDefinedDomains[i].Sid,
                    (SecurityDbDelete==DeltaType)?AccountControl:0,
                    (SecurityDbDelete==DeltaType)?0:AccountControl,
                    AccountName
                    );
    }


    //
    // Notify the KDC about the delta
    //

    NotifyInfo = MIDL_user_allocate(sizeof(SAMP_NOTIFICATION_INFORMATION));

    if (NULL!=NotifyInfo)
    {
        NTSTATUS    Status = STATUS_SUCCESS;

        //
        // If the memory alloc failed, then drop the notification information
        // on the floor. The commit has taken place anyway and there is not much
        // that we can do.
        //

        RtlZeroMemory(NotifyInfo,sizeof(SAMP_NOTIFICATION_INFORMATION));
        RtlCopyMemory(&NotifyInfo->DomainSid,DomainSid, RtlLengthSid(DomainSid));
        NotifyInfo->DeltaType = DeltaType;
        NotifyInfo->DbObjectType = DbObjectType;
        NotifyInfo->Rid = Rid;
        NotifyInfo->SerialNumber = NetLogonChangeLogSerialNumber;

        if (NULL!=AccountName)
        {
            Status = SampDuplicateUnicodeString(
                            &NotifyInfo->AccountName,
                            AccountName
                            );
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Register an LSA notification call back with the LSA
            // thread pool.
            //

            LsaIRegisterNotification(
                  SampNotifyKdcInBackground,
                  ( PVOID ) NotifyInfo,
                  NOTIFIER_TYPE_IMMEDIATE,
                  0,
                  NOTIFIER_FLAG_ONE_SHOT,
                  0,
                  0
                  );
        }
        else
        {
            //
            // Since we are not giving the notification, free the
            // notifyinfo structure
            //

            MIDL_user_free(NotifyInfo);
            NotifyInfo = NULL;
        }
    }

    //
    // Invalidate the ACL conversion cache
    //

    if ((SampGroupObjectType==ObjectType)||(SampAliasObjectType==ObjectType))
    {
        SampInvalidateAclConversionCache();
    }

    //
    // Let any Third Party Notification packages know about the delta.
    //

    SampDeltaChangeNotify(
        DomainSid,
        DeltaType,
        DbObjectType,
        Rid,
        AccountName,
        &NetLogonChangeLogSerialNumber,
        (DbObjectType==SecurityDbObjectSamUser)?&DeltaData:NULL
        );


Cleanup:

    if (DomainSid) {
        MIDL_user_free((PVOID)DomainSid);
        DomainSid = NULL;
    }

    if (LockAcquired)
    {
        SampReleaseSamLockExclusive();
    }
}

#define  MAX_NT5_NAME_LENGTH  64
#define  MAX_NT4_GROUP_NAME_LENGTH GNLEN        // NT4 time, max group name is 256

NTSTATUS
SampEnforceDownlevelNameRestrictions(
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    )
/*++

    This routine enforces the same name restrictions as the NT4 user interface
    did. The reason for this is backward compatibility with NT4 systems.

    Right now, for groups, it also enforces the NT5 schema limit on
    SamAccountName of 64 characters

   Parameters:

        NewAccountName -- The New Account Name that needs to be checked

        ObjectType -- Tell us the Object Type, such that we can enforce different restrictions
                      for different object.


   Return Values

        STATUS_SUCCESS -- If the name is O.K
        STATUS_INVALID_PARAMETER if the Name does not pass the test

--*/
{
    ULONG i,j;

    //
    // Check the Length
    // Do not apply Length restriction for Groups
    //

    if ((NewAccountName->Length > MAX_DOWN_LEVEL_NAME_LENGTH * sizeof (WCHAR)) &&
        (SampAliasObjectType != ObjectType) && (SampGroupObjectType != ObjectType)
       )
    {
        return STATUS_INVALID_ACCOUNT_NAME;
    }

    // For local and global groups, impose the NT4 Max Group Name Length - 256

    if ((NewAccountName->Length > MAX_NT4_GROUP_NAME_LENGTH * sizeof (WCHAR)) &&
        ((SampAliasObjectType == ObjectType) || (SampGroupObjectType == ObjectType))
       )
    {
        return STATUS_INVALID_ACCOUNT_NAME;
    }


    //
    // Check for invalid characters
    //

    for (i=0;i<(NewAccountName->Length)/sizeof(WCHAR);i++)
    {
        for (j=0;j< ARRAY_COUNT(InvalidDownLevelChars);j++)
        {
            if (InvalidDownLevelChars[j]==((WCHAR *) NewAccountName->Buffer)[i])
            {
                return STATUS_INVALID_ACCOUNT_NAME;
            }
        }
    }

    return STATUS_SUCCESS;
}


VOID
SampFlushNetlogonChangeNumbers()
/*++

    This routine flushes the latest Netlogon serial numbers to disk. This is typically
    called at shutdown time.

    Parameters

        None

    Return Values

        None

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;

    SAMTRACE("SampFlushNetlogonChangeNumbers");

    SampDiagPrint(INFORM,("Flushing Netlogon Serial Numbers to Disk\n"));

    for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
    {
        LARGE_INTEGER   DomainModifiedCount;
        ATTRVAL         DomainModifiedCountVal[] = {sizeof(LARGE_INTEGER),(UCHAR *) &DomainModifiedCount};
        ATTRTYP         DomainModifiedCountTyp[] = {SAMP_FIXED_DOMAIN_MODIFIED_COUNT};
        DEFINE_ATTRBLOCK1(DomainModifiedCountAttr,DomainModifiedCountTyp,DomainModifiedCountVal);

        //
        // Domain must be DS domain.
        //

        ASSERT(IsDsObject(SampDefinedDomains[i].Context));

        DomainModifiedCount.QuadPart = SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart;
        NtStatus = SampDsSetAttributes(
                        SampDefinedDomains[i].Context->ObjectNameInDs,
                        0,
                        REPLACE_ATT,
                        SampDomainObjectType,
                        &DomainModifiedCountAttr
                        );

        //
        // Not much we can do if we fail
        //

    }

    //
    // Commit the Changes. Not much can be done on failure
    //

    SampMaybeEndDsTransaction(TransactionCommit);

}


//
// The Following Functions implement a logic that ensures that
// all SAM threads accessing the Database wihout the SAM lock held
// are finished with their respective activities before the Database
// is shut down. The Way this works is as follws
//
//      1. Threads accessing the database without the SAM lock held
//         increment the active thread count while entering the Database
//         section and decrement it while leaving the database section
//
//      2. Shutdown notification code sets SampServiceState to not running
//         and waits till the active thread count is 0. This wait times out
//         after some time, so that stuck or dead locked callers are ignored
//         and a clean shut down is performed.
//


ULONG SampActiveThreadCount=0;
HANDLE SampShutdownEventHandle=INVALID_HANDLE_VALUE;
HANDLE SampAboutToShutdownEventHandle = INVALID_HANDLE_VALUE;


NTSTATUS
SampInitializeShutdownEvent()
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = NtCreateEvent(
                    &SampAboutToShutdownEventHandle,
                    EVENT_ALL_ACCESS,
                    NULL,
                    NotificationEvent,
                    FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }
    
    return(NtCreateEvent(
                &SampShutdownEventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE));
}

// avoid the MSB in case of any sign bit confusion

#define SAMP_SERVICE_TERMINATING_BIT 0x40000000

NTSTATUS
SampIncrementActiveThreads()
/*++
    Routine Description

        This Routine Increments the Active Thread Count counter in an
        atomic fashion.

--*/
{
  
    //
    // Check our Running State, if O.K increment active thread count
    // 

    if (InterlockedIncrement(&SampActiveThreadCount) > SAMP_SERVICE_TERMINATING_BIT) {

        SampDecrementActiveThreads();

        return(STATUS_INVALID_SERVER_STATE);
    }

    return STATUS_SUCCESS;
}

VOID
SampDecrementActiveThreads()
/*++

    This Routine Decrements the Active Thread Count counter in an atomin
    fashion

--*/
{
    //
    // Decrement the Active thread count
    //

    if (SAMP_SERVICE_TERMINATING_BIT == InterlockedDecrement(&SampActiveThreadCount))
    {

        NtSetEvent(SampShutdownEventHandle,NULL);
    }
}

VOID
SampWaitForAllActiveThreads(
    IN PSAMP_SERVICE_STATE PreviousServiceState OPTIONAL
    )
/*++

    This Routine Waits for all threads not holding SAM lock but
    actively using the Database to finish their Work

--*/
{
    if ( PreviousServiceState )
    {
        *PreviousServiceState = SampServiceState;
    }

    //
    // Set the service state to terminating
    //

    SampServiceState = SampServiceTerminating;

    //
    // Set the event to signal that we are about to shutdown
    //

    NtSetEvent(SampAboutToShutdownEventHandle,NULL);

    //
    // Set the service terminating bit
    //

    if (0!=InterlockedExchangeAdd(&SampActiveThreadCount,SAMP_SERVICE_TERMINATING_BIT))
    {
        //
        // There is at least one active thread
        //

        // Wait for at most 2 seconds for the thread

        DWORD TimeToWait = 2000;

        WaitForSingleObject(SampShutdownEventHandle,TimeToWait);
    }

    //
    // Signal the  shutdown event any case to tell everyone to abort
    //

    NtSetEvent(SampShutdownEventHandle,NULL);
}

BOOLEAN
SampIsSetupInProgress(
    OUT BOOLEAN *Upgrade OPTIONAL
    )
/*++

Routine Description:

    This routine makes registry calls to determine if we are running
    during gui mode setup or not.  If an unexpected error is returned
    from a system service, then we are assume we are not running during
    gui mode setup.

Arguments:

    Upgrade:  set to true if this is an upgrade

Return Value:

    TRUE we are running during gui mode setup; FALSE otherwise

--*/
{
    NTSTATUS          NtStatus;

    OBJECT_ATTRIBUTES SetupKeyObject;
    HANDLE            SetupKeyHandle;
    UNICODE_STRING    SetupKeyName;

    UNICODE_STRING    ValueName;
    DWORD             Value;

    BYTE                             Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize;

    BOOLEAN           SetupInProgress = FALSE;
    BOOLEAN           UpgradeInProgress = FALSE;

    RtlInitUnicodeString(&SetupKeyName, L"\\Registry\\Machine\\System\\Setup");

    RtlZeroMemory(&SetupKeyObject, sizeof(SetupKeyObject));
    InitializeObjectAttributes(&SetupKeyObject,
                               &SetupKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SetupKeyHandle,
                         KEY_READ,
                         &SetupKeyObject);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Read the value for setup
        //
        RtlInitUnicodeString(&ValueName, L"SystemSetupInProgress");

        RtlZeroMemory(Buffer, sizeof(Buffer));
        KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        KeyPartialInfoSize = sizeof(Buffer);
        NtStatus = NtQueryValueKey(SetupKeyHandle,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {

            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             RtlAllocateHeap(RtlProcessHeap(), 0, KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SetupKeyHandle,
                                           &ValueName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {
                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            if (KeyPartialInfo->DataLength == sizeof(DWORD)) {

                Value = *(DWORD*)(KeyPartialInfo->Data);

                if (Value) {
                    SetupInProgress = TRUE;
                }
            }
        }

        if (KeyPartialInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, KeyPartialInfo);
        }


        //
        // Now read the value for upgrade
        //
        RtlInitUnicodeString(&ValueName, L"UpgradeInProgress");

        RtlZeroMemory(Buffer, sizeof(Buffer));
        KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
        KeyPartialInfoSize = sizeof(Buffer);
        NtStatus = NtQueryValueKey(SetupKeyHandle,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {

            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             RtlAllocateHeap(RtlProcessHeap(), 0, KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SetupKeyHandle,
                                           &ValueName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {
                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            if (KeyPartialInfo->DataLength == sizeof(DWORD)) {

                Value = *(DWORD*)(KeyPartialInfo->Data);

                if (Value) {
                    UpgradeInProgress = TRUE;
                }
            }
        }

        if (KeyPartialInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, KeyPartialInfo);
        }

        NtClose(SetupKeyHandle);

    } else {

        //
        // If this key does not exist, then we certainly are not
        // running in gui mode setup.
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Open of \\Registry\\Machine\\System\\Setup failed with 0x%x\n",
                   NtStatus));

    }

    if (Upgrade) {
        *Upgrade = UpgradeInProgress;
    }

    return SetupInProgress;
}

VOID
SampWriteToSetupLog(
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the event id parameter and outputs it to the setup log.

Parameters:

    Same as SampWriteEventLog

Return Values:

   None

--*/
{
    HMODULE ResourceDll;
    WCHAR   *OutputString=NULL;
    PWCHAR  *InsertArray=NULL;
    ULONG   Length, Size;
    BOOL    Status;
    ULONG   i;

    SAMP_ALLOCA(InsertArray,(NumStrings+1)*sizeof(PWCHAR));
    if (NULL==InsertArray)
    {
        //
        // memory alloc failure; do not log
        //

        return;
    }

    for(i=0;i<NumStrings;i++)
    {
        InsertArray[i]=Strings[i]->Buffer;
    }
    InsertArray[NumStrings]=NULL;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        EventID,
                                        0,       // Use caller's language
                                        (LPWSTR)&OutputString,
                                        0,       // routine should allocate
                                        (va_list*) (InsertArray)
                                        );
        if (OutputString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            OutputString[Length-2] = L'\0';
            Length -= 2;

            if (SetupOpenLog(FALSE)) { // don't erase

                // for now everything is LogSevWarning
                Status = SetupLogError(OutputString, LogSevWarning);
                ASSERT(Status);
                SetupCloseLog();
            }
            LocalFree(OutputString);
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }


    return;

}

VOID
SampUpdatePerformanceCounters(
    IN DWORD                dwStat,
    IN DWORD                dwOperation,
    IN DWORD                dwChange
    )
/*++

Routine Description:

    For Server case, updates DS performance counters.
    For Workstation case, its a NOP

Arguments:

    dwStat - DSSTAT_* Statistic to update
    dwOperation - COUNTER_INCREMENT or COUNTER_SET
    dwChange - Value to set if dwOperation == COUNTER_SET

Return Value:

    None

--*/
{
    if ( SampUseDsData )
    {
        UpdateDSPerfStats( dwStat, dwOperation, dwChange );
    }
}


VOID
SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
)
/*++

    Routine Description

        This routine updates performance counters in the DS performance
        shared memory block.

    Parameters

        CounterType - Indicates what counter to increment.

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/                 
{
    if (SampUseDsData &&
        (SampServiceState == SampServiceEnabled))
    {
        switch(CounterType)
        {
        case MsvLogonCounter:
             SampUpdatePerformanceCounters(DSSTAT_MSVLOGONS,FLAG_COUNTER_INCREMENT,0);

             break;

        case KerbServerContextCounter:
             SampUpdatePerformanceCounters(DSSTAT_KERBEROSLOGONS,FLAG_COUNTER_INCREMENT,0);
             break;

        case KdcAsReqCounter:
             SampUpdatePerformanceCounters(DSSTAT_ASREQUESTS,FLAG_COUNTER_INCREMENT,0);
             break;

        case KdcTgsReqCounter:
             SampUpdatePerformanceCounters(DSSTAT_TGSREQUESTS,FLAG_COUNTER_INCREMENT,0);
             break;
        }
    }
}


NTSTATUS
SampCommitBufferedWrites(
    IN SAMPR_HANDLE SamHandle
    )
/*++

    Routine Description

      Routine for loopback callers to flush buffered writes in the Sam context
      to Disk. Buffered writes is currently used only by loopback

    Parameters

        SamHandle -- Handle to SAM

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/
{
   PSAMP_OBJECT Context = (PSAMP_OBJECT)SamHandle;
   NTSTATUS     NtStatus = STATUS_SUCCESS;
   NTSTATUS     IgnoreStatus = STATUS_SUCCESS;


   //
   // Increment the active thread count, so we will consider this
   // thread at shutdown time
   // 
   NtStatus = SampIncrementActiveThreads();
   if (!NT_SUCCESS(NtStatus))
   {
       return( NtStatus );
   }


   ASSERT(Context->LoopbackClient);

   //
   // Reference the Context
   //

   SampReferenceContext(Context);


   //
   // Flush any buffered Membership Operations to DS. only apply for Group and Alias Object.
   //
   switch (Context->ObjectType) {

   case SampGroupObjectType:

       if (Context->TypeBody.Group.CachedMembershipOperationsListLength)
       {
           NtStatus = SampDsFlushCachedMembershipOperationsList(Context->ObjectNameInDs,
                                                                SampGroupObjectType,
                                                                SAMP_GROUP_MEMBERS,
                                                                &Context->TypeBody.Group.CachedMembershipOperationsList,
                                                                &Context->TypeBody.Group.CachedMembershipOperationsListMaxLength,
                                                                &Context->TypeBody.Group.CachedMembershipOperationsListLength);
       }

       break;

   case SampAliasObjectType:

       if (Context->TypeBody.Alias.CachedMembershipOperationsListLength)
       {
           NtStatus = SampDsFlushCachedMembershipOperationsList(Context->ObjectNameInDs,
                                                                SampAliasObjectType,
                                                                SAMP_ALIAS_MEMBERS,
                                                                &Context->TypeBody.Alias.CachedMembershipOperationsList,
                                                                &Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength,
                                                                &Context->TypeBody.Alias.CachedMembershipOperationsListLength);
       }

       if (Context->TypeBody.Alias.CachedNonMembershipOperationsListLength)
       {
           NtStatus = SampDsFlushCachedMembershipOperationsList(Context->ObjectNameInDs,
                                                                SampAliasObjectType,
                                                                SAMP_ALIAS_NON_MEMBERS,
                                                                &Context->TypeBody.Alias.CachedNonMembershipOperationsList,
                                                                &Context->TypeBody.Alias.CachedNonMembershipOperationsListMaxLength,
                                                                &Context->TypeBody.Alias.CachedNonMembershipOperationsListLength);
       }

       break;

   default:

       ;
   }

   //
   // if something goes wrong, then we just quit
   //
   if (!NT_SUCCESS(NtStatus))
   {
       SampDeReferenceContext(Context, FALSE);
       ASSERT(NT_SUCCESS(IgnoreStatus));

   }
   else
   {

       //
       // Turn of Buffered Writes and force a flush
       //

       Context->BufferWrites = FALSE;

       //
       // Dereference context. Commit Changes
       //

       NtStatus = SampDeReferenceContext(Context,TRUE);

   }


   //
   // Let shutdown handling logic know that we are done
   // 

   SampDecrementActiveThreads();


   return(NtStatus);

}


ULONG
SampPositionOfHighestBit(
    ULONG Flag
    )
//
// Returns the position of the highest bit in Flag
// ranges from 32 - 0; 0 is returned if no bit is set.
//
{
    ULONG Index, Position;

    for (Index = 0x80000000, Position = 32;
            Index != 0;
                Index >>= 1, Position--)

        if ( Flag & Index )

            return Position;


    return 0;
}

NTSTATUS
SampSetAccountDomainPolicy(
    IN PUNICODE_STRING AccountDomainName,
    IN PSID            AccountDomainSid
    )
/*++

Routine Description

    This routine sets the account domain information in the LSA

Parameters

    AccountDomainName : the "external" name of the domain

    AccountDomainSid : the sid of the domain

Return Values

    STATUS_SUCCESS
    status from the LSA

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    LSAPR_HANDLE PolicyHandle = 0;
    POLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;


    // Parameter check
    ASSERT( AccountDomainName );
    ASSERT( AccountDomainSid );

    NtStatus = LsaIOpenPolicyTrusted( &PolicyHandle );

    if ( NT_SUCCESS( NtStatus ) )
    {
        RtlZeroMemory( &AccountDomainInfo, sizeof(AccountDomainInfo) );
        AccountDomainInfo.DomainName = *AccountDomainName;
        AccountDomainInfo.DomainSid = AccountDomainSid;

        NtStatus = LsarSetInformationPolicy( PolicyHandle,
                                             PolicyAccountDomainInformation,
                                             (LSAPR_POLICY_INFORMATION*) &AccountDomainInfo );

    }


    if ( PolicyHandle )
    {
        LsarClose( &PolicyHandle );
    }

    return NtStatus;

}


VOID
SampMapNtStatusToClientRevision(
   IN ULONG ClientRevision,
   IN OUT NTSTATUS *pNtStatus
   )
/*++

    Routine Description

       This routine takes the NtStatus passed in converts it to the NTSTATUS
       code that is most appropriate for the client revision indicated.

    Parameters:

       ClientRevision -- The revision of the client
       NtStatus       -- The NtStatus to be mapped is passed in and at the
                         end of the function, the mapped NtStatus is passed out

    Return Values

       None
--*/
{
    NTSTATUS    DownLevelNtStatus = *pNtStatus;

    //
    // for DownLevel client, map the new NtStatus code to the one they can understand
    //

    if (ClientRevision < SAM_CLIENT_NT5)
    {
        switch (*pNtStatus) {

        //
        // These new status codes are all for group membership operations.
        //

        case STATUS_DS_INVALID_GROUP_TYPE:
            DownLevelNtStatus = STATUS_INVALID_PARAMETER;
            break;

        case STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN:
        case STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN:
        case STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER:
        case STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER:
        case STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER:
        case STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER:
        case STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER:
            DownLevelNtStatus = STATUS_INVALID_MEMBER;
            break;

        case STATUS_DS_HAVE_PRIMARY_MEMBERS:
            DownLevelNtStatus = STATUS_MEMBER_IN_GROUP;
            break;

        case STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED:
            DownLevelNtStatus = STATUS_QUOTA_EXCEEDED;
            break;

        default:
            ;
            break;
        }

        *pNtStatus = DownLevelNtStatus;
    }
}



NTSTATUS
SamISameSite(
   OUT BOOLEAN * result
   )
/*++

Routine Description:

    This routine retrieves the Domain Object's fSMORoleOwner attribute, which
    is the PDC's DSNAME, then get the current DC's NTDS setting object.

    Bying comparing the current DC's ntds setting with fSMORoleOwner value,
    we can tell whether this DC is in the same site with PDC or not.

Parameters:

    result -- pointer to boolean. indication PDC and the current DS are in the
              same site or not.

              TRUE - same site,   FALSE - different site.

Return Value:

    STATUS_SUCCESS -- everything goes well,

    NtStatus

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    DWORD    Length = 0;
    DSNAME   *PDCObject = NULL;
    DSNAME   *PDCObjectTrimmed = NULL;
    DSNAME   *LocalDsaObject = NULL;
    DSNAME   *LocalDsaObjectTrimmed = NULL;
    DSNAME   *DomainObject = NULL;
    READARG  ReadArg;
    READRES  *ReadResult = NULL;
    ENTINFSEL EntInfSel;
    COMMARG  *CommArg = NULL;
    ATTR     AttrToRead;
    ULONG    DirError;


    SAMTRACE("SamISameSite");


    //
    // Get the Domain Object's DSNAME
    //
    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainObject
                                    );

    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        SAMP_ALLOCA(DomainObject,Length);
        if (NULL!=DomainObject)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &Length,
                                            DomainObject
                                            );
        }
        else 
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Get the NTDS setting object's DSNAME
    //
    Length = 0;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &Length,
                                    LocalDsaObject
                                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(LocalDsaObject,Length);
        if (NULL!=LocalDsaObject)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                            &Length,
                                            LocalDsaObject
                                            );
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Create/Begin DS Transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Prepare arguments to call DirRead,
    // read fSMORoleOwner attribute of Domain object
    //
    memset(&ReadArg, 0, sizeof(READARG));
    memset(&EntInfSel, 0, sizeof(ENTINFSEL));

    AttrToRead.attrTyp = ATT_FSMO_ROLE_OWNER;
    AttrToRead.AttrVal.valCount = 0;
    AttrToRead.AttrVal.pAVal = NULL;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &AttrToRead;

    ReadArg.pObject = DomainObject;
    ReadArg.pSel = &EntInfSel;
    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL == ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    SampClearErrors();

    //
    // Extract the value of fSMORoleOwner if succeed
    //
    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(NULL != ReadResult);
        ASSERT(1 == ReadResult->entry.AttrBlock.attrCount);
        ASSERT(ATT_FSMO_ROLE_OWNER == ReadResult->entry.AttrBlock.pAttr[0].attrTyp);
        ASSERT(1 == ReadResult->entry.AttrBlock.pAttr[0].AttrVal.valCount);

        PDCObject = (PDSNAME) ReadResult->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;

        SAMP_ALLOCA(PDCObjectTrimmed,PDCObject->structLen);
        if (NULL==PDCObjectTrimmed)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        SAMP_ALLOCA(LocalDsaObjectTrimmed,LocalDsaObject->structLen);
        if (NULL==LocalDsaObjectTrimmed)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (TrimDSNameBy( PDCObject, 3, PDCObjectTrimmed) ||
            TrimDSNameBy( LocalDsaObject, 3, LocalDsaObjectTrimmed)
            )
        {
            //
            // Trim DSNAME error
            //
            NtStatus = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (NameMatched(PDCObjectTrimmed, LocalDsaObjectTrimmed))
        {
            //
            // match ==> same site
            //
            *result = TRUE;
        }
        else
        {
            //
            // not match
            //
            *result = FALSE;
        }
    }

Cleanup:

    IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                              TransactionCommit :
                                              TransactionAbort );

    return NtStatus;

}


BOOLEAN
SamINT4UpgradeInProgress(
    VOID
    )
/*++

Routine Description:

    RAS User Parameters Convert routine needs to know whether this machine is
    promoted from NT4 PDC or from Windows 2000 Server.

    Global variable SampNT4UpgradeInProgress is set in SamIPromote(), thus we
    can tell RAS where we are

Parameters:

    None.

Return Values:

    TRUE -- machine is promoted from NT4 PDC
    FALSE -- machine is promoted from Windows 2000 Server

--*/
{
    return (SampNT4UpgradeInProgress);
}


BOOLEAN
SampIsMemberOfBuiltinDomain(
    IN PSID Sid
    )
/*++

Routine Description:

    This routine determines if a sid is a part of the built in domain.

Parameters:

    Sid -- a valid, non null sid.

Return Values:

    TRUE if the sid is part of the builtin domain; FALSE otherwise

--*/
{
    UCHAR SubAuthorityCount;
    BOOLEAN fResult = FALSE;

    SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);

    if ( SubAuthorityCount > 0 ) {

        *RtlSubAuthorityCountSid(Sid) = SubAuthorityCount-1;

        fResult = RtlEqualSid( Sid, SampBuiltinDomainSid );

        *RtlSubAuthorityCountSid(Sid) = SubAuthorityCount;
    }

    return fResult;

}


NTSTATUS
SamIGetDefaultAdministratorName(
    OUT LPWSTR Name,             OPTIONAL
    IN OUT ULONG  *NameLength
    )
/*++

Routine Description:

    This routine extracts the localized default name of the administrator's
    account.  Note: this is not necessary the current name of the admin (
    the account could have been renamed).

Parameters:

    Name -- buffer to be filled in

    NameLength -- length in characters of the buffer

Return Values:

    STATUS_SUCCESS if the name was found;
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE AccountNameResource;
    LPWSTR AdminName = NULL;

    ASSERT( NameLength );
    if ( (*NameLength) > 0 ) {
        ASSERT( Name );
    }

    //
    // Get the localized Admin name
    //
    AccountNameResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if ( AccountNameResource ) {

        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                       AccountNameResource,
                       SAMP_USER_NAME_ADMIN,
                       0, // use the caller's language
                       (LPWSTR) &AdminName,
                       0,
                       NULL );

        FreeLibrary(  AccountNameResource );
    }

    if ( AdminName ) {

        ULONG Length = wcslen(AdminName) + 1;

        // remove the cr and lf characters
        ASSERT( Length > 2 );
        Length -= 2;

        if ( *NameLength >= Length ) {

            wcsncpy( Name, AdminName, (Length-1) );

            Name[Length-1] = L'\0';

        } else {

            Status = STATUS_BUFFER_TOO_SMALL;

        }
        *NameLength = Length;

        LocalFree( AdminName );

    } else {

        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;

}



NTSTATUS
SampConvertUiListToApiList(
    IN  PUNICODE_STRING UiList OPTIONAL,
    OUT PUNICODE_STRING ApiList,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Converts a list of workstation names in UI/Service format into a list of
    canonicalized names in API list format. UI/Service list format allows
    multiple delimiters, leading and trailing delimiters. Delimiters are the
    set "\t,;". API list format has no leading or trailing delimiters and
    elements are delimited by a single comma character.

    For each name parsed from UiList, the name is canonicalized (which checks
    the character set and name length) as a workstation name. If this fails,
    an error is returned. No information is returned as to which element
    failed canonicalization: the list should be discarded and a new one re-input

Arguments:

    UiList  - The list to canonicalize in UI/Service list format
    ApiList - The place to store the canonicalized version of the list in
              API list format.  The list will have a trailing zero character.
    BlankIsDelimiter - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    List converted ok

        Failure = STATUS_INVALID_PARAMETER
                    UiList parameter is in error

                  STATUS_INVALID_COMPUTER_NAME
                    A name parsed from UiList has an incorrect format for a
                    computer (aka workstation) name
--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG inLen=0;
    PWSTR input;
    PWSTR buffer;
    PWSTR output;
    ULONG cLen;
    ULONG len;
    ULONG outLen = 0;
    WCHAR element[DNS_MAX_NAME_BUFFER_LENGTH+1];
    BOOLEAN firstElement = TRUE;
    BOOLEAN ok;

    try {
        if (ARGUMENT_PRESENT(UiList)) {
            inLen = UiList->MaximumLength;  // read memory test
            inLen = UiList->Length;
            input = UiList->Buffer;
            if (inLen & sizeof(WCHAR)-1) {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        RtlInitUnicodeString(ApiList, NULL);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = STATUS_ACCESS_VIOLATION;
    }
    if (NT_SUCCESS(status) && ARGUMENT_PRESENT(UiList) && inLen) {
        buffer = RtlAllocateHeap(RtlProcessHeap(), 0, inLen + sizeof(WCHAR));
        if (buffer == NULL) {
            status = STATUS_NO_MEMORY;
        } else {
            ApiList->Buffer = buffer;
            ApiList->MaximumLength = (USHORT)inLen + sizeof(WCHAR);
            output = buffer;
            ok = TRUE;
            while (len = SampNextElementInUIList(&input,
                                     &inLen,
                                     element,
                                     sizeof(element) - sizeof(element[0]),
                                     BlankIsDelimiter )) {
                if (len == (ULONG)-1L) {
                    ok = FALSE;
                } else {
                    cLen = len/sizeof(WCHAR);
                    element[cLen] = 0;
                    ok = SampValidateComputerName(element, cLen);
                }
                if (ok) {
                    if (!firstElement) {
                        *output++ = L',';

                        //
                        // sizeof(L',') returns 4, not 2!! because
                        // it also includes space for the NULL terminator
                        // in the end
                        //

                        outLen += sizeof(WCHAR);
                    } else {
                        firstElement = FALSE;
                    }
                    wcscpy(output, element);
                    outLen += len;
                    output += cLen;
                } else {
                    RtlFreeHeap(RtlProcessHeap(), 0, buffer);
                    ApiList->Buffer = NULL;
                    status = STATUS_INVALID_COMPUTER_NAME;
                    break;
                }
            }
        }
        if (NT_SUCCESS(status)) {
            ApiList->Length = (USHORT)outLen;
            if (!outLen) {
                ApiList->MaximumLength = 0;
                ApiList->Buffer = NULL;
                RtlFreeHeap(RtlProcessHeap(), 0, buffer);
            }
        }
    }
    return status;
}


ULONG
SampNextElementInUIList(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Locates the next (non-delimiter) element in a string and extracts it to a
    buffer. Delimiters are the set [\t,;]

Arguments:

    InputBuffer         - pointer to pointer to input buffer including delimiters
                          Updated on successful return
    InputBufferLength   - pointer to length of characters in InputBuffer.
                          Updated on successful return
    OutputBuffer        - pointer to buffer where next element is copied
    OutputBufferLength  - size of OutputBuffer (in bytes)
    BlankIsDelimiter    - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    ULONG
                           -1 = error - extracted element breaks OutputBuffer
                            0 = no element extracted (buffer is empty or all
                                delimiters)
        1..OutputBufferLength = OutputBuffer contains extracted element

--*/

{
    ULONG elementLength = 0;
    ULONG inputLength = *InputBufferLength;
    PWSTR input = *InputBuffer;

    while (inputLength && IS_DELIMITER(*input, BlankIsDelimiter)) {
        ++input;
        inputLength -= sizeof(*input);
    }
    while (inputLength && !IS_DELIMITER(*input, BlankIsDelimiter)) {
        if (!OutputBufferLength) {
            return (ULONG)-1L;
        }
        *OutputBuffer++ = *input++;
        OutputBufferLength -= sizeof(*input);
        elementLength += sizeof(*input);
        inputLength -= sizeof(*input);
    }
    *InputBuffer = input;
    *InputBufferLength = inputLength;
    return elementLength;
}


BOOLEAN
SampValidateComputerName(
    IN  PWSTR Name,
    IN  ULONG Length
    )

/*++

Routine Description:

    Determines whether a computer name is valid or not

Arguments:

    Name    - pointer to zero terminated wide-character computer name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid computer name
        FALSE   Name is not valid computer name

--*/

{

    if (0==DnsValidateName(Name,DnsNameHostnameFull))
    {
        //
        // O.K if it is a DNS name
        //

        return(TRUE);
    }

    //
    // Fall down to netbios name validation
    //

    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, InvalidDownLevelChars) == Length);
}



VOID
SamINotifyServerDelta(
    IN SAMP_NOTIFY_SERVER_CHANGE Change
    )
/*++

Routine Description:

    This routine is called by in proc components to notify SAM of global
    state change.
    
Arguments:

    Change -- the type of change that has occurred                

Return Value:

    None.

--*/
{
    PVOID fRet;

    switch ( Change ) {
    
    case SampNotifySiteChanged:

        fRet = LsaIRegisterNotification(SampUpdateSiteInfoCallback,
                                        NULL,
                                        NOTIFIER_TYPE_INTERVAL,
                                        0,            // no class
                                        NOTIFIER_FLAG_ONE_SHOT,
                                        1,          // wait for 1 seconds
                                        NULL        // no handle
                                        );

        if (!fRet) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to register SiteNotification\n"));
        }
        break;

    default:

        ASSERT( FALSE && "Unhandled change notification" );
    }

}
ULONG
SampClientRevisionFromHandle(IN PVOID handle)
{
   ULONG Revision = SAM_CLIENT_PRE_NT5;

   __try {
      Revision = ((NULL!=(PSAMP_OBJECT)handle)?(((PSAMP_OBJECT)handle)->ClientRevision):SAM_CLIENT_PRE_NT5);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
      ;;
   }

   return(Revision);
}


NTSTATUS
SampCreateDefaultUPN(
    IN PUNICODE_STRING AccountName,
    IN ULONG           DomainIndex,
    OUT PUNICODE_STRING UPN
    )
/*++

Routine Description:

    This routine creates the AccountName@DnsDomainName format name.
    
Arguments:

    AccountName -- the SAM account name
    
    DomainIndex -- the domain in which the account live
    
    UPN -- the constructed UPN, allocated via MIDL_user_allocate.

Return Value:

    STATUS_SUCCESS, resource error otherwise.                                                                 

--*/
{
    PUNICODE_STRING DefaultDomainName =
        &SampDefinedDomains[DomainIndex].DnsDomainName;
    USHORT   DefaultUpnLength;

    DefaultUpnLength = AccountName->Length+
                       DefaultDomainName->Length
                       + sizeof(WCHAR);

    UPN->Buffer = MIDL_user_allocate(DefaultUpnLength);
    if (NULL == UPN->Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(UPN->Buffer, AccountName->Buffer, AccountName->Length);

    RtlCopyMemory(
        (PBYTE)(UPN->Buffer) + AccountName->Length + 2 ,
        DefaultDomainName->Buffer,
        DefaultDomainName->Length);

    *(UPN->Buffer + AccountName->Length/2) = L'@';

    UPN->Length = DefaultUpnLength;
    UPN->MaximumLength = DefaultUpnLength;

    return STATUS_SUCCESS;
}


DWORD
SampWideCharToMultiByte(
    IN UINT    CodePage, 
    IN DWORD   dwFlags, 
    IN LPCWSTR lpWideCharStr, 
    IN INT     cchWideChar, 
    IN LPCSTR  lpDefaultChar, 
    IN LPBOOL  lpUsedDefaultChar,
    OUT LPSTR  *MultiByteStr
    )
//
// This routine is a simple allocation wrapper for the win32
// API WideCharToMultiByte routine.  midl_user_allocate is
// is the allocator, thus MultiByteStr must be freed with
// midl_user_free
//
{
    ULONG Size;

    *MultiByteStr = NULL;

    Size = WideCharToMultiByte(CodePage,
                        dwFlags,
                        lpWideCharStr,
                        cchWideChar,
                        NULL,
                        0,
                        lpDefaultChar,
                        lpUsedDefaultChar);
    if (Size > 0) {

        (*MultiByteStr) = MIDL_user_allocate(Size + sizeof(CHAR));
        if ((*MultiByteStr)) {

            Size = WideCharToMultiByte(CodePage,
                                       dwFlags,
                                       lpWideCharStr,
                                       cchWideChar,
                                       (*MultiByteStr),
                                       Size,
                                       lpDefaultChar,
                                       lpUsedDefaultChar);
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Size == 0) {
        if (*MultiByteStr) {
            MIDL_user_free(*MultiByteStr);
            *MultiByteStr = NULL;
        }
        return STATUS_UNSUCCESSFUL;
    } else {

        // NULL terminate the string
        (*MultiByteStr)[Size] = '\0';
        return STATUS_SUCCESS;
    }
}

NTSTATUS
SampUnicodeToUTF8(
    IN WCHAR *UString,
    IN ULONG  StringCount,
    OUT LPSTR *UTF8String
    )
//
// This routines converts a UNICODE string to a UTF8 string
// There should be no loss in the conversion
//
{
    return SampWideCharToMultiByte(CP_UTF8,
                                   0,  // no flags,
                                   UString,
                                   StringCount,
                                   NULL,
                                   NULL,
                                   UTF8String);
}

LPSTR
SampGetPDCString(
    VOID
    )
/*++

Routine Description:

    This routine returns the UTF8 string DN of the domain PDC

Parameters:

    None.

Return Values:

    See description, NULL if the value can't be found         

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME *Fsmo;
    LPSTR FsmoString = NULL;
    ULONG Size;

    Status = SampDsReadSingleAttribute(ROOT_OBJECT,
                                       ATT_FSMO_ROLE_OWNER,
                                       (PVOID*)&Fsmo,
                                       &Size);

    if (NT_SUCCESS(Status)) {

        Status = SampUnicodeToUTF8(Fsmo->StringName,
                                   Fsmo->NameLen,
                                   &FsmoString);

        MIDL_user_free(Fsmo);
    }

    return FsmoString;
}

LPSTR
SampGetUserString(
    IN DSNAME *User                    
    )
/*++

Routine Description:

    This routine returns the UTF8 string DN of the object pointed to by User

Parameters:

    User -- DSNAME of an object in the DS

Return Values:

    See description, NULL if the value can't be found         

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DSNAME *UserDn;
    LPSTR  UserString = NULL;
    ULONG  Size;

    Status = SampDsReadSingleAttribute(User,
                                      ATT_OBJ_DIST_NAME,
                                      (PVOID*)&UserDn,
                                      &Size);

    if (NT_SUCCESS(Status)) {

        Status = SampUnicodeToUTF8(UserDn->StringName,
                                   UserDn->NameLen,
                                   &UserString);

        MIDL_user_free(UserDn);
    }

    return UserString;
}


BOOL
SampAvoidPdcOnWan(
    VOID
    )
//
// This routine returns the NETLOGON configuration setting
// for AvoidPdcOnWan
//
{
    DWORD err;
    HKEY  h;
    DWORD AvoidPdcOnWan = 0;
    DWORD Type;
    DWORD Size = sizeof(AvoidPdcOnWan);

    err = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                     "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                     &h);
    if (ERROR_SUCCESS == err) {
        err = RegQueryValueExA(h, 
                               "AvoidPdcOnWan", 
                               0, 
                               &Type, 
                               (BYTE*)&AvoidPdcOnWan, 
                               &Size);

        RegCloseKey(h);
    }

    return (AvoidPdcOnWan == 0) ? FALSE : TRUE;

}


NTSTATUS
SampInitLatencyCounter (
    PSAMP_LATENCY Info,
    ULONG         Id,
    ULONG         SlotCount
    )
/*++

Routine Description:

    This routine initalizes Info so that it can be used in 
    SampUpdateLatencyCounter.
    
Parameters:

    Info -- a structure to maintain latency information
    
    Id -- the perf counter id (from DSSTAT space)
    
    SlotCount -- the number of previous latencies that should be averaged

Return Values:

    Resource error, if any. 
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory(Info, sizeof(*Info));
    Info->Latencies = midl_user_allocate(sizeof(ULONG) * SlotCount);
    if (!Info->Latencies) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(Info->Latencies, sizeof(sizeof(ULONG) * SlotCount));

    _try {
        InitializeCriticalSection(&Info->Lock);
    } _except(1) {
        Status = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(Status)) {
        midl_user_free(Info->Latencies);
        Info->Latencies = NULL;
        return Status;
    }
    
    Info->cLatencies = SlotCount;
    Info->PerfCounterId = Id;

    return STATUS_SUCCESS;

}                           

VOID
SampUpdateLatencyCounter(
    PSAMP_LATENCY Info,
    ULONG         New
    )
/*++

Routine Description:

    This routine takes a newly reported latency (New), replaces the oldest
    oldest element in the list of latencies with this new value, recalculates
    the average and then updates the perf counter with the latest average.
    
    Note that this routine is called on performance critical paths, therefore
    the local is non blocking -- any thread that doesn't grab the lock doesn't
    register its latency.
    
    Another approach is to use the spin lock and wait. At this point, this
    appoach is not used.
    

Parameters:

    Info -- the latency information structure
    
    New -- the new latency to average in

Return Values:

    None. 
    
--*/
{
    DWORD Mean;

    if (!TryEnterCriticalSection(&Info->Lock)) {
        // already busy, don't block
        return;
    }

    //
    // Update the information in the structure
    //
    Info->Sum -= Info->Latencies[Info->iLatencies];
    Info->Sum += New;
    Info->Latencies[Info->iLatencies] = New;
    Mean = Info->Sum / Info->cLatencies;

    //
    // Adjust the window
    //
    if (Info->iLatencies == Info->cLatencies-1) {
        Info->iLatencies = 0;
    } else {
        Info->iLatencies++;
    }

    LeaveCriticalSection(&Info->Lock);

    //
    // Update the perf counter
    //
    SampUpdatePerformanceCounters(Info->PerfCounterId, 
                                  FLAG_COUNTER_SET,
                                  Mean);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\validate.c ===
#include "samsrvp.h"
#include "validate.h"
#include <ntrtl.h>

#define RAISE_ERROR __leave

#define NULL_CHECK( Data )  \
    if( ( Data ) == NULL )  \
        goto Error

#define MAXIMUM_LENGTH_CHECK( Data )                    \
    if( ( Data )->MaximumLength < ( Data )->Length )    \
        RAISE_ERROR

#define EVEN_SIZE_CHECK( Data ) \
    if( ( Data ) % 2 != 0 )     \
        RAISE_ERROR

#define LENGTH_BUFFER_CONSISTENCY_CHECK( Length, Buffer )   \
    if( ( ( Length ) == 0 && ( Buffer ) != NULL ) ||        \
        ( ( Length ) != 0 && ( Buffer ) == NULL ) )         \
        RAISE_ERROR

#define BEGIN_FUNCTION( Parameter ) \
    BOOLEAN Result = FALSE;         \
    NULL_CHECK( Parameter );        \
    __try {

#define END_FUNCTION                                                        \
        Result = TRUE;                                                      \
    } __except( EXCEPTION_EXECUTE_HANDLER ){                                \
                                                                            \
    }                                                                       \
Error:                                                                      \
    return Result;

BOOLEAN
SampValidateRpcUnicodeString(
    IN PRPC_UNICODE_STRING UnicodeString
    )
{
    BEGIN_FUNCTION( UnicodeString )

        MAXIMUM_LENGTH_CHECK( UnicodeString );

        EVEN_SIZE_CHECK( UnicodeString->MaximumLength );

        EVEN_SIZE_CHECK( UnicodeString->Length );

        LENGTH_BUFFER_CONSISTENCY_CHECK( UnicodeString->MaximumLength, UnicodeString->Buffer );

    END_FUNCTION
}

BOOLEAN
SampValidateRpcString(
    IN PRPC_STRING String
    )
{
    BEGIN_FUNCTION( String )

        MAXIMUM_LENGTH_CHECK( String );

        LENGTH_BUFFER_CONSISTENCY_CHECK( String->MaximumLength, String->Buffer );

    END_FUNCTION
}

BOOLEAN
SampValidateRpcSID(
    IN PRPC_SID SID
    )
{
    BEGIN_FUNCTION( SID )

        if( !RtlValidSid( SID ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateRidEnumeration(
    IN PSAMPR_RID_ENUMERATION RidEnum
    )
{
    BEGIN_FUNCTION( RidEnum )

        if( !SampValidateRpcUnicodeString( &( RidEnum->Name ) ) )
            RA